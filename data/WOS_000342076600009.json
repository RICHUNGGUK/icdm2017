{"auto_keywords": [{"score": 0.04917227522621455, "phrase": "k-core_decomposition"}, {"score": 0.046036954523069426, "phrase": "core_number"}, {"score": 0.009183637990817109, "phrase": "static_graph"}, {"score": 0.009010424959745397, "phrase": "linear_time_algorithm"}, {"score": 0.007915460107551368, "phrase": "core_numbers"}, {"score": 0.00481495049065317, "phrase": "efficient_core_maintenance"}, {"score": 0.004778258911940497, "phrase": "large_dynamic_graphs"}, {"score": 0.004616560363089716, "phrase": "fundamental_problem"}, {"score": 0.004581373625744533, "phrase": "social_network_analysis"}, {"score": 0.004276468590041119, "phrase": "previous_studies"}, {"score": 0.0038862297330905836, "phrase": "online_social_networks"}, {"score": 0.0036553070575015344, "phrase": "key_issue"}, {"score": 0.003438058620195309, "phrase": "simple_implementation"}, {"score": 0.0029951555610569225, "phrase": "new_efficient_algorithm"}, {"score": 0.00288255520607591, "phrase": "dynamic_graph"}, {"score": 0.0026393362602995254, "phrase": "efficient_algorithm"}, {"score": 0.0024633601573822114, "phrase": "graph_size"}, {"score": 0.0023079225317714815, "phrase": "lower_and_upper_bounds"}, {"score": 0.0022296340517805125, "phrase": "extensive_experiments"}, {"score": 0.0021872912745910127, "phrase": "synthetic_datasets"}, {"score": 0.0021049977753042253, "phrase": "proposed_algorithm"}], "paper_keywords": ["Core maintenance", " k-core decomposition", " dynamic graphs"], "paper_abstract": "The k-core decomposition in a graph is a fundamental problem for social network analysis. The problem of k-core decomposition is to calculate the core number for every node in a graph. Previous studies mainly focus on k-core decomposition in a static graph. There exists a linear time algorithm for k-core decomposition in a static graph. However, in many real-world applications such as online social networks and the Internet, the graph typically evolves over time. In such applications, a key issue is to maintain the core numbers of nodes when the graph changes over time. A simple implementation is to perform the linear time algorithm to recompute the core number for every node after the graph is updated. Such simple implementation is expensive when the graph is very large. In this paper, we propose a new efficient algorithm to maintain the core number for every node in a dynamic graph. Our main result is that only certain nodes need to update their core numbers when the graph is changed by inserting/deleting an edge. We devise an efficient algorithm to identify and recompute the core numbers of such nodes. The complexity of our algorithm is independent of the graph size. In addition, to further accelerate the algorithm, we develop two pruning strategies by exploiting the lower and upper bounds of the core number. Finally, we conduct extensive experiments over both real-world and synthetic datasets, and the results demonstrate the efficiency of the proposed algorithm.", "paper_title": "Efficient Core Maintenance in Large Dynamic Graphs", "paper_id": "WOS:000342076600009"}