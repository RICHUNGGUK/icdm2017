{"auto_keywords": [{"score": 0.03551331429009871, "phrase": "gcs"}, {"score": 0.00481495049065317, "phrase": "gap-order_constraint_abstractions"}, {"score": 0.004723921546336048, "phrase": "verification_problems"}, {"score": 0.004698229304089357, "phrase": "gap-order_constraint_systems"}, {"score": 0.00441257945244739, "phrase": "source_state"}, {"score": 0.0043766186644841575, "phrase": "target_state"}, {"score": 0.004317331276979733, "phrase": "gap-order_constraints"}, {"score": 0.0042011448918579065, "phrase": "monotonicity_constraint_systems"}, {"score": 0.0040880724328903, "phrase": "constraint_automata"}, {"score": 0.003956379470617348, "phrase": "fairness_analysis"}, {"score": 0.0038080694145564836, "phrase": "strong_termination"}, {"score": 0.003736004578001584, "phrase": "upper_bound"}, {"score": 0.0035861227263414537, "phrase": "termination_problem"}, {"score": 0.0034990853199511982, "phrase": "fairness_problem"}, {"score": 0.003386301445203071, "phrase": "infinite_runs"}, {"score": 0.003349517793727593, "phrase": "acceptance_conditions"}, {"score": 0.003331275574328097, "phrase": "la_buchi"}, {"score": 0.003215091066260523, "phrase": "control_location"}, {"score": 0.0031370304755352486, "phrase": "gc_representation"}, {"score": 0.0030944828434567966, "phrase": "counter_variable_valuations"}, {"score": 0.0027970073862382113, "phrase": "constrained_branching-time_logic"}, {"score": 0.0027144995764488583, "phrase": "gc"}, {"score": 0.002684694915895104, "phrase": "expressive_properties"}, {"score": 0.002534974041090166, "phrase": "universal_fragment"}, {"score": 0.0024531892728645983, "phrase": "existential_fragment"}, {"score": 0.0022172248392349054, "phrase": "known_verification_problems"}, {"score": 0.0021398115287338693, "phrase": "elementary_upper_bounds"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Abstractions of counter systems", " Temporal logics with Presburger constraints", " Model checking", " Verification of infinite-state systems", " Complexity and decidability issues"], "paper_abstract": "We investigate verification problems for gap-order constraint systems (GCS), an (infinitely-branching) abstract model of counter machines, in which constraints (over Z) between the variables of the source state and the target state of a transition are gap-order constraints (GC) [32]. GCS extend monotonicity constraint systems [7], integral relation automata [16], and constraint automata in [19]. First, we address termination and fairness analysis of GCS. Since GCS are infinitely-branching, termination does not imply strong termination, i.e. the existence of an upper bound on the lengths of the runs from a given state. We show that the termination problem, the strong termination problem, and the fairness problem for GCS (the latter consisting in checking the existence of infinite runs in GCS satisfying acceptance conditions a la Buchi) are decidable and PsPAcE-complete. Moreover, for each control location of the given GCS, one can build a GC representation of the set of counter variable valuations from which termination (resp., strong termination, resp., fairness) does not hold (resp., does not hold, resp., does hold). Next, we consider a constrained branching-time logic, GCCTL*, obtained by enriching CTL* with GC, thus enabling expressive properties and subsuming the setting of [16]. We establish that, while model-checking GCS against the universal fragment of GCCTL* is undecidable, model-checking against the existential fragment, and satisfiability of both the universal and existential fragments are instead decidable and PsPAcE-complete (note that the two fragments are not dual since GC are not closed under negation). Moreover, our results imply PspAcE-completeness of known verification problems that were shown to be decidable in [16] with no elementary upper bounds. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Verification of gap-order constraint abstractions of counter systems", "paper_id": "WOS:000331666200001"}