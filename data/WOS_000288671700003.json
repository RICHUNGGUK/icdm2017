{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "counter_automata"}, {"score": 0.011255936091360608, "phrase": "original_programs"}, {"score": 0.004597754207658615, "phrase": "one-selector_linked_data_structures"}, {"score": 0.004309968592440261, "phrase": "accurate_abstract_model"}, {"score": 0.004172874316207784, "phrase": "control_states"}, {"score": 0.004058826900076531, "phrase": "abstract_heap_graphs"}, {"score": 0.0040215052006051235, "phrase": "list_segments"}, {"score": 0.003616108223034427, "phrase": "significant_theoretical_result"}, {"score": 0.003517223847512266, "phrase": "obtained_counter_automata"}, {"score": 0.0033428820402140683, "phrase": "practical_point"}, {"score": 0.0032066653632708965, "phrase": "efficient_automatic_analysis_techniques"}, {"score": 0.002896535621940078, "phrase": "list-manipulating_programs"}, {"score": 0.002843450389745497, "phrase": "theoretical_contribution"}, {"score": 0.002714943351733626, "phrase": "generated_counter_automata"}, {"score": 0.0026651772919894534, "phrase": "nested_loops"}, {"score": 0.0022772782536385717, "phrase": "ordered_data"}, {"score": 0.002164264600379492, "phrase": "automatically_safety"}], "paper_keywords": ["Formal verification", " Programs with singly-linked lists", " Safety and termination", " Counter automata", " Bisimulation", " Lists with ordered data"], "paper_abstract": "We address the problem of verifying programs manipulating one-selector linked data structures. We propose and study in detail an application of counter automata as an accurate abstract model for this problem. We let control states of the counter automata correspond to abstract heap graphs where list segments without sharing are collapsed, and use counters to keep track of the number of elements in these segments. As a significant theoretical result, we show that the obtained counter automata are bisimilar to the original programs. Moreover, from a practical point of view, our translation allows one to apply efficient automatic analysis techniques and tools developed for counter automata (integer programs) in order to verify both safety as well as termination of list-manipulating programs. As another theoretical contribution, we prove that if the control of the generated counter automata does not contain nested loops (i.e., these automata are flat), both safety and termination are decidable for the original programs. Subsequently, we generalise our counter-automata-based model to keep track of ordering properties over lists storing ordered data. Finally, we show effectiveness of our approach by verifying automatically safety as well as termination of several sorting programs.", "paper_title": "Programs with lists are counter automata", "paper_id": "WOS:000288671700003"}