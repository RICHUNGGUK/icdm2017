{"auto_keywords": [{"score": 0.03737634241271663, "phrase": "multicore_cpus"}, {"score": 0.00481495049065317, "phrase": "enhancing_design_space_exploration"}, {"score": 0.00469678464293492, "phrase": "design_cycle"}, {"score": 0.0046676969718111765, "phrase": "complex_special-purpose_computing_systems"}, {"score": 0.0044968982227349625, "phrase": "multiparametric_design_space_exploration"}, {"score": 0.004413846562278824, "phrase": "design_verification"}, {"score": 0.004359328949187473, "phrase": "special_purpose"}, {"score": 0.004345804626592329, "phrase": "vlsi_implementations"}, {"score": 0.004225950334493496, "phrase": "optimal_bitwidth"}, {"score": 0.004199766284749713, "phrase": "data_representation"}, {"score": 0.004160792819919432, "phrase": "time-consuming_monte_carlo_simulations"}, {"score": 0.004071249707923223, "phrase": "simulation-based_exploration_process"}, {"score": 0.0038978806337961565, "phrase": "low-density_parity-check"}, {"score": 0.0038139739023433958, "phrase": "modern_communication_standards"}, {"score": 0.003743487506598038, "phrase": "monte_carlo"}, {"score": 0.0036972190829870906, "phrase": "design_point"}, {"score": 0.00365152042769837, "phrase": "high-performance_computing"}, {"score": 0.003617616153730564, "phrase": "wide_set"}, {"score": 0.0035951877427580006, "phrase": "acceleration_options"}, {"score": 0.003528730431045574, "phrase": "graphics_processing_units"}, {"score": 0.0034742854447532678, "phrase": "field_programmable_gate_arrays"}, {"score": 0.003388909415044492, "phrase": "diverse_target_architectures"}, {"score": 0.0033262524445013303, "phrase": "multiple_code_versions"}, {"score": 0.0032851239209372943, "phrase": "distinct_programming_paradigms"}, {"score": 0.0031549249117721946, "phrase": "single_opencl_program"}, {"score": 0.003135356056324338, "phrase": "multiple_platforms"}, {"score": 0.003086961663712383, "phrase": "design_time"}, {"score": 0.0030582832134483685, "phrase": "single_opencl-based_parallel_kernel"}, {"score": 0.0030017207229983385, "phrase": "code_tuning"}, {"score": 0.0027943943921568456, "phrase": "opencl_kernels"}, {"score": 0.002708766459414734, "phrase": "potential_platform"}, {"score": 0.002650396278002678, "phrase": "opencl."}, {"score": 0.0026257554931689076, "phrase": "ldpc_decoding_simulations"}, {"score": 0.0026013505538490223, "phrase": "case_study"}, {"score": 0.002585206414738808, "phrase": "experimental_results"}, {"score": 0.002521623057264411, "phrase": "regular_and_irregular_ldpc_codes"}, {"score": 0.002429161048032688, "phrase": "long_length"}, {"score": 0.0022967713922705, "phrase": "design_parameters"}, {"score": 0.0021921302408803387, "phrase": "gpu"}, {"score": 0.0021784222586287713, "phrase": "fpga"}, {"score": 0.0021580985506699105, "phrase": "different_purposes"}, {"score": 0.002118149468085762, "phrase": "different_acceleration_factors"}, {"score": 0.0021049977753042253, "phrase": "conventional_multicore_cpus"}], "paper_keywords": ["Design", " Algorithms", " Performance", " Design space exploration", " simulation tools", " parallel computing", " FPGAs", " GPUs", " OpenCL"], "paper_abstract": "The design cycle for complex special-purpose computing systems is extremely costly and time-consuming. It involves a multiparametric design space exploration for optimization, followed by design verification. Designers of special purpose VLSI implementations often need to explore parameters, such as optimal bitwidth and data representation, through time-consuming Monte Carlo simulations. A prominent example of this simulation-based exploration process is the design of decoders for error correcting systems, such as the Low-Density Parity-Check (LDPC) codes adopted by modern communication standards, which involves thousands of Monte Carlo runs for each design point. Currently, high-performance computing offers a wide set of acceleration options that range from multicore CPUs to Graphics Processing Units (GPUs) and Field Programmable Gate Arrays (FPGAs). The exploitation of diverse target architectures is typically associated with developing multiple code versions, often using distinct programming paradigms. In this context, we evaluate the concept of retargeting a single OpenCL program to multiple platforms, thereby significantly reducing design time. A single OpenCL-based parallel kernel is used without modifications or code tuning on multicore CPUs, GPUs, and FPGAs. We use SOpenCL (Silicon to OpenCL), a tool that automatically converts OpenCL kernels to RTL in order to introduce FPGAs as a potential platform to efficiently execute simulations coded in OpenCL. We use LDPC decoding simulations as a case study. Experimental results were obtained by testing a variety of regular and irregular LDPC codes that range from short/medium (e.g., 8,000 bit) to long length (e.g., 64,800 bit) DVB-S2 codes. We observe that, depending on the design parameters to be simulated, on the dimension and phase of the design, the GPU or FPGA may suit different purposes more conveniently, thus providing different acceleration factors over conventional multicore CPUs.", "paper_title": "Enhancing Design Space Exploration by Extending CPU/GPU Specifications onto FPGAs", "paper_id": "WOS:000352224800014"}