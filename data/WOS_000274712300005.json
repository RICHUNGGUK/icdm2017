{"auto_keywords": [{"score": 0.031215858888706115, "phrase": "cknn_queries"}, {"score": 0.03099923609891841, "phrase": "hccknn_queries"}, {"score": 0.00481495049065317, "phrase": "constrained_k-nearest_neighbor_queries"}, {"score": 0.004695900553353526, "phrase": "important_query"}, {"score": 0.004662427600500598, "phrase": "spatio-temporal_databases"}, {"score": 0.004596192494271827, "phrase": "nearest_trajectories"}, {"score": 0.004563427013973105, "phrase": "moving_objects"}, {"score": 0.004530894050040479, "phrase": "existing_work"}, {"score": 0.00441883624011048, "phrase": "closest_trajectories"}, {"score": 0.004371660146981191, "phrase": "whole_data_space"}, {"score": 0.004217998654053147, "phrase": "constrained_k-nearest_neighbor"}, {"score": 0.004011867299107537, "phrase": "r-tree-like_structures"}, {"score": 0.003926626018798576, "phrase": "object_trajectories"}, {"score": 0.0038708031633013086, "phrase": "trajectory_set_d"}, {"score": 0.003829455440282146, "phrase": "query_object"}, {"score": 0.0036815763368083197, "phrase": "constrained_region_cr"}, {"score": 0.003464150192089816, "phrase": "thousand_yen"}, {"score": 0.003167441161387607, "phrase": "constrained_k_nearest_neighbors"}, {"score": 0.0028857130140890787, "phrase": "different_properties"}, {"score": 0.002610198789888055, "phrase": "stationary_query_points"}, {"score": 0.0025822818714499795, "phrase": "query_trajectories"}, {"score": 0.0024122616475793206, "phrase": "continuous_counterparts"}, {"score": 0.0023024126375034066, "phrase": "existing_data-partitioning_index"}, {"score": 0.002181851408180827, "phrase": "cpu_cost"}, {"score": 0.0021662599012740127, "phrase": "extensive_experiments"}, {"score": 0.0021049977753042253, "phrase": "proposed_algorithms"}], "paper_keywords": ["Query processing", " Nearest neighbor", " Moving object trajectory", " Algorithm"], "paper_abstract": "An important query for spatio-temporal databases is to find nearest trajectories of moving objects. Existing work on this topic focuses on the closest trajectories in the whole data space. In this paper, we introduce and solve constrained k-nearest neighbor (CkNN) queries and historical continuous CkNN (HCCkNN) queries on R-tree-like structures storing historical information about moving object trajectories. Given a trajectory set D, a query object (point or trajectory) q, a temporal extent T, and a constrained region CR, (i) a CkNN query over trajectories retrieves from D within T, the k (a parts per thousand yen 1) trajectories that lie closest to q and intersect (or are enclosed by) CR; and (ii) an HCCkNN query on trajectories retrieves the constrained k nearest neighbors (CkNNs) of q at any time instance of T. We propose a suite of algorithms for processing CkNN queries and HCCkNN queries respectively, with different properties and advantages. In particular, we thoroughly investigate two types of CkNN queries, i.e., CkNN(P) and CkNN(T), which are defined with respect to stationary query points and moving query trajectories, respectively; and two types of HCCkNN queries, namely, HCCkNN(P) and HCCkNN(T), which are continuous counterparts of CkNN(P) and CkNN(T), respectively. Our methods utilize an existing data-partitioning index for trajectory data (i.e., TB-tree) to achieve low I/O and CPU cost. Extensive experiments with both real and synthetic datasets demonstrate the performance of the proposed algorithms in terms of efficiency and scalability.", "paper_title": "Algorithms for constrained k-nearest neighbor queries over moving object trajectories", "paper_id": "WOS:000274712300005"}