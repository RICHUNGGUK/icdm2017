{"auto_keywords": [{"score": 0.014129323549701497, "phrase": "multi-core_cpus"}, {"score": 0.014029123586988284, "phrase": "many-core_gpus"}, {"score": 0.011491266393563591, "phrase": "optimal_configurations"}, {"score": 0.00481495049065317, "phrase": "computing_industry_trend"}, {"score": 0.00476334344613564, "phrase": "processing_capacity"}, {"score": 0.004449045430179066, "phrase": "staple_visualization_algorithm"}, {"score": 0.004401342842183475, "phrase": "volume_rendering"}, {"score": 0.004354149483556514, "phrase": "shared-memory_parallelism"}, {"score": 0.004185377431624781, "phrase": "tunable_algorithmic_settings"}, {"score": 0.004125634486868786, "phrase": "known_algorithmic_optimizations"}, {"score": 0.004052148727852149, "phrase": "measure_performance"}, {"score": 0.0039942998891989955, "phrase": "absolute_runtime"}, {"score": 0.003853251284913932, "phrase": "wide_variation"}, {"score": 0.0038256426589560774, "phrase": "runtime_performance"}, {"score": 0.0036640806940633373, "phrase": "tunable_parameters"}, {"score": 0.0034097787109430384, "phrase": "non-obvious_way"}, {"score": 0.003277615889580514, "phrase": "gpu"}, {"score": 0.003230665474330377, "phrase": "crossover_point"}, {"score": 0.0031730701021262155, "phrase": "good_cache_utilization"}, {"score": 0.0031164983132321417, "phrase": "computational_throughput"}, {"score": 0.002963390095037466, "phrase": "empirical_performance_model"}, {"score": 0.002931569771634119, "phrase": "particular_algorithm"}, {"score": 0.0028792911886505526, "phrase": "unstructured_memory_access_pattern"}, {"score": 0.0028279422436488116, "phrase": "individual_rays"}, {"score": 0.0027775064989253575, "phrase": "selected_viewpoint"}, {"score": 0.0027181663098561066, "phrase": "optimal_parameters"}, {"score": 0.0026986685585382347, "phrase": "modern_architectures"}, {"score": 0.0026315183701883437, "phrase": "previous_studies"}, {"score": 0.0026032523182547003, "phrase": "older_architectures"}, {"score": 0.002538470301402269, "phrase": "dramatic_performance_variation"}, {"score": 0.002493184318829227, "phrase": "optimal_algorithm_settings"}, {"score": 0.00247529638625566, "phrase": "performance_results"}, {"score": 0.0024311346712789553, "phrase": "clear_benefit"}, {"score": 0.0024136908511423875, "phrase": "production_visualization"}, {"score": 0.002396371892825691, "phrase": "analysis_codes"}, {"score": 0.0021049977753042253, "phrase": "memory_hierarchy"}], "paper_keywords": ["parallel volume rendering", " performance optimization", " auto-tuning", " multi-core CPU", " many-core GPU"], "paper_abstract": "Given the computing industry trend of increasing processing capacity by adding more cores to a chip, the focus of this work is tuning the performance of a staple visualization algorithm, raycasting volume rendering, for shared-memory parallelism on multi-core CPUs and many-core GPUs. Our approach is to vary tunable algorithmic settings, along with known algorithmic optimizations and two different memory layouts, and measure performance in terms of absolute runtime and L2 memory cache misses. Our results indicate there is a wide variation in runtime performance on all platforms, as much as 254% for the tunable parameters we test on multi-core CPUs and 265% on many-core GPUs, and the optimal configurations vary across platforms, often in a non-obvious way. For example, our results indicate the optimal configurations on the GPU occur at a crossover point between those that maintain good cache utilization and those that saturate computational throughput. This result is likely to be extremely difficult to predict with an empirical performance model for this particular algorithm because it has an unstructured memory access pattern that varies locally for individual rays and globally for the selected viewpoint. Our results also show that optimal parameters on modern architectures are markedly different from those in previous studies run on older architectures. In addition, given the dramatic performance variation across platforms for both optimal algorithm settings and performance results, there is a clear benefit for production visualization and analysis codes to adopt a strategy for performance optimization through auto-tuning. These benefits will likely become more pronounced in the future as the number of cores per chip and the cost of moving data through the memory hierarchy both increase.", "paper_title": "Multi-core and many-core shared-memory parallel raycasting volume rendering optimization and tuning", "paper_id": "WOS:000310796300008"}