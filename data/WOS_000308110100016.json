{"auto_keywords": [{"score": 0.04605004565343482, "phrase": "programming_models"}, {"score": 0.011140240764861557, "phrase": "two-level_network"}, {"score": 0.00481495049065317, "phrase": "gpu_programming_models"}, {"score": 0.004750440867604888, "phrase": "neural_networks"}, {"score": 0.004686791459644141, "phrase": "general_purpose_graphical_processing_units"}, {"score": 0.004655286471353965, "phrase": "gp-gpus"}, {"score": 0.004546666837896004, "phrase": "intriguing_technology"}, {"score": 0.004500891637057374, "phrase": "numerous_data-parallel_algorithms"}, {"score": 0.004455744669439372, "phrase": "gpu"}, {"score": 0.0038930368103015467, "phrase": "compute_unified_device_architecture"}, {"score": 0.003866882415081192, "phrase": "cuda"}, {"score": 0.0038278890186559276, "phrase": "open_computing_language"}, {"score": 0.0036511960413423542, "phrase": "direct_bearing"}, {"score": 0.0036144035798673967, "phrase": "application_runtime_performance"}, {"score": 0.0034359094594153304, "phrase": "two-level_character_recognition_network"}, {"score": 0.0032442139425705578, "phrase": "computation-to-communication_requirements"}, {"score": 0.0030943793545344495, "phrase": "snn_models"}, {"score": 0.003042555825368091, "phrase": "aforementioned_two-level_network"}, {"score": 0.0030118779844670353, "phrase": "architectural_performance_comparison"}, {"score": 0.0029815085406590426, "phrase": "snn_application"}, {"score": 0.002951444412262927, "phrase": "nvidia's_fermi"}, {"score": 0.0028630535573013686, "phrase": "opencl_programming_model"}, {"score": 0.002815093247670994, "phrase": "optimization_strategies"}, {"score": 0.002631131751548729, "phrase": "fermi_architecture"}, {"score": 0.0025180372061991206, "phrase": "optimization_techniques"}, {"score": 0.0024097920845706795, "phrase": "different_levels"}, {"score": 0.0023296961971785357, "phrase": "network_size"}, {"score": 0.0022446552199168472, "phrase": "significant_application_speed-up"}, {"score": 0.002126458181856629, "phrase": "serial_implementation"}], "paper_keywords": ["CUDA", " OpenCL", " Fermi", " Radeon", " Spiking neural network", " Programming models", " Architectures", " Speed-up", " Profiler counters"], "paper_abstract": "Recently, General Purpose Graphical Processing Units (GP-GPUs) have been identified as an intriguing technology to accelerate numerous data-parallel algorithms. Several GPU architectures and programming models are beginning to emerge and establish their niche in the High-Performance Computing (HPC) community. New massively parallel architectures such as the Nvidia's Fermi and AMD/ATi's Radeon pack tremendous computing power in their large number of multiprocessors. Their performance is unleashed using one of the two GP-GPU programming models: Compute Unified Device Architecture (CUDA) and Open Computing Language (OpenCL). Both of them offer constructs and features that have direct bearing on the application runtime performance. In this paper, we compare the two GP-GPU architectures and the two programming models using a two-level character recognition network. The two-level network is developed using four different Spiking Neural Network (SNN) models, each with different ratios of computation-to-communication requirements. To compare the architectures, we have chosen the two extremes of the SNN models for implementation of the aforementioned two-level network. An architectural performance comparison of the SNN application running on Nvidia's Fermi and AMD/ATi's Radeon is done using the OpenCL programming model exhausting all of the optimization strategies plausible for the two architectures. To compare the programming models, we implement the two-level network on Nvidia's Tesla C2050 based on the Fermi architecture. We present a hierarchy of implementations, where we successively add optimization techniques associated with the two programming models. We then compare the two programming models at these different levels of implementation and also present the effect of the network size (problem size) on the performance. We report significant application speed-up, as high as 1095x for the most computation intensive SNN neuron model, against a serial implementation on the Intel Core 2 Quad host. A comprehensive study presented in this paper establishes connections between programming models, architectures and applications.", "paper_title": "A comparative study of GPU programming models and architectures using neural networks", "paper_id": "WOS:000308110100016"}