{"auto_keywords": [{"score": 0.03891934872280938, "phrase": "programming_laws"}, {"score": 0.00481495049065317, "phrase": "object-oriented_program"}, {"score": 0.004355026964936104, "phrase": "transformation_rules"}, {"score": 0.00415777266387528, "phrase": "refinement_language"}, {"score": 0.004062731838284054, "phrase": "java"}, {"score": 0.0039085400187964196, "phrase": "object-oriented_programs"}, {"score": 0.003562322256892338, "phrase": "imperative_constructs"}, {"score": 0.0030994630902300133, "phrase": "weakest_precondition_semantics"}, {"score": 0.0029589086332593674, "phrase": "refactoring_rules"}, {"score": 0.002205079358459154, "phrase": "design_pattern"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Refactoring", " Formal methods", " Refinement calculus", " Object-oriented programming"], "paper_abstract": "Refactoring consists in restructuring an object-oriented program without changing its behaviour. In this paper, we present refactorings as transformation rules for programs written in a refinement language inspired on Java that allows reasoning about object-oriented programs and specifications. A set of programming laws is available for the imperative constructs of this language as well as for its object-oriented features; soundness of the laws is proved against a weakest precondition semantics, The proof that the refactoring rules preserve behaviour (semantics) is accomplished by the application of these programming laws and data simulation. As illustration of our approach to refactoring, we use our rules to restructure a program to be in accordance with a design pattern. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Sound refactorings", "paper_id": "WOS:000274977800002"}