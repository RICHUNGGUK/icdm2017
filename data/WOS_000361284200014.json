{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "compiler_scalability"}, {"score": 0.044728827124546816, "phrase": "polyhedral_compilers"}, {"score": 0.0047650691627251825, "phrase": "large_programs"}, {"score": 0.004732100994830163, "phrase": "small_price"}, {"score": 0.00465067040500426, "phrase": "well_known_problem"}, {"score": 0.004539005582217309, "phrase": "useful_optimizations"}, {"score": 0.004507594400447103, "phrase": "large_program_scopes"}, {"score": 0.004234456398783788, "phrase": "powerful_yet_costly_integer_programming_algorithms"}, {"score": 0.0040334640350288, "phrase": "polyhedral_compiler"}, {"score": 0.003922907208353323, "phrase": "real_scientific_applications"}, {"score": 0.003855347387268162, "phrase": "loop_nests"}, {"score": 0.003775803846431323, "phrase": "common_users"}, {"score": 0.0036595438031512217, "phrase": "scalability_problem"}, {"score": 0.0034736499231079083, "phrase": "large_number"}, {"score": 0.003390149669470349, "phrase": "program_scope"}, {"score": 0.0033317342432676385, "phrase": "one-shot_solution"}, {"score": 0.0032516342542969387, "phrase": "effective_number"}, {"score": 0.002980916123365584, "phrase": "single_super-statement"}, {"score": 0.0028991255455294565, "phrase": "minimum_sufficient_constraints"}, {"score": 0.002869034325496957, "phrase": "integer_linear_programming"}, {"score": 0.0028000270988465486, "phrase": "correct_optimizations"}, {"score": 0.0027326751144684386, "phrase": "pluto_polyhedral_compiler"}, {"score": 0.00266693888510356, "phrase": "program_statements"}, {"score": 0.002648448458159033, "phrase": "program_dependences"}, {"score": 0.0023776656246300063, "phrase": "memory_requirement"}, {"score": 0.002280423827531483, "phrase": "latest_version"}, {"score": 0.0022567398334877847, "phrase": "pluto_compiler"}, {"score": 0.002233301265743633, "phrase": "final_compile_times"}, {"score": 0.0021947755130109696, "phrase": "intel_compiler"}, {"score": 0.0021049977753042253, "phrase": "latter's_conservative_approach"}], "paper_keywords": ["Compiler scalability", " optimization", " polyhedral model", " statement condensation", " O-molecule"], "paper_abstract": "Compiler scalability is a well known problem: reasoning about the application of useful optimizations over large program scopes consumes too much time and memory during compilation. This problem is exacerbated in polyhedral compilers that use powerful yet costly integer programming algorithms to compose loop optimizations. As a result, the benefits that a polyhedral compiler has to offer to programs such as real scientific applications that contain sequences of loop nests, remain impractical for the common users. In this work, we address this scalability problem in polyhedral compilers. We identify three causes of unscalability, each of which stems from large number of statements and dependences in the program scope. We propose a one-shot solution to the problem by reducing the effective number of statements and dependences as seen by the compiler. We achieve this by representing a sequence of statements in a program by a single super-statement. This set of super-statements exposes the minimum sufficient constraints to the Integer Linear Programming (ILP) solver for finding correct optimizations. We implement our approach in the PLuTo polyhedral compiler and find that it condenses the program statements and program dependences by factors of 4.7x and 6.4x, respectively, averaged over 9 hot regions (ranging from 48 to 121 statements) in 5 real applications. As a result, the improvements in time and memory requirement for compilation are 268x and 20x, respectively, over the latest version of the PLuTo compiler. The final compile times are comparable to the Intel compiler while the performance is 1.92x better on average due to the latter's conservative approach to loop optimization.", "paper_title": "Improving Compiler Scalability: Optimizing Large Programs at Small Price", "paper_id": "WOS:000361284200014"}