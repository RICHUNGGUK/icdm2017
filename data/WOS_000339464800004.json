{"auto_keywords": [{"score": 0.049424447069121406, "phrase": "fft_processor"}, {"score": 0.011589620705650916, "phrase": "proposed_flow"}, {"score": 0.00481495049065317, "phrase": "fixed_wordlength_fft_processors"}, {"score": 0.004641351004344458, "phrase": "core_components"}, {"score": 0.004598933498016774, "phrase": "numerous_dsp-based_systems"}, {"score": 0.004515342865886609, "phrase": "ofdm"}, {"score": 0.004473982381245469, "phrase": "modem_wireless_communication"}, {"score": 0.004332471656145115, "phrase": "key_parameters"}, {"score": 0.004157058883925715, "phrase": "number_format"}, {"score": 0.0038624981944755813, "phrase": "optimization_flow"}, {"score": 0.0037921662574137535, "phrase": "fixed-point_numeric_values"}, {"score": 0.0036385507376985047, "phrase": "sqnr"}, {"score": 0.0035887342563437935, "phrase": "fixed_wordlength_constraint"}, {"score": 0.0035072146967082083, "phrase": "probability_distribution"}, {"score": 0.0034433297275344877, "phrase": "probabilistic_behavior"}, {"score": 0.0033961782274326948, "phrase": "output_signal"}, {"score": 0.0033037970113095577, "phrase": "computation_errors"}, {"score": 0.003126481516783286, "phrase": "scaling_decisions"}, {"score": 0.0030135741897058844, "phrase": "time-consuming_simulation"}, {"score": 0.002799810685137358, "phrase": "overall_output"}, {"score": 0.002786964045867666, "phrase": "sqnr._besides"}, {"score": 0.002661731266481372, "phrase": "fft"}, {"score": 0.0025420267431501367, "phrase": "experimental_results"}, {"score": 0.0022347698358650514, "phrase": "comparable_output_quality"}, {"score": 0.002163930783583212, "phrase": "extra_dynamic_number"}, {"score": 0.0021049977753042253, "phrase": "significantly_more_hardware_logic"}], "paper_keywords": ["FFT", " number scaling", " fixed wordlength", " signal-to-quantization noise ratio (SQNR)", " accuracy", " precision"], "paper_abstract": "The FFT processor serves as one of core components in numerous DSP-based systems, such as OFDM in modem wireless communication. While creating an FFT processor, key parameters, such as architecture, wordlength, and number format, must be all considered very carefully. In this paper, we propose an optimization flow that properly scales fixed-point numeric values at each butterfly stage to maximize the output SQNR under a fixed wordlength constraint. The proposed flow utilizes probability distribution to model the probabilistic behavior of the output signal at each stage. The computation errors due to quantization and saturation operations are statically analyzed before making scaling decisions. Therefore, without a need of time-consuming simulation, our method can efficiently determine the most appropriate number format for each stage and thus optimize the overall output SQNR. Besides, the proposed flow is capable of handling various FFT sizes, FFT algorithms, wordlengths, and input signal distributions. Experimental results indicate that the wordlength can be reduced about three bits for an 8K-point radix-2 memory-based FFT processor without compromise in the output SQNR. Furthermore, the FFT processor created using our static scaling optimization technique can produce a comparable output quality as the one equipped with an extra dynamic number scaling unit, which requires significantly more hardware logic.", "paper_title": "Probability-Based Static Scaling Optimization for Fixed Wordlength FFT Processors", "paper_id": "WOS:000339464800004"}