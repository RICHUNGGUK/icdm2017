{"auto_keywords": [{"score": 0.047002907981885236, "phrase": "atomic_updates"}, {"score": 0.036408538379468225, "phrase": "shared_memory"}, {"score": 0.029714393707618907, "phrase": "bank_conflicts"}, {"score": 0.00481495049065317, "phrase": "atomic_additions"}, {"score": 0.004766090327062509, "phrase": "gpu_scratchpad_memory"}, {"score": 0.004717723626157272, "phrase": "gpu_application_implementations"}, {"score": 0.004669845451682529, "phrase": "scatter_approaches"}, {"score": 0.00457553517865013, "phrase": "write_contention"}, {"score": 0.004460309246062286, "phrase": "output_elements"}, {"score": 0.0042819270655224916, "phrase": "colliding_threads"}, {"score": 0.003966388754366831, "phrase": "proper_understanding"}, {"score": 0.0037498152007206815, "phrase": "conflicting_accesses"}, {"score": 0.0036928221419965253, "phrase": "concurrent_threads"}, {"score": 0.003545024951402821, "phrase": "exhaustive_microbenchmark-based_analysis"}, {"score": 0.003351381374975648, "phrase": "access_conflicts"}, {"score": 0.003120099687922751, "phrase": "lock_mechanism"}, {"score": 0.002964706925144123, "phrase": "performance_model"}, {"score": 0.00290473242917264, "phrase": "latency_penalties"}, {"score": 0.002530359917257626, "phrase": "atomic_operations"}, {"score": 0.0021928902836049384, "phrase": "centroid_updating_step"}, {"score": 0.0021049977753042253, "phrase": "histogram_calculation"}], "paper_keywords": ["Performance model", " atomic operations", " shared memory", " K-means", " histogram", " CUDA", " GPU"], "paper_abstract": "GPU application implementations using scatter approaches will fall into write contention due to atomic updates of output elements, if these result from more than one input element. Colliding threads will be serialized, seriously harming performance. Dealing with these issues requires a proper understanding of the behavior of the scratchpad or shared memory under conflicting accesses caused by concurrent threads. Thus, this paper presents an exhaustive microbenchmark-based analysis of atomic additions in shared memory that quantifies the impact of access conflicts on latency and throughput. This analysis has led us to discover the lock mechanism that enables atomic updates to shared memory and to propose a performance model to estimate the latency penalties due to collisions by position or bank conflicts. Then, we have derived experiments from this model that show us the way to optimize applications using atomic operations. Position and bank conflicts can be diminished by replication and padding, respectively. The benefits of such techniques are illustrated with the optimization of two widely used voting processes: the centroid updating step in k-means clustering, and histogram calculation.", "paper_title": "Performance Modeling of Atomic Additions on GPU Scratchpad Memory", "paper_id": "WOS:000325170700016"}