{"auto_keywords": [{"score": 0.03773596973966994, "phrase": "parity-check_matrix"}, {"score": 0.00481495049065317, "phrase": "parity-check_matrices"}, {"score": 0.004364696693320128, "phrase": "iterative_decoding_techniques"}, {"score": 0.004293840838533456, "phrase": "linear_block_codes"}, {"score": 0.003924121879214595, "phrase": "stopping_sets"}, {"score": 0.003797690272118125, "phrase": "underlying_tanner_graph"}, {"score": 0.0031975786158658158, "phrase": "dead-end_sets"}, {"score": 0.0025628355581338563, "phrase": "iterative_decoders"}, {"score": 0.0025211567863488962, "phrase": "optimal_performance"}, {"score": 0.0023610946923597405, "phrase": "underlying_parity-check_matrices"}, {"score": 0.002157433262687853, "phrase": "optimal_stopping_set_enumerator"}, {"score": 0.0021049977753042253, "phrase": "weight_enumerator"}], "paper_keywords": ["dead-end set", " iterative decoding", " linear code", " parity-check matrix", " stopping set"], "paper_abstract": "The performance of iterative decoding techniques for linear block codes correcting erasures depends very much on the sizes of the stopping sets associated with the underlying Tanner graph, or, equivalently, the parity-check matrix representing the code. In this correspondence, we introduce the notion of dead-end sets to explicitly demonstrate this dependency. The choice of the parity-check matrix entails a tradeoff between performance and complexity. We give bounds on the complexity of iterative decoders achieving optimal performance in terms of the sizes of the underlying parity-check matrices. Further, we fully characterize codes for which the optimal stopping set enumerator equals the weight enumerator.", "paper_title": "Results on parity-check matrices with optimal stopping and/or dead-end set enumerators", "paper_id": "WOS:000253602200038"}