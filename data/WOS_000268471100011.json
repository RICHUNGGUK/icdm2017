{"auto_keywords": [{"score": 0.049568154654955704, "phrase": "embedded_systems"}, {"score": 0.04881182805984396, "phrase": "general-purpose_systems"}, {"score": 0.00481495049065317, "phrase": "multicore_embedded_systems"}, {"score": 0.004563427013973105, "phrase": "parallel_execution"}, {"score": 0.004490552331642995, "phrase": "symmetric_multicore_platform"}, {"score": 0.004395185177346749, "phrase": "concurrency_issues"}, {"score": 0.004324985524216987, "phrase": "general-purpose_programming"}, {"score": 0.004011867299107537, "phrase": "performance-limiting_coarse-grained_locking"}, {"score": 0.0038846843242954935, "phrase": "difficult-to-implement_fine-grained_locking"}, {"score": 0.0034148795808317555, "phrase": "embedded_software_transactional_memory"}, {"score": 0.003306559295382181, "phrase": "novel_solution"}, {"score": 0.0032536902910768957, "phrase": "concurrency_problem"}, {"score": 0.0032189132350239013, "phrase": "parallel_embedded_applications"}, {"score": 0.003150466780962537, "phrase": "common_software_transactional_memory_design_decisions"}, {"score": 0.0030178961017306646, "phrase": "embedded_platform"}, {"score": 0.002937879003671346, "phrase": "full_implementation"}, {"score": 0.002890887778279196, "phrase": "embedded_stm"}, {"score": 0.0027991418754844347, "phrase": "coarse-grained_and_fine-grained_locking_mechanisms"}, {"score": 0.002610198789888055, "phrase": "fine-grained_locking"}, {"score": 0.0025409639091476363, "phrase": "application_characteristics"}, {"score": 0.002473560912156024, "phrase": "shared_data"}, {"score": 0.0023314867226678555, "phrase": "effective_use"}, {"score": 0.0021049977753042253, "phrase": "traditional_locking_mechanisms"}], "paper_keywords": ["Design", " Experimentation", " Performance", " Embedded Systems", " Multicore", " Software Transactional Memory (STM)", " Synchronization", " Locking", " Transactions"], "paper_abstract": "Embedded systems, like general-purpose systems, can benefit from parallel execution on a symmetric multicore platform. Unfortunately, concurrency issues present in general-purpose programming also apply to embedded systems, protection from which is currently only offered with performance-limiting coarse-grained locking or error-prone and difficult-to-implement fine-grained locking. Transactional memory offers relief from these mechanisms, but has primarily been investigated on general-purpose systems. In this paper, we present Embedded Software Transactional Memory (ESTM) as a novel solution to the concurrency problem in parallel embedded applications. We investigate common software transactional memory design decisions and discuss the best decisions for an embedded platform. We offer a full implementation of an embedded STM and test it against both coarse-grained and fine-grained locking mechanisms. We find that we can meet or beat the performance of fine-grained locking over a range of application characteristics, including size of shared data, time spent in the critical section, and contention between threads. Our ESTM implementation benefits from the effective use of L1 memory, a feature which is built into our STM model but which cannot be directly utilized by traditional locking mechanisms.", "paper_title": "Software Transactional Memory for Multicore Embedded Systems", "paper_id": "WOS:000268471100011"}