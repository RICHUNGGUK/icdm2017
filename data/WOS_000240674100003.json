{"auto_keywords": [{"score": 0.048756712287817125, "phrase": "software_design_statements"}, {"score": 0.00481495049065317, "phrase": "software_design"}, {"score": 0.004447600571127578, "phrase": "global_constraints"}, {"score": 0.00436530211426514, "phrase": "programming_paradigms"}, {"score": 0.004324723240308028, "phrase": "architectural_styles"}, {"score": 0.00428451995524549, "phrase": "component-based_software_enginering_standards"}, {"score": 0.004166129325245761, "phrase": "law-governed_regularities"}, {"score": 0.003976007772514762, "phrase": "local_constraints"}, {"score": 0.0039024014688338964, "phrase": "design_patterns"}, {"score": 0.0038661089070527424, "phrase": "programming_idioms"}, {"score": 0.0036213041338584756, "phrase": "class_diagrams"}, {"score": 0.003587616378156851, "phrase": "program_documentation"}, {"score": 0.0034398445347109396, "phrase": "well-defined_vocabulary"}, {"score": 0.003313592421224647, "phrase": "mathematical_logic"}, {"score": 0.002839812512030847, "phrase": "non-local_statements"}, {"score": 0.0028134126957507803, "phrase": "nl"}, {"score": 0.0027741761880779535, "phrase": "strategic_statements"}, {"score": 0.0026722904884984348, "phrase": "local_and_intensional_statements"}, {"score": 0.0026105159490849364, "phrase": "tactical_statements"}, {"score": 0.0025028892126605124, "phrase": "local_and_extensional_statements"}, {"score": 0.002445021071485221, "phrase": "implementation_statements"}, {"score": 0.002388487669097511, "phrase": "broad_range"}, {"score": 0.002237036807966899, "phrase": "architectural_mismatch_theorem"}, {"score": 0.0021049977753042253, "phrase": "conflicting_non-local_statements"}], "paper_keywords": [""], "paper_abstract": "We distinguish three abstraction strata in software design statements: (i) Strategic design statements ('architectural design') determine global constraints, such as programming paradigms, architectural styles, component-based software enginering standards, design principles, and law-governed regularities; (ii) Tactical design statements ('detailed design') determine local constraints, such as design patterns, programming idioms, and refactorings; (iii) Implementation statements determine specific properties of the implementation, such as a class diagrams and program documentation. Seeking to ground this intuition in a well-defined vocabulary, we define two criteria of distinction in mathematical logic. We present the Intension/Locality hypothesis, postulating that the spectrum of software design statements is divided into three well-defined 'abstraction classes' as follows: (i) the class of non-local statements (NL) contains Strategic statements; (ii) the class of local and intensional statements (LF) contains Tactical statements; and (iii) the class of local and extensional statements (LE) contains Implementation statements. We demonstrate a broad range of software design statements that corroborate our hypothesis. We conclude with a proof of the architectural mismatch theorem, according to which architectural mismatch arises from attempting to combine components that assume conflicting non-local statements.", "paper_title": "Abstraction classes in software design", "paper_id": "WOS:000240674100003"}