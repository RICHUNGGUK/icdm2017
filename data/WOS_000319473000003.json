{"auto_keywords": [{"score": 0.04726196056959379, "phrase": "low_supply_voltage"}, {"score": 0.03935928634582904, "phrase": "faulty_resources"}, {"score": 0.00481495049065317, "phrase": "access_and_error_patterns"}, {"score": 0.004773476989344654, "phrase": "error-free_resource"}, {"score": 0.004611108249179507, "phrase": "practical_bottleneck"}, {"score": 0.004415857432588371, "phrase": "process_variation-induced_bit_errors"}, {"score": 0.00415625929636759, "phrase": "error-resilient_cache_architecture"}, {"score": 0.004049709080817396, "phrase": "previous_approaches"}, {"score": 0.0038115535592184438, "phrase": "cache_misses"}, {"score": 0.0036817833826578395, "phrase": "cache_access_locality"}, {"score": 0.0036500346000495317, "phrase": "error-free_resources"}, {"score": 0.0036029221645629225, "phrase": "cost-effective_manner"}, {"score": 0.003510507340837656, "phrase": "cache_lines"}, {"score": 0.003480230347985338, "phrase": "fully_and_partially_accessed_groups"}, {"score": 0.0033182992967343916, "phrase": "partially_accessed_group"}, {"score": 0.003205268682789165, "phrase": "memory_access_behavior"}, {"score": 0.003177615880037735, "phrase": "error_locations"}, {"score": 0.0031502008922533894, "phrase": "intra-cache_line_word-level_remapping"}, {"score": 0.0029776614744264724, "phrase": "cache_access_information_history"}, {"score": 0.002913837945508097, "phrase": "access_pattern-learning_line-fill_buffer"}, {"score": 0.0028267701593809877, "phrase": "fully_accessed_group"}, {"score": 0.0027422968723193057, "phrase": "error-free_assist_functions"}, {"score": 0.0025808284847319528, "phrase": "process_variation-induced_error"}, {"score": 0.0025474814283429213, "phrase": "target_minimum_supply_voltage"}, {"score": 0.0024820711838337713, "phrase": "error-aware_prefetch_method"}, {"score": 0.0024078737745407614, "phrase": "error-free_victim_cache"}, {"score": 0.0022857899334246946, "phrase": "experimental_results"}, {"score": 0.0022464835515931592, "phrase": "proposed_method"}, {"score": 0.0021511430180912164, "phrase": "error_rate"}, {"score": 0.0021049977753042253, "phrase": "small_area_overhead"}], "paper_keywords": ["Bit error", " cache architecture", " low power", " persistent error", " process variation", " SRAM", " Vccmin"], "paper_abstract": "Large SRAMs are the practical bottleneck to achieve a low supply voltage, because they suffer from process variation-induced bit errors at a low supply voltage. In this paper, we present an error-resilient cache architecture that resolves the drawback of previous approaches, i.e., the performance degradation at a low supply voltage which is caused by cache misses in accesses to faulty resources. We utilize cache access locality and error-free resources in a cost-effective manner. First, we classify cache lines into fully and partially accessed groups and apply appropriate methods to each group. For the partially accessed group, we propose a method of matching memory access behavior and error locations with intra-cache line word-level remapping. In order to reduce the area overhead used to store the cache access information history, we present an access pattern-learning line-fill buffer (LFB). For the fully accessed group, we propose the utilization of error-free assist functions in the cache, i.e., a LFB and victim cache with no process variation-induced error at the target minimum supply voltage. We also present an error-aware prefetch method that allows us to utilize the error-free victim cache to achieve a further reduction in cache misses due to faulty resources. Experimental results show that the proposed method gives an average 32.6% reduction in cycles per instruction at an error rate of 0.2% with a small area overhead of 8.2%.", "paper_title": "MAEPER: Matching Access and Error Patterns With Error-Free Resource for Low Vcc L1 Cache", "paper_id": "WOS:000319473000003"}