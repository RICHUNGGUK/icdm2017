{"auto_keywords": [{"score": 0.04066031201468573, "phrase": "deterministic_replay"}, {"score": 0.013099501369323176, "phrase": "respec"}, {"score": 0.00481495049065317, "phrase": "external_determinism"}, {"score": 0.004549734943142138, "phrase": "hardware_or_software_system"}, {"score": 0.004339867166576126, "phrase": "uniprocessor_systems"}, {"score": 0.004278807087784626, "phrase": "shared_memory_multiprocessor_systems"}, {"score": 0.004178935413340453, "phrase": "commodity_hardware"}, {"score": 0.004100712177044264, "phrase": "open_problem"}, {"score": 0.0038382392088338784, "phrase": "shared_memory_multithreaded_programs"}, {"score": 0.003802135020791801, "phrase": "commodity_multiprocessor_hardware"}, {"score": 0.003766369160795001, "phrase": "respec_targets"}, {"score": 0.0037486121194392564, "phrase": "online_replay"}, {"score": 0.0033624514778823763, "phrase": "speculative_logging"}, {"score": 0.0032838979278935814, "phrase": "shared_memory_dependencies"}, {"score": 0.003073545175760353, "phrase": "replayed_process"}, {"score": 0.003015950477134494, "phrase": "recorded_process"}, {"score": 0.002782938683493689, "phrase": "final_program_states"}, {"score": 0.0026293540353514075, "phrase": "low_recording"}, {"score": 0.0026045914281028473, "phrase": "replay_overhead"}, {"score": 0.0025678829712650437, "phrase": "common_case"}, {"score": 0.0025436978068459565, "phrase": "datarace-free_execution_intervals"}, {"score": 0.0024960069794216977, "phrase": "correct_replay"}, {"score": 0.00247249708860822, "phrase": "execution_intervals"}, {"score": 0.002437645786158106, "phrase": "data_races"}, {"score": 0.0023806459272452353, "phrase": "linux_kernel"}, {"score": 0.0022385926290967263, "phrase": "execution_time"}], "paper_keywords": ["Design", " Performance", " Reliability", " Replay", " Speculative execution", " External determinism"], "paper_abstract": "Deterministic replay systems record and reproduce the execution of a hardware or software system. While it is well known how to replay uniprocessor systems, replaying shared memory multiprocessor systems at low overhead on commodity hardware is still an open problem. This paper presents Respec, a new way to support deterministic replay of shared memory multithreaded programs on commodity multiprocessor hardware. Respec targets online replay in which the recorded and replayed processes execute concurrently. Respec uses two strategies to reduce overhead while still ensuring correctness: speculative logging and externally deterministic replay. Speculative logging optimistically logs less information about shared memory dependencies than is needed to guarantee deterministic replay, then recovers and retries if the replayed process diverges from the recorded process. Externally deterministic replay relaxes the degree to which the two executions must match by requiring only their system output and final program states match. We show that the combination of these two techniques results in low recording and replay overhead for the common case of datarace-free execution intervals and still ensures correct replay for execution intervals that have data races. We modified the Linux kernel to implement our techniques. Our software system adds on average about 18% overhead to the execution time for recording and replaying programs with two threads and 55% overhead for programs with four threads.", "paper_title": "Respec: Efficient Online Multiprocessor Replay via Speculation and External Determinism", "paper_id": "WOS:000275926700008"}