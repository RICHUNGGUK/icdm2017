{"auto_keywords": [{"score": 0.027014606534390705, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "type_errors"}, {"score": 0.004706453355638515, "phrase": "type_inference_engines"}, {"score": 0.004626680470601208, "phrase": "terrible_error_messages"}, {"score": 0.004445739135694758, "phrase": "type_system"}, {"score": 0.0041517954514423625, "phrase": "highly_expressive_type_system"}, {"score": 0.004063159019624247, "phrase": "gadts"}, {"score": 0.004058180509184539, "phrase": "glasgow_haskell_compiler"}, {"score": 0.003989351600022163, "phrase": "type_classes"}, {"score": 0.0036207206487324506, "phrase": "type_error"}, {"score": 0.0035189057079817285, "phrase": "first_source"}, {"score": 0.003267342521938321, "phrase": "likely_error_sources"}, {"score": 0.0031754329320561317, "phrase": "simple_bayesian_model"}, {"score": 0.0031215289677725693, "phrase": "graph_representation"}, {"score": 0.003068537223324389, "phrase": "typing_constraints"}, {"score": 0.0028006988338192375, "phrase": "possible_explanations"}, {"score": 0.002706383680762465, "phrase": "prior_work"}, {"score": 0.002675654549462983, "phrase": "error_diagnosis"}, {"score": 0.0026452734009203764, "phrase": "simpler_type_systems"}, {"score": 0.002570817338292482, "phrase": "richer_type_system"}, {"score": 0.0024560114164181765, "phrase": "new_nodes"}, {"score": 0.0023064582783867645, "phrase": "bayesian_reasoning"}, {"score": 0.0022034318550547866, "phrase": "large_corpus"}, {"score": 0.002178400923036365, "phrase": "haskell_programs"}, {"score": 0.0021049977753042253, "phrase": "error_localization_technique"}], "paper_keywords": ["Error diagnosis", " type inference", " Haskell"], "paper_abstract": "Type inference engines often give terrible error messages, and the more sophisticated the type system the worse the problem. We show that even with the highly expressive type system implemented by the Glasgow Haskell Compiler (GHC)-including type classes, GADTs, and type families-it is possible to identify the most likely source of the type error, rather than the first source that the inference engine trips over. To determine which are the likely error sources, we apply a simple Bayesian model to a graph representation of the typing constraints; the satisfiability or unsatisfiability of paths within the graph provides evidence for or against possible explanations. While we build on prior work on error diagnosis for simpler type systems, inference in the richer type system of Haskell requires extending the graph with new nodes. The augmentation of the graph creates challenges both for Bayesian reasoning and for ensuring termination. Using a large corpus of Haskell programs, we show that this error localization technique is practical and significantly improves accuracy over the state of the art.", "paper_title": "Diagnosing Type Errors with Class", "paper_id": "WOS:000361284200002"}