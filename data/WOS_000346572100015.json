{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multicore_systems"}, {"score": 0.03986629341595467, "phrase": "energy_efficiency"}, {"score": 0.036755348033607936, "phrase": "scalability_collapse"}, {"score": 0.0339990289226179, "phrase": "power-saving_state"}, {"score": 0.024576307843687237, "phrase": "better_scalability"}, {"score": 0.004710489616113198, "phrase": "increasing_ubiquity"}, {"score": 0.004676173016967478, "phrase": "multicore_processors"}, {"score": 0.004362326712297089, "phrase": "operating_systems"}, {"score": 0.004039792863335641, "phrase": "reduced_performance"}, {"score": 0.003923269062268688, "phrase": "existing_lock_implementations"}, {"score": 0.0038380787059463075, "phrase": "power_consumption"}, {"score": 0.0035541673947328163, "phrase": "significant_correlation"}, {"score": 0.0033890026927890058, "phrase": "lock_implementation"}, {"score": 0.002970476379751357, "phrase": "linux_kernel"}, {"score": 0.002853183476661506, "phrase": "sensitivity_analysis"}, {"score": 0.0027911639820564897, "phrase": "best_policy"}, {"score": 0.002401875938287542, "phrase": "experimental_results"}, {"score": 0.0022321322970228308, "phrase": "previous_work"}, {"score": 0.002191600750693037, "phrase": "requester-based_lock"}, {"score": 0.0021049977753042253, "phrase": "spin_locks"}], "paper_keywords": ["Scalability collapse", " multicore system", " lock contention", " requester-based lock", " power-saving state", " energy efficiency"], "paper_abstract": "In response to the increasing ubiquity of multicore processors, applications are usually designed or deployed to make each core busy. Unfortunately, lock contention within operating systems can limit the scalability of multicore systems so severely that an increase in the number of cores can actually lead to reduced performance (i.e., scalability collapse). Existing lock implementations have disadvantages in scalability, power consumption, and energy efficiency. In this paper, we observe that the number of tasks requesting a lock has a significant correlation with the occurrence of scalability collapse. Based on this observation, a lock implementation that allows tasks waiting for a lock to either spin or enter a power-saving state based on the number of requesters is proposed. Our lock protocol is called requester-based lock and is implemented in the Linux kernel to replace its default spin lock. Based on the results of a sensitivity analysis, we find that the best policy, in practice, for a task waiting for a lock to be granted is to enter the power-saving state immediately after noticing the lock cannot be acquired. Our requester-based lock scheme is evaluated using intensive benchmarking on AMD 32-core and Intel 40-core systems. Experimental results suggest that our lock avoids scalability collapse completely for most applications and shows better scalability, power consumption, and energy efficiency than previous work. Besides, the requester-based lock is extensible, which means using together with other kinds of spin locks can provide better scalability and energy efficiency.", "paper_title": "Requester-Based Spin Lock: A Scalable and Energy Efficient Locking Scheme on Multicore Systems", "paper_id": "WOS:000346572100015"}