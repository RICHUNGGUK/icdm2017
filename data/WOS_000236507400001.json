{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "infinite_sequence"}, {"score": 0.004395742407834023, "phrase": "useful_property"}, {"score": 0.004172722575842674, "phrase": "terminating_applet"}, {"score": 0.003735522846193052, "phrase": "computing_resources"}, {"score": 0.0031741489723036255, "phrase": "non-trivial_subset"}, {"score": 0.0026104197983396367, "phrase": "logical_relations"}, {"score": 0.0023982749733789882, "phrase": "small_set"}, {"score": 0.0023672002840029517, "phrase": "non-deterministic_'functional'_processes"}, {"score": 0.0022033327475266496, "phrase": "process_calculi"}, {"score": 0.0021049977753042253, "phrase": "behavioural_preorders"}], "paper_keywords": [""], "paper_abstract": "A process M terminates if it cannot produce an infinite sequence of reductions M ->(t) M1 ->(t) M2.... Termination is a useful property in concurrency. For instance, a terminating applet, when loaded on a machine, will not run for ever, possibly absorbing all computing resources (a 'denial of service' attack). Similarly, termination guarantees that queries to a given service originate only finite computations. We ensure termination of a non-trivial subset of the pi-calculus by a combination of conditions on types and on the syntax. The proof of termination is in two parts. The first uses the technique of logical relations - a well-know technique of)lambda-calculi - on a small set of non-deterministic 'functional' processes. The second part of the proof uses techniques of process calculi, in particular, techniques of behavioural preorders.", "paper_title": "Termination of processes", "paper_id": "WOS:000236507400001"}