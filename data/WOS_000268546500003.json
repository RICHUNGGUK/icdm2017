{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "accurate_garbage_collection"}, {"score": 0.004768378525561471, "phrase": "uncooperative_environments"}, {"score": 0.004653900688892822, "phrase": "concurrent_programming_language"}, {"score": 0.004586784108599346, "phrase": "java"}, {"score": 0.004411588377842043, "phrase": "existing_language"}, {"score": 0.004141365648080381, "phrase": "host_language"}, {"score": 0.003906586074865932, "phrase": "host_compiler"}, {"score": 0.0036493838225192883, "phrase": "efficient_compilers"}, {"score": 0.0035965032173588753, "phrase": "wide_range"}, {"score": 0.0035100601949451028, "phrase": "garbage-collected_languages"}, {"score": 0.003376037544631762, "phrase": "perfect_match"}, {"score": 0.0031231012822640672, "phrase": "thread_stacks"}, {"score": 0.003003809128328864, "phrase": "new_mechanism"}, {"score": 0.0027922467043592597, "phrase": "new_technique"}, {"score": 0.002751751956416832, "phrase": "ovm_java_virtual_machine"}, {"score": 0.0026986814118575317, "phrase": "gcc"}, {"score": 0.002659527314613792, "phrase": "back-end_compiler"}, {"score": 0.00259554612218815, "phrase": "lazy_pointer_stacks"}, {"score": 0.002570385604065795, "phrase": "existing_approaches"}, {"score": 0.0024601402359002056, "phrase": "henderson's_accurate_collector"}, {"score": 0.002400944221804575, "phrase": "code_size"}, {"score": 0.0023776656246300063, "phrase": "accurate_collection"}, {"score": 0.002297949552105756, "phrase": "real-time_systems"}, {"score": 0.0021780349459687622, "phrase": "real-time_concurrent_garbage_collection_algorithm"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["programming languages", " runtime systems", " compilers", " garbage collection", " Java"], "paper_abstract": "Implementing a concurrent programming language such as Java by means of a translator to an existing language is attractive as it provides portability over all platforms supported by the host language and reduces development time-as many low-level tasks can be delegated to the host compiler. The C and C++ programming languages are popular choices for many language implementations due to the availability of efficient compilers on a wide range of platforms. For garbage-collected languages, however, they are not a perfect match as no support is provided for accurately discovering pointers to heap-allocated data on thread stacks. We evaluate several previously published techniques and propose a new mechanism, lazy pointer stacks, for performing accurate garbage collection in such uncooperative environments. We implemented the new technique in the Ovm Java virtual machine with our own Java-to-C/C++ compiler using GCC as a back-end compiler. Our extensive experimental results confirm that lazy pointer stacks outperform existing approaches: we provide a speedup of 4.5% over Henderson's accurate collector with a 17% increase in code size. Accurate collection is essential in the context of real-time systems, we thus validate our approach with the implementation of a real-time concurrent garbage collection algorithm. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Accurate garbage collection in uncooperative environments revisited", "paper_id": "WOS:000268546500003"}