{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "exception-safety_classification"}, {"score": 0.04070303364753307, "phrase": "program_state"}, {"score": 0.033432006348234344, "phrase": "safety_level"}, {"score": 0.004774324145784758, "phrase": "exception_handling_mechanisms"}, {"score": 0.004714023408114857, "phrase": "structured_way"}, {"score": 0.004634799977448855, "phrase": "exceptional_circumstances"}, {"score": 0.004404994123834589, "phrase": "exception_handling"}, {"score": 0.004046923261950549, "phrase": "inconsistent_state-resources"}, {"score": 0.00378145978325955, "phrase": "client_code"}, {"score": 0.0034738975998176323, "phrase": "safety_guarantees"}, {"score": 0.003301461490509176, "phrase": "review_process"}, {"score": 0.003259702394241964, "phrase": "boost_organization"}, {"score": 0.0032321559007422087, "phrase": "standardized_libraries"}, {"score": 0.003097865379563127, "phrase": "understanding_program_invariants"}, {"score": 0.0027978304423349246, "phrase": "tool_support"}, {"score": 0.002658863179011018, "phrase": "first_automated_analysis"}, {"score": 0.0026363807171515255, "phrase": "exception_guarantees"}, {"score": 0.0025591748412278174, "phrase": "arbitrary_procedure"}, {"score": 0.0024736973328071026, "phrase": "exception_safety"}, {"score": 0.0023708445073819277, "phrase": "backward_data-flow_analysis"}, {"score": 0.0022530375696567136, "phrase": "no-throw_guarantee"}, {"score": 0.002177762848946681, "phrase": "prototype_implementation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Strong exception-safety guarantee", " Rollback semantics", " Data-flow analysis", " Program safety", " Exception handling"], "paper_abstract": "Exception handling mechanisms provide a structured way to deal with exceptional circumstances, making it easier to read and reason about programs. Exception handling, however, cannot avoid the problem that the transfer of control might leave the program in an inconsistent state-resources might leak, invariants might be violated, the program state might be changed. Since client code often needs to know how a program behaves in the presence of exceptions, the exception-safety classification distinguishes three different classes of safety guarantees; this classification is used, for example, during the review process in the Boost organization for standardized libraries in C++. Classifying the safety level of a procedure requires understanding program invariants and tracking program state at any given point in the code, which is error-prone when done by hand. Yet, no tool support is available to date. In this paper we present the first automated analysis for exception guarantees. Since the safety level of an arbitrary procedure is undecidable, the analysis conservatively approximates exception safety. The analysis is based on the theory of backward data-flow analysis and recognizes two of the three safety guarantees, the strong and the no-throw guarantee, and provides counterexamples otherwise. A prototype implementation is available. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Automating exception-safety classification", "paper_id": "WOS:000287834500005"}