{"auto_keywords": [{"score": 0.04970198387475844, "phrase": "synergy"}, {"score": 0.00481495049065317, "phrase": "smt_processors"}, {"score": 0.004646654984830476, "phrase": "current_operating_systems"}, {"score": 0.00453772385360173, "phrase": "different_contexts"}, {"score": 0.00450198136261303, "phrase": "simultaneous_multithreaded"}, {"score": 0.004396426822203258, "phrase": "multiple_independent_processing_units"}, {"score": 0.004078157608867258, "phrase": "hardware_resources"}, {"score": 0.003919973783578995, "phrase": "smt_instruction_fetch"}, {"score": 0.0036217089991592275, "phrase": "individual_threads"}, {"score": 0.0034674164050273568, "phrase": "job_scheduler"}, {"score": 0.003372658906684677, "phrase": "general_purpose_systems"}, {"score": 0.003319675107116333, "phrase": "os_job_scheduler"}, {"score": 0.0032034752726003025, "phrase": "embedded_systems"}, {"score": 0.0030913302090179967, "phrase": "worst-case_execution_times"}, {"score": 0.0029830992938695007, "phrase": "novel_strategy"}, {"score": 0.0029362173680378624, "phrase": "two-way_interaction"}, {"score": 0.002867268370615848, "phrase": "smt_processor"}, {"score": 0.002566255769251419, "phrase": "previous_approaches"}, {"score": 0.002486193594641237, "phrase": "time-critical_jobs"}, {"score": 0.002447101794397243, "phrase": "internal_resources"}, {"score": 0.0023990982005125763, "phrase": "non-time-critical_jobs"}, {"score": 0.0022967713922705, "phrase": "overall_throughput"}, {"score": 0.0021987994275190314, "phrase": "os_requirements"}, {"score": 0.0021049977753042253, "phrase": "best_currently_known_fetch_policies"}], "paper_keywords": ["multithreaded processors", " simultaneous multithreading", " ILP", " thread-level parallelism", " performance predictability", " real time", " operating systems"], "paper_abstract": "Current Operating Systems ( OS) perceive the different contexts of Simultaneous Multithreaded (SMT) processors as multiple independent processing units, although, in reality, threads executed in these units compete for the same hardware resources. Furthermore, hardware resources are assigned to threads implicitly as determined by the SMT instruction fetch (Ifetch) policy, without the control of the OS. Both factors cause a lack of control over how individual threads are executed, which can frustrate the work of the job scheduler. This presents a problem for general purpose systems, where the OS job scheduler cannot enforce priorities, and also for embedded systems, where it would be difficult to guarantee worst-case execution times. In this paper, we propose a novel strategy that enables a two-way interaction between the OS and the SMT processor and allows the OS to run jobs at a certain percentage of their maximum speed, regardless of the workload in which these jobs are executed. In contrast to previous approaches, our approach enables the OS to run time-critical jobs without dedicating all internal resources to them so that non-time-critical jobs can make significant progress as well and without significantly compromising overall throughput. In fact, our mechanism, in addition to fulfilling OS requirements, achieves 90 precent of the throughput of one of the best currently known fetch policies for SMTs.", "paper_title": "Predictable performance in SMT processors: Synergy between the OS and SMTs", "paper_id": "WOS:000237631000001"}