{"auto_keywords": [{"score": 0.03291721668032437, "phrase": "ram_model"}, {"score": 0.00481495049065317, "phrase": "ram-efficient_external_memory_sorting"}, {"score": 0.004682414867878963, "phrase": "large_number"}, {"score": 0.004502943680955863, "phrase": "external_memory_models"}, {"score": 0.004354572391793908, "phrase": "complexity_measure"}, {"score": 0.004072275820209647, "phrase": "slow_external_memory"}, {"score": 0.004027031316965272, "phrase": "fast_internal_memory"}, {"score": 0.0037658881407605445, "phrase": "internal_memory_time"}, {"score": 0.0036826452656927877, "phrase": "total_running_time"}, {"score": 0.003348838095597268, "phrase": "fundamental_problems"}, {"score": 0.0029945352738604742, "phrase": "conventional_wisdom"}, {"score": 0.0029282926103224717, "phrase": "merging_base_algorithms"}, {"score": 0.002895721231882758, "phrase": "external_memory"}, {"score": 0.0027690086059100495, "phrase": "suboptimal_ram_performance"}, {"score": 0.0026626797255348287, "phrase": "splitting_based_algorithm"}, {"score": 0.002603758927691463, "phrase": "existing_ram_sorting_techniques"}, {"score": 0.0025461386232786356, "phrase": "sorting_algorithm"}, {"score": 0.002263861731320045, "phrase": "sorting_lower_bound"}], "paper_keywords": ["I/O algorithms", " RAM algorithms", " External memory algorithms", " Sorting", " Priority queue"], "paper_abstract": "In recent years a large number of problems have been considered in external memory models of computation, where the complexity measure is the number of blocks of data that are moved between slow external memory and fast internal memory (also called I/Os). In practice, however, internal memory time often dominates the total running time once I/O-efficiency has been obtained. In this paper we initiate a study of algorithms for fundamental problems that are simultaneously I/O-efficient and internal memory efficient in the RAM model of computation. For sorting the conventional wisdom is to use merging base algorithms in external memory but we describe how this leads to suboptimal RAM performance. However, by using a splitting based algorithm in combination with existing RAM sorting techniques we obtain a sorting algorithm that is both I/O and RAM model efficient. Furthermore, we design an I/O- and RAM-efficient priority queue. Finally, we prove a sorting lower bound that shows that in most cases our results are optimal both in terms of I/O and internal computation.", "paper_title": "RAM-Efficient External Memory Sorting", "paper_id": "WOS:000366155100002"}