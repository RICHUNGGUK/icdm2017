{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "tso"}, {"score": 0.013126533108357177, "phrase": "memory_barrier"}, {"score": 0.011647955012140035, "phrase": "tso_rmws"}, {"score": 0.0047082722120016015, "phrase": "rmw"}, {"score": 0.004603945840067339, "phrase": "building_blocks"}, {"score": 0.004539913872457199, "phrase": "higher_level_synchronization_constructs"}, {"score": 0.004439301692276909, "phrase": "lock-free_data_structures"}, {"score": 0.004280523967775508, "phrase": "sparc"}, {"score": 0.00413897695636482, "phrase": "key_reason"}, {"score": 0.003935354824241103, "phrase": "write-buffer_drain"}, {"score": 0.0039024014688338964, "phrase": "critical_path"}, {"score": 0.00379452936798156, "phrase": "strict_atomicity_definition"}, {"score": 0.003577571074932361, "phrase": "atomicity_definition"}, {"score": 0.0033447157263095223, "phrase": "weaker_atomicity_definitions"}, {"score": 0.0032430998954652043, "phrase": "different_relaxed_ordering_differences"}, {"score": 0.0030234540584856352, "phrase": "common_synchronization_idioms"}, {"score": 0.0029069972482610403, "phrase": "recent_work"}, {"score": 0.002401935608502315, "phrase": "efficient_microarchitectural_implementations"}, {"score": 0.002361816711646652, "phrase": "rmws_-_simulation_results"}, {"score": 0.0022328534191265854, "phrase": "overall_performance_improvement"}, {"score": 0.002171031200018668, "phrase": "parallel_programs"}, {"score": 0.002122851828822048, "phrase": "parsec"}, {"score": 0.00210500122371786, "phrase": "stamp"}], "paper_keywords": ["Design", " Performance", " Experimentation", " Read-Modify-Write (RMW)", " Total-Store-Order (TSO)", " Atomics"], "paper_abstract": "Read-Modify-Write (RMW) instructions are widely used as the building blocks of a variety of higher level synchronization constructs, including locks, barriers, and lock-free data structures. Unfortunately, they are expensive in architectures such as x86 and SPARC which enforce (variants of) Total-Store-Order (TSO). A key reason is that RMWs in these architectures are ordered like a memory barrier, incurring the cost of a write-buffer drain in the critical path. Such strong ordering semantics are dictated by the requirements of the strict atomicity definition (type-1) that existing TSO RMWs use. Programmers often do not need such strong semantics. Besides, weakening the atomicity definition of TSO RMWs, would also weaken their ordering - thereby leading to more efficient hardware implementations. In this paper we argue for TSO RMWs to use weaker atomicity definitions - we consider two weaker definitions: type-2 and type-3, with different relaxed ordering differences. We formally specify how such weaker RMWs would be ordered, and show that type-2 RMWs, in particular, can seamlessly replace existing type-1 RMWs in common synchronization idioms - except in situations where a type-1 RMW is used as a memory barrier. Recent work has shown that the new C/C++ 11 concurrency model can be realized by generating conventional (type-1) RMWs for C/C++ 11 SC-atomic-writes and/or SC-atomic-reads. We formally prove that this is equally valid using the proposed type-2 RMWs; type-3 RMWs, on the other hand, could be used for SC-atomic-reads (and optionally SC-atomic-writes). We further propose efficient microarchitectural implementations for type-2 (type-3) RMWs - simulation results show that our implementation reduces the cost of an RMW by up to 58.9% (64.3%), which translates into an overall performance improvement of up to 9.0% (9.2%) on a set of parallel programs, including those from the SPLASH-2, PARSEC, and STAMP benchmarks.", "paper_title": "Fast RMWs for TSO: Semantics and Implementation", "paper_id": "WOS:000321865400007"}