{"auto_keywords": [{"score": 0.03934707432130444, "phrase": "worst-case_cost"}, {"score": 0.010612387000973441, "phrase": "double-ended_priority_queues"}, {"score": 0.004330321475256457, "phrase": "priority_queues"}, {"score": 0.004141093507753515, "phrase": "unspecified_element"}, {"score": 0.00400459716272594, "phrase": "standard_priority-queue_operations"}, {"score": 0.003916098498242888, "phrase": "first_transformation"}, {"score": 0.003829548069657859, "phrase": "double-ended_priority_queue"}, {"score": 0.0030451958332949735, "phrase": "second_transformation"}, {"score": 0.002977835845437357, "phrase": "meldable_double-ended_priority_queue"}, {"score": 0.0021049977753042253, "phrase": "data_structures"}], "paper_keywords": ["Data structures", " Priority queues", " Double-ended priority queues", " Min-max priority queues", " Priority deques", " Meticulous analysis", " Comparison complexity"], "paper_abstract": "We introduce two data-structural trans formations to construct double-ended priority queues from priority queues. To apply our transformations the priority queues exploited must support the extraction of an unspecified element, in addition to the standard priority-queue operations. With the first transformation we obtain a double-ended priority queue which guarantees the worst-case cost of O(1) for find-min, find-max, insert, extract; and the worst-case cost of O(lg n) with at most lg n + O(1) element comparisons for delete. With the second transformation we get a meldable double-ended priority queue which guarantees the worst-case cost of O(1) for find-min, find-max, insert, extract; the worst-case cost of O(lg n) with at most lg n + O(lg lg n) element comparisons for delete; and the worst-case cost of O (min {lg m, lg n n}) for meld. Here, m and n denote the number of elements stored in the data structures prior to the operation in question.", "paper_title": "Two new methods for constructing double-ended priority queues from priority queues", "paper_id": "WOS:000262730300004"}