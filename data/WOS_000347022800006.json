{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "iterative_loops"}, {"score": 0.04145933533719876, "phrase": "industrial_projects"}, {"score": 0.00478867907727921, "phrase": "recursive_methods"}, {"score": 0.004723622989145559, "phrase": "software_engineering"}, {"score": 0.004672212052212814, "phrase": "good_election"}, {"score": 0.0042571127331582975, "phrase": "call_graph"}, {"score": 0.004063547375196532, "phrase": "public_transformation"}, {"score": 0.0036519716087768253, "phrase": "industrial_algorithm"}, {"score": 0.0036121819729961384, "phrase": "java_library"}, {"score": 0.0035435867326548665, "phrase": "equivalent_recursive_methods"}, {"score": 0.003466780226380516, "phrase": "programming_language_java"}, {"score": 0.0031240075437664314, "phrase": "transformation_schema"}, {"score": 0.0030229485340586473, "phrase": "first_public_transformation"}, {"score": 0.00294122712771669, "phrase": "whole_java_language"}, {"score": 0.0027615309527078903, "phrase": "control_statements"}, {"score": 0.002709045632654716, "phrase": "loop_labels"}, {"score": 0.0026357877401570764, "phrase": "nested_loops"}, {"score": 0.0025019976123483085, "phrase": "previous_work"}, {"score": 0.0022176061978080837, "phrase": "different_problems"}, {"score": 0.0021994343316143125, "phrase": "exception_handling"}, {"score": 0.0021399277552314067, "phrase": "open_source"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Program transformation", " Iteration", " Recursion"], "paper_abstract": "Context: In software engineering, taking a good election between recursion and iteration is essential because their efficiency and maintenance are different. In fact, developers often need to transform iteration into recursion (e.g., in debugging, to decompose the call graph into iterations); thus, it is quite surprising that there does not exist a public transformation from loops to recursion that can be used in industrial projects (i.e., it is automatic, it handles all kinds of loops, it considers exceptions, etc.). Objective: This article describes an industrial algorithm implemented as a Java library able to automatically transform iterative loops into equivalent recursive methods. The transformation is described for the programming language Java, but it is general enough as to be adapted to many other languages that allow iteration and recursion. Method: We describe the changes needed to transform loops of types while/do/for/foreach into recursion. We provide a transformation schema for each kind of loop. Results: Our algorithm is the first public transformation that can be used in industrial projects and faces the whole Java language (i.e., it is fully automatic, it handles all kinds of loops, it considers exceptions, it treats the control statements break and continue, it handles loop labels, it is able to transform any number of nested loops, etc.). This is particularly interesting because some of these features are missing in all previous work, probably, due to the complexity that their mixture introduce in the transformation. Conclusion: Developers should use a methodology when transforming code, specifically when transforming loops into recursion. This article provides guidelines and algorithms that allow them to face different problems such as exception handling. The implementation has been made publicly available as open source. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Automatic transformation of iterative loops into recursive methods", "paper_id": "WOS:000347022800006"}