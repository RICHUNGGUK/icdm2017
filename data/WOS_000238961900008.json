{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "rpc"}, {"score": 0.032476646003436443, "phrase": "task_parallelism"}, {"score": 0.0047784273577245505, "phrase": "embedded_data"}, {"score": 0.00463507149599759, "phrase": "embedded_parallel_image_processing_applications"}, {"score": 0.004478907336898875, "phrase": "single_instruction_multiple_data"}, {"score": 0.004444946262482536, "phrase": "simd"}, {"score": 0.00434449804021954, "phrase": "deep_knowledge"}, {"score": 0.004118874671285618, "phrase": "specific_hardware_platform"}, {"score": 0.004041155193307942, "phrase": "chosen_hardware"}, {"score": 0.0038458526450015976, "phrase": "new_platform"}, {"score": 0.00373036974937097, "phrase": "design_space_exploration"}, {"score": 0.0035230711775515854, "phrase": "hardware-independent_program"}, {"score": 0.003456554957885269, "phrase": "algorithmic_skeletons"}, {"score": 0.003314591878914152, "phrase": "data_parallelism"}, {"score": 0.003276893480994257, "phrase": "low-level_image_processing"}, {"score": 0.0032150101448578734, "phrase": "different_operations"}, {"score": 0.0031663432942179853, "phrase": "different_kinds"}, {"score": 0.002922637921202474, "phrase": "asynchronous_remote_procedure_call"}, {"score": 0.0028347983387988847, "phrase": "low-memory_and_sparsely_connected_systems"}, {"score": 0.00266693888510356, "phrase": "normal_imperative_c-interface"}, {"score": 0.002596653214530156, "phrase": "skeleton_calls"}, {"score": 0.002499438189264537, "phrase": "task_dependency_graph"}, {"score": 0.0023784664152543718, "phrase": "run_time"}, {"score": 0.002220551141101661, "phrase": "parallel_implementation"}, {"score": 0.0021049977753042253, "phrase": "interconnect_bandwidth"}], "paper_keywords": ["design space exploration", " heterogeneous architectures", " constrained architectures", " algorithmic skeletons", " remote procedure call", " futures", " run-time scheduling"], "paper_abstract": "Developing embedded parallel image processing applications is usually a very hardware-dependent process, often using the single instruction multiple data (SIMD) paradigm, and requiring deep knowledge of the processors used. Furthermore, the application is tailored to a specific hardware platform, and if the chosen hardware does not meet the requirements, it must be rewritten for a new platform. We have proposed the use of design space exploration [9] to find the most suitable hardware platform for a certain application. This requires a hardware-independent program, and we use algorithmic skeletons [5] to achieve this, while exploiting the data parallelism inherent to low-level image processing. However, since different operations run best on different kinds of processors, we need to exploit task parallelism as well. This paper describes how we exploit task parallelism using an asynchronous remote procedure call (RPC) system, optimized for low-memory and sparsely connected systems such as smart cameras. It uses a futures [16]-like model to present a normal imperative C-interface to the user in which the skeleton calls are implicitly parallelized and pipelined. Simulation provides the task dependency graph and performance numbers for the mapping, which can be done at run time to facilitate data dependent branching. The result is an easy to program, platform independent framework which shields the user from the parallel implementation and mapping of his application, while efficiently utilizing on-chip memory and interconnect bandwidth.", "paper_title": "Skeletons and asynchronous RPC for embedded data and task parallel image processing", "paper_id": "WOS:000238961900008"}