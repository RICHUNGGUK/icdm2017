{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "synchronization_accelerator"}, {"score": 0.004765482708043842, "phrase": "multi-processor_embedded_systems"}, {"score": 0.004620093797504386, "phrase": "multi-processor_core_systems"}, {"score": 0.004479120557712926, "phrase": "difficult_challenge"}, {"score": 0.00443308765153716, "phrase": "current_solutions"}, {"score": 0.004102528738941734, "phrase": "parallel_programming"}, {"score": 0.0038558497470953306, "phrase": "master-slave_rtos"}, {"score": 0.0037381083634085424, "phrase": "parallel_programs"}, {"score": 0.0036616109902631293, "phrase": "multi-processor_core_system"}, {"score": 0.0035497797026638033, "phrase": "efficient_protocol"}, {"score": 0.003405948098114941, "phrase": "operating_system"}, {"score": 0.003370907075333389, "phrase": "application_programs"}, {"score": 0.0033190180867511605, "phrase": "interface_protocol"}, {"score": 0.0032510690712452147, "phrase": "dedicated_control_subnet"}, {"score": 0.003168079471049896, "phrase": "synchronization_overhead"}, {"score": 0.0031193028729331667, "phrase": "parallel_tasks"}, {"score": 0.0030239842475439814, "phrase": "multi-core_parallel_systems"}, {"score": 0.0029013950320185573, "phrase": "severe_limiting_factors"}, {"score": 0.0028273061946184645, "phrase": "performance_envelope"}, {"score": 0.0027982016314450717, "phrase": "experimental_results"}, {"score": 0.002726740692380339, "phrase": "register-transfer_level_simulations"}, {"score": 0.0026297428083782875, "phrase": "proposed_protocol"}, {"score": 0.0025892330566358503, "phrase": "control_subnet"}, {"score": 0.0025361866386341796, "phrase": "system_efficiency"}, {"score": 0.0023346234464901978, "phrase": "minimum_subset"}, {"score": 0.002298649369775623, "phrase": "massage-passing_interface_functions"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Real-time operating system", " Parallel programming", " Interface protocol", " Synchronization", " Multicore"], "paper_abstract": "With the proliferation of multi-processor core systems, parallel programming imposes a difficult challenge where current solutions are far from being considered efficient. In order to alleviate the difficulty of parallel programming, we propose a scheduler, which is part of a master-slave RTOS, to efficiently manage the parallel programs running on a multi-processor core system. We also propose an efficient protocol that serves as the interface between the operating system and application programs. This interface protocol runs on a dedicated control subnet to cut down the synchronization overhead between the parallel tasks. Such synchronization overhead incurred in these multi-core parallel systems has been recognized as one of the severe limiting factors when pushing up the performance envelope. Experimental results, obtained from the register-transfer level simulations of various benchmark parallel programs, show that the proposed protocol and the control subnet can improve the system efficiency by up to 33.5%. This protocol, as it is designed to be compatible with the minimum subset of the massage-passing interface functions (MPI), scales well with the number of cores. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "An efficient protocol with synchronization accelerator for multi-processor embedded systems", "paper_id": "WOS:000324960800008"}