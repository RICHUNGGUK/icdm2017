{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "online_tree_node_assignment_problem"}, {"score": 0.00459039896577789, "phrase": "ovsf_code_assignment_problem"}, {"score": 0.004460703838987562, "phrase": "complete_binary_tree"}, {"score": 0.004232331639807526, "phrase": "root_path"}, {"score": 0.003977403701783668, "phrase": "assigned_nodes"}, {"score": 0.003939565240409143, "phrase": "unassigned_nodes"}, {"score": 0.003828187766572941, "phrase": "new_node_assignment"}, {"score": 0.00349577373145384, "phrase": "node_assignments"}, {"score": 0.0032850648549389025, "phrase": "ovsf_code_assignment"}, {"score": 0.003146652729098066, "phrase": "buddy_memory_allocation"}, {"score": 0.00311669276800628, "phrase": "hypercube_subcube_allocation"}, {"score": 0.0029711052657054463, "phrase": "sorted_and_compact_configuration"}, {"score": 0.002791932344920906, "phrase": "intrinsic_tree_property"}, {"score": 0.002611010097359509, "phrase": "safe_assignment"}, {"score": 0.002488985155689794, "phrase": "fixed_set"}, {"score": 0.0024652715040303416, "phrase": "node-assignment_requests"}, {"score": 0.0021252533072727707, "phrase": "meaningful_improvements"}, {"score": 0.0021049977753042253, "phrase": "recent_results"}], "paper_keywords": ["Online algorithms", " Tree node assignment", " Competitive ratio"], "paper_abstract": "In this paper, we study the online tree node assignment problem, which is a generalization of the well studied OVSF code assignment problem. Assigned nodes in a complete binary tree must follow the rule that each leaf-to-root path must contain at most one assigned node. At times, it is necessary to swap assigned nodes with unassigned nodes in order to accommodate some new node assignment. The target of this problem is to minimize the number of swaps in satisfying a sequence of node assignments and releases. This problem is fundamental, not only to the OVSF code assignment, but also to other applications, such as buddy memory allocation and hypercube subcube allocation. All the previous solutions to this problem are based on a sorted and compact configuration by assigning the nodes linearly and level by level, ignoring the intrinsic tree property in their assignments. Our contributions are: (1) give the concept of safe assignment, which is proved to be unique for any fixed set of node-assignment requests; (2) an 8-competitive algorithm by holding the safe assignment; and (3) an improved 6-competitive variant of this algorithm. Our algorithms are simple and easy to implement and our contributions represent meaningful improvements over recent results. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Constant-competitive tree node assignment", "paper_id": "WOS:000330823500002"}