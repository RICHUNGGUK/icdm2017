{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "paraver"}, {"score": 0.00481495049065317, "phrase": "open_mpi."}, {"score": 0.00436890075128947, "phrase": "mpi_performance"}, {"score": 0.004298666679374568, "phrase": "extension_interface"}, {"score": 0.004094639048362357, "phrase": "open_mpi_implementation"}, {"score": 0.003900257249255497, "phrase": "timing_mpi-functions"}, {"score": 0.0036553070575015344, "phrase": "mpi-internal_information"}, {"score": 0.0032629585038738856, "phrase": "general_design_criteria"}, {"score": 0.0031845067058084583, "phrase": "interface_implementation"}, {"score": 0.0028890603352364273, "phrase": "performance_evaluation"}, {"score": 0.0028425481299483254, "phrase": "large-scale_applications"}, {"score": 0.002599763359352916, "phrase": "tracing_library"}, {"score": 0.002320449502337321, "phrase": "performance_bottlenecks"}, {"score": 0.0022101055924375725, "phrase": "real-world_application"}], "paper_keywords": [""], "paper_abstract": "This paper describes the implementation, usage and experience with the MPI performance revealing extension interface (Peruse) into the Open MPI implementation. While the PMPI-interface allows timing MPI-functions through wrappers, it can not provide MPI-internal information on MPI-states, and lower-level network performance. We introduce the general design criteria of the interface implementation and analyze the overhead generated by this functionality. To support performance evaluation of large-scale applications, tools for visualization are imperative. We extend the tracing library of the Paraver-toolkit to support tracing Peruse-events and show how this helps detecting performance bottlenecks. A test-suite and a real-world application are traced and visualized using Paraver.", "paper_title": "Implementation and usage of the PERUSE-interface in Open MPI", "paper_id": "WOS:000241557200038"}