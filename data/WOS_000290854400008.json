{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "semantic_atomicity"}, {"score": 0.011041260459879233, "phrase": "bridge_predicates"}, {"score": 0.0101746110354084, "phrase": "atomicity_specifications"}, {"score": 0.004777392826700429, "phrase": "multithreaded_programs"}, {"score": 0.004575977644865379, "phrase": "correct_multithreaded_programs"}, {"score": 0.004469700997700534, "phrase": "unintended_and_nondeterministic_interference"}, {"score": 0.004365881789903319, "phrase": "fundamental_correctness_property"}, {"score": 0.004052701031142039, "phrase": "parallel_execution"}, {"score": 0.0035750047462243836, "phrase": "programmer-defined_notion"}, {"score": 0.0034646205853140558, "phrase": "assertion_framework"}, {"score": 0.0033314049082500794, "phrase": "noninterference_properties"}, {"score": 0.0031534367609709264, "phrase": "novel_algorithm"}, {"score": 0.0030800962618484844, "phrase": "parallel_executions"}, {"score": 0.0030440661915657175, "phrase": "bounded_number"}, {"score": 0.0029966788947444535, "phrase": "atomic_blocks"}, {"score": 0.002825435048559866, "phrase": "sound_heuristics"}, {"score": 0.0028033523242224833, "phrase": "optional_user_annotations"}, {"score": 0.0026954938318408464, "phrase": "common_case"}, {"score": 0.002531463482341473, "phrase": "parallel_java_programs"}, {"score": 0.002472552537325606, "phrase": "semantic_atomicity_specifications"}, {"score": 0.002312960805824996, "phrase": "natural_and_intended_atomic_behavior"}, {"score": 0.002232675154416128, "phrase": "previous_approaches"}, {"score": 0.0021049977753042253, "phrase": "widely-used_java.util.concurrent_library"}], "paper_keywords": ["Algorithms", " Reliability", " Verification"], "paper_abstract": "In practice, it is quite difficult to write correct multithreaded programs due to the potential for unintended and nondeterministic interference between parallel threads. A fundamental correctness property for such programs is atomicity-a block of code in a program is atomic if, for any parallel execution of the program, there is an execution with the same overall program behavior in which the block is executed serially. We propose semantic atomicity, a generalization of atomicity with respect to a programmer-defined notion of equivalent behavior. We propose an assertion framework in which a programmer can use bridge predicates to specify noninterference properties at the level of abstraction of their application. Further, we propose a novel algorithm for systematically testing atomicity specifications on parallel executions with a bounded number of interruptions-i.e. atomic blocks whose execution is interleaved with that of other threads. We further propose a set of sound heuristics and optional user annotations that increase the efficiency of checking atomicity specifications in the common case where the specifications hold. We have implemented our assertion framework for specifying and checking semantic atomicity for parallel Java programs, and we have written semantic atomicity specifications for a number of benchmarks. We found that using bridge predicates allowed us to specify the natural and intended atomic behavior of a wider range of programs than did previous approaches. Further, in checking our specifications, we found several previously unknown bugs, including in the widely-used java.util.concurrent library.", "paper_title": "Specifying and Checking Semantic Atomicity for Multithreaded Programs", "paper_id": "WOS:000290854400008"}