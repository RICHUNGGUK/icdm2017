{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "conditional_random_fields"}, {"score": 0.0374287769677244, "phrase": "feature_interactions"}, {"score": 0.02803093454138702, "phrase": "instance_weighting"}, {"score": 0.0046073860169839305, "phrase": "flexible_and_powerful_model"}, {"score": 0.004556901872357751, "phrase": "sequence_labeling_problems"}, {"score": 0.004457579615095599, "phrase": "existing_learning_algorithms"}, {"score": 0.004265354774450696, "phrase": "large_numbers"}, {"score": 0.004218602458288531, "phrase": "potential_input_features"}, {"score": 0.004172360444377281, "phrase": "feature_combinations"}, {"score": 0.0040366412779632085, "phrase": "new_algorithm"}, {"score": 0.003992385826251404, "phrase": "training_crfs"}, {"score": 0.003948613642680196, "phrase": "gradient_tree"}, {"score": 0.0038624981944755813, "phrase": "tree_boosting"}, {"score": 0.00379914165379475, "phrase": "crf_potential_functions"}, {"score": 0.003716273882758735, "phrase": "weighted_sums"}, {"score": 0.003675517796014622, "phrase": "regression_trees"}, {"score": 0.0035953368057880593, "phrase": "compact_representations"}, {"score": 0.0033651019362620866, "phrase": "potentially_large_parameter_space"}, {"score": 0.0030808211830129304, "phrase": "markov_model"}, {"score": 0.002851790448644913, "phrase": "previous_algorithms"}, {"score": 0.00280496585980086, "phrase": "iterative_scaling"}, {"score": 0.0027741761880779535, "phrase": "gradient_descent"}, {"score": 0.0027437235598539904, "phrase": "gradient_tree_boosting"}, {"score": 0.002539689093411356, "phrase": "surrogate_splitting"}, {"score": 0.002484237236156446, "phrase": "cart"}, {"score": 0.0024299678474208023, "phrase": "missing_values"}, {"score": 0.00240328454980006, "phrase": "experimental_studies"}, {"score": 0.002261666793030715, "phrase": "standard_imputation"}, {"score": 0.0022368274529152342, "phrase": "indicator_feature_methods"}, {"score": 0.0021520139248317333, "phrase": "best_method"}, {"score": 0.0021049977753042253, "phrase": "feature_values"}], "paper_keywords": ["sequential supervised learning", " conditional random fields", " functional gradient", " gradient tree boosting", " missing values"], "paper_abstract": "Conditional random fields (CRFs) provide a flexible and powerful model for sequence labeling problems. However, existing learning algorithms are slow, particularly in problems with large numbers of potential input features and feature combinations. This paper describes a new algorithm for training CRFs via gradient tree boosting. In tree boosting, the CRF potential functions are represented as weighted sums of regression trees, which provide compact representations of feature interactions. So the algorithm does not explicitly consider the potentially large parameter space. As a result, gradient tree boosting scales linearly in the order of the Markov model and in the order of the feature interactions, rather than exponentially as in previous algorithms based on iterative scaling and gradient descent. Gradient tree boosting also makes it possible to use instance weighting (as in C4.5) and surrogate splitting (as in CART) to handle missing values. Experimental studies of the effectiveness of these two methods (as well as standard imputation and indicator feature methods) show that instance weighting is the best method in most cases when feature values are missing at random.", "paper_title": "Gradient Tree Boosting for Training Conditional Random Fields", "paper_id": "WOS:000262637300003"}