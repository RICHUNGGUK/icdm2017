{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_programs"}, {"score": 0.004208282550386197, "phrase": "weaker_property"}, {"score": 0.0041316803676012155, "phrase": "usual_expectation"}, {"score": 0.0038154673253945003, "phrase": "lock-free_programs"}, {"score": 0.003545024951402821, "phrase": "multiprocessor_architectures"}, {"score": 0.003501846136829077, "phrase": "lock-based_algorithms"}, {"score": 0.003417054482155433, "phrase": "lock-free_algorithms"}, {"score": 0.002224510044064184, "phrase": "pvs_theorem_prover"}, {"score": 0.0021441057555396013, "phrase": "proof_strategies"}, {"score": 0.0021049977753042253, "phrase": "user_interaction"}], "paper_keywords": ["Lock-free programs", " Concurrency", " Verification", " Temporal logic"], "paper_abstract": "Lock-freedom is a property of concurrent programs which states that, from any state of the program, eventually some process will complete its operation. Lock-freedom is a weaker property than the usual expectation that eventually all processes will complete their operations. By weakening their completion guarantees, lock-free programs increase the potential for parallelism, and hence make more efficient Use Of Multiprocessor architectures than lock-based algorithms. However, lock-free algorithms, and reasoning about them, are considerably more complex. In this paper we present a technique for proving that a program is lock-free. The technique is designed to be as general as possible and is guided by heuristics that simplify the proofs. We demonstrate our theory by proving lock-freedom of two non-trivial examples from the literature. The proofs have been machine-checked by the PVS theorem prover, and we have developed proof strategies to minimise user interaction. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "A general technique for proving lock-freedom", "paper_id": "WOS:000263021600004"}