{"auto_keywords": [{"score": 0.042059460565509646, "phrase": "purging-range_query"}, {"score": 0.0293534465139414, "phrase": "fbp"}, {"score": 0.014167691214588963, "phrase": "flash_memory"}, {"score": 0.013972513200673184, "phrase": "free_blocks"}, {"score": 0.013827871488191581, "phrase": "new_data_versions"}, {"score": 0.01272267985922204, "phrase": "old_data_versions"}, {"score": 0.010544922294267114, "phrase": "data_versions"}, {"score": 0.010399126081142138, "phrase": "wear_levels"}, {"score": 0.00481495049065317, "phrase": "multi-version_indexed_data"}, {"score": 0.004698392162272106, "phrase": "multi-version_index"}, {"score": 0.0045208777171271254, "phrase": "invalid_pages"}, {"score": 0.004395984840790689, "phrase": "efficient_garbage_collection_mechanism"}, {"score": 0.004304574865291508, "phrase": "sufficient_number"}, {"score": 0.004069963083642548, "phrase": "important_performance_issues"}, {"score": 0.003861596041315646, "phrase": "invalid_index_entries"}, {"score": 0.003525291235622844, "phrase": "purging_version_number"}, {"score": 0.0033447157263095223, "phrase": "garbage_collection_process"}, {"score": 0.0028664985822266344, "phrase": "free_pages"}, {"score": 0.0028068030356445894, "phrase": "performance_studies"}, {"score": 0.00256225327577508, "phrase": "rr"}, {"score": 0.0025264171945423254, "phrase": "page_reallocation_cost"}, {"score": 0.0023551955270737215, "phrase": "experimental_results"}, {"score": 0.0023223687707168155, "phrase": "pbl"}, {"score": 0.0021878600131802453, "phrase": "required_number"}, {"score": 0.002149799391146313, "phrase": "garbage_collection"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Flash memory", " Garbage collection", " Multi-version index", " Multi-version data", " Flash-based embedded database"], "paper_abstract": "Maintaining a multi-version index on flash memory could generate a lot of updates and invalid pages. It is important to have an efficient garbage collection mechanism to ensure the flash memory has sufficient number of free blocks for storing new data versions and their index structures. In this paper, we study the important performance issues in using the purging-range query to reclaim the blocks, which are storing old data versions and invalid index entries, to be free blocks. To reduce the cost for processing the purging-range query, we propose the physical block labeling (PBL) scheme to provide a better estimation on the purging version number to be used for purging old data versions. To further enhance the performance of the garbage collection process, and at the same time to maximize the deadspans of data versions and balance the wear levels of the blocks, we propose two schemes called, the sequential placement (SQ) and frequency-based placement (FBP), for placing new data versions into free pages. As illustrated in the performance studies, both SQ and FBP can effectively balance the wear levels of the blocks. The deadspans of data versions are longer under FBP than both SQ and RR, and the page reallocation cost is also lower under FBP especially when the size of flash memory allocated for the database is limited. The experimental results also illustrate that PBL can effectively minimize the number of invocations of the purging-range query to be one to reclaim the required number of blocks in each garbage collection. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Garbage collection of multi-version indexed data on flash memory", "paper_id": "WOS:000343626900002"}