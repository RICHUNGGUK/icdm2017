{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "wait_states"}, {"score": 0.004752221133109136, "phrase": "massively_parallel_applications"}, {"score": 0.00462919213721188, "phrase": "message-passing_applications"}, {"score": 0.004086744751579196, "phrase": "synchronization_points"}, {"score": 0.003954837422946628, "phrase": "first_step"}, {"score": 0.003852371777780562, "phrase": "performance_impact"}, {"score": 0.0035141291835319682, "phrase": "searching_event_traces"}, {"score": 0.003468287913322255, "phrase": "characteristic_patterns"}, {"score": 0.0031223774204093713, "phrase": "scalable_approach"}, {"score": 0.003021502415143067, "phrase": "parallel_replay"}, {"score": 0.002962543869356265, "phrase": "target_application's_communication_behavior"}, {"score": 0.0027741761880779535, "phrase": "previously_inaccessible_scale"}, {"score": 0.0026321198895843173, "phrase": "even_larger_configurations"}, {"score": 0.0024485643104830814, "phrase": "comprehensive_parallel_tool_architecture"}, {"score": 0.0022628564592874147, "phrase": "major_fraction"}, {"score": 0.002218668420806254, "phrase": "execution_time"}, {"score": 0.0021896891011033105, "phrase": "larger_scales"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Performance analysis", " Scalability", " Event tracing", " Pattern search"], "paper_abstract": "When scaling message-passing applications to thousands of processors, their performance is often affected by wait states that occur when processes fail to reach synchronization points simultaneously. As a first step in reducing the performance impact, we have shown in our earlier work that wait states can be diagnosed by searching event traces for characteristic patterns. However, our initial sequential search method did not scale beyond several hundred processes. Here, we present a scalable approach, based on a parallel replay of the target application's communication behavior, that can efficiently identify wait states at the previously inaccessible scale of 65,536 processes and that has potential for even larger configurations. We explain how our new approach has been integrated into a comprehensive parallel tool architecture, which we use to demonstrate that wait states may consume a major fraction of the execution time at larger scales. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "A scalable tool architecture for diagnosing wait states in massively parallel applications", "paper_id": "WOS:000268438000001"}