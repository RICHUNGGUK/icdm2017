{"auto_keywords": [{"score": 0.046301804206836855, "phrase": "sequential_proof"}, {"score": 0.045195294750025594, "phrase": "separation_logic"}, {"score": 0.004549242970806199, "phrase": "potential_parallelization_opportunities"}, {"score": 0.004191007935893067, "phrase": "correctly-synchronized_parallelized_program"}, {"score": 0.003984665807155269, "phrase": "previous_work"}, {"score": 0.0038365781437074017, "phrase": "independence_analysis"}, {"score": 0.0037409118365761894, "phrase": "synchronization_constructs"}, {"score": 0.0036707250689857348, "phrase": "relevant_dependencies"}, {"score": 0.003579179502431823, "phrase": "sequential_program"}, {"score": 0.0034028574973016933, "phrase": "naive_translation"}, {"score": 0.0032556926399045635, "phrase": "fine-grained_patterns"}, {"score": 0.0031346115554600003, "phrase": "straightforward_points"}, {"score": 0.002851189848197057, "phrase": "different_parts"}, {"score": 0.0027106334164712057, "phrase": "discovered_dependencies"}, {"score": 0.002609770322855842, "phrase": "synchronization_primitives"}, {"score": 0.002560751416355291, "phrase": "parallelized_program"}, {"score": 0.002449915958738505, "phrase": "resulting_parallelized_program"}, {"score": 0.0023587312574818208, "phrase": "original_sequential_program"}, {"score": 0.0021049977753042253, "phrase": "separation_logic_tools"}], "paper_keywords": ["Languages", " Theory", " Verification", " Separation Logic", " Abduction", " Frame Inference", " Deterministic Parallelism"], "paper_abstract": "We present an analysis which takes as its input a sequential program, augmented with annotations indicating potential parallelization opportunities, and a sequential proof, written in separation logic, and produces a correctly-synchronized parallelized program and proof of that program. Unlike previous work, ours is not an independence analysis; we insert synchronization constructs to preserve relevant dependencies found in the sequential program that may otherwise be violated by a naive translation. Separation logic allows us to parallelize fine-grained patterns of resource-usage, moving beyond straightforward points-to analysis. Our analysis works by using the sequential proof to discover dependencies between different parts of the program. It leverages these discovered dependencies to guide the insertion of synchronization primitives into the parallelized program, and to ensure that the resulting parallelized program satisfies the same specification as the original sequential program, and exhibits the same sequential behaviour. Our analysis is built using frame inference and abduction, two techniques supported by an increasing number of separation logic tools.", "paper_title": "Resource-Sensitive Synchronization Inference by Abduction", "paper_id": "WOS:000300548100024"}