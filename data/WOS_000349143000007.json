{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "lambda_calculus"}, {"score": 0.033252450698570545, "phrase": "maximally_compact_form"}, {"score": 0.004498393285602365, "phrase": "reduction_work"}, {"score": 0.004303830426772906, "phrase": "maximal_degree"}, {"score": 0.003979907786856535, "phrase": "maximal_compactness"}, {"score": 0.003680274684654909, "phrase": "graph_semantics"}, {"score": 0.0036058769733410614, "phrase": "first-order_term_graphs"}, {"score": 0.003426373820419672, "phrase": "term_graph_interpretations"}, {"score": 0.0033685408148574846, "phrase": "term_graphs"}, {"score": 0.0033004240095380623, "phrase": "functional_bisimulation"}, {"score": 0.003255777265493076, "phrase": "practical_and_efficient_methods"}, {"score": 0.002755338691613447, "phrase": "maximally_shared_form"}, {"score": 0.0026002844796442818, "phrase": "term_graph_g"}, {"score": 0.0024623110626032364, "phrase": "maximally_shared_term_graph"}, {"score": 0.0021049977753042253, "phrase": "readily_usable_implementation"}], "paper_keywords": ["Lambda Calculus with letrec", " unfolding semantics", " subterm sharing", " maximal sharing", " higher-order term graphs"], "paper_abstract": "Increasing sharing in programs is desirable to compactify the code, and to avoid duplication of reduction work at run-time, thereby speeding up execution. We show how a maximal degree of sharing can be obtained for programs expressed as terms in the lambda calculus with letrec. We introduce a notion of 'maximal compactness' for lambda(letrec)-terms among all terms with the same infinite unfolding. Instead of defined purely syntactically, this notion is based on a graph semantics. lambda(letrec)-terms are interpreted as first-order term graphs so that unfolding equivalence between terms is preserved and reflected through bisimilarity of the term graph interpretations. Compactness of the term graphs can then be compared via functional bisimulation. We describe practical and efficient methods for the following two problems: transforming a lambda(letrec)-term into a maximally compact form; and deciding whether two lambda(letrec)-terms are unfolding-equivalent. The transformation of a lambda(letrec)-term L into maximally compact form L-0 proceeds in three steps: (i) translate L into its term graph G = [L]; (ii) compute the maximally shared form of G as its bisimulation collapse G(0); (iii) read back a lambda(letrec)-term L-0 from the term graph G 0 with the property [L-0] = G(0). Then L-0 represents a maximally shared term graph, and it has the same unfolding as L. The procedure for deciding whether two given lambda(letrec)-terms L-1 and L-2 are unfolding-equivalent computes their term graph interpretations [L-1] and [L-2], and checks whether these are bisimilar. For illustration, we also provide a readily usable implementation.", "paper_title": "Maximal Sharing in the Lambda Calculus with letrec", "paper_id": "WOS:000349143000007"}