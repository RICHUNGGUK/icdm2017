{"auto_keywords": [{"score": 0.030660592326805094, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "theoretical_foundation"}, {"score": 0.004739056045644449, "phrase": "program_extraction"}, {"score": 0.004664352260912174, "phrase": "inductive_and_coinductive_proofs"}, {"score": 0.004554488671294504, "phrase": "practical_applications"}, {"score": 0.004240116703465252, "phrase": "inductive_and_coinductive_definitions"}, {"score": 0.004140203942496321, "phrase": "realizability_interpretation"}, {"score": 0.004074901471704325, "phrase": "first-order_proofs"}, {"score": 0.0036167509502276294, "phrase": "non-trivial_provably_correct_programs"}, {"score": 0.00347574024760684, "phrase": "exact_real_number_computation"}, {"score": 0.0031342307827666675, "phrase": "polymorphic_recursive_types"}, {"score": 0.003036040409062437, "phrase": "valid_programs"}, {"score": 0.002964415652865295, "phrase": "lazy_functional_programming_language"}, {"score": 0.0026307897899760383, "phrase": "perpetual_processes"}, {"score": 0.0025892330566358503, "phrase": "infinite_streams"}, {"score": 0.002508073621696602, "phrase": "typical_applications"}, {"score": 0.002391067964886602, "phrase": "exact_real_arithmetic"}], "paper_keywords": ["Program extraction", " Realizability", " Coinduction", " Verified programs", " Exact real number computation"], "paper_abstract": "The objective of this paper is to provide a theoretical foundation for program extraction from inductive and coinductive proofs geared to practical applications. The novelties consist in the addition of inductive and coinductive definitions to a realizability interpretation for first-order proofs, a soundness proof for this system, and applications to the synthesis of non-trivial provably correct programs in the area of exact real number computation. We show that realizers, although per se untyped, can be assigned polymorphic recursive types and hence represent valid programs in a lazy functional programming language such as Haskell. Programs extracted from proofs using coinduction can be understood as perpetual processes producing infinite streams of data. Typical applications of such processes are computations in exact real arithmetic. As an example we show how to extract a program computing the average of two real numbers w.r.t. the binary signed digit representation.", "paper_title": "Proofs, Programs, Processes", "paper_id": "WOS:000308697300005"}