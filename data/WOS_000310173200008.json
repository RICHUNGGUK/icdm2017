{"auto_keywords": [{"score": 0.04954517773618333, "phrase": "hash_function"}, {"score": 0.044023410914771945, "phrase": "perfect_hash_function"}, {"score": 0.043551591265386116, "phrase": "set_s_subset"}, {"score": 0.00481495049065317, "phrase": "nearly_optimal_space"}, {"score": 0.004655640997424794, "phrase": "key_universe"}, {"score": 0.004256005669252138, "phrase": "range's_size"}, {"score": 0.003890540531028228, "phrase": "vertical_bar_s_vertical_bar"}, {"score": 0.0038471128411102914, "phrase": "minimal_perfect_hash_function"}, {"score": 0.00366443843576107, "phrase": "minimum_size"}, {"score": 0.0034514309280805106, "phrase": "practical_performance"}, {"score": 0.003287482882222731, "phrase": "data_structure"}, {"score": 0.0029271812818615042, "phrase": "small_constant_factor"}, {"score": 0.0028944757265206332, "phrase": "theoretical_lower_bounds"}, {"score": 0.002685558057339722, "phrase": "practical_solution"}, {"score": 0.002567498166608835, "phrase": "membership_problem"}, {"score": 0.0024000447011533078, "phrase": "memory_hierarchy"}, {"score": 0.0022773736136311056, "phrase": "commodity_pc."}, {"score": 0.002260367486652148, "phrase": "open_source_implementation"}, {"score": 0.002177218756653181, "phrase": "gnu_lesser_general_public_license"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Perfect hash functions", " Randomized algorithms", " Random graphs", " Large key sets"], "paper_abstract": "A hash function is a mapping from a key universe U to a range of integers, i.e., h: U bar right arrow {0, 1, . . . , m-1}, where m is the range's size. A perfect hash function for some set S subset of U is a hash function that is one-to-one on S. where m >= vertical bar S vertical bar. A minimal perfect hash function for some set S subset of U is a perfect hash function with a range of minimum size, i.e., m = vertical bar S vertical bar. This paper presents a construction for (minimal) perfect hash functions that combines theoretical analysis, practical performance, expected linear construction time and nearly optimal space consumption for the data structure. For n keys and m = n the space consumption ranges from 2.62n + o(n) to 3.3n + o(n) bits, and for m = 1.23n it ranges from 1.95n + o(n) to 2.7n + o(n) bits. This is within a small constant factor from the theoretical lower bounds of 1.44n bits for m = n and 0.89n bits for m = 1.23n. We combine several theoretical results into a practical solution that has turned perfect hashing into a very compact data structure to solve the membership problem when the key set S is static and known in advance. By taking into account the memory hierarchy we can construct (minimal) perfect hash functions for over a billion keys in 46 min using a commodity PC. An open source implementation of the algorithms is available at http://cmph.sf.net under the GNU Lesser General Public License (LGPL). (c) 2012 Elsevier Ltd. All rights reserved.", "paper_title": "Practical perfect hashing in nearly optimal space", "paper_id": "WOS:000310173200008"}