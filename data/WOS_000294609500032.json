{"auto_keywords": [{"score": 0.04840115289905245, "phrase": "user_threads"}, {"score": 0.015719716506582538, "phrase": "lock-free_data_structures"}, {"score": 0.013811001414417264, "phrase": "software_cruising"}, {"score": 0.0045370785151713396, "phrase": "protected_programs"}, {"score": 0.004483450050677258, "phrase": "inlined_resource_reclamation"}, {"score": 0.004404188306112211, "phrase": "program_execution"}, {"score": 0.004326321719714357, "phrase": "resource_release"}, {"score": 0.004052358316137446, "phrase": "security_enforcement"}, {"score": 0.004004436217742343, "phrase": "resource_reclamation"}, {"score": 0.0038870860864224656, "phrase": "concurrent_monitor_thread"}, {"score": 0.0037507793596022326, "phrase": "increasingly_popular_multicore"}, {"score": 0.003706410380455668, "phrase": "multiprocessor_architectures"}, {"score": 0.003576416581189716, "phrase": "non-blocking_and_efficient_synchronization"}, {"score": 0.0033898953358387075, "phrase": "case_study"}, {"score": 0.003251552926963083, "phrase": "heap_buffer_overflow_problem"}, {"score": 0.0031561961485589633, "phrase": "detection_techniques"}, {"score": 0.003045440856986832, "phrase": "high_performance_overhead"}, {"score": 0.003009390313137981, "phrase": "legacy_code_compatibility"}, {"score": 0.0029737652463012318, "phrase": "semantics_loyalty"}, {"score": 0.002921114512115261, "phrase": "tedious_manual_program_transformation"}, {"score": 0.0028354207806133153, "phrase": "concurrent_heap_buffer_overflow_detector"}, {"score": 0.002801849371896573, "phrase": "cruiser"}, {"score": 0.002719644855867468, "phrase": "concurrent_thread"}, {"score": 0.002639845784408318, "phrase": "user_program"}, {"score": 0.002593091742792519, "phrase": "heap_integrity"}, {"score": 0.0025471636425006155, "phrase": "custom_lock-free_data_structures"}, {"score": 0.0024431289979171505, "phrase": "high_efficiency"}, {"score": 0.00213023743193503, "phrase": "throughput_slowdown"}, {"score": 0.002105001223721092, "phrase": "apache"}], "paper_keywords": ["Security", " Verification", " Languages", " Algorithms", " Software cruising", " buffer overflow", " program monitor", " multicore", " concurrency", " lock-free", " non-blocking algorithms"], "paper_abstract": "Security enforcement inlined into user threads often delays the protected programs; inlined resource reclamation may interrupt program execution and defer resource release. We propose software cruising, a novel technique that migrates security enforcement and resource reclamation from user threads to a concurrent monitor thread. The technique leverages the increasingly popular multicore and multiprocessor architectures and uses lock-free data structures to achieve non-blocking and efficient synchronization between the monitor and user threads. As a case study, software cruising is applied to the heap buffer overflow problem. Previous mitigation and detection techniques for this problem suffer from high performance overhead, legacy code compatibility, semantics loyalty, or tedious manual program transformation. We present a concurrent heap buffer overflow detector, CRUISER, in which a concurrent thread is added to the user program to monitor heap integrity, and custom lock-free data structures and algorithms are designed to achieve high efficiency and scalability. The experiments show that our approach is practical: it imposes an average of 5% performance overhead on SPEC CPU2006, and the throughput slowdown on Apache is negligible on average.", "paper_title": "Cruiser: Concurrent Heap Buffer Overflow Monitoring Using Lock-free Data Structures", "paper_id": "WOS:000294609500032"}