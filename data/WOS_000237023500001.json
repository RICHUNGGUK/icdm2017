{"auto_keywords": [{"score": 0.03952587045198138, "phrase": "asynchronous_system"}, {"score": 0.014931458417408833, "phrase": "synchronous_system"}, {"score": 0.00481495049065317, "phrase": "distributed_problem"}, {"score": 0.004475131673122001, "phrase": "full_classification"}, {"score": 0.004381296237718528, "phrase": "asynchronous_and_synchronous_models"}, {"score": 0.00399423294850375, "phrase": "possible_input_vectors"}, {"score": 0.003955926499405168, "phrase": "con_dition_c_e"}, {"score": 0.0037049712861659486, "phrase": "known_hierarchy"}, {"score": 0.003662361128867112, "phrase": "asynchronous_consensus"}, {"score": 0.003377454876085108, "phrase": "synchronous_consensus"}, {"score": 0.0032246835734680377, "phrase": "borderline_case"}, {"score": 0.003072867633896303, "phrase": "complete_hierarchy"}, {"score": 0.002973723971531988, "phrase": "main_result"}, {"score": 0.0029508634185805445, "phrase": "necessary_and_sufficient_number"}, {"score": 0.0029169007179202164, "phrase": "uniform_consensus"}, {"score": 0.0027159094186967247, "phrase": "generic_synchronous_early-deciding_uniform_consensus_protocol"}, {"score": 0.0026486202711759077, "phrase": "actual_crashes"}, {"score": 0.0021049977753042253, "phrase": "worst_case"}], "paper_keywords": ["consensus", " early deciding", " input vector", " process crash failure", " synchronous distributed system"], "paper_abstract": "The condition-based approach studies restrictions on the inputs to a distributed problem, called conditions, that facilitate its solution. Previous work considered mostly the asynchronous model of computation. This paper studies conditions for consensus in a synchronous system where processes can fail by crashing. It describes a full classification of conditions for consensus, establishing a continuum between the asynchronous and synchronous models, with the following hierarchy S-t([-i]) subset of (...) S-t([0]) subset of (...) subset of S-t([i]) where S-t([i]) includes all conditions (and in particular the trivial one made up of all possible input vectors). For a con dition C E St, t <= d <= t, we have: For values of d <= 0 consensus is solvable in an asynchronous system with t failures, and we obtain the known hierarchy of conditions that allows solving asynchronous consensus with more and more efficient protocols as we go from d = 0 to d = -t. For values of d > 0 consensus is known not solvable in an asynchronous system with t failures, but we obtain a hierarchy of conditions that allows solving synchronous consensus with protocols that can take more and more rounds, as we go from d = 0 to d = t. d = 0 is the borderline case where consensus can be solved in an asynchronous system with t failures, and can be solved optimally in a synchronous system. After having established the complete hierarchy, the paper concentrates on the two last items: 0 <= d <= t. The main result is that the necessary and sufficient number of rounds needed to solve uniform consensus for a condition C is an element of S-i([d]) (such that C is not an element of S-i([d-1])) is d + 1. In more detail, the paper presents a generic synchronous early-deciding uniform consensus protocol that enjoys the following properties. Let f be the number of actual crashes, I the input vector and C is an element of S-t([d]) the condition the protocol is instantiated with. The protocol terminates in two rounds when I is an element of C and f <= t - d, and in at most d + 1 rounds when I is an element of C and f > t - d. (It also terminates in one round when I is an element of C and d = f = 0.) Moreover, whether I belongs or not to C, no process requires more than min(t + 1, f + 2) rounds to decide. The paper then proves a corresponding lower bound stating that at least d + I rounds are necessary to get a decision in the worst case when I is an element of C (for C is an element of S-t([d]) and C is not an element of S-t([d-1])).", "paper_title": "Synchronous condition-based consensus", "paper_id": "WOS:000237023500001"}