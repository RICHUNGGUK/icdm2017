{"auto_keywords": [{"score": 0.0283693605925834, "phrase": "average_speedup"}, {"score": 0.009948701439628968, "phrase": "loosely_coupled_processors"}, {"score": 0.00893268467705313, "phrase": "application_and_helper_threads"}, {"score": 0.00748982600592301, "phrase": "helper_thread"}, {"score": 0.00481495049065317, "phrase": "helper_threads"}, {"score": 0.0046276016230633495, "phrase": "helper_thread_prefetching_scheme"}, {"score": 0.003877404180794398, "phrase": "interprocessor_communication"}, {"score": 0.0036729522133392175, "phrase": "large_loop-based_code_regions"}, {"score": 0.0035942114996235803, "phrase": "new_synchronization_mechanism"}, {"score": 0.0033076455392068095, "phrase": "application_thread"}, {"score": 0.003190265467214105, "phrase": "prefetching_timeliness"}, {"score": 0.0031558679589831287, "phrase": "cache_pollution"}, {"score": 0.003065938050346064, "phrase": "loosely_coupled_system"}, {"score": 0.0029252191241632888, "phrase": "standard_unmodified_cmp_system"}, {"score": 0.0028936710552719806, "phrase": "intelligent_memory_system"}, {"score": 0.002862462250995423, "phrase": "simple_processor"}, {"score": 0.002760836859397696, "phrase": "nine_memory-intensive_applications"}, {"score": 0.002549749054599413, "phrase": "conventional_processor-side"}, {"score": 0.002423882939663573, "phrase": "standard_cmp"}, {"score": 0.002320943211698446, "phrase": "real_cmp_system"}], "paper_keywords": ["Helper thread", " prefetching", " chip multiprocessors", " processing-in-memory system"], "paper_abstract": "This paper presents a helper thread prefetching scheme that is designed to work on loosely coupled processors, such as in a standard chip multiprocessor (CMP) system or an intelligent memory system. Loosely coupled processors have an advantage in that resources such as processor and L1 cache resources are not contended by the application and helper threads, hence preserving the speed of the application. However, interprocessor communication is expensive in such a system. We present techniques to alleviate this. Our approach exploits large loop-based code regions and is based on a new synchronization mechanism between the application and helper threads. This mechanism precisely controls how far ahead the execution of the helper thread can be with respect to the application thread. We found that this is important in ensuring prefetching timeliness and avoiding cache pollution. To demonstrate that prefetching in a loosely coupled system can be done effectively, we evaluate our prefetching by simulating a standard unmodified CMP system and an intelligent memory system where a simple processor in memory executes the helper thread. Evaluating our scheme with nine memory-intensive applications with the memory processor in DRAM achieves an average speedup of 1.25. Moreover, our scheme works well in combination with a conventional processor-side sequential L1 prefetcher, resulting in an average speedup of 1.31. In a standard CMP, the scheme achieves an average speedup of 1.33. Using a real CMP system with a shared L2 cache between two cores, our helper thread prefetching plus hardware L2 prefetching achieves an average speedup of 1.15 over the hardware L2 prefetching for the subset of applications with high L2 cache misses per cycle.", "paper_title": "Prefetching with Helper Threads for Loosely Coupled Multiprocessor Systems", "paper_id": "WOS:000268086400007"}