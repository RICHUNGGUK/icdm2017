{"auto_keywords": [{"score": 0.04366909172920831, "phrase": "metric"}, {"score": 0.00481495049065317, "phrase": "dynamic_binary"}, {"score": 0.004714023408114857, "phrase": "cache_inefficiencies"}, {"score": 0.004615202066192795, "phrase": "diverging_improvements"}, {"score": 0.004566567411073082, "phrase": "cpu_speeds"}, {"score": 0.004518442937844318, "phrase": "memory_access_latencies"}, {"score": 0.004400329132129292, "phrase": "memory_access_bottlenecks"}, {"score": 0.0039369107163201855, "phrase": "partial_access"}, {"score": 0.0038339398365449507, "phrase": "access_traces"}, {"score": 0.0037336520904376687, "phrase": "special_compiler"}, {"score": 0.0036942726653704213, "phrase": "linker_support"}, {"score": 0.0034299649219748513, "phrase": "partial_access_traces"}, {"score": 0.003375826910838081, "phrase": "dynamic_binary_rewriting"}, {"score": 0.003322540556404882, "phrase": "executing_application"}, {"score": 0.0032014433546265694, "phrase": "novel_algorithm"}, {"score": 0.0030521898646210413, "phrase": "constant_space_representations"}, {"score": 0.0030199761431186434, "phrase": "regular_accesses"}, {"score": 0.0029722900280316216, "phrase": "nested_loop_structures"}, {"score": 0.002833689453299307, "phrase": "offline_incremental_memory_hierarchy_simulation"}, {"score": 0.0027741761880779535, "phrase": "symbolic_information"}, {"score": 0.0026307897899760383, "phrase": "detailed_source-code"}, {"score": 0.002575526825728026, "phrase": "per-reference_metrics"}, {"score": 0.002548331088496964, "phrase": "cache_evictor_information"}, {"score": 0.0022916428586256723, "phrase": "memory_access_inefficiencies"}, {"score": 0.002231607958228148, "phrase": "potential_advantage"}, {"score": 0.0021847119298612264, "phrase": "compile-time_analysis"}, {"score": 0.0021049977753042253, "phrase": "interprocedural_analysis"}], "paper_keywords": ["algorithms", " languages", " performance", " dynamic binary rewriting", " program instrumentation", " data trace generation", " data trace compression", " cache analysis"], "paper_abstract": "With the diverging improvements in CPU speeds and memory access latencies, detecting and removing memory access bottlenecks becomes increasingly important. In this work we present METRIC, a software framework for isolating and understanding such bottlenecks using partial access traces. METRIC extracts access traces from executing programs without special compiler or linker support. We make four primary contributions. First, we present a framework for extracting partial access traces based on dynamic binary rewriting of the executing application. Second, we introduce a novel algorithm for compressing these traces. The algorithm generates constant space representations for regular accesses occurring in nested loop structures. Third, we use these traces for offline incremental memory hierarchy simulation. We extract symbolic information from the application executable and use this to generate detailed source-code correlated statistics including per-reference metrics, cache evictor information, and stream metrics. Finally, we demonstrate how this information can be used to isolate and understand memory access inefficiencies. This illustrates a potential advantage of METRIC over compile-time analysis for sample codes, particularly when interprocedural analysis is required.", "paper_title": "METRIC: Memory tracing via dynamic binary rewriting to identify cache inefficiencies", "paper_id": "WOS:000246013700006"}