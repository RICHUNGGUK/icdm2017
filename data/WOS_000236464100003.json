{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "polynomial_identities"}, {"score": 0.004714023408114857, "phrase": "programming_languages"}, {"score": 0.004648105242760093, "phrase": "turing"}, {"score": 0.003950846696972114, "phrase": "abstract_interpretation"}, {"score": 0.0038407203087210775, "phrase": "approximate_methods"}, {"score": 0.0036553070575015344, "phrase": "program_property"}, {"score": 0.0027546167254869493, "phrase": "integer_variables"}, {"score": 0.0024251568696803177, "phrase": "current_approaches"}, {"score": 0.002196342933346204, "phrase": "weakest_precondition_computations"}, {"score": 0.0021049977753042253, "phrase": "equality_guards"}], "paper_keywords": [""], "paper_abstract": "Since programming languages are Turing complete, it is impossible to decide for all programs whether a given non-trivial semantic property is valid or not. The way-out chosen by abstract interpretation is to provide approximate methods which may fail to certify a program property on some programs. Precision of the analysis can be measured by providing classes of programs for which the analysis is complete, i.e., decides the property in question. Here, we consider analyses of polynomial identities between integer variables such as x(1) (.) x(2) - 2X(3) = 0. We describe current approaches and clarify their completeness properties. We also present an extension of our approach based on weakest precondition computations to programs with procedures and equality guards.", "paper_title": "Interprocedurally analyzing polynomial identities", "paper_id": "WOS:000236464100003"}