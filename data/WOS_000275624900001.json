{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "csp"}, {"score": 0.004762481202423542, "phrase": "ccs._automata_theory"}, {"score": 0.004212317183063866, "phrase": "well-known_isomorphism"}, {"score": 0.004166387393691745, "phrase": "finite_deterministic_automata"}, {"score": 0.004067089834361745, "phrase": "non-deterministic_automata"}, {"score": 0.004022737161582054, "phrase": "process_algebra"}, {"score": 0.003987602129769316, "phrase": "appropriate_link"}, {"score": 0.003970149400015176, "phrase": "transition_systems"}, {"score": 0.003534641887775044, "phrase": "automata"}, {"score": 0.003450094666968569, "phrase": "set_inclusion"}, {"score": 0.0033457111585338713, "phrase": "different_choices"}, {"score": 0.0033310584280962234, "phrase": "basic_event"}, {"score": 0.002965229277927781, "phrase": "above-mentioned_versions"}, {"score": 0.002850329791402431, "phrase": "chosen_ordering"}, {"score": 0.0027338603905940153, "phrase": "transition_system"}, {"score": 0.002656917527407142, "phrase": "additional_transitions"}, {"score": 0.002604918317803036, "phrase": "transition_rule"}, {"score": 0.002570817338292482, "phrase": "operational_semantics"}, {"score": 0.002537161639036432, "phrase": "familiar_technique"}, {"score": 0.002482042640531416, "phrase": "relational_calculus"}, {"score": 0.002401595808772413, "phrase": "reactive_system_programming"}, {"score": 0.0022434880661725493, "phrase": "transition_network"}, {"score": 0.0022238584942804473, "phrase": "theorem-proving_tools"}, {"score": 0.0021329330368641906, "phrase": "observable_events"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Unifying theories of programming", " Process algebra", " CCS", " CSP", " Retraction"], "paper_abstract": "Automata theory provides two ways of defining an automaton: either by its transition system, defining its states and events, or by its language, the set of sequences (traces) of events in which it can engage. For many classes of automaton, these forms of definition have been proved equivalent. For example, there is a well-known isomorphism between regular languages and finite deterministic automata. This paper suggests that for (demonically) the non-deterministic automata (as treated in process algebra), the appropriate link between transition systems and languages may be a retraction rather than an isomorphism. A pair of automata, defined in the tradition of CCS by their transition systems, may be compared by a pre-ordering based on some kind of simulation or bisimulation, for example, weak, strong, or barbed. Automata defined in the tradition of CSP are naturally ordered by set inclusion of their languages (often called refinement): variations in ordering arise from different choices of basic event, including for example, refusals and divergences. In both cases, we characterise a theory by its underlying transition system and its choice of ordering. Our treatment is therefore wholly semantic, independent of the syntax and definition of operators of the calculus. We put forward a series of retractions relating the above-mentioned versions of CSP to their corresponding CCS transition models. A retraction is an injection that is (with respect to the chosen ordering) monotonic, increasing and idempotent (up to equivalence). It maps the nodes of a transition system of its source theory to those of a system that has been saturated by additional transitions. Each retraction will be defined by a transition rule, in the style of operational semantics; the proofs use the familiar technique of co-induction, often abbreviated by encoding in the relational calculus. The aim of this paper is to contribute to unification of theories of reactive system programming. More practical benefits may follow. For example, we justify a method to improve the efficiency of model checking based on simulation. Furthermore, we show how model checking of a transition network fits consistently with theorem-proving tools, which reason directly about specifications and designs that are expressed in terms of sets of sequences of observable events. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "CSP is a retract of CCS", "paper_id": "WOS:000275624900001"}