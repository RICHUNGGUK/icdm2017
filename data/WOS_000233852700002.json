{"auto_keywords": [{"score": 0.03676553571971632, "phrase": "paotr"}, {"score": 0.02828677433305066, "phrase": "optimal_strategy"}, {"score": 0.00481495049065317, "phrase": "optimal_satisficing_strategies"}, {"score": 0.004702044126663035, "phrase": "specified_boolean_expression"}, {"score": 0.004641573524608055, "phrase": "probabilistic_tests"}, {"score": 0.004611629128198648, "phrase": "success_probabilities"}, {"score": 0.004455143595587971, "phrase": "overall_outcome"}, {"score": 0.004331900322959056, "phrase": "minimum_expected_cost"}, {"score": 0.0042686882891270405, "phrase": "np"}, {"score": 0.004086674739578897, "phrase": "probabilistic_correlations"}, {"score": 0.00406029558417523, "phrase": "test_outcomes"}, {"score": 0.0038056550337028146, "phrase": "and-or_tree"}, {"score": 0.003772927430403312, "phrase": "internal_node"}, {"score": 0.003636934557777977, "phrase": "leaf_node"}, {"score": 0.0036134479059104054, "phrase": "probabilistic_test"}, {"score": 0.003430914893390882, "phrase": "optimal_strategies"}, {"score": 0.003350353689827389, "phrase": "depth-first_approach"}, {"score": 0.0033215284998365656, "phrase": "penultimate_rooted_subtree"}, {"score": 0.003257572374586535, "phrase": "single_\"mega-test"}, {"score": 0.0032086785898007403, "phrase": "resulting_reduced_tree"}, {"score": 0.0031130747438495427, "phrase": "and-or_trees"}, {"score": 0.0030203108210358704, "phrase": "deeper_trees"}, {"score": 0.0030007942185029074, "phrase": "depth-first_strategy"}, {"score": 0.00295574305768785, "phrase": "linear_relative_order"}, {"score": 0.0028063403737190584, "phrase": "linear_strategies"}, {"score": 0.002776175635712083, "phrase": "depth-first_strategies"}, {"score": 0.002746334238905657, "phrase": "even_the_best_linear_strategy"}, {"score": 0.0026472459661460047, "phrase": "natural_partial_order"}, {"score": 0.0026187868081654795, "phrase": "common_parent_node"}, {"score": 0.0025297521529992427, "phrase": "dynamic_programming_algorithm"}, {"score": 0.002438459096581756, "phrase": "maximum_number"}, {"score": 0.0023504528375650736, "phrase": "bounded_number"}, {"score": 0.0023403097376542914, "phrase": "internal_nodes"}, {"score": 0.0023001721617535408, "phrase": "tree_size"}, {"score": 0.0022705203494730753, "phrase": "special_class"}, {"score": 0.002217145714350045, "phrase": "polynomial_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["satisficing search", " diagnosis", " and-or tree", " computational complexity"], "paper_abstract": "Many tasks require evaluating a specified Boolean expression phi over a set of probabilistic tests whose costs and success probabilities are each known. A strategy specifies when to perform which test, towards determining the overall outcome of phi. We are interested in finding the strategy with the minimum expected cost. As this task is typically NP-hard-for example, when tests can occur many times within phi, or when there are probabilistic correlations between the test outcomes-we consider those cases in which the tests are probabilistically independent and each appears only once in phi. In such cases, phi can be written as an and-or tree, where each internal node corresponds to either the \"and\" or \"or\" of its children, and each leaf node is a probabilistic test. In this paper we investigate \"probabilistic and-or tree resolution\" (PAOTR), namely the problem of finding optimal strategies for and-or trees. We first consider a depth-first approach: evaluate each penultimate rooted subtree in isolation, replace each such subtree with a single \"mega-test\", and recurse on the resulting reduced tree. We show that the strategies produced by this approach are optimal for and-or trees with depth at most two but can be arbitrarily sub-optimal for deeper trees. Each depth-first strategy can be described by giving the linear relative order in which tests are to be executed, with the understanding that any test whose outcome becomes irrelevant is skipped. The class of linear strategies is strictly larger than depth-first strategies. We show that even the best linear strategy can also be arbitrarily sub-optimal. We next prove that an optimal strategy honors a natural partial order among tests with a common parent node (\"leaf-sibling tests\"), and use this to produce a dynamic programming algorithm that finds the optimal strategy in time O(d(2)(r + 1)(d)), where r is the maximum number of leaf-siblings and d is the number of leaf-parents; hence, for trees with a bounded number of internal nodes, this run-time is polynomial in the tree size. We also present another special class of and-or trees for which this task takes polynomial time. We close by presenting a number of other plausible approaches to PAOTR, together with counterexamples to show their limitations. (c) 2005 Elsevier B.V. All rights reserved.", "paper_title": "Finding optimal satisficing strategies for and-or trees", "paper_id": "WOS:000233852700002"}