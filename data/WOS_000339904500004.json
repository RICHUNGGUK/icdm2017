{"auto_keywords": [{"score": 0.04741002946225185, "phrase": "range_search"}, {"score": 0.0434700050693738, "phrase": "sequential_scan"}, {"score": 0.0354575315823035, "phrase": "upper_bound"}, {"score": 0.004771593452798216, "phrase": "database_area"}, {"score": 0.004629856947559767, "phrase": "good_worst-case_guarantees"}, {"score": 0.004411744930153217, "phrase": "query_rectangle"}, {"score": 0.004306556130853961, "phrase": "adversely_designed_datasets"}, {"score": 0.00399367108161192, "phrase": "real_data"}, {"score": 0.003898411343926653, "phrase": "commercial_systems"}, {"score": 0.003863275399791591, "phrase": "stark_contrast"}, {"score": 0.0038284549148537373, "phrase": "long-term_controversy"}, {"score": 0.0036479584876742085, "phrase": "theoretical_evidence"}, {"score": 0.0035288105310344463, "phrase": "worst_case"}, {"score": 0.003232956879952914, "phrase": "range_queries"}, {"score": 0.003174903873774882, "phrase": "practical_data"}, {"score": 0.0029707940194245216, "phrase": "dataset_size"}, {"score": 0.0028911146216534646, "phrase": "constant_factor"}, {"score": 0.0027133856739937133, "phrase": "constant_time"}, {"score": 0.002478225374613311, "phrase": "internal_nodes"}, {"score": 0.0023399219122055177, "phrase": "data_updates"}, {"score": 0.002297867835438532, "phrase": "query_optimizer"}, {"score": 0.0022361964497681934, "phrase": "instance-level_query"}, {"score": 0.002209319719984651, "phrase": "new_technique"}, {"score": 0.002169607777109061, "phrase": "heuristic_structures"}, {"score": 0.002150019713922273, "phrase": "theory-flavored_manner"}, {"score": 0.0021049977753042253, "phrase": "dominant_assessment_method"}], "paper_keywords": ["R-tree", " Performance analysis", " Theory", " Instance-level worst-case bound"], "paper_abstract": "Even with its significant impacts on the database area, the R-tree is often criticized by its lack of good worst-case guarantees. For example, in range search (where we want to report all the data points in a query rectangle), it is known that on adversely designed datasets and queries, an R-tree can be as slow as a sequential scan that simply reads all the data points. Nevertheless, R-trees work so well on real data that they have been widely implemented in commercial systems. This stark contrast has caused long-term controversy between practitioners and theoreticians as to whether this structure deserves its fame. This paper provides theoretical evidence that, somewhat surprisingly, R-trees are efficient in the worst case for range search on many real datasets. Given any integer , we explain how to obtain an upper bound on the cost of answering all (i.e., infinitely many) range queries retrieving at most objects. On practical data, the upper bound is only a fraction of the overhead of sequential scan (unless, apparently, is at the same order as the dataset size). Our upper bounds are tight up to a constant factor, namely they cannot be lowered by more than times while still capturing the most expensive queries. Our upper bounds can be calculated in constant time by remembering only three integers. These integers, in turn, are generated from only the leaf MBRs of an R-tree, but not the leaf nodes themselves. In practice, the internal nodes are often buffered in memory, so that the integers aforementioned can be efficiently maintained along with the data updates and made available to a query optimizer at any time. Furthermore, our analytical framework introduces instance-level query bound as a new technique for evaluating the efficiency of heuristic structures in a theory-flavored manner (previously, experimentation was the dominant assessment method).", "paper_title": "Instance-level worst-case query bounds on R-trees", "paper_id": "WOS:000339904500004"}