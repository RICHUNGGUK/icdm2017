{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "task-parallel_languages"}, {"score": 0.004657185361669812, "phrase": "joint_scheduling_and_memory_allocation_algorithm"}, {"score": 0.00450456611645112, "phrase": "task-parallel_programs"}, {"score": 0.004444921827311577, "phrase": "non-uniform_memory_architecture"}, {"score": 0.004270665568018583, "phrase": "task_and_data_placement_decisions"}, {"score": 0.004130660282810338, "phrase": "static_description"}, {"score": 0.004048860957751714, "phrase": "memory_hierarchy"}, {"score": 0.003968675046544738, "phrase": "runtime_information"}, {"score": 0.003916098498242888, "phrase": "intertask_communication"}, {"score": 0.0038642157757169315, "phrase": "existing_locality-aware_scheduling_strategies"}, {"score": 0.003687960013746783, "phrase": "strong_limitations"}, {"score": 0.0032925489316383955, "phrase": "task_dependences"}, {"score": 0.0032058286587989234, "phrase": "manual_program_annotations"}, {"score": 0.0030799988391729464, "phrase": "fragile_profiling_schemes"}, {"score": 0.002641621667026613, "phrase": "experimental_results"}, {"score": 0.00255488432062653, "phrase": "open-stream_language"}, {"score": 0.002405853977978678, "phrase": "scientific_applications"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_work-stealing_scheduler"}], "paper_keywords": ["Performance", " Languages", " FIFO queue", " dynamic scheduling", " work stealing", " lock-free algorithm", " weak memory model", " dataflow programming", " Kahn process network"], "paper_abstract": "We present a joint scheduling and memory allocation algorithm for efficient execution of task-parallel programs on non-uniform memory architecture (NUMA) systems. Task and data placement decisions are based on a static description of the memory hierarchy and on runtime information about intertask communication. Existing locality-aware scheduling strategies for fine-grained tasks have strong limitations: they are specific to some class of machines or applications, they do not handle task dependences, they require manual program annotations, or they rely on fragile profiling schemes. By contrast, our solution makes no assumption on the structure of programs or on the layout of data in memory. Experimental results, based on the Open-Stream language, show that locality of accesses to main memory of scientific applications can be increased significantly on a 64-core machine, resulting in a speedup of up to 1.63x compared to a state-of-the-art work-stealing scheduler.", "paper_title": "Topology-Aware and Dependence-Aware Scheduling and Memory Allocation for Task-Parallel Languages", "paper_id": "WOS:000344830900008"}