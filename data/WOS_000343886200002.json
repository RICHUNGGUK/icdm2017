{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "parallel_and"}, {"score": 0.004578783486828809, "phrase": "montgomery_multiplication"}, {"score": 0.004230749292148046, "phrase": "multiplier_operand_bits"}, {"score": 0.0041703614123283165, "phrase": "k_partitions"}, {"score": 0.003798231095121328, "phrase": "identical_algorithm"}, {"score": 0.0034841647157189985, "phrase": "computation_step"}, {"score": 0.003105305189036267, "phrase": "limited_digit_set"}, {"score": 0.002910545717767559, "phrase": "hardware_cost"}, {"score": 0.0028076592725295646, "phrase": "linear_growth"}, {"score": 0.0024842242921857705, "phrase": "power_consumption"}, {"score": 0.002448704249007665, "phrase": "multiplication_operands"}, {"score": 0.0022298571016688335, "phrase": "uniform_treatment"}, {"score": 0.0021979660485319523, "phrase": "partition_hardware_design"}, {"score": 0.0021049977753042253, "phrase": "fault-tolerant_hardware"}], "paper_keywords": ["Cryptography", " high-speed arithmetic", " modular exponentiation and multiplication", " high-radix", " low-power", " fault-tolerant"], "paper_abstract": "A way to speed up the Montgomery Multiplication by distributing the multiplier operand bits into k partitions is proposed. All of them process in parallel and use an identical algorithm. Each partition executes its task in n/k steps. Even though the computation step operates in radix 2(k), the complexity is reduced by the use of a limited digit set. Experiments with a 90-nm cell library show that the hardware cost and its complexity have a linear growth according to the number of partitions. Besides the gain in speed, the proposal reduces power consumption for multiplication operands with 256, 512, 1024, and 2048 bits. The uniform treatment of partition hardware design enables the realization of a fault-tolerant hardware.", "paper_title": "A Parallel and Uniform k-Partition Method for Montgomery Multiplication", "paper_id": "WOS:000343886200002"}