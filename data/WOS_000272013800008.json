{"auto_keywords": [{"score": 0.03891114619446894, "phrase": "interface_functions"}, {"score": 0.029983904720310105, "phrase": "maximal_reusability"}, {"score": 0.00481495049065317, "phrase": "modular_code_generation"}, {"score": 0.004786920391043703, "phrase": "synchronous_block_diagrams_modularity"}, {"score": 0.004608641771480322, "phrase": "hierarchical_block_diagrams"}, {"score": 0.004581807162841004, "phrase": "synchronous_semantics"}, {"score": 0.004515399150438986, "phrase": "fundamental_model"}, {"score": 0.004489105014468467, "phrase": "widespread_tools"}, {"score": 0.004449949342789427, "phrase": "embedded_software_domain"}, {"score": 0.004398286527734525, "phrase": "simulink"}, {"score": 0.004372655124839401, "phrase": "scade._code"}, {"score": 0.003970826351364956, "phrase": "minimal_information"}, {"score": 0.003867768665068189, "phrase": "previous_work"}, {"score": 0.0038005481380011677, "phrase": "modular_code"}, {"score": 0.0034410377627900274, "phrase": "quantified_notion"}, {"score": 0.003115428684709861, "phrase": "fundamental_trade-off"}, {"score": 0.0029127672735266836, "phrase": "code_size"}, {"score": 0.0027312312158843683, "phrase": "code_replication"}, {"score": 0.0026602596982627, "phrase": "embedded_system_context"}, {"score": 0.002401316206692149, "phrase": "zero_replication"}, {"score": 0.002380327476198495, "phrase": "intractable_problem"}, {"score": 0.002367402272083005, "phrase": "np"}, {"score": 0.002258183361711707, "phrase": "simple_iterative_procedure"}, {"score": 0.002205923961799702, "phrase": "propositional_formulas"}, {"score": 0.0021675228942726675, "phrase": "new_prototype_implementation"}, {"score": 0.002154871348969476, "phrase": "experimental_results"}, {"score": 0.0021173571273465416, "phrase": "practical_interest"}], "paper_keywords": ["Algorithms", " Design", " Languages", " Embedded software", " Block diagrams", " Synchronous languages", " Code generation", " Clustering", " NP-complete"], "paper_abstract": "We study modular, automatic code generation from hierarchical block diagrams with synchronous semantics. Such diagrams are the fundamental model behind widespread tools in the embedded software domain, such as Simulink and SCADE. Code is modular in the sense that it is generated for a given composite block independently from context (i.e., without knowing in which diagrams the block is to be used) and using minimal information about the internals of the block. In previous work, we have shown how modular code can be generated by computing a set of interface functions for each block and a set of dependencies between these functions that is exported along with the interface. We have also introduced a quantified notion of modularity in terms of the number of interface functions generated per block, and showed how to minimize this number, which is essential for scalability. Finally, we have exposed the fundamental trade-off between modularity and reusability (set of diagrams the block can be used in). In this paper we explore another trade-off: modularity vs. code size. We show that our previous technique, although it achieves maximal reusability and is optimal in terms of modularity, may result in code replication and therefore large code sizes, something often unacceptable in an embedded system context. We propose to remedy this by generating code with no replication, and show that this generally results in some loss of modularity. We show that optimizing modularity while maintaining maximal reusability and zero replication is an intractable problem (NP-complete). We also show that this problem can be solved using a simple iterative procedure that checks satisfiability of a sequence of propositional formulas. We report on a new prototype implementation and experimental results. The latter demonstrate the practical interest in our methods.", "paper_title": "Modular Code Generation from Synchronous Block Diagrams Modularity vs. Code Size", "paper_id": "WOS:000272013800008"}