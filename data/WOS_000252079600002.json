{"auto_keywords": [{"score": 0.03858815077336415, "phrase": "starting_point"}, {"score": 0.015719716506582538, "phrase": "database_re-engineering"}, {"score": 0.004643839937761046, "phrase": "technical_and_functional_descriptions"}, {"score": 0.004042166795461166, "phrase": "reverse_engineering"}, {"score": 0.003969640975997097, "phrase": "software_product"}, {"score": 0.003898411343926653, "phrase": "higher-level_specifications"}, {"score": 0.003539479990299223, "phrase": "new_version"}, {"score": 0.0033725614574134396, "phrase": "complete_process"}, {"score": 0.003213489259323921, "phrase": "transformation_functions"}, {"score": 0.003117890043128058, "phrase": "different_sets"}, {"score": 0.0030434561939032597, "phrase": "whole_process"}, {"score": 0.0029351141718104725, "phrase": "re-engineering_process"}, {"score": 0.0028823939507764238, "phrase": "physical_schema"}, {"score": 0.0027298319171606498, "phrase": "vendor-independent_metamodel"}, {"score": 0.0025542617599268323, "phrase": "class_diagram"}, {"score": 0.0025083651612064144, "phrase": "possible_conceptual_schema"}, {"score": 0.0022909325048608054, "phrase": "code_generation_process"}, {"score": 0.002222717552124615, "phrase": "executable_application"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["code generation", " re-engineering", " reverse engineering", " model-driven reengineering"], "paper_abstract": "This article presents the technical and functional descriptions of a tool specifically designed for database re-engineering. As is well known, re-engineering is the process of (1) applying reverse engineering to a software product to obtain higher-level specifications and (2) using these specifications as the starting point for the development of a new version of the system. Thus, the complete process can be seen as a sequence of transformation functions that operate on the different sets involved in the whole process. The starting point of the re-engineering process is the physical schema of the database which is translated into a vendor-independent metamodel (the logical schema) and then translated into a class diagram representing a possible conceptual schema of the database. This diagram is then taken as the starting point for the code generation process, which produces an executable application for four possible different platforms. Copyright (c) 2007 John Wiley & Sons, Ltd.", "paper_title": "An MDA-based approach for database re-engineering", "paper_id": "WOS:000252079600002"}