{"auto_keywords": [{"score": 0.0484092169382248, "phrase": "k_leaves"}, {"score": 0.03820930272983023, "phrase": "matching_worst-case"}, {"score": 0.03661928250702618, "phrase": "comparison_model"}, {"score": 0.00481495049065317, "phrase": "cartesian_trees"}, {"score": 0.0047310525657970615, "phrase": "free_trees"}, {"score": 0.00440976345264104, "phrase": "cartesian_tree"}, {"score": 0.004294962474996283, "phrase": "n-element_sequence"}, {"score": 0.003968112038249246, "phrase": "n-node_free_tree"}, {"score": 0.003101503914610488, "phrase": "cartesian_tree_construction_algorithm"}, {"score": 0.002994178996584381, "phrase": "\"bitonicity_transform"}, {"score": 0.002717750004930131, "phrase": "free_tree"}, {"score": 0.002488604965680912, "phrase": "special_case"}], "paper_keywords": ["Cartesian tree", " Adaptive algorithms", " Range queries", " Data structures"], "paper_abstract": "One can build a Cartesian tree from an n-element sequence in O(n) time, and from an n-node free tree in O(n log n) time (with a matching worst-case lower bound in the comparison model of computation). We connect these results together by describing a Cartesian tree construction algorithm based on a \"bitonicity transform\" running in O(n log k) time on a free tree with k leaves, noting that a path is the special case of a tree with just 2 leaves. We also provide a matching worst-case lower bound in the comparison model. (c) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Building Cartesian trees from free trees with k leaves", "paper_id": "WOS:000317557500007"}