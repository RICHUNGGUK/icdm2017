{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "optimizing_parallel_graph_programs"}, {"score": 0.0047292449487169345, "phrase": "unstructured_graphs"}, {"score": 0.004541918674719973, "phrase": "underlying_algorithms"}, {"score": 0.004481132747216135, "phrase": "complex_functions"}, {"score": 0.004441059405327222, "phrase": "runtime_data_values"}, {"score": 0.00438161736774803, "phrase": "static_parallelization"}, {"score": 0.0040777192615062815, "phrase": "optimistically_parallelized_graph_programs"}, {"score": 0.004023120753104693, "phrase": "new_application_area"}, {"score": 0.003933736547198066, "phrase": "first_shape_analysis"}, {"score": 0.0037948184359488284, "phrase": "failsafe_points"}, {"score": 0.003563370084662192, "phrase": "backup_copies"}, {"score": 0.003531474887552889, "phrase": "modified_data"}, {"score": 0.0033160345607565565, "phrase": "redundant_conflict_checking"}, {"score": 0.0030997236644076196, "phrase": "state_space_explosion"}, {"score": 0.0030171910207671205, "phrase": "predicate_discovery"}, {"score": 0.0029767499830258754, "phrase": "common_patterns"}, {"score": 0.00295008998986066, "phrase": "data_structure_usage"}, {"score": 0.0028844769395018595, "phrase": "shape_analysis"}, {"score": 0.0028586409810976367, "phrase": "tvla"}, {"score": 0.0027328817607818207, "phrase": "lonestar_suite"}, {"score": 0.0026962411675196213, "phrase": "optimized_programs"}, {"score": 0.0026362590493392785, "phrase": "galois_system"}, {"score": 0.00249767641333441, "phrase": "rollback_logging"}, {"score": 0.0023770362063833903, "phrase": "lock_acquisitions"}, {"score": 0.0021049977753042253, "phrase": "running_times"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Verification", " Abstract Interpretation", " Compiler Optimization", " Concurrency", " Parallelism", " Shape Analysis", " Static Analysis", " Amorphous Data-parallelism", " Irregular Programs", " Optimistic Parallelization", " Synchronization Overheads", " Cautious Operators"], "paper_abstract": "Computations on unstructured graphs are challenging to parallelize because dependences in the underlying algorithms are usually complex functions of runtime data values, thwarting static parallelization. One promising general-purpose parallelization strategy for these algorithms is optimistic parallelization. This paper identifies the optimization of optimistically parallelized graph programs as a new application area, and develops the first shape analysis for addressing this problem. Our shape analysis identifies failsafe points in the program after which the execution is guaranteed not to abort and backup copies of modified data are not needed; additionally, the analysis can be used to eliminate redundant conflict checking. It uses two key ideas: a novel top-down heap abstraction that controls state space explosion, and a strategy for predicate discovery that exploits common patterns of data structure usage. We implemented the shape analysis in TVLA, and used it to optimize benchmarks from the Lonestar suite. The optimized programs were executed on the Galois system. The analysis was successful in eliminating all costs related to rollback logging for our benchmarks. Additionally, it reduced the number of lock acquisitions by a factor ranging from 10X to 50X, depending on the application and the number of threads. These optimizations were effective in reducing the running times of the benchmarks by factors of 2 to 12X.", "paper_title": "A Shape Analysis for Optimizing Parallel Graph Programs", "paper_id": "WOS:000286472700014"}