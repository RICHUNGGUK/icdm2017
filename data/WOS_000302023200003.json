{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "interface_protocols"}, {"score": 0.004540734419151103, "phrase": "reliable_object-oriented_software"}, {"score": 0.004374385639298755, "phrase": "individual_classes"}, {"score": 0.003995226376780718, "phrase": "available_documentation"}, {"score": 0.0038283058265876713, "phrase": "incomplete_information"}, {"score": 0.003767517649628532, "phrase": "allowable_set"}, {"score": 0.003727527379253624, "phrase": "call_sequences"}, {"score": 0.00335016692413066, "phrase": "intellectually_scalable_manner"}, {"score": 0.002994859407965545, "phrase": "runtime_trace_collection_system"}, {"score": 0.002824005136794786, "phrase": "reverse_engineering_interface_protocols"}, {"score": 0.002794001681064862, "phrase": "collected_trace_data"}, {"score": 0.0026486862281576086, "phrase": "compact_specifications"}, {"score": 0.0025109095718850376, "phrase": "detailed_case_study"}, {"score": 0.002470987929071079, "phrase": "mozilla_necko_library"}, {"score": 0.002418742283474052, "phrase": "popular_applications"}, {"score": 0.002393034183276193, "phrase": "common_use"}, {"score": 0.0021049977753042253, "phrase": "identified_protocols"}], "paper_keywords": ["Object oriented software", " reverse engineering", " regular expression", " class interface", " program comprehension"], "paper_abstract": "Developing and maintaining reliable object-oriented software requires a precise understanding of how individual classes must be used. Unfortunately, for many systems, especially those that are large, the available documentation is inadequate. Developers are left with incomplete information concerning the allowable set of call sequences that each class can accommodate. Techniques for reverse engineering this information and presenting it to developers in an intellectually scalable manner are critical. In this paper, we present four contributions to address this challenge. First, we describe a runtime trace collection system for large C++ applications. Second, we present a methodology for reverse engineering interface protocols from collected trace data. Third, we present a scalable, tunable algorithm for generating compact specifications of these protocols. Finally, we present a detailed case study involving the Mozilla Necko library. We consider popular applications in common use constructed using this library. The results are promising both in terms of the performance of the approach and the utility of the identified protocols.", "paper_title": "CAPTURING INTERFACE PROTOCOLS TO SUPPORT COMPREHENSION AND EVALUATION OF C++ LIBRARIES", "paper_id": "WOS:000302023200003"}