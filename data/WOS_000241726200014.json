{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "structural_join"}, {"score": 0.004596960835906736, "phrase": "structural_joins"}, {"score": 0.004526503177267299, "phrase": "essential_building_blocks"}, {"score": 0.00445712058827745, "phrase": "xml_query_evaluation"}, {"score": 0.004288261454002681, "phrase": "difficult_task"}, {"score": 0.003878451139312637, "phrase": "linear_worst-case_run-time"}, {"score": 0.0036459007842756983, "phrase": "fiercely_varying_input_sizes"}, {"score": 0.003051887221639784, "phrase": "structural_join_algorithm"}, {"score": 0.002891032998395276, "phrase": "different_specialized_operators"}, {"score": 0.0027813397260607487, "phrase": "query_optimizer"}, {"score": 0.0026347074232350503, "phrase": "query_efficiency"}, {"score": 0.002554406040896888, "phrase": "new_hash-based_structural_joins"}, {"score": 0.002476546030310661, "phrase": "unordered_input_sequences"}, {"score": 0.002171202123281881, "phrase": "sort_operations"}, {"score": 0.0021378442381693847, "phrase": "intermediate_results"}], "paper_keywords": [""], "paper_abstract": "Algorithms for processing Structural Joins embody essential building blocks for XML query evaluation. Their design is a difficult task, because they have to satisfy many requirements, e. g., guarantee linear worst-case run-time; generate sorted, duplicate-free output; adapt to fiercely varying input sizes and element distributions; enable pipelining; and (probably) more. Therefore, it is not possible to design the structural join algorithm. Rather, the provision of different specialized operators, from which the query optimizer can choose, is beneficial for query efficiency. We propose new hash-based structural joins that can process unordered input sequences possibly containing duplicates. We also show that these algorithms can substantially reduce the number of sort operations on intermediate results for (complex) tree structured queries (twigs).", "paper_title": "Hash-based Structural Join algorithms", "paper_id": "WOS:000241726200014"}