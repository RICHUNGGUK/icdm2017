{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "synchronous_consensus"}, {"score": 0.044340662163821175, "phrase": "input_vectors"}, {"score": 0.043493982321701284, "phrase": "possible_input_vectors"}, {"score": 0.04293812570249548, "phrase": "condition-based_algorithms"}, {"score": 0.034692465572853035, "phrase": "legality_level"}, {"score": 0.004766877640444116, "phrase": "condition-based_approach"}, {"score": 0.004687815426832587, "phrase": "sophisticated_methods"}, {"score": 0.004579316323166273, "phrase": "distributed_consensus_problem"}, {"score": 0.00447331713604276, "phrase": "fault_tolerance"}, {"score": 0.004443482801729777, "phrase": "asynchronous_consensus"}, {"score": 0.00412809672402551, "phrase": "consensus_algorithms"}, {"score": 0.004019024264498125, "phrase": "actual_input_vectors"}, {"score": 0.003978866233891427, "phrase": "particular_condition"}, {"score": 0.003860774424566198, "phrase": "new_condition-based_paradigm"}, {"score": 0.0037587384888691645, "phrase": "new_concept"}, {"score": 0.0036963349119571104, "phrase": "time_complexity"}, {"score": 0.003622811707147052, "phrase": "adaptive_condition-based_approach"}, {"score": 0.0034684722988160637, "phrase": "hierarchical_conditions"}, {"score": 0.003354223660940168, "phrase": "execution_time"}, {"score": 0.003331828027460222, "phrase": "adaptive_condition-based_algorithms"}, {"score": 0.0031579462920888132, "phrase": "first_algorithm"}, {"score": 0.0028179057379595124, "phrase": "maximum_numbers"}, {"score": 0.0026977641744883826, "phrase": "input_vector"}, {"score": 0.0024643161985886085, "phrase": "previous_algorithms"}, {"score": 0.0024152394732063908, "phrase": "best_time_complexity"}, {"score": 0.002391067964886602, "phrase": "second_algorithm"}], "paper_keywords": ["distributed algorithm", " synchronous system", " consensus problem", " fault tolerance", " crash fault", " condition", " based approach", " adaptiveness"], "paper_abstract": "The condition-based approach is one of the sophisticated methods used to overcome several impossibility results in the distributed consensus problem ( e. g., impossibility of fault tolerance in asynchronous consensus or time complexity lower bounds in synchronous consensus). It introduces conditions on input vectors to specify subsets of all possible input vectors to consensus algorithms and condition-based algorithms can circumvent the impossibility if actual input vectors satisfy a particular condition. In this paper, we present a new condition-based paradigm for synchronous consensus. We introduce the new concept of adaptation on the time complexity of condition-based algorithms and present the adaptive condition-based approach to synchronous consensus. In our approach, all possible input vectors are classified into hierarchical conditions according to their difficulty called the legality level. The execution time of adaptive condition-based algorithms depends on the legality level of input vectors. We propose two adaptive condition-based algorithms for synchronous consensus. The first algorithm requires that the majority of processes be correct, and terminates within min {f + 2, t + 1} - l rounds if l < f, where f and t are the actual and the maximum numbers of faults, respectively, and l is the legality level of the input vector. Moreover, the algorithm terminates in one round if l >= t and f = 0 and terminates within two rounds if l >= f holds. Compared with previous algorithms, this algorithm achieves the best time complexity. The second algorithm can tolerate any number of faults, and terminates within max {3, min {f + 3, t +2} - l} rounds if l < f holds, terminates in one round if l >= t and f = 0, and terminates within three rounds if l >= f holds.", "paper_title": "Condition adaptation in synchronous consensus", "paper_id": "WOS:000237631000005"}