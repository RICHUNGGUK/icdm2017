{"auto_keywords": [{"score": 0.04861462157289286, "phrase": "object_composition"}, {"score": 0.00481495049065317, "phrase": "nonlinear_finite-element"}, {"score": 0.004553128404612054, "phrase": "significant_advantages"}, {"score": 0.0044968982227349625, "phrase": "class_inheritance"}, {"score": 0.004386503433248535, "phrase": "flexible_software_architecture"}, {"score": 0.004332322079100859, "phrase": "finite-element_analysis"}, {"score": 0.004173743791750695, "phrase": "separate_classes"}, {"score": 0.004122179528285764, "phrase": "fundamental_finite-element_algorithms"}, {"score": 0.0039221899471111, "phrase": "governing_nonlinear_equations"}, {"score": 0.0037551444630619015, "phrase": "analysis_composition"}, {"score": 0.003662892058072211, "phrase": "software_design_patterns"}, {"score": 0.003617616153730564, "phrase": "root-finding_algorithms"}, {"score": 0.0035728978842974246, "phrase": "time_integration_methods"}, {"score": 0.003528730431045574, "phrase": "constraint_handlers"}, {"score": 0.0034851070574149993, "phrase": "linear_equation_solvers"}, {"score": 0.003378385493203297, "phrase": "freedom_numberers"}, {"score": 0.0032953582866530966, "phrase": "interchangeable_components"}, {"score": 0.003234425353582135, "phrase": "strategy_pattern"}, {"score": 0.0031746155143471725, "phrase": "bridge_and_factory_method_patterns"}, {"score": 0.003077372515276563, "phrase": "finite-element_model"}, {"score": 0.0029097582786754444, "phrase": "numerical_solution_procedures"}, {"score": 0.002855934865505357, "phrase": "adapter_and_iterator_patterns"}, {"score": 0.0027172101552870973, "phrase": "abstract_interfaces"}, {"score": 0.0025532173213934422, "phrase": "analysis_model"}, {"score": 0.0025059724686541263, "phrase": "computational_details"}, {"score": 0.0024595996811420566, "phrase": "time_integration_method"}, {"score": 0.002429161048032688, "phrase": "sequence_diagrams"}, {"score": 0.002340081450249521, "phrase": "analysis_classes"}, {"score": 0.0022967713922705, "phrase": "nonlinear_finite-element_equations"}, {"score": 0.002212535878761148, "phrase": "design_patterns"}, {"score": 0.0021715812867126884, "phrase": "general_approach"}, {"score": 0.0021049977753042253, "phrase": "nonlinear_finite-element_software"}], "paper_keywords": ["Computer programming", " Computer software", " Finite element method", " Nonlinear analysis"], "paper_abstract": "Object composition offers significant advantages over class inheritance to develop a flexible software architecture for finite-element analysis. Using this approach, separate classes encapsulate fundamental finite-element algorithms and interoperate to form and solve the governing nonlinear equations. Communication between objects in the analysis composition is established using software design patterns. Root-finding algorithms, time integration methods, constraint handlers, linear equation solvers, and degree of freedom numberers are implemented as interchangeable components using the Strategy pattern. The Bridge and Factory Method patterns allow objects of the finite-element model to vary independently from objects that implement the numerical solution procedures. The Adapter and Iterator patterns permit equations to be assembled entirely through abstract interfaces that do not expose either the storage of objects in the analysis model or the computational details of the time integration method. Sequence diagrams document the interoperability of the analysis classes for solving nonlinear finite-element equations, demonstrating that object composition with design patterns provides a general approach to developing and refactoring nonlinear finite-element software.", "paper_title": "Nonlinear Finite-Element Analysis Software Architecture Using Object Composition", "paper_id": "WOS:000273037200011"}