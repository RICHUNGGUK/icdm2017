{"auto_keywords": [{"score": 0.04631011650344562, "phrase": "code_size"}, {"score": 0.012326893690672679, "phrase": "limited_encoding_space"}, {"score": 0.0045843245695654875, "phrase": "today's_embedded_applications"}, {"score": 0.00447316895126645, "phrase": "execution_time"}, {"score": 0.0044005599565517875, "phrase": "power_consumption"}, {"score": 0.004241451614311598, "phrase": "efficient_instruction_set_design"}, {"score": 0.0041555469216463855, "phrase": "important_issues"}, {"score": 0.004054745478848129, "phrase": "specific_applications"}, {"score": 0.0040052617265655035, "phrase": "better_performance"}, {"score": 0.003972607172518598, "phrase": "multiple_instructions"}, {"score": 0.003908091457759849, "phrase": "fast_execution_time"}, {"score": 0.003797690272118125, "phrase": "low_power_consumption"}, {"score": 0.0036453427552753533, "phrase": "application_specific_and_complex_instructions"}, {"score": 0.0035861227263414537, "phrase": "instruction_set_architecture"}, {"score": 0.0034847851398628546, "phrase": "conventional_architectures"}, {"score": 0.003456359260921982, "phrase": "free_space"}, {"score": 0.003386301445203071, "phrase": "excessive_bits"}, {"score": 0.003331275574328097, "phrase": "fixed_word_length"}, {"score": 0.003250403288147613, "phrase": "severe_weakness"}, {"score": 0.0029824560656987855, "phrase": "new_instruction_encoding_scheme"}, {"score": 0.002933973181012572, "phrase": "dynamic_implied_addressing_mode"}, {"score": 0.0026700637696697414, "phrase": "first_version"}, {"score": 0.0026159017392986595, "phrase": "special_on-chip_memory"}, {"score": 0.002583931950389087, "phrase": "extra_encoding_information"}, {"score": 0.002541910967437926, "phrase": "second_version"}, {"score": 0.002459902948098627, "phrase": "small_on-chip_buffer"}, {"score": 0.00241989408309933, "phrase": "special_instruction"}, {"score": 0.0023610946923597405, "phrase": "code_generation_algorithm"}, {"score": 0.002322689143237591, "phrase": "diam."}, {"score": 0.0022477391358787582, "phrase": "diam"}, {"score": 0.0021223334214910006, "phrase": "basic_architecture"}], "paper_keywords": ["Embedded processor", " Compiler", " Optimization", " Addressing mode"], "paper_abstract": "The complexity of today's embedded applications increases with various requirements such as execution time, code size or power consumption. To satisfy these requirements for performance, efficient instruction set design is one of the important issues because an instruction customized for specific applications can make better performance than multiple instructions in aspect of fast execution time, decrease of code size, and low power consumption. Limited encoding space, however, does not allow adding application specific and complex instructions freely to the instruction set architecture. To resolve this problem, conventional architectures increases free space for encoding by trimming excessive bits required beyond the fixed word length. This approach however shows severe weakness in terms of the complexity of compiler, code size and execution time. In this paper, we propose a new instruction encoding scheme based on the dynamic implied addressing mode (DIAM) to resolve limited encoding space and side-effect by trimming. We report our two versions of architectures to support our DIAM-based approach. In the first version, we use a special on-chip memory to store extra encoding information. In the second version, we replace the memory by a small on-chip buffer along with a special instruction. We also suggest a code generation algorithm to fully utilize DIAM. In our experiment, the architecture augmented with DIAM shows about 8% code size reduction and 18% speed up on average, as compared to the basic architecture without DIAM. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Two versions of architectures for dynamic implied addressing mode", "paper_id": "WOS:000281222300007"}