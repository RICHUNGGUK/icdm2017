{"auto_keywords": [{"score": 0.04534393383857729, "phrase": "sebyte"}, {"score": 0.0402246187192041, "phrase": "input_content"}, {"score": 0.00481495049065317, "phrase": "source_code_clone_detection"}, {"score": 0.004755353864362941, "phrase": "well-established_research_area"}, {"score": 0.004696491408936132, "phrase": "similar_code_fragments"}, {"score": 0.004146327465630697, "phrase": "semantic-enabled_token_matching"}, {"score": 0.003928321515373316, "phrase": "code_fingerprints"}, {"score": 0.003706299561774348, "phrase": "different_dimensions"}, {"score": 0.0035554096354423756, "phrase": "specific_point"}, {"score": 0.0032717489668326275, "phrase": "multi-dimensional_comparison"}, {"score": 0.003177892611195514, "phrase": "similarity_search_function"}, {"score": 0.0031254704616199614, "phrase": "well-known_measure"}, {"score": 0.003035802119820631, "phrase": "jaccard"}, {"score": 0.0028521858876446654, "phrase": "existing_approaches"}, {"score": 0.0027703320456201074, "phrase": "input_data"}, {"score": 0.002735972929840289, "phrase": "search_algorithm"}, {"score": 0.0026135859312619875, "phrase": "scalable_bytecode_clone_search_engine"}, {"score": 0.002517524071220657, "phrase": "classical_search_engine"}, {"score": 0.0024656866249273125, "phrase": "result_sets"}, {"score": 0.0024149139610228887, "phrase": "large_dataset"}, {"score": 0.0023261372216194383, "phrase": "six_most_recent_versions"}, {"score": 0.002297274552621268, "phrase": "eclipse_ide"}, {"score": 0.002158233639156017, "phrase": "reliable_ranking"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Clone detection", " Semantic Web", " Java bytecode", " Clone search", " Semantic search"], "paper_abstract": "While source code clone detection is a well-established research area, finding similar code fragments in binary and other intermediate code representations has been not yet that widely studied. In this paper, we introduce SeByte, a bytecode clone detection and search model that applies semantic-enabled token matching. It is developed based on the idea of relaxation on the code fingerprints. This approach separates the input content based on the types of tokens into different dimensions, with each dimension representing the input content from a specific point of view. Following this approach, SeByte compares each dimension separately and independently which we refer to as multi-dimensional comparison in our research. As the similarity search function we use a well-known measure that supports our multi-dimensional comparison heuristic, the Jaccard similarity coefficient. Our preliminary study shows that SeByte can detect clones that are missed by existing approaches due to the differences in the input data and the search algorithm. We then further exploit the model to build a scalable bytecode clone search engine. This extension meets the requirements of a classical search engine including the ranking of result sets. Our evaluation with a large dataset of 500,000 compiled Java classes, which we extracted from the six most recent versions of the Eclipse IDE, showed that our SeByte search is not only scalable but also capable of providing a reliable ranking. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "SeByte: Scalable clone and similarity search for bytecode", "paper_id": "WOS:000344578900004"}