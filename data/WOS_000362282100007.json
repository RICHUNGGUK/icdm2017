{"auto_keywords": [{"score": 0.036828180880018095, "phrase": "graph_mutations"}, {"score": 0.03613346133936676, "phrase": "multiple_computation_phases"}, {"score": 0.00481495049065317, "phrase": "giraph_unchained"}, {"score": 0.00462919213721188, "phrase": "pregel-like_graph_processing_systems"}, {"score": 0.004154349019245315, "phrase": "bsp"}, {"score": 0.004073359218158693, "phrase": "poor_performance"}, {"score": 0.004013662619667083, "phrase": "stale_messages"}, {"score": 0.003974349782102708, "phrase": "frequent_global_synchronization_barriers"}, {"score": 0.003935420482629049, "phrase": "asynchronous_computation_models"}, {"score": 0.00376488621224566, "phrase": "existing_asynchronous_systems"}, {"score": 0.0036733470451885465, "phrase": "limited_scalability"}, {"score": 0.0036194914688460656, "phrase": "frequent_global_barriers"}, {"score": 0.0033617891884360606, "phrase": "barrierless_asynchronous_parallel"}, {"score": 0.0030464178335562636, "phrase": "bap"}, {"score": 0.0029576827451501956, "phrase": "existing_asynchronous_models"}, {"score": 0.002680114113899346, "phrase": "open_source"}, {"score": 0.002614881955427391, "phrase": "giraph"}, {"score": 0.0025137856138000014, "phrase": "large_real-world_graphs"}, {"score": 0.002404706573379854, "phrase": "giraphuc"}, {"score": 0.0023811153883132536, "phrase": "across-the-board_performance_improvements"}, {"score": 0.0023003498123420237, "phrase": "synchronous_systems"}, {"score": 0.0021896891011033105, "phrase": "asynchronous_systems"}, {"score": 0.002125859121671525, "phrase": "bap_model"}, {"score": 0.0021049977753042253, "phrase": "efficient_and_transparent_asynchronous_execution"}], "paper_keywords": [""], "paper_abstract": "The bulk synchronous parallel (BSP) model used by synchronous graph processing systems allows algorithms to be easily implemented and reasoned about. However, BSP can suffer from poor performance due to stale messages and frequent global synchronization barriers. Asynchronous computation models have been proposed to alleviate these overheads but existing asynchronous systems that implement such models have limited scalability or retain frequent global barriers, and do not always support graph mutations or algorithms with multiple computation phases. We propose barrierless asynchronous parallel (BAP), a new computation model that reduces both message staleness and global synchronization. This enables BAP to overcome the limitations of existing asynchronous models while retaining support for graph mutations and algorithms with multiple computation phases. We present GiraphUC, which implements our BAP model in the open source distributed graph processing system Giraph, and evaluate our system at scale with large real-world graphs on 64 EC2 machines. We show that GiraphUC provides across-the-board performance improvements of up to 5x faster over synchronous systems and up to an order of magnitude faster than asynchronous systems. Our results demonstrate that the BAP model provides efficient and transparent asynchronous execution of algorithms that are programmed synchronously.", "paper_title": "Giraph Unchained: Barrier less Asynchronous Parallel Execution in Pregel-like Graph Processing Systems", "paper_id": "WOS:000362282100007"}