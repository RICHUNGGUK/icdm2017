{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "fpga."}, {"score": 0.00481495049065317, "phrase": "modular_debugging"}, {"score": 0.00477190623242136, "phrase": "fpga_design_validation"}, {"score": 0.0047292449487169345, "phrase": "design_validation"}, {"score": 0.004603525341738782, "phrase": "fpga_design_cycle"}, {"score": 0.00450130420152996, "phrase": "third-party_vendors"}, {"score": 0.0042459818200777846, "phrase": "different_stages"}, {"score": 0.003951453722517865, "phrase": "even_simple_parameter_modifications"}, {"score": 0.0037608593980593035, "phrase": "full_speed"}, {"score": 0.003611751858608048, "phrase": "high-level_language"}, {"score": 0.0035156341294017685, "phrase": "hardware_description_language"}, {"score": 0.00333097896868937, "phrase": "ip_and_third-party_cores"}, {"score": 0.003256922225995089, "phrase": "final_two_stages"}, {"score": 0.0031559919178954644, "phrase": "developed_approach"}, {"score": 0.003071965703296204, "phrase": "synthesized_hardware_designs"}, {"score": 0.0029901699209266435, "phrase": "original_high-level_model"}, {"score": 0.002833035775182696, "phrase": "synthesized_hardware"}, {"score": 0.00277001889871322, "phrase": "traditional_gate-level_view"}, {"score": 0.002708399936381754, "phrase": "high-level_programmatic_interface"}, {"score": 0.00257760787870709, "phrase": "software_reference_model"}, {"score": 0.002543043781904587, "phrase": "second_approach"}, {"score": 0.0025089420019955232, "phrase": "alternative_view"}, {"score": 0.0024202176034746337, "phrase": "traditional_software_debugger"}], "paper_keywords": ["Design", " Verification", " FPGA", " debug", " partial reconfiguration", " validation"], "paper_abstract": "Design validation is the most time-consuming task in the FPGA design cycle. Although manufacturers and third-party vendors offer a range of tools that provide visibility and control of the different stages of a design, many require that the design be fully re-implemented for even simple parameter modifications or do not allow the design to be run at full speed. Designs are typically first modeled using a high-level language then later rewritten in a hardware description language, first for simulation and then later modified for synthesis. IP and third-party cores may differ during these final two stages complicating development and validation. The developed approach provides two means of directly validating synthesized hardware designs. The first allows the original high-level model written in C or C++ to be directly coupled to the synthesized hardware, abstracting away the traditional gate-level view of designs. A high-level programmatic interface allows the synthesized design to be validated directly by the software reference model. The second approach provides an alternative view to FPGAs within the scope of a traditional software debugger. This debug framework leverages partially reconfigurable regions to accelerate the modification of dynamic, software-like breakpoints for low-level analysis and provides a automatable, scriptable, command-line interface directly to a running design on an FPGA.", "paper_title": "High-Level Abstractions and Modular Debugging for FPGA Design Validation", "paper_id": "WOS:000332482800002"}