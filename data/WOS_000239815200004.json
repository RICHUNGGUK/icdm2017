{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_programs"}, {"score": 0.004611369021812453, "phrase": "analysis-driven_storage_allocation_scheme"}, {"score": 0.004298666679374568, "phrase": "basic_principle"}, {"score": 0.0038168424095396205, "phrase": "shared_data_area"}, {"score": 0.0036553070575015344, "phrase": "thread-specific_data"}, {"score": 0.0035965032173588753, "phrase": "global_synchronization"}, {"score": 0.0034817084307034955, "phrase": "garbage_collection"}, {"score": 0.0031417377608722, "phrase": "shared_area"}, {"score": 0.0029126002350975634, "phrase": "actual_copying"}, {"score": 0.0025031188149336257, "phrase": "production-quality_language_implementation"}, {"score": 0.0022101055924375725, "phrase": "allocation_scheme"}, {"score": 0.0021627595586364724, "phrase": "best_performance_characteristics"}, {"score": 0.0021049977753042253, "phrase": "communal_memory_architecture"}], "paper_keywords": ["static analysis", " runtime systems", " concurrent languages", " message passing", " Erlang"], "paper_abstract": "We describe an analysis-driven storage allocation scheme for concurrent systems that use message passing with copying semantics. The basic principle is that in such a system, data which is not part of any message does not need to be allocated in a shared data area. This allows for the deallocation of thread-specific data without requiring global synchronization and often without even triggering garbage collection. On the other hand, data that is part of a message should preferably be allocated on a shared area since this allows for fast (O(1)) interprocess communication that does not require actual copying. In the context of a dynamically typed, higher-order concurrent functional language, we present a static message analysis which guides the allocation. As shown by our performance evaluation, conducted using a production-quality language implementation, the analysis is effective enough to discover most data which is to be used as a message, and to allow the allocation scheme to combine the best performance characteristics of both a process-centric and a communal memory architecture.", "paper_title": "Message analysis for concurrent programs using message passing", "paper_id": "WOS:000239815200004"}