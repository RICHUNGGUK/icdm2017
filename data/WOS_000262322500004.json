{"auto_keywords": [{"score": 0.04779502717396203, "phrase": "haskell"}, {"score": 0.04516700153090651, "phrase": "stg_machine"}, {"score": 0.0442933586077201, "phrase": "functional_programming"}, {"score": 0.02068334341981774, "phrase": "peyton_jones"}, {"score": 0.01499883571071355, "phrase": "stg"}, {"score": 0.010612331287242078, "phrase": "natural_semantics"}, {"score": 0.007959396427038797, "phrase": "lazy_semantics"}, {"score": 0.007642914449123403, "phrase": "stgl"}, {"score": 0.0069616122847317745, "phrase": "stgl."}, {"score": 0.004766210064040821, "phrase": "formal_derivation"}, {"score": 0.004717960684395242, "phrase": "spineless_tag-less_g-machine"}, {"score": 0.00463233362905709, "phrase": "target_abstract_machine"}, {"score": 0.004594775371848836, "phrase": "lazy_functional_language"}, {"score": 0.004502200592008975, "phrase": "glasgow_haskell_compiler"}, {"score": 0.0044114827274376305, "phrase": "haskell_compiler"}, {"score": 0.00434906528856802, "phrase": "high-level_description"}, {"score": 0.003755949722774176, "phrase": "haskell_code"}, {"score": 0.00374067990543051, "phrase": "ghc"}, {"score": 0.0037178892227175825, "phrase": "c_code"}, {"score": 0.003483238868675211, "phrase": "bare-bones_functional_language"}, {"score": 0.0032434583977423996, "phrase": "haskell's_semantics"}, {"score": 0.003107562634977276, "phrase": "step-by-step_formal_derivation"}, {"score": 0.0029773436815290215, "phrase": "higher_level"}, {"score": 0.0027610089418453614, "phrase": "lower_level"}, {"score": 0.002733004939331046, "phrase": "additionaly"}, {"score": 0.002705280175175965, "phrase": "substantial_changes"}, {"score": 0.002274684393868218, "phrase": "formal_definitions"}, {"score": 0.00224701149477484, "phrase": "derivation_step"}, {"score": 0.002215150711022386, "phrase": "main_contribution"}, {"score": 0.0021748483128942687, "phrase": "efficient_machine"}, {"score": 0.0021049977753042253, "phrase": "different_levels"}], "paper_keywords": [""], "paper_abstract": "The Spineless Tag-less G-machine (STG machine) was defined as the target abstract machine for compiling the lazy functional language Haskell. It is at the heart of the Glasgow Haskell Compiler (GHC) which is claimed to be the Haskell compiler that generates the most efficient code. A high-level description of the STG machine can be found in Peyton Jones (In Journal of Functional programming, 2(2), 127-202 1992), Marlow & Peyton Jones (In Sigplan Not., 39(9) 4-5 2004), and Marlow & Peyton Jones (in Journal of Functional Programming, 16(45), 415-449, 2006). Should the reader be interested in a more detailed view, then the only additional information available is the Haskell code of GHC and the C code of its runtime system. It is hard to prove that this machine correctly implements the lazy semantics of Haskell. Part of the problem lies in the fact that the STG machine executes a bare-bones functional language, called STGL, much lower level than Haskell. Therefore, part of the correctness should be-and it is-established by showing that the translation from Haskell to STGL preserves Haskell's semantics. The other part involves showing that the STG machine correctly implements the lazy semantics of STGL. In this paper we provide a step-by-step formal derivation of the STG machine and of its compilation to C, starting from a natural semantics of STGL. Thus, our starting point is higher level than the descriptions found Peyton Jones (In Journal of Functional programming, 2(2). 127-202, 1992) and Marlow & Peyton Jones (In Sigplan Not., 39(9) 4-5, 2004), and our arrival point is lower level than those works. Additionaly, there has been substantial changes between the so-called push/enter model or the STG machine described in Peyton Jones (In Journal of Functional programming, 2(2), 127-202, 1992), and the eval/apply model of the STG machine described in Marlow & Peyton Jones (In Sigplan Not., 39(9), 4-5, 2004). So, in fact, we derive two machines instead of one, starting from the same initial semantics. At each step we provide enough intuitions and explanations in order to understand the refinement, and then the formal definitions and statements proving that the derivation step is sound and complete. The main contribution of the paper is to show that an efficient machine such as the STG can be presented, understood, and formally reasoned about at different levels of abstraction.", "paper_title": "From natural semantics to C: A formal derivation of two STG machines", "paper_id": "WOS:000262322500004"}