{"auto_keywords": [{"score": 0.024548944639282498, "phrase": "coq"}, {"score": 0.004586531354697466, "phrase": "software-based_fault_isolation"}, {"score": 0.004338661611644755, "phrase": "google's_native_client"}, {"score": 0.004104132253183181, "phrase": "conceptually_simple_machine-code_analysis"}, {"score": 0.003855347387268162, "phrase": "complicated_architectures"}, {"score": 0.00342568771304873, "phrase": "analysis_wrong"}, {"score": 0.003285725064532174, "phrase": "new_checker"}, {"score": 0.002980916123365584, "phrase": "google's_original_analysis"}, {"score": 0.00266693888510356, "phrase": "declarative_description"}, {"score": 0.0025578967205807843, "phrase": "formal_model"}, {"score": 0.002241087008892355, "phrase": "independent_interest"}, {"score": 0.002134508934917511, "phrase": "wide_range"}, {"score": 0.0021049977753042253, "phrase": "machine-level_verification_tasks"}], "paper_keywords": ["security", " verification", " software fault isolation", " domain-specific languages"], "paper_abstract": "Software-based fault isolation (SFI), as used in Google's Native Client (NaCl), relies upon a conceptually simple machine-code analysis to enforce a security policy. But for complicated architectures such as the x86, it is all too easy to get the details of the analysis wrong. We have built a new checker that is smaller, faster, and has a much reduced trusted computing base when compared to Google's original analysis. The key to our approach is automatically generating the bulk of the analysis from a declarative description which we relate to a formal model of a subset of the x86 instruction set architecture. The x86 model, developed in Coq, is of independent interest and should be usable for a wide range of machine-level verification tasks.", "paper_title": "RockSalt: Better, Faster, Stronger SFI for the x86", "paper_id": "WOS:000307582100035"}