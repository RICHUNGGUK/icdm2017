{"auto_keywords": [{"score": 0.03609581176652309, "phrase": "aba_problem"}, {"score": 0.03312167116374837, "phrase": "abstract_model"}, {"score": 0.00481495049065317, "phrase": "scalable_lock-free_stack_algorithm"}, {"score": 0.004517210371632577, "phrase": "verifiable_steps"}, {"score": 0.0043908341845978575, "phrase": "scalable_stack_algorithm"}, {"score": 0.004359794046948005, "phrase": "hendler_et_al"}, {"score": 0.004267978415344142, "phrase": "sixteenth_annual_acm_symposium"}, {"score": 0.004163327464447124, "phrase": "barcelona"}, {"score": 0.004134045613392953, "phrase": "spain"}, {"score": 0.003989742144066683, "phrase": "push_and_pop_operations"}, {"score": 0.0038506359988314787, "phrase": "central_stack"}, {"score": 0.0037031937016576695, "phrase": "multiple_pairs"}, {"score": 0.003511159930253876, "phrase": "simpler_data_structure"}, {"score": 0.0033527773742790695, "phrase": "simple_lock-free_stack_algorithm"}, {"score": 0.0033172506969692626, "phrase": "linked-list_implementation"}, {"score": 0.0032358074601765555, "phrase": "memory_management"}, {"score": 0.003100800861459349, "phrase": "elimination_process"}, {"score": 0.0029819840849398234, "phrase": "basic_algorithmic_ideas"}, {"score": 0.0029294877178473017, "phrase": "implementation_details"}, {"score": 0.002827243416398972, "phrase": "different_variants"}, {"score": 0.0027382698136572785, "phrase": "elimination_stack_algorithm"}, {"score": 0.0025869338215971536, "phrase": "equivalent_execution"}, {"score": 0.002532359001507531, "phrase": "linearisable_stack"}, {"score": 0.0022843440226146005, "phrase": "refactoring_step"}, {"score": 0.0021967433763351884, "phrase": "preceding_derivation"}, {"score": 0.0021275693314553143, "phrase": "lipton's_reduction_method"}, {"score": 0.0021049977753042253, "phrase": "concurrent_and_non-concurrent_aspects"}], "paper_keywords": ["Refinement", " Derivation", " Lock-free algorithms", " Concurrency", " Stack", " Elimination", " Reduction, Linearisability", " Atomicity"], "paper_abstract": "We show how a sophisticated, lock-free concurrent stack implementation can be derived from an abstract specification in a series of verifiable steps. The algorithm is based on the scalable stack algorithm of Hendler et al. (Proceedings of the sixteenth annual ACM symposium on parallel algorithms, 27-30 June 2004, Barcelona, Spain, pp 206-215), which allows push and pop operations to be paired off and eliminated without affecting the central stack, thus reducing contention on the stack, and allowing multiple pairs of push and pop operations to be performed in parallel. Our algorithm uses a simpler data structure than Hendler, Shavit and Yerushalmi's, and avoids an ABA problem. We first derive a simple lock-free stack algorithm using a linked-list implementation, and discuss issues related to memory management and the ABA problem. We then add an abstract model of the elimination process, from which we derive our elimination algorithm. This allows the basic algorithmic ideas to be separated from implementation details, and provides a basis for explaining and comparing different variants of the algorithm. We show that the elimination stack algorithm is linearisable by showing that any execution of the implementation can be transformed into an equivalent execution of an abstract model of a linearisable stack. Each step in the derivation is either a data refinement which preserves the level of atomicity, an operational refinement which may alter the level of atomicity, or a refactoring step which alters the structure of the system resulting from the preceding derivation. We verify our refinements using an extension of Lipton's reduction method, allowing concurrent and non-concurrent aspects to be considered separately.", "paper_title": "Trace-based derivation of a scalable lock-free stack algorithm", "paper_id": "WOS:000263058800008"}