{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "two-electron_integrals"}, {"score": 0.03721265554141775, "phrase": "numerical_results"}, {"score": 0.004746264426887276, "phrase": "rys"}, {"score": 0.0046118021635786315, "phrase": "mixed_precision_implementation"}, {"score": 0.0032190636347671675, "phrase": "significant_penalty"}, {"score": 0.003105305189036267, "phrase": "entire_computation"}, {"score": 0.0030609320300175953, "phrase": "higher_precision"}, {"score": 0.002889672003089062, "phrase": "mixed_precision"}, {"score": 0.0028279422436488116, "phrase": "rys_two-electron_integral_quadrature_algorithm"}, {"score": 0.002612640527241776, "phrase": "floating-point_types"}, {"score": 0.0024664004864629724, "phrase": "systematic_way"}, {"score": 0.0023451553255837317, "phrase": "rys_algorithm"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Rys quadrature", " Mixed precision"], "paper_abstract": "A mixed precision implementation of two-electron integrals is demonstrated to have two benefits: (a) computations can be performed reliably in 32-bit precision on architectures for which 32-bit precision is significantly faster than 64-bit precision (e.g. graphical processing units), and (b) numerical results that match those using higher than 64-bit precision can be recovered without a significant penalty associated with performing the entire computation in higher precision. A justification is presented for using mixed precision in the Rys two-electron integral quadrature algorithm, together with timings and numerical results using a variety of floating-point types. The code discussed here presents a systematic way to control the accuracy of the Rys algorithm, regardless of the types and numbers of integrals. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Mixed-precision evaluation of two-electron integrals by Rys quadrature", "paper_id": "WOS:000304384500001"}