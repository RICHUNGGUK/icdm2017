{"auto_keywords": [{"score": 0.045768620742768294, "phrase": "rtsj"}, {"score": 0.043320577578149506, "phrase": "scj"}, {"score": 0.014794667164176538, "phrase": "java"}, {"score": 0.004698229304089357, "phrase": "java_specification_request"}, {"score": 0.0044549056501745074, "phrase": "real-time_specification"}, {"score": 0.004276306563103443, "phrase": "critical_systems"}, {"score": 0.004224130367280183, "phrase": "concurrency_model"}, {"score": 0.0041725881174377345, "phrase": "safety_critical_java"}, {"score": 0.004021689117050817, "phrase": "event-based_model"}, {"score": 0.0039402177950179345, "phrase": "thread-based_model"}, {"score": 0.0037055370870874484, "phrase": "pragmatic_reasons"}, {"score": 0.0036156119373414067, "phrase": "former_model"}, {"score": 0.0035423376631308567, "phrase": "scj_approach"}, {"score": 0.0034847851398628546, "phrase": "simple_example"}, {"score": 0.003250403288147613, "phrase": "scj_code"}, {"score": 0.0031199418866663543, "phrase": "scj_model"}, {"score": 0.0030818310926031024, "phrase": "rtsj."}, {"score": 0.002994701080666466, "phrase": "scj_classes"}, {"score": 0.0029581155916843663, "phrase": "rtsj's_boundasyncevent_class"}, {"score": 0.002839352319679885, "phrase": "rtsj_models"}, {"score": 0.002583931950389087, "phrase": "programming_restrictions"}, {"score": 0.0024903420152789135, "phrase": "scj_specification"}, {"score": 0.002459902948098627, "phrase": "revised_model"}, {"score": 0.0024001337476063094, "phrase": "slightly_more_complicated_api"}, {"score": 0.002229380111189829, "phrase": "resulting_increase"}, {"score": 0.002202123699556382, "phrase": "necessary_run-time_support"}, {"score": 0.0021662983565317283, "phrase": "multiprocessor_implementations"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Safety Critical Java", " real-time specification for Java", " threads", " asynchronous events"], "paper_abstract": "Over the last few years, the Java Community Process (under the auspices of Java Specification Request 302) has been developing a subset of Java augmented by the Real-Time Specification for Java (RTSJ) for use in safety critical systems. The concurrency model supported by Safety Critical Java (SCJ) relies almost exclusively on an event-based model rather than on a thread-based model. This paper reviews the advantages and disadvantages of the two models and gives the pragmatic reasons that SCJ has adopted the former model. It describes the SCJ approach and gives a simple example of how it can be used, illustrating the difference in style between the RTSJ and SCJ code. The paper then considers the compatibility of the SCJ model with the RTSJ. It argues that by basing the SCJ classes on the RTSJ's BoundAsyncEvent class, some inconsistencies exist between the SCJ and the RTSJ models. Furthermore, some of the optimizations that are possible when mapping handlers to server threads are inhibited, even though the programming restrictions necessary for these optimizations are imposed by the SCJ specification. A revised model is presented that has a slightly more complicated API but is more consistent with the RTSJ and allows the optimizations. However, there is a resulting increase in the necessary run-time support, particularly for multiprocessor implementations. Copyright (C) 2011 John Wiley & Sons, Ltd.", "paper_title": "Asynchronous event handling and Safety Critical Java", "paper_id": "WOS:000303983700005"}