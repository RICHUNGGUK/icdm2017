{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "engineering_software"}, {"score": 0.004779406424192843, "phrase": "modern_multi-core_processors"}, {"score": 0.004744123493964429, "phrase": "recent_multi-core_designs"}, {"score": 0.004691684576246597, "phrase": "symmetric_multi_processing"}, {"score": 0.004639822587124109, "phrase": "coherent_non_uniform_memory_access_architectures"}, {"score": 0.00452101969521343, "phrase": "performance_issues"}, {"score": 0.004438019162720755, "phrase": "parallel_finite_element_programs"}, {"score": 0.0041515831652973794, "phrase": "computer_architecture"}, {"score": 0.003941592232278979, "phrase": "system_memory_organization"}, {"score": 0.0034875380341306468, "phrase": "first_solution"}, {"score": 0.003423445743298995, "phrase": "application's_code"}, {"score": 0.0032381271420557052, "phrase": "second_solution"}, {"score": 0.002984264956378651, "phrase": "related_data"}, {"score": 0.0029621948240346092, "phrase": "local_cpus"}, {"score": 0.0029402874300114537, "phrase": "memory_banks"}, {"score": 0.0028121943702224326, "phrase": "operating_systems"}, {"score": 0.0025157865918985704, "phrase": "specialized_libraries"}, {"score": 0.0024879169065840493, "phrase": "specific_data_allocation"}, {"score": 0.002469508424323385, "phrase": "thread_scheduling"}, {"score": 0.002353120949568249, "phrase": "large_data_sets"}, {"score": 0.002128587147609539, "phrase": "civil-comp"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Parallel programming", " Parallel processing", " Cache-coherent Non Uniform Memory", " Access", " Finite Element Methods", " Multi-core processors", " Shared memory"], "paper_abstract": "Recent multi-core designs migrated from Symmetric Multi Processing to cache coherent Non Uniform Memory Access architectures. In this paper we discuss performance issues that arise when designing parallel Finite Element programs for a 64-core ccNUMA computer and explore solutions for these issues. We first present the overview of the computer architecture and show that highly parallel code that does not take into account the aspects of the system memory organization scales poorly, achieving only 2.8x speedup when running with 64 threads. Then, we discuss how we identified the sources of overhead and evaluate three possible solutions for the problem. We show that the first solution does not require the application's code to be modified, however, the speedup achieved is only 10.6x. The second solution enables the performance to scale up to 30.9x, however, it requires the programmer to manually schedule threads and allocate related data on local CPUs and memory banks and rely on ccNUMA aware libraries that are not portable across operating systems. Also, we propose and evaluate \"copy-on-thread\", an alternative solution that enables the performance to scale up to 25.5x without relying on specialized libraries nor requiring specific data allocation and thread scheduling. Finally, we argue that the issues reported only happen for large data sets and conclude the paper with recommendations to help programmers to design algorithms and programs that perform well on such kind of machine. (C) 2014 Civil-Comp Ltd. and Elsevier Ltd. All rights reserved.", "paper_title": "Accelerating engineering software on modern multi-core processors", "paper_id": "WOS:000353008100009"}