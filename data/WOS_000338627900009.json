{"auto_keywords": [{"score": 0.04246301635594336, "phrase": "self-aware_systems"}, {"score": 0.00481495049065317, "phrase": "design_tools"}, {"score": 0.004123781267600542, "phrase": "runtime_reconfigurable_fpgas"}, {"score": 0.003686935223424015, "phrase": "present_vendor_design_tools"}, {"score": 0.0034118234596993836, "phrase": "scalable_reconfigurable_systems"}, {"score": 0.0031845067058084583, "phrase": "different_positions"}, {"score": 0.002822434555587263, "phrase": "communication_architecture_synthesis"}, {"score": 0.0027741761880779535, "phrase": "physical_constraints_generation"}, {"score": 0.002726740692380339, "phrase": "physical_implementation"}, {"score": 0.0026570998719084153, "phrase": "timing_verification"}, {"score": 0.0025014259919355453, "phrase": "final_bitstream_generation"}, {"score": 0.0021049977753042253, "phrase": "user_interaction"}], "paper_keywords": ["Reconfigurable computing", " design tools", " FPGAs", " self-aware systems"], "paper_abstract": "To fully exploit the capabilities of runtime reconfigurable FPGAs in self-aware systems, design tools are required that exceed the capabilities of present vendor design tools. Such tools must allow the implementation of scalable reconfigurable systems with various different partial modules that might be loaded to different positions of the device at runtime. This comprises several complex tasks, including floorplanning, communication architecture synthesis, physical constraints generation, physical implementation, and timing verification all the way down to the final bitstream generation. In this article, we present how our GOAHEAD framework helps in implementing self-aware systems on FPGAs with a minimum of user interaction.", "paper_title": "Design Tools for Implementing Self-Aware and Fault-Tolerant Systems on FPGAs", "paper_id": "WOS:000338627900009"}