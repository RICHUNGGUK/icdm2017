{"auto_keywords": [{"score": 0.04971747610320425, "phrase": "lozenge_p"}, {"score": 0.04221854328038865, "phrase": "failure_detectors"}, {"score": 0.015255254617690358, "phrase": "one-shot_agreement_problems"}, {"score": 0.008079942811998888, "phrase": "asynchronous_distributed_systems"}, {"score": 0.006016128893604686, "phrase": "lozenge_s"}, {"score": 0.00481495049065317, "phrase": "respective_power"}, {"score": 0.004566123591480369, "phrase": "abstract_devices"}, {"score": 0.004396267325338022, "phrase": "distributed_computing_problems"}, {"score": 0.003983879657176108, "phrase": "chandra"}, {"score": 0.0039534093812876306, "phrase": "toueg"}, {"score": 0.003383884759373793, "phrase": "erroneous_suspicions"}, {"score": 0.0032087739900195232, "phrase": "single_correct_process"}, {"score": 0.0031365196064043494, "phrase": "one-shot_agreement_problem"}, {"score": 0.0031010029460927864, "phrase": "new_problem_instance"}, {"score": 0.0030082398041055003, "phrase": "new_values"}, {"score": 0.0029183525092117534, "phrase": "consensus"}, {"score": 0.002746225320405654, "phrase": "comparative_power"}, {"score": 0.002564763827975352, "phrase": "reliable_links"}, {"score": 0.0025165151708122957, "phrase": "crash_failures"}, {"score": 0.0021948455916770233, "phrase": "important_consequence"}, {"score": 0.0021049977753042253, "phrase": "weakest_class"}], "paper_keywords": ["agreement problem", " asynchronous distributed system", " consensus", " computational power", " input vector", " one-shot problem", " process crash", " unreliable failure detector", " P", " S"], "paper_abstract": "Unreliable failure detectors are abstract devices that, when added to asynchronous distributed systems, enable solving distributed computing problems (e.g., Consensus) that otherwise would be impossible to solve in these systems. This paper focuses on two classes of failure detectors defined by Chandra and Toueg, namely, the classes denoted lozenge P (eventually perfect) and lozenge S (eventually strong). Both classes include failure detectors that eventually detect permanently all process crashes, but while the failure detectors of lozenge P eventually make no erroneous suspicions, the failure detectors of lozenge S are only required to eventually not suspect a single correct process. Informally, in a one-shot agreement problem, a new problem instance is created each time the processes propose new values to be decided on (e.g., Consensus is one-shot). In such a context, this paper addresses the following question related to the comparative power of these classes, namely: \"Are there one-shot agreement problems that can be solved in asynchronous distributed systems with reliable links but prone to process crash failures augmented with lozenge P, but cannot be solved when those systems are augmented with lozenge S?\" Surprisingly, the paper shows that the answer to this question is \"no.\" An important consequence of this result is that lozenge P cannot be the weakest class of failure detectors that enables solving one-shot agreement problems in unreliable asynchronous distributed systems.", "paper_title": "On the respective power of lozenge P and lozenge S to solve one-shot agreement problems", "paper_id": "WOS:000245136400002"}