{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "coarse-grained_reconfigurable_architectures"}, {"score": 0.00466102244911872, "phrase": "high_performance"}, {"score": 0.004617949594931096, "phrase": "high_power_efficiency"}, {"score": 0.004247696749118451, "phrase": "application_mapping"}, {"score": 0.004092774981286263, "phrase": "data_mapping"}, {"score": 0.003888905257972882, "phrase": "multibank_local_memory"}, {"score": 0.003747020072136732, "phrase": "memory_access"}, {"score": 0.0035273744062641606, "phrase": "memory_bank"}, {"score": 0.003446353878654566, "phrase": "hardware_arbiter"}, {"score": 0.0033986345279488476, "phrase": "memory_requests"}, {"score": 0.003244275497488318, "phrase": "local_memory"}, {"score": 0.0031697368057340895, "phrase": "fundamental_restriction"}, {"score": 0.0028350413546400703, "phrase": "application_operations"}, {"score": 0.0027570267191549774, "phrase": "memory_banks"}, {"score": 0.0025952620596908747, "phrase": "multibank_memories"}, {"score": 0.0025355968118803956, "phrase": "compiler_optimization"}, {"score": 0.0025121156016001864, "phrase": "cgra_mapping"}, {"score": 0.0024429654627197393, "phrase": "memory_operations"}, {"score": 0.0024091057723923857, "phrase": "data_reuse"}, {"score": 0.0023427844897844093, "phrase": "multimedia_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "memory-unaware_scheduler"}], "paper_keywords": ["Coarse-grained reconfigurable architecture", " Compilation", " multibank memory", " bank conflict", " array mapping"], "paper_abstract": "Coarse-grained reconfigurable architectures (CGRAs) promise high performance at high power efficiency. They fulfil this promise by keeping the hardware extremely simple, and moving the complexity to application mapping. One major challenge comes in the form of data mapping. For reasons of power-efficiency and complexity, CGRAs use multibank local memory, and a row of PEs share memory access. In order for each row of the PEs to access any memory bank, there is a hardware arbiter between the memory requests generated by the PEs and the banks of the local memory. However, a fundamental restriction remains in that a bank cannot be accessed by two different PEs at the same time. We propose to meet this challenge by mapping application operations onto PEs and data into memory banks in a way that avoids such conflicts. To further improve performance on multibank memories, we propose a compiler optimization for CGRA mapping to reduce the number of memory operations by exploiting data reuse. Our experimental results on kernels from multimedia benchmarks demonstrate that our local memory-aware compilation approach can generate mappings that are up to 53% better in performance (26% on average) compared to a memory-unaware scheduler.", "paper_title": "Memory Access Optimization in Compilation for Coarse-Grained Reconfigurable Architectures", "paper_id": "WOS:000297137800006"}