{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "target_constraints"}, {"score": 0.04973625252864221, "phrase": "data_exchange"}, {"score": 0.013347074786027204, "phrase": "schema_mappings"}, {"score": 0.010435409021063343, "phrase": "schema_mapping"}, {"score": 0.010069208369916614, "phrase": "canonical_target_instance"}, {"score": 0.0046118021635786315, "phrase": "source_schema"}, {"score": 0.004497262692458022, "phrase": "target_schema"}, {"score": 0.0042920078348374375, "phrase": "rich_literature"}, {"score": 0.004155399041702324, "phrase": "schema_mapping_language"}, {"score": 0.003839422251550131, "phrase": "relational_model"}, {"score": 0.0037305551963210523, "phrase": "xml_data"}, {"score": 0.0036247638406450735, "phrase": "target_instance"}, {"score": 0.003598786417573615, "phrase": "xml_data_exchange"}, {"score": 0.0035346515636097533, "phrase": "far_less_attention"}, {"score": 0.003459191419478298, "phrase": "rich_language"}, {"score": 0.0032893028281789287, "phrase": "document_navigation"}, {"score": 0.003230665474330377, "phrase": "data_values"}, {"score": 0.002963390095037466, "phrase": "target_semantics"}, {"score": 0.002900090135006575, "phrase": "canonical_instance"}, {"score": 0.0027675275077806744, "phrase": "crucial_role"}, {"score": 0.0027181663098561066, "phrase": "good_solutions"}, {"score": 0.0026220625042810706, "phrase": "general_xml_constraint_model"}, {"score": 0.0025752890978323873, "phrase": "structural_constraints"}, {"score": 0.002370625627299064, "phrase": "non-key_constraints"}, {"score": 0.0023033100935570755, "phrase": "chase_method"}, {"score": 0.0022540779997940897, "phrase": "experimental_results"}, {"score": 0.002166530105679438, "phrase": "target_instances"}, {"score": 0.0021509807762081145, "phrase": "good_quality"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["XML", " Data exchange", " Constraints"], "paper_abstract": "Data exchange is the problem of taking data structured under a source schema and creating an instance of a target schema, by following a mapping between the two schemas. There is a rich literature on problems related to data exchange, e.g., the design of a schema mapping language, the consistency of schema mappings, operations on mappings, and query answering over mappings. Data exchange is extensively studied on relational model, and is also recently discussed for XML data. This article investigates the construction of target instance for XML data exchange, which has received far less attention. We first present a rich language for the definition of schema mappings, which allow one to use various forms of document navigation and specify conditions on data values. Given a schema mapping, we then provide an algorithm to construct a canonical target instance. The schema mapping alone is not adequate for expressing target semantics, and hence, the canonical instance is in general not optimal. We recognize that target constraints play a crucial role in the generation of good solutions. In light of this, we employ a general XML constraint model to define target constraints. Structural constraints and keys are used to identify a certain entity, as rules for data merging. Moreover, we develop techniques to enforce non-key constraints on the canonical target instance, by providing a chase method to reason about data. Experimental results show that our algorithms scale well, and are effective in producing target instances of good quality. (C) 2012 Elsevier Ltd. All rights reserved.", "paper_title": "XML data exchange with target constraints", "paper_id": "WOS:000314448400005"}