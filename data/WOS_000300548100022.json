{"auto_keywords": [{"score": 0.034516326855160186, "phrase": "redex"}, {"score": 0.00481495049065317, "phrase": "run_your_research"}, {"score": 0.004778594263962987, "phrase": "formal_models"}, {"score": 0.004671156704912419, "phrase": "programming_language_community"}, {"score": 0.0044634416051962545, "phrase": "language_design"}, {"score": 0.004363058588000252, "phrase": "language_tool"}, {"score": 0.004248782702870078, "phrase": "program_analysis"}, {"score": 0.004075198669927074, "phrase": "faulty_model"}, {"score": 0.0037774893672602506, "phrase": "mechanized_formal_language"}, {"score": 0.00342263123933042, "phrase": "plt"}, {"score": 0.0033455764382772754, "phrase": "lightweight_version"}, {"score": 0.0031604223680801774, "phrase": "domain-specific_language"}, {"score": 0.0030542703032534766, "phrase": "racket_programming_language"}, {"score": 0.0027151161550531206, "phrase": "semantics_engineering_life_cycle"}, {"score": 0.002574523719093119, "phrase": "lightweight_mechanization"}, {"score": 0.0025453546203590364, "phrase": "largest_part"}, {"score": 0.002350196395175188, "phrase": "nine_papers"}, {"score": 0.0022972306948217548, "phrase": "redex-based_lightweight_modeling"}, {"score": 0.0022200068884960836, "phrase": "work_flow"}, {"score": 0.0021948455916770233, "phrase": "semantics_engineer"}], "paper_keywords": ["Design", " Reliability", " Theory", " Lightweight Semantics Engineering"], "paper_abstract": "Formal models serve in many roles in the programming language community. In its primary role, a model communicates the idea of a language design; the architecture of a language tool; or the essence of a program analysis. No matter which role it plays, however, a faulty model doesn't serve its purpose. One way to eliminate flaws from a model is to write it down in a mechanized formal language. It is then possible to state theorems about the model, to prove them, and to check the proofs. Over the past nine years, PLT has developed and explored a lightweight version of this approach, dubbed Redex. In a nutshell, Redex is a domain-specific language for semantic models that is embedded in the Racket programming language. The effort of creating a model in Redex is often no more burdensome than typesetting it with LaTeX; the difference is that Redex comes with tools for the semantics engineering life cycle. In this paper we report on a validation of this form of lightweight mechanization. The largest part of this validation concerns the formalization and exploration of nine ICFP 2009 papers in Redex, an effort that uncovered mistakes in all nine papers. The results suggest that Redex-based lightweight modeling is effective and easy to integrate into the work flow of a semantics engineer. This experience also suggests lessons for the developers of other mechanization tools.", "paper_title": "Run Your Research", "paper_id": "WOS:000300548100022"}