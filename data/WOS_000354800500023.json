{"auto_keywords": [{"score": 0.04780597585803098, "phrase": "second_part"}, {"score": 0.028959088651106028, "phrase": "explicit_instantiation_annotations"}, {"score": 0.00481495049065317, "phrase": "set-theoretic_types"}, {"score": 0.004263972370406983, "phrase": "higher-order_polymorphic_functions"}, {"score": 0.004061584718427419, "phrase": "recursive_types"}, {"score": 0.0035100601949451028, "phrase": "first_part"}, {"score": 0.003370565320453525, "phrase": "companion_paper"}, {"score": 0.002984373546099842, "phrase": "explicitly-typed_version"}, {"score": 0.0028195727965553367, "phrase": "type_instantiation"}, {"score": 0.0025578967205807843, "phrase": "local_type_inference_system"}, {"score": 0.0023776656246300063, "phrase": "function_applications"}, {"score": 0.0021394674440767124, "phrase": "explicit_type_annotations"}, {"score": 0.0021049977753042253, "phrase": "function_definitions"}], "paper_keywords": ["Types", " XML", " intersection types", " type constraints"], "paper_abstract": "This article is the second part of a two articles series about the definition of higher-order polymorphic functions in a type system with recursive types and set-theoretic type connectives (unions, intersections, and negations). In the first part, presented in a companion paper, we defined and studied the syntax, semantics, and evaluation of the explicitly-typed version of a calculus, in which type instantiation is driven by explicit instantiation annotations. In this second part we present a local type inference system that allows the programmer to omit explicit instantiation annotations for function applications, and a type reconstruction system that allows the programmer to omit explicit type annotations for function definitions.", "paper_title": "Polymorphic Functions with Set-Theoretic Types", "paper_id": "WOS:000354800500023"}