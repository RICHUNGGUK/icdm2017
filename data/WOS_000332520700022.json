{"auto_keywords": [{"score": 0.049751826735385404, "phrase": "binary_programs"}, {"score": 0.04721001669280442, "phrase": "software_crashes"}, {"score": 0.0395136795727744, "phrase": "existing_exploits"}, {"score": 0.00481495049065317, "phrase": "automatic_exploit_generation"}, {"score": 0.0046846932351254636, "phrase": "new_method"}, {"score": 0.004419426676931621, "phrase": "symbolic_failure_model"}, {"score": 0.004374192072307276, "phrase": "concolic_executions"}, {"score": 0.004314595541370065, "phrase": "directed_paths"}, {"score": 0.004255807517348647, "phrase": "whole_system_environment_model"}, {"score": 0.004197817125707719, "phrase": "mapped_symbolic_memory"}, {"score": 0.004112303664150895, "phrase": "new_selective_symbolic_input_method"}, {"score": 0.004042369239448456, "phrase": "pseudo_symbolic_variables"}, {"score": 0.004000978459274141, "phrase": "symbolic_pointers"}, {"score": 0.003866033961859878, "phrase": "end-to-end_approach"}, {"score": 0.0037872535287644103, "phrase": "crash_inputs"}, {"score": 0.00365949103351756, "phrase": "existing_benchmark_programs"}, {"score": 0.0035603802089559716, "phrase": "word_processor"}, {"score": 0.0035360637808988468, "phrase": "microsoft"}, {"score": 0.0031899784784921222, "phrase": "vulnerability_types"}, {"score": 0.0030402538087882015, "phrase": "uninitialized_variables"}, {"score": 0.0029578641378775633, "phrase": "software_fuzz_testing_targets"}, {"score": 0.0028975361811534265, "phrase": "manual_process"}, {"score": 0.002877700749616268, "phrase": "security_knowledge"}, {"score": 0.0028482011835781434, "phrase": "mitigation-hardened_exploits"}, {"score": 0.002752029982133015, "phrase": "automated_process"}, {"score": 0.002733187900351625, "phrase": "software_failures"}, {"score": 0.0027144744718498102, "phrase": "source_code"}, {"score": 0.002686643644493607, "phrase": "proposed_method"}, {"score": 0.0025604827895852646, "phrase": "larger_programs"}, {"score": 0.0025429488129788103, "phrase": "existing_systems"}, {"score": 0.002440231768165477, "phrase": "benchmark_programs"}, {"score": 0.0023578033235964356, "phrase": "microsoft_office_word"}, {"score": 0.0023416540209862803, "phrase": "new_exploits"}, {"score": 0.0023017619208704067, "phrase": "best_speedup"}, {"score": 0.002247049536955401, "phrase": "initial_attempt"}, {"score": 0.0022240004131756095, "phrase": "heap_overflow_vulnerability"}, {"score": 0.0021049977753042253, "phrase": "sophisticated_hacking_efforts"}], "paper_keywords": ["Automatic exploit generation", " bug forensics", " software crash analysis", " symbolic execution", " taint analysis"], "paper_abstract": "This paper presents a new method, capable of automatically generating attacks on binary programs from software crashes. We analyze software crashes with a symbolic failure model by performing concolic executions following the failure directed paths, using a whole system environment model and concrete address mapped symbolic memory in (SE)-E-2 We propose a new selective symbolic input method and lazy evaluation on pseudo symbolic variables to handle symbolic pointers and speed up the process. This is an end-to-end approach able to create exploits from crash inputs or existing exploits for various applications, including most of the existing benchmark programs, and several large scale applications, such as a word processor (Microsoft office word), a media player (mpalyer), an archiver (unrar), or a pdf reader (foxit). We can deal with vulnerability types including stack and heap overflows, format string, and the use of uninitialized variables. Notably, these applications have become software fuzz testing targets, but still require a manual process with security knowledge to produce mitigation-hardened exploits. Using this method to generate exploits is an automated process for software failures without source code. The proposed method is simpler, more general, faster, and can be scaled to larger programs than existing systems. We produce the exploits within one minute for most of the benchmark programs, including mplayer. We also transform existing exploits of Microsoft office word into new exploits within four minutes. The best speedup is 7,211 times faster than the initial attempt. For heap overflow vulnerability, we can automatically exploit the unlink() macro of glibc, which formerly requires sophisticated hacking efforts.", "paper_title": "Software Crash Analysis for Automatic Exploit Generation on Binary Programs", "paper_id": "WOS:000332520700022"}