{"auto_keywords": [{"score": 0.047500611403999166, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "memory_model"}, {"score": 0.0047527118741586055, "phrase": "recent_advances"}, {"score": 0.004615587054831451, "phrase": "trusted_implementations"}, {"score": 0.004585653726916024, "phrase": "real-world_languages"}, {"score": 0.004497008230182996, "phrase": "fully_specified_semantics"}, {"score": 0.004410068751933955, "phrase": "ideal_candidate"}, {"score": 0.004296747096249343, "phrase": "translation_steps"}, {"score": 0.0042550030421781605, "phrase": "production_virtual_machines"}, {"score": 0.004132178452877669, "phrase": "compiler_technology"}, {"score": 0.004078729256705429, "phrase": "java's_key_innovations"}, {"score": 0.003986844722309844, "phrase": "significant_obstacles"}, {"score": 0.00389702203873437, "phrase": "ambitious_attempt"}, {"score": 0.0038216374069880038, "phrase": "multithreaded_programs"}, {"score": 0.0036871853429163953, "phrase": "intuitive_grasp"}, {"score": 0.0034210964819485893, "phrase": "verifying_compiler_infrastructure"}, {"score": 0.003311458758488674, "phrase": "axiomatic_style"}, {"score": 0.003247364431057555, "phrase": "intuitive_reordering-based_reasonings"}, {"score": 0.00307240091019322, "phrase": "operational_reasoning"}, {"score": 0.002878556952876824, "phrase": "buffered_memory_model"}, {"score": 0.0027862576750944277, "phrase": "pragmatic_point"}, {"score": 0.0027591477674456227, "phrase": "design_space"}, {"score": 0.002568217828414509, "phrase": "formal_reasoning"}, {"score": 0.0024858445890050614, "phrase": "specific_hardware_family"}, {"score": 0.0024218488309672697, "phrase": "bmm"}, {"score": 0.002398274973378986, "phrase": "reorderings_compilers"}, {"score": 0.0023213398100616132, "phrase": "key_enabling_device"}, {"score": 0.0022912596877648723, "phrase": "verification_pathway"}, {"score": 0.0022615684627308283, "phrase": "machine_instructions"}, {"score": 0.0021049977753042253, "phrase": "tso_architectures"}], "paper_keywords": ["Concurrency", " Java", " Memory Model", " Verified Compilation"], "paper_abstract": "Recent advances in verification have made it possible to envision trusted implementations of real-world languages. Java with its type-safety and fully specified semantics would appear to be an ideal candidate; yet, the complexity of the translation steps used in production virtual machines have made it a challenging target for verifying compiler technology. One of Java's key innovations, its memory model, poses significant obstacles to such an endeavor. The Java Memory Model is an ambitious attempt at specifying the behavior of multithreaded programs in a portable, hardware agnostic, way. While experts have an intuitive grasp of the properties that the model should enjoy, the specification is complex and not well-suited for integration within a verifying compiler infrastructure. Moreover, the specification is given in an axiomatic style that is distant from the intuitive reordering-based reasonings traditionally used to justify or rule out behaviors, and ill suited to the kind of operational reasoning one would expect to employ in a compiler. This paper takes a step back, and introduces a Buffered Memory Model (BMM) for Java. We choose a pragmatic point in the design space sacrificing generality in favor of a model that is fully characterized in terms of the reorderings it allows, amenable to formal reasoning, and which can be efficiently applied to a specific hardware family, namely x86 multiprocessors. Although the BMM restricts the reorderings compilers are allowed to perform, it serves as the key enabling device to achieving a verification pathway from bytecode to machine instructions. Despite its restrictions, we show that it is backwards compatible with the Java Memory Model and that it does not cripple performance on TSO architectures.", "paper_title": "Plan B: A Buffered Memory Model for Java", "paper_id": "WOS:000318629900029"}