{"auto_keywords": [{"score": 0.04521749909490238, "phrase": "machine_code"}, {"score": 0.015024373125175986, "phrase": "client_device"}, {"score": 0.013806499790823245, "phrase": "aotc"}, {"score": 0.006508170917095158, "phrase": "jitc"}, {"score": 0.00481495049065317, "phrase": "embedded_java_platforms"}, {"score": 0.004756592495553215, "phrase": "java_platforms"}, {"score": 0.004755539143056074, "phrase": "persistent_memory_overhead"}, {"score": 0.004698938469311569, "phrase": "java_classes"}, {"score": 0.004697897824092935, "phrase": "relocation_information"}, {"score": 0.004516323676817212, "phrase": "service_providers"}, {"score": 0.00448886315956469, "phrase": "run_time"}, {"score": 0.004434439786037454, "phrase": "higher_performance"}, {"score": 0.004394053797771851, "phrase": "static_java_classes"}, {"score": 0.0042490799524136594, "phrase": "time_compiler"}, {"score": 0.004121423202649493, "phrase": "translated_machine_code"}, {"score": 0.003913112416104065, "phrase": "dynamically_downloaded_classes"}, {"score": 0.0034005585921467875, "phrase": "persistent_memory"}, {"score": 0.0032582736131450316, "phrase": "later_run"}, {"score": 0.003121923422694974, "phrase": "translation_overhead"}, {"score": 0.002982140436039972, "phrase": "address_constants"}, {"score": 0.0029459306440711443, "phrase": "cached_machine_code"}, {"score": 0.0028312491793328043, "phrase": "different_run"}, {"score": 0.0027293449981640105, "phrase": "constant_pool_resolution"}, {"score": 0.0026879721810996906, "phrase": "relocation_problem"}, {"score": 0.002393317277328894, "phrase": "sun's_cdc_vm_reference_implementation"}, {"score": 0.0022308649734438042, "phrase": "eembc"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Java ahead-of-time compiler", " just-in-time compiler", " relocation", " early binding", " Java virtual machine", " J2ME CDC"], "paper_abstract": "Many embedded Java platforms execute two types of Java classes: those installed statically on the client device and those downloaded dynamically from service providers at run time. For achieving higher performance, the static Java classes can be compiled into machine code by ahead-of-time compiler (AOTC) in the server, and the translated machine code can be installed on the client device. Unfortunately, AOTC cannot be applicable to the dynamically downloaded classes. This paper proposes client-AOTC (c-AOTC), which performs AOTC on the client device using the just-in-time compiler (JITC) module installed on the device, obviating the JITC overhead and complementing the server-AOTC. The machine code of a method translated by JITC is cached on a persistent memory of the device, and when the method is invoked again in a later run of the program, the machine code is loaded and executed directly without any translation overhead. A major issue in c-AOTC is relocation because sonic of the address constants embedded in the cached machine code are not correct when the machine code is loaded and used in a different run; those addresses should be corrected before they are used. Constant pool resolution and inlining complicate the relocation problem, and we propose our solutions. The persistent memory overhead for saving the relocation information is also an issue, and we propose a technique to encode the relocation information and compress the machine code efficiently. We developed a c-AOTC on Sun's CDC VM reference implementation, and our evaluation results indicate that c-AOTC can improve the performance significantly, as much as an average of 12% for EEMBC and 4% for SpecJVM98, with a persistent memory overhead of 1% on average. Copyright (c) 2008 John Wiley & Sons, Ltd.", "paper_title": "Client ahead-of-time compiler for embedded Java platforms", "paper_id": "WOS:000263705700002"}