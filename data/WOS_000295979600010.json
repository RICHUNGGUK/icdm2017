{"auto_keywords": [{"score": 0.04877129670463601, "phrase": "multijoin_query_plans"}, {"score": 0.00481495049065317, "phrase": "producing_high"}, {"score": 0.004555499634179394, "phrase": "efficient_framework"}, {"score": 0.004492841495994535, "phrase": "high_and_early_result_throughput"}, {"score": 0.004192190072470619, "phrase": "single_join_operator"}, {"score": 0.004077616905584829, "phrase": "radical_step"}, {"score": 0.0040215052006051235, "phrase": "query_plans"}, {"score": 0.00398452530840582, "phrase": "multiple_join_operators"}, {"score": 0.003929689573550262, "phrase": "proposed_framework"}, {"score": 0.0036328561748082138, "phrase": "symmetric_hash_join"}, {"score": 0.003517223847512266, "phrase": "early_results"}, {"score": 0.0034528025626422154, "phrase": "incoming_data"}, {"score": 0.0032364494905485677, "phrase": "previous_join_operators"}, {"score": 0.003177154457204778, "phrase": "single-join_queries"}, {"score": 0.002909960617042717, "phrase": "new_flushing_policy"}, {"score": 0.002765636101369536, "phrase": "memory_allotment"}, {"score": 0.0025922289692173997, "phrase": "early_result"}, {"score": 0.0025565050791036973, "phrase": "multijoin_queries"}, {"score": 0.0024750474634399797, "phrase": "state_manager"}, {"score": 0.0023091093387071593, "phrase": "disk-resident_data"}, {"score": 0.0022355167967736326, "phrase": "early_result_throughput"}, {"score": 0.0022149235007885826, "phrase": "extensive_experimental_results"}, {"score": 0.002174303033371869, "phrase": "proposed_methods"}, {"score": 0.0021443262599352996, "phrase": "state-of-the-art_join_operators"}, {"score": 0.0021049977753042253, "phrase": "single_and_multijoin_query_plans"}], "paper_keywords": ["Database management", " systems", " query processing"], "paper_abstract": "This paper introduces an efficient framework for producing high and early result throughput in multijoin query plans. While most previous research focuses on optimizing for cases involving a single join operator, this work takes a radical step by addressing query plans with multiple join operators. The proposed framework consists of two main methods, a flush algorithm and operator state manager. The framework assumes a symmetric hash join, a common method for producing early results, when processing incoming data. In this way, our methods can be applied to a group of previous join operators (optimized for single-join queries) when taking part in multijoin query plans. Specifically, our framework can be applied by 1) employing a new flushing policy to write in-memory data to disk, once memory allotment is exhausted, in a way that helps increase the probability of producing early result throughput in multijoin queries, and 2) employing a state manager that adaptively switches operators in the plan between joining in-memory data and disk-resident data in order to positively affect the early result throughput. Extensive experimental results show that the proposed methods outperform the state-of-the-art join operators optimized for both single and multijoin query plans.", "paper_title": "On Producing High and Early Result Throughput in Multijoin Query Plans", "paper_id": "WOS:000295979600010"}