{"auto_keywords": [{"score": 0.049352273134126434, "phrase": "parallel_design_patterns"}, {"score": 0.00481495049065317, "phrase": "template_matching"}, {"score": 0.004669845451682529, "phrase": "triumphant_spread"}, {"score": 0.004622450915803531, "phrase": "multicore_processors"}, {"score": 0.004460309246062286, "phrase": "software_developers"}, {"score": 0.00437021209960886, "phrase": "growing_amount"}, {"score": 0.0041316803676012155, "phrase": "parallel_programs"}, {"score": 0.004007083686875716, "phrase": "sequential_programs"}, {"score": 0.003906116922372891, "phrase": "design_patterns"}, {"score": 0.0038467574225322086, "phrase": "turning_point"}, {"score": 0.003807684498435389, "phrase": "software_development"}, {"score": 0.0037498152007206815, "phrase": "programmer_productivity"}, {"score": 0.0034911335714333507, "phrase": "rising_number"}, {"score": 0.0032836104153151973, "phrase": "existing_sequential_program"}, {"score": 0.0028170314398963704, "phrase": "sequential_design_patterns"}, {"score": 0.0027041907335656782, "phrase": "parallelization_decisions"}, {"score": 0.0025958582759972315, "phrase": "previously_extracted_dynamic_dependence_graph"}, {"score": 0.0025433263646920364, "phrase": "code_blocks"}, {"score": 0.0025046245057922557, "phrase": "input_program"}, {"score": 0.002416589459425828, "phrase": "parallel_patterns"}, {"score": 0.0022382002476510573, "phrase": "detected_pattern"}, {"score": 0.0021928902836049384, "phrase": "parallel_version"}, {"score": 0.0021049977753042253, "phrase": "six_programs"}], "paper_keywords": ["Design", " Performance", " Parallel pattern detection", " pipeline detection", " do-all detection", " parallelism"], "paper_abstract": "The triumphant spread of multicore processors over the past decade increases the pressure on software developers to exploit the growing amount of parallelism available in the hardware. However, writing parallel programs is generally challenging. For sequential programs, the formulation of design patterns marked a turning point in software development, boosting programmer productivity and leading to more reusable and maintainable code. While the literature is now also reporting a rising number of parallel design patterns, programmers confronted with the task of parallelizing an existing sequential program still struggle with the question of which parallel pattern to apply where in their code. In this article, we show how template matching, a technique traditionally used in the discovery of sequential design patterns, can also be used to support parallelization decisions. After looking for matches in a previously extracted dynamic dependence graph, we classify code blocks of the input program according to the structure of the parallel patterns we find. Based on this information, the programmer can easily implement the detected pattern and create a parallel version of his or her program. We tested our approach with six programs, in which we successfully detected pipeline and do-all patterns.", "paper_title": "Using Template Matching to Infer Parallel Design Patterns", "paper_id": "WOS:000348232000030"}