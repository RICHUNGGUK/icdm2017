{"auto_keywords": [{"score": 0.049715817986079144, "phrase": "temporal_logic"}, {"score": 0.01166765279513347, "phrase": "ctl"}, {"score": 0.010220360418366901, "phrase": "coccinelle"}, {"score": 0.00481495049065317, "phrase": "foundation_for_flow-based_program_matching"}, {"score": 0.004652754203582873, "phrase": "program_control-flow_paths"}, {"score": 0.004495996972278015, "phrase": "recent_program_matching_languages"}, {"score": 0.004311527998148399, "phrase": "well-defined_means"}, {"score": 0.004230188765513944, "phrase": "control-flow_paths"}, {"score": 0.004150377643719188, "phrase": "indeed_an_extension"}, {"score": 0.0038458526450015976, "phrase": "optimizing_compilers"}, {"score": 0.0037446140218109895, "phrase": "coccinelle_program_transformation_tool"}, {"score": 0.0037020429480068653, "phrase": "linux_collateral_evolutions"}, {"score": 0.003673930454794753, "phrase": "systems_code"}, {"score": 0.0035908627899097407, "phrase": "existing_variants"}, {"score": 0.003365529624506815, "phrase": "entire_formula"}, {"score": 0.0032150101448578734, "phrase": "matched_term"}, {"score": 0.0029675701595142656, "phrase": "ctl-vw"}, {"score": 0.0028456326741466494, "phrase": "suitable_basis"}, {"score": 0.002760101069870307, "phrase": "coccinelle's_program"}, {"score": 0.0026771333996253783, "phrase": "existential_quantification"}, {"score": 0.0026567830878420347, "phrase": "program_fragments"}, {"score": 0.0025282151875392817, "phrase": "different_values"}, {"score": 0.0025089940342989227, "phrase": "different_control-flow_paths"}, {"score": 0.0023784664152543718, "phrase": "subsequent_program_transformation_process"}, {"score": 0.0021455612994325424, "phrase": "transformation_rule"}, {"score": 0.0021050215994948317, "phrase": "linux"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Program transformation", " bug finding", " program matching", " CTL", " model checking"], "paper_abstract": "Reasoning about program control-flow paths is an important functionality of a number of recent program matching languages and associated searching and transformation tools. Temporal logic provides a well-defined means of expressing properties of control-flow paths in programs, and indeed an extension of the temporal logic CTL has been applied to the problem of specifying and verifying the transformations commonly performed by optimizing compilers. Nevertheless, in developing the Coccinelle program transformation tool for performing Linux collateral evolutions in systems code, we have found that existing variants of CTL do not adequately support rules that transform subterms other than the ones matching an entire formula. Being able to transform any of the subterms of a matched term seems essential in the domain targeted by Coccinelle. In this paper, we propose an extension to CTL named CTL-VW (CTL with variables and witnesses) that is a suitable basis for the semantics and implementation of the Coccinelle's program matching language. Our extension to CTL includes existential quantification over program fragments, which allows metavariables in the program matching language to range over different values within different control-flow paths, and a notion of witnesses that record such existential bindings for use in the subsequent program transformation process. We formalize CTL-VW and describe its use in the context of Coccinelle. We then assess the performance of the approach in practice, using a transformation rule that fixes several reference count bugs in Linux code.", "paper_title": "A Foundation for Flow-Based Program Matching Using Temporal Logic and Model Checking", "paper_id": "WOS:000272013800011"}