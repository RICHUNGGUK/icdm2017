{"auto_keywords": [{"score": 0.046541446666067465, "phrase": "abstract_state_machines"}, {"score": 0.004583579470330216, "phrase": "arbitrary_algorithms"}, {"score": 0.0026357877401570764, "phrase": "previous_articles'_definitions"}, {"score": 0.002550481822137976, "phrase": "behavioral_equivalence"}, {"score": 0.002388043660169452, "phrase": "main_result"}, {"score": 0.0022980978400845144, "phrase": "small-step_algorithm"}, {"score": 0.0022236983707415907, "phrase": "asm."}, {"score": 0.002163535133532765, "phrase": "possible_variations"}, {"score": 0.0021049977753042253, "phrase": "asm_semantics"}], "paper_keywords": ["algorithms", " theory", " sequential algorithms", " interaction", " postulates", " equivalence of algorithms", " abstract state machines"], "paper_abstract": "This is the third in a series of three articles extending the proof of the Abstract State Machine thesis-that arbitrary algorithms are behaviorally equivalent to abstract state machines-to algorithms that can interact with their environments during a step, rather than only between steps. As in the first two articles of the series, we are concerned here with ordinary, small-step, interactive algorithms. This means that the algorithms: (1) proceed in discrete, global steps, (2) perform only a bounded amount of work in each step, (3) use only such information from the environment as can be regarded as answers to queries, and (4) never complete a step until all queries from that step have been answered. After reviewing the previous articles' definitions of such algorithms, of behavioral equivalence, and of abstract state machines (ASMs), we prove the main result: Every ordinary, interactive, small-step algorithm is behaviorally equivalent to an ASM. We also discuss some possible variations of and additions to the ASM semantics.", "paper_title": "Ordinary interactive small-step algorithms, III", "paper_id": "WOS:000248577000003"}