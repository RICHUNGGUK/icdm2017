{"auto_keywords": [{"score": 0.04948724894692256, "phrase": "conditional_converge"}, {"score": 0.00481495049065317, "phrase": "new_notion"}, {"score": 0.0045249263666466005, "phrase": "conditional_property"}, {"score": 0.004359328949187473, "phrase": "ccc_protocol"}, {"score": 0.004305481798183612, "phrase": "predicate_q"}, {"score": 0.004225950334493496, "phrase": "three-party_protocol"}, {"score": 0.0038978806337961565, "phrase": "secret_x"}, {"score": 0.0032953582866530966, "phrase": "masked_form"}, {"score": 0.0021049977753042253, "phrase": "concrete_scheme"}], "paper_keywords": ["oblivious transfer", " oblivious cast", " converge cast"], "paper_abstract": "In this paper, we introduce a new notion of conditional converge cast (CCC), by adding the conditional property to converge cast. A CCC protocol with predicate Q is a three-party protocol which involves two senders S-0 and S-1 and a receiver R. S-0 owns a secret x and a message m(0), so does S-1 with y and m(1) In a protocol, S-0 and S-1 send their messages to R in a masked form. R obtains the message depending on the value of Q(x, y), i.e. R obtains m(0) if Q(x, y) = 0, or m(1) otherwise. The secrets, x and y, are not revealed to R or the other sender, and Q(x, y) is not revealed to S-0 and S-1. In addition to the formulation, we propose a concrete scheme for conditional converge cast with the \"equality\" predicate.", "paper_title": "Conditional converge cast", "paper_id": "WOS:000256862800031"}