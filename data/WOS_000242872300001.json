{"auto_keywords": [{"score": 0.04931358686155013, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "flexible_model"}, {"score": 0.004776297980616768, "phrase": "dynamic_linking"}, {"score": 0.00464343008299973, "phrase": "flexible_code_deployment"}, {"score": 0.0045876189888390895, "phrase": "partially_linked_code"}, {"score": 0.0040978781692373005, "phrase": "explicit_actions"}, {"score": 0.003704797078215222, "phrase": "different_versions"}, {"score": 0.0035726811019151984, "phrase": "subtle_errors"}, {"score": 0.003282520691783122, "phrase": "soundness"}, {"score": 0.003229815147800001, "phrase": "similar_ideas"}, {"score": 0.0031271827534050493, "phrase": "linking_errors"}, {"score": 0.0029553380263320195, "phrase": "linking_phases"}, {"score": 0.0028498718992429825, "phrase": "different_order"}, {"score": 0.0027370835853738626, "phrase": "different_times"}, {"score": 0.00266079124891013, "phrase": "non-deterministic_model"}, {"score": 0.0024842242921857705, "phrase": "design_space"}, {"score": 0.0022546720211200893, "phrase": "execution_strategies"}, {"score": 0.0021479597698614373, "phrase": "link_errors"}], "paper_keywords": ["dynamic linking", " loading verifier", " jit-compilation types", " operational semantics", " code deployment", " Java", " C#"], "paper_abstract": "Dynamic linking supports flexible code deployment, allowing partially linked code to link further code on the fly, as needed. Thus, end-users enjoy the advantage of automatically receiving any updates, without any need for any explicit actions on their side, such as re-compilation, or re-linking. On the down side, two executions of a program may link in different versions of code, which in some cases causes subtle errors, and may mystify end-users. Dynamic linking in Java and C# are similar: the same linking phases are involved, Soundness is based on similar ideas, and executions which do not throw linking errors give the same result. They are, however, not identical: the linking phases are combined differently, and take place in different order. Consequently, linking errors may be detected at different times by Java and C# runtime systems. We develop a non-deterministic model. which describes the behaviour of both Java and C# program executions. The non-determinism allows us to describe the design space, to distill the similarities between the two languages. and to use one proof of soundness for both. We also prove that all execution strategies are equivalent with respect to terminating executions that do not throw link errors: they give the same results. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "A flexible model for dynamic linking in Java and C#", "paper_id": "WOS:000242872300001"}