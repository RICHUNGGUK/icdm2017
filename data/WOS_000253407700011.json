{"auto_keywords": [{"score": 0.03251942252482322, "phrase": "non-referentially-transparent_mechanism"}, {"score": 0.027308042897192127, "phrase": "non-local_but_purely_syntactic_transformation"}, {"score": 0.004814955496608903, "phrase": "first-class"}, {"score": 0.0045357787854931894, "phrase": "novel_functional_programming_construct"}, {"score": 0.0044685410845412745, "phrase": "convenient_modular_run-time_nonstandard_interpretation"}, {"score": 0.004294052530714228, "phrase": "map-closure_construct"}, {"score": 0.0040854526743211396, "phrase": "closure_environment"}, {"score": 0.003984968827278219, "phrase": "new_closure"}, {"score": 0.00392586404888927, "phrase": "modified_environment"}, {"score": 0.003848413823574867, "phrase": "user's_perspective"}, {"score": 0.003753738096719609, "phrase": "powerful_and_useful_construct"}, {"score": 0.0036250779580069455, "phrase": "security_logging"}, {"score": 0.003553540530701019, "phrase": "error_checking"}, {"score": 0.0034834098902271626, "phrase": "code_instrumentation"}, {"score": 0.0034146585649631692, "phrase": "run-time_code"}, {"score": 0.003347259612209552, "phrase": "resource_monitoring"}, {"score": 0.003281186608301359, "phrase": "implementor's_perspective"}, {"score": 0.0028822890425197582, "phrase": "direct_style"}, {"score": 0.0026612444314342023, "phrase": "higher-order_programs"}, {"score": 0.0026086775334428617, "phrase": "cps_conversion"}, {"score": 0.0024693979425773993, "phrase": "closure_conversion"}, {"score": 0.002136747803494932, "phrase": "procedure_definition"}, {"score": 0.0021049977753042253, "phrase": "local_macro_transformation"}], "paper_keywords": ["design", " languages", " referential transparency", " lambda lifting"], "paper_abstract": "We motivate and discuss a novel functional programming construct that allows convenient modular run-time nonstandard interpretation via reflection on closure environments. This map-closure construct encompasses both the ability to examine the contents of a closure environment and to construct a new closure with a modified environment. From the user's perspective, map-closure is a powerful and useful construct that supports such tasks as tracing, security logging, sandboxing, error checking, profiling, code instrumentation and metering, run-time code patching, and resource monitoring. From the implementor's perspective, map-closure is analogous to call/cc. Just as call/cc is a non-referentially-transparent mechanism that reifies the continuations that are only implicit in programs written in direct style, map-closure is a non-referentially-transparent mechanism that reifies the closure environments that are only implicit in higher-order programs. Just as CPS conversion is a non-local but purely syntactic transformation that can eliminate references to call/cc, closure conversion is a non-local but purely syntactic transformation that can eliminate references to map-closure. We show how the combination of map-closure and call/cc can be used to implement set! as a procedure definition and a local macro transformation.", "paper_title": "First-class nonstandard interpretations by opening closures", "paper_id": "WOS:000253407700011"}