{"auto_keywords": [{"score": 0.0493653882313026, "phrase": "query_processing"}, {"score": 0.00481495049065317, "phrase": "seven-dimensional_analysis_of_hashing_methods"}, {"score": 0.004672444473700524, "phrase": "solved_problem"}, {"score": 0.004575195715264118, "phrase": "constant_time_access"}, {"score": 0.004373537527118041, "phrase": "arbitrary_method"}, {"score": 0.004334280585565239, "phrase": "black_box"}, {"score": 0.0042953744947227535, "phrase": "good_performance"}, {"score": 0.004143196873246147, "phrase": "negligible_delta"}, {"score": 0.0040569185796103845, "phrase": "previous_statements"}, {"score": 0.003820144626025562, "phrase": "integer_keys"}, {"score": 0.003729335910488339, "phrase": "five-dimensional_requirements_space"}, {"score": 0.003326515807982512, "phrase": "design_space"}, {"score": 0.003276848046269042, "phrase": "different_hashing_scheme"}, {"score": 0.003122824878906245, "phrase": "right_hashing_scheme"}, {"score": 0.003104086547947925, "phrase": "hash_function_combination"}, {"score": 0.003066945490483524, "phrase": "significant_difference"}, {"score": 0.0028446460307503343, "phrase": "improved_variant"}, {"score": 0.0028275721614025714, "phrase": "robin_hood_hashing"}, {"score": 0.0027437235598539904, "phrase": "hash_functions"}, {"score": 0.0025447921872619435, "phrase": "table_memory_layout"}, {"score": 0.002506766880001808, "phrase": "simd_instructions"}, {"score": 0.002447101794397243, "phrase": "right_combination"}, {"score": 0.0024250944519924383, "phrase": "considerable_impact"}, {"score": 0.0023960581528720934, "phrase": "lookup_performance"}, {"score": 0.00233198831578686, "phrase": "major_conclusion"}, {"score": 0.0021369416775353107, "phrase": "strong_guideline"}], "paper_keywords": [""], "paper_abstract": "Hashing is a solved problem. It allows us to get constant time access for lookups. Hashing is also simple. It is safe to use an arbitrary method as a black box and expect good performance, and optimizations to hashing can only improve it by a negligible delta. Why are all of the previous statements plain wrong? That is what this paper is about. In this paper we thoroughly study hashing for integer keys and carefully analyze the most common hashing methods in a five-dimensional requirements space: (1) data-distribution, (2) load factor, (3) dataset size, (4) read/write-ratio, and (5) un/successfulratio. Each point in that design space may potentially suggest a different hashing scheme, and additionally also a different hash function. We show that a right or wrong decision in picking the right hashing scheme and hash function combination may lead to significant difference in performance. To substantiate this claim, we carefully analyze two additional dimensions: (6) five representative hashing schemes (which includes an improved variant of Robin Hood hashing), (7) four important classes of hash functions widely used today. That is, we consider 20 different combinations in total. Finally, we also provide a glimpse about the effect of table memory layout and the use of SIMD instructions. Our study clearly indicates that picking the right combination may have considerable impact on insert and lookup performance, as well as memory footprint. A major conclusion of our work is that hashing should be considered a white box before blindly using it in applications, such as query processing. Finally, we also provide a strong guideline about when to use which hashing method.", "paper_title": "A Seven-Dimensional Analysis of Hashing Methods and its Implications on Query Processing", "paper_id": "WOS:000386425900002"}