{"auto_keywords": [{"score": 0.0494713765104406, "phrase": "automatic_vectorization"}, {"score": 0.010568807721602878, "phrase": "machine_learning_models"}, {"score": 0.00481495049065317, "phrase": "machine_learning"}, {"score": 0.004575053987970206, "phrase": "compute-intensive_programs"}, {"score": 0.004310173770196077, "phrase": "auto-vectorization_capabilities"}, {"score": 0.004273601449537163, "phrase": "current_production_compilers"}, {"score": 0.0042373381286051354, "phrase": "careful_vector-code_synthesis"}, {"score": 0.004130376386308024, "phrase": "loop_transformations"}, {"score": 0.0035731269727067496, "phrase": "significant_challenge"}, {"score": 0.003512702405367876, "phrase": "cost_models"}, {"score": 0.0034828730516958807, "phrase": "vectorizing_compilers"}, {"score": 0.0033804443117334535, "phrase": "best_choices"}, {"score": 0.0031440159350875057, "phrase": "simd_codes"}, {"score": 0.0030776686414001964, "phrase": "existing_approaches"}, {"score": 0.003025597247856977, "phrase": "high-level_features"}, {"score": 0.002850168497994985, "phrase": "generated_assembly_code"}, {"score": 0.0026282000779095987, "phrase": "numerous_possible_vectorized_variants"}, {"score": 0.002583713580625699, "phrase": "input_code"}, {"score": 0.0024969812322112174, "phrase": "machine_learning_model"}, {"score": 0.0023824468367751365, "phrase": "tensor_contraction_kernels"}, {"score": 0.0022828795331819025, "phrase": "intel_icc's_auto-vectorized_code"}, {"score": 0.0021504218042734677, "phrase": "stencil_computations"}, {"score": 0.002123051344001408, "phrase": "good_improvement"}, {"score": 0.0021049977753042253, "phrase": "auto-vectorized_code"}], "paper_keywords": ["Performance"], "paper_abstract": "Automatic vectorization is critical to enhancing performance of compute-intensive programs on modern processors. However, there is much room for improvement over the auto-vectorization capabilities of current production compilers through careful vector-code synthesis that utilizes a variety of loop transformations (e.g., unroll-and-jam, interchange, etc.). As the set of transformations considered is increased, the selection of the most effective combination of transformations becomes a significant challenge: Currently used cost models in vectorizing compilers are often unable to identify the best choices. In this paper, we address this problem using machine learning models to predict the performance of SIMD codes. In contrast to existing approaches that have used high-level features of the program, we develop machine learning models based on features extracted from the generated assembly code. The models are trained offline on a number of benchmarks and used at compile-time to discriminate between numerous possible vectorized variants generated from the input code. We demonstrate the effectiveness of the machine learning model by using it to guide automatic vectorization on a variety of tensor contraction kernels, with improvements ranging from 2x to 8 x over Intel ICC's auto-vectorized code. We also evaluate the effectiveness of the model on a number of stencil computations and show good improvement over auto-vectorized code.", "paper_title": "Using Machine Learning to Improve Automatic Vectorization", "paper_id": "WOS:000299995000033"}