{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "memory_performance"}, {"score": 0.004701985831087475, "phrase": "growing_concern"}, {"score": 0.004657542074154025, "phrase": "high_performance_computing_laboratories"}, {"score": 0.0043786774510943625, "phrase": "processor_speed"}, {"score": 0.0042354707960660706, "phrase": "dynamic_random_access_memory_speed"}, {"score": 0.0040969285074699, "phrase": "memory_access_times"}, {"score": 0.004019797503157808, "phrase": "limiting_factor"}, {"score": 0.00398177607914381, "phrase": "high_performance_scientific_codes"}, {"score": 0.00388828234270598, "phrase": "multi-core_processors"}, {"score": 0.0037789720824759503, "phrase": "rapid_growth"}, {"score": 0.003603549914861701, "phrase": "similar_improvements"}, {"score": 0.003569451476205552, "phrase": "memory_capacity"}, {"score": 0.0034690732089830045, "phrase": "memory_contention"}, {"score": 0.003307988966112615, "phrase": "lightweight_memory_tracing_tool"}, {"score": 0.0032302647179383915, "phrase": "parallel_codes"}, {"score": 0.0031244995579170465, "phrase": "peak_memory_usage"}, {"score": 0.003022186855664124, "phrase": "memory_use"}, {"score": 0.0028409576481842457, "phrase": "also_its_overheads"}, {"score": 0.002708960273193547, "phrase": "programming_languages"}, {"score": 0.002683304054823427, "phrase": "scientific_domains"}, {"score": 0.002522344964242888, "phrase": "parameterized_memory_model"}, {"score": 0.0024281181691350085, "phrase": "two-dimensional_non-linear_magnetohydrodynamics_application"}, {"score": 0.0022824314760583834, "phrase": "unexpected_growth_term"}, {"score": 0.002186712881521657, "phrase": "refined_model"}, {"score": 0.0021251363422701446, "phrase": "memory_consumption"}], "paper_keywords": ["high performance computing", " memory", " multi-core", " tracing", " modelling"], "paper_abstract": "The importance of memory performance and capacity is a growing concern for high performance computing laboratories around the world. It has long been recognized that improvements in processor speed exceed the rate of improvement in dynamic random access memory speed and, as a result, memory access times can be the limiting factor in high performance scientific codes. The use of multi-core processors exacerbates this problem with the rapid growth in the number of cores not being matched by similar improvements in memory capacity, increasing the likelihood of memory contention. In this paper, we present , a lightweight memory tracing tool and analysis framework for parallel codes, which is able to identify peak memory usage and also analyse per-function memory use over time. An evaluation of , in terms of its effectiveness and also its overheads, is performed using nine established scientific applications/benchmark codes representing a variety of programming languages and scientific domains. We also show how can be used to automatically generate a parameterized memory model for one of these applications, a two-dimensional non-linear magnetohydrodynamics application, . Through the memory model we are able to identify an unexpected growth term which becomes dominant at scale. With a refined model we are able to predict memory consumption with under 7% error.", "paper_title": "Towards Automated Memory Model Generation Via Event Tracing", "paper_id": "WOS:000314892500003"}