{"auto_keywords": [{"score": 0.04967088836874542, "phrase": "gradual_typing"}, {"score": 0.04180483198330231, "phrase": "siek"}, {"score": 0.041461599389448454, "phrase": "vachharajani"}, {"score": 0.00481495049065317, "phrase": "gradual_programs"}, {"score": 0.004652845998457721, "phrase": "dynamic_checking"}, {"score": 0.004593467306126913, "phrase": "static_type_system"}, {"score": 0.004496174406337201, "phrase": "functional_languages"}, {"score": 0.004307700591183651, "phrase": "type_systems"}, {"score": 0.004074397977869244, "phrase": "implicitly_typed_languages"}, {"score": 0.0040223714916651845, "phrase": "type_inference"}, {"score": 0.0039035351575463103, "phrase": "gradual_type_inference_system"}, {"score": 0.0038207994186834015, "phrase": "gradual_types"}, {"score": 0.0037558704408683905, "phrase": "ill-typed_static_programs"}, {"score": 0.0036762529165489644, "phrase": "type_system"}, {"score": 0.0036448787596988423, "phrase": "local_reasoning"}, {"score": 0.0036137713873827374, "phrase": "type_substitutions"}, {"score": 0.0035676056286816915, "phrase": "imperative_inference_algorithm"}, {"score": 0.00350696416714684, "phrase": "subtle_correctness_statement"}, {"score": 0.0034179225740833055, "phrase": "new_approach"}, {"score": 0.003388745581055085, "phrase": "gradual_type_inference"}, {"score": 0.003288567185099276, "phrase": "gradual_inference"}, {"score": 0.003232653376857698, "phrase": "static_types"}, {"score": 0.0031640918630415566, "phrase": "static_implicitly_typed_language"}, {"score": 0.0029925402963843282, "phrase": "gradual_system"}, {"score": 0.002842428606954139, "phrase": "modular_structure"}, {"score": 0.0026199603775129516, "phrase": "ahmed_et_al"}, {"score": 0.0025315664299815537, "phrase": "principal_types"}, {"score": 0.0024461474613359994, "phrase": "static_parametric_polymorphism"}, {"score": 0.002274059352027922, "phrase": "static_type_parameters"}, {"score": 0.002254624822004988, "phrase": "gradual_type_parameters"}, {"score": 0.0022257833099336858, "phrase": "gradual_type_consistency"}, {"score": 0.00218789980093445, "phrase": "resulting_extension"}, {"score": 0.0021049977753042253, "phrase": "polymorphic_or_monomorphic_blame_calculi"}], "paper_keywords": [""], "paper_abstract": "Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement. This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus (Ahmed et al. 2009, 2011). The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.", "paper_title": "Principal Type Schemes for Gradual Programs", "paper_id": "WOS:000354800500024"}