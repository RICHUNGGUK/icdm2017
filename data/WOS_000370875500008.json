{"auto_keywords": [{"score": 0.037437275316748744, "phrase": "near-optimal_set"}, {"score": 0.03679787767141641, "phrase": "locked_cache_contents"}, {"score": 0.027127626350728195, "phrase": "static_wcet_analysis_approach"}, {"score": 0.02417936494960818, "phrase": "average_wcet_improvements"}, {"score": 0.023927378084157278, "phrase": "first_approach_range"}, {"score": 0.023267873201022596, "phrase": "second_approach_range"}, {"score": 0.02246846748295754, "phrase": "wcet"}, {"score": 0.004646496622257368, "phrase": "increasing_speed_gap"}, {"score": 0.004175533280178052, "phrase": "cache_locking"}, {"score": 0.004131135118662576, "phrase": "effective_technique"}, {"score": 0.0040726680518382965, "phrase": "unpredictability_problem"}, {"score": 0.0039723268236794935, "phrase": "wcet_aware_d-cache"}, {"score": 0.003902165732101058, "phrase": "single_task"}, {"score": 0.0037789720824759503, "phrase": "first_approach"}, {"score": 0.0036990033106718183, "phrase": "global_ilp"}, {"score": 0.003383552654319383, "phrase": "second_one"}, {"score": 0.003150612723641925, "phrase": "longest_path_length"}, {"score": 0.003094920033010818, "phrase": "ilp_formulation"}, {"score": 0.0024108455980729284, "phrase": "benchmark_suite"}], "paper_keywords": ["Worst-case execution time", " dynamic data cache locking", " interference graph", " graph orientation", " false dependency", " integer linear programming"], "paper_abstract": "Caches have been extensively used to bridge the increasing speed gap between processors and off-chip memory. However, caches make it much harder to compute the WCET (Worst-Case Execution Time) of a program. Cache locking is an effective technique for overcoming the unpredictability problem of caches. We investigate the WCET aware D-cache locking problem for a single task, and propose two dynamic cache locking approaches. The first approach formulates the problem as a global ILP (Integer Linear Programming) problem that simultaneously selects a near-optimal set of variables as the locked cache contents and allocates them to the D-cache. The second one iteratively constructs a subgraph of the CFG of the task where the lengths of all the paths are close to the longest path length, and uses an ILP formulation to select a near-optimal set of variables in the subgraph as the locked cache contents and allocate them to the D-cache. For both approaches, we propose a novel, efficient D-cache allocation algorithm. We have implemented both approaches and compared them with the longest path-based, dynamic cache locking approach proposed in [22] and the static WCET analysis approach without cache locking proposed in [14] by using a set of benchmarks from the Malardalen WCET benchmark suite, SNU real-time benchmarks and the benchmarks used in [27]. Compared to the static WCET analysis approach, the average WCET improvements of the first approach range between 11.3% and 31.6%, and the average WCET improvements of the second approach range between 12.3% and 32.9%. Compared to the longest path-based, dynamic cache locking approach, the average WCET improvements of the first approach range between 4.7% and 14.3%, and the average WCET improvements of the second approach range between 5.3% and 15.0%.", "paper_title": "WCET-Aware Dynamic D-cache Locking for A Single Task", "paper_id": "WOS:000370875500008"}