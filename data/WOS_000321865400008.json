{"auto_keywords": [{"score": 0.033015424278534135, "phrase": "rely-guarantee_references"}, {"score": 0.015719716506582538, "phrase": "side_effects"}, {"score": 0.01326800772795403, "phrase": "rely-guarantee_program_logics"}, {"score": 0.012555539354820504, "phrase": "shared_objects"}, {"score": 0.009563094393121098, "phrase": "mutable_data"}, {"score": 0.004652845998457721, "phrase": "imperative_programs"}, {"score": 0.004613175917207636, "phrase": "unrestricted_side_effects"}, {"score": 0.004363401436068803, "phrase": "new_type_system_approach"}, {"score": 0.004289291421348352, "phrase": "safe_assumptions"}, {"score": 0.004127094600862448, "phrase": "unifying_ideas"}, {"score": 0.00409188863874203, "phrase": "reference_immutability_type_systems"}, {"score": 0.0038702288460744274, "phrase": "multiple_references"}, {"score": 0.003788196352457501, "phrase": "multiple_threads"}, {"score": 0.003582928547553209, "phrase": "individual_references"}, {"score": 0.003522027550662857, "phrase": "multiple_aliases"}, {"score": 0.003388745581055085, "phrase": "guarantee_condition"}, {"score": 0.0033026956021014204, "phrase": "rely_condition"}, {"score": 0.00319134078848996, "phrase": "existing_reference_immutability_type_systems"}, {"score": 0.003044313656896057, "phrase": "precise_control"}, {"score": 0.0030183163057929687, "phrase": "state_modification"}, {"score": 0.0028669153591624696, "phrase": "flexible_aliasing"}, {"score": 0.002842428606954139, "phrase": "dependent_types"}, {"score": 0.0023333715029833007, "phrase": "special_case"}, {"score": 0.002283839204519042, "phrase": "first_reference_immutability_type_system"}, {"score": 0.002235356010935877, "phrase": "immutable_data"}, {"score": 0.0021049977753042253, "phrase": "dependently-typed_monadic_dsl"}], "paper_keywords": ["reference immutability", " rely-guarantee", " refinement types"], "paper_abstract": "Reasoning about side effects and aliasing is the heart of verifying imperative programs. Unrestricted side effects through one reference can invalidate assumptions about an alias. We present a new type system approach to reasoning about safe assumptions in the presence of aliasing and side effects, unifying ideas from reference immutability type systems and rely-guarantee program logics. Our approach, rely-guarantee references, treats multiple references to shared objects similarly to multiple threads in rely-guarantee program logics. We propose statically associating rely and guarantee conditions with individual references to shared objects. Multiple aliases to a given object may coexist only if the guarantee condition of each alias implies the rely condition for all other aliases. We demonstrate that existing reference immutability type systems are special cases of rely-guarantee references. In addition to allowing precise control over state modification, rely-guarantee references allow types to depend on mutable data while still permitting flexible aliasing. Dependent types whose denotation is stable over the actions of the rely and guarantee conditions for a reference and its data will not be invalidated by any action through any alias. We demonstrate this with refinement (subset) types that may depend on mutable data. As a special case, we derive the first reference immutability type system with dependent types over immutable data. We show soundness for our approach and describe experience using rely-guarantee references in a dependently-typed monadic DSL in COQ.", "paper_title": "Rely-Guarantee References for Refinement Types Over Aliased Mutable Data", "paper_id": "WOS:000321865400008"}