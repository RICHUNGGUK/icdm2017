{"auto_keywords": [{"score": 0.034390647849458084, "phrase": "lightweight_locks"}, {"score": 0.00481495049065317, "phrase": "lazy-stm_programs"}, {"score": 0.004661187824098818, "phrase": "tm"}, {"score": 0.0045411156682300695, "phrase": "easy-using_parallel_programming_model"}, {"score": 0.004338898899247236, "phrase": "conventional_locking_techniques"}, {"score": 0.004172722575842674, "phrase": "large_amount"}, {"score": 0.004118751115632515, "phrase": "alternative_hardware_and_software_tm_implementations"}, {"score": 0.0039097293657870584, "phrase": "formal_reasoning"}, {"score": 0.003834099867584972, "phrase": "tm_programs"}, {"score": 0.003569050665799723, "phrase": "assembly_level"}, {"score": 0.0033222630615013763, "phrase": "software_tm_implementation"}, {"score": 0.00307240091019322, "phrase": "shared_memory"}, {"score": 0.0025102759256260703, "phrase": "logic_-_a_combination"}, {"score": 0.0024297565926197505, "phrase": "separation_logic"}, {"score": 0.002398274973378986, "phrase": "concurrent_separation_logic"}, {"score": 0.0023062508214156123, "phrase": "concurrent_programs"}, {"score": 0.0022468671200629024, "phrase": "machine_model"}, {"score": 0.0022033327475266496, "phrase": "whole_framework"}, {"score": 0.0021050112553878974, "phrase": "pcc"}], "paper_keywords": ["program verification", " transactional memory (TM)", " proof-carrying-code", " permission accounting in separation logic"], "paper_abstract": "Transactional memory (TM) is an easy-using parallel programming model that avoids common problems associated with conventional locking techniques. Several researchers have proposed a large amount of alternative hardware and software TM implementations. However, few ones focus on formal reasoning about these TM programs. In this paper, we propose a framework at assembly level for reasoning about lazy software transactional memory (STM) programs. First, we give a software TM implementation based on lightweight locks. These locks are also one part of the shared memory. Then we define the semantics of the model operationally, and the lightweight locks in transaction are non-blocking, avoiding deadlocks among transactions. Finally we design a logic - a combination of permission accounting in separation logic and concurrent separation logic - to verify various properties of concurrent programs based on this machine model. The whole framework is formalized using a proof-carrying-code (PCC) framework.", "paper_title": "Formal Reasoning About Lazy-STM Programs", "paper_id": "WOS:000279714400016"}