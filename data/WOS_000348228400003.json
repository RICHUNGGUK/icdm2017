{"auto_keywords": [{"score": 0.024777504543774434, "phrase": "iops"}, {"score": 0.00481495049065317, "phrase": "low_performance_variation"}, {"score": 0.004769444094319619, "phrase": "nand_flash_storage_systems"}, {"score": 0.004548253531664032, "phrase": "storage_space"}, {"score": 0.004357927940322685, "phrase": "sustained_write_performance"}, {"score": 0.004316722156877335, "phrase": "effective_storage_capacity"}, {"score": 0.004255639740735269, "phrase": "flash_translation_layer"}, {"score": 0.004077508669922702, "phrase": "garbage_collection"}, {"score": 0.003906804492585634, "phrase": "gc_techniques"}, {"score": 0.0037432199549135826, "phrase": "effective_selection"}, {"score": 0.00370780481244907, "phrase": "victim_blocks"}, {"score": 0.0036379729015583975, "phrase": "operational_overhead"}, {"score": 0.0035022161192936234, "phrase": "cost_overhead"}, {"score": 0.0034526191487098093, "phrase": "victim_selection_process"}, {"score": 0.0032922964156452696, "phrase": "storage_systems"}, {"score": 0.0030078460113945136, "phrase": "novel_gc_mechanism"}, {"score": 0.0028140548269469934, "phrase": "fast_victim_selection"}, {"score": 0.002787406053363446, "phrase": "preemptive_operation"}, {"score": 0.0027610089418453614, "phrase": "small_additional_space_overhead"}, {"score": 0.0027348611289528583, "phrase": "existing_page-mapped_ftls"}, {"score": 0.0026077803487003, "phrase": "gc_scheme"}, {"score": 0.0025586128304269616, "phrase": "on-demand_victim_search"}, {"score": 0.0024747842618794255, "phrase": "average_input-output_operations"}, {"score": 0.0023485549678832628, "phrase": "standard_deviation"}, {"score": 0.0021971473452127126, "phrase": "better_performance"}, {"score": 0.0021659920594094407, "phrase": "existing_preemptive_gc_techniques"}, {"score": 0.0021049977753042253, "phrase": "host_requests"}], "paper_keywords": ["Data storage systems", " embedded software", " flash memories", " memory management", " scheduling algorithms"], "paper_abstract": "In many NAND flash-memory storage systems, invalidated pages can occupy the storage space until being erased. In order to preserve sustained write performance and effective storage capacity, the flash translation layer (FTL) must recycle these pages through garbage collection (GC) operations. Many previous studies have investigated GC techniques, most of which have focused on the effective selection of victim blocks to reduce the operational overhead. However, methods to reduce the cost overhead of the victim selection process, as well as to improve the responsiveness of storage systems during GC, have not yet been explored. In this paper, therefore, we propose a novel GC mechanism, called link-based GC (LINK-GC), which provides fast victim selection and preemptive operation with small additional space overhead to existing page-mapped FTLs. In our experiments, when compared with a GC scheme based on an on-demand victim search, the proposed mechanism increases the average input-output operations per second (IOPS) by up to 15.8% and decreases the standard deviation of IOPS by up to 6.16 times. Additionally, the LINK-GC shows better performance than the existing preemptive GC techniques in terms of responsiveness to host requests.", "paper_title": "Garbage Collection for Low Performance Variation in NAND Flash Storage Systems", "paper_id": "WOS:000348228400003"}