{"auto_keywords": [{"score": 0.03627589476871563, "phrase": "analysis_granularity"}, {"score": 0.02556638506390357, "phrase": "total_buffer_size"}, {"score": 0.00481495049065317, "phrase": "buffer_management_trade-offs"}, {"score": 0.004757643419056999, "phrase": "streaming_software_synthesis"}, {"score": 0.00429715240295033, "phrase": "signal_processing"}, {"score": 0.004220624516321415, "phrase": "efficient_processing"}, {"score": 0.00414545383888272, "phrase": "seemingly_infinite_sequence"}, {"score": 0.004096082254543022, "phrase": "input_data"}, {"score": 0.003927848423072668, "phrase": "software_synthesis"}, {"score": 0.0038810583785936505, "phrase": "data_flow_graphs"}, {"score": 0.0037664981403399064, "phrase": "inherent_trade-off"}, {"score": 0.0032423089921154503, "phrase": "buffer's_spatio-temporal_footprints"}, {"score": 0.003109031770476385, "phrase": "buffer_allocation_problem"}, {"score": 0.003071965703296204, "phrase": "two-dimensional_packing"}, {"score": 0.0029280552768499056, "phrase": "packing_problem"}, {"score": 0.002893140560765452, "phrase": "e._g."}, {"score": 0.0026600905156986317, "phrase": "evolutionary_packing_optimization_algorithm"}, {"score": 0.002597012212823168, "phrase": "buffer_allocations"}, {"score": 0.0025660347613972573, "phrase": "experimental_results"}, {"score": 0.002373472641477602, "phrase": "generated_implementations"}, {"score": 0.0022758279600841014, "phrase": "dramatic_improvements"}, {"score": 0.0021304214257321, "phrase": "additional_cost"}, {"score": 0.0021049977753042253, "phrase": "optimization_runtime"}], "paper_keywords": ["Algorithms", " Performance", " Streaming applications", " software synthesis", " synchronous data flow", " postscheduling", " buffer management", " optimization"], "paper_abstract": "Streaming applications, which are abundant in many disciplines such as multimedia, networking, and signal processing, require efficient processing of a seemingly infinite sequence of input data. In the context of streaming software synthesis from data flow graphs, we study the inherent trade-off between memory requirement and compilation runtime, under a given task firing schedule. We utilize postscheduling analysis granularity to control the amount of details in characterization of buffer's spatio-temporal footprints. Subsequently, we transform the buffer allocation problem to two-dimensional packing of polygons, where complexity of the packing problem (e. g., polygon shapes) is determined by the analysis granularity. We develop an evolutionary packing optimization algorithm which readily yields buffer allocations. Experimental results highlight the trade-off between complexity of the analysis and the total buffer size of generated implementations. In addition, they show dramatic improvements in total buffer size, if one is willing to pay the additional cost in optimization runtime.", "paper_title": "Postscheduling Buffer Management Trade-Offs in Streaming Software Synthesis", "paper_id": "WOS:000307079000009"}