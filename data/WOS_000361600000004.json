{"auto_keywords": [{"score": 0.04277460225039281, "phrase": "false_alarms"}, {"score": 0.02705502490725876, "phrase": "varvel"}, {"score": 0.00481495049065317, "phrase": "scalable_and_scope-bounded_software_verification"}, {"score": 0.004780633011300165, "phrase": "varvel._software"}, {"score": 0.004712726613162057, "phrase": "static_analysis"}, {"score": 0.004563427013973105, "phrase": "automated_software_verification"}, {"score": 0.004340488340181084, "phrase": "industry_practice"}, {"score": 0.0036292245355184576, "phrase": "analysis_problem"}, {"score": 0.003603327452846714, "phrase": "manageable_parts"}, {"score": 0.0034148795808317555, "phrase": "useful_specifications"}, {"score": 0.00323625520042892, "phrase": "inference_techniques"}, {"score": 0.0031223774204093713, "phrase": "verification_scope"}, {"score": 0.0028041618337853, "phrase": "iterative_reasoning"}, {"score": 0.0027741761880779535, "phrase": "calling_environment"}, {"score": 0.0027151607914592552, "phrase": "non-trivial_bugs"}, {"score": 0.002591554263245753, "phrase": "software_model_checking_tool"}, {"score": 0.00249135867469492, "phrase": "industrial_use"}, {"score": 0.002473572879934031, "phrase": "nec"}, {"score": 0.0023356699564158426, "phrase": "usability_improvements"}, {"score": 0.0022696277881969896, "phrase": "numerous_large_software_projects"}, {"score": 0.002237308726827077, "phrase": "model_simplifications"}, {"score": 0.002174041708084857, "phrase": "debugging_assistance"}, {"score": 0.0021049977753042253, "phrase": "experimental_evaluations"}], "paper_keywords": ["Software model checking", " Program analysis", " Abstract interpretation", " Scope bounding", " Bug detection", " Witness presentation"], "paper_abstract": "Software model checking and static analysis have matured over the last decade, enabling their use in automated software verification. However, lack of scalability makes these tools hard to apply in industry practice. Furthermore, approximations in the models of program and environment lead to a profusion of false alarms. This paper proposes DC2, a verification framework using scope-bounding to address the issue of scalability, while retaining enough precision to avoid false alarms in practice. DC2 splits the analysis problem into manageable parts, relying on a combination of three automated techniques: (a) techniques to infer useful specifications for functions in the form of pre- and post-conditions; (b) stub inference techniques that infer abstractions to replace function calls beyond the verification scope; and (c) automatic refinement of pre- and post-conditions using counterexamples that are deemed to be false alarms by a user. The techniques enable DC2 to perform iterative reasoning over the calling environment of functions, to find non-trivial bugs and fewer false alarms. Based on the DC2 framework, we have developed a software model checking tool for C/C++ programs called Varvel, which has been in industrial use at NEC for a number of years. In addition to DC2, we describe other scalability and usability improvements in Varvel that have enabled its successful application on numerous large software projects. These include model simplifications, support for witness understanding to improve debugging assistance, and handling of C++ programs. We present experimental evaluations that demonstrate the effectiveness of DC2 and report on the usage of Varvel in NEC.", "paper_title": "Scalable and scope-bounded software verification in VARVEL", "paper_id": "WOS:000361600000004"}