{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "software-based_speculative_parallelization"}, {"score": 0.004676575291629554, "phrase": "runtime_technique"}, {"score": 0.004586531354697466, "phrase": "sequential_code"}, {"score": 0.00443308765153716, "phrase": "dependence_violations"}, {"score": 0.004263972370406983, "phrase": "dependence_violation"}, {"score": 0.004061584718427419, "phrase": "sequential_execution"}, {"score": 0.003906586074865932, "phrase": "offending_thread"}, {"score": 0.0036671822784770463, "phrase": "particular_violation"}, {"score": 0.0035100601949451028, "phrase": "design_space"}, {"score": 0.003359647377874098, "phrase": "new_mechanism"}, {"score": 0.0031536550157613974, "phrase": "data_dependence_violation"}, {"score": 0.0029602552900111433, "phrase": "inter-thread_dependencies"}, {"score": 0.0028471655497661528, "phrase": "offending_threads"}, {"score": 0.0026209522797963447, "phrase": "new_approach"}, {"score": 0.00259554612218815, "phrase": "existent_solutions"}, {"score": 0.0025578967205807843, "phrase": "real_system"}, {"score": 0.0025207920578878894, "phrase": "different_applications"}, {"score": 0.002286781334850213, "phrase": "relative_performance_improvement"}, {"score": 0.002135995282374723, "phrase": "squashed_threads"}, {"score": 0.0021049977753042253, "phrase": "speculative_parallelization_scheme"}], "paper_keywords": ["Thread-level speculation", " optimistic parallelization", " loop-based parallelization"], "paper_abstract": "Speculative parallelization is a runtime technique that optimistically executes sequential code in parallel, checking that no dependence violations arise. In the case of a dependence violation, all mechanisms proposed so far either switch to sequential execution, or conservatively stop and restart the offending thread and all its successors, potentially discarding work that does not depend on this particular violation. In this work we systematically explore the design space of solutions for this problem, proposing a new mechanism that reduces the number of threads that should be restarted when a data dependence violation is found. Our new solution, called exclusive squashing, keeps track of inter-thread dependencies at runtime, selectively stopping and restarting offending threads, together with all threads that have consumed data from them. We have compared this new approach with existent solutions on a real system, executing different applications with loops that are not analyzable at compile time and present as much as 10% of inter-thread dependence violations at runtime. Our experimental results show a relative performance improvement of up to 14%, together with a reduction of one-third of the numbers of squashed threads. The speculative parallelization scheme and benchmarks described in this paper are available under request.", "paper_title": "Squashing Alternatives for Software-Based Speculative Parallelization", "paper_id": "WOS:000338511000018"}