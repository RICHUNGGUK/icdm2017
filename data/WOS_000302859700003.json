{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "parallel_ripple_search"}, {"score": 0.0047732596509542135, "phrase": "game_developers"}, {"score": 0.004630150894006861, "phrase": "huge_numbers"}, {"score": 0.0045108906244892165, "phrase": "increasingly_large_and_detailed_virtual_worlds"}, {"score": 0.004394688617163029, "phrase": "multi-core_architectures"}, {"score": 0.00428146713705618, "phrase": "expensive_pathfinding_operations"}, {"score": 0.00417115038996633, "phrase": "traditional_single-processor_pathfinding_strategies"}, {"score": 0.003660614912817745, "phrase": "large_overhead"}, {"score": 0.003581797255879607, "phrase": "optimal_paths"}, {"score": 0.0030754582519753474, "phrase": "high-level_graph"}, {"score": 0.00303553181618577, "phrase": "local_search_areas"}, {"score": 0.0030092017034068666, "phrase": "cpu_cores"}, {"score": 0.0029830992938695033, "phrase": "equidistant_intervals"}, {"score": 0.0027943943921568456, "phrase": "good_guesstimate_points"}, {"score": 0.002770150086489194, "phrase": "border_touch"}, {"score": 0.002663620639539737, "phrase": "expensive_parallel_programming_synchronization_locks"}, {"score": 0.002594880866651459, "phrase": "opportunistic_use"}, {"score": 0.0025723630851105304, "phrase": "node_collisions"}, {"score": 0.0025500402081330394, "phrase": "cooperating_cores"}, {"score": 0.0025059724686541263, "phrase": "multi-core's_shared_memory_architecture"}, {"score": 0.0023886641270884973, "phrase": "full_speed"}, {"score": 0.0021987994275190314, "phrase": "dynamic_obstacles"}, {"score": 0.0021702292394814144, "phrase": "natural_way"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Parallel Ripple Search", " pathfinding", " parallel algorithms", " multi-core architectures"], "paper_abstract": "Game developers are often faced with very demanding requirements on huge numbers of agents moving naturally through increasingly large and detailed virtual worlds. With the advent of multi-core architectures, new approaches to accelerate expensive pathfinding operations are worth being investigated. Traditional single-processor pathfinding strategies, such as A* and its derivatives, have been long praised for their flexibility. We implemented several parallel versions of such algorithms to analyze their intrinsic behavior, concluding that they have a large overhead, yield far from optimal paths, do not scale up to many cores or are cache unfriendly. In this article, we propose Parallel Ripple Search, a novel parallel pathfinding algorithm that largely solves these limitations. It utilizes a high-level graph to assign local search areas to CPU cores at equidistant intervals. These cores then use A* flooding behavior to expand towards each other, yielding good guesstimate points at border touch on. The process does not rely on expensive parallel programming synchronization locks but instead relies on the opportunistic use of node collisions among cooperating cores, exploiting the multi-core's shared memory architecture. As a result, all cores effectively run at full speed until enough way-points are found. We show that this approach is a fast, practical and scalable solution and that it flexibly handles dynamic obstacles in a natural way. Copyright (C) 2012 John Wiley & Sons, Ltd.", "paper_title": "Multi-core scalable and efficient pathfinding with Parallel Ripple Search", "paper_id": "WOS:000302859700003"}