{"auto_keywords": [{"score": 0.042107603951746134, "phrase": "read_operation"}, {"score": 0.02244403548051471, "phrase": "step_complexity"}, {"score": 0.010355333074254706, "phrase": "max_registers"}, {"score": 0.00481495049065317, "phrase": "polylogarithmic_concurrent_data_structures"}, {"score": 0.004795200895225848, "phrase": "monotone_circuits"}, {"score": 0.0047267100475487595, "phrase": "useful_concurrent_data_structures"}, {"score": 0.004238775572746022, "phrase": "key_step"}, {"score": 0.004161050160020356, "phrase": "max_register"}, {"score": 0.004042955729336173, "phrase": "write_operation"}, {"score": 0.003985166330358716, "phrase": "largest_value"}, {"score": 0.003944392608697896, "phrase": "fixed_m"}, {"score": 0.003920128102807887, "phrase": "m-valued_max_register"}, {"score": 0.00370833093475637, "phrase": "unbounded_max_register"}, {"score": 0.0035369291417564606, "phrase": "monotone_circuit"}, {"score": 0.003515162360861593, "phrase": "wait-free_concurrent_data_structure"}, {"score": 0.003352658916650986, "phrase": "largest_input_values"}, {"score": 0.0031068064097811844, "phrase": "current_value"}, {"score": 0.0030686679245324837, "phrase": "polynomially-many_increments"}, {"score": 0.00298148348580958, "phrase": "best_previously_known_upper_bounds"}, {"score": 0.0029509483926257645, "phrase": "exact_counting"}, {"score": 0.0029147175927233546, "phrase": "approximate_counting"}, {"score": 0.0028612013515115753, "phrase": "upper_bounds"}, {"score": 0.00280288726371104, "phrase": "deterministic_implementations"}, {"score": 0.002678734566245688, "phrase": "lower_bound_on_the_worst-case_complexity_for_an_m-valued_bounded_max_register"}, {"score": 0.0024466435732258427, "phrase": "m-valued_k-additive-accurate_counter"}, {"score": 0.0023527296826339225, "phrase": "additive_error"}, {"score": 0.002314271047073693, "phrase": "increment_operations"}, {"score": 0.0022670785913397637, "phrase": "solo-terminating_randomized_implementation"}, {"score": 0.0022531089868518235, "phrase": "n-valued_max_register"}, {"score": 0.002225426912273257, "phrase": "global_coins"}, {"score": 0.002207160984451439, "phrase": "simple_schedules"}, {"score": 0.0021845387990972543, "phrase": "high_probability"}, {"score": 0.0021710766932077972, "phrase": "worst-case_step_complexity"}, {"score": 0.0021049977753042253, "phrase": "write_operations"}], "paper_keywords": ["Algorithms", " Theory", " Distributed computing", " shared memory", " max registers", " counters", " monotone circuits"], "paper_abstract": "This article presents constructions of useful concurrent data structures, including max registers and counters, with step complexity that is sublinear in the number of processes, n. This result avoids a well-known lower bound by having step complexity that is polylogarithmic in the number of values the object can take or the number of operations applied to it. The key step in these implementations is amethod for constructing a max register, a linearizable, wait-free concurrent data structure that supports a write operation and a read operation that returns the largest value previously written. For fixed m, an m-valued max register is constructed from one-bit multi-writer multireader registers at a cost of at most [log m] atomic register operations per write or read. An unbounded max register is constructed with cost O(min(log v, n)) to read or write a value v. Max registers are used to transform any monotone circuit into a wait-free concurrent data structure that provides write operations setting the inputs to the circuit and a read operation that returns the value of the circuit on the largest input values previously supplied. One application is a simple, linearizable, waitfree counter with a cost of O(min(log nlog v, n)) to perform an increment and O(min(log v, n)) to perform a read, where v is the current value of the counter. For polynomially-many increments, this becomes O(log(2) n), an exponential improvement on the best previously known upper bounds of O(n) for exact counting and O(n(4/5+epsilon)) for approximate counting. Finally, it is shown that the upper bounds are almost optimal. It is shown that for deterministic implementations, even if they are only required to satisfy solo-termination, min([log m], n - 1) is a lower bound on the worst-case complexity for an m-valued bounded max register, which is exactly equal to the upper bound for m <= 2(n-1), and min(n-1, [log m] - log ([log m] + k)) is a lower bound for the read operation of an m-valued k-additive-accurate counter, which is a bounded counter in which a read operation is allowed to return a value within an additive error of +/- k of the number of increment operations linearized before it. Furthermore, even in a solo-terminating randomized implementation of an n-valued max register with an oblivious adversary and global coins, there exist simple schedules in which, with high probability, the worst-case step complexity of a read operation is Omega (log n/log log n) if the write operations have polylogarithmic step complexity.", "paper_title": "Polylogarithmic Concurrent Data Structures from Monotone Circuits", "paper_id": "WOS:000300902200002"}