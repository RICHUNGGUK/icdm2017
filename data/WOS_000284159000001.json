{"auto_keywords": [{"score": 0.04876221941883469, "phrase": "rambo"}, {"score": 0.00481495049065317, "phrase": "dynamic_networks"}, {"score": 0.0041589926969138585, "phrase": "entire_set"}, {"score": 0.004002426645789667, "phrase": "initial_devices"}, {"score": 0.003905864553426306, "phrase": "new_set"}, {"score": 0.0037196472104696157, "phrase": "distributed_shared_memory"}, {"score": 0.003542276457435362, "phrase": "dynamic_changes"}, {"score": 0.003505378950567746, "phrase": "short_intervals"}, {"score": 0.0032012284065895537, "phrase": "longer_intervals"}, {"score": 0.003048502724695561, "phrase": "newly_joined_devices"}, {"score": 0.00293361812353423, "phrase": "main_novelty"}, {"score": 0.002842840150239715, "phrase": "efficient_reconfiguration_mechanism"}, {"score": 0.0028132076314202606, "phrase": "quorum-based_replication_strategy"}, {"score": 0.0027452574218375593, "phrase": "rambo_algorithm"}, {"score": 0.0027071661844502992, "phrase": "wide_variety"}, {"score": 0.0026883186885595127, "phrase": "aberrant_behavior"}, {"score": 0.002506894277338543, "phrase": "stored_consistency"}, {"score": 0.0023052356887304226, "phrase": "timely_fashion"}], "paper_keywords": ["Dynamic distributed systems", " Atomic register", " Distributed shared memory", " Fault-tolerance", " Reconfigurable", " Eventual synchrony"], "paper_abstract": "In this paper, we present Rambo, an algorithm for emulating a read/write distributed shared memory in a dynamic, rapidly changing environment. Rambo provides a highly reliable, highly available service, even as participants join, leave, and fail. In fact, the entire set of participants may change during an execution, as the initial devices depart and are replaced by a new set of devices. Even so, Rambo ensures that data stored in the distributed shared memory remains available and consistent. There are two basic techniques used by Rambo to tolerate dynamic changes. Over short intervals of time, replication suffices to provide fault-tolerance. While some devices may fail and leave, the data remains available at other replicas. Over longer intervals of time, Rambo copes with changing participants via reconfiguration, which incorporates newly joined devices while excluding devices that have departed or failed. The main novelty of Rambo lies in the combination of an efficient reconfiguration mechanism with a quorum-based replication strategy for read/write shared memory. The Rambo algorithm can tolerate a wide variety of aberrant behavior, including lost and delayed messages, participants with unsynchronized clocks, and, more generally, arbitrary asynchrony. Despite such behavior, Rambo guarantees that its data is stored consistency. We analyze the performance of Rambo during periods when the system is relatively well-behaved: messages are delivered in a timely fashion, reconfiguration is not too frequent, etc. We show that in these circumstances, read and write operations are efficient, completing in at most eight message delays.", "paper_title": "Rambo: a robust, reconfigurable atomic memory service for dynamic networks", "paper_id": "WOS:000284159000001"}