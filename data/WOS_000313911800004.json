{"auto_keywords": [{"score": 0.035575227687234805, "phrase": "non-dominant_threads"}, {"score": 0.010082280851223131, "phrase": "shared_data"}, {"score": 0.0045765783794477505, "phrase": "thread_safety"}, {"score": 0.004513631630494221, "phrase": "data_structures"}, {"score": 0.004192190072470619, "phrase": "multiple_threads"}, {"score": 0.0040215052006051235, "phrase": "common_access_pattern"}, {"score": 0.003616108223034427, "phrase": "biased_locks"}, {"score": 0.0035010071030752883, "phrase": "single_dominant_thread"}, {"score": 0.0034052594710793664, "phrase": "greater_overheads"}, {"score": 0.0032514447965530354, "phrase": "new_family"}, {"score": 0.0032215231177304513, "phrase": "biased_synchronization_mechanisms"}, {"score": 0.0031479142819948007, "phrase": "modified_interface"}, {"score": 0.00288317238346065, "phrase": "message_passing_mechanisms"}, {"score": 0.0027913353347879507, "phrase": "critical_sections"}, {"score": 0.0027528751037412128, "phrase": "queueing_work"}, {"score": 0.0025447065763362984, "phrase": "asynchronous_critical_section_accesses"}, {"score": 0.0024636239664210433, "phrase": "conventional_intel"}, {"score": 0.002418453525649304, "phrase": "sandy_bridge"}, {"score": 0.0023199017847424447, "phrase": "tm"}, {"score": 0.002204697943520258, "phrase": "existing_biased_locking_algorithms"}, {"score": 0.0021049977753042253, "phrase": "existing_algorithms"}], "paper_keywords": ["Algorithms", " Performance", " Synchronization", " biased locking"], "paper_abstract": "For most multi-threaded applications, data structures must be shared between threads. Ensuring thread safety on these data structures incurs overhead in the form of locking and other synchronization mechanisms. Where data is shared among multiple threads these costs are unavoidable. However, a common access pattern is that data is accessed primarily by one dominant thread, and only very rarely by the other, non-dominant threads. Previous research has proposed biased locks, which are optimized for a single dominant thread, at the cost of greater overheads for non-dominant threads. In this article we propose a new family of biased synchronization mechanisms that, using a modified interface, push accesses to shared data from the non-dominant threads to the dominant one, via a novel set of message passing mechanisms. We present mechanisms for protecting critical sections, for queueing work, for caching shared data in registers where it is safe to do so, and for asynchronous critical section accesses. We present results for the conventional Intel (R) Sandy Bridge processor and for the emerging network-optimized many-core IBM (R) PowerEN (TM) processor. We find that our algorithms compete well with existing biased locking algorithms, and, in particular, perform better than existing algorithms as accesses from non-dominant threads increase.", "paper_title": "Fast Asymmetric Thread Synchronization", "paper_id": "WOS:000313911800004"}