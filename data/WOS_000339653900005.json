{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "largest_empty"}, {"score": 0.00429057323623293, "phrase": "n_points"}, {"score": 0.0039729853486821995, "phrase": "efficient_algorithm"}, {"score": 0.0038973170902076707, "phrase": "preprocessing_p"}, {"score": 0.0034063576796640603, "phrase": "largest_disk"}, {"score": 0.002948547333717581, "phrase": "data_structure"}, {"score": 0.0027564303939865476, "phrase": "preprocessing_cost"}, {"score": 0.0022302306304023602, "phrase": "alternative_solution"}, {"score": 0.002166711569953301, "phrase": "improved_query_cost"}, {"score": 0.0021049977753042253, "phrase": "slightly_worse_storage"}], "paper_keywords": [""], "paper_abstract": "Let P be a set of n points in the plane. We present an efficient algorithm for preprocessing P, so that, for a given query point q, we can quickly report the largest disk that contains q but its interior is disjoint from P. The storage required by the data structure is O(n log n), the preprocessing cost is O(n log(2) n), and a query takes O(log(2) n) time. We also present an alternative solution with an improved query cost and with slightly worse storage and preprocessing requirements.", "paper_title": "FINDING THE LARGEST EMPTY DISK CONTAINING A QUERY POINT", "paper_id": "WOS:000339653900005"}