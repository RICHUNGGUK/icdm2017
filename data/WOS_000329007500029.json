{"auto_keywords": [{"score": 0.0466864385803342, "phrase": "job_size"}, {"score": 0.024887636613523813, "phrase": "array-based_design"}, {"score": 0.004815116388816293, "phrase": "mpi"}, {"score": 0.004722898398399427, "phrase": "large-scale_jobs"}, {"score": 0.0043215158337835706, "phrase": "message_queues"}, {"score": 0.004206236029936448, "phrase": "fast_queue_operations"}, {"score": 0.004173865018011237, "phrase": "large_scales"}, {"score": 0.004125773078637226, "phrase": "paramount_importance"}, {"score": 0.004031238480458909, "phrase": "upcoming_exascale_computing_eras"}, {"score": 0.0038634933357842302, "phrase": "growing_processor_core_density"}, {"score": 0.0037749456215035856, "phrase": "expected_smaller_memory_density"}, {"score": 0.0037170399498025215, "phrase": "larger_scales"}, {"score": 0.0035899674590142653, "phrase": "memory_requirements"}, {"score": 0.003548579306515579, "phrase": "scalability_issue"}, {"score": 0.0034405207528624983, "phrase": "operation_problem"}, {"score": 0.0033357416981328577, "phrase": "multidimensional_queue_management_mechanism"}, {"score": 0.0032718761046588835, "phrase": "memory_overhead"}, {"score": 0.003111472132927442, "phrase": "novel_approach"}, {"score": 0.003005039427642664, "phrase": "well-known_and_fast_data_structures"}, {"score": 0.0028687545730861665, "phrase": "linked_list-based_approach"}, {"score": 0.002707033618304716, "phrase": "array-based_method"}, {"score": 0.002624533657819515, "phrase": "memory_consumption"}, {"score": 0.0025842289219860795, "phrase": "queue_operation_time_speedups"}, {"score": 0.0024957862318504753, "phrase": "linked_list_design"}, {"score": 0.002373339527491525, "phrase": "consistent_lower_memory_footprint"}, {"score": 0.0022744242010653997, "phrase": "linked_list-based_queue"}, {"score": 0.0022308329460335985, "phrase": "rate_improvements"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["MPI", " Message queues", " Multidimensional searches", " Scalability", " Exascale"], "paper_abstract": "The Message Passing Interface (MPI) message queues have been shown to grow proportionately to the job size for many applications. With such a behaviour and knowing that message queues are used very frequently, ensuring fast queue operations at large scales is of paramount importance in the current and the upcoming exascale computing eras. Scalability, however, is two-fold. With the growing processor core density per node, and the expected smaller memory density per core at larger scales, a queue mechanism that is blind on memory requirements poses another scalability issue even if it solves the speed of operation problem. In this work we propose a multidimensional queue management mechanism whose operation time and memory overhead grow sub-linearly with the job size. We show why a novel approach is justified in spite of the existence of well-known and fast data structures such as binary search trees. We compare our proposal with a linked list-based approach which is not scalable in terms of speed of operation, and with an array-based method which is not scalable in terms of memory consumption. Our proposed multidimensional approach yields queue operation time speedups that translate to up to 4-fold execution time improvement over the linked list design for the applications studied in this work. It also shows a consistent lower memory footprint compared to the array-based design. Finally, compared to the linked list-based queue, our proposed design yields cache miss rate improvements which are on average on par with the array-based design. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "A fast and resource-conscious MPI message queue mechanism for large-scale jobs", "paper_id": "WOS:000329007500029"}