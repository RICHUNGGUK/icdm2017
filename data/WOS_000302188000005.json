{"auto_keywords": [{"score": 0.04419846536070136, "phrase": "rtsj"}, {"score": 0.014915304258076415, "phrase": "java"}, {"score": 0.013553203159795999, "phrase": "scoped_memory_model"}, {"score": 0.011737918301168547, "phrase": "scoped_memory_areas"}, {"score": 0.00481495049065317, "phrase": "rtsj_memory_management"}, {"score": 0.004610058444728656, "phrase": "real-time_system"}, {"score": 0.004478308876320956, "phrase": "memory_behaviour"}, {"score": 0.0043713857434347254, "phrase": "functional_requirements"}, {"score": 0.004308455856718928, "phrase": "real-time_specification"}, {"score": 0.004085333687668526, "phrase": "garbage_collection_delays"}, {"score": 0.004046020290832207, "phrase": "critical_real-time_applications"}, {"score": 0.003949377440799037, "phrase": "hard_real-time_constraints"}, {"score": 0.003799509133780117, "phrase": "garbage_collection"}, {"score": 0.0036201167891046046, "phrase": "real-time_application"}, {"score": 0.0034159525504642656, "phrase": "runtime_errors"}, {"score": 0.0033182152378613767, "phrase": "precisely_how_many_scoped_memory_areas"}, {"score": 0.0030121159909273897, "phrase": "real-time_systems"}, {"score": 0.002869793011316547, "phrase": "current_approaches"}, {"score": 0.0028284184438992282, "phrase": "scoped_memory_management"}, {"score": 0.002801166393333128, "phrase": "new_emerging_challenges"}, {"score": 0.002760778494680823, "phrase": "scoped_memory_management_model"}, {"score": 0.0024342079318127423, "phrase": "optimal_scoped_memory_model"}, {"score": 0.0022967713922705, "phrase": "current_solutions"}, {"score": 0.002252701813819903, "phrase": "new_research_questions"}, {"score": 0.0022202042044679984, "phrase": "realtime_java_systems"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["RTSJ memory management", " Scoped memory", " Immortal memory", " Memory regions", " Real-time Java", " Benchmarks", " Programming languages"], "paper_abstract": "Developing a real-time system in Java requires awareness of memory behaviour in addition to software functional requirements. The Real-Time Specification for Java (RTSJ) introduces a scoped memory model to avoid garbage collection delays in critical real-time applications which need to meet hard real-time constraints. Scoped memory management has certain advantages over garbage collection in terms of predictability. However, developing a real-time application using scoped memory areas (regions) may suffer from both design and runtime errors. Moreover, from a memory footprint perspective, the inability to determine precisely how many scoped memory areas should be used and which objects or threads should be allocated into these scoped memory areas makes using RTSJ problematic for developing real-time systems. In this paper, a survey of the current approaches to improve scoped memory management and new emerging challenges in RTSJ scoped memory management model are presented. Categorizing those problems and challenges provides a picture of the issues researchers have yet to investigate and to support solutions for an optimal scoped memory model. Current approaches and a set of benchmarks used to evaluate current solutions are presented and new research questions in developing realtime Java systems using a scoped memory model are proposed. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Region-Based RTSJ Memory Management: State of the art", "paper_id": "WOS:000302188000005"}