{"auto_keywords": [{"score": 0.049498146181447024, "phrase": "recursive_game_graphs"}, {"score": 0.004815168583768755, "phrase": "modular"}, {"score": 0.0046797114400479135, "phrase": "formal_verification"}, {"score": 0.004641770842098217, "phrase": "program_analysis"}, {"score": 0.0044747919503484055, "phrase": "two-player_games"}, {"score": 0.004091370602573054, "phrase": "sequential_programs"}, {"score": 0.004058180509184539, "phrase": "recursive_procedure_calls"}, {"score": 0.003912112659326054, "phrase": "pushdown_games"}, {"score": 0.003802135020791801, "phrase": "natural_notion"}, {"score": 0.003217124533918232, "phrase": "current_invocation"}, {"score": 0.0029531640201737384, "phrase": "modular_games"}, {"score": 0.002918450731006152, "phrase": "np"}, {"score": 0.0028351712509358997, "phrase": "fixed-point_computation_algorithm"}, {"score": 0.0027330029055210926, "phrase": "worst_case"}, {"score": 0.002634506575564286, "phrase": "total_number"}, {"score": 0.002613103872300205, "phrase": "returned_values"}, {"score": 0.0024480094603893175, "phrase": "global_history"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["model-checking", " games in verification", " pushdown systems"], "paper_abstract": "Many problems in formal verification and program analysis can be formalized as computing winning strategies for two-player games on graphs. In this paper, we focus on solving games in recursive game graphs which can model the control flow in sequential programs with recursive procedure calls. While such games can be viewed as the pushdown games studied in the literature, the natural notion of winning in our framework requires the strategies to be modular with only local memory; that is, resolution of choices within a module does not depend on the context in which the module is invoked, but only on the history within the current invocation of the module. While reachability in (global) pushdown games is known to be EXPTIME-complete, we show reachability in modular games to be NP-complete. We present a fixed-point computation algorithm for solving modular games such that in the worst case the number of iterations is exponential in the total number of returned values from the modules. If the strategy within a module does not depend on the global history, but can remember the history of the past invocations of this module, that is, if memory is local but persistent, we show that reachability becomes undecidable. (c) 2005 Published by Elsevier B.V.", "paper_title": "Modular strategies for recursive game graphs", "paper_id": "WOS:000236485400005"}