{"auto_keywords": [{"score": 0.03874834581291972, "phrase": "proposed_approach"}, {"score": 0.00481495049065317, "phrase": "multicore_applications"}, {"score": 0.004713162564945179, "phrase": "multiprocessor_systems"}, {"score": 0.004663074596384574, "phrase": "major_challenge"}, {"score": 0.004629977311316031, "phrase": "modern_computer_science"}, {"score": 0.0045971138571344345, "phrase": "multicore_programming"}, {"score": 0.004420472010542188, "phrase": "fundamental_data_structures"}, {"score": 0.004373480870285314, "phrase": "standard_collection"}, {"score": 0.004342430078306461, "phrase": "data_structures"}, {"score": 0.0042354707960660706, "phrase": "sequential_standard_template_library"}, {"score": 0.0038606630003037864, "phrase": "highly_concurrent_fundamental_data_structures"}, {"score": 0.0037789720824759503, "phrase": "associated_programming_interface"}, {"score": 0.003752126270661821, "phrase": "advanced_optimization_support"}, {"score": 0.0034567253581991226, "phrase": "internal_support"}, {"score": 0.003432160899769594, "phrase": "nonblocking_synchronization"}, {"score": 0.00335950642866031, "phrase": "better_safety"}, {"score": 0.0033119237381809617, "phrase": "traditional_blocking_synchronization"}, {"score": 0.003150612723641925, "phrase": "priority_inversion"}, {"score": 0.0030402088074201793, "phrase": "large_numbers"}, {"score": 0.002986461855862617, "phrase": "new_library"}, {"score": 0.0028715299874549245, "phrase": "fundamental_computations"}, {"score": 0.0028511121935559072, "phrase": "multithreaded_contexts"}, {"score": 0.0027610089418453614, "phrase": "familiar_look"}, {"score": 0.0026737455737636867, "phrase": "immense_boost"}, {"score": 0.002635850034826311, "phrase": "software_reuse"}, {"score": 0.002561658528837694, "phrase": "scientific_and_systems_applications"}, {"score": 0.002454258761940649, "phrase": "concurrent_replacement_library"}, {"score": 0.002419466507425567, "phrase": "immediate_practical_relevance"}, {"score": 0.0023936956017015696, "phrase": "significant_impact"}, {"score": 0.0023513512089705303, "phrase": "parallel_programming_domains"}, {"score": 0.0023180144105895257, "phrase": "massive_data_mining"}, {"score": 0.0023015232625177755, "phrase": "computational_biology"}, {"score": 0.0022851491693940272, "phrase": "financial_engineering"}, {"score": 0.0022527488455744656, "phrase": "control_systems"}, {"score": 0.0021429152327481892, "phrase": "first_design"}, {"score": 0.0021049977753042253, "phrase": "wait_free_hash_table"}], "paper_keywords": ["Nonblocking", " data container", " library", " concurrency", " parallelism", " data structures", " non-blocking", " lock-free", " wait-free", " parallel programming", " data storage", " hash table"], "paper_abstract": "Exploiting the parallelism in multiprocessor systems is a major challenge in modern computer science. Multicore programming demands a change in the way we design and use fundamental data structures. The standard collection of data structures and algorithms in C++11 is the sequential standard template library (STL). In this paper, we present their vision for the theory and practice for the design and implementation of a collection of highly concurrent fundamental data structures for multiprocessor application development with associated programming interface and advanced optimization support. Specifically, the proposed approach will provide a familiar, easy-to-use, and composable interface, similar to that of C++ STL. Each container type will be enhanced with internal support for nonblocking synchronization of its data access, thereby providing better safety and performance than traditional blocking synchronization by: 1) eliminating hazards such as deadlock, livelock, and priority inversion and 2) by being highly scalable in supporting large numbers of threads. The new library, lockless containers/data concurrency, will provide algorithms for handling fundamental computations in multithreaded contexts, and will incorporate these into libraries with familiar look and feel. The proposed approach will provide an immense boost in performance and software reuse, consequently productivity, for developers of scientific and systems applications, which are predominantly in C/C++. STL is widely used and a concurrent replacement library will have an immediate practical relevance and a significant impact on a variety of parallel programming domains including simulation, massive data mining, computational biology, financial engineering, and embedded control systems. As a proof-of-concept, this paper discusses the first design and implementation of a wait free hash table.", "paper_title": "LC/DC: lockless Containers and Data Concurrency A Novel Nonblocking Container Library for Multicore Applications", "paper_id": "WOS:000209652700050"}