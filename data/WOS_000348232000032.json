{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "control_flow"}, {"score": 0.006978249887058187, "phrase": "destruction_algorithms"}, {"score": 0.00685016341536279, "phrase": "arbitrarily_complex_control_flow"}, {"score": 0.006662398905589436, "phrase": "ddg_representation"}, {"score": 0.0047852458513833315, "phrase": "demand_dependence"}, {"score": 0.004741030507509777, "phrase": "demand-based_dependence_graphs"}, {"score": 0.004525979481628125, "phrase": "intermediate_representations"}, {"score": 0.004415284957189386, "phrase": "wide_range"}, {"score": 0.004388035083357706, "phrase": "program_transformations"}, {"score": 0.004163069673268028, "phrase": "restricted_form"}, {"score": 0.004023662440623241, "phrase": "automatic_parallelization"}, {"score": 0.0039009678436644183, "phrase": "practical_compilers"}, {"score": 0.003876879827074979, "phrase": "efficient_construction"}, {"score": 0.0035879931522580745, "phrase": "efficient_object_code"}, {"score": 0.003446353878654566, "phrase": "structural_constraints"}, {"score": 0.003414467360488913, "phrase": "generatable_control_flow"}, {"score": 0.003372408902017458, "phrase": "qualitative_evaluation"}, {"score": 0.003341204247243636, "phrase": "key_contribution"}, {"score": 0.0032292292848296617, "phrase": "intrinsic_structural_limitation"}, {"score": 0.0031306834002600547, "phrase": "fundamental_result"}, {"score": 0.003073000846658596, "phrase": "loop_repetition"}, {"score": 0.003054009753601139, "phrase": "decision_predicates"}, {"score": 0.003035135667860725, "phrase": "computed_continuations"}, {"score": 0.002960795132939529, "phrase": "predicate_continuation"}, {"score": 0.002951631137816642, "phrase": "normal_form"}, {"score": 0.0028615323526689582, "phrase": "predicate_continuation_form"}, {"score": 0.002817516691031648, "phrase": "novel_destruction_algorithm"}, {"score": 0.002656327554326748, "phrase": "original_cfg"}, {"score": 0.002575219653364536, "phrase": "overspecific_detail"}, {"score": 0.002375714262344562, "phrase": "representational_overhead"}, {"score": 0.002361022183015472, "phrase": "compile_time"}, {"score": 0.002317487599170394, "phrase": "branch_instructions"}, {"score": 0.0022960215670802774, "phrase": "existing_solutions"}, {"score": 0.002260684786333025, "phrase": "previous_work"}, {"score": 0.0022258906408344973, "phrase": "additional_overhead"}, {"score": 0.0021848422732893926, "phrase": "produced_object_code"}, {"score": 0.0021312837202666687, "phrase": "first_scheme"}, {"score": 0.0021049977753042253, "phrase": "original_control_flow"}], "paper_keywords": ["Algorithms", " Theory", " Intermediate representations", " control flow", " demand-dependence", " value state dependence graph"], "paper_abstract": "Demand-based dependence graphs (DDGs), such as the (Regionalized) Value State Dependence Graph ((R)VSDG), are intermediate representations (IRs) well suited for a wide range of program transformations. They explicitly model the flow of data and state, and only implicitly represent a restricted form of control flow. These features make DDGs especially suitable for automatic parallelization and vectorization, but cannot be leveraged by practical compilers without efficient construction and destruction algorithms. Construction algorithms remodel the arbitrarily complex control flow of a procedure to make it amenable to DDG representation, whereas destruction algorithms reestablish control flow for generating efficient object code. Existing literature presents solutions to both problems, but these impose structural constraints on the generatable control flow, and omit qualitative evaluation. The key contribution of this article is to show that there is no intrinsic structural limitation in the control flow directly extractable from RVSDGs. This fundamental result originates from an interpretation of loop repetition and decision predicates as computed continuations, leading to the introduction of the predicate continuation normal form. We provide an algorithm for constructing RVSDGs in predicate continuation form, and propose a novel destruction algorithm for RVSDGs in this form. Our destruction algorithm can generate arbitrarily complex control flow; we show this by proving that the original CFG an RVSDG was derived from can, apart from overspecific detail, be reconstructed perfectly. Additionally, we prove termination and correctness of these algorithms. Furthermore, we empirically evaluate the performance, the representational overhead at compile time, and the reduction in branch instructions compared to existing solutions. In contrast to previous work, our algorithms impose no additional overhead on the control flow of the produced object code. To our knowledge, this is the first scheme that allows the original control flow of a procedure to be recovered from a DDG representation.", "paper_title": "Perfect Reconstructability of Control Flow from Demand Dependence Graphs", "paper_id": "WOS:000348232000032"}