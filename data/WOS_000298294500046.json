{"auto_keywords": [{"score": 0.04617122112854065, "phrase": "java"}, {"score": 0.008847034486167953, "phrase": "vm"}, {"score": 0.00481495049065317, "phrase": "jit_compilation_policy"}, {"score": 0.004777917315737992, "phrase": "modern_machines"}, {"score": 0.004491678520807451, "phrase": "managed_languages"}, {"score": 0.0043215158337835706, "phrase": "intermediate_language_binary_codes"}, {"score": 0.004271729935895193, "phrase": "virtual_machine"}, {"score": 0.0041220144146682704, "phrase": "vms"}, {"score": 0.004078232992955235, "phrase": "jit_compilation"}, {"score": 0.003954109842050071, "phrase": "effective_decisions"}, {"score": 0.0038485929962942776, "phrase": "different_program_regions"}, {"score": 0.003789561910103601, "phrase": "best_overall_program_performance"}, {"score": 0.0036884198249734863, "phrase": "jit_compilation_policies"}, {"score": 0.0035761182400032487, "phrase": "single_compiler_thread"}, {"score": 0.0035076666315744525, "phrase": "single-processor_machines"}, {"score": 0.003087500254099842, "phrase": "multiple_concurrent_compiler_threads"}, {"score": 0.00292477450010107, "phrase": "significant_performance_impacts"}, {"score": 0.002846647336160784, "phrase": "hotspot_jvm"}, {"score": 0.0027706013216537042, "phrase": "new_configurations"}, {"score": 0.002728059572916527, "phrase": "modern_java_benchmarks"}, {"score": 0.0026965813247045427, "phrase": "traditional_static_whole-program_discovery"}, {"score": 0.0025842289219860795, "phrase": "future_many-core_hardware"}, {"score": 0.0024385083712241988, "phrase": "increasing_compiler_aggressiveness"}, {"score": 0.002401053532270901, "phrase": "multiple_compiler_threads"}, {"score": 0.002265638487492082, "phrase": "single-core_machines"}, {"score": 0.0022136307563123256, "phrase": "program_performance"}, {"score": 0.0021461354559957234, "phrase": "jit_method_compilations"}], "paper_keywords": ["Languages", " Performance virtual machines", " dynamic compilation", " multicore", " Java"], "paper_abstract": "Dynamic or Just-in-Time (JIT) compilation is crucial to achieve acceptable performance for applications (written in managed languages, such as Java and C#) distributed as intermediate language binary codes for a virtual machine (VM) architecture. Since it occurs at runtime, JIT compilation needs to carefully tune its compilation policy to make effective decisions regarding if and when to compile different program regions to achieve the best overall program performance. Past research has extensively tuned JIT compilation policies, but mainly for VMs with a single compiler thread and for execution on single-processor machines. This work is driven by the need to explore the most effective JIT compilation strategies in their modern operational environment, where (a) processors have evolved from single to multi/many cores, and (b) VMs provide support for multiple concurrent compiler threads. Our results confirm that changing if and when methods are compiled have significant performance impacts. We construct several novel configurations in the HotSpot JVM to facilitate this study. The new configurations are necessitated by modern Java benchmarks that impede traditional static whole-program discovery, analysis and annotation, and are required for simulating future many-core hardware that is not yet widely available. We study the effects on performance of increasing compiler aggressiveness for VMs with multiple compiler threads running on existing single/multi-core and future many-core machines. Our results indicate that although more aggressive JIT compilation policies show no benefits on single-core machines, these can often improve program performance for multi/many-core machines. However, accurately prioritizing JIT method compilations is crucial to realize such benefits.", "paper_title": "JIT Compilation Policy for Modern Machines", "paper_id": "WOS:000298294500046"}