{"auto_keywords": [{"score": 0.04686976522164259, "phrase": "dependent_types"}, {"score": 0.0068106070950838616, "phrase": "real_type_error"}, {"score": 0.004815131602428673, "phrase": "counterexamples"}, {"score": 0.004720606036240263, "phrase": "recent_research"}, {"score": 0.0046741260449047976, "phrase": "abstract_model_checking"}, {"score": 0.0045599093158915326, "phrase": "new_approach"}, {"score": 0.004361276005140776, "phrase": "existing_approaches"}, {"score": 0.00395017798595193, "phrase": "recursive_functions"}, {"score": 0.0038727120021750973, "phrase": "counterexample-guided_refinement"}, {"score": 0.0036673959568781734, "phrase": "main_idea"}, {"score": 0.003577691211998842, "phrase": "classical_fixed-point_type_inference"}, {"score": 0.0033379819706003885, "phrase": "current_set"}, {"score": 0.0033050703534275717, "phrase": "candidate_types"}, {"score": 0.0032241994368246065, "phrase": "interpolating_theorem_prover"}, {"score": 0.003038066486989815, "phrase": "additional_candidate_dependent_types"}, {"score": 0.0029784342137867776, "phrase": "spurious_counterexample"}, {"score": 0.0027925723953701083, "phrase": "sufficient_candidates"}, {"score": 0.0026443691099806003, "phrase": "non-trivial_use"}, {"score": 0.002618278365749875, "phrase": "\"linear\"_intersection_types"}, {"score": 0.0024916260764216752, "phrase": "type_inference_system"}, {"score": 0.0023947191132328233, "phrase": "prototype_implementation"}, {"score": 0.0022901862321082407, "phrase": "ocaml_language"}, {"score": 0.0021793698531006197, "phrase": "quantifier-free_theory"}, {"score": 0.0021049977753042253, "phrase": "uninterpreted_function_symbols"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Verification", " Dependent types", " Intersection types", " Interpolation", " Counterexamples", " Type inference"], "paper_abstract": "Motivated by recent research in abstract model checking, we present a new approach to inferring dependent types. Unlike many of the existing approaches, our approach does not rely on programmers to supply the candidate (or the correct) types for the recursive functions and instead does counterexample-guided refinement to automatically generate the set of candidate dependent types. The main idea is to extend the classical fixed-point type inference routine to return a counterexample if the program is found untypable with the current set of candidate types. Then, an interpolating theorem prover is used to validate the counterexample as a real type error or generate additional candidate dependent types to refute the spurious counterexample. The process is repeated until either a real type error is found or sufficient candidates are generated to prove the program typable. Our system makes non-trivial use of \"linear\" intersection types in the refinement phase. The paper presents the type inference system and reports on the experience with a prototype implementation that infers dependent types for a subset of the Ocaml language. The implementation infers dependent types containing predicates from the quantifier-free theory of linear arithmetic and equality with uninterpreted function symbols.", "paper_title": "Dependent Types from Counterexamples", "paper_id": "WOS:000274028100012"}