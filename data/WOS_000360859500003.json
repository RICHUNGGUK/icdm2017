{"auto_keywords": [{"score": 0.0473529610493366, "phrase": "variability_model"}, {"score": 0.014411148314049525, "phrase": "modeling_language"}, {"score": 0.00481495049065317, "phrase": "model-based_software_product_lines"}, {"score": 0.0047527118741586055, "phrase": "model-based_software_product_line"}, {"score": 0.004497008230182996, "phrase": "core_artifacts"}, {"score": 0.004467840466181518, "phrase": "base_models"}, {"score": 0.004296747096249343, "phrase": "realization_model"}, {"score": 0.004172722575842674, "phrase": "base_model_elements"}, {"score": 0.003999843765164458, "phrase": "design_space"}, {"score": 0.0037112756920669593, "phrase": "derived_product_models"}, {"score": 0.003639471039860495, "phrase": "numerous_well-formedness_and_business_rules"}, {"score": 0.0033222630615013737, "phrase": "invalid_product_models"}, {"score": 0.0032899551003641152, "phrase": "valid_configuration"}, {"score": 0.0030624066849965817, "phrase": "domain-specific_rules"}, {"score": 0.0030326180561817497, "phrase": "earlier_the_specification"}, {"score": 0.003012919635505122, "phrase": "incorrect_mappings"}, {"score": 0.0029933487820771217, "phrase": "testing_oracles"}, {"score": 0.002935393439834135, "phrase": "derivation_engines"}, {"score": 0.002850551552945005, "phrase": "generic_process"}, {"score": 0.002804478352027886, "phrase": "common_variability_language"}, {"score": 0.002688133833564332, "phrase": "specific_modeling_language"}, {"score": 0.0025021056497407765, "phrase": "linegen"}, {"score": 0.0024858445890050614, "phrase": "different_scenarios"}, {"score": 0.002374931094109485, "phrase": "pre-defined_variability_models"}, {"score": 0.0022615684627308283, "phrase": "different_scales"}, {"score": 0.00212569405594774, "phrase": "real_industrial_scenario"}, {"score": 0.0021049977753042253, "phrase": "large-scale_metamodel"}], "paper_keywords": ["Software product lines", " Model-based engineering", " Counterexamples"], "paper_abstract": "In a model-based software product line (MSPL), the variability of the domain is characterized in a variability model and the core artifacts are base models conforming to a modeling language (also called metamodel). A realization model connects the features of the variability model to the base model elements, triggering operations over these elements based on a configuration. The design space of an MSPL is extremely complex to manage for the engineer, since the number of variants may be exponential and the derived product models have to be conforming to numerous well-formedness and business rules. In this paper, the objective is to provide a way to generate MSPLs, called counterexamples (also called antipatterns), that can produce invalid product models despite a valid configuration in the variability model. We describe the foundations and motivate the usefulness of counterexamples (e.g., inference of guidelines or domain-specific rules to avoid earlier the specification of incorrect mappings; testing oracles for increasing the robustness of derivation engines given a modeling language). We provide a generic process, based on the common variability language (CVL) to randomly search the space of MSPLs for a specific modeling language. We develop LineGen a tool on top of CVL and modeling technologies to support the methodology and the process. LineGen targets different scenarios and is flexible to work either with just a domain metamodel as input or also with pre-defined variability models and base models. We validate the effectiveness of this process for three formalisms at different scales (up to 247 metaclasses and 684 rules). We also apply the approach in the context of a real industrial scenario involving a large-scale metamodel.", "paper_title": "Generating counterexamples of model-based software product lines", "paper_id": "WOS:000360859500003"}