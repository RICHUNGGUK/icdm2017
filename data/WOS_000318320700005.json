{"auto_keywords": [{"score": 0.04268690864740321, "phrase": "test_cases"}, {"score": 0.011097828938782228, "phrase": "integration_testing"}, {"score": 0.010415643220105292, "phrase": "internal_behavior"}, {"score": 0.008339048655495448, "phrase": "unit_testing"}, {"score": 0.006815071789202814, "phrase": "black-box_approach"}, {"score": 0.00481495049065317, "phrase": "representative_unit_test_cases"}, {"score": 0.004780926543714981, "phrase": "high-confidence_medical_software"}, {"score": 0.004437807397753662, "phrase": "integrated_software_modules"}, {"score": 0.004163290958633733, "phrase": "target_software"}, {"score": 0.004119211418949265, "phrase": "black_box"}, {"score": 0.003989742144066683, "phrase": "software_module"}, {"score": 0.003796355951305572, "phrase": "thoroughly_test"}, {"score": 0.00378290546281883, "phrase": "interaction_behavior"}, {"score": 0.0037561467438280175, "phrase": "integrated_modules"}, {"score": 0.0037031937016576695, "phrase": "critical_faults"}, {"score": 0.0035995085881892464, "phrase": "safety-critical_systems"}, {"score": 0.0035613768414594262, "phrase": "medical_software"}, {"score": 0.0033647036658823798, "phrase": "thorough_test_cases"}, {"score": 0.0033408932140621948, "phrase": "critical_software"}, {"score": 0.0032937749380725317, "phrase": "new_integration_testing_method"}, {"score": 0.0031340167205149813, "phrase": "cost-effective_method"}, {"score": 0.003100800861459349, "phrase": "subtle_interaction_faults"}, {"score": 0.0030679359570782595, "phrase": "integration_testing_phase"}, {"score": 0.002992595374066178, "phrase": "unit_testing_phase"}, {"score": 0.0029608739165086257, "phrase": "suggested_approach"}, {"score": 0.002642681666526916, "phrase": "extracted_representative_test_cases"}, {"score": 0.002559501330352064, "phrase": "state_domain"}, {"score": 0.002532359001507531, "phrase": "single_test_sequence"}, {"score": 0.002426630714074822, "phrase": "unit_test_cases"}, {"score": 0.0023838876943453515, "phrase": "effective_test_cases"}, {"score": 0.0023586032632567796, "phrase": "diverse_execution_paths"}, {"score": 0.002333586381274878, "phrase": "interaction_faults"}, {"score": 0.002308834230545883, "phrase": "complex_modules"}, {"score": 0.0022843440226146005, "phrase": "produced_test_sequence"}, {"score": 0.002260112998123604, "phrase": "test_coverage"}, {"score": 0.002220296517089146, "phrase": "unit_testing_coverage"}, {"score": 0.0021503823972534096, "phrase": "optimal_test_sequences"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Integration testing", " Test case reuse", " Interaction fault", " Medical software"], "paper_abstract": "As medical software is getting larger-sized, complex, and connected with other devices, finding faults in integrated software modules gets more difficult and time consuming. Existing integration testing typically takes a black-box approach, which treats the target software as a black box and selects test cases without considering internal behavior of each software module. Though it could be cost-effective, this black-box approach cannot thoroughly test interaction behavior among integrated modules and might leave critical faults undetected, which should not happen in safety-critical systems such as medical software. This work anticipates that information on internal behavior is necessary even for integration testing to define thorough test cases for critical software and proposes a new integration testing method by reusing test cases used for unit testing. The goal is to provide a cost-effective method to detect subtle interaction faults at the integration testing phase by reusing the knowledge obtained from unit testing phase. The suggested approach notes that the test cases for the unit testing include knowledge on internal behavior of each unit and extracts test cases for the integration testing from the test cases for the unit testing for a given test criteria. The extracted representative test cases are connected with functions under test using the state domain and a single test sequence to cover the test cases is produced. By means of reusing unit test cases, the tester has effective test cases to examine diverse execution paths and find interaction faults without analyzing complex modules. The produced test sequence can have test coverage as high as the unit testing coverage and its length is close to the length of optimal test sequences. (C) 2013 Elsevier Ltd. All rights reserved.", "paper_title": "Integration testing through reusing representative unit test cases for high-confidence medical software", "paper_id": "WOS:000318320700005"}