{"auto_keywords": [{"score": 0.031992588399962184, "phrase": "register_cache"}, {"score": 0.00481495049065317, "phrase": "energy-efficient_register_caching"}, {"score": 0.004773692073488661, "phrase": "compiler_assistance"}, {"score": 0.004712463245074863, "phrase": "register_file"}, {"score": 0.004652016085325825, "phrase": "critical_component"}, {"score": 0.004592340708764929, "phrase": "modern_superscalar_processor"}, {"score": 0.004305203085016233, "phrase": "flight_instructions"}, {"score": 0.004141575435071002, "phrase": "simultaneous_issue"}, {"score": 0.003767203575060969, "phrase": "high_access_latency"}, {"score": 0.003592859432554987, "phrase": "register_accesses"}, {"score": 0.0033391018638565715, "phrase": "pipeline_depth"}, {"score": 0.003157174936641705, "phrase": "novel_use"}, {"score": 0.003130077012135034, "phrase": "compiler_analysis"}, {"score": 0.00295950473406239, "phrase": "single-cycle_register_accesses"}, {"score": 0.0028839363228932704, "phrase": "energy_consumption"}, {"score": 0.002738523189244011, "phrase": "free_bits"}, {"score": 0.002703327151461985, "phrase": "real_isa"}, {"score": 0.002469269628821745, "phrase": "read_ports"}, {"score": 0.002226430168622392, "phrase": "register_system_energy"}, {"score": 0.0021416404045850224, "phrase": "energy_savings"}], "paper_keywords": ["Experimentation", " Measurement", " Performance", " Low-power design", " energy efficiency", " compiler", " microarchitecture", " register file", " register cache"], "paper_abstract": "The register file is a critical component in a modern superscalar processor. It must be large enough to accommodate the results of all in-flight instructions. It must also have enough ports to allow simultaneous issue and writeback of many values each cycle. However, this makes it one of the most energy-consuming structures within the processor with a high access latency. As technology scales, there comes a point where register accesses are the bottleneck to performance and so must be pipelined over several cycles. This increases the pipeline depth, lowering performance. To overcome these challenges, we propose a novel use of compiler analysis to aid register caching. Adding a register cache allows us to preserve single-cycle register accesses, maintaining performance and reducing energy consumption. We do this by passing information to the processor using free bits in a real ISA, allowing us to cache only the most important registers. Evaluating the register cache over a variety of sizes and associativities and varying the read ports into the cache, our best scheme achieves an energy-delay-squared (EDD) product of 0.81, with a performance increase of 11%. Another configuration saves 13% of register system energy. Using four register cache read ports brings both performance gains and energy savings, consistently outperforming two state-of-the-art hardware approaches.", "paper_title": "Energy-Efficient Register Caching with Compiler Assistance", "paper_id": "WOS:000271212900001"}