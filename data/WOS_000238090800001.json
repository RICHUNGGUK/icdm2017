{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "language_design"}, {"score": 0.004728499903204582, "phrase": "lightning_striking_four_times"}, {"score": 0.0045933810497156705, "phrase": "definitive_programming_language"}, {"score": 0.0045108906244892165, "phrase": "definitive_language"}, {"score": 0.004445961412092278, "phrase": "programming_language"}, {"score": 0.004397875849247165, "phrase": "good_solutions"}, {"score": 0.004287680323820891, "phrase": "computer_science_researchers"}, {"score": 0.004180234323211199, "phrase": "higher_levels"}, {"score": 0.004090274535243564, "phrase": "computer_science"}, {"score": 0.004002242925856335, "phrase": "rising_level"}, {"score": 0.0038737214010638745, "phrase": "small_set"}, {"score": 0.0038457240885563146, "phrase": "definitive_languages"}, {"score": 0.0034118234596993836, "phrase": "tentative_conclusions"}, {"score": 0.003314203895848455, "phrase": "substantial_research_projects"}, {"score": 0.0032783186166708985, "phrase": "important_problems"}, {"score": 0.0030048355421601705, "phrase": "unified_discipline"}, {"score": 0.002646267286675984, "phrase": "common_structure"}, {"score": 0.0022228943786652914, "phrase": "functional_programming"}, {"score": 0.002182881082103045, "phrase": "important_defaults"}, {"score": 0.002151388538895855, "phrase": "global_mutable_state"}, {"score": 0.0021049977753042253, "phrase": "essential_ingredient"}], "paper_keywords": [""], "paper_abstract": "What will a definitive programming language look like? By definitive language I mean a programming language that gives good solutions at its level of abstraction, allowing computer science researchers to move on and work at higher levels. Given the evolution of computer science as a field with a rising level of abstraction, it is my belief that a small set of definitive languages will eventually exist. But how can we learn something about this set, considering that many basic questions about languages have not yet been settled? In this paper, I give some tentative conclusions about one definitive language. I present four case studies of substantial research projects that tackle important problems in four quite different areas: fault-tolerant programming, secure distributed programming, network-transparent distributed programming, and teaching programming as a unified discipline. All four projects had to think about language design. In this paper, I summarize the reasons why each project designed the language it did. It turns out that all four languages have a common structure. They can be seen as layered, with the following four layers in this order: a strict functional core, then deterministic concurrency, then message-passing concurrency, and finally shared-state concurrency (usually with transactions). This confirms the importance of functional programming and message passing as important defaults; however, global mutable state is also seen as an essential ingredient.", "paper_title": "Convergence in language design: A case of lightning striking four times in the same place", "paper_id": "WOS:000238090800001"}