{"auto_keywords": [{"score": 0.044111484437312234, "phrase": "reference_types"}, {"score": 0.015719716506582538, "phrase": "on-the-fly_garbage_collection"}, {"score": 0.004453874101119545, "phrase": "java's_weak_and_other_reference_types"}, {"score": 0.004055998173160551, "phrase": "dacapo_benchmarks"}, {"score": 0.0033372020049592726, "phrase": "new_framework"}, {"score": 0.0031107911390188055, "phrase": "jikes_rvm."}, {"score": 0.002619781855065404, "phrase": "sapphire"}, {"score": 0.0024418934977061876, "phrase": "deletion_barrier"}, {"score": 0.002223351523626989, "phrase": "previous_approaches"}], "paper_keywords": ["Algorithms", " Languages", " Garbage Collection", " Real-time processing", " Java", " Weak Pointers", " Jikes RVM"], "paper_abstract": "Most proposals for on-the-fly garbage collection ignore the question of Java's weak and other reference types. However, we show that reference types are heavily used in DaCapo benchmarks. Of the few collectors that do address this issue, most block mutators, either globally or individually, while processing reference types. We introduce a new framework for processing reference types on-the-fly in Jikes RVM. Our framework supports both insertion and deletion write barriers. We have model checked our algorithm and incorporated it in our new implementation of the Sapphire on-the-fly collector. Using a deletion barrier, we process references while mutators are running in less than three times the time that previous approaches take while mutators are halted; our overall execution times are no worse, and often better.", "paper_title": "Reference Object Processing in On-The-Fly Garbage Collection", "paper_id": "WOS:000358310800006"}