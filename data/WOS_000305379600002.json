{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "adaptive_component-based_dataflow_middleware"}, {"score": 0.0046429592670444945, "phrase": "modern_computational_resources"}, {"score": 0.004594951819987416, "phrase": "distributed_applications"}, {"score": 0.004547438494330851, "phrase": "expert_knowledge"}, {"score": 0.004500414250942443, "phrase": "low-level_programming_tools"}, {"score": 0.004407813106104401, "phrase": "productive_high-level"}, {"score": 0.004362226376603478, "phrase": "high-performance_programming_framework"}, {"score": 0.004272456401437226, "phrase": "even_state-of-the-art_high-level_frameworks"}, {"score": 0.004098397888277889, "phrase": "tedious_manual_tuning_step"}, {"score": 0.003911010373894104, "phrase": "best_application_execution_performance"}, {"score": 0.003771185758226876, "phrase": "novel_framework"}, {"score": 0.0036174746598098863, "phrase": "high-performance_dataflow_applications"}, {"score": 0.003542976343910816, "phrase": "tedious_tuning_process"}, {"score": 0.0031928040608991543, "phrase": "multi-core_cpus"}, {"score": 0.003015143226706584, "phrase": "datacutter"}, {"score": 0.0028771413440398614, "phrase": "kaapi"}, {"score": 0.002803213985198645, "phrase": "asynchronous_function_calls"}, {"score": 0.002473895542219933, "phrase": "execution_time_performance"}, {"score": 0.002435542816459651, "phrase": "runtime_engines"}, {"score": 0.0022760856906838814, "phrase": "good_performance"}, {"score": 0.0022407927161620855, "phrase": "wide_range"}, {"score": 0.002171836484200008, "phrase": "much-reduced_development_cost"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Distributed computing", " Runtime system middleware", " Heterogeneous computing"], "paper_abstract": "Making the best use of modern computational resources for distributed applications requires expert knowledge of low-level programming tools, or a productive high-level and high-performance programming framework. Unfortunately, even state-of-the-art high-level frameworks still require the developer to conduct a tedious manual tuning step to find the work partitioning which gives the best application execution performance. Here, we present a novel framework, with which developers can easily create high-performance dataflow applications, without the tedious tuning process. We compare the performance of our approach to that of three distributed programming frameworks which differ significantly in their programming paradigm, their support for multi-core CPUs and accelerators, and their load-balancing approach. These three frameworks are DataCutter, a component-based dataflow framework, KAAPI, a framework using asynchronous function calls, and MR-MPI, a MapReduce implementation. By highly optimizing the implementations of three applications on the four frameworks and comparing the execution time performance of the runtime engines, we show their strengths and weaknesses. We show that our approach achieves good performance for a wide range of applications, with a much-reduced development cost. (c) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Improving performance of adaptive component-based dataflow middleware", "paper_id": "WOS:000305379600002"}