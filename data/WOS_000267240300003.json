{"auto_keywords": [{"score": 0.04795845458902327, "phrase": "simply_typed_lambda-calculus"}, {"score": 0.043025239716159284, "phrase": "normal_form"}, {"score": 0.00481495049065317, "phrase": "sized_heterogeneous_types"}, {"score": 0.004398749458244697, "phrase": "substitution"}, {"score": 0.004251210982670317, "phrase": "free_variable"}, {"score": 0.003627800727103479, "phrase": "freshly_created_redexes"}, {"score": 0.003239114833599948, "phrase": "lexicographic_induction"}, {"score": 0.0028919522313933525, "phrase": "structurally_recursive_normalizer"}, {"score": 0.002671263324230699, "phrase": "hereditary_substitutions"}, {"score": 0.0025819015229390663, "phrase": "functional_programming_language"}, {"score": 0.0025239898026543964, "phrase": "sized_heterogeneous_inductive_types"}, {"score": 0.002153316680437517, "phrase": "type_system"}], "paper_keywords": [""], "paper_abstract": "In the simply typed lambda-calculus, a hereditary Substitution replaces a free variable in a normal form r by another normal form s of type a, removing freshly created redexes on the fly. It can be defined by lexicographic induction on a and r, thus giving rise to a structurally recursive normalizer for the simply typed lambda-calculus. We implement hereditary substitutions in a functional programming language With sized heterogeneous inductive types F(omega)(boolean AND) arriving at an interpreter whose termination can be tracked by the type system of its host programming language.", "paper_title": "Implementing a normalizer using sized heterogeneous types", "paper_id": "WOS:000267240300003"}