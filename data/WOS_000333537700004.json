{"auto_keywords": [{"score": 0.04831127719801428, "phrase": "compcert"}, {"score": 0.040708700726361825, "phrase": "ssa"}, {"score": 0.00481495049065317, "phrase": "ssa-based_middle-end"}, {"score": 0.004508661664944657, "phrase": "formally_verified_compiler"}, {"score": 0.004383406949799696, "phrase": "compact_and_efficient_code"}, {"score": 0.004261617028111862, "phrase": "large_subset"}, {"score": 0.004143196873246147, "phrase": "c_language"}, {"score": 0.0032145922365231093, "phrase": "open_problem"}, {"score": 0.003125175084962886, "phrase": "formally_an_ssa-based_compiler"}, {"score": 0.0027139447110929586, "phrase": "formally_verified_ssa-based_middle-end"}, {"score": 0.0025171707263241675, "phrase": "leroy"}, {"score": 0.0023346234464901978, "phrase": "intuitive_formal_semantics"}, {"score": 0.0021049977753042253, "phrase": "program_optimizations"}], "paper_keywords": ["Languages", " Reliability", " Verification", " Single static assignment", " compiler verification", " mechanized proof"], "paper_abstract": "CompCert is a formally verified compiler that generates compact and efficient code for a large subset of the C language. However, CompCert foregoes using SSA, an intermediate representation employed by many compilers that enables writing simpler, faster optimizers. In fact, it has remained an open problem to verify formally an SSA-based compiler. We report on a formally verified, SSA-based middle-end for CompCert. In addition to providing a formally verified SSA-based middle-end, we address two problems raised by Leroy in [2009]: giving an intuitive formal semantics to SSA, and leveraging its global properties to reason locally about program optimizations.", "paper_title": "Formal Verification of an SSA-Based Middle-End for CompCert", "paper_id": "WOS:000333537700004"}