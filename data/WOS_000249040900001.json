{"auto_keywords": [{"score": 0.0424834033013568, "phrase": "mls_instructions"}, {"score": 0.0047386923107107645, "phrase": "recent_study"}, {"score": 0.0044101380740283825, "phrase": "single-instruction_multiple-data_instruction"}, {"score": 0.004288591089532374, "phrase": "mls"}, {"score": 0.004007083686875716, "phrase": "optimized_machine_code"}, {"score": 0.003927848423072668, "phrase": "effective_approach"}, {"score": 0.0037740295668681014, "phrase": "mls_problem"}, {"score": 0.0035544816252832375, "phrase": "unlimited_register_file_size"}, {"score": 0.003190878119415192, "phrase": "maximum_weighted_path_cover"}, {"score": 0.0031528393611136704, "phrase": "dynamic_weighted_graph"}, {"score": 0.003053598205821532, "phrase": "finite_size"}, {"score": 0.0030171910207671205, "phrase": "register_file"}, {"score": 0.0028643622911111942, "phrase": "register_sequencing"}, {"score": 0.0028076592725295646, "phrase": "limited_register_resource"}, {"score": 0.0027631038845413393, "phrase": "target_processor"}, {"score": 0.0026126405272417783, "phrase": "benchmark_programs"}, {"score": 0.002382987346529592, "phrase": "existing_compilers"}, {"score": 0.0023545567809591804, "phrase": "total_code_size_reduction"}, {"score": 0.0023079225317714815, "phrase": "code_size_reduction"}, {"score": 0.0022803854904010347, "phrase": "almost_no_cost"}, {"score": 0.0022531762659857507, "phrase": "overall_increase"}, {"score": 0.0022352169832099153, "phrase": "compilation_time"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler", " SIMD", " parallelism", " code optimization", " processors", " embedded systems"], "paper_abstract": "In a recent study, we discovered that many single load/store operations in embedded applications can be parallelized and thus encoded simultaneously in a single-instruction multiple-data instruction, called the multiple load/store (MLS) instruction. In this work, we investigate the problem of utilizing MLS instructions to produce optimized machine code, and propose an effective approach to the problem. Specifically, we formalize the MLS problem, that is, the problem of maximizing the use of MLS instructions with an unlimited register file size. Based on this analysis, we show that we can solve the problem efficiently by translating it into a variant of the problem finding a maximum weighted path cover in a dynamic weighted graph. To handle a more realistic case of the finite size of the register file, our solution is then extended to take into account the constraints of register sequencing in MLS instructions and the limited register resource available in the target processor. We demonstrate the effectiveness of our approach experimentally by using a set of benchmark programs. In summary, our approach can reduce the number of loads/stores by 13.3% on average, compared with the code generated from existing compilers. The total code size reduction is 3.6%. This code size reduction comes at almost no cost because the overall increase in compilation time as a result of our technique remains quite minimal. Copyright (C) 2007 John Wiley & Sons, Ltd.", "paper_title": "Efficient embedded code generation with multiple load/store instructions", "paper_id": "WOS:000249040900001"}