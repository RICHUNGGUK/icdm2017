{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cache_optimizations"}, {"score": 0.004695900553353526, "phrase": "iterative_numerical_codes"}, {"score": 0.004522796947899013, "phrase": "hardware_prefetching"}, {"score": 0.004301834610818624, "phrase": "code_transformations"}, {"score": 0.003990385737207714, "phrase": "memory_accesses"}, {"score": 0.0038431888954930083, "phrase": "prefetching_techniques"}, {"score": 0.0035648266669315943, "phrase": "best_performance"}, {"score": 0.00347657813672945, "phrase": "hardware_prefetching_units"}, {"score": 0.0031845067058084583, "phrase": "software_prefetch_instructions"}, {"score": 0.003066945490483524, "phrase": "cache_simulation"}, {"score": 0.0029169007179202164, "phrase": "hardware_prefetcher"}, {"score": 0.0022133711375320244, "phrase": "prefetch_instructions"}, {"score": 0.0021049977753042253, "phrase": "interleaved_block_prefetching"}], "paper_keywords": [""], "paper_abstract": "Cache optimizations use code transformations to increase the locality of memory accesses and use prefetching techniques to hide latency. For best performance, hardware prefetching units of processors should be complemented with software prefetch instructions. A cache simulation enhanced with a hardware prefetcher is presented to run code for a 3D multigrid solver. Thus, cache misses not predicted can be handled via insertion of prefetch instructions. Additionally, Interleaved Block Prefetching (IBPF), is presented. Measurements show its potential.", "paper_title": "Cache optimizations for iterative numerical codes aware of hardware prefetching", "paper_id": "WOS:000237003200111"}