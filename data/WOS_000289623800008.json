{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "simply_typed_lambda-calculus"}, {"score": 0.00470862827326028, "phrase": "rebind_primitive_constructs"}, {"score": 0.004403480614319231, "phrase": "open_code"}, {"score": 0.0039822874870125095, "phrase": "standard_static_binding"}, {"score": 0.003808209866576388, "phrase": "unifying_foundation"}, {"score": 0.003724034990158436, "phrase": "dynamic_scoping"}, {"score": 0.0033864888703414903, "phrase": "dynamic_updating"}, {"score": 0.0032747835779400212, "phrase": "mobile_code"}, {"score": 0.003149094460617212, "phrase": "alternative_action"}, {"score": 0.002944715025443487, "phrase": "application_scenario"}, {"score": 0.002784540221128404, "phrase": "type_safety"}, {"score": 0.002618366076489732, "phrase": "static_and_dynamic_type_checking"}, {"score": 0.0025037596405075866, "phrase": "dynamic_error"}, {"score": 0.0023941575109692314, "phrase": "replacing_term"}, {"score": 0.0023281003994670714, "phrase": "wrong_type"}, {"score": 0.002176887956041267, "phrase": "purely_static_type_system"}], "paper_keywords": ["Lambda calculus", " type systems", " static and dynamic scoping", " rebinding"], "paper_abstract": "We extend the simply typed lambda-calculus with unbind and rebind primitive constructs. That is, a value can be a fragment of open code, which in order to be used should be explicitly rebound. This mechanism nicely coexists with standard static binding. The motivation is to provide an unifying foundation for mechanisms of dynamic scoping, where the meaning of a name is determined at runtime, rebinding, such as dynamic updating of resources and exchange of mobile code, and delegation, where an alternative action is taken if a binding is missing. Depending on the application scenario, we consider two extensions which differ in the way type safety is guaranteed. The former relies on a combination of static and dynamic type checking. That is, rebind raises a dynamic error if for some variable there is no replacing term or it has the wrong type. In the latter, this error is prevented by a purely static type system, at the price of more sophisticated types.", "paper_title": "EXTENDING THE LAMBDA-CALCULUS WITH UNBIND AND REBIND", "paper_id": "WOS:000289623800008"}