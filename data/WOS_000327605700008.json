{"auto_keywords": [{"score": 0.04131023925415857, "phrase": "accurate_models"}, {"score": 0.00481495049065317, "phrase": "performance_estimation"}, {"score": 0.004747997855358171, "phrase": "mpsoc_transaction-accurate_models"}, {"score": 0.004324723240308028, "phrase": "accurate_performance_estimation_techniques"}, {"score": 0.004166129325245761, "phrase": "new_techniques"}, {"score": 0.004108161406159407, "phrase": "fine-grained_code_analysis"}, {"score": 0.003957477564354679, "phrase": "mpsoc_transaction"}, {"score": 0.003848088904418221, "phrase": "gcc_profiling_tool"}, {"score": 0.0037592362369401546, "phrase": "native_simulation_process"}, {"score": 0.003672427620845944, "phrase": "profiling_result"}, {"score": 0.0036213041338584756, "phrase": "instruction_analyzer"}, {"score": 0.0035542408902458677, "phrase": "cpu_architecture"}, {"score": 0.0034559594248079807, "phrase": "cycle_cost"}, {"score": 0.0034238045290210534, "phrase": "c_code"}, {"score": 0.00329813918116714, "phrase": "memory_analyzer"}, {"score": 0.003206916619690171, "phrase": "memory_access_latency"}, {"score": 0.0030319482153908037, "phrase": "instruction_cache_models"}, {"score": 0.0028799352389969443, "phrase": "segment-based_strategy"}, {"score": 0.002800247197692108, "phrase": "cache_models"}, {"score": 0.0027100527874262446, "phrase": "equalized_access_model"}, {"score": 0.00263505298504827, "phrase": "memory_access_behavior"}, {"score": 0.0025741370320813968, "phrase": "global_memory_access_latency"}, {"score": 0.002538263784314365, "phrase": "bus_contention"}, {"score": 0.002514625755809045, "phrase": "memory_bandwidth"}, {"score": 0.002388487669097511, "phrase": "different_hardware_architectures"}, {"score": 0.0023551955270737215, "phrase": "experimental_results"}, {"score": 0.0022580713471027996, "phrase": "estimation_accuracy"}, {"score": 0.0021649437083408425, "phrase": "virtual_prototype_models"}, {"score": 0.0021247934141234988, "phrase": "tolerable_overhead"}, {"score": 0.0021049977753042253, "phrase": "simulation_speed"}], "paper_keywords": ["Instruction", " memory", " multiprocessor system-onchip (MPSoC)", " performance estimation", " profiling", " transaction-accurate model"], "paper_abstract": "Efficient design of multiprocessor system-on-chip (MPSoC) requires early, fast, and accurate performance estimation techniques. In this paper, we present new techniques based on fine-grained code analysis to estimate accurate performance during simulation of MPSoC transaction accurate models. First, a GCC profiling tool is applied in the native simulation process. Based on the profiling result, an instruction analyzer of the target CPU architecture is proposed to analyze the cycle cost of C code under estimation. In addition, a memory analyzer is used to further estimate memory access latency including both instruction/data cache time cost and global memory access cycles. Both data and instruction cache models are proposed to estimate cache miss penalty, and a segment-based strategy is adopted to update the cache models more efficiently. Furthermore, an equalized access model is presented to imitate the memory access behavior of processors for estimating global memory access latency caused by bus contention and memory bandwidth. We have applied these techniques on an H. 264 decoder application with different hardware architectures. The experimental results show that applying these techniques can obviously improve estimation accuracy of transaction accurate models close to that of the virtual prototype models, with a tolerable overhead on simulation speed.", "paper_title": "Performance Estimation Techniques With MPSoC Transaction-Accurate Models", "paper_id": "WOS:000327605700008"}