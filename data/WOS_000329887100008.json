{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "conditional_trace"}, {"score": 0.004741167616693272, "phrase": "maude_programs"}, {"score": 0.004544016163767266, "phrase": "existing_software"}, {"score": 0.004338239182984759, "phrase": "trace_slicing_technique"}, {"score": 0.004031238480458909, "phrase": "general_framework"}, {"score": 0.003954109842050071, "phrase": "maude_language"}, {"score": 0.003878451139312637, "phrase": "wide_variety"}, {"score": 0.0037314328720368453, "phrase": "maude_execution_trace_t"}, {"score": 0.0036884198249734863, "phrase": "slicing_criterion"}, {"score": 0.0034405207528624983, "phrase": "final_computation_state"}, {"score": 0.003284550970221379, "phrase": "backward_dependence"}, {"score": 0.003246672441842787, "phrase": "observed_information"}, {"score": 0.00317221667574882, "phrase": "execution_step"}, {"score": 0.003051887221639784, "phrase": "simplified_trace_slice"}, {"score": 0.0027599042621376624, "phrase": "slicing_technique"}, {"score": 0.0027386335451725762, "phrase": "better_inspection"}, {"score": 0.0027175263159330523, "phrase": "debugging_activities"}, {"score": 0.0026143990748127253, "phrase": "bug_localization"}, {"score": 0.0025054621733192283, "phrase": "execution_trace"}, {"score": 0.0021544587602892466, "phrase": "reduction_power"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Trace slicing", " Program debugging and comprehension", " Rewriting logic"], "paper_abstract": "Understanding the behavior of software is important for the existing software to be improved. In this paper, we present a trace slicing technique that is suitable for analyzing complex, textually-large computations in rewriting logic, which is a general framework efficiently implemented in the Maude language that seamlessly unifies a wide variety of logics and models of concurrency. Given a Maude execution trace T and a slicing criterion for the trace (i.e., a piece of information that we want to observe in the final computation state), we traverse T from back to front and the backward dependence of the observed information is incrementally computed at each execution step. At the end of the traversal, a simplified trace slice is obtained by filtering out all the irrelevant data that do not impact on the data of interest. By narrowing the size of the trace, the slicing technique favors better inspection and debugging activities since most tedious and irrelevant inspections that are routinely performed during diagnosis and bug localization can be eliminated automatically. Moreover, cutting down the execution trace can expose opportunities for further improvement, which we illustrate by means of several examples that we execute by using iJULIENNE, a trace slicer that implements our conditional slicing technique and is endowed with a trace querying mechanism that increases flexibility and reduction power. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Using conditional trace slicing for improving Maude programs", "paper_id": "WOS:000329887100008"}