{"auto_keywords": [{"score": 0.043083320582523676, "phrase": "jni"}, {"score": 0.007605242310676817, "phrase": "java"}, {"score": 0.0053171248822713795, "phrase": "ffi"}, {"score": 0.00481495049065317, "phrase": "dynamic_bug_detectors"}, {"score": 0.00478218760286811, "phrase": "foreign_language_interfaces"}, {"score": 0.004749646583168342, "phrase": "programming_language_specifications"}, {"score": 0.004717325943509345, "phrase": "static_and_dynamic_analyses"}, {"score": 0.004669254965563445, "phrase": "syntactic_and_semantic_errors"}, {"score": 0.004621671570727774, "phrase": "individual_languages"}, {"score": 0.004405919996432158, "phrase": "poor_specification"}, {"score": 0.004301834610818624, "phrase": "multilingual_programs"}, {"score": 0.00422899036681456, "phrase": "virtually_all_java_programs"}, {"score": 0.00388278852285898, "phrase": "current_java_compilers"}, {"score": 0.0038563438670516127, "phrase": "virtual_machines"}, {"score": 0.0037523473563976246, "phrase": "jni_constraints"}, {"score": 0.0037140731069193896, "phrase": "paper's_most_significant_contribution"}, {"score": 0.003626272370749206, "phrase": "dynamic_analyses"}, {"score": 0.0036015684625793775, "phrase": "state_machines"}, {"score": 0.003480541792744611, "phrase": "ffi_constraints"}, {"score": 0.0034450303951025704, "phrase": "eleven_state_machines"}, {"score": 0.0032952735750239924, "phrase": "mapping_function"}, {"score": 0.0032063591061580526, "phrase": "program_entities"}, {"score": 0.003077451642616653, "phrase": "ffi_call"}, {"score": 0.002963830787280652, "phrase": "context-specific_dynamic_analysis"}, {"score": 0.002883833572486452, "phrase": "bug_detection_tools"}, {"score": 0.002629405440065951, "phrase": "jvm_tools_interface"}, {"score": 0.002602555367635598, "phrase": "resulting_tool"}, {"score": 0.0025759787655463212, "phrase": "jinn"}, {"score": 0.002532284627202572, "phrase": "virtual_machine"}, {"score": 0.002463906556781983, "phrase": "wide_variety"}, {"score": 0.002447101794397243, "phrase": "ffi_bugs"}, {"score": 0.002364777610365689, "phrase": "annotation_burden"}, {"score": 0.002340623433237658, "phrase": "common_ffi_constraints"}, {"score": 0.002308800317961002, "phrase": "generated_jinn_code"}, {"score": 0.002246443296542436, "phrase": "state_machine"}, {"score": 0.0022311183974368484, "phrase": "mapping_code"}, {"score": 0.002126725585391261, "phrase": "correct_multilingual_software"}], "paper_keywords": ["Design", " Languages", " Reliability", " Verification", " Multilingual Programs", " Foreign Function Interfaces (FFI)", " Java Native Interface (JNI)", " Python/C", " Dynamic Analysis", " FFI Bugs", " Specification", " Specification Generation"], "paper_abstract": "Programming language specifications mandate static and dynamic analyses to preclude syntactic and semantic errors. Although individual languages are usually well-specified, composing languages is not, and this poor specification is a source of many errors in multilingual programs. For example, virtually all Java programs compose Java and C using the Java Native Interface (JNI). Since JNI is informally specified, developers have difficulty using it correctly, and current Java compilers and virtual machines (VMs) inconsistently check only a subset of JNI constraints. This paper's most significant contribution is to show how to synthesize dynamic analyses from state machines to detect foreign function interface (FFI) violations. We identify three classes of FFI constraints encoded by eleven state machines that capture thousands of JNI and Python/C FFI rules. We use a mapping function to specify which state machines, transitions, and program entities (threads, objects, references) to check at each FFI call and return. From this function, we synthesize a context-specific dynamic analysis to find FFI bugs. We build bug detection tools for JNI and Python/C using this approach. For JNI, we dynamically and transparently interpose the analysis on Java and C language transitions through the JVM tools interface. The resulting tool, called Jinn, is compiler and virtual machine independent. It detects and diagnoses a wide variety of FFI bugs that other tools miss. This approach greatly reduces the annotation burden by exploiting common FFI constraints: whereas the generated Jinn code is 22,000+ lines, we wrote only 1,400 lines of state machine and mapping code. Overall, this paper lays the foundation for a more principled approach to developing correct multilingual software and a more concise and automated approach to FFI specification.", "paper_title": "Jinn: Synthesizing Dynamic Bug Detectors for Foreign Language Interfaces", "paper_id": "WOS:000279357500004"}