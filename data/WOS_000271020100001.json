{"auto_keywords": [{"score": 0.04970196977675422, "phrase": "coarse-grained_reconfigurable_architectures"}, {"score": 0.042712690847577596, "phrase": "cgra"}, {"score": 0.00481495049065317, "phrase": "spatial_mapping_algorithm"}, {"score": 0.004610058444728656, "phrase": "increasing_attention"}, {"score": 0.004413846562278824, "phrase": "impressive_performance_improvements"}, {"score": 0.004327429667024575, "phrase": "cgra_platforms"}, {"score": 0.004209269012699911, "phrase": "existing_cgra_compilers"}, {"score": 0.0032546105164772995, "phrase": "graph_drawing_based_approach"}, {"score": 0.00303072749758085, "phrase": "randomly_generated_graphs"}, {"score": 0.002913052619634697, "phrase": "previous_approach"}, {"score": 0.0028334016912935165, "phrase": "better_qualities"}, {"score": 0.002788865808981643, "phrase": "utilized_cgra_resources"}, {"score": 0.002701877448139625, "phrase": "increased_opportunities"}, {"score": 0.002680556511196791, "phrase": "novel_power_and_performance_optimization_techniques"}, {"score": 0.0025866699249916508, "phrase": "shorter_execution_cycles"}, {"score": 0.0025059724686541263, "phrase": "minimum_mapping_time_overhead"}, {"score": 0.00246657044320953, "phrase": "similar_results"}, {"score": 0.0023896108055582615, "phrase": "livermore_loops"}, {"score": 0.002370748861728166, "phrase": "mediabench"}, {"score": 0.002352084475365876, "phrase": "multimedia"}, {"score": 0.0023337358189609273, "phrase": "wavelet"}, {"score": 0.0023150468182777813, "phrase": "dspstone"}, {"score": 0.0022876877275935757, "phrase": "spkm"}, {"score": 0.0022517100995552443, "phrase": "customized_algorithm"}, {"score": 0.0022162970216404927, "phrase": "specific_cgra_template"}, {"score": 0.00212175050242788, "phrase": "resource_configurations"}, {"score": 0.0021049977753042253, "phrase": "spkm."}], "paper_keywords": ["Compiler", " kernel mapping", " reconfigurable architecture"], "paper_abstract": "Recently coarse-grained reconfigurable architectures (CGRAs) have drawn increasing attention due to their efficiency and flexibility. While many CGRAs have demonstrated impressive performance improvements, the effectiveness of CGRA platforms ultimately hinges on the compiler. Existing CGRA compilers do not model the details of the CGRA, and thus they are i) unable to map applications, even though a mapping exists, and ii) using too many processing elements (PEs) to map an application. In this paper, we model several CGRA details, e. g., irregular CGRA topologies, shared resources and routing PEs in our compiler and develop a graph drawing based approach, Split-Push Kernel Mapping (SPKM), for mapping applications onto CGRAs. On randomly generated graphs our technique can map on average 4.5 more applications than the previous approach, while generating mappings which have better qualities in terms of utilized CGRA resources. Utilizing fewer resources is directly translated into increased opportunities for novel power and performance optimization techniques. Our technique shows less power consumption in 71 cases and shorter execution cycles in 66 cases out of 100 synthetic applications, with minimum mapping time overhead. We observe similar results on a suite of benchmarks collected from Livermore loops, Mediabench, Multimedia, Wavelet and DSPStone benchmarks. SPKM is not a customized algorithm only for a specific CGRA template, and it is demonstrated by exploring various PE interconnection topologies and shared resource configurations with SPKM.", "paper_title": "A Graph Drawing Based Spatial Mapping Algorithm for Coarse-Grained Reconfigurable Architectures", "paper_id": "WOS:000271020100001"}