{"auto_keywords": [{"score": 0.03724062504758166, "phrase": "binary_code"}, {"score": 0.00995992550331932, "phrase": "execution_paths"}, {"score": 0.00481495049065317, "phrase": "analysis_enhancement"}, {"score": 0.004772137871562584, "phrase": "synchronous_program"}, {"score": 0.004666756595735701, "phrase": "critical_systems"}, {"score": 0.0044231966846655394, "phrase": "fast_enough"}, {"score": 0.004383852039913171, "phrase": "functionality_aspects"}, {"score": 0.004211069233133584, "phrase": "high_level_design_methods"}, {"score": 0.004118026552723285, "phrase": "synchronous_approach"}, {"score": 0.003991196463806465, "phrase": "verification_tools"}, {"score": 0.003955679223407243, "phrase": "real-time_aspects"}, {"score": 0.0037827603118271757, "phrase": "static_timing_analysis"}, {"score": 0.0036826452656927877, "phrase": "safe_bounds"}, {"score": 0.0036335821512795026, "phrase": "worst-case_execution_time"}, {"score": 0.003367611042980526, "phrase": "estimated_wcet"}, {"score": 0.003220315882881027, "phrase": "high-level_synchronous_design"}, {"score": 0.0031071175640144943, "phrase": "high-level_functional_properties"}, {"score": 0.0028284924551705516, "phrase": "worst-case_candidates"}, {"score": 0.002621297299343551, "phrase": "semantic_information"}, {"score": 0.0025863375961196005, "phrase": "high-level_design"}, {"score": 0.0025518429503461736, "phrase": "executable_code"}, {"score": 0.0022613292987262177, "phrase": "existing_timing_analysis_framework"}, {"score": 0.0022112700457629494, "phrase": "realistic_example"}, {"score": 0.0021334650920198715, "phrase": "large_possible_improvement"}, {"score": 0.0021049977753042253, "phrase": "reasonable_computation_time"}], "paper_keywords": ["WCET", " Model-based design", " Synchronous languages", " Model checking", " Traceability"], "paper_abstract": "Real-time critical systems can be considered as correct if they compute both right and fast enough. Functionality aspects (computing right) can be addressed using high level design methods, such as the synchronous approach that provides languages, compilers and verification tools. Real-time aspects (computing fast enough) can be addressed with static timing analysis, that aims at discovering safe bounds on the worst-case execution time (WCET) of the binary code. In this paper, we aim at improving the estimated WCET in the case where the binary code comes from a high-level synchronous design. The key idea is that some high-level functional properties may imply that some execution paths of the binary code are actually infeasible, and thus, can be removed from the worst-case candidates. In order to automatize the method, we show (1) how to trace semantic information between the high-level design and the executable code, (2) how to use a model-checker to prove infeasibility of some execution paths, and (3) how to integrate such infeasibility information into an existing timing analysis framework. Based on a realistic example, we show that there is a large possible improvement for a reasonable computation time overhead.", "paper_title": "Timing analysis enhancement for synchronous program", "paper_id": "WOS:000350299400004"}