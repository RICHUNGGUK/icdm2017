{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "termination_analysis"}, {"score": 0.004762550320451225, "phrase": "program_termination"}, {"score": 0.004685012337701536, "phrase": "relevant_property"}, {"score": 0.004387225575447685, "phrase": "programming_languages"}, {"score": 0.004339459955098738, "phrase": "traditional_approaches"}, {"score": 0.004108288481894523, "phrase": "source_code"}, {"score": 0.003997343989408636, "phrase": "new_semantics-based_approach"}, {"score": 0.003826007045267751, "phrase": "two-stage_scheme"}, {"score": 0.0033546701239540555, "phrase": "data_structure"}, {"score": 0.0031240075437664314, "phrase": "programming_language"}, {"score": 0.002861708609922034, "phrase": "semantics-based_approach"}, {"score": 0.002679501909303057, "phrase": "first_stage"}, {"score": 0.002592784882557155, "phrase": "symbolic_execution"}, {"score": 0.002536534348967784, "phrase": "appropriate_subsumption"}, {"score": 0.002508867228980776, "phrase": "abstraction_operators"}, {"score": 0.0024410093024417527, "phrase": "finite_representation"}, {"score": 0.0022980978400845144, "phrase": "higher_level_approach"}, {"score": 0.002260591903283384, "phrase": "useful_insights"}, {"score": 0.002223696715077018, "phrase": "new_semantics-based_termination_tools"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Program termination", " Symbolic execution", " Program analysis"], "paper_abstract": "Program termination is a relevant property that has been extensively studied in the context of many different formalisms and programming languages. Traditional approaches to proving termination are usually based on inspecting the source code. Recently, a new semantics-based approach has emerged, which typically follows a two-stage scheme: first, a finite data structure representing the computation space of the program is built; then, termination is analyzed by inspecting the transitions in this data structure using traditional, syntax-based techniques. Unfortunately, this approach is still specific to a programming language and semantics. In this work, we present instead a general, high-level framework that follows the semantics-based approach to proving termination. In particular, we focus on the first stage and advocate the use of symbolic execution, together with appropriate subsumption and abstraction operators, for producing a finite representation of the computations of a program. Hopefully, this higher level approach will provide useful insights for designing new semantics-based termination tools for particular programming languages. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Symbolic execution as a basis for termination analysis", "paper_id": "WOS:000352047500007"}