{"auto_keywords": [{"score": 0.039383785397268056, "phrase": "alp_proof-procedures"}, {"score": 0.03703773443586109, "phrase": "built-in_predicates"}, {"score": 0.029841086079651358, "phrase": "chr_rules"}, {"score": 0.02804688688794027, "phrase": "integrity_constraints"}, {"score": 0.004814971944570536, "phrase": "chr"}, {"score": 0.004701556483912018, "phrase": "sciff_abductive_system"}, {"score": 0.004518442937844318, "phrase": "hypothetical_reasoning"}, {"score": 0.004223299391912042, "phrase": "protocol_verification"}, {"score": 0.004189863767755212, "phrase": "abductive_logic_programming"}, {"score": 0.004026598712747509, "phrase": "logic_programming"}, {"score": 0.003947358102140903, "phrase": "operational_semantics"}, {"score": 0.0039005612858880115, "phrase": "alp_language"}, {"score": 0.003823791479971016, "phrase": "proof_procedure"}, {"score": 0.0037784540167266497, "phrase": "first_implementations"}, {"score": 0.0036747384051186937, "phrase": "meta-interpretation_technique"}, {"score": 0.0034895911869254146, "phrase": "logic_programming_systems"}, {"score": 0.0033668870709083884, "phrase": "theoretical_results"}, {"score": 0.0031217859267564344, "phrase": "easy_integration"}, {"score": 0.0030481444896915504, "phrase": "constraint_handling_rules"}, {"score": 0.002917604283241353, "phrase": "abductive_proof_procedures"}, {"score": 0.002882980094838904, "phrase": "first_chr-based_implementation"}, {"score": 0.0027594936602962075, "phrase": "efficient_solution"}, {"score": 0.0027159094186967247, "phrase": "defined_predicates"}, {"score": 0.002578946584040053, "phrase": "sound_treatment"}, {"score": 0.0024488738006005133, "phrase": "chr-based_implementation"}, {"score": 0.002419798694301991, "phrase": "sciff_abductive_proof-procedure"}, {"score": 0.002372103459168231, "phrase": "different_approach"}, {"score": 0.0023439376937579204, "phrase": "sciff_implementation"}, {"score": 0.0023069016803337365, "phrase": "chr_constraints"}, {"score": 0.002164505365535068, "phrase": "default_negation"}, {"score": 0.0021049977753042253, "phrase": "chr-based_implementations"}], "paper_keywords": [""], "paper_abstract": "Abduction is a form of inference that supports hypothetical reasoning and has been applied to a number of domains, such as diagnosis, planning, protocol verification. Abductive Logic Programming (ALP) is the integration of abduction in logic programming. Usually, the operational semantics of an ALP language is defined as a proof procedure. The first implementations of ALP proof-procedures were based on the meta-interpretation technique, which is flexible but limits the use of the built-in predicates of logic programming systems. Another, more recent, approach exploits theoretical results on the similarity between abducibles and constraints. With this approach, which bears the advantage of an easy integration with built-in predicates and constraints, Constraint Handling Rules has been the language of choice for the implementation of abductive proof procedures. The first CHR-based implementation mapped integrity constraints directly to CHR rules, which is an efficient solution, but prevents defined predicates from being in the body of integrity constraints and does not allow a sound treatment of negation by default. In this paper, we describe the CHR-based implementation of the SCIFF abductive proof-procedure, which follows a different approach. The SCIFF implementation maps integrity constraints to CHR constraints, and the transitions of the proof-procedure to CHR rules, making it possible to treat default negation, while retaining the other advantages of CHR-based implementations of ALP proof-procedures.", "paper_title": "The CHR-based Implementation of the SCIFF Abductive System", "paper_id": "WOS:000320502200002"}