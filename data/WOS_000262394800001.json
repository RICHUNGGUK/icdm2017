{"auto_keywords": [{"score": 0.04526211521024841, "phrase": "programming_model"}, {"score": 0.04423066948242862, "phrase": "data_races"}, {"score": 0.00481495049065317, "phrase": "concurrent_object-oriented_programs"}, {"score": 0.004723322467153553, "phrase": "multithreaded_object-oriented_programs"}, {"score": 0.004567129988306349, "phrase": "nonlocal_nature"}, {"score": 0.004501774379030109, "phrase": "aliasing_and_data_races"}, {"score": 0.004394910907549057, "phrase": "programming_regime"}, {"score": 0.004148631410346188, "phrase": "local_reasoning"}, {"score": 0.0038415095105632157, "phrase": "synchronization_primitives"}, {"score": 0.0037322713756404295, "phrase": "current_mainstream_programming_languages"}, {"score": 0.0035060903664150115, "phrase": "stylized_comments"}, {"score": 0.0030938932434437178, "phrase": "annotated_program"}, {"score": 0.0027965187255008647, "phrase": "program_behavior"}, {"score": 0.00247944491239733, "phrase": "program_elements"}, {"score": 0.0022302306304023602, "phrase": "custom_build"}, {"score": 0.0021049977753042253, "phrase": "case_study"}], "paper_keywords": ["Verification", " Aliasing", " data races", " local reasoning", " modular reasoning", " ownership", " verification condition generation"], "paper_abstract": "Reasoning about multithreaded object-oriented programs is difficult, due to the nonlocal nature of object aliasing and data races. We propose a programming regime (or programming model) that rules out data races, and enables local reasoning in the presence of object aliasing and concurrency. Our programming model builds on the multithreading and synchronization primitives as they are present in current mainstream programming languages. Java or C# programs developed according to our model can be annotated by means of stylized comments to make the use of the model explicit. We show that such annotated programs can be formally verified to comply with the programming model. If the annotated program verifies, the underlying Java or C# program is guaranteed to be free from data races, and it is sound to reason locally about program behavior. Verification is modular: a program is valid if all methods are valid, and validity of a method does not depend on program elements that are not visible to the method. We have implemented a verifier for programs developed according to our model in a custom build of the Spec# programming system, and we have validated our approach on a case study.", "paper_title": "A Programming Model for Concurrent Object-Oriented Programs", "paper_id": "WOS:000262394800001"}