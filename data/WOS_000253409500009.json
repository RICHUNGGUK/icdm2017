{"auto_keywords": [{"score": 0.047792824767915534, "phrase": "intra-array_memory_reuse"}, {"score": 0.00481495049065317, "phrase": "lattice-based_array_contraction"}, {"score": 0.0047448515702010734, "phrase": "source-to-source_translator"}, {"score": 0.004630270043271386, "phrase": "prior_work"}, {"score": 0.004474468584252318, "phrase": "general_theoretical_framework"}, {"score": 0.004366387782457736, "phrase": "lattice_theory"}, {"score": 0.0041174821422410544, "phrase": "temporary_array"}, {"score": 0.003998380230709541, "phrase": "a._ne_mappings"}, {"score": 0.003959447096055027, "phrase": "modulo_operations"}, {"score": 0.003901754272977278, "phrase": "memory_locations"}, {"score": 0.0034693659976716197, "phrase": "first_part"}, {"score": 0.0034355810444902106, "phrase": "bee"}, {"score": 0.003368948014436942, "phrase": "source-to-source_transformer"}, {"score": 0.003239549357111286, "phrase": "necessary_information"}, {"score": 0.0031612033120065747, "phrase": "array_elements"}, {"score": 0.003054681986032532, "phrase": "memory_reduction"}, {"score": 0.0030101325901285537, "phrase": "second_part"}, {"score": 0.0029229677574293725, "phrase": "stand-alone_mathematical_tool"}, {"score": 0.0027561164046279413, "phrase": "successive_minima"}, {"score": 0.002689430273401131, "phrase": "good_admissible_lattices"}, {"score": 0.002598764579760562, "phrase": "lattice-based_memory_reuse"}, {"score": 0.002474505516708906, "phrase": "linear_programming"}, {"score": 0.0024503741901918527, "phrase": "polyhedra_manipulations"}, {"score": 0.002356173823922118, "phrase": "embedded_program_optimizations"}, {"score": 0.002276717177453959, "phrase": "memory_expansion"}, {"score": 0.0021999341184897217, "phrase": "high-level_synthesis"}, {"score": 0.0021049977753042253, "phrase": "communicating_hardware_accelerators"}], "paper_keywords": ["memory reduction", " source-to-source transformations", " program analysis", " lattices", " algorithms", " experimentation", " theory"], "paper_abstract": "We build on prior work on intra-array memory reuse, for which a general theoretical framework was proposed based on lattice theory. Intra-array memory reuse is a way of reducing the size of a temporary array by folding, thanks to a. ne mappings and modulo operations, reusing memory locations when they contain a value not used later. We describe the algorithms needed to implement such a strategy. Our implementation has two parts. The first part, Bee, uses the source-to-source transformer ROSE to extract from the program all necessary information on the lifetime of array elements and to generate the code after memory reduction. The second part, Cl@k, is a stand-alone mathematical tool dedicated to optimizations on polyhedra, in particular the computation of successive minima and the computation of good admissible lattices, which are the basis for lattice-based memory reuse. Both tools are developed in C++ and use linear programming and polyhedra manipulations. They can be used either for embedded program optimizations, e. g., to limit memory expansion introduced for parallelization, or in high-level synthesis, e. g., to design memories between communicating hardware accelerators.", "paper_title": "Bee+Cl@k: An implementation of lattice-based array contraction in the source-to-source translator ROSE", "paper_id": "WOS:000253409500009"}