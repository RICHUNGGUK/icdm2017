{"auto_keywords": [{"score": 0.0496265667331732, "phrase": "clock-tree_synthesis"}, {"score": 0.038792795268824225, "phrase": "buffered_clock_tree"}, {"score": 0.029831790983786292, "phrase": "clock_skew"}, {"score": 0.00481495049065317, "phrase": "fast_timing-model_independent"}, {"score": 0.004701985831087475, "phrase": "high-performance_synchronous_chip_design"}, {"score": 0.004548253531664032, "phrase": "small_clock_skew"}, {"score": 0.004441517985511521, "phrase": "clocking_speed"}, {"score": 0.004337276328199398, "phrase": "insufficient_accuracy"}, {"score": 0.004296264970612285, "phrase": "timing_models"}, {"score": 0.004255639740735269, "phrase": "modern_chip_design"}, {"score": 0.004136044939878838, "phrase": "clock-tree_synthesis_flow"}, {"score": 0.004000741805312148, "phrase": "running_time"}, {"score": 0.003815064377019477, "phrase": "chip_designs"}, {"score": 0.0035864603175592854, "phrase": "efficient_timing-model_independent_approach"}, {"score": 0.003485605409687907, "phrase": "structural_optimization"}, {"score": 0.003355515315708125, "phrase": "novel_clock-tree_structure"}, {"score": 0.0031393948330209224, "phrase": "symmetrical_clock_tree"}, {"score": 0.002965229277927781, "phrase": "inserted_buffers"}, {"score": 0.002657890175649468, "phrase": "clock_source"}, {"score": 0.0025343769150179764, "phrase": "clock_tree"}, {"score": 0.00241658945942583, "phrase": "simulation_information"}, {"score": 0.0023936956017015696, "phrase": "experimental_results"}, {"score": 0.0021971473452127126, "phrase": "marginal_wiring_overheads"}, {"score": 0.0021251363422701446, "phrase": "commonly_used_ibm_benchmarks"}], "paper_keywords": ["Clock skew", " clock-tree synthesis", " physical design", " timing"], "paper_abstract": "In high-performance synchronous chip design, a buffered clock tree with small clock skew is essential for improving clocking speed. Due to the insufficient accuracy of timing models for modern chip design, embedding simulation into a clock-tree synthesis flow becomes inevitable. Consequently, the running time for clock-tree synthesis becomes prohibitively huge as the complexity of chip designs grows rapidly. To construct a buffered clock tree efficiently, we propose an efficient timing-model independent approach to perform skew minimization by structural optimization. To achieve the goal, a novel clock-tree structure, called symmetrical structure, is presented. At each level of a symmetrical clock tree, the number of branches, the wirelength, and the inserted buffers are almost the same. It is natural that the clock skew could be minimized if the configurations of all paths from the clock source to sinks are similar. By symmetrically constructing a clock tree, the clock skew can be minimized without referring to simulation information. Experimental results show that our approach can not only efficiently construct a buffered clock tree but also effectively minimize clock skew with marginal wiring overheads. Based on a set of commonly used IBM benchmarks, e.g., a state-of-the-art work without (with) ngspice simulation results in averagely 10.04X (3.44X) clock skew and requires 163X (61906X) running time over our approach.", "paper_title": "Fast Timing-Model Independent Buffered Clock-Tree Synthesis", "paper_id": "WOS:000307974800008"}