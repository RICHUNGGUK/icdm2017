{"auto_keywords": [{"score": 0.046529306696527974, "phrase": "generic_functions"}, {"score": 0.04464053001280883, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "generic_function"}, {"score": 0.004545240514015278, "phrase": "data_type_specific_functionality"}, {"score": 0.003992129945230457, "phrase": "recent_years"}, {"score": 0.003643607569483598, "phrase": "new_languages"}, {"score": 0.0035399770257915466, "phrase": "existing_languages"}, {"score": 0.0034725269588525534, "phrase": "common_characteristic"}, {"score": 0.0026142814606853037, "phrase": "fancy_type_systems"}, {"score": 0.0025892330566358503, "phrase": "separate_tools"}, {"score": 0.0025644240336018045, "phrase": "haskell's_type_classes"}, {"score": 0.0021049977753042253, "phrase": "theoretical_perspective"}], "paper_keywords": [""], "paper_abstract": "A generic function is a function that can be instantiated on many data types to obtain data type specific functionality. Examples of generic functions are the functions that can be derived in Haskell, such as show, read, and '=='. The recent years have seen a number of proposals that support the definition of generic functions. Some of the proposals define new languages, some define extensions to existing languages. As a common characteristic none of the proposals can be made to work within Haskell 98: they all require something extra, either a more sophisticated type system or an additional language construct. The purpose of this paper is to show that one can, in fact, program generically within Haskell 98 obviating to some extent the need for fancy type systems or separate tools. Haskell's type classes are at the heart of this approach: they ensure that generic functions can be defined succinctly and, in particular, that they can be used painlessly. We detail three different implementations of generics both from a practical and from a theoretical perspective.", "paper_title": "Generics for the masses", "paper_id": "WOS:000240174500004"}