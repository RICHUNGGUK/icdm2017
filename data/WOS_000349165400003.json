{"auto_keywords": [{"score": 0.03793790553377171, "phrase": "multimlton"}, {"score": 0.00481495049065317, "phrase": "standard_ml._multimlton"}, {"score": 0.0046987973264610685, "phrase": "mlton_compiler"}, {"score": 0.004660702714929615, "phrase": "runtime_system"}, {"score": 0.004529776351030488, "phrase": "specific_support"}, {"score": 0.004493046526753308, "phrase": "acml"}, {"score": 0.0044025116437190785, "phrase": "concurrent_ml"}, {"score": 0.004278807087784626, "phrase": "composable_asynchronous_events"}, {"score": 0.004041686156098498, "phrase": "potentially_large_numbers"}, {"score": 0.003817655499320344, "phrase": "implicit_concurrency"}, {"score": 0.003771282384646587, "phrase": "asynchronous_events"}, {"score": 0.003740679163860117, "phrase": "scalability_demands"}, {"score": 0.003635503288514593, "phrase": "global_coordination"}, {"score": 0.0035477010181860376, "phrase": "split-heap_memory_manager"}, {"score": 0.003433909720151841, "phrase": "different_cores"}, {"score": 0.0031780228058373235, "phrase": "available_concurrency"}, {"score": 0.0031522185379771056, "phrase": "acml_programs"}, {"score": 0.0031012349116334606, "phrase": "new_collector_design"}, {"score": 0.0030139837612215728, "phrase": "read_barriers"}, {"score": 0.0029531640201737384, "phrase": "significant_overhead"}, {"score": 0.0027893011631269873, "phrase": "asynchronous_communication"}, {"score": 0.002699769374493867, "phrase": "lightweight_concurrency"}, {"score": 0.0026560841114619147, "phrase": "barrier_overheads"}, {"score": 0.002623783458189614, "phrase": "multimlton's_key_novelties"}, {"score": 0.002408388114274793, "phrase": "experimental_results"}, {"score": 0.002359759876402679, "phrase": "parallel_benchmarks"}, {"score": 0.0023405839743112482, "phrase": "different_multicore_architectures"}, {"score": 0.0022933216359142736, "phrase": "azul_vega"}, {"score": 0.002201661008368378, "phrase": "intel"}], "paper_keywords": [""], "paper_abstract": "MULTIMLTON is an extension of the MLton compiler and runtime system that targets scalable, multicore architectures. It provides specific support for ACML, a derivative of Concurrent ML that allows for the construction of composable asynchronous events. To effectively manage asynchrony, we require the runtime to efficiently handle potentially large numbers of lightweight, short-lived threads, many of which are created specifically to deal with the implicit concurrency introduced by asynchronous events. Scalability demands also dictate that the runtime minimize global coordination. MULTIMLTON therefore implements a split-heap memory manager that allows mutators and collectors running on different cores to operate mostly independently. More significantly, MULTIMLTON exploits the premise that there is a surfeit of available concurrency in ACML programs to realize a new collector design that completely eliminates the need for read barriers, a source of significant overhead in other managed runtimes. These two symbiotic features - a thread design specifically tailored to support asynchronous communication, and a memory manager that exploits lightweight concurrency to greatly reduce barrier overheads - are MULTIMLTON's key novelties. In this article, we describe the rationale, design, and implementation of these features, and provide experimental results over a range of parallel benchmarks and different multicore architectures including an 864 core Azul Vega 3, and a 48 core non-coherent Intel SCC (Single-Cloud Computer), that justify our design decisions.", "paper_title": "MultiMLton: A multicore-aware runtime for standard ML", "paper_id": "WOS:000349165400003"}