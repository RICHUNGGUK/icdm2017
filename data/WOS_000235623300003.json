{"auto_keywords": [{"score": 0.03206918993968707, "phrase": "areso"}, {"score": 0.006556686152981813, "phrase": "basic_input"}, {"score": 0.006397703281887771, "phrase": "shifted_input"}, {"score": 0.00481495049065317, "phrase": "shifted_operands_-_a_register_transfer_level_concurrent_error_detection_technique"}, {"score": 0.004698000536608171, "phrase": "algorithm-level"}, {"score": 0.004428728205625129, "phrase": "new_register_transfer"}, {"score": 0.004154335744633717, "phrase": "ced"}, {"score": 0.004013662619667083, "phrase": "shifted_operands"}, {"score": 0.0032800186243040663, "phrase": "reso_operators"}, {"score": 0.003247868216333148, "phrase": "rt-level_designs"}, {"score": 0.0029722900280316216, "phrase": "specialized_reso_operators"}, {"score": 0.0024768883044869023, "phrase": "algorithm_level"}, {"score": 0.002428530921948425, "phrase": "rt-level_scheduling"}, {"score": 0.0023811153883132536, "phrase": "operator_chaining"}, {"score": 0.0023117182131967523, "phrase": "user-specified_error_detection_latencies"}, {"score": 0.0022223176391038785, "phrase": "error_detection_latency_tradeoffs"}, {"score": 0.002146926767291475, "phrase": "practical_design_examples"}, {"score": 0.0021050267691325995, "phrase": "bc"}], "paper_keywords": ["concurrent error detection", " high-level synthesis", " register transfer level", " single-event upsets", " time redundancy"], "paper_abstract": "This paper presents Algorithm-level REcomputing with Shifted Operands (ARESO), which is a new register transfer (RT) level time redundancy-based concurrent error detection (CED) technique. In REcomputing with Shifted Operands (RESO), operations (additions, subtractions, etc.) are carried out twice-once on the basic input and once on the shifted input. Results from these two operations are compared to detect an error. Although using RESO operators in RT-level designs is straightforward, it entails time and area overhead. In contrast, ARESO does not use specialized RESO operators. In ARESO, an algorithm is carried out twice-once on the basic input and once on the shifted input. Results from these two algorithm-level instantiations are compared to detect an error. By operating at the algorithm level, ARESO exploits RT-level scheduling, pipelining, operator chaining, and multicycling to incorporate user-specified error detection latencies. ARESO supports hardware versus performance versus error detection latency tradeoffs. The authors validated ARESO on practical design examples using the Synopsys Behavior Compiler (BC).", "paper_title": "Algorithm-level recomputing with shifted operands - A register transfer level concurrent error detection technique", "paper_id": "WOS:000235623300003"}