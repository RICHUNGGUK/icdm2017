{"auto_keywords": [{"score": 0.03594971232257351, "phrase": "proof_assistants"}, {"score": 0.00481495049065317, "phrase": "real-world_semantics"}, {"score": 0.004696491408936132, "phrase": "remarkable_successes"}, {"score": 0.004657653216262924, "phrase": "rigorous_engineering"}, {"score": 0.004599994523941615, "phrase": "mathematically_rigorous_semantic_models"}, {"score": 0.004449688143230257, "phrase": "real-world_processors"}, {"score": 0.004304271837157217, "phrase": "security_mechanisms"}, {"score": 0.0037527984559873745, "phrase": "engineering_issues"}, {"score": 0.003585089792133518, "phrase": "clear_and_usable_mathematics"}, {"score": 0.0031125001790084936, "phrase": "extended_period"}, {"score": 0.0028760125558659907, "phrase": "engineering_reusable_large-scale_semantic_models"}, {"score": 0.0027703320456201074, "phrase": "functional_programming_languages"}, {"score": 0.0027020387992490367, "phrase": "lem_definitions"}, {"score": 0.002657453659266227, "phrase": "ocaml"}, {"score": 0.0026136279459767803, "phrase": "coq"}, {"score": 0.002507090493320592, "phrase": "latex"}, {"score": 0.0024863114724150283, "phrase": "html"}, {"score": 0.0024149139610228887, "phrase": "delicate_balance"}, {"score": 0.0023750478314945303, "phrase": "careful_library_design"}, {"score": 0.0022036216160494925, "phrase": "usable_and_human-readable_code"}], "paper_keywords": ["Lem", " real-world semantics", " specification language", " proof assistants"], "paper_abstract": "Recent years have seen remarkable successes in rigorous engineering: using mathematically rigorous semantic models (not just idealised calculi) of real-world processors, programming languages, protocols, and security mechanisms, for testing, proof, analysis, and design. Building these models is challenging, requiring experimentation, dialogue with vendors or standards bodies, and validation; their scale adds engineering issues akin to those of programming to the task of writing clear and usable mathematics. But language and tool support for specification is lacking. Proof assistants can be used but bring their own difficulties, and a model produced in one, perhaps requiring many person-years effort and maintained over an extended period, cannot be used by those familiar with another. We introduce Lem, a language for engineering reusable large-scale semantic models. The Lem design takes inspiration both from functional programming languages and from proof assistants, and Lem definitions are translatable into OCaml for testing, Coq, HOL4, and Isabelle/HOL for proof, and LaTeX and HTML for presentation. This requires a delicate balance of expressiveness, careful library design, and implementation of transformations - akin to compilation, but subject to the constraint of producing usable and human-readable code for each target. Lem's effectiveness is demonstrated by its use in practice.", "paper_title": "Lem: Reusable Engineering of Real-world Semantics", "paper_id": "WOS:000349143000016"}