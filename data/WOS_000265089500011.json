{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "byzantine_processes"}, {"score": 0.004743806810821005, "phrase": "policy-enforced_tuple_spaces"}, {"score": 0.0046046429665581555, "phrase": "large_amount"}, {"score": 0.004536592536813498, "phrase": "byzantine_fault-tolerant_algorithms"}, {"score": 0.0044695432851061525, "phrase": "message-passing_systems"}, {"score": 0.004027031316965272, "phrase": "byzantine_failures"}, {"score": 0.0039674831861175935, "phrase": "shared_memory"}, {"score": 0.003737934295442975, "phrase": "new_computing_model"}, {"score": 0.003601235776892337, "phrase": "fine-grained_access_policies"}, {"score": 0.0034954725617970294, "phrase": "new_shared_memory_object"}, {"score": 0.00296675450822924, "phrase": "simple_and_efficient_consensus_algorithms"}, {"score": 0.002712794864739074, "phrase": "also_less_memory_bits"}, {"score": 0.0025940660106162404, "phrase": "access_control_lists"}, {"score": 0.002499094513009327, "phrase": "sticky_bits"}, {"score": 0.002389696110283506, "phrase": "peats_objects"}, {"score": 0.0021049977753042253, "phrase": "present_lock-free_and_wait-free_universal_constructions"}], "paper_keywords": ["Byzantine fault-tolerance", " shared memory algorithms", " tuple spaces", " consensus", " universal constructions"], "paper_abstract": "Despite the large amount of Byzantine fault-tolerant algorithms for message-passing systems designed through the years, only recent algorithms for the coordination of processes subject to Byzantine failures using shared memory have appeared. This paper presents a new computing model in which shared memory objects are protected by fine-grained access policies, and a new shared memory object, the Policy-Enforced Augmented Tuple Space (PEATS). We show the benefits of this model by providing simple and efficient consensus algorithms. These algorithms are much simpler and require less shared memory operations, using also less memory bits than previous algorithms based on access control lists (ACLs) and sticky bits. We also prove that PEATS objects are universal, i.e., that they can be used to implement any other shared memory object, and present lock-free and wait-free universal constructions.", "paper_title": "Sharing Memory between Byzantine Processes Using Policy-Enforced Tuple Spaces", "paper_id": "WOS:000265089500011"}