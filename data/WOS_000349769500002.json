{"auto_keywords": [{"score": 0.014948551534413344, "phrase": "spmxv"}, {"score": 0.00481495049065317, "phrase": "iterative_solvers"}, {"score": 0.00475413908468027, "phrase": "latency_overhead"}, {"score": 0.004714023408114857, "phrase": "parallel_sparse-matrix_vector_multiplies"}, {"score": 0.0046544807197808095, "phrase": "parallel_linear_iterative_solvers"}, {"score": 0.004615202066192795, "phrase": "sparse_matrix_vector_multiplication"}, {"score": 0.004240116703465252, "phrase": "additional_synchronization_point"}, {"score": 0.004204320052179726, "phrase": "relatively_high_message_latency_costs"}, {"score": 0.004151188559520802, "phrase": "small_message_sizes"}, {"score": 0.003928572641266562, "phrase": "inner_product_computation"}, {"score": 0.0038624981944755813, "phrase": "output_vector"}, {"score": 0.003670843919846253, "phrase": "novel_parallelization_method"}, {"score": 0.0036090884921108086, "phrase": "latency_costs"}, {"score": 0.003578600071301459, "phrase": "synchronization_overhead"}, {"score": 0.0034299649219748513, "phrase": "communication_rearrangement_scheme"}, {"score": 0.0033865859510157238, "phrase": "computational_rearrangement"}, {"score": 0.0033437537557378157, "phrase": "alternative_method"}, {"score": 0.003301461490509176, "phrase": "input_vector"}, {"score": 0.003204841443605308, "phrase": "collective_communications"}, {"score": 0.0031242709509664837, "phrase": "single_phase"}, {"score": 0.0030847461428168614, "phrase": "communication_rearrangement"}, {"score": 0.0029817668105720924, "phrase": "global_collective_communication_operations"}, {"score": 0.002944039482467119, "phrase": "proposed_method"}, {"score": 0.002870006736445581, "phrase": "maximum_number"}, {"score": 0.002785978280998868, "phrase": "sparsity_pattern"}, {"score": 0.0026475981474045414, "phrase": "increased_message_volume"}, {"score": 0.0026140878612307536, "phrase": "negligible_redundant_computation"}, {"score": 0.002548331088496964, "phrase": "message_latency_costs"}, {"score": 0.0024947959375982614, "phrase": "increasing_message_volume"}, {"score": 0.0023408288327263316, "phrase": "one-to-one_task-to-processor_mapping"}, {"score": 0.002243506773483362, "phrase": "ibm"}, {"score": 0.0021593396036472777, "phrase": "proposed_parallelization_method"}, {"score": 0.0021410718792612173, "phrase": "superior_scalable_performance"}, {"score": 0.0021049977753042253, "phrase": "conventional_parallelization_method"}], "paper_keywords": ["Parallel linear iterative solvers", " sparse matrix vector multiplication", " point-to-point communication", " inner product computation", " conjugate gradient", " collective communication", " message latency overhead", " avoiding latency", " hiding latency", " iterative improvement heuristic"], "paper_abstract": "In parallel linear iterative solvers, sparse matrix vector multiplication (SpMxV) incurs irregular point-to-point (P2P) communications, whereas inner product computations incur regular collective communications. These P2P communications cause an additional synchronization point with relatively high message latency costs due to small message sizes. In these solvers, each SpMxV is usually followed by an inner product computation that involves the output vector of SpMxV. Here, we exploit this property to propose a novel parallelization method that avoids the latency costs and synchronization overhead of P2P communications. Our method involves a computational and a communication rearrangement scheme. The computational rearrangement provides an alternative method for forming input vector of SpMxV and allows P2P and collective communications to be performed in a single phase. The communication rearrangement realizes this opportunity by embedding P2P communications into global collective communication operations. The proposed method grants a certain value on the maximum number of messages communicated regardless of the sparsity pattern of the matrix. The downside, however, is the increased message volume and the negligible redundant computation. We favor reducing the message latency costs at the expense of increasing message volume. Yet, we propose two iterative-improvement-based heuristics to alleviate the increase in the volume through one-to-one task-to-processor mapping. Our experiments on two supercomputers, Cray XE6 and IBM BlueGene/Q, up to 2,048 processors show that the proposed parallelization method exhibits superior scalable performance compared to the conventional parallelization method.", "paper_title": "A Novel Method for Scaling Iterative Solvers: Avoiding Latency Overhead of Parallel Sparse-Matrix Vector Multiplies", "paper_id": "WOS:000349769500002"}