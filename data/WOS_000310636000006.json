{"auto_keywords": [{"score": 0.03786165600609578, "phrase": "tunstall"}, {"score": 0.00481495049065317, "phrase": "string-to-dictionary_matching_problem"}, {"score": 0.0038794730876377057, "phrase": "compressed_matching"}, {"score": 0.0037363522297378777, "phrase": "fixed-length_encodings"}, {"score": 0.003401148484767927, "phrase": "suffix_trees"}, {"score": 0.0024014759148123736, "phrase": "natural_language_text"}, {"score": 0.0023346234464901978, "phrase": "compressed_search"}, {"score": 0.0022273034991008326, "phrase": "long_enough_patterns"}, {"score": 0.0021049977753042253, "phrase": "potentially_large_number"}], "paper_keywords": ["compressed matching", " tunstall", " suffix trees"], "paper_abstract": "The String-to-Dictionary Matching Problem is defined, in which a string is searched for in all the possible concatenations of the elements of a given dictionary, with applications to compressed matching in variable to fixed-length encodings, such as Tunstall's. Two algorithms based on suffix trees are suggested, the one focusing on the dictionary, the other on the pattern to be searched for. The problem is then extended to deal also with patterns that include gaps. Experiments on natural language text suggest that compressed search might use less comparisons for long enough patterns, in spite of a potentially large number of encodings.", "paper_title": "The String-to-Dictionary Matching Problem", "paper_id": "WOS:000310636000006"}