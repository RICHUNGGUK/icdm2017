{"auto_keywords": [{"score": 0.049150989754801186, "phrase": "tm"}, {"score": 0.00481495049065317, "phrase": "transactional_memory_contention_management"}, {"score": 0.00452252857066346, "phrase": "concurrent_applications"}, {"score": 0.004348813532606792, "phrase": "multiple_cores"}, {"score": 0.004298006360831255, "phrase": "data_access_pattern"}, {"score": 0.004036852178449883, "phrase": "data_patterns"}, {"score": 0.004005339423663657, "phrase": "frequent_write_sharing"}, {"score": 0.003958529104387973, "phrase": "long_transactions"}, {"score": 0.0038363485899400285, "phrase": "smaller_number"}, {"score": 0.0037471850931318942, "phrase": "numerous_conflicts"}, {"score": 0.003674461410107989, "phrase": "tm_implementations"}, {"score": 0.0036172962914449796, "phrase": "transactional_threads"}, {"score": 0.003491894048789576, "phrase": "kernel's_transaction-ignorant_scheduler"}, {"score": 0.003357633232360232, "phrase": "stm-level_contention_manager"}, {"score": 0.0032924448113309797, "phrase": "contention_managers"}, {"score": 0.0032539388572032563, "phrase": "\"_conventional\"_tm_implementations"}, {"score": 0.00310435218261112, "phrase": "reasonable_performance"}, {"score": 0.0030800962618484844, "phrase": "high-contention_workloads"}, {"score": 0.0030321497870310077, "phrase": "scheduling-based_tm_contention-management"}, {"score": 0.0029616217177058602, "phrase": "tm_efficiency"}, {"score": 0.0028033523242224833, "phrase": "user-level_schedulers"}, {"score": 0.002551409948440577, "phrase": "different_strategies"}, {"score": 0.002531463482341473, "phrase": "efficient_communication"}, {"score": 0.002472552537325606, "phrase": "user-level_tm_library"}, {"score": 0.002340357706078868, "phrase": "kernel-level_support"}, {"score": 0.0023220573674955776, "phrase": "tm_contention_management"}, {"score": 0.0022769287097263564, "phrase": "kernel-level_tm_scheduling_support"}, {"score": 0.002197891020396052, "phrase": "lightweight_kernel-level_scheduling_support"}, {"score": 0.0021215910859085146, "phrase": "transaction_throughput"}], "paper_keywords": ["Algorithms", " Performance", " Transactional Memory", " Scheduling", " Contention Management"], "paper_abstract": "Transactional Memory (TM) is considered as one of the most promising paradigms for developing concurrent applications. TM has been shown to scale well on multiple cores when the data access pattern behaves \"well,\" i.e., when few conflicts are induced. In contrast, data patterns with frequent write sharing, with long transactions, or when many threads contend for a smaller number of cores, result in numerous conflicts. Until recently, TM implementations had little control of transactional threads, which remained under the supervision of the kernel's transaction-ignorant scheduler. Conflicts are thus traditionally resolved by consulting an STM-level contention manager. Consequently, the contention managers of these \" conventional\" TM implementations suffer from a lack of precision and often fail to ensure reasonable performance in high-contention workloads. Recently, scheduling-based TM contention-management has been proposed for increasing TM efficiency under high-contention [2, 5, 19]. However, only user-level schedulers have been considered. In this work, we propose, implement and evaluate several novel kernel-level scheduling support mechanisms for TM contention management. We also investigate different strategies for efficient communication between the kernel and the user-level TM library. To the best of our knowledge, our work is the first to investigate kernel-level support for TM contention management. We have introduced kernel-level TM scheduling support into both the Linux and Solaris kernels. Our experimental evaluation demonstrates that lightweight kernel-level scheduling support significantly reduces the number of aborts while improving transaction throughput on various workloads.", "paper_title": "Scheduling Support for Transactional Memory Contention Management", "paper_id": "WOS:000280548100008"}