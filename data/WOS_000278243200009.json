{"auto_keywords": [{"score": 0.04582909850189696, "phrase": "open_multi-methods"}, {"score": 0.00481495049065317, "phrase": "multiple_dispatch"}, {"score": 0.004795585480947173, "phrase": "-_the_selection"}, {"score": 0.004606148097788071, "phrase": "dynamic_type"}, {"score": 0.004424160689087029, "phrase": "object-oriented_programming"}, {"score": 0.004301046274139699, "phrase": "open-class_extensions"}, {"score": 0.004131063310728304, "phrase": "retroactive_design"}, {"score": 0.003920049436883885, "phrase": "programming_guidelines"}, {"score": 0.0037955672944969287, "phrase": "language_feature"}, {"score": 0.0034452601929727752, "phrase": "argument_types"}, {"score": 0.0033223686422055834, "phrase": "covariant_return_types"}, {"score": 0.003077092305006702, "phrase": "model_implementation"}, {"score": 0.00301560261110296, "phrase": "existing_open_multi-method_extensions"}, {"score": 0.0027150658583211746, "phrase": "link-time_analysis"}, {"score": 0.00266079124891013, "phrase": "memory_usage"}, {"score": 0.002545165985686468, "phrase": "runtime_cost"}, {"score": 0.002504374718975704, "phrase": "open_multi-method"}, {"score": 0.0024052270356036743, "phrase": "double_dispatch"}, {"score": 0.0021917966722180132, "phrase": "dynamic_loading"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Multi-methods", " Open-methods", " Multiple dispatch", " Binary method problem", " Augmenting method problem", " Object-oriented programming", " Generic programming", " C plus"], "paper_abstract": "Multiple dispatch - the selection of a function to be invoked based on the dynamic type of two or more arguments - is a solution to several classical problems in object-oriented programming. Open multi-methods generalize multiple dispatch towards open-class extensions, which improve separation of concerns and provisions for retroactive design. We present the rationale, design, implementation, performance, programming guidelines, and experiences of working with a language feature, called open multi-methods, for C++. Our open multi-methods support both repeated and virtual inheritance. Our call resolution rules generalize both virtual function dispatch and overload resolution semantics. After using all information from argument types, these rules can resolve further ambiguities by using covariant return types. Care was taken to integrate open multi-methods with existing C++ language features and rules. We describe a model implementation and compare its performance and space requirements to existing open multi-method extensions and work-around techniques for C++. Compared to these techniques, our approach is simpler to use, catches more user mistakes, and resolves more ambiguities through link-time analysis, is comparable in memory usage, and runs significantly faster. In particular, the runtime cost of calling an open multi-method is constant and less than the cost of a double dispatch (two virtual function calls). Finally, we provide a sketch of a design for open multi-methods in the presence of dynamic loading and linking of libraries. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Design and evaluation of C plus plus open multi-methods", "paper_id": "WOS:000278243200009"}