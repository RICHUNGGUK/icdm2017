{"auto_keywords": [{"score": 0.047929617715279135, "phrase": "bmc"}, {"score": 0.014246143635812258, "phrase": "propositional_formulas"}, {"score": 0.00481495049065317, "phrase": "facilitating_multicore"}, {"score": 0.004529093447865156, "phrase": "verification_problem"}, {"score": 0.004392565073466714, "phrase": "satisfiability_checks"}, {"score": 0.0042928648367867835, "phrase": "bound_deepens"}, {"score": 0.003976523732243618, "phrase": "hybrid_approach"}, {"score": 0.003931118518507637, "phrase": "stateless_explicit-state_exploration"}, {"score": 0.0038125469099459905, "phrase": "bmc_process"}, {"score": 0.003585986761045987, "phrase": "linear_temporal_logic"}, {"score": 0.0034911335714333507, "phrase": "sese"}, {"score": 0.0033599501775954024, "phrase": "bounded-context_switching"}, {"score": 0.0032336801561165113, "phrase": "system_design"}, {"score": 0.0031967297437935772, "phrase": "legal_execution_paths"}, {"score": 0.0031002400518251936, "phrase": "heuristic_state_predicates"}, {"score": 0.00307657476125683, "phrase": "path_clusters"}, {"score": 0.0029270797740550973, "phrase": "encoded_formula"}, {"score": 0.0028936226331006563, "phrase": "ltl_property"}, {"score": 0.0028715299874549245, "phrase": "independent_bmc_instances"}, {"score": 0.002806256131739047, "phrase": "smt_solvers"}, {"score": 0.0026091594819333654, "phrase": "entire_model"}, {"score": 0.0025014259919355453, "phrase": "hybrid_checking_procedure"}, {"score": 0.0024633601573822114, "phrase": "incremental_fashion"}, {"score": 0.0023798115577749225, "phrase": "user-specified_bound"}, {"score": 0.0023079225317714815, "phrase": "proposed_hybrid_approach"}, {"score": 0.002129356014992349, "phrase": "state-of-the-art_bmc_methods"}, {"score": 0.002104999029278527, "phrase": "sal"}], "paper_keywords": ["Bounded Model Checking", " stateless explicit-state exploration", " multicore computation", " linear temporal logic properties"], "paper_abstract": "Bounded Model Checking (BMC) converts a verification problem within a user-specified bound into satisfiability checks of propositional formulas. As the bound deepens, the formulas become larger in size and harder to solve. In this paper, we propose a hybrid approach in which stateless explicit-state exploration (SESE) is integrated into the BMC process to improve the scalability and performance of BMC for the verification of properties expressed in Linear Temporal Logic (LTL). Specifically, SESE is utilized to traverse, under the constraints of Bounded-Context Switching (BCS), the state space of a system design and memorize legal execution paths. These paths are classified according to heuristic state predicates into path clusters, which are then encoded into propositional formulas representing, together with the encoded formula for an LTL property, independent BMC instances. Such BMC instances are solved with SMT solvers running on mutilcores in parallel. Once a counterexample is found for one of the instances, the entire model checking (SESE as well as BMC) terminates. This hybrid checking procedure progresses in an incremental fashion until either a counterexample is found or the user-specified bound is reached. We have implemented this proposed hybrid approach in a tool called Garakabu2 with Yices 2 as its back-end solver. The experimental results show that Garakabu2 outperforms significantly the state-of-the-art BMC methods implemented in SAL for both safety and liveness properties.", "paper_title": "Facilitating Multicore Bounded Model Checking with Stateless Explicit-State Exploration(aEuro)", "paper_id": "WOS:000365157000003"}