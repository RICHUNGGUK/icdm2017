{"auto_keywords": [{"score": 0.05007852962010534, "phrase": "lock_contention"}, {"score": 0.004776484866276242, "phrase": "multithreaded_applications"}, {"score": 0.004700468701207975, "phrase": "shared-memory_parallelism"}, {"score": 0.0046256566852302256, "phrase": "threaded_codes"}, {"score": 0.0044795698035664695, "phrase": "shared_data"}, {"score": 0.00432070565627091, "phrase": "parallel_efficiency"}, {"score": 0.00401961206251868, "phrase": "multithreaded_program"}, {"score": 0.0037999551521987426, "phrase": "performance_losses"}, {"score": 0.0036212219870826725, "phrase": "straightforward_strategy"}, {"score": 0.0035778632599436024, "phrase": "call_stack"}, {"score": 0.0035208552733545463, "phrase": "idle_time"}, {"score": 0.002868646843975439, "phrase": "new_technique"}, {"score": 0.0027008385562908425, "phrase": "lock_holders"}, {"score": 0.0025633455664747606, "phrase": "quantum_chemistry_application"}, {"score": 0.0025326211341475903, "phrase": "extensive_use"}, {"score": 0.0024822279007111255, "phrase": "distinct_locks"}, {"score": 0.002209060366991921, "phrase": "hpctoolkit"}, {"score": 0.0021049977753042253, "phrase": "large_core_counts"}], "paper_keywords": ["Performance", " Measurement", " Algorithms", " Performance Analysis", " Lock Contention", " Multithreading", " HPCTOOLKIT"], "paper_abstract": "Many programs exploit shared-memory parallelism using multithreading. Threaded codes typically use locks to coordinate access to shared data. In many cases, contention for locks reduces parallel efficiency and hurts scalability. Being able to quantify and attribute lock contention is important for understanding where a multithreaded program needs improvement. This paper proposes and evaluates three strategies for gaining insight into performance losses due to lock contention. First, we consider using a straightforward strategy based on call stack profiling to attribute idle time and show that it fails to yield insight into lock contention. Second, we consider an approach that builds on a strategy previously used for analyzing idleness in work-stealing computations; we show that this strategy does not yield insight into lock contention. Finally, we propose a new technique for measurement and analysis of lock contention that uses data associated with locks to blame lock holders for the idleness of spinning threads. Our approach incurs < 5% overhead on a quantum chemistry application that makes extensive use of locking (65M distinct locks, a maximum of 340K live locks, and an average of 30K lock acquisitions per second per thread) and attributes lock contention to its full static and dynamic calling contexts. Our strategy, implemented in HPCTOOLKIT, is fully distributed and should scale well to systems with large core counts.", "paper_title": "Analyzing Lock Contention in Multithreaded Applications", "paper_id": "WOS:000280548100025"}