{"auto_keywords": [{"score": 0.048010005733846825, "phrase": "in-place_update"}, {"score": 0.014814912370836581, "phrase": "functional_semantics"}, {"score": 0.00481495049065317, "phrase": "usage_aspects"}, {"score": 0.0047846807459660376, "phrase": "linear_typing_schemes"}, {"score": 0.0044922081848067135, "phrase": "linear_schemes"}, {"score": 0.004177805391358892, "phrase": "static_analysis"}, {"score": 0.003947118540355604, "phrase": "linear_and_non-linear_schemes"}, {"score": 0.0038124354878360032, "phrase": "new_typing_scheme"}, {"score": 0.0037527389293924907, "phrase": "semantic_property"}, {"score": 0.003500945350055404, "phrase": "\"read-only\"_context"}, {"score": 0.003317970131738248, "phrase": "in-place_update_interpretation"}, {"score": 0.0032866843679612134, "phrase": "machine_model_semantics"}, {"score": 0.003095257144856771, "phrase": "function_argument_types"}, {"score": 0.0027278178983579085, "phrase": "main_novelty"}, {"score": 0.00264296841319955, "phrase": "linear_value"}, {"score": 0.0024421847638964947, "phrase": "previous_systems"}, {"score": 0.002426795311298483, "phrase": "functional_languages"}, {"score": 0.0023071120479647325, "phrase": "strong_soundness_property"}, {"score": 0.0022212306049833397, "phrase": "principal_types"}, {"score": 0.0022072304165576405, "phrase": "feasible_type_reconstruction"}, {"score": 0.0021726139494880653, "phrase": "m._konecny"}, {"score": 0.0021317942470536325, "phrase": "nijmegen"}, {"score": 0.002118551119649606, "phrase": "proceedings"}, {"score": 0.0021050026344196426, "phrase": "springer-verlag"}], "paper_keywords": [""], "paper_abstract": "Linear typing schemes can be used to guarantee non-interference and so the soundness of in-place update with respect to a functional semantics. But linear schemes are restrictive in practice, and more restrictive than necessary to guarantee soundness of in-place update. This limitation has prompted research into static analysis and more sophisticated typing disciplines to determine when in-place update may be safely used, or to combine linear and non-linear schemes. Here we contribute to this direction by defining a new typing scheme that better approximates the semantic property of soundness of in-place update for a functional semantics. We begin from the observation that some data are used only in a \"read-only\" context, after which it may be safely re-used before being destroyed. Formalising the in-place update interpretation in a machine model semantics allows us to refine this observation, motivating three usage aspects apparent from the semantics that are used to annotate function argument types. The aspects are (1) used destructively, (2), used read-only but shared with result, and (3) used read-only and not shared with the result. The main novelty is aspect (2), which allows a linear value to be safely read and even aliased with a result of a function without being consumed. This novelty makes our type system more expressive than previous systems for functional languages in the literature. The system remains simple and intuitive, but it enjoys a strong soundness property whose proof is non-trivial. Moreover, our analysis features principal types and feasible type reconstruction, as shown in M. Konecny (in TYPES 2002 workshop, Nijmegen, Proceedings, Springer-Verlag, 2003).", "paper_title": "A type system with usage aspects", "paper_id": "WOS:000254541700001"}