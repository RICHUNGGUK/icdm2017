{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "stack-space_bounds"}, {"score": 0.010207958362553502, "phrase": "formal_verification"}, {"score": 0.010067247386390577, "phrase": "source_level"}, {"score": 0.007730840738657899, "phrase": "compcert_clight"}, {"score": 0.0069161447667412425, "phrase": "quantitative_logic"}, {"score": 0.0047881480263782675, "phrase": "c_programs"}, {"score": 0.004682414867878963, "phrase": "semantic_properties"}, {"score": 0.004515532787428149, "phrase": "important_quantitative_properties"}, {"score": 0.004342430078306461, "phrase": "machine_level"}, {"score": 0.004318246489874451, "phrase": "interactive_proofs"}, {"score": 0.0040382952886546825, "phrase": "compiled_machine_code"}, {"score": 0.00400459716272594, "phrase": "c_level"}, {"score": 0.0039380388343479384, "phrase": "verified_compcert-based_compiler"}, {"score": 0.003808209866576388, "phrase": "interactive_stack-bound_development"}, {"score": 0.003703282519292336, "phrase": "stack_bounds"}, {"score": 0.0035811651542886746, "phrase": "record_function"}, {"score": 0.0035216195857272403, "phrase": "source_language"}, {"score": 0.0034727526607880883, "phrase": "target_language"}, {"score": 0.0033770368103682564, "phrase": "coq_proof_assistant"}, {"score": 0.0033208740593211467, "phrase": "crucial_properties"}, {"score": 0.003229330714669772, "phrase": "novel_quantitative_hoare_logic"}, {"score": 0.00315791054946254, "phrase": "compcert_clight_level"}, {"score": 0.003096727374923341, "phrase": "coq"}, {"score": 0.0029945352738604742, "phrase": "small-step_semantics"}, {"score": 0.0028795712616923462, "phrase": "account_low-level_details"}, {"score": 0.002761275225630865, "phrase": "low-level_details"}, {"score": 0.0027153251683182784, "phrase": "concrete_stack-space"}, {"score": 0.002670137713149619, "phrase": "produced_machine_code"}, {"score": 0.0026478260192958924, "phrase": "verified_stack_analyzer"}, {"score": 0.002574788013427524, "phrase": "non-recursive_functions"}, {"score": 0.002455205987751813, "phrase": "interactively_developed_stack_bounds"}, {"score": 0.0024278839351563764, "phrase": "experimental_evaluation"}, {"score": 0.0024075916292945715, "phrase": "developed_framework"}, {"score": 0.0023741464204143406, "phrase": "verified_stack-space_bounds"}, {"score": 0.0023281003994670714, "phrase": "real_system_code"}, {"score": 0.0022893422054387235, "phrase": "verified_operating-system_kernel"}, {"score": 0.002238664219600659, "phrase": "benchmark_suite"}, {"score": 0.0022013916728990564, "phrase": "compcert_benchmarks"}, {"score": 0.0021829882516961846, "phrase": "derived_bounds"}, {"score": 0.0021526564019119466, "phrase": "measured_stack-space_usage"}, {"score": 0.0021227451058653084, "phrase": "compiled_programs"}], "paper_keywords": ["Formal Verification", " Compiler Construction", " Program Logics", " Stack-Space Bounds", " Quantitative Verification"], "paper_abstract": "Verified compilers guarantee the preservation of semantic properties and thus enable formal verification of programs at the source level. However, important quantitative properties such as memory and time usage still have to be verified at the machine level where interactive proofs tend to be more tedious and automation is more challenging. This article describes a framework that enables the formal verification of stack-space bounds of compiled machine code at the C level. It consists of a verified CompCert-based compiler that preserves quantitative properties, a verified quantitative program logic for interactive stack-bound development, and a verified stack analyzer that automatically derives stack bounds during compilation. The framework is based on event traces that record function calls and returns. The source language is CompCert Clight and the target language is x86 assembly. The compiler is implemented in the Coq Proof Assistant and it is proved that crucial properties of event traces are preserved during compilation. A novel quantitative Hoare logic is developed to verify stack-space bounds at the CompCert Clight level. The quantitative logic is implemented in Coq and proved sound with respect to event traces generated by the small-step semantics of CompCert Clight. Stack-space bounds can be proved at the source level without taking into account low-level details that depend on the implementation of the compiler. The compiler fills in these low-level details during compilation and generates a concrete stack-space bound that applies to the produced machine code. The verified stack analyzer is guaranteed to automatically derive bounds for code with non-recursive functions. It generates a derivation in the quantitative logic to ensure soundness as well as interoperability with interactively developed stack bounds. In an experimental evaluation, the developed framework is used to obtain verified stack-space bounds for micro benchmarks as well as real system code. The examples include the verified operating-system kernel CertiKOS, parts of the MiBench embedded benchmark suite, and programs from the CompCert benchmarks. The derived bounds are close to the measured stack-space usage of executions of the compiled programs on a Linux x86 system.", "paper_title": "End-to-End Verification of Stack-Space Bounds for C Programs", "paper_id": "WOS:000344455800030"}