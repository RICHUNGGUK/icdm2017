{"auto_keywords": [{"score": 0.03201460631367665, "phrase": "average_analysis_time"}, {"score": 0.02952876531682219, "phrase": "access-based_localization"}, {"score": 0.00481495049065317, "phrase": "static_analysis"}, {"score": 0.004671803485255806, "phrase": "abstract_memory_states"}, {"score": 0.0046018264570209765, "phrase": "economical_abstract_interpretation"}, {"score": 0.004567230180529598, "phrase": "imperative_programs"}, {"score": 0.004203343568960231, "phrase": "new_memory_localization_technique"}, {"score": 0.00409372989087314, "phrase": "conventional_reachability-based_approach"}, {"score": 0.003971938976270902, "phrase": "key_observation"}, {"score": 0.0039124037252916055, "phrase": "reachable_memory_parts"}, {"score": 0.0038247634489737142, "phrase": "accessed_parts"}, {"score": 0.00378167947598949, "phrase": "tiny_subsets"}, {"score": 0.0037390789999636764, "phrase": "reachable_part"}, {"score": 0.003627800727103479, "phrase": "efficient_pre-analysis"}, {"score": 0.0035599338383885447, "phrase": "input_states"}, {"score": 0.003440945901489461, "phrase": "code_block"}, {"score": 0.0033893426032054366, "phrase": "main_analysis"}, {"score": 0.0033511469200347907, "phrase": "access-set_results"}, {"score": 0.0033008858616145205, "phrase": "memory_entries"}, {"score": 0.003263683763829895, "phrase": "code_blocks"}, {"score": 0.0031905286720361145, "phrase": "industrial-strength_global_c_static_analyzer"}, {"score": 0.00307221807606505, "phrase": "procedure's_body"}, {"score": 0.0028810424107858436, "phrase": "analysis_precision"}, {"score": 0.0026014984513015368, "phrase": "loop_bodies"}, {"score": 0.0025819015229390663, "phrase": "basic_blocks"}, {"score": 0.002543148295176345, "phrase": "procedure_bodies"}, {"score": 0.0025049752758014602, "phrase": "analysis_time"}, {"score": 0.0023490143960001675, "phrase": "performance_problem"}, {"score": 0.002305014991156598, "phrase": "recursive_procedures"}, {"score": 0.0021049977753042253, "phrase": "relational_numeric_analyses"}], "paper_keywords": ["Static analysis", " Abstract interpretation", " Localization"], "paper_abstract": "On-the-fly localization of abstract memory states is vital for economical abstract interpretation of imperative programs. Such localization is sometimes called \"abstract garbage collection\" or \"framing\". In this article we present a new memory localization technique that is more effective than the conventional reachability-based approach. Our technique is based on a key observation that collecting the reachable memory parts is too conservative and the accessed parts are usually tiny subsets of the reachable part. Our technique first estimates, by an efficient pre-analysis, which parts of input states will be accessed during the analysis of each code block. Then the main analysis uses the access-set results to trim the memory entries before analyzing code blocks. In experiments with an industrial-strength global C static analyzer, the technique is applied right before analyzing each procedure's body and reduces the average analysis time and memory by 92.1% and 71.2%, respectively, without sacrificing the analysis precision. In addition, we present three extensions of access-based localization: (1) we generalize the idea and apply the localization more frequently such as at loop bodies and basic blocks as well as procedure bodies, additionally reducing analysis time by an average of 31.8%; (2) we present a technique to mitigate a performance problem of localization in handling recursive procedures, and show that this extension improves the average analysis time by 42%; (3) we show how to incorporate the access-based localization into relational numeric analyses. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Access-based abstract memory localization in static analysis", "paper_id": "WOS:000321536100025"}