{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "interval_analysis"}, {"score": 0.00458869631642791, "phrase": "signedness_ignorance"}, {"score": 0.0035208552733545463, "phrase": "program_analysis"}, {"score": 0.00340954056723008, "phrase": "integer_computations"}, {"score": 0.0032753168662834516, "phrase": "infinite_precision"}, {"score": 0.003071429173571846, "phrase": "fixed_width"}, {"score": 0.0028115863316685937, "phrase": "novel_integer_interval_abstract_domain"}, {"score": 0.002615381301695394, "phrase": "signedness_agnostic"}, {"score": 0.0021391300942881, "phrase": "modest_cost"}, {"score": 0.0021049977753042253, "phrase": "execution_time"}], "paper_keywords": ["Algorithms", " Languages", " Reliability", " Theory", " Verification", " Abstract interpretation", " interval analysis", " LLVM", " machine arithmetic", " modular arithmetic", " overflow", " program analysis"], "paper_abstract": "The most commonly used integer types have fixed bit-width, making it possible for computations to \"wrap around,\" and many programs depend on this behaviour. Yet much work to date on program analysis and verification of integer computations treats integers as having infinite precision, and most analyses that do respect fixed width lose precision when overflow is possible. We present a novel integer interval abstract domain that correctly handles wrap-around. The analysis is signedness agnostic. By treating integers as strings of bits, only considering signedness for operations that treat them differently, we produce precise, correct results at a modest cost in execution time.", "paper_title": "Interval Analysis and Machine Arithmetic: Why Signedness Ignorance Is Bliss", "paper_id": "WOS:000348919700001"}