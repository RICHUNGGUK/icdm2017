{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "many-core_architecture"}, {"score": 0.04694776222290317, "phrase": "existing_algorithms"}, {"score": 0.004739056045644449, "phrase": "current_trends"}, {"score": 0.004701556483912018, "phrase": "computer_programming"}, {"score": 0.004590820632326585, "phrase": "challenging_task"}, {"score": 0.00446490613141384, "phrase": "many-core_architectures"}, {"score": 0.0043945048085683005, "phrase": "central_processing_units"}, {"score": 0.004223299391912042, "phrase": "standardized_general-purpose_parallel_programming_and_porting_methodologies"}, {"score": 0.003823803986707131, "phrase": "next-generation"}, {"score": 0.003517458289610994, "phrase": "well_known_algorithms"}, {"score": 0.003109390330476147, "phrase": "independent_linux_operating_system"}, {"score": 0.0026836723685046407, "phrase": "communication_layer"}, {"score": 0.0025892330566358503, "phrase": "clustalw_tool"}, {"score": 0.0023069016803337365, "phrase": "unprecedented_way"}, {"score": 0.002279508335630797, "phrase": "standalone_personal_computer"}, {"score": 0.002208035721125305, "phrase": "effective_exploitation"}, {"score": 0.002181813794658713, "phrase": "parallel_implementations"}, {"score": 0.0021559025985688255, "phrase": "detailed_understanding"}, {"score": 0.002130298466581199, "phrase": "peculiar_many-core_characteristics"}, {"score": 0.0021049977753042253, "phrase": "previous_non-parallel_source_codes"}], "paper_keywords": ["System-on-chip", " Multiprocessor system", " Code migration", " Domain-specific architecture", " Programming methodology", " Sequence alignment and assembly"], "paper_abstract": "Current trends in computer programming look for solutions in the challenging task of porting and optimizing existing algorithms to many-core architectures with tens of Central Processing Units (CPUs). Yet, the lack of standardized general-purpose parallel programming and porting methodologies represents the main bottleneck on these developments. We have focused on bioinformatics applied to genomics in general and the so-called \"Next-Generation\" Sequencing (NGS) in particular, in order to study the viability and cost of porting and optimizing well known algorithms to a many-core architecture. Three different methods are tackled in order to implement existing algorithms in Tile64, corresponding to a microprocessor containing 64 CPUs, each of them being capable of executing an independent Linux operating system. Three different approaches have been explored: (i) implementation of the Needleman-Wunsch/Smith-Waterman pairwise aligner from scratch; (ii) direct translation of the Message Passing Interface (MPI) C++ ABySS assembly algorithm with changes on the communication layer; and (iii) migration of the ClustalW tool, parallelizing only the most time-consuming stage. The performance-gain/development-cost tradeoffs indicate that the Tile64 microprocessor has the potential to increase the performance of bioinformatics in an unprecedented way for a standalone Personal Computer (PC). Yet, the effective exploitation of these parallel implementations requires a detailed understanding of the peculiar many-core characteristics when migrating previous non-parallel source codes. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Direct approaches to exploit many-core architecture in bioinformatics", "paper_id": "WOS:000311771700002"}