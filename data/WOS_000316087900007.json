{"auto_keywords": [{"score": 0.03267645255366653, "phrase": "single-type_edtds"}, {"score": 0.015341667125581717, "phrase": "xml_schema"}, {"score": 0.010901382625108303, "phrase": "unambiguous_edtd."}, {"score": 0.010750074737100275, "phrase": "unambiguous_edtds"}, {"score": 0.0074696362985526114, "phrase": "uniform_generation"}, {"score": 0.00481495049065317, "phrase": "regular_tree_languages"}, {"score": 0.0047310525657970615, "phrase": "learning_and_approximation_algorithms"}, {"score": 0.004487989502479992, "phrase": "random_a_corpus"}, {"score": 0.004378854464130883, "phrase": "similarity_measure"}, {"score": 0.004287415750101536, "phrase": "generated_xsd"}, {"score": 0.004242411872706126, "phrase": "target_schema"}, {"score": 0.0041102032028337366, "phrase": "formal_foundation"}, {"score": 0.004024351756560517, "phrase": "similarity_measures"}, {"score": 0.0039264465913491356, "phrase": "common_and_different_trees"}, {"score": 0.003804046908915231, "phrase": "necessary_machinery"}, {"score": 0.003672500644750565, "phrase": "extended_dtds"}, {"score": 0.0035831245825960617, "phrase": "unranked_regular_tree_languages"}, {"score": 0.003483631502938922, "phrase": "efficient_algorithm"}, {"score": 0.0033044432971036652, "phrase": "latter_class"}, {"score": 0.0028201570908224166, "phrase": "allowed_trees"}, {"score": 0.0026844452074327265, "phrase": "well-known_formalism"}, {"score": 0.002609840513713399, "phrase": "free_a_sampling_procedure"}, {"score": 0.0024581013157048926, "phrase": "full_class"}, {"score": 0.0023729878025466836, "phrase": "counting_problem"}, {"score": 0.0023233376117560317, "phrase": "approximation_algorithm"}, {"score": 0.0021049977753042253, "phrase": "k-occurrence_automata"}], "paper_keywords": ["XML schema languages", " Counting", " Complexity"], "paper_abstract": "To experimentally validate learning and approximation algorithms for XML Schema Definitions (XSDs), we need algorithms to generate uniformly at random a corpus of XSDs as well as a similarity measure to compare how close the generated XSD resembles the target schema. In this paper, we provide the formal foundation for such a testbed. We adopt similarity measures based on counting the number of common and different trees in the two languages, and we develop the necessary machinery for computing them. We use the formalism of extended DTDs (EDTDs) to represent the unranked regular tree languages. In particular, we obtain an efficient algorithm to count the number of trees up to a certain size in an unambiguous EDTD. The latter class of unambiguous EDTDs encompasses the more familiar classes of single-type, restrained competition and bottom-up deterministic EDTDs. The single-type EDTDs correspond precisely to the core of XML Schema, while the others are strictly more expressive. We also show how constraints on the shape of allowed trees can be incorporated. As we make use of a translation into a well-known formalism for combinatorial specifications, we get for free a sampling procedure to draw members of any unambiguous EDTD. When dropping the restriction to unambiguous EDTDs, i.e. taking the full class of EDTDs into account, we show that the counting problem becomes #P-complete and provide an approximation algorithm. Finally, we discuss uniform generation of single-type EDTDs, i.e., the formal abstraction of XSDs. To this end, we provide an algorithm to generate k-occurrence automata (k-OAs) uniformly at random and show how this leads to the uniform generation of single-type EDTDs.", "paper_title": "Generating, Sampling and Counting Subclasses of Regular Tree Languages", "paper_id": "WOS:000316087900007"}