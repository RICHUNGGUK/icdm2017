{"auto_keywords": [{"score": 0.03977146875669389, "phrase": "abstract_resource"}, {"score": 0.00481495049065317, "phrase": "higher-order_flow_analysis"}, {"score": 0.004615202066192795, "phrase": "abstract-interpretation-based_flow_analysis"}, {"score": 0.0033579708256295847, "phrase": "flow_sets"}, {"score": 0.003264316172836322, "phrase": "abstract_interpretation"}, {"score": 0.0029775511937434797, "phrase": "interpretation_increases"}, {"score": 0.00281371157349156, "phrase": "abstract_counting"}, {"score": 0.0022276618873985445, "phrase": "environment_analysis"}], "paper_keywords": [""], "paper_abstract": "We present two complementary improvements for abstract-interpretation-based flow analysis of higher-order languages: (1) abstract garbage collection and (2) abstract counting.(1,2) Abstract garbage collection is an analog to its concrete Counterpart: the analysis determines when an abstract resource has become unreachable, and then, re-allocates it as fresh. This prevents flow sets from joining during abstract interpretation, which has two immediate effects: (1) the precision of the interpretation increases and (2) its running time often [falls. In abstract counting, the analysis tracks how many times an abstract resource has been allocated. A Count of one implies that the abstract resource momentarily represents only one concrete resource. This knowledge, in turn, drives environment analysis, expanding the kind (rather than just the degree) of optimization available to the compiler.", "paper_title": "Exploiting reachability and cardinality in higher-order flow analysis", "paper_id": "WOS:000261111700007"}