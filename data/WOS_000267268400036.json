{"auto_keywords": [{"score": 0.03685259410949237, "phrase": "chameleon"}, {"score": 0.013598227587512848, "phrase": "fixed_choice"}, {"score": 0.00481495049065317, "phrase": "adaptive_selection_of_collections"}, {"score": 0.004690823731613819, "phrase": "java"}, {"score": 0.004522080178250592, "phrase": "scripting_languages"}, {"score": 0.0044751408801974755, "phrase": "python"}, {"score": 0.004405361391874672, "phrase": "ruby"}, {"score": 0.0043367547691560175, "phrase": "extensive_use"}, {"score": 0.004291617358806677, "phrase": "collection_classes"}, {"score": 0.004224786847720058, "phrase": "collection_implementation"}, {"score": 0.004051595625804513, "phrase": "operation_time"}, {"score": 0.0040094142308666975, "phrase": "space_utilization"}, {"score": 0.0036489343475053187, "phrase": "significant_performance_degradation"}, {"score": 0.003234934827553253, "phrase": "appropriate_collection_implementation"}, {"score": 0.0031513240597392843, "phrase": "program_execution"}, {"score": 0.003085989256759819, "phrase": "elaborate_trace"}, {"score": 0.0030538300202383106, "phrase": "heap-based_metrics"}, {"score": 0.002823050755743821, "phrase": "rules_engine"}, {"score": 0.0027356847952125433, "phrase": "suggested_collection_adaptation_strategies"}, {"score": 0.002637160140011997, "phrase": "corrective_strategies"}, {"score": 0.0023254633298356894, "phrase": "small_set"}, {"score": 0.0021383680500215267, "phrase": "significant_improvement"}, {"score": 0.0021049977753042253, "phrase": "memory_footprint"}], "paper_keywords": ["Performance", " Languages", " bloat", " collections", " java", " semantic profiler"], "paper_abstract": "Languages such as Java and C#, as well as scripting languages like Python, and Ruby, make extensive use of Collection classes. A collection implementation represents a fixed choice in the dimensions of operation time, space utilization, and synchronization. Using the collection in a manner not consistent with this fixed choice can cause significant performance degradation. In this paper, we present CHAMELEON, a low-overhead automatic tool that assists the programmer in choosing the appropriate collection implementation for her application. During program execution, CHAMELEON computes elaborate trace and heap-based metrics on collection behavior. These metrics are consumed on-the-fly by a rules engine which outputs a list of suggested collection adaptation strategies. The tool can apply these corrective strategies automatically or present them to the programmer. We have implemented CHAMELEON on top of a IBM's J9 production JVM, and evaluated it over a small set of benchmarks. We show that for some applications, using CHAMELEON leads to a significant improvement of the memory footprint of the application.", "paper_title": "Chameleon: Adaptive Selection of Collections", "paper_id": "WOS:000267268400036"}