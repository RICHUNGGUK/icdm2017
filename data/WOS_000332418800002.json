{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "explicit_deallocation"}, {"score": 0.004278807087784626, "phrase": "small_devices"}, {"score": 0.004219774794569897, "phrase": "embedded_systems"}, {"score": 0.004161553532799662, "phrase": "strict_memory_requirements"}, {"score": 0.003855347387268162, "phrase": "unusual_memory_management_features"}, {"score": 0.003775803846431323, "phrase": "heap_regions"}, {"score": 0.0037236852537136547, "phrase": "explicit_cell_deallocation"}, {"score": 0.0035468507553681034, "phrase": "proof_carrying_code_environment"}, {"score": 0.0033549790559972053, "phrase": "safe_compiler"}, {"score": 0.003308649946463136, "phrase": "machine_checkable_certificates"}, {"score": 0.0032629585038738856, "phrase": "important_safety_properties"}, {"score": 0.002742196991950893, "phrase": "safe_compiler's_back-end"}, {"score": 0.002648448458159033, "phrase": "appropriate_abstract_machine"}, {"score": 0.0025937408242280757, "phrase": "language_semantics"}, {"score": 0.002505054869094183, "phrase": "code_generation_functions"}, {"score": 0.0021947755130109696, "phrase": "memory_consumption_senses"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Functional languages", " Memory management", " Certifying compilers", " Abstract machines", " Code generation"], "paper_abstract": "In this paper we summarise Safe, a first-order functional language for programming small devices and embedded systems with strict memory requirements, which has been introduced elsewhere. It has some unusual memory management features such as heap regions and explicit cell deallocation. It is targeted at a Proof Carrying Code environment, and consistently with this aim the Safe compiler provides machine checkable certificates about important safety properties such as the absence of dangling pointers and bounded memory consumption. The kernel of the paper is devoted to developing part of the Safe compiler's back-end, by deriving an appropriate abstract machine from the language semantics, by providing the code generation functions, and by formally proving that the translation is sound, both in the semantic and in the memory consumption senses. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "A resource semantics and abstract machine for Safe: A functional language with regions and explicit deallocation", "paper_id": "WOS:000332418800002"}