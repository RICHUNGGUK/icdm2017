{"auto_keywords": [{"score": 0.041791008124514514, "phrase": "memory_requirements"}, {"score": 0.00481495049065317, "phrase": "packet_payload"}, {"score": 0.004741845603430361, "phrase": "high_speed"}, {"score": 0.004646088032529303, "phrase": "crucial_task"}, {"score": 0.004598933498016774, "phrase": "modern_network_management"}, {"score": 0.0044150318724093226, "phrase": "application-specific_services"}, {"score": 0.0043258453436258405, "phrase": "deterministic_finite_automatons"}, {"score": 0.004089725258435817, "phrase": "linear_time"}, {"score": 0.003788296551609616, "phrase": "practical_packet_scanning"}, {"score": 0.0036181717017041387, "phrase": "single_dfa._existing_solutions"}, {"score": 0.003581412258960711, "phrase": "memory_blow-up"}, {"score": 0.0034733518170738517, "phrase": "memory_requirement"}, {"score": 0.003351381374975648, "phrase": "input_character"}, {"score": 0.0032172054825137866, "phrase": "novel_method"}, {"score": 0.003025915966640355, "phrase": "high_matching_speed"}, {"score": 0.0029798924689472014, "phrase": "worst-case_guarantees"}, {"score": 0.00290473242917264, "phrase": "duplicate_transitions"}, {"score": 0.0026359661683151006, "phrase": "merged_transition_table"}, {"score": 0.002556359086441866, "phrase": "efficient_algorithm"}, {"score": 0.002530359917257626, "phrase": "transition_sharing"}, {"score": 0.002466510117718297, "phrase": "high_efficiency"}, {"score": 0.00235560370536971, "phrase": "frequently_updated_dfas"}, {"score": 0.002284444272376043, "phrase": "real_world_rule_sets"}, {"score": 0.0022154296909169826, "phrase": "rule_sets"}, {"score": 0.002126635713519053, "phrase": "best_memory"}, {"score": 0.0021049977753042253, "phrase": "run-time_trade-offs"}], "paper_keywords": ["regular expression", " memory reduction", " deep packet inspection", " transition sharing"], "paper_abstract": "Scanning packet payload at a high speed has become a crucial task in modern network management due to its wide variety applications on network security and application-specific services. Traditionally, Deterministic finite automatons (DFAs) are used to perform this operation in linear time. However, the memory requirements of DFAs are prohibitively high for patterns used in practical packet scanning, especially when many patterns are compiled into a single DFA. Existing solutions for memory blow-up are making a trade-off between memory requirement and memory access of processing per input character. In this paper we proposed a novel method to drastically reduce the memory requirements of DFAs while still maintain the high matching speed and provide worst-case guarantees. We removed the duplicate transitions between states by dividing all the DFA states into a number of groups and making each group of states share a merged transition table. We also proposed an efficient algorithm For transition sharing between states. The high efficiency in time and space made our approach adapted to frequently updated DFAs. We performed several experiments on real world rule sets. Overall, for all rule sets and approach evaluated, Our approach offers the best memory versus run-time trade-offs.", "paper_title": "Fast and Memory-Efficient Regular Expression Matching Using Transition Sharing", "paper_id": "WOS:000272394700016"}