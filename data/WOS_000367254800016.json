{"auto_keywords": [{"score": 0.04586846484671967, "phrase": "gpu_devices"}, {"score": 0.04382947386253929, "phrase": "multiple_gpu_devices"}, {"score": 0.035884478140401375, "phrase": "native_opencl_run-time_system"}, {"score": 0.03417501812534373, "phrase": "virtcl"}, {"score": 0.030457179852808183, "phrase": "kernel_tasks"}, {"score": 0.030107690735348032, "phrase": "history-based_scheduler"}, {"score": 0.026742492150313695, "phrase": "virtcl_framework"}, {"score": 0.00481495049065317, "phrase": "opencl_device_abstraction"}, {"score": 0.004702225913184213, "phrase": "multiple_graphics_processing_units"}, {"score": 0.004497899823062428, "phrase": "existing_heterogeneous_programming_models"}, {"score": 0.004418666248371415, "phrase": "abstract_details"}, {"score": 0.0043537008514226445, "phrase": "per-device_level"}, {"score": 0.004139850082354509, "phrase": "multiple_applications"}, {"score": 0.004091072003277219, "phrase": "multi-gpu_system"}, {"score": 0.003901617424466747, "phrase": "distributed_memory_model"}, {"score": 0.0038671088466269645, "phrase": "opencl"}, {"score": 0.003517107332500739, "phrase": "programming_burden"}, {"score": 0.003334309053314909, "phrase": "single_virtual_device"}, {"score": 0.003304776913264834, "phrase": "scheduling_computations"}, {"score": 0.0032561349010603734, "phrase": "multiple_devices"}, {"score": 0.0030960281690122745, "phrase": "primary_opencl_apis"}, {"score": 0.0030685999966886734, "phrase": "virtual_device"}, {"score": 0.002815638762571003, "phrase": "front-end_library"}, {"score": 0.0027659570272100835, "phrase": "back-end_cldaemon"}, {"score": 0.0025605773834404253, "phrase": "communication-aware_manner"}, {"score": 0.0024930878032164757, "phrase": "small_overhead"}, {"score": 0.0023845255359681143, "phrase": "rodinia_benchmark_suite"}, {"score": 0.002335489878370869, "phrase": "abstraction_layer"}, {"score": 0.002314783782656802, "phrase": "time-consuming_initialization"}, {"score": 0.0022604585778195152, "phrase": "different_scheduling_policies"}, {"score": 0.0022271532243556373, "phrase": "real-world_application"}, {"score": 0.002123831297790248, "phrase": "multiple_kernel_tasks"}, {"score": 0.0021049977753042253, "phrase": "multi-gpu_systems"}], "paper_keywords": ["Design", " Management", " Experimentation"], "paper_abstract": "The interest in using multiple graphics processing units (GPUs) to accelerate applications has increased in recent years. However, the existing heterogeneous programming models (e.g., OpenCL) abstract details of GPU devices at the per-device level and require programmers to explicitly schedule their kernel tasks on a system equipped with multiple GPU devices. Unfortunately, multiple applications running on a multi-GPU system may compete for some of the GPU devices while leaving other GPU devices unused. Moreover, the distributed memory model defined in OpenCL, where each device has its own memory space, increases the complexity of managing the memory among multiple GPU devices. In this article we propose a framework (called VirtCL) that reduces the programming burden by acting as a layer between the programmer and the native OpenCL run-time system for abstracting multiple devices into a single virtual device and for scheduling computations and communications among the multiple devices. VirtCL comprises two main components: (1) a front-end library, which exposes primary OpenCL APIs and the virtual device, and (2) a back-end run-time system (called CLDaemon) for scheduling and dispatching kernel tasks based on a history-based scheduler. The front-end library forwards computation requests to the back-end CLDaemon, which then schedules and dispatches the requests. We also propose a history-based scheduler that is able to schedule kernel tasks in a contention-and communication-aware manner. Experiments demonstrated that the VirtCL framework introduced a small overhead (mean of 6%) but outperformed the native OpenCL run-time system for most benchmarks in the Rodinia benchmark suite, which was due to the abstraction layer eliminating the time-consuming initialization of OpenCL contexts. We also evaluated different scheduling policies in VirtCL with a real-world application (clsurf) and various synthetic workload traces. The results indicated that the VirtCL framework provides scalability for multiple kernel tasks running on multi-GPU systems.", "paper_title": "VirtCL: A Framework for OpenCL Device Abstraction and Management", "paper_id": "WOS:000367254800016"}