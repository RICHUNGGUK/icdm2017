{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "bell"}, {"score": 0.014473997951850278, "phrase": "sleigh"}, {"score": 0.007823884880665355, "phrase": "per-object_sites"}, {"score": 0.004779854231878764, "phrase": "bit"}, {"score": 0.004640590144749795, "phrase": "memory_leaks"}, {"score": 0.004539005582217309, "phrase": "crippling_performance"}, {"score": 0.004310501708408856, "phrase": "immediate_symptoms"}, {"score": 0.004278807087784626, "phrase": "online_leak_detection_tools"}, {"score": 0.003816197777388722, "phrase": "high_space_overhead"}, {"score": 0.0037463983616303786, "phrase": "production_environments"}, {"score": 0.0036778708850237814, "phrase": "bit-encoding_leak_location"}, {"score": 0.0035054881943660096, "phrase": "single_bit"}, {"score": 0.0033288399506044763, "phrase": "sufficient_objects"}, {"score": 0.003161065111494053, "phrase": "brute-force_decoding"}, {"score": 0.003091767402370757, "phrase": "high_accuracy"}, {"score": 0.0030017207229983385, "phrase": "object_allocation_and_last-use_sites"}, {"score": 0.0028715299874549245, "phrase": "stale_objects"}, {"score": 0.0028085616610192456, "phrase": "long_time"}, {"score": 0.0026472970609754095, "phrase": "object_header"}, {"score": 0.002598821419664902, "phrase": "per-object_space_overhead"}, {"score": 0.0025137856138000014, "phrase": "adaptive_profiling"}, {"score": 0.0024677487011556427, "phrase": "sleigh's_output"}, {"score": 0.0023346234464901978, "phrase": "sufficiently_many_objects"}, {"score": 0.0023003498123420237, "phrase": "bell_decoding"}, {"score": 0.0021049977753042253, "phrase": "statistical_per-object_metadata"}], "paper_keywords": ["reliability", " performance", " experimentation", " memory leaks", " low-overhead monitoring", " probabilistic approaches", " managed languages"], "paper_abstract": "Memory leaks compromise availability and security by crippling performance and crashing programs. Leaks are difficult to diagnose because they have no immediate symptoms. Online leak detection tools benefit from storing and reporting per-object sites (e. g., allocation sites) for potentially leaking objects. In programs with many small objects, per-object sites add high space overhead, limiting their use in production environments. This paper introduces Bit-Encoding Leak Location (Bell), a statistical approach that encodes per-object sites to a single bit per object. A bit loses information about a site, but given sufficient objects that use the site and a known, finite set of possible sites, Bell uses brute-force decoding to recover the site with high accuracy. We use this approach to encode object allocation and last-use sites in Sleigh, a new leak detection tool. Sleigh detects stale objects (objects unused for a long time) and uses Bell decoding to report their allocation and last-use sites. Our implementation steals four unused bits in the object header and thus incurs no per-object space overhead. Sleigh's instrumentation adds 29% execution time overhead, which adaptive profiling reduces to 11%. Sleigh's output is directly useful for finding and fixing leaks in SPEC JBB2000 and Eclipse, although sufficiently many objects must leak before Bell decoding can report sites with confidence. Bell is suitable for other leak detection approaches that store per-object sites, and for other problems amenable to statistical per-object metadata.", "paper_title": "Bell: Bit-encoding online memory leak detection", "paper_id": "WOS:000202972600007"}