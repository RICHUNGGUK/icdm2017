{"auto_keywords": [{"score": 0.024134772656611854, "phrase": "tnt"}, {"score": 0.00481495049065317, "phrase": "complementary_activities"}, {"score": 0.00436890075128947, "phrase": "practical_success_rate"}, {"score": 0.004298666679374568, "phrase": "verification_tools"}, {"score": 0.003996271202811961, "phrase": "safety_verification"}, {"score": 0.003900257249255497, "phrase": "current_focus"}, {"score": 0.0038375280115736958, "phrase": "liveness_verification"}, {"score": 0.003567455727660992, "phrase": "termination_proofs"}, {"score": 0.0033433365160336842, "phrase": "infinite_program_execution"}, {"score": 0.0021049977753042253, "phrase": "bit-level_reasoning"}], "paper_keywords": ["reliability", " verification", " program verification", " model checking", " testing", " nontermination", " recurrent sets"], "paper_abstract": "The search for proof and the search for counterexamples (bugs) are complementary activities that need to be pursued concurrently in order to maximize the practical success rate of verification tools. While this is well-understood in safety verification, the current focus of liveness verification has been almost exclusively on the search for termination proofs. A counterexample to termination is an infinite program execution. In this paper, we propose a method to search for such counterexamples. The search proceeds in two phases. We first dynamically enumerate lasso-shaped candidate paths for counterexamples, and then statically prove their feasibility. We illustrate the utility of our nontermination prover, called TNT, on several nontrivial examples, some of which require bit-level reasoning about integer representations.", "paper_title": "Proving non-termination", "paper_id": "WOS:000256500600016"}