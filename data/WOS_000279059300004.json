{"auto_keywords": [{"score": 0.0370524624129902, "phrase": "spm"}, {"score": 0.03095533011367865, "phrase": "reference_case"}, {"score": 0.026076771122330072, "phrase": "energy_consumption"}, {"score": 0.00481495049065317, "phrase": "scratchpad_memory_management_techniques_for_code"}, {"score": 0.004769444094319619, "phrase": "embedded_systems"}, {"score": 0.004701986529515816, "phrase": "mmu."}, {"score": 0.004399525320473839, "phrase": "memory_management_unit"}, {"score": 0.0042354707960660706, "phrase": "postpass_optimizer"}, {"score": 0.004155742403177802, "phrase": "application_binaries"}, {"score": 0.0040969285074699, "phrase": "fully_automated_process"}, {"score": 0.0037969755088553326, "phrase": "mixed_integer_linear_programming_formulation"}, {"score": 0.0036379729015583975, "phrase": "external_memory"}, {"score": 0.003603549914861701, "phrase": "pinned_code"}, {"score": 0.003371508176308189, "phrase": "spm._paged_code"}, {"score": 0.0031693980719538287, "phrase": "proposed_technique"}, {"score": 0.0030656196752517836, "phrase": "cycle-accurate_arm_processor_simulator"}, {"score": 0.0027218799769229596, "phrase": "direct-mapped_cache"}, {"score": 0.002657890175649468, "phrase": "comparable_die_area"}, {"score": 0.0025103699913760057, "phrase": "runtime_performance"}, {"score": 0.0021251363422701446, "phrase": "measured_results"}], "paper_keywords": ["Compilers", " postpass optimization", " code placement", " demand paging", " scratchpad memory", " embedded systems"], "paper_abstract": "We propose a code scratchpad memory (SPM) management technique with demand paging for embedded systems that have no memory management unit. Based on profiling information, a postpass optimizer analyzes and optimizes application binaries in a fully automated process. It classifies the code of the application including libraries into three classes based on a mixed integer linear programming formulation: External code is executed directly from the external memory. Pinned code is loaded into the SPM when the application starts and stays in the SPM. Paged code is loaded into/unloaded from the SPM on demand. We evaluate the proposed technique by running 14 embedded applications both on a cycle-accurate ARM processor simulator and an ARM1136JF-S core. On the simulator, the reference case, a four-way set-associative cache, is compared to a direct-mapped cache and an SPM of comparable die area. On average, we observe an improvement of 12 percent in runtime performance and a 21 percent reduction in energy consumption. On the ARM11 board, the reference case run on the 16-KB four-way set-associative cache is compared to the demand paging solution on the 16-KB SPM, optionally supported by the cache. The measured results show both a runtime performance improvement and a reduction of the energy consumption by 23 percent, on average.", "paper_title": "Scratchpad Memory Management Techniques for Code in Embedded Systems without an MMU", "paper_id": "WOS:000279059300004"}