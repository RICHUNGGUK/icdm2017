{"auto_keywords": [{"score": 0.033432006348234344, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "lazy_functional_program"}, {"score": 0.0037336520904376687, "phrase": "standard_static_types"}, {"score": 0.0026140878612307536, "phrase": "classical_blaming"}, {"score": 0.002391067964886602, "phrase": "lazy_functional_languages"}, {"score": 0.0021049977753042253, "phrase": "correct_programs"}], "paper_keywords": ["Languages", " Reliability", " purely functional", " lazy", " library", " Haskell"], "paper_abstract": "Until now there has been no support for specifying and enforcing contracts within a lazy functional program. That is a shame, because contracts consist of pre- and post-conditions for functions that go beyond the standard static types. This paper presents the design and implementation of a small, easy-to-use, purely functional contract library for Haskell, which, when a contract is violated, also provides more useful information than the classical blaming of one contract partner. From now on lazy functional languages can profit from the assurances in the development of correct programs that contracts provide.", "paper_title": "Practical Typed Lazy Contracts", "paper_id": "WOS:000311296000008"}