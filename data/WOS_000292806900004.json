{"auto_keywords": [{"score": 0.030322382466632915, "phrase": "source_code_artifacts"}, {"score": 0.015613038597652446, "phrase": "source_code"}, {"score": 0.014000030769558096, "phrase": "persistence_layer"}, {"score": 0.00481495049065317, "phrase": "design_inconsistencies"}, {"score": 0.004749106104067268, "phrase": "logical_abduction"}, {"score": 0.0047003115977448905, "phrase": "design_decay"}, {"score": 0.004604214511792668, "phrase": "trivial_task"}, {"score": 0.004463723624910583, "phrase": "software_system's_code"}, {"score": 0.004372442291178139, "phrase": "database_queries"}, {"score": 0.004238993477742183, "phrase": "coding_conventions"}, {"score": 0.0038758293658651237, "phrase": "far_greater_complexity"}, {"score": 0.003835972725191194, "phrase": "basic_corrective_actions"}, {"score": 0.003809628721278519, "phrase": "simplistic_implementation_problems"}, {"score": 0.0037188360359702182, "phrase": "local_variable"}, {"score": 0.003693293499842943, "phrase": "non-declared_variable"}, {"score": 0.0035681790580031998, "phrase": "abductive_reasoning_approach"}, {"score": 0.003543667617024855, "phrase": "inconsistency_correction"}, {"score": 0.003353521531649663, "phrase": "system's_design"}, {"score": 0.0033304797419738182, "phrase": "coding_rules"}, {"score": 0.0032065418360603293, "phrase": "possible_causes"}, {"score": 0.003151736708029235, "phrase": "system's_code"}, {"score": 0.0031193028729331667, "phrase": "documented_rules"}, {"score": 0.0030344301563232944, "phrase": "hypothesized_cause"}, {"score": 0.0029214769181390653, "phrase": "design_rules"}, {"score": 0.0029013950320185573, "phrase": "equality_relationships"}, {"score": 0.002518746501941657, "phrase": "user-defined_binary_relationships"}, {"score": 0.0024333239726872604, "phrase": "state_changing_method"}, {"score": 0.0023999697562763433, "phrase": "persistence_method"}, {"score": 0.002194011800331242, "phrase": "logic_queries"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Inconsistency management", " Abductive reasoning", " Logic meta programming"], "paper_abstract": "Correcting design decay in source code is not a trivial task. Diagnosing and subsequently correcting inconsistencies between a software system's code and its design rules (e.g., database queries are only allowed in the persistence layer) and coding conventions can be complex, time-consuming and error-prone. Providing support for this process is therefore highly desirable, but of a far greater complexity than suggesting basic corrective actions for simplistic implementation problems (like the \"declare a local variable for non-declared variable\" suggested by Eclipse). We present an abductive reasoning approach to inconsistency correction that consists of (1) a means for developers to document and verify a system's design and coding rules, (2) an abductive logic reasoner that hypothesizes possible causes of inconsistencies between the system's code and the documented rules and (3) a library of corrective actions for each hypothesized cause. This work builds on our previous work, where we expressed design rules as equality relationships between sets of source code artifacts (e.g., the set of methods in the persistence layer is the same as the set of methods that query the database). In this paper, we generalize our approach to design rules expressed as user-defined binary relationships between two sets of source code artifacts (e.g., every state changing method should invoke a persistence method). We illustrate our approach on the design of IntensiVE, a tool suite that enables defining sets of source code artifacts intensionally (by means of logic queries) and verifying relationships between such sets. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Diagnosing and correcting design inconsistencies in source code with logical abduction", "paper_id": "WOS:000292806900004"}