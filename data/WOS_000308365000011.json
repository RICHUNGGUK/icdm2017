{"auto_keywords": [{"score": 0.04586846484671967, "phrase": "chr"}, {"score": 0.0064760681230093715, "phrase": "smchr"}, {"score": 0.00481495049065317, "phrase": "constraint_handling_rules"}, {"score": 0.004641351004344458, "phrase": "high-level_rule-based_programming_language"}, {"score": 0.004312622975366676, "phrase": "global_store"}, {"score": 0.004234129588974058, "phrase": "flat_conjunction"}, {"score": 0.0035668128900149814, "phrase": "host_system"}, {"score": 0.0033548062793973144, "phrase": "satisfiability_modulo_constraint_handling_rules"}, {"score": 0.0032336801561165113, "phrase": "tight_integration"}, {"score": 0.0031360786664165093, "phrase": "modern_boolean_satisfiability"}, {"score": 0.003022825806274343, "phrase": "quantifier-free_formulae"}, {"score": 0.0029677378488677983, "phrase": "arbitrary_propositional_structure"}, {"score": 0.002860546817196148, "phrase": "satisfiability_modulo_theories"}, {"score": 0.0026252106881752067, "phrase": "execution_algorithm"}, {"score": 0.002530359917257626, "phrase": "lazy_clause_generation"}, {"score": 0.002469032978674379, "phrase": "new_clause"}, {"score": 0.002424012799998538, "phrase": "sat_solver"}, {"score": 0.002224510044064184, "phrase": "practical_aspects"}, {"score": 0.0021705796895687864, "phrase": "smchr_system"}, {"score": 0.0021049977753042253, "phrase": "\"built-in\"_constraint_solver"}], "paper_keywords": ["CHR", " satisfiability modulo theories", " lazy clause generation"], "paper_abstract": "Constraint Handling Rules (CHRs) are a high-level rule-based programming language for specification and implementation of constraint solvers. CHR manipulates a global store representing a flat conjunction of constraints. By default, CHR does not support goals with a more complex propositional structure including disjunction, negation, etc., or CHR relies on the host system to provide such features. In this paper we introduce Satisfiability Modulo Constraint Handling Rules (SMCHR): a tight integration of CHR with a modern Boolean Satisfiability (SAT) solver for quantifier-free formulae with an arbitrary propositional structure. SMCHR is essentially a Satisfiability Modulo Theories (SMT) solver where the theory T is implemented in CHR. The execution algorithm of SMCHR is based on lazy clause generation, where a new clause for the SAT solver is generated whenever a rule is applied. We shall also explore the practical aspects of building an SMCHR system, including extending a \"built-in\" constraint solver supporting equality with unification and justifications.", "paper_title": "SMCHR: Satisfiability modulo constraint handling rules", "paper_id": "WOS:000308365000011"}