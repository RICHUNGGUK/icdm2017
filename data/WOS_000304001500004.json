{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "aspect-oriented_programs"}, {"score": 0.011088897030493313, "phrase": "aspect-oriented_state_model"}, {"score": 0.004768104290288521, "phrase": "finite_state_machines"}, {"score": 0.004607686390487483, "phrase": "new_types"}, {"score": 0.004562847483469705, "phrase": "programming_faults"}, {"score": 0.004430920292612374, "phrase": "new_constructs"}, {"score": 0.004345085569121329, "phrase": "crosscutting_concerns"}, {"score": 0.004260906498835763, "phrase": "aspect_faults"}, {"score": 0.0036256123915754303, "phrase": "automated_generation"}, {"score": 0.0035902958977673313, "phrase": "aspect_tests"}, {"score": 0.0035553221885904467, "phrase": "aspect-oriented_state_models"}, {"score": 0.003503497128638099, "phrase": "structure-oriented_testing_strategy"}, {"score": 0.0034355662264234864, "phrase": "test_code"}, {"score": 0.0032554492909625653, "phrase": "state_coverage"}, {"score": 0.0032237268289353983, "phrase": "transition_coverage"}, {"score": 0.003130396338031522, "phrase": "property-oriented_testing_strategy"}, {"score": 0.0030101325901285537, "phrase": "model_checking"}, {"score": 0.0028106505443369545, "phrase": "aspect_models"}, {"score": 0.0027832502848247303, "phrase": "system_properties"}, {"score": 0.0027561164046279413, "phrase": "mutation_analysis"}, {"score": 0.0026115277372906805, "phrase": "testing_strategies"}, {"score": 0.0024264776194357993, "phrase": "comparative_evaluations"}, {"score": 0.0023677483882740317, "phrase": "structure-oriented_and_property-oriented_testing_strategies"}, {"score": 0.002254510319372956, "phrase": "structure-oriented_strategies"}, {"score": 0.0021891781017389783, "phrase": "property-oriented_strategies"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["aspect-oriented programming", " model-based testing", " finite state machines", " model checking", " coverage criteria"], "paper_abstract": "Aspect-oriented programming yields new types of programming faults due to the introduction of new constructs for dealing with crosscutting concerns. To reveal aspect faults, this paper presents a framework for testing whether or not aspect-oriented programs conform to their state models. It supports two families of strategies (i.e. structure-oriented and property-oriented) for automated generation of aspect tests from aspect-oriented state models. A structure-oriented testing strategy derives tests and test code from an aspect-oriented state model to meet a given structural coverage criterion, such as state coverage, transition coverage, or round trip. A property-oriented testing strategy generates test code from the counterexamples of model checking. Two such strategies are checking an aspect-oriented state model against trap properties and checking mutants of aspect models against system properties. Mutation analysis of aspect-oriented programs is used to evaluate the effectiveness of these testing strategies. The experiments demonstrate that testing aspect-oriented programs against their state models can detect many aspect faults. The comparative evaluations also reveal that the structure-oriented and property-oriented testing strategies complement each othersome aspect faults were detected by the structure-oriented strategies, but not by the property-oriented strategies and vice versa. Copyright (c) 2010 John Wiley & Sons, Ltd.", "paper_title": "Testing aspect-oriented programs with finite state machines", "paper_id": "WOS:000304001500004"}