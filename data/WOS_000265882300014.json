{"auto_keywords": [{"score": 0.046840734843818926, "phrase": "element_comparisons"}, {"score": 0.04380262464631336, "phrase": "priority_queue"}, {"score": 0.04274518365190484, "phrase": "worst-case_cost"}, {"score": 0.00481495049065317, "phrase": "multipartite_priority_queues"}, {"score": 0.004404994123834589, "phrase": "priority-queue_operations"}, {"score": 0.003953639783762917, "phrase": "minimum_finding"}, {"score": 0.0031845067058084583, "phrase": "binomial_queues"}, {"score": 0.002931569771634119, "phrase": "data_structure"}, {"score": 0.002548331088496964, "phrase": "immediate_application"}, {"score": 0.0024063484128685367, "phrase": "sorting_algorithm"}, {"score": 0.00227225841515826, "phrase": "inversion_measure"}, {"score": 0.0021319959284827896, "phrase": "n_elements"}], "paper_keywords": ["Priority queues", " heaps", " meticulous analysis", " constant factors"], "paper_abstract": "We introduce a framework for reducing the number of element comparisons performed in priority-queue operations. In particular, we give a priority queue which guarantees the worst-case cost of O(1) per minimum finding and insertion, and the worst-case cost of O(log n) with at most log n + O(1) element comparisons per deletion, improving the bound of 2 log n + O(1) known for binomial queues. Here, n denotes the number of elements stored in the data structure prior to the operation in question, and log n equals log(2)(max {2, n}). As an immediate application of the priority queue developed, we obtain a sorting algorithm that is optimally adaptive with respect to the inversion measure of disorder, and that sorts a sequence having n elements and I inversions with at most n log(I/n) + O(n) element comparisons.", "paper_title": "Multipartite Priority Queues", "paper_id": "WOS:000265882300014"}