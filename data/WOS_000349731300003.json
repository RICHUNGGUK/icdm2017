{"auto_keywords": [{"score": 0.04845014153646605, "phrase": "message-passing_programs"}, {"score": 0.041552086294390694, "phrase": "endpoint_sharing"}, {"score": 0.02896867592391074, "phrase": "program_logic"}, {"score": 0.00481495049065317, "phrase": "contract-obedient_channels"}, {"score": 0.00469159356595623, "phrase": "formal_verification"}, {"score": 0.004138309011478741, "phrase": "channel_endpoint"}, {"score": 0.0034953361767153285, "phrase": "communication_protocol"}, {"score": 0.002913837945508097, "phrase": "successful_reception"}, {"score": 0.0026951616152303373, "phrase": "separation_logic"}, {"score": 0.0026146109167103655, "phrase": "fine-grained_reasoning"}, {"score": 0.0025920406425973368, "phrase": "endpoint-sharing_programs"}, {"score": 0.0023974563359295043, "phrase": "operational_semantics"}, {"score": 0.0023460397258997525, "phrase": "proved_programs"}, {"score": 0.002227083991228041, "phrase": "data_races"}, {"score": 0.002207851585508636, "phrase": "memory_leaks"}, {"score": 0.002179313258573377, "phrase": "communication_errors"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Program verification", " Message passing", " Linear channels", " Separation logic"], "paper_abstract": "Recent advances in the formal verification of message-passing programs are based on proving that programs correctly implement a given protocol. Many existing verification techniques for message-passing programs assume that at most one thread may attempt to send or receive on a channel endpoint at any given point in time, and expressly forbid endpoint sharing. Approaches that do allow such sharing often do not prove that channels obey their protocols. In this paper, we identify two principles that can guarantee obedience to a communication protocol even in the presence of endpoint sharing. Firstly, threads may concurrently use an endpoint in any way that does not advance the state of the protocol. Secondly, threads may compete for receiving on an endpoint provided that the successful reception of the message grants them ownership of that endpoint retrospectively. We develop a program logic based on separation logic that unifies these principles and allows fine-grained reasoning about endpoint-sharing programs. We demonstrate its applicability on a number of examples. The program logic is shown sound against an operational semantics of programs, and proved programs are guaranteed to follow the given protocols and to be free of data races, memory leaks, and communication errors. (C) 2014 Published by Elsevier B.V.", "paper_title": "Shared contract-obedient channels", "paper_id": "WOS:000349731300003"}