{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "operation_gating"}, {"score": 0.03790784334990464, "phrase": "behavioral_synthesis"}, {"score": 0.004785356349906913, "phrase": "low-power_behavioral_synthesis"}, {"score": 0.004712160586409063, "phrase": "power_reduction"}, {"score": 0.004683195250422422, "phrase": "advanced_rtl_synthesis_tools"}, {"score": 0.00459735824483322, "phrase": "observability_don't-care_conditions"}, {"score": 0.0044853402274804815, "phrase": "systematic_approach"}, {"score": 0.004349131361255114, "phrase": "power-friendly_rtl_descriptions"}, {"score": 0.003832423454781517, "phrase": "rtl_power_optimization_techniques"}, {"score": 0.003693103542455806, "phrase": "behavior-level_observability"}, {"score": 0.0035369291417564606, "phrase": "efficient_procedure"}, {"score": 0.0034935290662899488, "phrase": "approximated_behavior-level_observability"}, {"score": 0.0034294219963679857, "phrase": "dataflow_graph"}, {"score": 0.003397809453525626, "phrase": "previous_techniques"}, {"score": 0.0033457659530207306, "phrase": "bit_level"}, {"score": 0.0033251716926666437, "phrase": "boolean_networks"}, {"score": 0.0032240802202623316, "phrase": "word_level"}, {"score": 0.003145417398038261, "phrase": "reasonable_approximation"}, {"score": 0.0030972277169783067, "phrase": "observability-masking_nature"}, {"score": 0.0030686679245324837, "phrase": "boolean_operations"}, {"score": 0.0029027394930867902, "phrase": "stronger_observability_conditions"}, {"score": 0.002814454488050123, "phrase": "non-boolean_operations"}, {"score": 0.002754253119972439, "phrase": "black_boxes"}, {"score": 0.002728847267539957, "phrase": "behavior-level_observability_condition"}, {"score": 0.002637675827548546, "phrase": "operation_scheduler"}, {"score": 0.002518227743688769, "phrase": "real-world_designs"}, {"score": 0.0024416087858984644, "phrase": "total_power"}, {"score": 0.002404175869425017, "phrase": "previous_method"}, {"score": 0.002323826502178581, "phrase": "optimal_solutions"}, {"score": 0.0022323154532645187, "phrase": "first_time_behavior-level_observability_analysis"}, {"score": 0.0021710766932077972, "phrase": "systematic_manner"}, {"score": 0.0021049977753042253, "phrase": "compiler_transformations"}], "paper_keywords": ["Algorithms", " Design", " Observability", " low power", " scheduling", " operation gating", " behavioral synthesis"], "paper_abstract": "Many techniques for power reduction in advanced RTL synthesis tools rely explicitly or implicitly on observability don't-care conditions. In this article we propose a systematic approach to maximize the effectiveness of these techniques by generating power-friendly RTL descriptions in behavioral synthesis. This is done using operation gating, that is, explicitly adding a predicate to an operation based on its observability condition, so that the operation, once identified as unobservable at runtime, can be avoided using RTL power optimization techniques such as clock gating. We first introduce the concept of behavior-level observability and its approximations in the context of behavioral synthesis. We then propose an efficient procedure to compute an approximated behavior-level observability of every operation in a dataflow graph. Unlike previous techniques which work at the bit level in Boolean networks, our method is able to perform analysis at the word level, and thus avoids most computation effort with a reasonable approximation. Our algorithm exploits the observability-masking nature of some Boolean operations, as well as the select operation, and allows certain forms of other knowledge to be considered for stronger observability conditions. The approximation is proved exact for (acyclic) dataflow graphs when non-Boolean operations other than select are treated as black boxes. The behavior-level observability condition obtained by our analysis can be used to guide the operation scheduler to optimize the efficiency of operation gating. In a set of experiments on real-world designs, our method achieves an average of 33.9% reduction in total power; it outperforms a previous method by 17.1% on average and gives close-to-optimal solutions on several designs. To the best of our knowledge, this is the first time behavior-level observability analysis and optimization are performed during behavioral synthesis in a systematic manner. We believe that our idea can be applied to compiler transformations in general.", "paper_title": "Behavior-Level Observability Analysis for Operation Gating in Low-Power Behavioral Synthesis", "paper_id": "WOS:000284931600004"}