{"auto_keywords": [{"score": 0.03786863702090832, "phrase": "tree_automata"}, {"score": 0.03255473281463336, "phrase": "red-black_trees"}, {"score": 0.025752071127151926, "phrase": "tasc"}, {"score": 0.004815658223740165, "phrase": "automata"}, {"score": 0.004674952036988355, "phrase": "tree_updates"}, {"score": 0.0045581828632009795, "phrase": "verification_framework"}, {"score": 0.004519908617935935, "phrase": "hoare-style_pre-"}, {"score": 0.004406994912939125, "phrase": "balanced_tree-like_data_structures"}, {"score": 0.004333283735537634, "phrase": "considered_verification_problem"}, {"score": 0.004189523950071494, "phrase": "standard_semi-algorithmic_approach"}, {"score": 0.004050514095922329, "phrase": "loop_invariants"}, {"score": 0.0038668462001710314, "phrase": "program_pre-"}, {"score": 0.003738502710504415, "phrase": "program_states"}, {"score": 0.0036450381529042103, "phrase": "memory_configurations"}, {"score": 0.003568932067237836, "phrase": "size_constraints"}, {"score": 0.003479692058963528, "phrase": "main_advantage"}, {"score": 0.0034359094594153304, "phrase": "new_class"}, {"score": 0.003335873298309004, "phrase": "tree_languages"}, {"score": 0.0032938942910948096, "phrase": "arithmetic_reasoning"}, {"score": 0.003104849179057156, "phrase": "avl_trees"}, {"score": 0.002735392281320413, "phrase": "interesting_theoretical_contribution"}, {"score": 0.0025137856138000014, "phrase": "tree-updating_program_statements"}, {"score": 0.002261794227418188, "phrase": "insertion_procedure"}, {"score": 0.0021408862709571615, "phrase": "arbitrary_balanced_red-black_tree"}, {"score": 0.0021049977753042253, "phrase": "balanced_red-black_tree"}], "paper_keywords": [""], "paper_abstract": "This paper describes a verification framework for Hoare-style pre- and post-conditions of programs manipulating balanced tree-like data structures. Since the considered verification problem is undecidable, we appeal to the standard semi-algorithmic approach in which the user has to provide loop invariants, which are then automatically checked, together with the program pre- and post-conditions. We specify sets of program states, representing tree-like memory configurations, using Tree Automata with Size Constraints (TASC). The main advantage of this new class of tree automata is that they recognise tree languages based on arithmetic reasoning about the lengths of various (possibly all) paths in trees, like, e.g., in AVL trees or red-black trees. TASCs are closed under union, intersection, and complement, and their emptiness problem is decidable. Thus we obtain a class of automata which are an interesting theoretical contribution by itself. Further, we show that, under few restrictions, one can automatically compute the effect of tree-updating program statements on the set of configurations represented by a TASC, which makes TASC a practical verification tool. We tried out our approach on the insertion procedure for red-black trees, for which we verified that the output on an arbitrary balanced red-black tree is also a balanced red-black tree.", "paper_title": "Automata-based verification of programs with tree updates", "paper_id": "WOS:000273586100001"}