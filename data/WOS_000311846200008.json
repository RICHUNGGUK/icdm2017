{"auto_keywords": [{"score": 0.023218160810037324, "phrase": "fps"}, {"score": 0.00481495049065317, "phrase": "task_graphs"}, {"score": 0.004769182299692333, "phrase": "execution_time"}, {"score": 0.0047013405841819025, "phrase": "effective_multicore_computing"}, {"score": 0.004612376827433774, "phrase": "efficient_usage"}, {"score": 0.004546755482549647, "phrase": "computational_resources"}, {"score": 0.004439445472040688, "phrase": "offline_mapping"}, {"score": 0.004192078165260057, "phrase": "classical_approaches"}, {"score": 0.0041522059428827345, "phrase": "considerable_a_priori_knowledge"}, {"score": 0.00409310463335204, "phrase": "target_application"}, {"score": 0.00401560412621627, "phrase": "practical_setting"}, {"score": 0.003977403701783668, "phrase": "precise_information"}, {"score": 0.003791763445590174, "phrase": "approximate_time_and_resource_usage_figures"}, {"score": 0.0036494864560524735, "phrase": "conservative_assumptions"}, {"score": 0.0035125292519354724, "phrase": "real-time_guarantees"}, {"score": 0.0033969001271637934, "phrase": "predictable_and_efficient_nonpreemptive_scheduling"}, {"score": 0.00326939082861424, "phrase": "duration_uncertainty"}, {"score": 0.0032382660477699695, "phrase": "hard_real-time_guarantees"}, {"score": 0.003176899769744057, "phrase": "limited_idle_time_insertion"}, {"score": 0.00305762327908599, "phrase": "precedence_constraint_posting"}, {"score": 0.002928765962664163, "phrase": "probability_distributions"}, {"score": 0.0025737890313763407, "phrase": "fixed_priority_scheduling"}, {"score": 0.0023388183537341213, "phrase": "pcp_schedules"}, {"score": 0.002316532084420729, "phrase": "good_stability"}, {"score": 0.0021049977753042253, "phrase": "fifo_scheduler"}], "paper_keywords": ["Scheduling", " uncertain execution and communication times", " task graph", " multicore", " precedence constraint posting", " optimization"], "paper_abstract": "Effective multicore computing requires to make efficient usage of the computational resources on a chip. Offline mapping and scheduling can be applied to improve the performance, but classical approaches require considerable a priori knowledge of the target application. In a practical setting, precise information is often unavailable; one can then resort to approximate time and resource usage figures, but this usually requires to make conservative assumptions. The issue is further stressed if real-time guarantees must be provided. We tackle predictable and efficient nonpreemptive scheduling of multitask applications in the presence of duration uncertainty. Hard real-time guarantees are provided with limited idle time insertion, by exploiting a hybrid offline/online technique known as Precedence Constraint Posting (PCP). Our approach does not require probability distributions to be specified, relying instead on simple and cheaper-to-obtain information (bounds, average values). The method has been tested on synthetic applications/platforms and compared with an offline optimized Fixed Priority Scheduling (FPS) approach and a pure online FIFO scheduler; the results are very promising, as the PCP schedules exhibit good stability and improved average execution time (14 percent on average, up to 30 percent versus FPS and up to 40 percent versus the FIFO scheduler).", "paper_title": "Robust Scheduling of Task Graphs under Execution Time Uncertainty", "paper_id": "WOS:000311846200008"}