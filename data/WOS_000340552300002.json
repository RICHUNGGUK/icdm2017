{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "minimizing_active_processor_time"}, {"score": 0.004619027561771169, "phrase": "job_j"}, {"score": 0.004555499634179394, "phrase": "integer_length"}, {"score": 0.004380188224329844, "phrase": "time_intervals"}, {"score": 0.004270347498153512, "phrase": "parameter_b"}, {"score": 0.004192190072470619, "phrase": "b_jobs"}, {"score": 0.003975333378231377, "phrase": "fewest_number"}, {"score": 0.0039570128312167545, "phrase": "active_timeslots"}, {"score": 0.0039025542443475378, "phrase": "fixed_amount"}, {"score": 0.003866663923338113, "phrase": "active_timeslot"}, {"score": 0.0033973992952939726, "phrase": "total_time"}, {"score": 0.003312121699003206, "phrase": "linear_time_algorithm"}, {"score": 0.0032589683982733545, "phrase": "unit_length"}, {"score": 0.0031918759137610523, "phrase": "single_interval"}, {"score": 0.0031333949463567554, "phrase": "sorted_order"}, {"score": 0.00311174102059922, "phrase": "general_t"}, {"score": 0.003034848746026668, "phrase": "np"}, {"score": 0.0028107659139347103, "phrase": "arbitrary_lengths"}, {"score": 0.002733843621554627, "phrase": "general_b"}, {"score": 0.002683732044181976, "phrase": "linear_programming"}, {"score": 0.0025802660239538353, "phrase": "special_graph"}, {"score": 0.002538827707857368, "phrase": "babenko_et_al"}, {"score": 0.002412865625735725, "phrase": "non-unit_length_jobs"}, {"score": 0.0023851187337905412, "phrase": "time_algorithm"}, {"score": 0.002363150587804677, "phrase": "preemptive_scheduling_problem"}, {"score": 0.0022406949011398855, "phrase": "unit_length_jobs"}, {"score": 0.002225196379204285, "phrase": "optimal_non-preemptive_schedule"}, {"score": 0.0021692780228437358, "phrase": "optimal_preemptive_schedule"}, {"score": 0.0021049977753042253, "phrase": "arbitrary_length"}], "paper_keywords": ["Algorithms", " Scheduling", " Matchings", " Active time"], "paper_abstract": "We introduce the following elementary scheduling problem. We are given a collection of n jobs, where each job J (i) has an integer length a\"\" (i) as well as a set T (i) of time intervals in which it can be feasibly scheduled. Given a parameter B, the processor can schedule up to B jobs at a timeslot t so long as it is \"active\" at t. The goal is to schedule all the jobs in the fewest number of active timeslots. The machine consumes a fixed amount of energy per active timeslot, regardless of the number of jobs scheduled in that slot (as long as the number of jobs is non-zero). In other words, subject to a\"\" (i) units of each job i being scheduled in its feasible region and at each slot at most B jobs being scheduled, we are interested in minimizing the total time during which the machine is active. We present a linear time algorithm for the case where jobs are unit length and each T (i) is a single interval, assuming that jobs are given in sorted order. For general T (i) , we show that the problem is NP-complete even for B=3. However when B=2, we show that it can be efficiently solved. In addition, we consider a version of the problem where jobs have arbitrary lengths and can be preempted at any point in time. For general B, the problem can be solved by linear programming. For B=2, the problem amounts to finding a triangle-free 2-matching on a special graph. We extend the algorithm of Babenko et al. (Proceedings of the 16th Annual International Conference on Computing and Combinatorics, pp. 120-129, 2010) to handle our variant, and also to handle non-unit length jobs. This yields an time algorithm to solve the preemptive scheduling problem for B=2, where L=a (i) a\"\" (i) . We also show that for B=2 and unit length jobs, the optimal non-preemptive schedule has active time at most 4/3 times that of the optimal preemptive schedule; this bound extends to several versions of the problem when jobs have arbitrary length.", "paper_title": "A Model for Minimizing Active Processor Time", "paper_id": "WOS:000340552300002"}