{"auto_keywords": [{"score": 0.03836998339683977, "phrase": "synquake"}, {"score": 0.00481495049065317, "phrase": "scalable_and_transparent_parallelization"}, {"score": 0.004683292152590589, "phrase": "transactional_memory_support"}, {"score": 0.004455272634364756, "phrase": "multiplayer_games"}, {"score": 0.004406121974246201, "phrase": "software_transactional_memory"}, {"score": 0.0042148594491580324, "phrase": "realistic_high_impact_application"}, {"score": 0.004099969224336647, "phrase": "stm"}, {"score": 0.00392153537973826, "phrase": "better_performance"}, {"score": 0.003814212645832246, "phrase": "state-of-the-art_lock-based_programming"}, {"score": 0.003490056936165004, "phrase": "main_data_structures"}, {"score": 0.0034324073240680213, "phrase": "essential_features"}, {"score": 0.0033757067564871494, "phrase": "popular_multiplayer_game_quake"}, {"score": 0.0032290277960438855, "phrase": "synthetic_workload_generator"}, {"score": 0.003158088307044493, "phrase": "client_game_actions"}, {"score": 0.002905629026254221, "phrase": "stm_version"}, {"score": 0.0028260302580927856, "phrase": "state-of-the-art_lock-based_parallelization"}, {"score": 0.002643753276264565, "phrase": "stm-synquake_support"}, {"score": 0.002542890176213921, "phrase": "potentially_complex_game_action"}, {"score": 0.0024323098907299027, "phrase": "bounding_box"}, {"score": 0.0023525345110929326, "phrase": "game_action"}, {"score": 0.0022880528191813083, "phrase": "lock-based_synquake"}, {"score": 0.0022129983153880467, "phrase": "higher_scalability_factor"}, {"score": 0.0021885300925245516, "phrase": "stm-synquake_versus_lock-based_synquake"}, {"score": 0.0021285340816566906, "phrase": "higher_degree"}, {"score": 0.0021049977753042253, "phrase": "false_sharing"}], "paper_keywords": ["Performance"], "paper_abstract": "This work addresses the problem of parallelizing multiplayer games using software Transactional Memory (STM) support. Using a realistic high impact application, we show that STM provides not only ease of programming, but also better performance than that achievable with state-of-the-art lock-based programming. Towards this goal, we use SynQuake, a game benchmark which extracts the main data structures and the essential features of the popular multiplayer game Quake, but can be driven with a synthetic workload generator that flexibly emulates client game actions and various hot-spot scenarios in the game world. We implement, evaluate and compare the STM version of SynQuake with a state-of-the-art lock-based parallelization of Quake, which we ported to SynQuake. While in STM-SynQuake support for maintaining the consistency of each potentially complex game action is automatic, conservative locking of surrounding objects within a bounding box for the duration of the game action is inherently needed in lock-based SynQuake. This leads to a higher scalability factor of STM-SynQuake versus lock-based SynQuake, due to a higher degree of false sharing in the latter.", "paper_title": "Towards Scalable and Transparent Parallelization of Multiplayer Games using Transactional Memory Support", "paper_id": "WOS:000280548100030"}