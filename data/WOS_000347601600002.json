{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multicore_parallelism"}, {"score": 0.049707293588616405, "phrase": "functional_programming"}, {"score": 0.044111484437312234, "phrase": "cooper's_algorithm"}, {"score": 0.04280931884725773, "phrase": "omega_test"}, {"score": 0.03739117521346518, "phrase": "parallel_implementation"}, {"score": 0.004648995193787914, "phrase": "presburger_arithmetic"}, {"score": 0.004008820473628357, "phrase": "correct-by-construction_prototype_implementations"}, {"score": 0.0037957839728524046, "phrase": "decision_procedures"}, {"score": 0.0035940277928341265, "phrase": "dag_model"}, {"score": 0.0034296217420566304, "phrase": "negative_factors"}, {"score": 0.0033502512757488433, "phrase": "garbage_collection"}, {"score": 0.0032855095476183372, "phrase": "task_creations"}, {"score": 0.0032094634756436595, "phrase": "sequential_bottlenecks"}, {"score": 0.0031845067058084613, "phrase": "severe_consequences"}, {"score": 0.0031474338010045386, "phrase": "parallel_efficiency"}, {"score": 0.0030506626796257077, "phrase": "functional_programming_language"}, {"score": 0.0027240799841720957, "phrase": "exact-shadow_part"}, {"score": 0.0026609940110902666, "phrase": "considered_procedures"}, {"score": 0.0025690867646665835, "phrase": "case_study"}, {"score": 0.002499798127196099, "phrase": "parallel_algorithms"}, {"score": 0.0024803459795996116, "phrase": "sequential_ones"}, {"score": 0.00243237365704391, "phrase": "data-intensive_tree_algorithms"}, {"score": 0.00234834406550549, "phrase": "strict_and_impure_functional_programming_language"}, {"score": 0.0022672107906933714, "phrase": "exact-shadow_elimination_procedure"}, {"score": 0.002154930852763048, "phrase": "fourier-motzkin_elimination_method"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Multicore", " Parallelism", " Functional programming", " Presburger Arithmetic", " Decision procedure"], "paper_abstract": "In this paper we investigate multicore parallelism in the context of functional programming by means of two quantifier-elimination procedures for Presburger Arithmetic: one is based on Cooper's algorithm and the other is based on the Omega Test. We first develop correct-by-construction prototype implementations in a functional programming language. Thereafter, the parallelism inherent in the decision procedures is analyzed using the Directed Acyclic Graph (DAG) model of multicore parallelism. In the step from a DAG model to a parallel implementation, the parallel implementation is optimized taking into account negative factors such as cache misses, garbage collection and overhead due to task creations, because such factors may introduce sequential bottlenecks with severe consequences for the parallel efficiency. The experiments were conducted using the functional programming language F# and .NET platform executing on an 8-core machine. A speedup of approximately 4 was obtained for Cooper's algorithm and a speedup of approximately 6 was obtained for the exact-shadow part of the Omega Test. The considered procedures are complex, memory-intense algorithms on huge formula trees and the case study reveals more general applicable techniques and guideline for deriving parallel algorithms from sequential ones in the context of data-intensive tree algorithms. The obtained insights should apply for any strict and impure functional programming language. Furthermore, the results obtained for the exact-shadow elimination procedure have a wider applicability because they can directly be transferred to the Fourier-Motzkin elimination method. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "An approach to multicore parallelism using functional programming: A case study based on Presburger Arithmetic", "paper_id": "WOS:000347601600002"}