{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "dynamic_runtime_testing"}, {"score": 0.01557276120808942, "phrase": "rapid_development"}, {"score": 0.004724365740062236, "phrase": "architectural_simulators"}, {"score": 0.0046797114400479135, "phrase": "architectural_simulator_platforms"}, {"score": 0.004635477242873163, "phrase": "particularly_complex_and_error-prone_programs"}, {"score": 0.0045052562941109734, "phrase": "hardware_details"}, {"score": 0.004337276328199398, "phrase": "stable_cycle-accurate_architectural_simulator"}, {"score": 0.004136044939878838, "phrase": "visible_errors"}, {"score": 0.004019797503157808, "phrase": "significant_effort"}, {"score": 0.0038698476651328898, "phrase": "simulator_code"}, {"score": 0.003815064377019477, "phrase": "first_place"}, {"score": 0.0036207206487324506, "phrase": "programming_errors"}, {"score": 0.0032149396890830575, "phrase": "accurate_detection"}, {"score": 0.0031845067058084583, "phrase": "functional_bugs"}, {"score": 0.003154360892955196, "phrase": "architectural_cycle-accurate_simulators"}, {"score": 0.002979367540824502, "phrase": "cycle-accurate_simulator"}, {"score": 0.002895535087931938, "phrase": "simple_and_functionally_equivalent_emulator"}, {"score": 0.0028006988338192375, "phrase": "possible_functional_error"}, {"score": 0.0025586128304269616, "phrase": "reliable_and_accurate_verification"}, {"score": 0.0023936956017015696, "phrase": "complex_setup"}, {"score": 0.002359759876402679, "phrase": "simulator_execution"}, {"score": 0.0022933216359142736, "phrase": "dynamic_testing"}, {"score": 0.0022608057001451414, "phrase": "simulator_modification_time"}, {"score": 0.0021352776064254195, "phrase": "simulator_performance"}], "paper_keywords": ["Architectural", " Simulator", " Cycle-accurate", " Simulation", " Dynamic", " Runtime", " Testing"], "paper_abstract": "Architectural simulator platforms are particularly complex and error-prone programs that aim to simulate all hardware details of a given target architecture. Development of a stable cycle-accurate architectural simulator can easily take several man-years. Discovering and fixing all visible errors in a simulator often requires significant effort, much higher than for writing the simulator code in the first place. In addition, there are no guarantees that all programming errors will be eliminated, no matter how much effort is put into testing and debugging. This paper presents dynamic runtime testing, a methodology for rapid development and accurate detection of functional bugs in architectural cycle-accurate simulators. Dynamic runtime testing consists of comparing an execution of a cycle-accurate simulator with an execution of a simple and functionally equivalent emulator. Dynamic runtime testing detects a possible functional error if there is a mismatch between the execution in the simulator and the emulator. Dynamic runtime testing provides a reliable and accurate verification of a simulator, during its entire development cycle, with very acceptable performance impact, and without requiring complex setup for the simulator execution. Based on our experience, dynamic testing reduced the simulator modification time from 12-18 person-months to only 3-4 person-months, while it only modestly reduced the simulator performance (in our case under 20 %).", "paper_title": "Using Dynamic Runtime Testing for Rapid Development of Architectural Simulators", "paper_id": "WOS:000329403900007"}