{"auto_keywords": [{"score": 0.030555976854272263, "phrase": "firesquad_algorithm"}, {"score": 0.025190315054433306, "phrase": "safe_state"}, {"score": 0.00481495049065317, "phrase": "fully_connected_network"}, {"score": 0.004507882471601552, "phrase": "arbitrary_memory_state"}, {"score": 0.0044398358177815305, "phrase": "self-stabilizing_firing_squad_problem"}, {"score": 0.004328689762198895, "phrase": "simultaneous_response"}, {"score": 0.004263336444795021, "phrase": "external_input"}, {"score": 0.004073113268289532, "phrase": "noncrashed_processes"}, {"score": 0.0039310261964323545, "phrase": "correct_process"}, {"score": 0.003871653343842317, "phrase": "external_\"go\"_input"}, {"score": 0.00351582806482809, "phrase": "firesquad"}, {"score": 0.003308085469148074, "phrase": "firing_squad_algorithm"}, {"score": 0.003034558550137019, "phrase": "smooth_transition"}, {"score": 0.0028263192354046245, "phrase": "fault-tolerance_properties"}, {"score": 0.0027000395818027366, "phrase": "arbitrary_transient_errors"}, {"score": 0.002592523232809191, "phrase": "permanent_ones"}, {"score": 0.002271725588755076, "phrase": "go_input"}, {"score": 0.0021049977753042253, "phrase": "arbitrary_state"}], "paper_keywords": ["distributed algorithms", " firing squad", " self-stabilization", " synchronous system", " common knowledge", " simultaneity"], "paper_abstract": "Consider a fully connected network where up to t processes may crash and all processes start in an arbitrary memory state. The self-stabilizing firing squad problem consists of eventually guaranteeing simultaneous response to an external input. This is modeled by requiring that the noncrashed processes \"fire\" simultaneously if some correct process received an external \"GO\" input, and that they only fire as a response to some process receiving such an input. This paper presents FIRESQUAD, the first self-stabilizing firing squad algorithm. A firing squad algorithm facilitates the use of algorithms that need to start in the same round. It allows a smooth transition between algorithms whose executions need to be disjoint. The FIRESQUAD algorithm combines two forms of fault-tolerance properties: self-stabilization to allow recovery from arbitrary transient errors and resilience to crash failures to handle permanent ones. The FIRESQUAD algorithm is optimal in two respects: (a) once the algorithm is in a safe state, it fires in response to a go input as fast as any other algorithm does, and (b) starting from an arbitrary state, it converges to a safe state as fast as any other algorithm does.", "paper_title": "AN OPTIMAL SELF-STABILIZING FIRING SQUAD", "paper_id": "WOS:000303396500006"}