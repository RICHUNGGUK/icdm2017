{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "representation_sharing"}, {"score": 0.004759406828601808, "phrase": "garbage_collector"}, {"score": 0.004698514007994158, "phrase": "memory_footprint"}, {"score": 0.004473982381245469, "phrase": "duplicate_terms"}, {"score": 0.00428629884026304, "phrase": "functional_programming_systems"}, {"score": 0.004031719751487946, "phrase": "prolog"}, {"score": 0.0038154673253945003, "phrase": "current_techniques"}, {"score": 0.0036107898615445797, "phrase": "new_contributions"}, {"score": 0.003022825806274343, "phrase": "warren_abstract_machine"}, {"score": 0.0027572166867780275, "phrase": "wam-like_prolog_implementation"}, {"score": 0.002424012799998538, "phrase": "benchmark_results"}, {"score": 0.002265833357217618, "phrase": "heap_garbage_collector"}], "paper_keywords": ["Prolog", " WAM", " memory management"], "paper_abstract": "Representation sharing can reduce the memory footprint of a program by sharing one representation between duplicate terms. The most common implementation of representation sharing in functional programming systems is known as hash-consing. In the context of Prolog, representation sharing has been given little attention. Some current techniques that deal with representation sharing are reviewed. The new contributions are (1) an easy implementation of input sharing for findall/3; and (2) a description of a sharer module that introduces representation sharing at runtime. Their realization is shown in the context of the Warren Abstract Machine (WAM) as implemented by hProlog. Both can be adapted to any WAM-like Prolog implementation. The sharer works independently of the garbage collector, but it can be made to cooperate with the garbage collector. Benchmark results show that the sharer has a cost comparable to the heap garbage collector, that its effectiveness is highly application-dependent, and that its policy must be tuned to the collector.", "paper_title": "Representation sharing for Prolog", "paper_id": "WOS:000313293200003"}