{"auto_keywords": [{"score": 0.027704624149933656, "phrase": "iap"}, {"score": 0.00481495049065317, "phrase": "goal-level_independent"}, {"score": 0.004542158659382197, "phrase": "simultaneous_execution"}, {"score": 0.004284755353695709, "phrase": "run_time"}, {"score": 0.004041879818641576, "phrase": "multiple_answers"}, {"score": 0.0034423989472667756, "phrase": "parallel_goals"}, {"score": 0.0032471155306148156, "phrase": "backtracking_limits_parallelism"}, {"score": 0.0031536550157613974, "phrase": "expected_simplification"}, {"score": 0.0030628762739398855, "phrase": "classic_schemes"}, {"score": 0.0029892206557359836, "phrase": "complex_engineering"}, {"score": 0.002931569771634119, "phrase": "consequent_difficulty"}, {"score": 0.002903161412792026, "phrase": "system_maintenance"}, {"score": 0.0027651847105654363, "phrase": "well-known_trapped_goal"}, {"score": 0.0026337482179592422, "phrase": "alternative_parallel_backtracking_model"}, {"score": 0.002297949552105756, "phrase": "significant_performance_advantages"}, {"score": 0.0021780349459687622, "phrase": "important_engineering_task"}, {"score": 0.002125612498781805, "phrase": "backtracking_mechanism"}, {"score": 0.0021049977753042253, "phrase": "previous_approaches"}], "paper_keywords": ["parallelism", " logic programming", " memoization", " backtracking", " performance"], "paper_abstract": "Goal-level Independent and-parallelism (IAP) is exploited by scheduling for simultaneous execution of two or more goals, which will not interfere with each other at run time. This can be done safely even if such goals can produce multiple answers. The most successful IAP implementations to date have used recomputation of answers and sequentially ordered backtracking. While in principle simplifying the implementation, recomputation can be very inefficient if the granularity of the parallel goals is large enough and they produce several answers, while sequentially ordered backtracking limits parallelism. And, despite the expected simplification, the implementation of the classic schemes has proved to involve complex engineering, with the consequent difficulty for system maintenance and extension, while still frequently running into the well-known trapped goal and garbage slot problems. This work presents an alternative parallel backtracking model for IAP and its implementation. The model features parallel out-of-order (i.e., nonchronological) backtracking and relies on answer memoization to reuse and combine answers. We show that this approach can bring significant performance advantages. Also, it can bring some simplification to the important engineering task involved in implementing the backtracking mechanism of previous approaches.", "paper_title": "Parallel backtracking with answer memoing for independent and-parallelism", "paper_id": "WOS:000292701100009"}