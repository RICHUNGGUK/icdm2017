{"auto_keywords": [{"score": 0.00481725769111103, "phrase": "proofs"}, {"score": 0.004506048850130758, "phrase": "source_integrity_constraints"}, {"score": 0.004216880725292, "phrase": "integrity_constraints"}, {"score": 0.004027586827290042, "phrase": "direct_access"}, {"score": 0.003807684498435389, "phrase": "different_kinds"}, {"score": 0.003636692152882991, "phrase": "relational_operators"}, {"score": 0.003351381374975648, "phrase": "semantic_property"}, {"score": 0.0031360786664165093, "phrase": "key_idea"}, {"score": 0.002831462722290752, "phrase": "corresponding_semantic_property"}, {"score": 0.002441422510910065, "phrase": "desired_type"}, {"score": 0.0022382002476510573, "phrase": "single_plan"}, {"score": 0.002137537770621167, "phrase": "alternative_proofs"}, {"score": 0.0021049977753042253, "phrase": "lower-cost_plans"}], "paper_keywords": ["Theory", " Languages", " Access methods", " optimization", " hidden web"], "paper_abstract": "We present algorithms for answering queries making use of information about source integrity constraints, access restrictions, and access costs. Our method can exploit the integrity constraints to find plans even when there is no direct access to relations appearing in the query. We look at different kinds of plans, depending on the kind of relational operators that are permitted within their commands. To each type of plan, we associate a semantic property that is necessary for having a plan of that type. The key idea of our method is to move from a search for a plan to a search for a proof of the corresponding semantic property, and then generate a plan from a proof. We provide algorithms for converting proofs to plans and show that they will find a plan of the desired type whenever such a plan exists. We show that while discovery of one proof allows us to find a single plan that answers the query, we can explore alternative proofs to find lower-cost plans.", "paper_title": "Generating Plans from Proofs", "paper_id": "WOS:000371198500002"}