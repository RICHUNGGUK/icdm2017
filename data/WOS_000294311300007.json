{"auto_keywords": [{"score": 0.04177064964099934, "phrase": "spinnaker"}, {"score": 0.038949231696870396, "phrase": "boot_process"}, {"score": 0.00481495049065317, "phrase": "neural_network_cmp_system"}, {"score": 0.004769616966550469, "phrase": "homogeneous_interconnect_fabric"}, {"score": 0.00470983237900705, "phrase": "million-core_parallel_system"}, {"score": 0.004621551111118693, "phrase": "difficult_process"}, {"score": 0.00452063603944825, "phrase": "hardware_support"}, {"score": 0.004478061063857035, "phrase": "configuration_process"}, {"score": 0.004435885269134359, "phrase": "pre-configured_default_state"}, {"score": 0.004366469287481091, "phrase": "operating_condition"}, {"score": 0.0041515244239033145, "phrase": "neural_network_simulation"}, {"score": 0.004009894739765119, "phrase": "universal_neural_chip"}, {"score": 0.003947118540355604, "phrase": "event-driven_model"}, {"score": 0.003922283019437895, "phrase": "complete_system_virtualisation"}, {"score": 0.0037527389293924907, "phrase": "sideband_network"}, {"score": 0.0036476222647061243, "phrase": "single_homogeneous_network_interconnect"}, {"score": 0.0036132394176383582, "phrase": "application_inter-processor_communications"}, {"score": 0.0035120164504478437, "phrase": "fault_tolerance"}, {"score": 0.0034352452951903305, "phrase": "dynamic_run-time_reconfiguration"}, {"score": 0.003317970131738248, "phrase": "application's_communications_model"}, {"score": 0.0031148723927633955, "phrase": "working_configuration"}, {"score": 0.0030660649234990284, "phrase": "event-driven_asynchronous_communications"}, {"score": 0.002999012736727594, "phrase": "purely_local_control"}, {"score": 0.0029520153163594435, "phrase": "global_synchronisation"}, {"score": 0.002933422608537915, "phrase": "state_information"}, {"score": 0.002905752244360772, "phrase": "transition_sequence"}, {"score": 0.002878342135479895, "phrase": "novel_two-stage"}, {"score": 0.0028511898481970595, "phrase": "\"_boot-up_process"}, {"score": 0.002815383690003621, "phrase": "spinnaker_hardware"}, {"score": 0.002753798541636975, "phrase": "highspeed_flood-fill_technique"}, {"score": 0.002719212119462965, "phrase": "run-time_reconfiguration"}, {"score": 0.0026681430839293574, "phrase": "multi-cmp_spinnaker_system"}, {"score": 0.00264296841319955, "phrase": "error-free_cmp_configuration_time"}, {"score": 0.002568856989650261, "phrase": "high-level_simulation"}, {"score": 0.002544616720630384, "phrase": "full-scale_system"}, {"score": 0.002481085648977413, "phrase": "mean_application-loading_time"}, {"score": 0.002292571801358424, "phrase": "cycle-accurate_functionality"}, {"score": 0.0022494973475924024, "phrase": "complete_process"}, {"score": 0.002228263890334039, "phrase": "useful_method"}, {"score": 0.0022072304165576405, "phrase": "large-scale_event-driven_parallel_systems"}, {"score": 0.0021726139494880653, "phrase": "dedicated_hardware_boot_support"}, {"score": 0.0021453112313233554, "phrase": "system_state_assumptions"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Chip multiprocessor", " Configuration", " Asynchronous", " Boot", " Neural", " Network"], "paper_abstract": "Configuring a million-core parallel system at boot time is a difficult process when the system has neither specialised hardware support for the configuration process nor a pre-configured default state that puts it in operating condition. The architecture of SpiNNaker, a parallel chip multiprocessor (CMP) system for neural network simulation, is in this class. To function as a universal neural chip. SpiNNaker uses an event-driven model with complete system virtualisation so that all components are generic and identical. Where most large CMP systems feature a sideband network to complete the boot process, SpiNNaker has a single homogeneous network interconnect for both application inter-processor communications and system control functions. This network improves fault tolerance and makes it easier to support dynamic run-time reconfiguration, however, it requires a boot process compatible with the application's communications model. Here, we present such a boot loader, capable of bringing a generic, initially unconfigured parallel system into a working configuration. Since SpiNNaker uses event-driven asynchronous communications throughout, the loader operates with purely local control: there is no global synchronisation, state information, or transition sequence. A novel two-stage \"unfolding\" boot-up process efficiently configures the SpiNNaker hardware and loads the application using a highspeed flood-fill technique with support for run-time reconfiguration. SystemC simulation of a multi-CMP SpiNNaker system indicates an error-free CMP configuration time of similar to 1.37 ms, while a high-level simulation of a full-scale system (64 K CMPs) indicates a mean application-loading time of similar to 20 ms (for a 100 KB application), which is virtually independent of the size of the system. Further hardware-level Verilog simulation verified the cycle-accurate functionality of CMP configuration. The complete process illustrates a useful method for configuring large-scale event-driven parallel systems without having to provide dedicated hardware boot support or rely on system state assumptions. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Event-driven configuration of a neural network CMP system over an homogeneous interconnect fabric", "paper_id": "WOS:000294311300007"}