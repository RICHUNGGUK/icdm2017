{"auto_keywords": [{"score": 0.03580806098011901, "phrase": "bit-width_restrictions"}, {"score": 0.00481495049065317, "phrase": "instruction_bit-width"}, {"score": 0.004778594263962987, "phrase": "low-power_vliw_architectures"}, {"score": 0.004618342952383313, "phrase": "embedded_applications"}, {"score": 0.004583464412234181, "phrase": "abundant_instruction_level_parallelism"}, {"score": 0.004480394224548146, "phrase": "long_instruction_bus_width"}, {"score": 0.004379631619412168, "phrase": "memory_space"}, {"score": 0.004168986485488861, "phrase": "reduced_bit-width_instruction_set_architecture"}, {"score": 0.004059772950454586, "phrase": "narrower_instruction_word_length"}, {"score": 0.0038498211283780484, "phrase": "bus-bandwidth_requirements"}, {"score": 0.0038062581748678245, "phrase": "power_dissipation"}, {"score": 0.003501452436803395, "phrase": "equivalent_reduced_bit-width"}, {"score": 0.003448705829033573, "phrase": "narrow_instruction_word"}, {"score": 0.0032702516771609957, "phrase": "original_isa."}, {"score": 0.0032332256013507072, "phrase": "existing_processors"}, {"score": 0.0032087739900195232, "phrase": "narrow_instructions"}, {"score": 0.0031484483754909026, "phrase": "severe_restrictions"}, {"score": 0.0031246358910995316, "phrase": "register_accessibility"}, {"score": 0.0029741713977710495, "phrase": "complete_conversion"}, {"score": 0.002929344511491418, "phrase": "case_study"}, {"score": 0.00265394824073552, "phrase": "effective_instruction_word_length"}, {"score": 0.0025069746344846397, "phrase": "synergy_effect"}, {"score": 0.002305974875400655, "phrase": "code_size"}, {"score": 0.0021948455916770233, "phrase": "slight_run_time_cost"}, {"score": 0.0021049977753042253, "phrase": "original_machine"}], "paper_keywords": ["Design", " Algorithms", " Performance", " VLIW architecture", " reduced bit-width ISA", " code generation", " power consumption", " code size"], "paper_abstract": "VLIW (very long instruction word) architectures have proven to be useful for embedded applications with abundant instruction level parallelism. But due to the long instruction bus width it often consumes more power and memory space than necessary. One way to lessen this problem is to adopt a reduced bit-width instruction set architecture (ISA) that has a narrower instruction word length. This facilitates a more efficient hardware implementation in terms of area and power by decreasing bus-bandwidth requirements and the power dissipation associated with instruction fetches. In practice, however, it is impossible to convert a given ISA fully into an equivalent reduced bit-width one because the narrow instruction word, due to bit-width restrictions, can encode only a small subset of normal instructions in the original ISA. Consequently, existing processors provide narrow instructions in very limited cases along with severe restrictions on register accessibility. The objective of this work is to explore the possibility of complete conversion, as a case study, of an existing 32-bit VLIW ISA into a 16-bit one that supports effectively all 32-bit instructions. To this objective, we attempt to circumvent the bit-width restrictions by dynamically extending the effective instruction word length of the converted 16-bit operations. Further, we will show that our proposed ISA conversion can create a synergy effect with a VLES (variable length execution set) architecture that is adopted in most recent VLIW processors. According to our experiment, the code size becomes significantly smaller after the conversion to 16-bit VLIW code. Also at a slight run time cost, the machine with the 16-bit ISA consumes much less energy than the original machine.", "paper_title": "Reducing Instruction Bit-Width for Low-Power VLIW Architectures", "paper_id": "WOS:000317427700009"}