{"auto_keywords": [{"score": 0.03286917812756054, "phrase": "fitness_improvement"}, {"score": 0.00481495049065317, "phrase": "code_growth"}, {"score": 0.004739056045644449, "phrase": "tree-based_genetic_programming"}, {"score": 0.004518442937844318, "phrase": "evolutionary_optimization_method"}, {"score": 0.004342430078306461, "phrase": "program_induction"}, {"score": 0.004273951631010383, "phrase": "genetic_programming"}, {"score": 0.004173244935967375, "phrase": "variable-length_tree_structures"}, {"score": 0.003947358102140903, "phrase": "serious_problem"}, {"score": 0.003885085477351673, "phrase": "variable-length_representations"}, {"score": 0.0036456298076415652, "phrase": "tree_structures"}, {"score": 0.0034208822062692127, "phrase": "corresponding_increase"}, {"score": 0.0032099453192629976, "phrase": "size_reduction"}, {"score": 0.0028944757265206332, "phrase": "\"optimization\"_method"}, {"score": 0.002694375425481759, "phrase": "semantically_driven_local_search_operator"}, {"score": 0.002548331088496964, "phrase": "best_fitness"}, {"score": 0.002508073621696602, "phrase": "five_examples"}, {"score": 0.002316105585203396, "phrase": "obtained_size_reduction"}, {"score": 0.002190519728921395, "phrase": "local_search_operator"}, {"score": 0.0021049980887993046, "phrase": "tarpeian"}], "paper_keywords": ["Tree traversal", " Subtree fitness", " Code growth", " Local optimization", " Tree-based genetic programming"], "paper_abstract": "Genetic programming is an evolutionary optimization method following the principle of program induction. Genetic programming often uses variable-length tree structures for representing candidate solutions. A serious problem with variable-length representations is code growth: during evolution these tree structures tend to grow in size without a corresponding increase in fitness. Many anti-bloat methods focus solely on size reduction and forget about fitness improvement, which is rather strange when using an \"optimization\" method. This paper reports the application of a semantically driven local search operator to control code growth and improve best fitness. Five examples, two theoretical benchmark applications and three real-life test problems are used to illustrate the obtained size reduction and fitness improvement. Performance of the local search operator is also compared with various other anti-bloat methods such as size and depth delimiters, an expression simplifier, linear and adaptive parsimony pressure, automatically defined functions and Tarpeian bloat control.", "paper_title": "Efficient tree traversal to reduce code growth in tree-based genetic programming", "paper_id": "WOS:000262434800004"}