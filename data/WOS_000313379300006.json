{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "job-shop_scheduling_problem"}, {"score": 0.008439472063587174, "phrase": "feasible_solutions"}, {"score": 0.006521084509162226, "phrase": "complexity_analysis"}, {"score": 0.004724708238414131, "phrase": "scheduling_problems"}, {"score": 0.00469500313566324, "phrase": "substantial_attention"}, {"score": 0.004650793657308996, "phrase": "last_decennia"}, {"score": 0.0046069985410261746, "phrase": "job-shop_problem"}, {"score": 0.004507011270684075, "phrase": "np"}, {"score": 0.004435885269134359, "phrase": "strong_sense"}, {"score": 0.00439410494607959, "phrase": "well-known_benchmark_instances"}, {"score": 0.004284596323560538, "phrase": "practical_difficulty"}, {"score": 0.004099455381916337, "phrase": "exact_algorithms"}, {"score": 0.00389760315371842, "phrase": "lower_complexity"}, {"score": 0.0038608730929994696, "phrase": "exhaustive_enumeration"}, {"score": 0.003717368939083015, "phrase": "well-known_bellman_equation"}, {"score": 0.0036591647504372175, "phrase": "karp"}, {"score": 0.0036246643358397272, "phrase": "optimal_sequences"}, {"score": 0.0035678974387440914, "phrase": "best_complexity"}, {"score": 0.0035231224373946457, "phrase": "traveling_salesman_problem"}, {"score": 0.0034352706696076673, "phrase": "tsp"}, {"score": 0.0032046857274089747, "phrase": "similar_results"}, {"score": 0.0029241700853970013, "phrase": "resulting_algorithm"}, {"score": 0.0028332303659245085, "phrase": "brute_force"}, {"score": 0.002473256335879102, "phrase": "benchmark_instances"}, {"score": 0.0023290951071300433, "phrase": "potential_practical_implications"}, {"score": 0.0022494973475924024, "phrase": "theoretical_ones"}, {"score": 0.0021933182759089364, "phrase": "celebrated_benchmark_instances"}, {"score": 0.002179493631738601, "phrase": "processing_times"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Job-shop scheduling", " Dynamic programming", " Complexity analysis"], "paper_abstract": "Scheduling problems received substantial attention during the last decennia. The job-shop problem is a very important scheduling problem, which is NP-hard in the strong sense and with well-known benchmark instances of relatively small size which attest the practical difficulty in solving it. The literature on the job-shop scheduling problem includes several approximation and exact algorithms. So far, no algorithm is known which solves the job-shop scheduling problem optimally with a lower complexity than the exhaustive enumeration of all feasible solutions. We propose such an algorithm, based on the well-known Bellman equation designed by Held and Karp to find optimal sequences and which offers the best complexity to solve the Traveling Salesman Problem known to this date. For the TSP this means O(n(2)2(n)) which is exponentially better than O(n!) required to evaluate all feasible solutions. We reach similar results by first recovering the principle of optimality, which is not obtained for free in the case of the job-shop scheduling problem, and by performing a complexity analysis of the resulting algorithm. Our analysis is conservative but nevertheless exponentially better than brute force. We also show very promising results obtained from our implementation of this algorithm, which seem to indicate two things: firstly that there is room for improvement in the complexity analysis (we observe the generation of a number of solutions per state for the benchmark instances considered which is orders of magnitude lower than the bound we could devise) and secondly that the potential practical implications of this approach are at least as exciting as the theoretical ones, since we manage to solve some celebrated benchmark instances in processing times ranging from seconds to minutes. (C) 2012 Elsevier Ltd. All rights reserved.", "paper_title": "Solving the job-shop scheduling problem optimally by dynamic programming", "paper_id": "WOS:000313379300006"}