{"auto_keywords": [{"score": 0.04962656673317322, "phrase": "systemc"}, {"score": 0.00481495049065317, "phrase": "core-based_embedded_systems"}, {"score": 0.0046797114400479135, "phrase": "reference_language"}, {"score": 0.004635477242873163, "phrase": "hardware_description"}, {"score": 0.00459165923324494, "phrase": "eda_community"}, {"score": 0.0037969755088553326, "phrase": "extension_module"}, {"score": 0.0037432199549135826, "phrase": "existing_system"}, {"score": 0.003603549914861701, "phrase": "actual_system_implementation"}, {"score": 0.003355515315708125, "phrase": "cpu-independent_device"}, {"score": 0.003261133560558666, "phrase": "different_processors"}, {"score": 0.0031393948330209255, "phrase": "different_techniques"}, {"score": 0.0030656196752517836, "phrase": "development_environment"}, {"score": 0.0026452734009203764, "phrase": "cpu-centered_design"}, {"score": 0.00258307991054107, "phrase": "different_abstraction_levels"}, {"score": 0.0022608057001451414, "phrase": "software_portion"}, {"score": 0.0021049977753042253, "phrase": "required_modularity"}], "paper_keywords": ["co-simulation", " embedded system", " rapid prototyping"], "paper_abstract": "SystemC is becoming the reference language for hardware description in EDA community. It is suitable for describing hardware at several abstraction levels, and it can be used to develop devices for programmable, CPU-based, systems. In such a context, there are several requirements to meet. The hardware under development can be an extension module for an existing system, possibly with no knowledge on the actual system implementation. At the same time, the module to develop can be minded as a CPU-independent device that should be evaluated against different processors. Hence, the developer should leverage different techniques, depending on the development environment involved. We present a framework that allows to co-simulate the hardware under development and the software, in a system extending context as well as in a CPU-centered design. Such a framework can use different abstraction levels for the hardware, thus allowing to meet the best accuracy/performance tradeoffs. Moreover, when required, the CPU can be replaced on the fly, keeping the software portion just marginally changed (or not modified at all), then realizing the required modularity of the design.", "paper_title": "SystemC co-simulation for core-based embedded systems", "paper_id": "WOS:000249298400003"}