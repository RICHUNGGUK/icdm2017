{"auto_keywords": [{"score": 0.04968510255692421, "phrase": "flow_logic"}, {"score": 0.007540019397661224, "phrase": "electronic_supplements"}, {"score": 0.00481495049065317, "phrase": "flow_logic_for_process_calculi"}, {"score": 0.004396600680348434, "phrase": "abstract_interpretation"}, {"score": 0.004360412703519539, "phrase": "data_flow_analysis"}, {"score": 0.004324521292490181, "phrase": "constraint_based_analysis"}, {"score": 0.004132312946154097, "phrase": "type_systems"}, {"score": 0.004047781270412204, "phrase": "programming_languages"}, {"score": 0.003948613642680196, "phrase": "tutorial_development"}, {"score": 0.003835972725191194, "phrase": "process_calculi"}, {"score": 0.0036653985479652854, "phrase": "simple_analysis"}, {"score": 0.0034024277222012597, "phrase": "subject_reduction"}, {"score": 0.0033743949483348626, "phrase": "adequacy_results"}, {"score": 0.0032242793143795454, "phrase": "least_solution"}, {"score": 0.002931569771634119, "phrase": "analysis_technology"}, {"score": 0.0028953973490895746, "phrase": "reachability_components"}, {"score": 0.0028715299874549245, "phrase": "interaction_points"}, {"score": 0.0028360962841331634, "phrase": "localized_environments"}, {"score": 0.0027211030647461324, "phrase": "relational_analysis"}, {"score": 0.0026543514413663893, "phrase": "program_logic"}, {"score": 0.0025785359740308337, "phrase": "hoare's_logic"}, {"score": 0.002504880563070155, "phrase": "executive_summary"}, {"score": 0.002363806685815014, "phrase": "theoretical_properties"}, {"score": 0.0023249757987087055, "phrase": "implementation_considerations"}, {"score": 0.0022399174232611853, "phrase": "analysis_techniques"}, {"score": 0.0021490449563443025, "phrase": "code_mobility"}, {"score": 0.00213131678182067, "phrase": "also_the_proofs"}, {"score": 0.0021049977753042253, "phrase": "main_results"}], "paper_keywords": ["Algorithms", " Design", " Documentation", " Languages", " Reliability", " Theory", " Verification", " Static analysis", " flow logic", " process calculi", " Moore family", " subject reduction", " adequacy"], "paper_abstract": "Flow Logic is an approach to statically determining the behavior of programs and processes. It borrows methods and techniques from Abstract Interpretation, Data Flow Analysis and Constraint Based Analysis while presenting the analysis in a style more reminiscent of Type Systems. Traditionally developed for programming languages, this article provides a tutorial development of the approach of Flow Logic for process calculi based on a decade of research. We first develop a simple analysis for the pi-calculus; this consists of the specification, semantic soundness (in the form of subject reduction and adequacy results), and a Moore Family result showing that a least solution always exists, as well as providing insights on how to implement the analysis. We then show how to strengthen the analysis technology by introducing reachability components, interaction points, and localized environments, and finally, we extend it to a relational analysis. A Flow Logic is a program logic-in the same sense that a Hoare's logic is. We conclude with an executive summary presenting the highlights of the approach from this perspective including a discussion of theoretical properties as well as implementation considerations. The electronic supplements present an application of the analysis techniques to a version of the pi-calculus incorporating distribution and code mobility; also the proofs of the main results can be found in the electronic supplements.", "paper_title": "Flow Logic for Process Calculi", "paper_id": "WOS:000300322300003"}