{"auto_keywords": [{"score": 0.027982418923305122, "phrase": "faithful_implementation"}, {"score": 0.00481495049065317, "phrase": "hybrid-systems_models"}, {"score": 0.004770211811866158, "phrase": "hybrid_systems"}, {"score": 0.00466016686289196, "phrase": "appropriate_formalism"}, {"score": 0.004595356579614969, "phrase": "embedded_systems"}, {"score": 0.004447600571127578, "phrase": "continuous_dynamics"}, {"score": 0.004406260054779782, "phrase": "discrete_control"}, {"score": 0.00428451995524549, "phrase": "distributed_embedded_systems"}, {"score": 0.004108161406159407, "phrase": "hybrid_automata"}, {"score": 0.004032118497047498, "phrase": "code_generation"}, {"score": 0.00379452936798156, "phrase": "formal_guarantees"}, {"score": 0.003741712498615481, "phrase": "generated_code"}, {"score": 0.0034884152484429207, "phrase": "hard_problem"}, {"score": 0.0033603864623013733, "phrase": "continuous_time"}, {"score": 0.003329117824699891, "phrase": "concurrent_execution"}, {"score": 0.00329813918116714, "phrase": "instantaneous_switching"}, {"score": 0.0031919592786945126, "phrase": "inherently_discrete_platform"}, {"score": 0.0030891871245908665, "phrase": "sampling_interval"}, {"score": 0.0030604342671868836, "phrase": "round-off_errors"}, {"score": 0.0030178044717552605, "phrase": "communication_delays"}, {"score": 0.002853124436286834, "phrase": "semantic_differences"}, {"score": 0.002735522834514124, "phrase": "potentially_different_system_behavior"}, {"score": 0.002598333022293788, "phrase": "hybrid-systems_model"}, {"score": 0.0024912073108138613, "phrase": "different_techniques"}, {"score": 0.002289993730291138, "phrase": "model_heater_system"}, {"score": 0.0022475295254231714, "phrase": "heater_case_study"}, {"score": 0.002185301851004467, "phrase": "fault_transitions"}, {"score": 0.0021049977753042253, "phrase": "correct_behavior"}], "paper_keywords": ["Formal languages", " software engineering"], "paper_abstract": "Hybrid systems have emerged as an appropriate formalism to model embedded systems as they capture the theme of continuous dynamics with discrete control. Under this paradigm, distributed embedded systems can be modeled as a network of communicating hybrid automata. Several techniques for code generation from these models have also been proposed and commercially implemented. Providing formal guarantees of the generated code with respect to the model, however, has turned out to be a hard problem. While the model is set in continuous time with concurrent execution and instantaneous switching, the code running on an inherently discrete platform, can be affected by the sampling interval, round-off errors, and communication delays between the sensor, controller, and actuators. Consequently, semantic differences between the model and its code can arise with potentially different system behavior. This paper proposes a criterion for faithful implementation of the hybrid-systems model with a focus on its switching semantics. We discuss different techniques to ensure a faithful implementation of the model, and test the feasibility of our concepts by implementing a model heater system. In this heater case study, we successfully eliminate all fault transitions and, thereby, generate code with correct behavior complying with the specification.", "paper_title": "Generating Reliable Code from Hybrid-Systems Models", "paper_id": "WOS:000280134600011"}