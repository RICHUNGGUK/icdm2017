{"auto_keywords": [{"score": 0.04005626467701364, "phrase": "composed_service"}, {"score": 0.021121326037795565, "phrase": "uddi_registry"}, {"score": 0.010100912918628737, "phrase": "service_selection"}, {"score": 0.00939132595301473, "phrase": "qos_calculator"}, {"score": 0.008484564655427232, "phrase": "component_services"}, {"score": 0.00794953277191779, "phrase": "qos_parameters"}, {"score": 0.00672758606574331, "phrase": "esga"}, {"score": 0.00481495049065317, "phrase": "improved_initial_population_selection_strategy"}, {"score": 0.0046176782475198085, "phrase": "important_criterion"}, {"score": 0.004522080178250592, "phrase": "uddi_process"}, {"score": 0.004498490110526062, "phrase": "qos_extension"}, {"score": 0.004463334513749285, "phrase": "quality_requests"}, {"score": 0.004440049534195442, "phrase": "service_providers"}, {"score": 0.004405348628112645, "phrase": "functional_and_qos_information"}, {"score": 0.004224786847720058, "phrase": "qos_value"}, {"score": 0.0041481266398007074, "phrase": "optimal_service"}, {"score": 0.0040094142308666975, "phrase": "requestor's_feedback"}, {"score": 0.0038651944848734133, "phrase": "service_composition"}, {"score": 0.003785115566529808, "phrase": "local_and_global_restrictions"}, {"score": 0.003629882559085245, "phrase": "aggregation_rule"}, {"score": 0.003480993634130542, "phrase": "multi-objective_optimization"}, {"score": 0.0033999344623871735, "phrase": "path_formation"}, {"score": 0.003320756562046789, "phrase": "service_class"}, {"score": 0.0032947744638635148, "phrase": "genetic_algorithm"}, {"score": 0.003243416560986838, "phrase": "complicated_global_optimization_problems"}, {"score": 0.0031845067058084583, "phrase": "simplex_genetic_algorithm"}, {"score": 0.0031430823944465177, "phrase": "optimal_global_solution"}, {"score": 0.003118486096035156, "phrase": "elitist_selection_genetic_algorithm"}, {"score": 0.002982688100421823, "phrase": "integer_encoding"}, {"score": 0.0029593432468318745, "phrase": "encoding_rule"}, {"score": 0.002815665199416027, "phrase": "service_number"}, {"score": 0.0027645030021576926, "phrase": "initial_population_selection_strategy"}, {"score": 0.0027356847952125433, "phrase": "random_initial_population_creation_method"}, {"score": 0.0026579702194790174, "phrase": "new_composed_service"}, {"score": 0.0026233771102489394, "phrase": "average_fitness"}, {"score": 0.0026028371642126285, "phrase": "selected_composed_services"}, {"score": 0.002431411689381161, "phrase": "fitness_function"}, {"score": 0.002412371116984224, "phrase": "weighted_sum"}, {"score": 0.002362320344521919, "phrase": "genetic_operation"}, {"score": 0.002343819560536301, "phrase": "penalty_function"}, {"score": 0.0022241213593294164, "phrase": "roulette_wheel_selection_method"}, {"score": 0.0021552506195781852, "phrase": "genetic_operators"}, {"score": 0.0021049977753042253, "phrase": "better_performance"}], "paper_keywords": [""], "paper_abstract": "With more and more web services being applied, the quality of service (QoS) becomes an important criterion in a service selection. We propose a UDDI process with QoS extension to support quality requests. Service providers can send functional and QoS information to the UDDI registry. As a component of the UDDI registry, the QoS calculator calculates the QoS value of each service to decide the optimal service and send the information back to the UDDI registry. After receiving the requestor's feedback, the QoS calculator re-calculates QoS of the service. In a service composition, component services and the composed service should satisfy local and global restrictions respectively. The QoS of component services aggregate to QoS of the composed service according to an aggregation rule. The QoS parameters may conflict with each other, so this problem is actually a multi-objective optimization. A service selection can be seen as a path formation and each node of the path is a service class. A genetic algorithm can be used to solve complicated global optimization problems. It is proved that a simplex genetic algorithm cannot converge to optimal global solution but the elitist selection genetic algorithm (ESGA) can. So we use ESGA to solve this problem. We use integer encoding as the encoding rule. A composed service can be seen as a chromosome and a gene is an integer that represents a service number in its service class. We use an initial population selection strategy instead of the random initial population creation method. In the strategy, if the fitness of a new composed service is worse than the average fitness of the selected composed services, it should be abandoned, otherwise it should be kept. We coordinate these objectives by assigning a weight to each parameter and the fitness function is the weighted sum of QoS parameters. In the stage of genetic operation, the penalty function is subtracted from the fitness of the composed service if it does not satisfy the restrictions. We use the roulette wheel selection method, single point crossover operator, and uniform mutation operator as genetic operators. It is shown that this method has better performance than the method using ESGA through an experiment.", "paper_title": "A QoS Driven Web Service Composition Method Based on ESGA (Elitist Selection Genetic Algorithm) with an Improved Initial Population Selection Strategy", "paper_id": "WOS:000265103800053"}