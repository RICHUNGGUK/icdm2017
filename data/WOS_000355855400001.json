{"auto_keywords": [{"score": 0.046232683509134974, "phrase": "fortran"}, {"score": 0.004814951205774009, "phrase": "coarrays"}, {"score": 0.004770461993586338, "phrase": "parallelize_legacy_fortran_applications"}, {"score": 0.004073809704022463, "phrase": "oo_programming"}, {"score": 0.003907013105134715, "phrase": "extensible_suite"}, {"score": 0.0038708810091769856, "phrase": "model-verification_and_performance_tests"}, {"score": 0.003764469758319617, "phrase": "coarray_parallel_programming"}, {"score": 0.003712362078915926, "phrase": "rapid_evolution"}, {"score": 0.0036609730219354796, "phrase": "serial_application"}, {"score": 0.003610292749660581, "phrase": "parallel_application"}, {"score": 0.0035273744062641636, "phrase": "multicore_processors"}, {"score": 0.0034947408949397127, "phrase": "many-core_accelerators"}, {"score": 0.0034624082435775676, "phrase": "shared_and_distributed_memory"}, {"score": 0.0032292292848296617, "phrase": "resulting_performance"}, {"score": 0.003125835572347772, "phrase": "intel_fortran_compiler"}, {"score": 0.0030117065110966414, "phrase": "scaling_behavior"}, {"score": 0.0029288446848334576, "phrase": "profile_analysis"}, {"score": 0.002902592298670166, "phrase": "tau"}, {"score": 0.0025832180231667853, "phrase": "nearly_linear_speedup"}, {"score": 0.0025355968118803956, "phrase": "sequential_summation"}, {"score": 0.002431626477893495, "phrase": "cray_compiler"}, {"score": 0.002364715199803207, "phrase": "intel"}, {"score": 0.002331909406363425, "phrase": "collective_reductions"}, {"score": 0.0022995902068489557, "phrase": "cray"}, {"score": 0.0022467024793003812, "phrase": "linear_speedup"}, {"score": 0.0022155569675462333, "phrase": "distributed-memory_execution"}, {"score": 0.0021746987512551693, "phrase": "similar_results"}, {"score": 0.0021049977753042253, "phrase": "new_collective_procedures"}], "paper_keywords": [""], "paper_abstract": "This paper summarizes a strategy for parallelizing a legacy Fortran 77 programusing the object-oriented (OO) and coarray features that entered Fortran in the 2003 and 2008 standards, respectively. OO programming (OOP) facilitates the construction of an extensible suite of model-verification and performance tests that drive the development. Coarray parallel programming facilitates a rapid evolution from a serial application to a parallel application capable of running on multicore processors and many-core accelerators in shared and distributed memory. We delineate 17 code modernization steps used to refactor and parallelize the program and study the resulting performance. Our initial studies were done using the Intel Fortran compiler on a 32-core shared memory server. Scaling behavior was very poor, and profile analysis using TAU showed that the bottleneck in the performance was due to our implementation of a collective, sequential summation procedure. We were able to improve the scalability and achieve nearly linear speedup by replacing the sequential summation with a parallel, binary tree algorithm. We also tested the Cray compiler, which provides its own collective summation procedure. Intel provides no collective reductions. With Cray, the program shows linear speedup even in distributed-memory execution. We anticipate similar results with other compilers once they support the new collective procedures proposed for Fortran 2015.", "paper_title": "Using Coarrays to Parallelize Legacy Fortran Applications: Strategy and Case Study", "paper_id": "WOS:000355855400001"}