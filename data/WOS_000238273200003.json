{"auto_keywords": [{"score": 0.049506552437065754, "phrase": "merlin"}, {"score": 0.014347950049403362, "phrase": "garbage_collection"}, {"score": 0.007250007377980366, "phrase": "perfect_traces"}, {"score": 0.005477795812153312, "phrase": "trace_granularity"}, {"score": 0.00481495049065317, "phrase": "object_lifetime"}, {"score": 0.004644247838681628, "phrase": "rapidly_growing_number"}, {"score": 0.004570326517392777, "phrase": "object-oriented_languages"}, {"score": 0.004497638432980249, "phrase": "java"}, {"score": 0.004201033616196156, "phrase": "deeper_understandings"}, {"score": 0.004167451906343558, "phrase": "object_lifetime_behavior"}, {"score": 0.004134137523409649, "phrase": "quick_exploration"}, {"score": 0.004068302313449334, "phrase": "new_garbage_collection_algorithms"}, {"score": 0.003876996400581697, "phrase": "whole-heap_garbage_collection"}, {"score": 0.0038305869305614504, "phrase": "potential_collection_point"}, {"score": 0.003606711217432998, "phrase": "granulated_traces"}, {"score": 0.00328849874768242, "phrase": "garbage_collection_algorithms"}, {"score": 0.003171740347925348, "phrase": "systematic_methodology"}, {"score": 0.003146360480030653, "phrase": "simulation_studies"}, {"score": 0.003083793024782014, "phrase": "present_results"}, {"score": 0.002891793055307152, "phrase": "simulated_garbage_collection_results"}, {"score": 0.002722634472231842, "phrase": "new_algorithm"}, {"score": 0.0026792166577171476, "phrase": "computing_object_lifetimes"}, {"score": 0.0025633455664747606, "phrase": "dead_objects"}, {"score": 0.0024822279007111255, "phrase": "merlin_algorithm"}, {"score": 0.0024524733595572084, "phrase": "garbage_collections"}, {"score": 0.0024133533748653033, "phrase": "base_system"}, {"score": 0.0023940274498526213, "phrase": "experimental_results"}, {"score": 0.0022630008787375435, "phrase": "brute-force_method"}, {"score": 0.0022179605282337395, "phrase": "object_allocation"}, {"score": 0.002130545585846588, "phrase": "heap_behavior"}, {"score": 0.0021049977753042253, "phrase": "new_object_lifetime_behaviors"}], "paper_keywords": ["garbage collection", " trace design", " object lifetime analysis", " trace generation"], "paper_abstract": "Programmers are writing a rapidly growing number of programs in object-oriented languages, such as Java and C#, that require garbage collection. Garbage collection traces and simulation speed up research by enabling deeper understandings of object lifetime behavior and quick exploration and design of new garbage collection algorithms. When generating perfect traces, the brute-force method of computing object lifetimes requires a whole-heap garbage collection at every potential collection point in the program. Because this process is prohibitively expensive, researchers often use granulated traces by collecting only periodically, for example, every 32 KB of allocation. We extend the state of the art for simulating garbage collection algorithms in two ways. First, we develop a systematic methodology for simulation studies of copying garbage collection and present results showing the effects of trace granularity on these simulations. We show that trace granularity often distorts simulated garbage collection results compared with perfect traces. Second, we present and measure the performance of a new algorithm called Merlin for computing object lifetimes. Merlin timestamps objects and later uses the timestamps of dead objects to reconstruct when they died. The Merlin algorithm piggybacks on garbage collections performed by the base system. Experimental results show that Merlin can generate traces over two orders of magnitude faster than the brute-force method which collects after every object allocation. We also use Merlin to produce visualizations of heap behavior that expose new object lifetime behaviors.", "paper_title": "Generating object lifetime traces with Merlin", "paper_id": "WOS:000238273200003"}