{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "acyclic_conjunctive_queries"}, {"score": 0.004610058444728656, "phrase": "sql_queries"}, {"score": 0.004462105963334103, "phrase": "order_by_clause"}, {"score": 0.004225950334493496, "phrase": "naive_approach"}, {"score": 0.004135010810625326, "phrase": "first_computing"}, {"score": 0.0036288825833675127, "phrase": "web_applications"}, {"score": 0.003048782877550259, "phrase": "top-k_tuples"}, {"score": 0.0027341763737751467, "phrase": "enumerating_answers"}, {"score": 0.002675252546913683, "phrase": "sorted_order"}, {"score": 0.0026175952455594277, "phrase": "polynomial_delay"}, {"score": 0.0025334249463305875, "phrase": "query-and-data_complexity"}, {"score": 0.002347378595930709, "phrase": "efficient_algorithm"}, {"score": 0.0022472527731744974, "phrase": "top-ranked_tuple"}, {"score": 0.00217496508306238, "phrase": "conjunctive_query"}], "paper_keywords": [""], "paper_abstract": "Evaluations of SQL queries with the ORDER BY clause is considered. The naive approach of first computing the result and then sorting the tuples is not suitable for Web applications, since the result could be very large while users expect to get quickly the top-k tuples. Tractability, in this case, amounts to enumerating answers in sorted order with polynomial delay, under query-and-data complexity. It is proved that an efficient algorithm for finding the top-ranked tuple of a conjunctive query is a sufficient (and not just necessary) condition for tractability. Several classes of orders are shown to have this property when queries are acyclic.", "paper_title": "Incrementally computing ordered answers of acyclic conjunctive queries", "paper_id": "WOS:000239450400013"}