{"auto_keywords": [{"score": 0.04280931884725775, "phrase": "tentative_checkpoint"}, {"score": 0.007606256441588011, "phrase": "consistent_global_checkpointing"}, {"score": 0.00481495049065317, "phrase": "consistent_global_checkpoint_collection"}, {"score": 0.004630910803911567, "phrase": "widely_used_techniques"}, {"score": 0.0045415338200109345, "phrase": "distributed_systems"}, {"score": 0.004384960761826366, "phrase": "novel_checkpointing_algorithm"}, {"score": 0.00396218934254591, "phrase": "consistent_global_checkpoint_initiation"}, {"score": 0.0038404642251010797, "phrase": "application_messages"}, {"score": 0.0038106195546165574, "phrase": "limited_control_messages"}, {"score": 0.0036363418376496484, "phrase": "new_consistent_global_checkpoint_initiation"}, {"score": 0.003389704997952315, "phrase": "existing_communication-induced_checkpointing_algorithms"}, {"score": 0.0029453365339797933, "phrase": "current_consistent_global_checkpoint_initiation"}, {"score": 0.002854761308379149, "phrase": "message_log"}, {"score": 0.002821516317503421, "phrase": "stable_storage"}, {"score": 0.0027347383772384102, "phrase": "message_logs"}, {"score": 0.0026923527275481804, "phrase": "stable_storage_form"}, {"score": 0.002549096826249, "phrase": "new_tentative_checkpoint"}, {"score": 0.0024803459795996116, "phrase": "tentative_checkpoints"}, {"score": 0.0023029188952824685, "phrase": "process_increase"}, {"score": 0.002223351523626989, "phrase": "consistent_global_checkpoint"}, {"score": 0.002171836484200008, "phrase": "performance_evaluation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Distributed systems", " Fault-tolerance", " Checkpointing", " Rollback recovery", " Communication-induced checkpointing"], "paper_abstract": "Checkpointing and rollback recovery are widely used techniques for achieving fault-tolerance in distributed systems. In this paper, we present a novel checkpointing algorithm which has the following desirable features: A process can independently initiate consistent global checkpointing by saving its current state, called a tentative checkpoint. Other processes come to know about a consistent global checkpoint initiation through information piggy-backed with the application messages or limited control messages if necessary. When a process comes to know about a new consistent global checkpoint initiation, it takes a tentative checkpoint after processing the message (not before processing the message as in existing communication-induced checkpointing algorithms). After a process takes a tentative checkpoint, it starts logging the messages sent and received in memory. When a process comes to know that every other process has taken a tentative checkpoint corresponding to current consistent global checkpoint initiation, it flushes the tentative checkpoint and the message log to the stable storage. The tentative checkpoints together with the message logs stored in the stable storage form a consistent global checkpoint. Two or more processes can concurrently initiate consistent global checkpointing by taking a new tentative checkpoint; in that case, the tentative checkpoints taken by all these processes will be part of the same consistent global checkpoint. The sequence numbers assigned to checkpoints by a process increase monotonically. Checkpoints with the same sequence number form a consistent global checkpoint. We also present the performance evaluation of our algorithm. (C) 2008 Elsevier Inc. All rights reserved.", "paper_title": "An optimistic checkpointing and message logging approach for consistent global checkpoint collection in distributed systems", "paper_id": "WOS:000261532200004"}