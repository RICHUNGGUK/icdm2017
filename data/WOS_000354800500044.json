{"auto_keywords": [{"score": 0.049255390034042286, "phrase": "quantitative_analysis_problem"}, {"score": 0.04733190377720631, "phrase": "icfg"}, {"score": 0.00481495049065317, "phrase": "quantitative_interprocedural_analysis"}, {"score": 0.0046993598473345395, "phrase": "interprocedural_control-flow_graphs"}, {"score": 0.00436890075128947, "phrase": "positive_integer-valued_number"}, {"score": 0.0041184131734368825, "phrase": "neutral_events"}, {"score": 0.0040757181942937875, "phrase": "weight_function"}, {"score": 0.003991646181215783, "phrase": "numerical_value"}, {"score": 0.003571591012750155, "phrase": "numerical_weights"}, {"score": 0.0035468507553681034, "phrase": "good_events"}, {"score": 0.0034615969985956866, "phrase": "bad_events"}, {"score": 0.003308649946463136, "phrase": "maximal_ratio"}, {"score": 0.0032743220621043023, "phrase": "valid_paths"}, {"score": 0.0031187606191012012, "phrase": "polynomial_time"}, {"score": 0.003054367741379269, "phrase": "efficient_and_practical_algorithm"}, {"score": 0.002939737235379635, "phrase": "static_program_analysis"}, {"score": 0.002879029968532794, "phrase": "worst-case_execution_time"}, {"score": 0.0028195727965553367, "phrase": "average_energy_consumption"}, {"score": 0.0027903049766389433, "phrase": "mobile_application"}, {"score": 0.002630085891013006, "phrase": "java_soot_framework"}, {"score": 0.002461852774571558, "phrase": "sound_approach"}, {"score": 0.002436289099444074, "phrase": "false_positives"}, {"score": 0.0023859534478427313, "phrase": "inefficiently-used_containers"}, {"score": 0.002280423827531483, "phrase": "static_profiling"}, {"score": 0.002134508934917511, "phrase": "relatively_large_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "relevant_and_useful_information"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Interprocedural analysis", " Quantitative objectives", " Mean-payoff and ratio objectives", " Memory bloat", " Static profiling"], "paper_abstract": "We consider the quantitative analysis problem for interprocedural control-flow graphs (ICFGs). The input consists of an ICFG, a positive weight function that assigns every transition a positive integer-valued number, and a labelling of the transitions (events) as good, bad, and neutral events. The weight function assigns to each transition a numerical value that represents ameasure of how good or bad an event is. The quantitative analysis problem asks whether there is a run of the ICFG where the ratio of the sum of the numerical weights of good events versus the sum of weights of bad events in the long-run is at least a given threshold (or equivalently, to compute the maximal ratio among all valid paths in the ICFG). The quantitative analysis problem for ICFGs can be solved in polynomial time, and we present an efficient and practical algorithm for the problem. We show that several problems relevant for static program analysis, such as estimating the worst-case execution time of a program or the average energy consumption of a mobile application, can be modeled in our framework. We have implemented our algorithm as a tool in the Java Soot framework. We demonstrate the effectiveness of our approach with two case studies. First, we show that our framework provides a sound approach (no false positives) for the analysis of inefficiently-used containers. Second, we show that our approach can also be used for static profiling of programs which reasons about methods that are frequently invoked. Our experimental results show that our tool scales to relatively large benchmarks, and discovers relevant and useful information that can be used to optimize performance of the programs.", "paper_title": "Quantitative Interprocedural Analysis", "paper_id": "WOS:000354800500044"}