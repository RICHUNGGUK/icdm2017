{"auto_keywords": [{"score": 0.04452857699254113, "phrase": "sigma"}, {"score": 0.028186686794369017, "phrase": "input-covering_schedules"}, {"score": 0.00799794408582641, "phrase": "program_p"}, {"score": 0.0073116272454886826, "phrase": "p's_execution"}, {"score": 0.004775726266706856, "phrase": "multithreaded_programs"}, {"score": 0.00467905143301368, "phrase": "multithreaded_execution"}, {"score": 0.004640929126263433, "phrase": "small_sets"}, {"score": 0.003828912548622257, "phrase": "semantically_valid_result"}, {"score": 0.0037055370870874484, "phrase": "small_sigma"}, {"score": 0.003250403288147613, "phrase": "symbolic_execution"}, {"score": 0.0030069962181403487, "phrase": "unbounded_length"}, {"score": 0.0029100272315053253, "phrase": "bounded_epochs"}, {"score": 0.002605201547405916, "phrase": "constrained_execution_runtime"}, {"score": 0.002583931950389087, "phrase": "pthreads_programs"}, {"score": 0.0024398167078355224, "phrase": "possible_runtime_schedules"}, {"score": 0.0021049977753042253, "phrase": "conventional_nondeterministic_execution"}], "paper_keywords": ["static analysis", " symbolic execution", " constrained execution", " determinism"], "paper_abstract": "We propose constraining multithreaded execution to small sets of input-covering schedules, which we define as follows: given a program P, we say that a set of schedules Sigma covers all inputs of program P if, when given any input, P's execution can be constrained to some schedule in Sigma and still produce a semantically valid result. Our approach is to first compute a small Sigma for a given program P, and then, at runtime, constrain P's execution to always follow some schedule in Sigma, and never deviate. We have designed an algorithm that uses symbolic execution to systematically enumerate a set of input-covering schedules, Sigma. To deal with programs that run for an unbounded length of time, we partition execution into bounded epochs, find input-covering schedules for each epoch in isolation, and then piece the schedules together at runtime. We have implemented this algorithm along with a constrained execution runtime for pthreads programs, and we report results. Our approach has the following advantage: because all possible runtime schedules are known a priori, we can seek to validate the program by thoroughly verifying each schedule in Sigma, in isolation, without needing to reason about the huge space of thread interleavings that arises due to conventional nondeterministic execution.", "paper_title": "Input-Covering Schedules for Multithreaded Programs", "paper_id": "WOS:000327697300038"}