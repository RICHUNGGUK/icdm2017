{"auto_keywords": [{"score": 0.027102711270290843, "phrase": "tcam"}, {"score": 0.00481495049065317, "phrase": "hardware_priority_queues"}, {"score": 0.004771276094330179, "phrase": "recursive_and_fast_construction"}, {"score": 0.004727995968069753, "phrase": "n-element_priority_queue"}, {"score": 0.0046993598473345395, "phrase": "exponentially_smaller_hardware_priority_queues"}, {"score": 0.004642861663947661, "phrase": "ram"}, {"score": 0.0045726187330434025, "phrase": "priority_queue_implementations"}, {"score": 0.0044089082776901135, "phrase": "key_size"}, {"score": 0.004342430078306461, "phrase": "expensive_special_hardware"}, {"score": 0.0042252744467257885, "phrase": "priority_queue_size"}, {"score": 0.004161553532799662, "phrase": "priority_queue"}, {"score": 0.0040987896316698495, "phrase": "considerably_smaller_hardware_priority_queues"}, {"score": 0.003916098498242888, "phrase": "pq_operation"}, {"score": 0.003787302434234525, "phrase": "ppq"}, {"score": 0.003051713660488494, "phrase": "tcam_based_priority_queue"}, {"score": 0.0030147970456037274, "phrase": "tcam-ppq"}, {"score": 0.0029965060407413898, "phrase": "scalable_perfect_line_rate_fair_queuing"}, {"score": 0.0028110048684383167, "phrase": "hardware_tcam."}, {"score": 0.002436289099444074, "phrase": "maximum_number"}, {"score": 0.002348883765159185, "phrase": "previous_result"}, {"score": 0.0022440136394950632, "phrase": "time_complexity"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["Sorting", " TCAM", " Priority Queue", " WFQ"], "paper_abstract": "A recursive and fast construction of an n-element priority queue from exponentially smaller hardware priority queues and size n RAM is presented. All priority queue implementations to date require either O(log n) instructions per operation or, exponential (with key size) space or, expensive special hardware whose cost and latency dramatically increases with the priority queue size. Hence constructing a priority queue (PQ) from considerably smaller hardware priority queues (which are also much faster) while maintaining the 0(1) steps per PQ operation is critical. Here we present such an acceleration technique called the Power Priority Queue (PPQ) technique. Specifically, an n-element PPQ is constructed from 2k - 1 primitive priority queues of size k root n (k = 2,3,...) and a RAM of size n, where the throughput of the construct beats that of a single, size n primitive hardware priority queue. For example an n-element PQ can be constructed from either three root n or five,3 root n primitive H/W priority queues. Applying our technique to a TCAM based priority queue, results in TCAM-PPQ a scalable perfect line rate fair queuing of millions of concurrent connections at speeds of 100 Gbps. This demonstrates the benefits of our scheme; when used with hardware TCAM. We expect similar-results with systolic-arrays-shift-registers-and-similar-technologies As a byproduct of our technique we present an O(n) time sorting algorithm in a system equipped with a O(w root n) entries TCAM, where here n is the number of items, and w is the maximum number of bits required to represent an item, improving on a previous result that used an Omega(n) entries TCAM. Finally, we provide a lower bound on the time complexity of sorting n-element with TCAM of size O(n) that matches our TCAM based sorting algorithm. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Recursive design of hardware priority queues", "paper_id": "WOS:000337648400006"}