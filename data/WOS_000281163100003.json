{"auto_keywords": [{"score": 0.04949240338189186, "phrase": "high-level_abstractions"}, {"score": 0.02322730111336097, "phrase": "modern_applications"}, {"score": 0.00944509837188495, "phrase": "multicore_processors"}, {"score": 0.005704609437839335, "phrase": "automatic_parallelization"}, {"score": 0.004555028829645471, "phrase": "sequential_applications"}, {"score": 0.004471530397729526, "phrase": "significant_attention"}, {"score": 0.004001593118269276, "phrase": "shared-memory_systems"}, {"score": 0.0037390093889739526, "phrase": "fortran"}, {"score": 0.0036477941360224435, "phrase": "primitive_data_types"}, {"score": 0.0034294219963679857, "phrase": "complex_user-defined_class_types"}, {"score": 0.0032240802202623316, "phrase": "research_compilers"}, {"score": 0.0030876784650745973, "phrase": "high-level_object-oriented_abstractions"}, {"score": 0.002831894638104635, "phrase": "source-to-source_compiler_infrastructure"}, {"score": 0.0027971262980039198, "phrase": "rose"}, {"score": 0.002728847267539957, "phrase": "compiler_techniques"}, {"score": 0.002471973283582411, "phrase": "semantic-aware_parallelization_strategies"}, {"score": 0.0023819914954155905, "phrase": "extended_compiler_analyses"}, {"score": 0.0023527296826339225, "phrase": "preliminary_results"}], "paper_keywords": ["Automatic parallelization", " High-level abstractions", " Semantics", " ROSE", " OpenMP"], "paper_abstract": "Automatic introduction of OpenMP for sequential applications has attracted significant attention recently because of the proliferation of multicore processors and the simplicity of using OpenMP to express parallelism for shared-memory systems. However, most previous research has only focused on C and Fortran applications operating on primitive data types. Modern applications using high-level abstractions, such as C++ STL containers and complex user-defined class types, are largely ignored due to the lack of research compilers that are readily able to recognize high-level object-oriented abstractions and leverage their associated semantics. In this paper, we use a source-to-source compiler infrastructure, ROSE, to explore compiler techniques to recognize high-level abstractions and to exploit their semantics for automatic parallelization. Several representative parallelization candidate kernels are used to study semantic-aware parallelization strategies for high-level abstractions, combined with extended compiler analyses. Preliminary results have shown that semantics of abstractions can help extend the applicability of automatic parallelization to modern applications and expose more opportunities to take advantage of multicore processors.", "paper_title": "Semantic-Aware Automatic Parallelization of Modern Applications Using High-Level Abstractions", "paper_id": "WOS:000281163100003"}