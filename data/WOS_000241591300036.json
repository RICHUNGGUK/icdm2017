{"auto_keywords": [{"score": 0.0444227308407221, "phrase": "user_space"}, {"score": 0.015719716506582538, "phrase": "zero-copy_data_path"}, {"score": 0.004637478829869904, "phrase": "huge_requests"}, {"score": 0.004494570360108983, "phrase": "concurrent_users"}, {"score": 0.004438642216475526, "phrase": "excessive_memory_copy_operations"}, {"score": 0.0036782824183282823, "phrase": "serviceable_requests"}, {"score": 0.0036097844103129043, "phrase": "cpu_resources"}, {"score": 0.0031448288291084, "phrase": "upper_described_problems"}, {"score": 0.0029909851863915283, "phrase": "existing_system_call_interface"}, {"score": 0.00262191949451482, "phrase": "supposed_zero-copy_data_path"}, {"score": 0.002493592357827492, "phrase": "cpu_copies"}, {"score": 0.0022696277881969896, "phrase": "improved_cpu_efficiency"}, {"score": 0.0022133711375320244, "phrase": "larger_number"}], "paper_keywords": [""], "paper_abstract": "Huge requests for file transmission by concurrent users cause excessive memory copy operations and system calls between kernel and user space, which are very expensive and require many CPU cycles for processing. And it has been a bottleneck that limits the number of serviceable requests and prevents CPU resources from being allocated to other processes. In this paper, we suppose the zero-copy data path for efficient file transmission to solve the upper described problems. To do that, we used existing system call interface, sendfile, for file transmission from one device to another and used the same buffer page to transmit a file. The supposed zero-copy data path reduces CPU cost per transaction by eliminating CPU copies between kernel and user space and by avoiding unnecessary system calls in user space. The improved CPU efficiency means that a larger number of requests can be serviced with the same CPU configuration.", "paper_title": "Design and implementation of zero-copy data path for efficient file transmission", "paper_id": "WOS:000241591300036"}