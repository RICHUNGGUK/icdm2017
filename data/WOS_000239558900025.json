{"auto_keywords": [{"score": 0.048661882068602086, "phrase": "distributed_systems"}, {"score": 0.004815168583768755, "phrase": "modular"}, {"score": 0.004334280585565239, "phrase": "highly-available_distributed_systems"}, {"score": 0.003113441660343867, "phrase": "long_periods"}, {"score": 0.003021141590548526, "phrase": "different_nodes"}, {"score": 0.002976019715894587, "phrase": "different_software_versions"}, {"score": 0.0028446460307503343, "phrase": "incompatible_protocols"}, {"score": 0.0024842242921857705, "phrase": "service_disruption"}, {"score": 0.0024105326885334962, "phrase": "new_ways"}, {"score": 0.002286781334850213, "phrase": "multi-version_system"}, {"score": 0.0021857667493036786, "phrase": "prototype_implementation"}, {"score": 0.0021369416775353107, "phrase": "automatic_upgrades"}, {"score": 0.0021049977753042253, "phrase": "modest_overhead"}], "paper_keywords": [""], "paper_abstract": "Upgrading the software of long-lived, highly-available distributed systems is difficult. It is not possible to upgrade all the nodes in a system at once, since some nodes may be unavailable and halting the system for an upgrade is unacceptable. Instead, upgrades must happen gradually, and there may be long periods of time when different nodes run different software versions and need to communicate using incompatible protocols. We present a methodology and infrastructure that make it possible to upgrade distributed systems automatically while limiting service disruption. We introduce new ways to reason about correctness in a multi-version system. We also describe a prototype implementation that supports automatic upgrades with modest overhead.", "paper_title": "Modular software upgrades for distributed systems", "paper_id": "WOS:000239558900025"}