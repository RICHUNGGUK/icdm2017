{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "tree_compression_pushdown_automaton."}, {"score": 0.004746263721902201, "phrase": "new_kind"}, {"score": 0.004645057834614705, "phrase": "deterministic_pushdown_automaton"}, {"score": 0.004261268957001927, "phrase": "tree_compression_automaton"}, {"score": 0.0041703614123283165, "phrase": "complete_compressed_index"}, {"score": 0.0034841647157189985, "phrase": "single_tree"}, {"score": 0.0028279422436488116, "phrase": "automaton's_transitions"}, {"score": 0.0025202582748972122, "phrase": "linear_time"}, {"score": 0.002396371892825691, "phrase": "length_n"}, {"score": 0.002166530105679438, "phrase": "subtree_repeats"}, {"score": 0.0021049977753042253, "phrase": "overall_complexity"}], "paper_keywords": ["trees", " pushdown automata", " compression", " indexing trees", " arbology"], "paper_abstract": "A new kind of a deterministic pushdown automaton, called a Tree Compression Automaton, is presented. The tree compression automaton represents a complete compressed index of a set of trees for subtrees and accepts all subtrees of given trees. The algorithm for constructing our pushdown automaton is incremental. For a single tree with n nodes, the automaton has at most n + 1 states, its transition function cardinality is at most 4n and there are 2n + 1 pushdown store symbols. If hashing is used for storing automaton's transitions, thus removing a factor of log n, the construction of the automaton takes linear time and space with respect to the length n of the input tree(s). Our pushdown automaton construction can also be used for finding all subtree repeats without augmenting the overall complexity.", "paper_title": "TREE COMPRESSION PUSHDOWN AUTOMATON", "paper_id": "WOS:000307856900006"}