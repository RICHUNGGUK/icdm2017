{"auto_keywords": [{"score": 0.029646929800025177, "phrase": "causal_atomicity"}, {"score": 0.011872215473181772, "phrase": "petri_net"}, {"score": 0.00481495049065317, "phrase": "important_generic_specification"}, {"score": 0.0038624981944755813, "phrase": "control_flow"}, {"score": 0.0030494153169181334, "phrase": "partially_ordered_executions"}, {"score": 0.0026252106881752067, "phrase": "robust_notion"}, {"score": 0.0023507916951658455, "phrase": "petri_net_tools"}, {"score": 0.0021049977753042253, "phrase": "automatic_partial-order_reduction"}], "paper_keywords": [""], "paper_abstract": "Atomicity is an important generic specification that assures that a programmer can pretend blocks occur sequentially in any execution. We define a notion of atomicity based on causality. We model the control flow of a program with threads using a Petri net that naturally abstracts data, and faithfully captures the independence and interaction between threads. The causality between events in the partially ordered executions of the Petri net is used to define the notion of causal atomicity. We show that causal atomicity is a robust notion that many correct programs adopt, and show how we can effectively check causal atomicity using Petri net tools based on unfoldings, which exploit the concurrency in the net to yield automatic partial-order reduction in the state-space.", "paper_title": "Causal atomicity", "paper_id": "WOS:000240257000028"}