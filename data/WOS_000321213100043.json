{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cyclic_dependencies"}, {"score": 0.007468242826783355, "phrase": "cyclic_aborts"}, {"score": 0.00478740563679966, "phrase": "transactional_memory"}, {"score": 0.004760131883436814, "phrase": "tm"}, {"score": 0.004652016085325825, "phrase": "key_programmability_problems"}, {"score": 0.0046253989970108985, "phrase": "chip_multiprocessors"}, {"score": 0.0045464538515249085, "phrase": "concurrent_transactions"}, {"score": 0.004379977556546879, "phrase": "existing_hardware_tms"}, {"score": 0.004111960807556655, "phrase": "conflicting_transactions"}, {"score": 0.003949974260471287, "phrase": "acyclic_conflicts"}, {"score": 0.0035825553390798105, "phrase": "late_aborts"}, {"score": 0.003431481042678356, "phrase": "acyclic_aborts"}, {"score": 0.0031210959920028357, "phrase": "multiple_accesses"}, {"score": 0.002790170184447136, "phrase": "wng_policy"}, {"score": 0.002758273619951683, "phrase": "previous_htms"}, {"score": 0.002711109302199029, "phrase": "multiple_readers"}, {"score": 0.002574387911697005, "phrase": "new_mechanisms"}, {"score": 0.0025376454089004376, "phrase": "transactional_state"}, {"score": 0.0024305295343926966, "phrase": "stamp"}, {"score": 0.002402731767209114, "phrase": "average_speedups"}, {"score": 0.002375253757224999, "phrase": "higher-contention_benchmarks"}, {"score": 0.002294686545883412, "phrase": "low-contention_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "tokentm"}], "paper_keywords": ["Design", " Performance", " transactional memory", " transactional conflicts", " cyclic dependencies", " serializing transactions"], "paper_abstract": "Transactional memory (TM) has been proposed to alleviate some key programmability problems in chip multiprocessors. Most TMs optimistically allow concurrent transactions, detecting read-write or write-write conflicts. Upon conflicts, existing hardware TMs (HTMs) use one of three conflict-resolution policies: (1) always-abort, (2) always-wait for some conflicting transactions to complete, or (3) always-go past conflicts and resolve acyclic conflicts at commit or abort upon cyclic dependencies. While each policy has advantages, the policies degrade performance under contention by limiting concurrency (always-abort, always-wait) or incurring late aborts due to cyclic dependencies (always-go). Thus, while always-go avoids acyclic aborts, no policy avoids cyclic aborts. We propose Wait-n-GoTM (WnGTM) to increase concurrency while avoiding cyclic aborts. We observe that most cyclic dependencies are caused by threads interleaving multiple accesses to a few heavily-read-write-shared delinquent data cache blocks. These accesses occur in code sections called cycle inducer sections (CISTs). Accordingly, we propose Wait-n-Go (WnG) conflict-resolution to avoid many cyclic aborts by predicting and serializing the CISTs. To support the WnG policy, we extend previous HTMs to (1) allow multiple readers and writers, (2) scalably identify dependencies, and (3) detect cyclic dependencies via new mechanisms, namely, conflict transactional state, order-capture, and hardware timestamps, respectively. In 16-core simulations of STAMP, WnGTM achieves average speedups of 46% for higher-contention benchmarks and 28% for all benchmarks over always-abort (TokenTM) with low-contention benchmarks remaining unchanged, compared to always-go (DATM) and always-wait (LogTM-SE), which perform worse than and 6% better than TokenTM, respectively.", "paper_title": "Wait-n-GoTM: Improving HTM Performance by Serializing Cyclic Dependencies", "paper_id": "WOS:000321213100043"}