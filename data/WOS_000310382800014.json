{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "stream_programs"}, {"score": 0.0047689174754929195, "phrase": "resource_constrained_multicore_architectures"}, {"score": 0.004723322467153553, "phrase": "stream_programming_model"}, {"score": 0.004523455475492876, "phrase": "important_application_domains"}, {"score": 0.004480196733208298, "phrase": "software_pipelining"}, {"score": 0.004416079619543104, "phrase": "important_code_scheduling_technique"}, {"score": 0.0042495320879288615, "phrase": "multicore_evolution"}, {"score": 0.004168618849008299, "phrase": "new_dimension"}, {"score": 0.0039729853486821995, "phrase": "best_software_pipelining_schedule"}, {"score": 0.0034392837410790293, "phrase": "new_solution_methodology"}, {"score": 0.003215295260684715, "phrase": "integer_linear_programming"}, {"score": 0.0030058503645435455, "phrase": "rate-optimal_software_pipelining"}, {"score": 0.0029343925814926787, "phrase": "intercore_communication_overhead"}, {"score": 0.002864628676257225, "phrase": "extended_formulation"}, {"score": 0.0027431953780099826, "phrase": "memory_size"}, {"score": 0.002730023736069673, "phrase": "constrained_systems"}, {"score": 0.00266510562382701, "phrase": "rate-optimal_software_pipelining_execution"}, {"score": 0.002601727192945944, "phrase": "strict_memory"}, {"score": 0.0025767987652419054, "phrase": "processor_cores"}, {"score": 0.0025398521156505425, "phrase": "communication_constraints"}, {"score": 0.00242047093248845, "phrase": "proposed_problem_formulations"}, {"score": 0.0023178219772486868, "phrase": "brook_programming_environment"}, {"score": 0.0022409963215568565, "phrase": "dfbrook"}, {"score": 0.002208853811052348, "phrase": "experimental_study"}, {"score": 0.0021049977753042253, "phrase": "proposed_solutions"}], "paper_keywords": ["Multicore", " stream programs", " software pipelining", " resource constrained"], "paper_abstract": "Stream programming model has been productively applied to a number of important application domains. Software pipelining is an important code scheduling technique for stream programs. However, the multicore evolution has presented a new dimension of challenges: that is how to orchestrate the best software pipelining schedule in the face of resource constrained architectures (e. g., number of cores, available memory, and bandwidth)? In this paper, we proposed a new solution methodology to address the problem above. Our main contributions include the following. A unified Integer Linear Programming (ILP) formulation has been proposed that combines the requirement of both rate-optimal software pipelining and the minimization of intercore communication overhead. Next, an extended formulation has been proposed to formulate the schedule under memory size constrained systems. It orchestrates the rate-optimal software pipelining execution for stream programs with strict memory, processor cores, and communication constraints. A solution testbed has been implemented for the proposed problem formulations. This has been realized by extending the Brook programming environment with our software pipelining support-named DFBrook. An experimental study has been conducted to verify the effectiveness of the proposed solutions.", "paper_title": "Software Pipelining for Stream Programs on Resource Constrained Multicore Architectures", "paper_id": "WOS:000310382800014"}