{"auto_keywords": [{"score": 0.0408755212786262, "phrase": "oi_optimization"}, {"score": 0.014788111051720997, "phrase": "class_a"}, {"score": 0.011408109377899425, "phrase": "full_potential"}, {"score": 0.010919017972014021, "phrase": "source_code"}, {"score": 0.00481495049065317, "phrase": "java_applications"}, {"score": 0.00478672147169923, "phrase": "object_inlining"}, {"score": 0.004703018868854905, "phrase": "known_optimization"}, {"score": 0.004675442997905995, "phrase": "object_oriented_programming"}, {"score": 0.004634380652505945, "phrase": "referenced_objects"}, {"score": 0.004607205374689976, "phrase": "class_b"}, {"score": 0.004421368738303273, "phrase": "class_b_part"}, {"score": 0.004395437013020554, "phrase": "class_a."}, {"score": 0.0043185468826678185, "phrase": "b_type_objects"}, {"score": 0.004205715668397308, "phrase": "indirect_accesses"}, {"score": 0.004083787598482644, "phrase": "direct_accesses"}, {"score": 0.003930529468459255, "phrase": "significant_performance_potential"}, {"score": 0.0038617405001251325, "phrase": "performance_measurements"}, {"score": 0.0037607992433574835, "phrase": "aggressive_oi_optimization"}, {"score": 0.0037387272682935686, "phrase": "complex_analysis"}, {"score": 0.003651722462180419, "phrase": "multiple_references"}, {"score": 0.0036196183044671106, "phrase": "inlinable_object"}, {"score": 0.0034633366010891403, "phrase": "oi"}, {"score": 0.0034126606309263694, "phrase": "two-stage_process"}, {"score": 0.0033826510524766758, "phrase": "first_stage"}, {"score": 0.0033627909221532527, "phrase": "automatic_analysis"}, {"score": 0.0032080372297065727, "phrase": "code_transformations"}, {"score": 0.00303346212256215, "phrase": "second_stage"}, {"score": 0.002834759855989069, "phrase": "compilation_process"}, {"score": 0.002809817778886807, "phrase": "javac_run"}, {"score": 0.002760588246708752, "phrase": "half-automated_technique"}, {"score": 0.0027042405175243833, "phrase": "oi."}, {"score": 0.002688352108538072, "phrase": "proposed_oi_refactoring_process"}, {"score": 0.0024609079887911063, "phrase": "better_performance_gain"}, {"score": 0.00237539960152304, "phrase": "oi_optimization_effects"}, {"score": 0.0023614392066048763, "phrase": "multithreaded_applications"}, {"score": 0.0023406519395653674, "phrase": "multicore_machines"}, {"score": 0.0022996234912148463, "phrase": "oi_transformation"}, {"score": 0.002265981774560307, "phrase": "eclipse_jdt"}, {"score": 0.002252662984070481, "phrase": "java_development_tools"}, {"score": 0.002161593130928687, "phrase": "profiling_data"}, {"score": 0.0021174453532942115, "phrase": "proposed_system"}], "paper_keywords": ["Refactoring", " Java", " Inlining", " Eclipse"], "paper_abstract": "Object Inlining (OI) is a known optimization in object oriented programming in which referenced objects of class B are inlined into their referencing objects of class A by making all fields and methods of class B part of class A. The optimization saves all the new operations of B type objects from class A and at the same time replaces all indirect accesses, from A to fields of B, by direct accesses. To the best of our knowledge, in-spite of the significant performance potential of the OI optimization, reported performance measurements were relatively moderate. This is because an aggressive OI optimization requires complex analysis and code transformations to overcome problems like multiple references to the inlinable object, object references that escape their object scope, etc. To extract the full potential of OI, we propose a two-stage process. The first stage includes automatic analysis of the source code that informs the user, via comments in the IDE, about code transformations that are needed in order to enable or to maximize the potential of the OI optimization. In the second stage, the OI optimization is applied automatically on the source code as a code refactoring operation, or preferably, as part of the compilation process prior to javac run. We show that this half-automated technique helps to extract the full potential of OI. The proposed OI refactoring process also determines the order of applying the inlinings of the objects and enables us to apply inlinings of objects created inside a method; thus enabling us to reach better performance gain. In this work we also include an evaluation of the OI optimization effects on multithreaded applications running on multicore machines. The comments and the OI transformation were implemented in the Eclipse JDT (Java Development Tools) plugin. The system was then applied on the SPECjbb2000 source code along with profiling data collected by the Eclipse TPTP plugin. The proposed system achieved 46% improvement in performance.", "paper_title": "Refactoring techniques for aggressive object inlining in Java applications", "paper_id": "WOS:000298798400004"}