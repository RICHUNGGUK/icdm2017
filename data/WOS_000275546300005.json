{"auto_keywords": [{"score": 0.034517811089193814, "phrase": "cpbpv"}, {"score": 0.01641014641517145, "phrase": "constraint_store"}, {"score": 0.009276122459239979, "phrase": "cpbpv_framework"}, {"score": 0.008755778756906082, "phrase": "execution_paths"}, {"score": 0.008671912752220644, "phrase": "bounded_length"}, {"score": 0.00481495049065317, "phrase": "bounded_program_verification"}, {"score": 0.004413846562278824, "phrase": "novel_constraint-programming_framework"}, {"score": 0.004165105357908494, "phrase": "constraint_stores"}, {"score": 0.00376293585033711, "phrase": "counter_examples"}, {"score": 0.0036026484429137998, "phrase": "properties_exists"}, {"score": 0.0035507457285983268, "phrase": "input_program"}, {"score": 0.0034491650585057754, "phrase": "boundness_restrictions"}, {"score": 0.00320770578058916, "phrase": "spurious_execution_paths"}, {"score": 0.0029117710453690827, "phrase": "rich_language"}, {"score": 0.002883718207958817, "phrase": "constraint_programming"}, {"score": 0.0024818194799172263, "phrase": "experimental_results"}, {"score": 0.0024224481033945943, "phrase": "magnitude_improvements"}, {"score": 0.0023990982005125763, "phrase": "earlier_approaches"}, {"score": 0.002263639474937039, "phrase": "variable_domains"}, {"score": 0.0021670777282518424, "phrase": "subtle_errors"}], "paper_keywords": ["Bounded program verification", " Constraint-based symbolic execution", " Detection of nonconformities", " Test cases generation"], "paper_abstract": "This paper studies how to verify the conformity of a program with its specification and proposes a novel constraint-programming framework for bounded program verification (CPBPV). The CPBPV framework uses constraint stores to represent both the specification and the program and explores execution paths of bounded length nondeterministically. The CPBPV framework detects non-conformities and provides counter examples when a path of bounded length that refutes some properties exists. The input program is partially correct under the boundness restrictions, if each constraint store so produced implies the post-condition. CPBPV does not explore spurious execution paths, as it incrementally prunes execution paths early by detecting that the constraint store is not consistent. CPBPV uses the rich language of constraint programming to express the constraint store. Finally, CPBPV is parameterized with a list of solvers which are tried in sequence, starting with the least expensive and less general. Experimental results often produce orders of magnitude improvements over earlier approaches, running times being often independent of the size of the variable domains. Moreover, CPBPV was able to detect subtle errors in some programs for which other frameworks based on bounded model checking have failed.", "paper_title": "CPBPV: a constraint-programming framework for bounded program verification", "paper_id": "WOS:000275546300005"}