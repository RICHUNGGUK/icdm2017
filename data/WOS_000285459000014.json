{"auto_keywords": [{"score": 0.04596799358717516, "phrase": "combinatorial_explosion"}, {"score": 0.00481495049065317, "phrase": "lambda-calculus_term"}, {"score": 0.004756610783430674, "phrase": "dag"}, {"score": 0.004058180509184539, "phrase": "bottom-up_manner"}, {"score": 0.0038332390893263844, "phrase": "top-down_fashion"}, {"score": 0.003635503288514593, "phrase": "uplinked_dags"}, {"score": 0.003490343299449249, "phrase": "alternate_techniques"}, {"score": 0.003447932289587852, "phrase": "lamping_graphs"}, {"score": 0.003419943984098415, "phrase": "explicit-substitution_calculi"}, {"score": 0.0027330029055210926, "phrase": "\"readback\"_problem"}, {"score": 0.0025918745925152423, "phrase": "director_strings"}, {"score": 0.0021837406983565098, "phrase": "complete_implementation"}, {"score": 0.0021571717917276724, "phrase": "data_structure"}, {"score": 0.0021049980887993046, "phrase": "sml."}], "paper_keywords": [""], "paper_abstract": "If we represent lambda-calculus term as a DAG rather than a tree, we can efficiently represent the sharing that arises from beta-reduction, thus avoiding combinatorial explosion in space. By adding uplinks from a child to its parents, we can efficiently implement beta-reduction in a bottom-up manner, thus avoiding combinatorial explosion in time required to search the term in a top-down fashion. We present an algorithm for performing beta-reduction on lambda-terms represented as uplinked DAGs; describe its proof of correctness; discuss its relation to alternate techniques such as Lamping graphs, explicit-substitution calculi and director strings; and present some timings of an implementation. Besides being both fast and parsimonious of space, the algorithm is particularly suited to applications such as compilers, theorem provers, and type-manipulation systems that may need to examine terms in between reductions-i.e., the \"readback\" problem for our representation is trivial. Like Lamping graphs, and unlike director strings or the suspension. calculus, the algorithm functions by side-effecting the term containing the redex; the representation is not a \"persistent\" one. The algorithm additionally has the charm of being quite simple; a complete implementation of the data structure and algorithm is 180 lines of SML.", "paper_title": "Bottom-up beta-reduction: Uplinks and lambda-DAGs", "paper_id": "WOS:000285459000014"}