{"auto_keywords": [{"score": 0.014901165248967342, "phrase": "typed_languages"}, {"score": 0.00919305760113047, "phrase": "base_environment"}, {"score": 0.00481495049065317, "phrase": "base_type_environment"}, {"score": 0.004222515162635615, "phrase": "type_system_designers"}, {"score": 0.00415777266387528, "phrase": "soundness_proofs"}, {"score": 0.0034538466642399976, "phrase": "typed_language"}, {"score": 0.0033228699494959172, "phrase": "well-furnished_standard_library"}, {"score": 0.0030994630902300133, "phrase": "software_artifacts"}, {"score": 0.0030283730114326014, "phrase": "base_type_environments"}, {"score": 0.0024574537875026634, "phrase": "type_environments"}, {"score": 0.0021049977753042253, "phrase": "random_testing"}], "paper_keywords": ["Random testing", " Type environments", " Numeric towers"], "paper_abstract": "As programmers, programming in typed languages increases our confidence in the correctness of our programs. As type system designers, soundness proofs increase our confidence in the correctness of our type systems. There is more to typed languages than their typing rules, however. To be usable, a typed language needs to provide a well-furnished standard library and to specify types for its exports. As software artifacts, these base type environments can rival typecheckers in complexity. Our experience with the Typed Racket base environment-which accounts for 31% of the code in the Typed Racket implementation-teaches us that writing type environments can be just as error-prone as writing typecheckers. We report on our experience over the past two years of using random testing to increase our confidence in the correctness of the Typed Racket base environment.", "paper_title": "Experience Report: Applying Random Testing to a Base Type Environment", "paper_id": "WOS:000327696700033"}