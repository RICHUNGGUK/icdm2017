{"auto_keywords": [{"score": 0.025500902621675058, "phrase": "interleaving_strategy"}, {"score": 0.00481495049065317, "phrase": "strategic_interleaving"}, {"score": 0.004379977556546879, "phrase": "sequential_deterministic_program"}, {"score": 0.003949974260471287, "phrase": "contemporary_programming_languages"}, {"score": 0.0038494249783286557, "phrase": "java"}, {"score": 0.0036553070575015344, "phrase": "algebraic_theory"}, {"score": 0.003267925215811654, "phrase": "deterministic_interleaving_strategy"}, {"score": 0.0029214769181390653, "phrase": "plausible_interleaving_strategies"}, {"score": 0.0027982016314450717, "phrase": "simple_and_concise_way"}, {"score": 0.0023145690608400425, "phrase": "deadlock_freedom"}, {"score": 0.0021049977753042253, "phrase": "multi-threaded_programs"}], "paper_keywords": ["threads", " multi-threading", " thread algebra", " interleaving strategies", " services", " deadlock freedom"], "paper_abstract": "We take a thread as the behavior of a sequential deterministic program under execution and multi-threading as the form of concurrency provided by contemporary programming languages such as Java and C#. We outline an algebraic theory about threads and multi-threading. In the case of multi-threading, some deterministic interleaving strategy determines how threads are interleaved. Interleaving operators for a number of plausible interleaving strategies are specified in a simple and concise way. By that, we show that it is essentially open-ended what counts as an interleaving strategy. We use deadlock freedom as an example to show that there are properties of multi-threaded programs that depend on the interleaving strategy used.", "paper_title": "Thread algebra for strategic interleaving", "paper_id": "WOS:000250235100003"}