{"auto_keywords": [{"score": 0.03821066921635996, "phrase": "fixed_collection"}, {"score": 0.03137898155509575, "phrase": "classical_process_calculi"}, {"score": 0.00481495049065317, "phrase": "distributed_applications"}, {"score": 0.004597754207658615, "phrase": "simple_and_uniform_programming_model"}, {"score": 0.004270347498153512, "phrase": "internet-scale_programs"}, {"score": 0.004096493540086106, "phrase": "loosely-coupled_distributed_components"}, {"score": 0.003911578552479064, "phrase": "composite_application"}, {"score": 0.0033274941600476104, "phrase": "datalog"}, {"score": 0.003281643474564305, "phrase": "reactor's_code"}, {"score": 0.003177154457204778, "phrase": "external_stimulus"}, {"score": 0.0030617935728586006, "phrase": "attempted_update"}, {"score": 0.0030196181347744372, "phrase": "reactor's_state"}, {"score": 0.0029234476524900794, "phrase": "reactor_model"}, {"score": 0.0024865237976623286, "phrase": "simply_its_state"}, {"score": 0.002407290605654707, "phrase": "message_channels"}, {"score": 0.0021443262599352996, "phrase": "datalog-style_rules"}, {"score": 0.0021245712108461227, "phrase": "aspect-like_composition"}, {"score": 0.0021049977753042253, "phrase": "separately-specified_functional_concerns"}], "paper_keywords": ["Reactors", " Datalog", " Actors", " Synchronous programming", " Asynchronous programming", " Synchronization", " Distributed programming"], "paper_abstract": "Our aim is to define the kernel of a simple and uniform programming model-the reactor model-which can serve as a foundation for building and evolving internet-scale programs. Such programs are characterized by collections of loosely-coupled distributed components that are assembled on the fly to produce a composite application. A reactor consists of two principal components: mutable state, in the form of a fixed collection of relations, and code, in the form of a fixed collection of rules in the style of Datalog. A reactor's code is executed in response to an external stimulus, which takes the form of an attempted update to the reactor's state. As in classical process calculi, the reactor model accommodates collections of distributed, concurrently executing processes. However, unlike classical process calculi, our observable behaviors are sequences of states, rather than sequences of messages. Similarly, the interface to a reactor is simply its state, rather than a collection of message channels, ports, or methods. One novel feature of our model is the ability to compose behaviors both synchronously and asynchronously. Also, our use of Datalog-style rules allows aspect-like composition of separately-specified functional concerns in a natural way. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Reactors: A data-oriented synchronous/asynchronous programming model for distributed applications", "paper_id": "WOS:000263228000005"}