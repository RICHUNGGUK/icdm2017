{"auto_keywords": [{"score": 0.049418985040378574, "phrase": "lock-free_data-structures"}, {"score": 0.00481495049065317, "phrase": "automatic_memory_reclamation_for_lock-free_data_structures"}, {"score": 0.0044608829094248985, "phrase": "lock-free_memory_reclamation"}, {"score": 0.004132743580000062, "phrase": "known_lock-free_reclamation_schemes"}, {"score": 0.0031955979242589494, "phrase": "original_lock-free_algorithm"}, {"score": 0.0030226700832113942, "phrase": "automatic_lock-free_reclamation_scheme"}, {"score": 0.0028590732866152118, "phrase": "mark-sweep_garbage_collection"}, {"score": 0.002704306866425829, "phrase": "normalized_lock-free_algorithm"}, {"score": 0.002336655334451464, "phrase": "proposed_scheme"}, {"score": 0.002241087008892355, "phrase": "hash_table"}, {"score": 0.002119702106867801, "phrase": "best_manual"}], "paper_keywords": ["Algorithms", " Design", " Theory", " Memory Management", " Concurrent Data Structures", " Non-blocking", " Lock-free", " Hazard Pointers"], "paper_abstract": "Lock-free data-structures are widely employed in practice, yet designing lock-free memory reclamation for them is notoriously difficult. In particular, all known lock-free reclamation schemes are \"manual\" in the sense that the developer has to specify when nodes have retired and may be reclaimed. Retiring nodes adequately is non-trivial and often requires the modification of the original lock-free algorithm. In this paper we present an automatic lock-free reclamation scheme for lock-free data-structures in the spirit of a mark-sweep garbage collection. The proposed algorithm works with any normalized lock-free algorithm and with no need for the programmer to retire nodes or make changes to the algorithm. Evaluation of the proposed scheme on a linked-list and a hash table shows that it performs similarly to the best manual (lock-free) memory reclamation scheme.", "paper_title": "Automatic Memory Reclamation for Lock-Free Data Structures", "paper_id": "WOS:000367256500015"}