{"auto_keywords": [{"score": 0.042786126849983945, "phrase": "application_mapping"}, {"score": 0.02880781948027875, "phrase": "recurrent_loops"}, {"score": 0.00481495049065317, "phrase": "coarse-grained_reconfigurable_architectures"}, {"score": 0.004767261858417823, "phrase": "coarse-grained_reconfigurable_arrays"}, {"score": 0.004424268136268051, "phrase": "power_efficiency"}, {"score": 0.0043804319008535555, "phrase": "software_programmability"}, {"score": 0.004230382915464492, "phrase": "cgras"}, {"score": 0.0040449598280454645, "phrase": "cgra_platforms"}, {"score": 0.003984968827278219, "phrase": "previous_solutions"}, {"score": 0.0038869467872381957, "phrase": "computation_speed"}, {"score": 0.0036980501827538455, "phrase": "local_memory_architecture"}, {"score": 0.003643185395780667, "phrase": "achievable_power"}, {"score": 0.0034660938095219846, "phrase": "memory-aware_application_mapping"}, {"score": 0.003347259612209552, "phrase": "effective_solution"}, {"score": 0.0031061129850110994, "phrase": "local_memory_size"}, {"score": 0.003044785536429499, "phrase": "communication_bandwidth"}, {"score": 0.00299958349498286, "phrase": "local_memory"}, {"score": 0.002955050521440921, "phrase": "external_main_memory"}, {"score": 0.0028822890425197582, "phrase": "efficient_methods"}, {"score": 0.0028394925080958205, "phrase": "dependent_data"}, {"score": 0.002797329638474873, "phrase": "double-buffering_local_memory"}, {"score": 0.0026217213613095322, "phrase": "energy-delay_product"}, {"score": 0.0024941578231560055, "phrase": "energy_consumption"}, {"score": 0.0023846534541336326, "phrase": "memory-unaware_mapping"}, {"score": 0.0023609780669713288, "phrase": "realistic_local_memory_architectures"}, {"score": 0.0022016885701010088, "phrase": "memory_parameters"}, {"score": 0.002158179521369965, "phrase": "runtime_overhead"}], "paper_keywords": ["Array mapping", " bank conflict", " coarse-grained reconfigurable architecture", " compilation", " multi-bank memory"], "paper_abstract": "Coarse-grained reconfigurable arrays (CGRAs) are a very promising platform, providing both up to 10-100 MOps/mW of power efficiency and software programmability. However, this promise of CGRAs critically hinges on the effectiveness of application mapping onto CGRA platforms. While previous solutions have greatly improved the computation speed, they have largely ignored the impact of the local memory architecture on the achievable power and performance. This paper motivates the need for memory-aware application mapping for CGRAs, and proposes an effective solution for application mapping that considers the effects of various memory architecture parameters including the number of banks, local memory size, and the communication bandwidth between the local memory and the external main memory. Further we propose efficient methods to handle dependent data on a double-buffering local memory, which is necessary for recurrent loops. Our proposed solution achieves 59% reduction in the energy-delay product, which factors into about 47% and 22% reduction in the energy consumption and runtime, respectively, as compared to memory-unaware mapping for realistic local memory architectures. We also show that our scheme scales across a range of applications and memory parameters, and the runtime overhead of handling recurrent loops by our proposed methods can be less than 1%.", "paper_title": "High Throughput Data Mapping for Coarse-Grained Reconfigurable Architectures", "paper_id": "WOS:000296015200002"}