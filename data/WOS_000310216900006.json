{"auto_keywords": [{"score": 0.044322505446268326, "phrase": "input_applications"}, {"score": 0.00481495049065317, "phrase": "non-contiguous_processor_allocation"}, {"score": 0.004761850836420121, "phrase": "mesh-based_chip_multiprocessors"}, {"score": 0.004709333998298903, "phrase": "virtual_point-to-point_links"}, {"score": 0.004455272634364756, "phrase": "processor_allocation_mechanism"}, {"score": 0.004406121974246201, "phrase": "run-time_assignment"}, {"score": 0.004285594361623147, "phrase": "communicating_tasks"}, {"score": 0.004168349927332055, "phrase": "processing_nodes"}, {"score": 0.004099542199088835, "phrase": "chip_multiprocessor"}, {"score": 0.004009555045206973, "phrase": "arrival_order"}, {"score": 0.0036485497734171294, "phrase": "on-chip_communication"}, {"score": 0.003283272764794988, "phrase": "communication_infrastructure"}, {"score": 0.0030545815929619306, "phrase": "non-contiguous_processor_allocation_mechanisms"}, {"score": 0.002921815042028607, "phrase": "input_application"}, {"score": 0.002873524721802591, "phrase": "disjoint_regions"}, {"score": 0.0026881926384093088, "phrase": "router_pipeline_stages"}, {"score": 0.002643753276264565, "phrase": "inter-region_routers"}, {"score": 0.0026000466400112974, "phrase": "different_existing_contiguous_and_non-contiguous_processor_allocation_techniques"}, {"score": 0.002445865715873089, "phrase": "comparison_purpose"}, {"score": 0.0024054226746197706, "phrase": "best_fit"}, {"score": 0.0023788319661581696, "phrase": "stack-based_allocation_algorithms"}, {"score": 0.00230080652063411, "phrase": "greedy-available-busy-list_algorithm"}, {"score": 0.0022007302738063566, "phrase": "non-contiguous_techniques"}, {"score": 0.002140400526572388, "phrase": "considerable_improvements"}, {"score": 0.0021049977753042253, "phrase": "selected_contiguous_and_non-contiguous_methods"}], "paper_keywords": [""], "paper_abstract": "In this study, the authors propose a processor allocation mechanism for run-time assignment of a set of communicating tasks of input applications onto the processing nodes of a chip multiprocessor, when the arrival order and execution lifetime of the input applications are not known a priori. This mechanism targets the on-chip communication and aims to reduce the power and latency of the network-on-chip employed as the communication infrastructure. In this work, the authors benefit from the advantages of non-contiguous processor allocation mechanisms, by allowing the tasks of the input application mapped onto disjoint regions (submeshes) and then virtually connecting them by bypassing the router pipeline stages of the inter-region routers. Among different existing contiguous and non-contiguous processor allocation techniques, the authors have chosen and implemented four efficient schemes for the comparison purpose: the best fit and stack-based allocation algorithms as contiguous techniques and the greedy-available-busy-list algorithm and run-time incremental mapping as non-contiguous techniques. Experimental results show considerable improvements over all selected contiguous and non-contiguous methods.", "paper_title": "Supporting non-contiguous processor allocation in mesh-based chip multiprocessors using virtual point-to-point links", "paper_id": "WOS:000310216900006"}