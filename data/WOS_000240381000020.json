{"auto_keywords": [{"score": 0.004814970514323876, "phrase": "lod"}, {"score": 0.004600870784042767, "phrase": "massive_models"}, {"score": 0.004075198669927074, "phrase": "drastic_simplifications"}, {"score": 0.003720600007408015, "phrase": "kd-tree_data_structure"}, {"score": 0.003320277992107974, "phrase": "primary_and_secondary_rays"}, {"score": 0.003245520963944678, "phrase": "lod_representation"}, {"score": 0.0031966173935538992, "phrase": "small_runtime_overhead"}, {"score": 0.0030311679447397725, "phrase": "ray_coherence_techniques"}, {"score": 0.002985484575498061, "phrase": "cache-coherent_layouts"}, {"score": 0.0026640466056415298, "phrase": "aliasing_artifacts"}, {"score": 0.0026040262154057607, "phrase": "memory_coherence"}, {"score": 0.0022711961447468114, "phrase": "rendering_models"}, {"score": 0.0021049977753042253, "phrase": "image_quality"}], "paper_keywords": ["ray tracing", " LODs", " cache coherence", " layouts", " kd-trees", " massive models"], "paper_abstract": "We present a novel LOD (level-of-detail) algorithm to accelerate ray tracing of massive models. Our approach computes drastic simplifications of the model and the LODs are well integrated with the kd-tree data structure. We introduce a simple and efficient LOD metric to bound the error for primary and secondary rays. The LOD representation has small runtime overhead and our algorithm can be combined with ray coherence techniques and cache-coherent layouts to improve the performance. In practice, the use of LODs can alleviate aliasing artifacts and improve memory coherence. We implement our algorithm on both 32-bit and 64-bit machines and are able to achieve up to 2-20 times improvement in frame rate of rendering models consisting of tens or hundreds of millions of triangles with little loss in image quality.", "paper_title": "R-LODs: fast LOD-based ray tracing of massive models", "paper_id": "WOS:000240381000020"}