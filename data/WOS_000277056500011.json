{"auto_keywords": [{"score": 0.03278829389315602, "phrase": "function-level_searches"}, {"score": 0.0047310525657970615, "phrase": "optimization_phase_sequence_searches"}, {"score": 0.004628223381645729, "phrase": "compiler_optimization_phase"}, {"score": 0.004468304427278713, "phrase": "compiler_developers"}, {"score": 0.004257360656055417, "phrase": "code_size"}, {"score": 0.00416478405812793, "phrase": "cost-constrained_domain"}, {"score": 0.004074212307838049, "phrase": "different_sequences"}, {"score": 0.0040385352882334235, "phrase": "optimization_phases"}, {"score": 0.003916098498242888, "phrase": "best_performance"}, {"score": 0.0038818006513785977, "phrase": "different_applications"}, {"score": 0.003847802030433298, "phrase": "compiler_writers"}, {"score": 0.0038141000450978746, "phrase": "embedded_systems_developers"}, {"score": 0.003682207422331339, "phrase": "iterative_empirical_searches"}, {"score": 0.0036499505265403377, "phrase": "machine-learning_based_heuristic_algorithms"}, {"score": 0.003539252646181146, "phrase": "phase_sequences"}, {"score": 0.0033131804981786747, "phrase": "program_level"}, {"score": 0.003170520716404193, "phrase": "function_level"}, {"score": 0.0031289290660162145, "phrase": "finer_granularity"}, {"score": 0.0030206579994328975, "phrase": "greater_overall_performance_benefits"}, {"score": 0.0029161225023394363, "phrase": "slower_searches"}, {"score": 0.0028652153774536967, "phrase": "greater_number"}, {"score": 0.00284009509859163, "phrase": "performance_evaluations"}, {"score": 0.002790511479398411, "phrase": "expensive_program_simulations"}, {"score": 0.002682081928174866, "phrase": "performance_benefits"}, {"score": 0.0026121403051734744, "phrase": "function-level_approaches"}, {"score": 0.0024776677004255104, "phrase": "novel_search_algorithm"}, {"score": 0.0024451427672857458, "phrase": "distinct_function-level_searches"}, {"score": 0.0023294867572824147, "phrase": "potentially_unique_sequences"}, {"score": 0.0022290883852844057, "phrase": "enhanced_performance_benefits"}, {"score": 0.0021805201234139475, "phrase": "search-time_cost"}, {"score": 0.0021049977753042253, "phrase": "program-level_searches"}], "paper_keywords": ["Performance", " Measurements", " Algorithms", " Phase Ordering", " Genetic Algorithms"], "paper_abstract": "The issues of compiler optimization phase ordering and selection present important challenges to compiler developers in several domains, and in particular to the speed, code size, power, and cost-constrained domain of embedded systems. Different sequences of optimization phases have been observed to provide the best performance for different applications. Compiler writers and embedded systems developers have recently addressed this problem by conducting iterative empirical searches using machine-learning based heuristic algorithms in an attempt to find the phase sequences that are most effective for each application. Such searches are generally performed at the program level, although a few studies have been performed at the function level. The finer granularity of function-level searches has the potential to provide greater overall performance benefits, but only at the cost of slower searches caused by a greater number of performance evaluations that often require expensive program simulations. In this paper, we evaluate the performance benefits and search time increases of function-level approaches as compared to their program-level counterparts. We, then, present a novel search algorithm that conducts distinct function-level searches simultaneously, but requires only a single program simulation for evaluating the performance of potentially unique sequences for each function. Thus, our new hybrid search strategy provides the enhanced performance benefits of function-level searches with a search-time cost that is comparable to or less than program-level searches.", "paper_title": "Improving Both the Performance Benefits and Speed of Optimization Phase Sequence Searches", "paper_id": "WOS:000277056500011"}