{"auto_keywords": [{"score": 0.03399273535727023, "phrase": "type_system"}, {"score": 0.00481495049065317, "phrase": "hybrid_synchronous_language"}, {"score": 0.0047804843375940835, "phrase": "hybrid_modelers"}, {"score": 0.004729262510294508, "phrase": "simulink"}, {"score": 0.00467855218490191, "phrase": "corner_stones"}, {"score": 0.004645057834614705, "phrase": "embedded_systems_development"}, {"score": 0.004562362497952548, "phrase": "discrete_controllers"}, {"score": 0.00443308765153716, "phrase": "single_language"}, {"score": 0.0040086845241492424, "phrase": "continuous_part"}, {"score": 0.0038810583785936505, "phrase": "numerical_solver"}, {"score": 0.0038256426589560774, "phrase": "discrete_part"}, {"score": 0.003397535839387366, "phrase": "conservative_extension"}, {"score": 0.003373181367365139, "phrase": "data-flow_equations"}, {"score": 0.003313053707792957, "phrase": "ordinary_differential_equations"}, {"score": 0.003253994336864267, "phrase": "possible_reset"}, {"score": 0.003150319576043518, "phrase": "discrete_computations"}, {"score": 0.0031277316566463978, "phrase": "continuous_ones"}, {"score": 0.002942138511829811, "phrase": "non-standard_analysis"}, {"score": 0.002900090135006575, "phrase": "synchronous_interpretation"}, {"score": 0.0028689475587958917, "phrase": "whole_language"}, {"score": 0.0026315183701883437, "phrase": "extended_data-flow_language"}, {"score": 0.002584576723303367, "phrase": "source-to-source_transformation"}, {"score": 0.00247529638625566, "phrase": "existing_tools"}, {"score": 0.0023033100935570755, "phrase": "single_off-the-shelf_numerical_solver"}, {"score": 0.0022298571016688335, "phrase": "causally-related_cascades"}, {"score": 0.0021049977753042253, "phrase": "sundials_library"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Real-time systems", " Hybrid systems", " Synchronous languages", " Block diagrams", " Compilation", " Semantics", " Type systems"], "paper_abstract": "Hybrid modelers such as SIMULINK have become corner stones of embedded systems development. They allow both discrete controllers and their continuous environments to be expressed in a single language. Despite the availability of such tools, there remain a number of issues related to the lack of reproducibility of simulations and to the separation of the continuous part, which has to be exercised by a numerical solver, from the discrete part, which must be guaranteed not to evolve during a step. Starting from a minimal, yet full-featured, LUSTRE-like synchronous language, this paper presents a conservative extension where data-flow equations can be mixed with ordinary differential equations (ODEs) with possible reset. A type system is proposed to statically distinguish discrete computations from continuous ones and to ensure that signals are used in their proper domains. We propose a semantics based on non-standard analysis which gives a synchronous interpretation to the whole language, clarifies the discrete/continuous interaction and the treatment of zero-crossings, and also allows the correctness of the type system to be established. The extended data-flow language is realized through a source-to-source transformation into a synchronous subset, which can then be compiled using existing tools into routines that are both efficient and bounded in their use of memory. These routines are orchestrated with a single off-the-shelf numerical solver using a simple but precise algorithm which treats causally-related cascades of zero-crossings. We have validated the viability of the approach through experiments with the SUNDIALS library.", "paper_title": "Divide and Recycle: Types and Compilation for a Hybrid Synchronous Language", "paper_id": "WOS:000294608700007"}