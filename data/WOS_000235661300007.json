{"auto_keywords": [{"score": 0.03848444673798997, "phrase": "total_flow_time"}, {"score": 0.03608025052346447, "phrase": "leonardi"}, {"score": 0.011892194330666055, "phrase": "parallel_machines"}, {"score": 0.011130093080860944, "phrase": "raz"}, {"score": 0.010767280963601642, "phrase": "srpt"}, {"score": 0.00481495049065317, "phrase": "preemptive_total_flow_time_approximation"}, {"score": 0.004674333455266527, "phrase": "classical_problem"}, {"score": 0.004639822587124109, "phrase": "scheduling_jobs"}, {"score": 0.004471035765089235, "phrase": "flow_time"}, {"score": 0.004167001961564886, "phrase": "online_settings"}, {"score": 0.0037700424606538856, "phrase": "scheduling_algorithm"}, {"score": 0.0035403928352411057, "phrase": "np"}, {"score": 0.0033110234463504125, "phrase": "well_known_heuristic_shortest_remaining_processing_time"}, {"score": 0.0032261342460565457, "phrase": "logarithmic_factor"}, {"score": 0.003190420554790267, "phrase": "optimal_offline_algorithm"}, {"score": 0.0030856268625708695, "phrase": "better_approximation_factors"}, {"score": 0.002951220859491642, "phrase": "online_algorithm"}, {"score": 0.0029077288662492894, "phrase": "best_known_algorithm"}, {"score": 0.002875529792120695, "phrase": "off-line_setting"}, {"score": 0.0028017745468000587, "phrase": "on-line_setting"}, {"score": 0.0025916375737852506, "phrase": "nicer_and_simpler_proof"}, {"score": 0.002562929776267296, "phrase": "approximation_ratio"}, {"score": 0.002543967867030228, "phrase": "srpt."}, {"score": 0.0024421501497321027, "phrase": "original_paper"}, {"score": 0.0023270490574896804, "phrase": "later_paper"}, {"score": 0.002284234786840546, "phrase": "job_preemption"}, {"score": 0.0021049977753042253, "phrase": "processing_time"}], "paper_keywords": [""], "paper_abstract": "We consider the classical problem of scheduling jobs in a multiprocessor setting in order to minimize the flow time (total time in the system). The performance of the algorithm, both in offline and online settings, can be significantly improved if we allow preemption: i.e., interrupt a job and later continue its execution. Preemption is inherent to make a scheduling algorithm efficient [7,8]. Minimizing the total flow time on parallel machines with preemption is known to be NP-hard on m >= 2 machines. Leonardi and Raz [8] showed that the well known heuristic shortest remaining processing time (SRPT) performs within a logarithmic factor of the optimal offline algorithm on parallel machines. It is not known if better approximation factors can be reached and thus SRPT, although it is an online algorithm, becomes the best known algorithm in the off-line setting. In fact, in the on-line setting, Leonardi and Raz showed that no algorithm can achieve a better bound. In this work we present a nicer and simpler proof of the approximation ratio of SRPT. The proof presented in this paper combines techniques from the original paper of Leonardi and Raz [8] with those presented in a later paper on approximating total flow time when job preemption but not job migration is allowed [2] and on approximating total flow time non- clairvoyantly [3], that is when the processing time of a job is only known at time of completion.", "paper_title": "A simpler proof of preemptive total flow time approximation on parallel machines", "paper_id": "WOS:000235661300007"}