{"auto_keywords": [{"score": 0.02998999927405984, "phrase": "hand-optimized_code"}, {"score": 0.00481495049065317, "phrase": "reliable_generation_of_high-performance_matrix_algebra"}, {"score": 0.004752221133109136, "phrase": "scientific_programmers"}, {"score": 0.00462919213721188, "phrase": "vendor-tuned_basic_linear_algebra_subprograms"}, {"score": 0.004450568197899267, "phrase": "portable_high_performance"}, {"score": 0.00406001734835979, "phrase": "successive_calls"}, {"score": 0.003954837422946628, "phrase": "optimal_performance"}, {"score": 0.003877737556673229, "phrase": "entire_sequence"}, {"score": 0.003631390978147703, "phrase": "vendor-tuned_blas"}, {"score": 0.003468287913322255, "phrase": "source_code"}, {"score": 0.003423140833908326, "phrase": "fortran"}, {"score": 0.0031429517477457925, "phrase": "state-of-the-art_optimizing_compiler"}, {"score": 0.002982068153662372, "phrase": "optimizing_compilers"}, {"score": 0.00266693888510356, "phrase": "domain-specific_compiler"}, {"score": 0.0025137964661296705, "phrase": "blas"}, {"score": 0.0023850311572318496, "phrase": "high_performance"}, {"score": 0.0023384629381463054, "phrase": "scalable_search_algorithm"}, {"score": 0.0022777800735119405, "phrase": "best_combination"}, {"score": 0.0022480304016499605, "phrase": "loop_fusion"}, {"score": 0.002218668420806254, "phrase": "array_contraction"}, {"score": 0.002146926767291475, "phrase": "data_parallelism"}, {"score": 0.0021049977753042253, "phrase": "bto_compiler"}], "paper_keywords": ["Languages", " Performance", " Autotuning", " domain-specific languages", " linear algebra", " genetic algorithms"], "paper_abstract": "Scientific programmers often turn to vendor-tuned Basic Linear Algebra Subprograms (BLAS) to obtain portable high performance. However, many numerical algorithms require several BLAS calls in sequence, and those successive calls do not achieve optimal performance. The entire sequence needs to be optimized in concert. Instead of vendor-tuned BLAS, a programmer could start with source code in Fortran or C (e.g., based on the Netlib BLAS) and use a state-of-the-art optimizing compiler. However, our experiments show that optimizing compilers often attain only one-quarter of the performance of hand-optimized code. In this article, we present a domain-specific compiler for matrix kernels, the Build to Order BLAS (BTO), that reliably achieves high performance using a scalable search algorithm for choosing the best combination of loop fusion, array contraction, and multithreading for data parallelism. The BTO compiler generates code that is between 16% slower and 39% faster than hand-optimized code.", "paper_title": "Reliable Generation of High-Performance Matrix Algebra", "paper_id": "WOS:000355670800006"}