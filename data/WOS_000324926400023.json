{"auto_keywords": [{"score": 0.027507999683207576, "phrase": "udi"}, {"score": 0.014921834787303388, "phrase": "logic_programming"}, {"score": 0.014050675926286898, "phrase": "prolog_system"}, {"score": 0.00481495049065317, "phrase": "udi."}, {"score": 0.004718431349852634, "phrase": "large_data-sets_poses"}, {"score": 0.004512814529823301, "phrase": "first_approach"}, {"score": 0.004422325007817267, "phrase": "relational_database"}, {"score": 0.003996271202811961, "phrase": "main_memory"}, {"score": 0.003884479830773329, "phrase": "substantial_overheads"}, {"score": 0.003700037700138249, "phrase": "large_data-sets"}, {"score": 0.0036553070575015344, "phrase": "efficient_way"}, {"score": 0.0035386420095120706, "phrase": "processing_time"}, {"score": 0.0034817084307034955, "phrase": "time_indexing"}, {"score": 0.003236596168242036, "phrase": "exo-compilation"}, {"score": 0.003158776195052182, "phrase": "large_tables"}, {"score": 0.003107935254560724, "phrase": "next_step"}, {"score": 0.003020918749760067, "phrase": "memory_footprint"}, {"score": 0.002831037222426215, "phrase": "significant_advantages"}, {"score": 0.0027741761880779535, "phrase": "memory_usage"}, {"score": 0.0027184540871935284, "phrase": "execution_time"}, {"score": 0.002685558057339722, "phrase": "alternative_path"}, {"score": 0.0026103363762901423, "phrase": "user-defined_indexing"}, {"score": 0.002506507889886399, "phrase": "specialized_indexing"}, {"score": 0.0024862418814045723, "phrase": "specific_applications"}, {"score": 0.0024461989110005447, "phrase": "spatial_indexing"}, {"score": 0.002406799309495983, "phrase": "spatial_system"}, {"score": 0.00233936726307301, "phrase": "pluggable_modules"}, {"score": 0.0021049977753042253, "phrase": "high-performance_indexers"}], "paper_keywords": [""], "paper_abstract": "The widespread availability of large data-sets poses both an opportunity and a challenge to logic programming. A first approach is to couple a relational database with logic programming, say, a Prolog system with MySQL. While this approach does pay off in cases where the data cannot reside in main memory, it is known to introduce substantial overheads. Ideally, we would like the Prolog system to deal with large data-sets in an efficient way both in terms of memory and of processing time. Just In Time Indexing (JITI) was mainly motivated by this challenge, and can work quite well in many application. Exo-compilation, designed to deal with large tables, is a next step that achieves very interesting results, reducing the memory footprint over two thirds. We show that combining exo-compilation with Just In Time Indexing can have significant advantages both in terms of memory usage and in terms of execution time. An alternative path that is relevant for many applications is User-Defined Indexing (UDI). This allows the use of specialized indexing for specific applications, say the spatial indexing crucial to any spatial system. The UDI sees indexing as pluggable modules, and can naturally be combined with Exo-compilation. We do so by using UDI with exo-data, and incorporating ideas from the UDI into high-performance indexers for specific tasks.", "paper_title": "BigYAP: Exo-compilation meets UDI", "paper_id": "WOS:000324926400023"}