{"auto_keywords": [{"score": 0.04886502274223977, "phrase": "determinate_concurrency"}, {"score": 0.00481495049065317, "phrase": "synchronous_model"}, {"score": 0.00473320761888448, "phrase": "synchronous_languages"}, {"score": 0.004326188427877999, "phrase": "sequential_languages"}, {"score": 0.004234649319236325, "phrase": "java"}, {"score": 0.0037398106866046972, "phrase": "synchronous_execution_model"}, {"score": 0.0034179225740833055, "phrase": "classical_synchronous_moc"}, {"score": 0.0030573959252626695, "phrase": "sufficient_scheduling_information"}, {"score": 0.0030054007508185858, "phrase": "race_conditions"}, {"score": 0.002929056388593134, "phrase": "programming_patterns"}, {"score": 0.0028916124463906983, "phrase": "sequential_programming"}, {"score": 0.002665305036900055, "phrase": "standard_synchronous_moc."}, {"score": 0.0026425357050743003, "phrase": "sc_moc"}, {"score": 0.002608744950946475, "phrase": "conservative_extension"}, {"score": 0.0025207284405252914, "phrase": "common_synchronous_moc"}, {"score": 0.0023434058350520763, "phrase": "shared_variable_accesses"}, {"score": 0.0023134312557290043, "phrase": "sc-admissible_scheduling"}, {"score": 0.002264321283759897, "phrase": "\"free_scheduling"}, {"score": 0.0021973099304606076, "phrase": "sequential_constructiveness"}, {"score": 0.002150659690967412, "phrase": "priority-based_scheduling_algorithm"}, {"score": 0.0021049977753042253, "phrase": "sc_programs"}], "paper_keywords": ["Theory", " Languages", " Algorithms", " Concurrency", " constructiveness", " determinacy", " determinism", " embedded systems", " Esterel", " reactive systems", " synchronous languages"], "paper_abstract": "Synchronous languages ensure determinate concurrency but at the price of restrictions on what programs are considered valid, or constructive. Meanwhile, sequential languages such as C and Java offer an intuitive, familiar programming paradigm but provide no guarantees with regard to determinate concurrency. The sequentially constructive (SC) model of computation (MoC) presented here harnesses the synchronous execution model to achieve determinate concurrency while taking advantage of familiar, convenient programming paradigms from sequential languages. In essence, the SC MoC extends the classical synchronous MoC by allowing variables to be read and written in any order and multiple times, as long as the sequentiality expressed in the program provides sufficient scheduling information to rule out race conditions. This allows to use programming patterns familiar from sequential programming, such as testing and later setting the value of a variable, which are forbidden in the standard synchronous MoC. The SC MoC is a conservative extension in that programs considered constructive in the common synchronous MoC are also SC and retain the same semantics. In this article, we investigate classes of shared variable accesses, define SC-admissible scheduling as a restriction of \"free scheduling,\" derive the concept of sequential constructiveness, and present a priority-based scheduling algorithm for analyzing and compiling SC programs efficiently.", "paper_title": "Sequentially Constructive Concurrency-A Conservative Extension of the Synchronous Model of Computation", "paper_id": "WOS:000341390100027"}