{"auto_keywords": [{"score": 0.03902269339461907, "phrase": "intrinsic_encodings"}, {"score": 0.00481495049065317, "phrase": "typed_term_representations"}, {"score": 0.004575053987970206, "phrase": "typed_object_languages"}, {"score": 0.004516962628112147, "phrase": "proof_assistant"}, {"score": 0.0044786435725543685, "phrase": "programming_language"}, {"score": 0.004421770937919324, "phrase": "extrinsic_approach"}, {"score": 0.004255431326383001, "phrase": "untyped_object_expressions"}, {"score": 0.0041657281535389615, "phrase": "separate_definition"}, {"score": 0.004060566667226606, "phrase": "untyped_terms"}, {"score": 0.004008981656795115, "phrase": "intrinsic_approach"}, {"score": 0.0039244530915794025, "phrase": "single_definition"}, {"score": 0.00387459052649752, "phrase": "well-typed_object_expressions"}, {"score": 0.0038253590626087237, "phrase": "ill-typed_expressions"}, {"score": 0.003423969509052361, "phrase": "respect_object_types"}, {"score": 0.0033232673019931206, "phrase": "metalanguage_types"}, {"score": 0.003239304090565123, "phrase": "non-trivial_dependency"}, {"score": 0.0031981188104809994, "phrase": "significant_complexity"}, {"score": 0.003130633384437765, "phrase": "intrinsic-style_formalizations"}, {"score": 0.0030908254851076005, "phrase": "simply-typed_and_polymorphic_languages"}, {"score": 0.0029617414861784525, "phrase": "coq_proof_assistant"}, {"score": 0.002924074850256874, "phrase": "coq_types"}, {"score": 0.0028992294924613327, "phrase": "object-level_variables"}, {"score": 0.0027311076665349657, "phrase": "typing_environment"}, {"score": 0.0025291601927956765, "phrase": "similar_ones"}, {"score": 0.0024969812322112174, "phrase": "simpler_notion"}, {"score": 0.002433843373780471, "phrase": "simply-typed_case"}, {"score": 0.0023123057299992587, "phrase": "type_equality_coercions"}, {"score": 0.0022731540640627307, "phrase": "polymorphic_case"}, {"score": 0.0022442249871042026, "phrase": "substitution_operations"}, {"score": 0.0022062235065459274, "phrase": "type_coercions"}, {"score": 0.002123051344001408, "phrase": "uniform_use"}, {"score": 0.0021049977753042253, "phrase": "heterogeneous_equality"}], "paper_keywords": ["The Coq proof assistant", " de Bruijn indices", " Typed object languages"], "paper_abstract": "There are two approaches to formalizing the syntax of typed object languages in a proof assistant or programming language. The extrinsic approach is to first define a type that encodes untyped object expressions and then make a separate definition of typing judgements over the untyped terms. The intrinsic approach is to make a single definition that captures well-typed object expressions, so ill-typed expressions cannot even be expressed. Intrinsic encodings are attractive and naturally enforce the requirement that metalanguage operations on object expressions, such as substitution, respect object types. The price is that the metalanguage types of intrinsic encodings and operations involve non-trivial dependency, adding significant complexity. This paper describes intrinsic-style formalizations of both simply-typed and polymorphic languages, and basic syntactic operations thereon, in the Coq proof assistant. The Coq types encoding object-level variables (de Bruijn indices) and terms are indexed by both type and typing environment. One key construction is the boot-strapping of definitions and lemmas about the action of substitutions in terms of similar ones for a simpler notion of renamings. In the simply-typed case, this yields definitions that are free of any use of type equality coercions. In the polymorphic case, some substitution operations do still require type coercions, which we at least partially tame by uniform use of heterogeneous equality.", "paper_title": "Strongly Typed Term Representations in Coq", "paper_id": "WOS:000305832500003"}