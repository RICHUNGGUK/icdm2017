{"auto_keywords": [{"score": 0.03534873591980855, "phrase": "synchronous_networks"}, {"score": 0.014540690236857511, "phrase": "distributed_local_proofs"}, {"score": 0.014297456264221332, "phrase": "time_complexity"}, {"score": 0.010863652829183428, "phrase": "asynchronous_ones"}, {"score": 0.00989728604665758, "phrase": "required_detection_time"}, {"score": 0.00481495049065317, "phrase": "fast_and_compact_self-stabilizing_verification"}, {"score": 0.004653667500876187, "phrase": "distributed_local_verification"}, {"score": 0.004545915940478968, "phrase": "self-stabilizing_algorithms"}, {"score": 0.004469114481190944, "phrase": "somewhat_generalized_notion"}, {"score": 0.004328576620172575, "phrase": "space_optimality"}, {"score": 0.004228320275779304, "phrase": "memory_size"}, {"score": 0.0037128955884188773, "phrase": "local_proofs"}, {"score": 0.0036579053062085424, "phrase": "memory_efficiency"}, {"score": 0.0032810180076973806, "phrase": "maximum_degree"}, {"score": 0.0032324033471059347, "phrase": "open_problem"}, {"score": 0.003211788912325178, "phrase": "awerbuch_et_al"}, {"score": 0.0028562555601272634, "phrase": "known_transformer"}, {"score": 0.0027722039149189136, "phrase": "efficient_construction_algorithm"}, {"score": 0.002754516260621121, "phrase": "efficient_self-stabilizing_proof_labeling_scheme"}, {"score": 0.00272528658234627, "phrase": "efficient_self-stabilizing_algorithm"}, {"score": 0.00269639111869875, "phrase": "mst"}, {"score": 0.0026620655619396263, "phrase": "memory_optimal_self-stabilizing_algorithm"}, {"score": 0.002572709810193776, "phrase": "previous_algorithms"}, {"score": 0.0025562917369603144, "phrase": "previous_mst_algorithms"}, {"score": 0.002539978170928796, "phrase": "memory_bits"}, {"score": 0.0024916579184315404, "phrase": "optimal_space_algorithms"}], "paper_keywords": ["Distributed network algorithms", " Locality", " Proof labels", " Minimum spanning tree", " Distributed property verification", " Self-stabilization", " Fast fault detection", " Local fault detection"], "paper_abstract": "This paper demonstrates the usefulness of distributed local verification of proofs, as a tool for the design of self-stabilizing algorithms. In particular, it introduces a somewhat generalized notion of distributed local proofs, and utilizes it for improving the time complexity significantly, while maintaining space optimality. As a result, we show that optimizing the memory size carries at most a small cost in terms of time, in the context of minimum spanning tree (MST). That is, we present algorithms that are both time and space efficient for both constructing an MST and for verifying it. This involves several parts that may be considered contributions in themselves. First, we generalize the notion of local proofs, trading off the time complexity for memory efficiency. This adds a dimension to the study of distributed local proofs, which has been gaining attention recently. Specifically, we design a (self-stabilizing) proof labeling scheme which is memory optimal (i.e., bits per node), and whose time complexity is in synchronous networks, or time in asynchronous ones, where is the maximum degree of nodes. This answers an open problem posed by Awerbuch et al. (1991). We also show that time is necessary, even in synchronous networks. Another property is that if faults occurred, then, within the required detection time above, they are detected by some node in the locality of each of the faults. Second, we show how to enhance a known transformer that makes input/output algorithms self-stabilizing. It now takes as input an efficient construction algorithm and an efficient self-stabilizing proof labeling scheme, and produces an efficient self-stabilizing algorithm. When used for MST, the transformer produces a memory optimal self-stabilizing algorithm, whose time complexity, namely, , is significantly better even than that of previous algorithms (the time complexity of previous MST algorithms that used memory bits per node was , and the time for optimal space algorithms was ). Inherited from our proof labeling scheme, our self-stabilising MST construction algorithm also has the following two properties: (1) if faults occur after the construction ended, then they are detected by some nodes within time in synchronous networks, or within time in asynchronous ones, and (2) if faults occurred, then, within the required detection time above, they are detected within the locality of each of the faults. We also show how to improve the above two properties, at the expense of some increase in the memory.", "paper_title": "Fast and compact self-stabilizing verification, computation, and fault detection of an MST", "paper_id": "WOS:000358780800004"}