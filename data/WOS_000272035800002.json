{"auto_keywords": [{"score": 0.03984961577718066, "phrase": "reduction_rules"}, {"score": 0.00481495049065317, "phrase": "lambda_context_calculus"}, {"score": 0.004448263134790434, "phrase": "substitution"}, {"score": 0.004385733482617193, "phrase": "strong_variable"}, {"score": 0.004166129325245761, "phrase": "weaker_variable"}, {"score": 0.003741712498615481, "phrase": "'vanilla'_lambda-calculus"}, {"score": 0.003689628075766217, "phrase": "simple_and_modular_way"}, {"score": 0.0035376693476114733, "phrase": "standard_lambda-calculus"}, {"score": 0.0034559594248079807, "phrase": "good_properties"}, {"score": 0.003329117824699891, "phrase": "lamcc"}, {"score": 0.0031328221096543823, "phrase": "untyped_lambda-calculus_exists"}, {"score": 0.002948066398723126, "phrase": "full_proofs"}, {"score": 0.002800247197692108, "phrase": "functional_binding_splits"}, {"score": 0.0027612315954598085, "phrase": "functional_abstraction"}, {"score": 0.0026722904884984348, "phrase": "name-binder_tf"}, {"score": 0.0023223663501882917, "phrase": "global_state"}, {"score": 0.002226592967032469, "phrase": "contextual_equivalence"}, {"score": 0.0021649437083408425, "phrase": "function_application"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Lambda-calculus", " Calculi of contexts", " Functional programming", " Binders", " Nominal techniques", " Explicit substitutions", " Capturing substitution"], "paper_abstract": "We present the Lambda Context Calculus. This simple lambda-calculus features variables arranged in a hierarchy of strengths such that Substitution of a strong variable does not avoid capture with respect to abstraction by a weaker variable. This allows the calculus to express both capture-avoiding and capturing substitution (instantiation). The reduction rules extend the 'vanilla' lambda-calculus in a simple and modular way and preserve the look and feel of a standard lambda-calculus with explicit substitutions. Good properties of the lambda-calculus are preserved. The LamCC is confluent, and a natural injection into the LamCC of the untyped lambda-calculus exists and preserves strong normalisation. We discuss the calculus and its design with full proofs. In the presence of the hierarchy of variables, functional binding splits into a functional abstraction lambda (lambda) and a name-binder tf (sic)(new). We investigate how the components of this calculus interact with each other and with the reduction rules, with examples. In two more extended case studies we demonstrate how global state can be expressed, and how contexts and contextual equivalence can be naturally internalised using function application. (C) 2009 Elsevier Inc. All rights reserved.", "paper_title": "The lambda-context calculus (extended version)", "paper_id": "WOS:000272035800002"}