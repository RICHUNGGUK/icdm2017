{"auto_keywords": [{"score": 0.0455466088830923, "phrase": "temporal_locality"}, {"score": 0.036590546733605435, "phrase": "function_calls"}, {"score": 0.026958233193937944, "phrase": "execution_time"}, {"score": 0.00481495049065317, "phrase": "locality-improving_refactorings"}, {"score": 0.004775335634705251, "phrase": "reuse_path_analysis"}, {"score": 0.004677711903652145, "phrase": "huge_speed_gaps"}, {"score": 0.004620093797504386, "phrase": "memory_hierarchy"}, {"score": 0.0045820747375409435, "phrase": "modern_computer_architectures"}, {"score": 0.004414806639101985, "phrase": "good_data_locality"}, {"score": 0.004253618550301311, "phrase": "data_reuses"}, {"score": 0.004132312946154097, "phrase": "best_existing_tools"}, {"score": 0.004098291340525772, "phrase": "locality_bottlenecks"}, {"score": 0.003948613642680196, "phrase": "subsequent_cache-missing_reuse"}, {"score": 0.003820144626025562, "phrase": "bottleneck_locations"}, {"score": 0.003773049633656302, "phrase": "source_code"}, {"score": 0.0036352070472201086, "phrase": "effective_code"}, {"score": 0.003502382624110703, "phrase": "unclear_interaction"}, {"score": 0.003444912629614206, "phrase": "loop_iterations"}, {"score": 0.003171358146412577, "phrase": "locality_analysis"}, {"score": 0.0030680994147125364, "phrase": "cache_bottlenecks"}, {"score": 0.0029928611380840757, "phrase": "code_refactorings"}, {"score": 0.0028360962841331634, "phrase": "dynamic_hierarchy"}, {"score": 0.002755104031926742, "phrase": "code_path"}, {"score": 0.0025999744005191713, "phrase": "reuse_paths_results"}, {"score": 0.0025678829712650437, "phrase": "significant_reduction"}, {"score": 0.0024232694434408093, "phrase": "realistic_programs"}, {"score": 0.002315367926547472, "phrase": "locality_optimizations"}, {"score": 0.0021049977753042253, "phrase": "selected_programs"}], "paper_keywords": [""], "paper_abstract": "Due to the huge speed gaps in the memory hierarchy of modern computer architectures, it is important that programs maintain a good data locality. Improving temporal locality implies reducing the distance of data reuses that are far apart. The best existing tools indicate locality bottlenecks by highlighting both the source locations generating the use and the subsequent cache-missing reuse. Even with this knowledge of the bottleneck locations in the source code, it often remains hard to find an effective code refactoring that improves temporal locality, due to the unclear interaction of function calls and loop iterations occurring between use and reuse. The contributions in this paper are two-fold. First, the locality analysis is enhanced to not only pinpoint the cache bottlenecks, but to also suggest code refactorings that may resolve them. The refactorings are found by analyzing the dynamic hierarchy of function calls and loops on the code path between reuses, called reuse paths. Secondly, reservoir sampling of the reuse paths results in a significant reduction of the execution time and memory requirements during profiling, enabling the analysis of realistic programs. An interactive GUI, called SLO (Suggestions for Locality Optimizations), has been used to explore the most appropriate refactorings in a number of SPEC2000 programs. After refactoring, the execution time of the selected programs was halved, on the average.", "paper_title": "Discovery of locality-improving refactorings by reuse path analysis", "paper_id": "WOS:000241591300023"}