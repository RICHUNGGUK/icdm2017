{"auto_keywords": [{"score": 0.03482174305944775, "phrase": "large_characteristic"}, {"score": 0.00481495049065317, "phrase": "lacunary_perfect_powers"}, {"score": 0.0037789720824759503, "phrase": "monte_carlo_randomized_algorithm"}, {"score": 0.0036596534390380287, "phrase": "non-zero_terms"}, {"score": 0.0034444213065548688, "phrase": "lacunary_representation"}, {"score": 0.0031170783606525856, "phrase": "root_h"}, {"score": 0.002830839166653185, "phrase": "sparsity-sensitive_newton_iteration"}, {"score": 0.0027708785175203556, "phrase": "second_approach"}, {"score": 0.002751174423568564, "phrase": "computing_h"}, {"score": 0.0025343769150179764, "phrase": "number-theoretic_conjecture"}, {"score": 0.002498527227286441, "phrase": "erdos"}, {"score": 0.0024806900500356148, "phrase": "schinzel"}, {"score": 0.00246304736237201, "phrase": "zannier"}, {"score": 0.0023180144105895257, "phrase": "lacunary_size"}, {"score": 0.0022933216359142736, "phrase": "input_polynomial_f."}, {"score": 0.002220806891955454, "phrase": "randomized_detection_algorithm"}, {"score": 0.0021971473452127126, "phrase": "latter_perfect_root_computation_algorithm"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Sparse/lacunary polynomial", " Perfect power", " Black-box computation"], "paper_abstract": "We consider solutions to the equation f = h(r) for polynomials f and h and integer r >= 2. Given a polynomial f in the lacunary (also called sparse or super-sparse) representation, we first show how to determine if f can be written as hr and, if so, to find such an r. This is a Monte Carlo randomized algorithm whose cost is polynomial in the number of non-zero terms of f and in log deg f, i.e., polynomial in the size of the lacunary representation, and it works over F-q [x] (for large characteristic) as well as Q[x]. We also give two deterministic algorithms to compute the perfect root h given f and r. The first is output-sensitive (based on the sparsity of h) and works only over Q[x]. A sparsity-sensitive Newton iteration forms the basis for the second approach to computing h, which is extremely efficient and works over both F-q[x] (for large characteristic) and Q[x], but depends on a number-theoretic conjecture. Work of Erdos, Schinzel, Zannier, and others suggests that both of these algorithms are unconditionally polynomial-time in the lacunary size of the input polynomial f. Finally, we demonstrate the efficiency of the randomized detection algorithm and the latter perfect root computation algorithm with an implementation in the C++ library NTL. (C) 2011 Elsevier Ltd. All rights reserved.", "paper_title": "Detecting lacunary perfect powers and computing their roots", "paper_id": "WOS:000297446800004"}