{"auto_keywords": [{"score": 0.050078458624386674, "phrase": "reuse_locality"}, {"score": 0.04891516735102203, "phrase": "replacement_policy"}, {"score": 0.03848205523283893, "phrase": "rereference_interval_prediction"}, {"score": 0.03770544718188539, "phrase": "inclusive_sllcs"}, {"score": 0.03157812967874103, "phrase": "nrr"}, {"score": 0.0309363403846303, "phrase": "nru"}, {"score": 0.004781215097314411, "phrase": "inclusive_shared_last-level_caches"}, {"score": 0.00440976345264104, "phrase": "chip_accesses"}, {"score": 0.004378854464130883, "phrase": "temporal_locality"}, {"score": 0.004287415750101536, "phrase": "first_levels"}, {"score": 0.004257360656055417, "phrase": "private_cache_memories"}, {"score": 0.004052769207704492, "phrase": "sllc."}, {"score": 0.0040102178375662914, "phrase": "traditional_replacement_algorithms"}, {"score": 0.003940286428597882, "phrase": "bad_choices"}, {"score": 0.0038989120088094185, "phrase": "sllc_replacement"}, {"score": 0.0038715697646612766, "phrase": "recent_proposals"}, {"score": 0.0038444185258456245, "phrase": "sllc_replacement_policies"}, {"score": 0.00371148138781691, "phrase": "replacement_list"}, {"score": 0.0035206146304891973, "phrase": "cmp_market"}, {"score": 0.002890567951526303, "phrase": "lrr"}, {"score": 0.002800358658581207, "phrase": "lru_cost"}, {"score": 0.002609840513713399, "phrase": "multiprogrammed_workloads"}, {"score": 0.002537303919584199, "phrase": "sllc._lrr"}, {"score": 0.0022192898027958304, "phrase": "sllc"}, {"score": 0.0021805201234139475, "phrase": "similar_conclusions"}, {"score": 0.0021049977753042253, "phrase": "sllc_size"}], "paper_keywords": ["Design", " Performance", " Replacement policy", " shared resources management"], "paper_abstract": "Optimization of the replacement policy used for Shared Last-Level Cache (SLLC) management in a Chip-MultiProcessor (CMP) is critical for avoiding off-chip accesses. Temporal locality, while being exploited by first levels of private cache memories, is only slightly exhibited by the stream of references arriving at the SLLC. Thus, traditional replacement algorithms based on recency are bad choices for governing SLLC replacement. Recent proposals involve SLLC replacement policies that attempt to exploit reuse either by segmenting the replacement list or improving the rereference interval prediction. On the other hand, inclusive SLLCs are commonplace in the CMP market, but the interaction between replacement policy and the enforcement of inclusion has barely been discussed. After analyzing that interaction, this article introduces two simple replacement policies exploiting reuse locality and targeting inclusive SLLCs: Least Recently Reused (LRR) and Not Recently Reused (NRR). NRR has the same implementation cost as NRU, and LRR only adds one bit per line to the LRU cost. After considering reuse locality and its interaction with the invalidations induced by inclusion, the proposals are evaluated by simulating multiprogrammed workloads in an 8-core system with two private cache levels and an SLLC. LRR outperforms LRU by 4.5% (performing better in 97 out of 100 mixes) and NRR outperforms NRU by 4.2% (performing better in 99 out of 100 mixes). We also show that our mechanisms outperform rereference interval prediction, a recently proposed SLLC replacement policy and that similar conclusions can be drawn by varying the associativity or the SLLC size.", "paper_title": "Exploiting Reuse Locality on Inclusive Shared Last-Level Caches", "paper_id": "WOS:000313911800015"}