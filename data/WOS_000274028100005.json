{"auto_keywords": [{"score": 0.047358918256261234, "phrase": "concurrent_module"}, {"score": 0.038749692047715355, "phrase": "tree_locking"}, {"score": 0.03812983798224722, "phrase": "two-phase_locking"}, {"score": 0.00481495049065317, "phrase": "commonly_used_correctness_condition"}, {"score": 0.0039737570920809215, "phrase": "concurrent_modules"}, {"score": 0.0038112201846057445, "phrase": "standard_locking_protocols"}, {"score": 0.003418958653159371, "phrase": "existing_literature"}, {"score": 0.003092690568543981, "phrase": "concurrent_interleavings"}, {"score": 0.0027974705482714884, "phrase": "large_class"}, {"score": 0.002751075263422475, "phrase": "locking_protocols"}, {"score": 0.002426717832834137, "phrase": "main_consequence"}, {"score": 0.0021049977753042253, "phrase": "sequential_reasoning"}], "paper_keywords": ["Theory", " Verification", " Concurrency", " Verification", " Serializability", " Reduction", " Modular Analysis"], "paper_abstract": "Serializability is a commonly used correctness condition in concurrent programming. When a concurrent module is serializable, certain other properties of the module can be verified by considering only its sequential executions. In many cases, concurrent modules guarantee serializability by using standard locking protocols, such as tree locking or two-phase locking. Unfortunately, according to the existing literature, verifying that a concurrent module adheres to these protocols requires considering concurrent interleavings. In this paper, we show that adherence to a large class of locking protocols (including tree locking and two-phase locking) can be verified by considering only sequential executions. The main consequence of our results is that in many cases, the (manual or automatic) verification of serializability can itself be done using sequential reasoning.", "paper_title": "Sequential Verification of Serializability", "paper_id": "WOS:000274028100005"}