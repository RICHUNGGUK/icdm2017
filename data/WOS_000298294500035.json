{"auto_keywords": [{"score": 0.03217160122346609, "phrase": "coordination_problem"}, {"score": 0.00481495049065317, "phrase": "parallel_programming"}, {"score": 0.0047057084749407485, "phrase": "comprehensive_library"}, {"score": 0.004634254474150777, "phrase": "scalable_synchronization_primitives"}, {"score": 0.004494570360108983, "phrase": "essential_tool"}, {"score": 0.003797978200741566, "phrase": "concurrency_library"}, {"score": 0.0036553070575015344, "phrase": "gonthier's_join_calculus"}, {"score": 0.0035179764329354877, "phrase": "scalable_coordination"}, {"score": 0.00283870598459543, "phrase": "correct_solution"}, {"score": 0.002649472341607234, "phrase": "derived_solutions"}, {"score": 0.0026091594819333654, "phrase": "robust_performance"}, {"score": 0.0021872912745910127, "phrase": "seven_coordination_problems"}, {"score": 0.0021049977753042253, "phrase": "specialized_algorithms"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " message passing", " concurrency", " parallelism"], "paper_abstract": "Coordination can destroy scalability in parallel programming. A comprehensive library of scalable synchronization primitives is therefore an essential tool for exploiting parallelism. Unfortunately, such primitives do not easily combine to yield solutions to more complex problems. We demonstrate that a concurrency library based on Fournet and Gonthier's join calculus can provide declarative and scalable coordination. By declarative, we mean that the programmer needs only to write down the constraints of a coordination problem, and the library will automatically derive a correct solution. By scalable, we mean that the derived solutions deliver robust performance both as the number of processors increases, and as the complexity of the coordination problem grows. We validate our claims empirically on seven coordination problems, comparing our generic solution to specialized algorithms from the literature.", "paper_title": "Scalable Join Patterns", "paper_id": "WOS:000298294500035"}