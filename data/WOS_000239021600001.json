{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "protocol_verification"}, {"score": 0.004533427352547707, "phrase": "foci_proof_method"}, {"score": 0.0040186038781533946, "phrase": "proof_obligations"}, {"score": 0.0038825121288253435, "phrase": "data_objects"}, {"score": 0.0037188360359702182, "phrase": "original_cones"}, {"score": 0.0036553070575015344, "phrase": "foci_method"}, {"score": 0.0035928610354026102, "phrase": "groote"}, {"score": 0.003531474887552889, "phrase": "springintveld"}, {"score": 0.003130077012135034, "phrase": "preprocessing_step"}, {"score": 0.0026116610153271943, "phrase": "focus_points"}, {"score": 0.0023958337477050047, "phrase": "pvs."}, {"score": 0.0022360556250998072, "phrase": "mechanical_protocol_verification"}], "paper_keywords": ["protocol verification", " branching bisimulation", " process algebra", " PVS"], "paper_abstract": "We define a cones and foci proof method, which rephrases the question whether two system specifications are branching bisimilar in terms of proof obligations on relations between data objects. Compared to the original cones and foci method from Groote and Springintveld, our method is more generally applicable, because it does not require a preprocessing step to eliminate tau-loops. We prove soundness of our approach and present a set of rules to prove the reachability of focus points. Our method has been formalized and proved correct using PVS. Thus we have established a framework for mechanical protocol verification. We apply this framework to the Concurrent Alternating Bit Protocol.", "paper_title": "Cones and foci: A mechanical framework for protocol verification", "paper_id": "WOS:000239021600001"}