{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "type_theory"}, {"score": 0.004518442937844318, "phrase": "constructive_type_theory"}, {"score": 0.00445506209373501, "phrase": "bitonic"}, {"score": 0.004270178957872099, "phrase": "fastest_sorting_algorithms"}, {"score": 0.003760137090849196, "phrase": "general_recursive_algorithm"}, {"score": 0.003334309053314909, "phrase": "formal_proof"}, {"score": 0.00310664242361199, "phrase": "quite_a_number"}, {"score": 0.0028740705307540317, "phrase": "dependently-typed_binary_trees"}, {"score": 0.002391067964886602, "phrase": "linear_orders"}, {"score": 0.002357457094026928, "phrase": "lattice_theory"}, {"score": 0.002275477757478827, "phrase": "correctness_proof"}, {"score": 0.002180848602315088, "phrase": "ordered_set"}, {"score": 0.0021049977753042253, "phrase": "boolean_values"}], "paper_keywords": [""], "paper_abstract": "We discuss two complete formalisations of bitonic sort in constructive type theory, Bitonic sort is one of the fastest sorting algorithms where the sequence of comparisons is not data-dependent. In addition, it is a general recursive algorithm. In the formalisation we face two main problems: only structural recursion is allowed in type theory, and a formal proof of the correctness of the algorithm needs to consider quite a number of cases. In our first formalisation we define bitonic sort over dependently-typed binary trees with information in the leaves and we make use of the 0-1-principle to prove that the algorithm sorts inputs of arbitrary types. In our second formalisation we use notions from linear orders, lattice theory and monoids. The correctness proof is directly performed for any ordered set and not only for Boolean values.", "paper_title": "Formalising bitonic sort in type theory", "paper_id": "WOS:000235656800006"}