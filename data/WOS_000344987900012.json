{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "application-specific_memories"}, {"score": 0.00468627326602559, "phrase": "memory_access_times"}, {"score": 0.004499647408293102, "phrase": "primary_bottleneck"}, {"score": 0.00414830454375092, "phrase": "\"memory_wall"}, {"score": 0.0038242899532391914, "phrase": "performance_disparity"}, {"score": 0.0037219886365287085, "phrase": "processor_cores"}, {"score": 0.0036224139706218916, "phrase": "main_memory"}, {"score": 0.00338493754743055, "phrase": "performance_gap"}, {"score": 0.0030783143919343972, "phrase": "custom_memory_subsystems"}, {"score": 0.0025456716198597627, "phrase": "fixed_memory_subsystem"}, {"score": 0.0024774888010414206, "phrase": "custom_subsystems"}, {"score": 0.0023148964315569866, "phrase": "application-specific_properties"}, {"score": 0.0021925226977381244, "phrase": "memory-specific_properties"}, {"score": 0.0021049977753042253, "phrase": "access_times"}], "paper_keywords": [""], "paper_abstract": "Memory access times are the primary bottleneck for many applications today. This \"memory wall\" is due to the performance disparity between processor cores and main memory. To address the performance gap, we propose the use of custom memory subsystems tailored to the application rather than attempting to optimize the application for a fixed memory subsystem. Custom subsystems can take advantage of application-specific properties as well as memory-specific properties to improve access times or write-backs given constraints on size or power.", "paper_title": "Optimization of Application-Specific Memories", "paper_id": "WOS:000344987900012"}