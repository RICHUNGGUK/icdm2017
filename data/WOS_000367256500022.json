{"auto_keywords": [{"score": 0.04441588338354569, "phrase": "unexecuted_statements"}, {"score": 0.025291683923675968, "phrase": "athena"}, {"score": 0.00481495049065317, "phrase": "guided_stochastic_program_mutation"}, {"score": 0.0044495843279816075, "phrase": "recent_promising_approach"}, {"score": 0.004408456735066782, "phrase": "compiler_validation"}, {"score": 0.00418892838079239, "phrase": "existing_program"}, {"score": 0.004073809704022463, "phrase": "new_equivalent_test_programs"}, {"score": 0.0039621270845351985, "phrase": "orion"}, {"score": 0.003907013105134715, "phrase": "simple_realization"}, {"score": 0.003644001325962353, "phrase": "production_compilers"}, {"score": 0.003610292749660581, "phrase": "orion's_effectiveness"}, {"score": 0.0034303782895431715, "phrase": "emi"}, {"score": 0.003290734521752397, "phrase": "bayesian"}, {"score": 0.0031845067058084613, "phrase": "diverse_programs"}, {"score": 0.002942495422585405, "phrase": "code_deletions"}, {"score": 0.002874870266177579, "phrase": "unexecuted_regions"}, {"score": 0.0026811531172346676, "phrase": "objective_function"}, {"score": 0.0026440008776012665, "phrase": "control-flow-diverse_programs"}, {"score": 0.002607362103727335, "phrase": "markov_chain_monte_carlo"}, {"score": 0.0025121156016001864, "phrase": "search_space"}, {"score": 0.0024543571925896073, "phrase": "deep_bugs"}, {"score": 0.002420339995088838, "phrase": "elaborate_mutations"}, {"score": 0.0023427844897844093, "phrase": "c_compilers"}, {"score": 0.002195033004022173, "phrase": "deep_and_important_bugs"}, {"score": 0.0021646125352626326, "phrase": "gcc"}, {"score": 0.002144550223029327, "phrase": "llvm."}], "paper_keywords": ["Compiler testing", " equivalent program variants", " automated testing", " Markov Chain Monte Carlo"], "paper_abstract": "Compiler testing is important and challenging. Equivalence Modulo Inputs (EMI) is a recent promising approach for compiler validation. It is based on mutating the unexecuted statements of an existing program under some inputs to produce new equivalent test programs w.r.t. these inputs. Orion is a simple realization of EMI by only randomly deleting unexecuted statements. Despite its success in finding many bugs in production compilers, Orion's effectiveness is still limited by its simple, blind mutation strategy. To more effectively realize EMI, this paper introduces a guided, advanced mutation strategy based on Bayesian optimization. Our goal is to generate diverse programs to more thoroughly exercise compilers. We achieve this with two techniques: (1) the support of both code deletions and insertions in the unexecuted regions, leading to a much larger test program space; and (2) the use of an objective function that promotes control-flow-diverse programs for guiding Markov Chain Monte Carlo (MCMC) optimization to explore the search space. Our technique helps discover deep bugs that require elaborate mutations. Our realization, Athena, targets C compilers. In 19 months, Athena has found 72 new bugs - many of which are deep and important bugs - in GCC and LLVM. Developers have confirmed all 72 bugs and fixed 68 of them.", "paper_title": "Finding Deep Compiler Bugs via Guided Stochastic Program Mutation", "paper_id": "WOS:000367256500022"}