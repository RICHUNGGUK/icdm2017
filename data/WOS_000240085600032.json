{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "higher-order_unification"}, {"score": 0.013558037225511048, "phrase": "implicit_type_arguments"}, {"score": 0.00440976345264104, "phrase": "lightweight_approach"}, {"score": 0.004003169429008801, "phrase": "dependently-typed_terms"}, {"score": 0.0037311260623089436, "phrase": "implicit_type_information"}, {"score": 0.00307431840409833, "phrase": "type_reconstruction"}, {"score": 0.002994178996584381, "phrase": "proof_search"}, {"score": 0.0029161225023394363, "phrase": "logical_framework"}, {"score": 0.002258745901862197, "phrase": "occurs_check"}, {"score": 0.0021049977753042253, "phrase": "significant_performance_improvements"}], "paper_keywords": [""], "paper_abstract": "In this paper, we discuss a lightweight approach to eliminate the overhead due to implicit type arguments during higher-order unification of dependently-typed terms. First, we show that some implicit type information is uniquely determined, and can therefore be safely skipped during higher-order unification. Second, we discuss its impact in practice during type reconstruction and during proof search within the logical framework Twelf. Our experimental results show that implicit type arguments are numerous and large in size, but their impact on run-time is between 10% and 20%. On the other hand optimizations such as eliminating the occurs check are shown to be crucial to achieve significant performance improvements.", "paper_title": "Eliminating redundancy in higher-order unification: A lightweight approach", "paper_id": "WOS:000240085600032"}