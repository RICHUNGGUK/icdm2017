{"auto_keywords": [{"score": 0.0312750663515312, "phrase": "task's_data_requirements"}, {"score": 0.00481495049065317, "phrase": "numa_systems"}, {"score": 0.004731754442072492, "phrase": "compute_resource"}, {"score": 0.004698878021540436, "phrase": "many-core_system"}, {"score": 0.004382364826200616, "phrase": "program_execution_models"}, {"score": 0.004217425501814589, "phrase": "available_resources"}, {"score": 0.004087084193780308, "phrase": "parallel_'tasks"}, {"score": 0.004016413965935386, "phrase": "underlying_system_layer"}, {"score": 0.003933214459874487, "phrase": "different_threads"}, {"score": 0.003905864553426306, "phrase": "software-only_schedulers"}, {"score": 0.0037587915908689497, "phrase": "different_applications"}, {"score": 0.0037326500020622715, "phrase": "programming_models"}, {"score": 0.0036809089768350496, "phrase": "large-scale_multi-core_systems"}, {"score": 0.0035299344877334385, "phrase": "task_information"}, {"score": 0.003505378950567746, "phrase": "deep_cache_hierarchies"}, {"score": 0.0034207673889407003, "phrase": "hardware-only_schedulers"}, {"score": 0.0033984837919352894, "phrase": "carbon"}, {"score": 0.0033265580369717996, "phrase": "task_queuing"}, {"score": 0.0031789521764305287, "phrase": "hardware_scheduling_approach"}, {"score": 0.003091381857342703, "phrase": "task-based_programming_models"}, {"score": 0.00292339061443511, "phrase": "prior_knowledge"}, {"score": 0.002862767868795934, "phrase": "better_task_placement"}, {"score": 0.0027645030021576926, "phrase": "overall_cache"}, {"score": 0.0026883186885595127, "phrase": "program's_performance"}, {"score": 0.0026696020591118344, "phrase": "power_utilization"}, {"score": 0.0025779504911297236, "phrase": "synthetic_benchmarks"}, {"score": 0.002542174767860791, "phrase": "real_applications"}, {"score": 0.0023214036848949876, "phrase": "overall_execution_time"}, {"score": 0.0023052356887304226, "phrase": "fifo_scheduling"}, {"score": 0.002249527353528286, "phrase": "faster_execution"}, {"score": 0.0021049977753042253, "phrase": "lower_power_consumption"}], "paper_keywords": ["Scheduling", " Hardware scheduling", " Task-based application", " Dataflow"], "paper_abstract": "To harness the compute resource of many-core system with tens to hundreds of cores, applications have to expose parallelism to the hardware. Researchers are aggressively looking for program execution models that make it easier to expose parallelism and use the available resources. One common approach is to decompose a program into parallel 'tasks' and allow an underlying system layer to schedule these tasks to different threads. Software-only schedulers can implement various scheduling policies and algorithms that match the characteristics of different applications and programming models. Unfortunately with large-scale multi-core systems, software schedulers suffer significant overheads as they synchronize and communicate task information over deep cache hierarchies. To reduce these overheads, hardware-only schedulers like Carbon have been proposed to enable task queuing and scheduling to be done in hardware. This paper presents a hardware scheduling approach where the structure provided to programs by task-based programming models can be incorporated into the scheduler, making it aware of a task's data requirements. This prior knowledge of a task's data requirements allows for better task placement by the scheduler which result in a reduction in overall cache misses and memory traffic, improving the program's performance and power utilization. Simulations of this technique for a range of synthetic benchmarks and components of real applications have shown a reduction in the number of cache misses by up to 72 and 95 % for the L1 and L2 caches, respectively, and up to 30 % improvement in overall execution time against FIFO scheduling. This results not only in faster execution and in less data transfer with reductions of up to 50 %, allowing for less load on the interconnect, but also in lower power consumption.", "paper_title": "Architectural support for task scheduling: hardware scheduling for dataflow on NUMA systems", "paper_id": "WOS:000355231600020"}