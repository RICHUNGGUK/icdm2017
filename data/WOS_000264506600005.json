{"auto_keywords": [{"score": 0.048718786750838995, "phrase": "pure_pattern_calculus"}, {"score": 0.004814955496608903, "phrase": "first-class"}, {"score": 0.004589124394375718, "phrase": "pattern-matching_functions"}, {"score": 0.0043738432231020885, "phrase": "first-class_citizens"}, {"score": 0.0037864980290391354, "phrase": "new_expressive_power"}, {"score": 0.0035741900278634616, "phrase": "path_polymorphism"}, {"score": 0.0035060903664150115, "phrase": "recursive_functions"}, {"score": 0.0034063576796640603, "phrase": "arbitrary_data_structures"}, {"score": 0.00334144503360907, "phrase": "pattern_polymorphism"}, {"score": 0.002837188425640173, "phrase": "training_data"}, {"score": 0.0027564303939865476, "phrase": "general_framework"}, {"score": 0.002703869368554536, "phrase": "pattern_calculi"}, {"score": 0.002273605493468005, "phrase": "matching_algorithm"}], "paper_keywords": [""], "paper_abstract": "Pure pattern calculus supports pattern-matching functions in which patterns are first-class citizens that can be passed as parameters, evaluated and returned as results. This new expressive power supports two new forms of polymorphism. Path polymorphism allows recursive functions to traverse arbitrary data structures. Pattern polymorphism allows patterns to be treated as parameters which may be collected from various sources or generated from training data. A general framework for pattern calculi is developed. It supports a proof of confluence that is parameterised by the nature of the matching algorithm, Suitable for the pure pattern calculus and all other known pattern calculi.", "paper_title": "First-class patterns", "paper_id": "WOS:000264506600005"}