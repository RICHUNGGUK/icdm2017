{"auto_keywords": [{"score": 0.04585178715687913, "phrase": "abbott"}, {"score": 0.004637478829869904, "phrase": "small_but_useful_generalisation"}, {"score": 0.004590217765551337, "phrase": "'derivative'_operation"}, {"score": 0.004527947981009528, "phrase": "huet's_notion"}, {"score": 0.0042579795015449005, "phrase": "concrete_representation"}, {"score": 0.00422899036681456, "phrase": "one-hole_contexts"}, {"score": 0.003990385737207714, "phrase": "container-like_functor"}, {"score": 0.003909413809681223, "phrase": "one-hole_context"}, {"score": 0.0035892794633115227, "phrase": "generic_program"}, {"score": 0.003540539868937462, "phrase": "polynomial_functors"}, {"score": 0.0032616462517547477, "phrase": "map-like_operations"}, {"score": 0.003141246279336443, "phrase": "recursive_data_structure"}, {"score": 0.003066945490483524, "phrase": "tail_recursion"}, {"score": 0.002873986510042009, "phrase": "dissection_structure"}, {"score": 0.0028446460307503343, "phrase": "huet's_operations"}, {"score": 0.002786858120570499, "phrase": "original_motivation"}, {"score": 0.0026565317818265394, "phrase": "leftmost_hole"}, {"score": 0.002463906556781983, "phrase": "remainder_theorem"}, {"score": 0.0023973704289918726, "phrase": "larger_example"}, {"score": 0.0023167153974120083, "phrase": "relatively_efficient_generic_algorithm"}, {"score": 0.0022311183974368484, "phrase": "first-order_syntax"}, {"score": 0.0022083264126633085, "phrase": "source_code"}, {"score": 0.002126725585391261, "phrase": "recent_extensions"}, {"score": 0.0021049977753042253, "phrase": "glasgow_haskell_compiler"}], "paper_keywords": ["algorithms", " design", " languages", " theory", " datatype", " differentiation", " dissection", " division", " generic programming", " iteration", " polynomial", " stack", " tail recursion", " traversal", " zipper"], "paper_abstract": "This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper' (Huet 1997; McBride 2001; Abbott et al. 2005b), giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right. I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet's operations for navigating zippers. The original motivation for dissection was to define 'division', capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online(1) and compiles with recent extensions to the Glasgow Haskell Compiler.", "paper_title": "Clowns to the left of me, jokers to the right (pearl) - Dissecting data structures", "paper_id": "WOS:000256500600028"}