{"auto_keywords": [{"score": 0.0496533317597282, "phrase": "graphics_processing_units"}, {"score": 0.03131352182619874, "phrase": "cost_model"}, {"score": 0.00481495049065317, "phrase": "java_loops"}, {"score": 0.004729704116022601, "phrase": "accelerated_graphics_cards"}, {"score": 0.004403480614319231, "phrase": "right_kinds"}, {"score": 0.00419229472352669, "phrase": "raw_performance"}, {"score": 0.0038855864345030563, "phrase": "narrow_class"}, {"score": 0.0038510053729959074, "phrase": "special-purpose_applications"}, {"score": 0.0037997077863530897, "phrase": "raw_processing_power"}, {"score": 0.0034902664176377943, "phrase": "java_jit_compiler"}, {"score": 0.0034437574674180365, "phrase": "suitable_code"}, {"score": 0.0033981248603693155, "phrase": "gpu"}, {"score": 0.003024852378977727, "phrase": "cpu."}, {"score": 0.002778317177178732, "phrase": "input_and_output_data"}, {"score": 0.002716844480081738, "phrase": "cpu_memory"}, {"score": 0.0025632898741546556, "phrase": "different_hardware_combinations"}, {"score": 0.002364865100579589, "phrase": "java_bytecode_language"}, {"score": 0.002271476019266231, "phrase": "multi-dimensional_arrays"}, {"score": 0.002162316557411786, "phrase": "indirect_references"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Java", " GPU", " Parallelization"], "paper_abstract": "Accelerated graphics cards, or Graphics Processing Units (GPUs), have become ubiquitous in recent years. On the right kinds of problems, GPUs greatly surpass CPUs in terms of raw performance. However, because they are difficult to program, GPUs are used only for a narrow class of special-purpose applications; the raw processing power made available by GPUs is unused most of the time. This paper presents an extension to a Java JIT compiler that executes suitable code on the GPU instead of the CPU. Both static and dynamic features are used to decide whether it is feasible and beneficial to off-load a piece of code on the CPU. The paper presents a cost model that balances the speedup available from the CPU against the cost of transferring input and output data between main memory and CPU memory. The cost model is parameterized so that it can be applied to different hardware combinations. The paper also presents ways to overcome several obstacles to parallelization inherent in the design of the Java bytecode language: unstructured control flow, the lack of multi-dimensional arrays, the precise exception semantics, and the proliferation of indirect references. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Parallel execution of Java loops on Graphics Processing Units", "paper_id": "WOS:000317544500004"}