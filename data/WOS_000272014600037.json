{"auto_keywords": [{"score": 0.050078515420922065, "phrase": "parallel_programming"}, {"score": 0.04596948808198861, "phrase": "nb-feb"}, {"score": 0.004224418476742716, "phrase": "promising_synchronization"}, {"score": 0.004081385289516914, "phrase": "may-core_architectures"}, {"score": 0.0034118234596993836, "phrase": "consensus_problem"}, {"score": 0.0033419808453225516, "phrase": "arbitrary_number"}, {"score": 0.003097865379563127, "phrase": "namely_its_memory_requests"}, {"score": 0.0028321862184182913, "phrase": "performance_degradation"}, {"score": 0.002755104031926742, "phrase": "\"hot_spots"}, {"score": 0.0023346234464901978, "phrase": "conditional_flag"}], "paper_keywords": ["Algorithms", " Reliability", " Theory", " many-core architectures", " non-blocking synchronization", " full/empty bit", " universal primitives", " combinability"], "paper_abstract": "We introduce a non-blocking full/empty bit primitive, or NB-FEB for short, as a promising synchronization primitive for parallel programming on may-core architectures. We show that the NB-FEB primitive is universal, scalable and feasible. NB-FEB, together with registers, can solve the consensus problem for an arbitrary number of processes (universality). NB-FEB is combinable, namely its memory requests to the same memory location can be combined into only one memory request, which consequently mitigates performance degradation due to synchronization \"hot spots\" (scalability). Since NB-FEB is a variant of the original full/empty bit that always returns a value instead of waiting for a conditional flag, it is as feasible as the original full/empty bit, which has been implemented in many computer systems (feasibility).", "paper_title": "Preliminary Results on NB-FEB, a Synchronization Primitive for Parallel Programming", "paper_id": "WOS:000272014600037"}