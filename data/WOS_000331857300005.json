{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "partial_specifications"}, {"score": 0.04963913874714364, "phrase": "heap-manipulating_programs"}, {"score": 0.030958856924928026, "phrase": "primary_methods"}, {"score": 0.004619027561771169, "phrase": "challenging_task"}, {"score": 0.004492841495994535, "phrase": "complex_data_structures"}, {"score": 0.004451546786101008, "phrase": "strong_invariants"}, {"score": 0.004370087541308677, "phrase": "sorted_lists"}, {"score": 0.004270347498153512, "phrase": "verification_process"}, {"score": 0.004172874316207784, "phrase": "human_assistance"}, {"score": 0.004134508282135594, "phrase": "specification_annotations"}, {"score": 0.0040215052006051235, "phrase": "intellectual_effort"}, {"score": 0.003734979290204709, "phrase": "new_approach"}, {"score": 0.0037006243674469657, "phrase": "program_verification"}, {"score": 0.003358368814209542, "phrase": "missing_constraints"}, {"score": 0.003312121699003206, "phrase": "discovered_constraints"}, {"score": 0.0032514447965530323, "phrase": "numerical_and_multi-set_properties"}, {"score": 0.0030056887638095883, "phrase": "partial_specification"}, {"score": 0.002843450389745497, "phrase": "auxiliary_methods"}, {"score": 0.0025329623864528317, "phrase": "shape_properties"}, {"score": 0.0024865237976623286, "phrase": "eventual_goal"}, {"score": 0.0024522530645471065, "phrase": "full_functional_properties"}, {"score": 0.002429668083484833, "phrase": "pointer-based_data_structures"}, {"score": 0.0022878396720586044, "phrase": "non-trivial_constraints"}, {"score": 0.002164264600379492, "phrase": "richer_properties"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Static program analysis", " Separation logic", " Numerical analysis", " Partial specification refinement", " Semi-automatic software verification", " Constraint abstraction"], "paper_abstract": "Automatically verifying heap-manipulating programs is a challenging task, especially when dealing with complex data structures with strong invariants, such as sorted lists and AVL/red-black trees. The verification process can greatly benefit from human assistance through specification annotations, but this process requires intellectual effort from users and is error-prone. In this paper, we propose a new approach to program verification that allows users to provide only partial specification to methods. Our approach will the refine the given annotation into a more complete specification by discovering missing constraints. The discovered constraints may involve both numerical and multi-set properties that could be later confirmed or revised by users. We further augment our approach by requiring partial specification to be given only for primary methods. Specifications for loops and auxiliary methods can then be systematically discovered by our augmented mechanism, with the help of information propagated from the primary methods. Our work is aimed at verifying beyond shape properties, with the eventual goal of analysing full functional properties for pointer-based data structures. Initial experiments have confirmed that we can automatically refine partial specifications with non-trivial constraints, thus making it easier for users to handle specifications with richer properties. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Automatically refining partial specifications for heap-manipulating programs", "paper_id": "WOS:000331857300005"}