{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "compositional_class_refinement"}, {"score": 0.004726382602809228, "phrase": "object-z._object-z"}, {"score": 0.0046394362688524475, "phrase": "coupling_constraints"}, {"score": 0.00411182818527434, "phrase": "high_level"}, {"score": 0.003712362078915926, "phrase": "class_refinement"}, {"score": 0.003199345207727474, "phrase": "large_systems"}, {"score": 0.0027570267191549774, "phrase": "key_step"}, {"score": 0.0026811531172346676, "phrase": "equivalence_transformation"}, {"score": 0.002607362103727335, "phrase": "arbitrary_object-z_specification"}, {"score": 0.002488851299416018, "phrase": "introduced_constraints"}, {"score": 0.0024429654627197393, "phrase": "non-compositional_refinements"}, {"score": 0.0021049977753042253, "phrase": "unrestricted_approach"}], "paper_keywords": [""], "paper_abstract": "Object-Z allows coupling constraints between classes which, on the one hand, facilitate specification at a high level of abstraction, but, on the other hand, make class refinement non-compositional. The consequence of this is that refinement is not practical for large Systems. This paper overcomes this limitation by introducing a methodology for compositional class refinement in Object-Z. The key step is an equivalence transformation of an arbitrary Object-Z specification to one in which introduced constraints prohibit non-compositional refinements. The methodology also allows the constraints which couple classes to be refined yielding an unrestricted approach to compositional class refinement.", "paper_title": "Compositional class refinement in Object-Z", "paper_id": "WOS:000240312100015"}