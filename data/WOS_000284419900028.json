{"auto_keywords": [{"score": 0.040229067790740376, "phrase": "wsn"}, {"score": 0.00481495049065317, "phrase": "maximal_recovery_network_coding_under_topology_constraint"}, {"score": 0.004642292792558686, "phrase": "wireless_sensor_networks"}, {"score": 0.004414907432703781, "phrase": "efficient_channel_codes"}, {"score": 0.0038849148160362257, "phrase": "source_data"}, {"score": 0.0037798652680135106, "phrase": "size_k"}, {"score": 0.003711409222544974, "phrase": "variable_nodes_subset"}, {"score": 0.0036776458116294986, "phrase": "low-density_parity_check"}, {"score": 0.003561865840737996, "phrase": "resulting_fixed_size_symbol_stream"}, {"score": 0.003310684108128973, "phrase": "source_symbols"}, {"score": 0.003221111762383486, "phrase": "belief_propagation"}, {"score": 0.003091262582401731, "phrase": "cng_code_ensembles"}, {"score": 0.0030491497463386924, "phrase": "maximal_recovery"}, {"score": 0.0029802289354540507, "phrase": "different_erasure_rates"}, {"score": 0.002953097497434808, "phrase": "network_topological_constraints"}, {"score": 0.0029128614098881253, "phrase": "node_transmission_range"}, {"score": 0.0028731719610706214, "phrase": "analytic_framework"}, {"score": 0.0028340217672278975, "phrase": "code_performance"}, {"score": 0.0028082176224611542, "phrase": "transmission_range_constraints"}, {"score": 0.0027322025124213566, "phrase": "necessary_condition"}, {"score": 0.0027073229284666294, "phrase": "code_stability"}, {"score": 0.0026582395558737855, "phrase": "fixed-point_stability_analysis"}, {"score": 0.0025162511343171, "phrase": "differential_evolution_algorithm"}, {"score": 0.0024593458703463474, "phrase": "distributed_algorithm"}, {"score": 0.0023927516438886445, "phrase": "encoded_symbols"}, {"score": 0.002349357968054711, "phrase": "designed_code_ensemble"}, {"score": 0.0022857351723674004, "phrase": "designed_cng_code"}, {"score": 0.0022136780933978612, "phrase": "random_nc"}, {"score": 0.002193509835371438, "phrase": "growth_code_based_ensembles"}, {"score": 0.0021243539405631866, "phrase": "network_size"}, {"score": 0.0021049977753042253, "phrase": "inter-connectivity_variations"}], "paper_keywords": ["Low-density parity check (LDPC) codes", " network channel coding", " network coding (NC)", " partial recovery", " wireless sensor networks (WSN)"], "paper_abstract": "Network coding (NC) within wireless sensor networks (WSNs) can be viewed as the mapping of efficient channel codes to the data generated within the network. In particular, this perspective of code-on-network-graphs (CNG) can be exploited to map source data generated within WSN (of size K) to a variable nodes subset in low-density parity check (LDPC) codes. The resulting fixed size symbol stream when transmitted through the network suffers erasures. At sink, an average of z source symbols can be recovered by employing belief propagation decoding. In this paper, we determine CNG code ensembles that achieve maximal recovery (z/K) for different erasure rates and network topological constraints corresponding to node transmission range. An analytic framework to predict code performance under transmission range constraints is developed. Additionally, necessary condition for code stability was derived using fixed-point stability analysis. Optimal solutions for a WSN with 1000 nodes are determined using differential evolution algorithm. We outline a distributed algorithm for generating a sequence of encoded symbols adhering to the designed code ensemble. The performance of the designed CNG code is demonstrated to be superior to random NC and growth code based ensembles, as well as resilient to network size and inter-connectivity variations.", "paper_title": "Maximal Recovery Network Coding Under Topology Constraint", "paper_id": "WOS:000284419900028"}