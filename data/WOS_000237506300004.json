{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "compilation_sequences"}, {"score": 0.04009147393860778, "phrase": "input_program"}, {"score": 0.004779085953614184, "phrase": "randomized_search_algorithms"}, {"score": 0.00474348728309194, "phrase": "modern_optimizing_compilers"}, {"score": 0.004690583510896564, "phrase": "fixed_sequence"}, {"score": 0.004240116703465252, "phrase": "small_number"}, {"score": 0.004208515754292201, "phrase": "specified_ways"}, {"score": 0.004161553532799662, "phrase": "command-line_flags"}, {"score": 0.003861534816807933, "phrase": "appropriate_compilation_sequence"}, {"score": 0.003775803846431323, "phrase": "adaptive_compilers"}, {"score": 0.0037336520904376687, "phrase": "good_compilation_sequence"}, {"score": 0.0033747739383101095, "phrase": "program-specific_sequences"}, {"score": 0.0033370841436001597, "phrase": "better_results"}, {"score": 0.003299813878412728, "phrase": "single_universal_sequence"}, {"score": 0.0030847461428168614, "phrase": "large_and_complex_search_space"}, {"score": 0.002993701876937243, "phrase": "possible_repeats"}, {"score": 0.0023554947277883535, "phrase": "important_properties"}, {"score": 0.0023291617361832157, "phrase": "full_spaces"}, {"score": 0.0021448202319775634, "phrase": "observed_properties"}, {"score": 0.0021049977753042253, "phrase": "search_algorithms"}], "paper_keywords": ["compilers", " code optimization", " adaptive compilation"], "paper_abstract": "Modern optimizing compilers apply a fixed sequence of optimizations, which we call a compilation sequence, to each program that they compile. These compilers let the user modify their behavior in a small number of specified ways, using command-line flags (e.g.,-O1,-O2,...). For five years, we have been working with compilers that automatically select an appropriate compilation sequence for each input program. These adaptive compilers discover a good compilation sequence tailored to the input program, the target machine, and a user-chosen objective function. We have shown, as have others, that program-specific sequences can produce better results than any single universal sequence [1, 7, 10, 21, 23] Our adaptive compiler looks for compilation sequences in a large and complex search space. Its typical compilation sequence includes 10 passes (with possible repeats) chosen from the 16 available-there are 16(10) or [1,099,511,627,776] such sequences. To learn about the properties of such spaces, we have studied subspaces that consist of 10 passes drawn from a set of 5 (5(10) or 9,765,625 sequences). These 10-of-5 subspaces are small enough that we can analyze them thoroughly but large enough to reflect important properties of the full spaces. This paper reports, in detail, on our analysis of several of these subspaces and on the consequences of those observed properties for the design of search algorithms.", "paper_title": "Exploring the structure of the space of compilation sequences using randomized search algorithms", "paper_id": "WOS:000237506300004"}