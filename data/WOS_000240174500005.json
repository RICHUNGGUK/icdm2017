{"auto_keywords": [{"score": 0.03303646134359794, "phrase": "haskell"}, {"score": 0.007853571207477953, "phrase": "cyclone"}, {"score": 0.00481495049065317, "phrase": "region-based_type_systems"}, {"score": 0.0046390482426405324, "phrase": "memory_management"}, {"score": 0.004370814742381778, "phrase": "type_systems"}, {"score": 0.004306205029641728, "phrase": "region-based_languages"}, {"score": 0.0032444113660668743, "phrase": "plain_old_parametric_polymorphism"}, {"score": 0.002574788013427524, "phrase": "region_calculus"}, {"score": 0.0025366596616434767, "phrase": "tofte"}, {"score": 0.002499094513009327, "phrase": "talpin"}, {"score": 0.002443784721651744, "phrase": "monadic_variant"}, {"score": 0.0024075916292945715, "phrase": "system_f"}, {"score": 0.0023719332915829268, "phrase": "region_primitives"}, {"score": 0.002201263415024454, "phrase": "launchbury"}, {"score": 0.0021687806803474367, "phrase": "st_monad"}, {"score": 0.0021049977753042253, "phrase": "peyton_jones"}], "paper_keywords": [""], "paper_abstract": "Region-based type systems provide programmer control over memory management without sacrificing type-safety. However, the type systems for region-based languages, such as the ML-Kit or Cyclone, are relatively complicated, and proving their soundness is non-trivial. This paper shows that the complication is in principle unnecessary. In particular, we show that plain old parametric polymorphism, as found in Haskell, is all that is needed. We substantiate this claim by giving a type- and meaning-preserving translation from a variation of the region calculus of Tofte and Talpin to a monadic variant of System F with region primitives whose types and operations are inspired by (and generalize) the ST monad of Launchbury and Peyton Jones.", "paper_title": "Monadic regions", "paper_id": "WOS:000240174500005"}