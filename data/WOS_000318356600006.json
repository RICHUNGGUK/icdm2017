{"auto_keywords": [{"score": 0.038906160240873275, "phrase": "parallel_applications"}, {"score": 0.00481495049065317, "phrase": "linux_kernel"}, {"score": 0.004769958800452922, "phrase": "scientific_applications"}, {"score": 0.0046593017130868, "phrase": "operating_system"}, {"score": 0.004508661664944657, "phrase": "operating_systems"}, {"score": 0.004362870617347183, "phrase": "single_resource"}, {"score": 0.004301866573113785, "phrase": "cpu."}, {"score": 0.0038431888954930083, "phrase": "application's_time"}, {"score": 0.003531474887552889, "phrase": "synchronization_point"}, {"score": 0.003369322866499541, "phrase": "increasing_system_scale"}, {"score": 0.0032756158688245, "phrase": "application_turn-around_time"}, {"score": 0.003095923814666088, "phrase": "application_interruption"}, {"score": 0.0030097975788892896, "phrase": "time_configurations"}, {"score": 0.002967634471075658, "phrase": "recent_unmodified_linux_kernel"}, {"score": 0.0027395968397212053, "phrase": "authors'_knowledge"}, {"score": 0.002626034130205569, "phrase": "high-performance_computing_context"}, {"score": 0.002493592357827492, "phrase": "involuntary_preemption"}, {"score": 0.0024586427394152196, "phrase": "task_scheduling"}, {"score": 0.002323663295811215, "phrase": "relatively_small_scales"}, {"score": 0.002280333649167796, "phrase": "modest_scale"}, {"score": 0.0021755038991725147, "phrase": "bulk-synchronous-parallel_application"}, {"score": 0.0021249064184347658, "phrase": "higher_benefits"}, {"score": 0.0021049977753042253, "phrase": "extreme_scales"}], "paper_keywords": ["noise", " jitter", " partitioning", " Linux", " scheduling"], "paper_abstract": "Scientific applications are interrupted by the operating system far too often. Historically, operating systems have been optimized to time-share a single resource, the CPU. We now have an abundance of cores, but we are still swapping out the application to run other tasks and therefore increasing the application's time to solution. In addition, with parallel applications the probability of one of the tasks entering a synchronization point late due to one of these interrupts increases with increasing system scale, which further increases the application turn-around time. This paper reviews measures that can be taken to reduce application interruption using only compile and run time configurations in a recent unmodified Linux kernel. Although these measures have been available for some time, to the best of the authors' knowledge, they have never been implemented in a high-performance computing context. We then introduce our invasive method, where we remove the involuntary preemption induced by task scheduling. Our experiments show that parallel applications benefit from these modifications even at relatively small scales. At the modest scale of our testbed, we see a 1.91% improvement in a bulk-synchronous-parallel application that should project into higher benefits at extreme scales.", "paper_title": "Understanding and isolating the noise in the Linux kernel", "paper_id": "WOS:000318356600006"}