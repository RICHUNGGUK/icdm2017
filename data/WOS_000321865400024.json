{"auto_keywords": [{"score": 0.033057242091515615, "phrase": "different_threads"}, {"score": 0.00481495049065317, "phrase": "general_data_structure_expansion"}, {"score": 0.004645057834614705, "phrase": "sequential_codes"}, {"score": 0.004541918674719973, "phrase": "common_and_significant_transformation"}, {"score": 0.004421156723819163, "phrase": "runtime_parallelizing_systems"}, {"score": 0.0042650992966174065, "phrase": "spurious_data_dependencies"}, {"score": 0.0041891398413899435, "phrase": "inherent_parallelism"}, {"score": 0.004059438255358923, "phrase": "significant_challenge"}, {"score": 0.003951453722517865, "phrase": "dynamic_and_recursive_data_structures"}, {"score": 0.0038636556112977226, "phrase": "real_applications"}, {"score": 0.0036443694410100507, "phrase": "naming_mechanism"}, {"score": 0.0035794251590584563, "phrase": "address_range"}, {"score": 0.003531474887552889, "phrase": "pointer-based_data_structure"}, {"score": 0.0034220655476652683, "phrase": "explicitly_declared_bounds"}, {"score": 0.0033011569787033297, "phrase": "novel_solution"}, {"score": 0.003256922225995089, "phrase": "difficult_problem"}, {"score": 0.0032132782979796895, "phrase": "general_data_structures"}, {"score": 0.0031702173541386888, "phrase": "memory_accesses"}, {"score": 0.0030997236644076196, "phrase": "contentious_data_structures"}, {"score": 0.003044455555031339, "phrase": "different_data_fields"}, {"score": 0.0029901699209266435, "phrase": "compile-time_type_checking"}, {"score": 0.00295008998986066, "phrase": "data_dependence_graph"}, {"score": 0.002910545717767559, "phrase": "aggressive_extension"}, {"score": 0.002833035775182696, "phrase": "array_expansion"}, {"score": 0.0026600905156986317, "phrase": "thread-private_stacks"}, {"score": 0.0026009105281485888, "phrase": "targeted_loop"}, {"score": 0.002464193238340546, "phrase": "gcc"}, {"score": 0.0023451553255837317, "phrase": "well-known_benchmark_suites"}, {"score": 0.002313701384950788, "phrase": "mibench"}, {"score": 0.002292965705677312, "phrase": "mediabench_ii"}, {"score": 0.0022118619998034742, "phrase": "new_approach"}, {"score": 0.00216263228969761, "phrase": "high_speedup"}, {"score": 0.002124036931047162, "phrase": "transformed_code"}, {"score": 0.0021049977753042253, "phrase": "multiple_cores"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Parallelization", " privatization", " multithreading"], "paper_abstract": "Among techniques for parallelizing sequential codes, privatization is a common and significant transformation performed by both compilers and runtime parallelizing systems. Without privatization, repetitive updates to the same data structures often introduce spurious data dependencies that hide the inherent parallelism. Unfortunately, it remains a significant challenge to compilers to automatically privatize dynamic and recursive data structures which appear frequently in real applications written in languages such as C/C++. This is because such languages lack a naming mechanism to define the address range of a pointer-based data structure, in contrast to arrays with explicitly declared bounds. In this paper we present a novel solution to this difficult problem by expanding general data structures such that memory accesses issued from different threads to contentious data structures are directed to different data fields. Based on compile-time type checking and a data dependence graph, this aggressive extension to the traditional scalar and array expansion isolates the address ranges among different threads, without struggling with privatization based on thread-private stacks, such that the targeted loop can be effectively parallelized. With this method fully implemented in GCC, experiments are conducted on a set of programs from well-known benchmark suites such as Mibench, MediaBench II and SPECint. Results show that the new approach can lead to a high speedup when executing the transformed code on multiple cores.", "paper_title": "General Data Structure Expansion for Multi-threading", "paper_id": "WOS:000321865400024"}