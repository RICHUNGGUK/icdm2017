{"auto_keywords": [{"score": 0.03644451033122438, "phrase": "parallel_computation"}, {"score": 0.00481495049065317, "phrase": "mitigating_communication_errors"}, {"score": 0.004768378525561471, "phrase": "error-prone_parallel_execution"}, {"score": 0.004608879242346434, "phrase": "ever-smaller_transistor_sizes"}, {"score": 0.004411588377842043, "phrase": "important_application_classes"}, {"score": 0.004081385289516914, "phrase": "recent_research"}, {"score": 0.0038127186374325582, "phrase": "error_tolerance"}, {"score": 0.003721098220825489, "phrase": "even_seemingly_error-tolerant_applications"}, {"score": 0.003392507399258166, "phrase": "inter-thread_communication"}, {"score": 0.0033433365160336842, "phrase": "equally_catastrophic_effects"}, {"score": 0.0031845067058084613, "phrase": "potentially_catastrophic_errors"}, {"score": 0.003003809128328864, "phrase": "yield_benefits"}, {"score": 0.0029747028229638625, "phrase": "data_error_tolerance"}, {"score": 0.002917331114260319, "phrase": "fsm-based_checkers"}, {"score": 0.002778682854371595, "phrase": "semantic_alignment"}, {"score": 0.002751751956416832, "phrase": "program_control_flow"}, {"score": 0.0026466064623118105, "phrase": "commguard_techniques"}, {"score": 0.0026209522797963447, "phrase": "low_overhead"}, {"score": 0.002570385604065795, "phrase": "application_information"}, {"score": 0.0025085435314540837, "phrase": "parallel_programming_languages"}, {"score": 0.0024126686412257407, "phrase": "potentially_catastrophic_communication_errors"}, {"score": 0.002389276641014013, "phrase": "potentially_tolerable_data_errors"}, {"score": 0.002366110899738696, "phrase": "commguard"}, {"score": 0.0023431692392929353, "phrase": "important_streaming_applications"}, {"score": 0.002320465049925727, "phrase": "jpeg"}, {"score": 0.002199363362666037, "phrase": "good_output_quality"}], "paper_keywords": ["Application-level error tolerance", " high-level programming languages", " parallel computing"], "paper_abstract": "As semiconductor technology scales towards ever-smaller transistor sizes, hardware fault rates are increasing. Since important application classes (e.g., multimedia, streaming workloads) are data-error-tolerant, recent research has proposed techniques that seek to save energy or improve yield by exploiting error tolerance at the architecture/microarchitecture level. Even seemingly error-tolerant applications, however, will crash or hang due to control-flow/memory addressing errors. In parallel computation, errors involving inter-thread communication can have equally catastrophic effects. Our work explores techniques that mitigate the impact of potentially catastrophic errors in parallel computation, while still garnering power, cost, or yield benefits from data error tolerance. Our proposed CommGuard solution uses FSM-based checkers to pad and discard data in order to maintain semantic alignment between program control flow and the data communicated between processors. CommGuard techniques are low overhead and they exploit application information already provided by some parallel programming languages (e.g. StreamIt). By converting potentially catastrophic communication errors into potentially tolerable data errors, CommGuard allows important streaming applications like JPEG and MP3 decoding to execute without crashing and to sustain good output quality, even for errors as frequent as every 500 mu s", "paper_title": "CommGuard: Mitigating Communication Errors in Error-Prone Parallel Execution", "paper_id": "WOS:000370874900022"}