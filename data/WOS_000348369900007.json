{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "usage_automata"}, {"score": 0.0067740244192638814, "phrase": "usage_policy"}, {"score": 0.004269630481719451, "phrase": "finite_state_automata"}, {"score": 0.004174451361776433, "phrase": "additional_features"}, {"score": 0.0035648266669315943, "phrase": "real-world_applications"}, {"score": 0.002953711377604328, "phrase": "main_contribution"}, {"score": 0.0028233196851239753, "phrase": "model_checking_technique"}, {"score": 0.0025989960809479104, "phrase": "i.e._basic_processes"}, {"score": 0.0025219085140220773, "phrase": "possible_patterns"}, {"score": 0.0024842242921857705, "phrase": "resource_access"}, {"score": 0.0023040642263522505, "phrase": "infinite_states"}, {"score": 0.0021049977753042253, "phrase": "polynomial-time_model_checking_technique"}], "paper_keywords": [""], "paper_abstract": "We study usage automata, a formal model for specifying policies on the usage of resources. Usage automata extend finite state automata with some additional features, parameters and guards, that improve their expressivity. We show that usage automata are expressive enough to model policies of real-world applications. We discuss their expressive power, and we prove that the problem of telling whether a computation complies with a usage policy is decidable. The main contribution of this paper is a model checking technique for usage automata. The model is that of usages, i.e. basic processes that describe the possible patterns of resource access and creation. In spite of the model having infinite states, because of recursion and resource creation, we devise a polynomial-time model checking technique for deciding when a usage complies with a usage policy.", "paper_title": "Model checking usage policies", "paper_id": "WOS:000348369900007"}