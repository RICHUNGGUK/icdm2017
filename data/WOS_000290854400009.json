{"auto_keywords": [{"score": 0.043038683365025775, "phrase": "mnemosyne"}, {"score": 0.0071523949486571176, "phrase": "scm"}, {"score": 0.004702092660370367, "phrase": "phase-change_memory"}, {"score": 0.004665061661144316, "phrase": "stt-ram"}, {"score": 0.0045557008859819234, "phrase": "user-level_access"}, {"score": 0.0045198174374297285, "phrase": "non-volatile_storage"}, {"score": 0.004484215355348556, "phrase": "regular_memory_instructions"}, {"score": 0.00443133501650381, "phrase": "memory_devices"}, {"score": 0.004396426822203258, "phrase": "fast_user-mode_access"}, {"score": 0.0043103495043308755, "phrase": "regular_in-memory_data_structures"}, {"score": 0.003982500388997765, "phrase": "persistent_memory"}, {"score": 0.003607404191062938, "phrase": "additional_mechanisms"}, {"score": 0.0035648266669315943, "phrase": "system_failure"}, {"score": 0.003522749900725601, "phrase": "data_structures"}, {"score": 0.0034537189001268113, "phrase": "invalid_state"}, {"score": 0.003241750934419473, "phrase": "global_persistent_data"}, {"score": 0.0030187498405804315, "phrase": "persistent_variables"}, {"score": 0.0029830992938695007, "phrase": "consistent_updates"}, {"score": 0.002947868524740683, "phrase": "lightweight_transaction_mechanism"}, {"score": 0.0028786467218197245, "phrase": "disk-based_persistent_memory"}, {"score": 0.0026384167183586015, "phrase": "memory_pages"}, {"score": 0.002576442680766742, "phrase": "file_system"}, {"score": 0.0025159206854716274, "phrase": "performance_characteristics"}, {"score": 0.0024960634897058394, "phrase": "forthcoming_scms"}, {"score": 0.0022696277881969896, "phrase": "openldap_directory_server"}, {"score": 0.0022428042503686053, "phrase": "microbenchmark_studies"}, {"score": 0.002138636271204459, "phrase": "alternative_persistence_strategies"}, {"score": 0.0021049977753042253, "phrase": "berkeley_db"}], "paper_keywords": ["Design", " Languages", " Performance", " Reliability", " Persistent memory", " storage-class memory", " persistence", " memory transactions", " performance"], "paper_abstract": "New storage-class memory (SCM) technologies, such as phase-change memory, STT-RAM, and memristors, promise user-level access to non-volatile storage through regular memory instructions. These memory devices enable fast user-mode access to persistence, allowing regular in-memory data structures to survive system crashes. In this paper, we present Mnemosyne, a simple interface for programming with persistent memory. Mnemosyne addresses two challenges: how to create and manage such memory, and how to ensure consistency in the presence of failures. Without additional mechanisms, a system failure may leave data structures in SCM in an invalid state, crashing the program the next time it starts. In Mnemosyne, programmers declare global persistent data with the keyword \"pstatic\" or allocate it dynamically. Mnemosyne provides primitives for directly modifying persistent variables and supports consistent updates through a lightweight transaction mechanism. Compared to past work on disk-based persistent memory, Mnemosyne reduces latency to storage by writing data directly to memory at the granularity of an update rather than writing memory pages back to disk through the file system. In tests emulating the performance characteristics of forthcoming SCMs, we show that Mnemosyne can persist data as fast as 3 microseconds. Furthermore, it provides a 35 percent performance increase when applied in the OpenLDAP directory server. In microbenchmark studies we find that Mnemosyne can be up to 1400% faster than alternative persistence strategies, such as Berkeley DB or Boost serialization, that are designed for disks.", "paper_title": "Mnemosyne: Lightweight Persistent Memory", "paper_id": "WOS:000290854400009"}