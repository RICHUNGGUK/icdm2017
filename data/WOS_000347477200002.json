{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cb_tree"}, {"score": 0.004430920292612374, "phrase": "splay_trees"}, {"score": 0.004387793971765289, "phrase": "more-frequently_accessed_items"}, {"score": 0.004198839649063847, "phrase": "sequential_execution"}, {"score": 0.0035902958977673313, "phrase": "original_splay_tree"}, {"score": 0.0034524248924699985, "phrase": "accessed_item"}, {"score": 0.0025608471909800076, "phrase": "scalable_concurrent_self-adjusting_bst."}, {"score": 0.0021678232353129472, "phrase": "concurrent_cb_tree"}, {"score": 0.002125735077004312, "phrase": "existing_concurrent_search_trees"}, {"score": 0.0021049977753042253, "phrase": "non-uniform_access_sequences"}], "paper_keywords": ["Self-adjusting tree", " Splay tree", " Optimistic concurrency control"], "paper_abstract": "We present the CB tree, a counting-based self-adjusting binary search tree in which, as in splay trees, more-frequently accessed items move closer to the root. In a sequential execution, after m operations of which c(upsilon) access item upsilon, an access of upsilon traverses a path of length O(1 + log m/c(upsilon)) while doing few if any rotations. Unlike the original splay tree, in which each access moves the accessed item all the way to the root via a sequence of rotations, accesses in a CB tree do very few rotations, specifically O (n + n log m/n), during a sequence of m operations of which n are insertions. This is o(1) (subconstant) amortized per operation if m >> n. We adapt the CB tree into a scalable concurrent self-adjusting BST. We show experimentally that the concurrent CB tree scales well because it, too, performs few rotations, and therefore self-adjusts without having rotations create a bottleneck. Our evaluation shows that the concurrent CB tree performs better than existing concurrent search trees on non-uniform access sequences derived from real workloads.", "paper_title": "The CB tree: a practical concurrent self-adjusting search tree", "paper_id": "WOS:000347477200002"}