{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "sequential_applications"}, {"score": 0.004712726613162057, "phrase": "core_spilling"}, {"score": 0.004662427600500598, "phrase": "chip_multiprocessors"}, {"score": 0.004514714250357749, "phrase": "scalable_means"}, {"score": 0.0044426140044122545, "phrase": "thread-level_parallelism"}, {"score": 0.0043482604833437735, "phrase": "multithreaded_applications"}, {"score": 0.004255902303152008, "phrase": "single-threaded_applications"}, {"score": 0.00409895142748329, "phrase": "statically_partitioned_resources"}, {"score": 0.0040334640350288, "phrase": "cmp._such_sequential_applications"}, {"score": 0.003741371936431574, "phrase": "legacy_code"}, {"score": 0.003470358620464986, "phrase": "novel_approach"}, {"score": 0.0032712190037495975, "phrase": "multiple_cores"}, {"score": 0.002875391177926809, "phrase": "low-overhead_migration"}, {"score": 0.0026384167183586015, "phrase": "arbitration_mechanism"}, {"score": 0.0023314867226678555, "phrase": "single-threaded_performance"}, {"score": 0.0022453451864218477, "phrase": "eight-core_cmp"}, {"score": 0.002209406458446019, "phrase": "multiple_application_workload"}, {"score": 0.002162379426839795, "phrase": "entire_spec"}], "paper_keywords": ["multithreaded processors", " scheduling and task partitioning"], "paper_abstract": "Chip multiprocessors (CMPs) provide a scalable means of exploiting thread-level parallelism for multitasking or multithreaded applications. However, single-threaded applications will have difficulty dynamically leveraging the statically partitioned resources in a CMP. Such sequential applications may be difficult to statically decompose into threads or may simply be a legacy code where recompilation is not possible or cost-effective. We present a novel approach to dynamically accelerate the performance of sequential application(s) on multiple cores. Execution is allowed to spill from one core to another when resources on one core have been exhausted. We propose two techniques to enable low-overhead migration between cores: prespilling and locality-based filtering. We develop and analyze an arbitration mechanism to intelligently allocate cores among a set of sequential applications on a CMP. On average, core spilling on an eight-coreCMP can accelerate single-threaded performance by 35 percent. Wefurther explore an eight-core CMP running a multiple application workload composed of the entire SPEC 2000 benchmark suite in various combinations and arrival times. Using core spilling to accelerate", "paper_title": "Accelerating sequential applications on CMPs using core spilling", "paper_id": "WOS:000247541500007"}