{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "agda"}, {"score": 0.00481495049065317, "phrase": "partiality_monad"}, {"score": 0.00471228691115201, "phrase": "operational_semantics"}, {"score": 0.004546000131069232, "phrase": "functional_language"}, {"score": 0.004110831924517065, "phrase": "latter_approach"}, {"score": 0.00333697550984782, "phrase": "functional_semantics"}, {"score": 0.0031730701021262155, "phrase": "constructive_setting"}, {"score": 0.002910545717767559, "phrase": "coinductive_partiality"}, {"score": 0.00278752137116301, "phrase": "small-step_operational_semantics"}, {"score": 0.002669683153809812, "phrase": "virtual_machines"}, {"score": 0.0025938977569302177, "phrase": "computable_functions"}, {"score": 0.002396371892825691, "phrase": "resulting_semantics"}, {"score": 0.002362105010110277, "phrase": "useful_type_soundness"}, {"score": 0.00232832698253493, "phrase": "compiler_correctness"}], "paper_keywords": ["Dependent types", " mixed induction and coinduction", " partiality monad"], "paper_abstract": "The operational semantics of a partial, functional language is often given as a relation rather than as a function. The latter approach is arguably more natural: if the language is functional, why not take advantage of this when defining the semantics? One can immediately see that a functional semantics is deterministic and, in a constructive setting, computable. This paper shows how one can use the coinductive partiality monad to define big-step or small-step operational semantics for lambda-calculi and virtual machines as total, computable functions (total definitional interpreters). To demonstrate that the resulting semantics are useful type soundness and compiler correctness results are also proved. The results have been implemented and checked using Agda, a dependently typed programming language and proof assistant.", "paper_title": "Operational Semantics Using the Partiality Monad", "paper_id": "WOS:000311296000013"}