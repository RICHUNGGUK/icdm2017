{"auto_keywords": [{"score": 0.047317134097898006, "phrase": "mfts"}, {"score": 0.00481495049065317, "phrase": "multi-level_fault-tolerant_archiving_storage"}, {"score": 0.004771196027464407, "phrase": "optimized_maintenance_bandwidth"}, {"score": 0.004579147045265106, "phrase": "multi-level_fault-tolerant_storage_cluster"}, {"score": 0.004374772264092067, "phrase": "wide_variety"}, {"score": 0.0040479661688863884, "phrase": "fault-tolerance_levels"}, {"score": 0.0036275736378775757, "phrase": "appropriate_coding_scheme"}, {"score": 0.003545625043276134, "phrase": "individual_reliability_requirements"}, {"score": 0.003433987036569199, "phrase": "multi-level_reliable_storage"}, {"score": 0.0033872210664940817, "phrase": "virtual_storage_space"}, {"score": 0.0032955848190195343, "phrase": "changing_reliability_demands"}, {"score": 0.0031483163191080425, "phrase": "mfts_system"}, {"score": 0.0030771609361092164, "phrase": "intersecting_zigzag_sets_code"}, {"score": 0.002953097497434808, "phrase": "general-purpose_erasure_codes"}, {"score": 0.0028210902750714075, "phrase": "fast_reconstructions"}, {"score": 0.002782647772219627, "phrase": "minimal_overhead"}, {"score": 0.0027573101010593863, "phrase": "fault-tolerance_level_transitions"}, {"score": 0.0027073229284666294, "phrase": "performance_optimization"}, {"score": 0.002634031703695684, "phrase": "izs-enabled_mfts"}, {"score": 0.0025627194819793347, "phrase": "vandermonde-and_cauchy-reed-solomon_codes"}, {"score": 0.0024258208033731154, "phrase": "comparable_user-response-time_performance"}, {"score": 0.002275299774554847, "phrase": "offline_reconstruction_case"}, {"score": 0.002193509835371438, "phrase": "online_reconstruction"}, {"score": 0.0021243539405631866, "phrase": "marginal_increase"}, {"score": 0.0021049977753042253, "phrase": "user_response_time"}], "paper_keywords": ["Erasure-coded storage cluster", " multi-level fault tolerance", " optimized maintenance bandwidth", " TCP-Incast"], "paper_abstract": "In this paper, we propose a multi-level fault-tolerant storage cluster called MFTS, which provides flexible reliability for a wide variety of applications. MFTS makes use of a reliability upper-bound (i.e., Parameter r) to guide the process of adjusting fault-tolerance levels, i.e., i-erasure(s) and i is an element of{1, 2,...,r}. In particular, MFTS can map an appropriate coding scheme to an application with individual reliability requirements. MFTS is capable of partitioning multi-level reliable storage using a virtual storage space, thereby adapting to any changing reliability demands of applications. We present the implementation of the MFTS system, which adopts an intersecting zigzag sets code (IZS code) rather than replication or general-purpose erasure codes. Our MFTS has three salient features: partial updates, fast reconstructions, and minimal overhead of fault-tolerance level transitions. To quantify performance optimization in our storage cluster, we compare IZS-enabled MFTS with two storage clusters equipped with the Vandermonde-and Cauchy-Reed-Solomon codes. The experimental results show that: 1) three schemes have comparable user-response-time performance in both the operational and degraded modes; 2) MFTS outperforms the other two alternatives by up to 26.1 percent in the offline reconstruction case; 3) MFTS speeds up the online reconstruction by up to 23.7 percent over the other two schemes with marginal increase in user response time.", "paper_title": "MFTS: A Multi-Level Fault-Tolerant Archiving Storage with Optimized Maintenance Bandwidth", "paper_id": "WOS:000346319600003"}