{"auto_keywords": [{"score": 0.03792455040208497, "phrase": "special_case"}, {"score": 0.032860293486390586, "phrase": "motivating_application"}, {"score": 0.00481495049065317, "phrase": "data_structures_for_mergeable_trees"}, {"score": 0.004707810093520679, "phrase": "computational_geometry"}, {"score": 0.004632737164977336, "phrase": "novel_variant"}, {"score": 0.004486147558765763, "phrase": "dynamic_rooted_trees"}, {"score": 0.0042748769561032325, "phrase": "standard_problem"}, {"score": 0.004206678601411097, "phrase": "single_operation"}, {"score": 0.00399564102224961, "phrase": "linear_number"}, {"score": 0.0037586895199831095, "phrase": "first_method"}, {"score": 0.003698697664245042, "phrase": "farach"}, {"score": 0.00367498004431872, "phrase": "thorup"}, {"score": 0.0034347810592224096, "phrase": "n-node_forest"}, {"score": 0.0034017706220810223, "phrase": "standard_dynamic_tree_operation"}, {"score": 0.003315280396086864, "phrase": "latter_bound"}, {"score": 0.0032728607237892038, "phrase": "worst_case"}, {"score": 0.003199923972285777, "phrase": "underlying_data_structure"}, {"score": 0.003068741668908204, "phrase": "arbitrary_arc_deletions"}, {"score": 0.0026804738789336763, "phrase": "n_numbers"}, {"score": 0.002554021496818708, "phrase": "even-more-special_case"}, {"score": 0.002410109046803846, "phrase": "standard_dynamic_trees"}, {"score": 0.002386922774536045, "phrase": "black_box"}, {"score": 0.0023639590354685817, "phrase": "mergeable_tree_operation"}, {"score": 0.0023412157039327665, "phrase": "constant_number"}, {"score": 0.002326174890933973, "phrase": "standard_dynamic_tree_operations"}, {"score": 0.0023037942361136205, "phrase": "third_method"}, {"score": 0.002139197034966045, "phrase": "different_analytical_tools"}, {"score": 0.0021186115162176457, "phrase": "different_properties"}, {"score": 0.0021049977753042253, "phrase": "dynamic_trees"}], "paper_keywords": ["Amortized efficiency", " computational topology", " critical pairs", " dynamic trees", " extreme points", " link-cut trees", " manifolds", " merging"], "paper_abstract": "Motivated by an application in computational geometry, we consider a novel variant of the problem of efficiently maintaining a forest of dynamic rooted trees. This variant includes an operation that merges two tree paths. In contrast to the standard problem, in which a single operation can only add or delete one arc, one merge can add and delete up to a linear number of arcs. In spite of this, we develop three different methods that need only polylogarithmic time per operation. The first method extends a solution of Farach and Thorup [1998] for the special case of paths. Each merge takes O(log(2) n) amortized time on an n-node forest and each standard dynamic tree operation takes O(log n) time; the latter bound is amortized, worst case, or randomized depending on the underlying data structure. For the special case that occurs in the motivating application, in which arbitrary arc deletions (cuts) do not occur, we give a method that takes O(log n) time per operation, including merging. This is best possible in a model of computation with an Omega(nlog n) lower bound for sorting n numbers, since such sorting can be done in O(n) tree operations. For the even-more-special case in which there are no cuts and no parent queries, we give a method that uses standard dynamic trees as a black box: each mergeable tree operation becomes a constant number of standard dynamic tree operations. This third method can also be used in the motivating application, but only by changing the algorithm in the application. Each of our three methods needs different analytical tools and reveals different properties of dynamic trees.", "paper_title": "Data Structures for Mergeable Trees", "paper_id": "WOS:000292839300001"}