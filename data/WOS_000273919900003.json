{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "high-dimensional_knn"}, {"score": 0.04053713504171759, "phrase": "high-dimensional_data"}, {"score": 0.004716520738331953, "phrase": "incremental_updates"}, {"score": 0.004620093797504386, "phrase": "k_nearest_neighbor"}, {"score": 0.004463723624910583, "phrase": "operation_associates"}, {"score": 0.004053362743156545, "phrase": "different_data"}, {"score": 0.003531474887552889, "phrase": "high-dimensional_knn_join"}, {"score": 0.0034118234596993836, "phrase": "static_data_sets"}, {"score": 0.0028321862184182913, "phrase": "efficient_incremental_computation"}, {"score": 0.002467140591777737, "phrase": "reverse_knn_queries"}, {"score": 0.0023346234464901978, "phrase": "extensive_experimental_study"}, {"score": 0.0021049977753042253, "phrase": "dynamic_workloads"}], "paper_keywords": ["Query optimization", " Storage & access", " Optimization and performance"], "paper_abstract": "The k Nearest Neighbor (kNN) join operation associates each data object in one data set with its k nearest neighbors from the same or a different data set. The kNN join on high-dimensional data (high-dimensional kNN join) is a very expensive operation. Existing high-dimensional kNN join algorithms were designed for static data sets and therefore cannot handle updates efficiently. In this article, we propose a novel kNN join method, named kNNJoin(+), which supports efficient incremental computation of kNN join results with updates on high-dimensional data. As a by-product, our method also provides answers for the reverse kNN queries with very little overhead. We have performed an extensive experimental study. The results show the effectiveness of kNNJoin(+) for processing high-dimensional kNN joins in dynamic workloads.", "paper_title": "High-dimensional kNN joins with incremental updates", "paper_id": "WOS:000273919900003"}