{"auto_keywords": [{"score": 0.037383488419657, "phrase": "abc_model"}, {"score": 0.004690025569165577, "phrase": "synchrony_conditions"}, {"score": 0.0045855181084455444, "phrase": "purely_asynchronous_model"}, {"score": 0.00443308765153716, "phrase": "message_delays"}, {"score": 0.004205940624913343, "phrase": "execution_patterns"}, {"score": 0.004174451361776433, "phrase": "network_topology"}, {"score": 0.004112267396643521, "phrase": "abc"}, {"score": 0.0039456466422100045, "phrase": "forward-and_backward-oriented_messages"}, {"score": 0.003785836059995376, "phrase": "asynchronous_execution"}, {"score": 0.0037153426267756452, "phrase": "clock_synchronization"}, {"score": 0.003459191419478298, "phrase": "byzantine_failures"}, {"score": 0.0032941471167321408, "phrase": "partially_synchronous_theta-model"}, {"score": 0.003113441660343867, "phrase": "novel_method"}, {"score": 0.0030554300179552415, "phrase": "asynchronous_executions"}, {"score": 0.002953711377604328, "phrase": "farkas'_theorem"}, {"score": 0.002931569771634119, "phrase": "linear_inequalities"}, {"score": 0.0028986672783671147, "phrase": "non-standard_cycle_space"}, {"score": 0.0028233196851239753, "phrase": "point-set_topology"}, {"score": 0.002719055901632759, "phrase": "delay_assignment"}, {"score": 0.0026986685585382347, "phrase": "model_indistinguishability"}, {"score": 0.002678433668156676, "phrase": "time-free_safety"}, {"score": 0.002502995662011305, "phrase": "existing_partially_synchronous_system_models"}, {"score": 0.0024656025278901824, "phrase": "dwork"}, {"score": 0.002447105073248825, "phrase": "lynch"}, {"score": 0.0024287496682099735, "phrase": "stockmayer"}, {"score": 0.0024014759148123736, "phrase": "query-response_model"}, {"score": 0.0023834640793589435, "phrase": "mostefaoui"}, {"score": 0.002365587018070219, "phrase": "mourgaya"}, {"score": 0.002339022282471467, "phrase": "raynal"}, {"score": 0.002252602622785975, "phrase": "abc_model's_applicability"}, {"score": 0.0021530945641993152, "phrase": "vlsi_systems-on-chip"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Fault-tolerant distributed algorithms", " Partially synchronous models", " Clock synchronization", " VLSI"], "paper_abstract": "This paper shows how synchrony conditions can be added to the purely asynchronous model in a way that avoids any reference to message delays and computing step times, as well as system-wide constraints on execution patterns and network topology. Our Asynchronous Bounded-Cycle (ABC) model just bounds the ratio of the number of forward-and backward-oriented messages in certain (\"relevant\") cycles in the space-time diagram of an asynchronous execution. We show that clock synchronization and lock-step rounds can be implemented and proved correct in the ABC model, even in the presence of Byzantine failures. Furthermore, we prove that any algorithm working correctly in the partially synchronous Theta-Model also works correctly in the ABC model. In our proof, we first apply a novel method for assigning certain message delays to asynchronous executions, which is based on a variant of Farkas' theorem of linear inequalities and a non-standard cycle space of graphs. Using methods from point-set topology, we then prove that the existence of this delay assignment implies model indistinguishability for time-free safety and liveness properties. We also introduce several weaker variants of the ABC model, and relate our model to the existing partially synchronous system models, in particular, the classic models of Dwork, Lynch and Stockmayer and the query-response model by Mostefaoui, Mourgaya, and Raynal. Finally, we discuss some aspects of the ABC model's applicability in real systems, in particular, in the context of VLSI Systems-on-Chip. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "The Asynchronous Bounded-Cycle model", "paper_id": "WOS:000295106600006"}