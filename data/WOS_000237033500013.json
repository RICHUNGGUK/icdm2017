{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "bloom_filters"}, {"score": 0.00471193241675062, "phrase": "first_algorithm"}, {"score": 0.0045124316982387315, "phrase": "longest_prefix"}, {"score": 0.004340081802944066, "phrase": "parallel_queries"}, {"score": 0.004174287115855492, "phrase": "membership_queries"}, {"score": 0.0040672766251859975, "phrase": "address_prefix_membership"}, {"score": 0.003945879572348638, "phrase": "prefix_length"}, {"score": 0.003795086335272422, "phrase": "internet_protocol"}, {"score": 0.0037138072936226, "phrase": "lookups_results"}, {"score": 0.003665874747419775, "phrase": "search_engine"}, {"score": 0.003634262647873338, "phrase": "better_performance"}, {"score": 0.003571850980647625, "phrase": "tcam-based_approaches"}, {"score": 0.003525744120930142, "phrase": "key_feature"}, {"score": 0.0033182992967343916, "phrase": "dependent_memory_accesses"}, {"score": 0.00319141242685261, "phrase": "longer_address_lengths"}, {"score": 0.003163878786694538, "phrase": "additional_unique_address_prefix_lengths"}, {"score": 0.0030693625816617044, "phrase": "memory_resources"}, {"score": 0.002939202022371694, "phrase": "forwarding_table"}, {"score": 0.0028513785049061767, "phrase": "internet_protocol_version"}, {"score": 0.002637377202509382, "phrase": "basic_version"}, {"score": 0.0025585490847951703, "phrase": "previous_advances"}, {"score": 0.0025364615261136655, "phrase": "lpm_algorithms"}, {"score": 0.0024606422183102382, "phrase": "performance_simulations"}, {"score": 0.0022759626674997173, "phrase": "ram"}, {"score": 0.0022464835515931592, "phrase": "commodity_sram_device"}, {"score": 0.002207851585508636, "phrase": "average_performance"}, {"score": 0.0021418339161425994, "phrase": "worst_case"}], "paper_keywords": ["Bloom filter", " computer networking", " IP lookup", " longest prefix matching"], "paper_abstract": "We introduce the first algorithm that we are aware of to employ Bloom filters for longest prefix matching (LPM). The algorithm performs parallel queries on Bloom filters, an efficient data structure for membership queries, in order to determine address prefix membership in sets of prefixes sorted by prefix length. We show that use of this algorithm for Internet Protocol (IP) routing lookups results in a search engine providing better performance and scalability than TCAM-based approaches. The key feature of our technique is that the performance, as determined by the number of dependent memory accesses per lookup, can be held constant for longer address lengths or additional unique address prefix lengths in the forwarding table given that memory resources scale linearly with the number of prefixes in the forwarding table. Our approach is equally attractive for Internet Protocol Version 6 (IPv6) which uses 128-bit destination addresses, four times longer than IPv4. We present a basic version of our approach along with optimizations leveraging previous advances in LPM algorithms. We also report results of performance simulations of our system using snapshots of IPv4 BGP tables and extend the results to IPv6. Using less than 2 Mb of embedded RAM and a commodity SRAM device, our technique achieves average performance of one hash probe per lookup and a worst case of two hash probes and one array access per lookup.", "paper_title": "Longest prefix matching using bloom filters", "paper_id": "WOS:000237033500013"}