{"auto_keywords": [{"score": 0.03818620838813371, "phrase": "mac_protocol"}, {"score": 0.015467388594408032, "phrase": "mac_protocols"}, {"score": 0.004815129954436975, "phrase": "mac"}, {"score": 0.004698229304089357, "phrase": "wireless_sensor_networks"}, {"score": 0.004509919457793852, "phrase": "correct_timing"}, {"score": 0.0039402177950179345, "phrase": "larger_mac_protocol_code_size"}, {"score": 0.003736004578001584, "phrase": "basic_functionality"}, {"score": 0.0034847851398628546, "phrase": "different_way"}, {"score": 0.003223883109446599, "phrase": "common_functionality"}, {"score": 0.002827740707723551, "phrase": "mac_extensions"}, {"score": 0.0027253441561528495, "phrase": "working_implementation"}, {"score": 0.002637434388160821, "phrase": "b-mac"}, {"score": 0.0026159023233741792, "phrase": "tinyos"}, {"score": 0.002541910967437926, "phrase": "standard_tinyos_b-mac_implementation"}, {"score": 0.002370794661629904, "phrase": "similar_performance"}, {"score": 0.0022385401780982204, "phrase": "t-mac"}, {"score": 0.002220257443705344, "phrase": "lmac"}, {"score": 0.002193112810577616, "phrase": "crankshaft"}, {"score": 0.0021223334214910006, "phrase": "real-world_experience"}], "paper_keywords": ["Wireless sensor networks", " MAC protocols", " Protocol architecture"], "paper_abstract": "Most current WSN MAC protocol implementations have multiple tasks to perform deciding on correct timing, sending of packets, sending of acknowledgements, etc. However, as much of this is common to all MAC protocols, there is duplication of functionality, which leads to larger MAC protocol code size and therefore increasing numbers of bugs. Additionally, extensions to the basic functionality must be separately implemented in each MAC protocol. In this paper, we look at a different way to design a MAC protocol, focusing on the providing of interfaces which can be used to implement the common functionality separately. This leaves the core of the MAC protocol, determining only when to send, which is substantially different for each protocol. We also look at some examples of MAC extensions that this approach enables. We demonstrate a working implementation of these principles as an implementation of B-MAC for TinyOS, and compare it with the standard TinyOS B-MAC implementation. We show a 35% smaller code size, with the same overall functionality but increased extensibility, and while maintaining similar performance. We also present results and experiences from using the same framework to implement T-MAC, LMAC, and Crankshaft. All are demonstrated with data from real-world experience using our 24 node testbed.", "paper_title": "The lambda MAC framework: redefining MAC protocols for wireless sensor networks", "paper_id": "WOS:000282914100013"}