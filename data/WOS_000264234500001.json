{"auto_keywords": [{"score": 0.023128937234491477, "phrase": "sq"}, {"score": 0.00481495049065317, "phrase": "age_registers"}, {"score": 0.004674952036988355, "phrase": "simple_load-store_queue_filtering"}, {"score": 0.004450568197899267, "phrase": "main_challenges"}, {"score": 0.004363846362238565, "phrase": "modern_processor_design"}, {"score": 0.0041136473765874815, "phrase": "scalable_and_efficient_mechanism"}, {"score": 0.003993958025223994, "phrase": "memory_access_order_violations"}, {"score": 0.003802135020791801, "phrase": "out-of-order_execution"}, {"score": 0.003728000957725218, "phrase": "traditional_age-ordered_associative_load"}, {"score": 0.0027469703311742647, "phrase": "timing_information"}, {"score": 0.00266693888510356, "phrase": "primary_instrument"}, {"score": 0.0025638362414466278, "phrase": "dependence_violation"}, {"score": 0.0024891269874339553, "phrase": "memory_dependences"}, {"score": 0.0022777800735119405, "phrase": "energy_cost"}, {"score": 0.0022113879114507577, "phrase": "associative_lq"}, {"score": 0.0021049977753042253, "phrase": "performance_degradation"}], "paper_keywords": ["LSQ", " Age registers", " Age-based Filtering", " Energy-efficiency"], "paper_abstract": "One of the main challenges of modern processor design is the implementation of a scalable and efficient mechanism to detect memory access order violations as a result of out-of-order execution. Traditional age-ordered associative load and store queues are complex, inefficient. and power-hungry. In this paper, we introduce two new LSQ filtering mechanisms with different design tradeoffs, but both explicitly rely on timing information as a primary instrument to rule out dependence violation and enforce memory dependences. Our timing-centric design operates at a fraction of the energy cost of an associative LQ and SQ with no performance degradation. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Using age registers for a simple load-store queue filtering", "paper_id": "WOS:000264234500001"}