{"auto_keywords": [{"score": 0.04969089536874817, "phrase": "phase_selection"}, {"score": 0.00481495049065317, "phrase": "optimization_phase_selection_during_dynamic_jit_compilation"}, {"score": 0.004641770842098217, "phrase": "applied_set"}, {"score": 0.004604136423327813, "phrase": "compiler_optimization_phases"}, {"score": 0.004566805735863274, "phrase": "individual_functions"}, {"score": 0.0044385053213394175, "phrase": "generated_code"}, {"score": 0.004331393784852601, "phrase": "novel_feature-vector"}, {"score": 0.004192571571622019, "phrase": "online_jit_compilation"}, {"score": 0.004091370602573054, "phrase": "program_startup_speed"}, {"score": 0.004058180509184539, "phrase": "steady-state_performance"}, {"score": 0.003912112659326054, "phrase": "fixed_single_sequence_baseline"}, {"score": 0.003695237613399466, "phrase": "steady-state_performance_gain"}, {"score": 0.0035913348026306306, "phrase": "existing_online_phase_selection_heuristics"}, {"score": 0.003378385493203297, "phrase": "online_jit_environments"}, {"score": 0.0031650944584992726, "phrase": "phase_selection_related_behavior"}, {"score": 0.0030262967460085366, "phrase": "existing_heuristic_solutions"}, {"score": 0.0028121429464519733, "phrase": "phase_selection_problem"}, {"score": 0.00278930116312699, "phrase": "jit_compilers"}, {"score": 0.0027330029055210926, "phrase": "long-running_genetic_algorithms"}, {"score": 0.002613103872300205, "phrase": "ideal_steady-state_performance_gains"}, {"score": 0.0024083881142747954, "phrase": "existing_state-of-the-art_heuristic_solutions"}, {"score": 0.002274684393868218, "phrase": "possible_causes"}, {"score": 0.00220163445285539, "phrase": "optimization_phase_behavior"}, {"score": 0.0021222476760114914, "phrase": "robust_open-source_production-quality_framework"}], "paper_keywords": ["Performance", " Experimentation", " Languages", " Phase selection", " Compiler optimizations", " HotSpot"], "paper_abstract": "Phase selection is the process of customizing the applied set of compiler optimization phases for individual functions or programs to improve performance of generated code. Researchers have recently developed novel feature-vector based heuristic techniques to perform phase selection during online JIT compilation. While these heuristics improve program startup speed, steady-state performance was not seen to benefit over the default fixed single sequence baseline. Unfortunately, it is still not conclusively known whether this lack of steady-state performance gain is due to a failure of existing online phase selection heuristics, or because there is, indeed, little or no speedup to be gained by phase selection in online JIT environments. The goal of this work is to resolve this question, while examining the phase selection related behavior of optimizations, and assessing and improving the effectiveness of existing heuristic solutions. We conduct experiments to find and understand the potency of the factors that can cause the phase selection problem in JIT compilers. Next, using long-running genetic algorithms we determine that program-wide and method-specific phase selection in the HotSpot JIT compiler can produce ideal steady-state performance gains of up to 15% (4.3% average) and 44% (6.2% average) respectively. We also find that existing state-of-the-art heuristic solutions are unable to realize these performance gains (in our experimental setup), discuss possible causes, and show that exploiting knowledge of optimization phase behavior can help improve such heuristic solutions. Our work develops a robust open-source production-quality framework using the HotSpot JVM to further explore this problem in the future.", "paper_title": "Performance Potential of Optimization Phase Selection During Dynamic JIT Compilation", "paper_id": "WOS:000324470900013"}