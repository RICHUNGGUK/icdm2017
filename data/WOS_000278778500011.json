{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "canonicalization_algorithm"}, {"score": 0.0043953478557600565, "phrase": "hash_algorithm"}, {"score": 0.0038551626276406175, "phrase": "previous_related_work"}, {"score": 0.003641433168173135, "phrase": "blank_nodes"}, {"score": 0.0034395119150793787, "phrase": "canonical_serialization"}, {"score": 0.003051073364818384, "phrase": "potential_applications"}, {"score": 0.0028167336373711494, "phrase": "computing_differences"}, {"score": 0.002753138528582461, "phrase": "graph_synchronization"}, {"score": 0.0022933216359142736, "phrase": "big_dataset"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Semantic Web", " Notation 3", " RDF", " Hash"], "paper_abstract": "This paper presents a hash and a canonicalization algorithm for Notation 3 (N3) and Resource Description Framework (RDF) graphs. The hash algorithm produces, given a graph, a hash value such that the same value would be obtained from any other equivalent graph. Contrary to previous related work, it is well-suited for graphs with blank nodes, variables and subgraphs. The canonicalization algorithm outputs a canonical serialization of a given graph (i.e. a canonical representative of the set of all the graphs that are equivalent to it). Potential applications of these algorithms include, among others, checking graphs for identity, computing differences between graphs and graph synchronization. The former could be especially useful for crawlers that gather RDF/N3 data from the Web, to avoid processing several times graphs that are equivalent. Both algorithms have been evaluated on a big dataset, with more than 29 million triples and several millions of subgraphs and variables. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "Hashing and canonicalizing Notation 3 graphs", "paper_id": "WOS:000278778500011"}