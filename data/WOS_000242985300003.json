{"auto_keywords": [{"score": 0.042359072210759886, "phrase": "group_query"}, {"score": 0.009712602141945671, "phrase": "special_frequent_cases"}, {"score": 0.00791028158035118, "phrase": "sql"}, {"score": 0.007263081403656924, "phrase": "group_queries"}, {"score": 0.005187084385607369, "phrase": "extended_syntax"}, {"score": 0.00481495049065317, "phrase": "complex_queries"}, {"score": 0.004789787025402563, "phrase": "complex_analysis"}, {"score": 0.004756439208898034, "phrase": "massive_data_stores"}, {"score": 0.004682249073883829, "phrase": "significant_aggregation"}, {"score": 0.004665919428735841, "phrase": "different_attribute_sets"}, {"score": 0.004617269822144303, "phrase": "participating_relations"}, {"score": 0.004358584453134808, "phrase": "specialized_algorithms"}, {"score": 0.00433579561641877, "phrase": "complex_aggregate_queries"}, {"score": 0.004313125414855644, "phrase": "better_execution_plans"}, {"score": 0.004194196152885942, "phrase": "aggregate_queries"}, {"score": 0.004064300046551393, "phrase": "main_characteristic"}, {"score": 0.0038499137517691187, "phrase": "disjoint_groups"}, {"score": 0.0037111224061086357, "phrase": "complex_operation"}, {"score": 0.003509157568063135, "phrase": "grouping_attributes"}, {"score": 0.0034907943842402097, "phrase": "naive_plan"}, {"score": 0.0034004049624346846, "phrase": "relatively_small_base_relations"}, {"score": 0.003359025219414365, "phrase": "groupwise_evaluation"}, {"score": 0.0033356053735972024, "phrase": "huge_performance_gains"}, {"score": 0.003306559295382181, "phrase": "syntactic_criterion"}, {"score": 0.003154012038613403, "phrase": "chatziantoniou"}, {"score": 0.003143004895665077, "phrase": "ross"}, {"score": 0.0031265422943020774, "phrase": "multiple_features"}, {"score": 0.0031047383199118836, "phrase": "relational_databases"}, {"score": 0.0030669459467997547, "phrase": "vldb"}, {"score": 0.002905014836964794, "phrase": "complex_decision_support_query"}, {"score": 0.002884751286783386, "phrase": "different_sets"}, {"score": 0.002766095838413097, "phrase": "parallel_execution"}, {"score": 0.0027564303939865476, "phrase": "multi-query_processing"}, {"score": 0.0027372004299239176, "phrase": "special_cases"}, {"score": 0.002685005104010837, "phrase": "complex_aggregate_query"}, {"score": 0.0026523079380037706, "phrase": "groupwise_processing"}, {"score": 0.0026200079019908025, "phrase": "research_community"}, {"score": 0.0025610594062592243, "phrase": "relational_system"}, {"score": 0.0025166162153444135, "phrase": "relational_operator"}, {"score": 0.0024729423545448207, "phrase": "generalized_groupwise_operator"}, {"score": 0.0024300245722317874, "phrase": "naive_optimization"}, {"score": 0.002417294719663267, "phrase": "new_operator"}, {"score": 0.002396225962168334, "phrase": "consideration_decompositions"}, {"score": 0.002387849842770347, "phrase": "group_query_components"}, {"score": 0.0023097192880965965, "phrase": "efficient_algorithms"}, {"score": 0.0022976182115685756, "phrase": "specific_operators"}, {"score": 0.0022895859890647175, "phrase": "common_operations"}, {"score": 0.002206920631147511, "phrase": "multi-feature_queries"}, {"score": 0.002195356952012696, "phrase": "frequent_and_practical_subclass"}, {"score": 0.0021648151927460813, "phrase": "specialized_evaluation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["query processing", " query languages", " decision support queries", " OLAP"], "paper_abstract": "Performing complex analysis on top of massive data stores is essential to most modern enterprises and organizations and requires significant aggregation over different attribute sets (dimensions) of the participating relations. Such queries may take hours or days, a time period unacceptable in most cases. As a result. it is important to study these queries and identify special frequent cases that can be evaluated with specialized algorithms. Understanding complex aggregate queries leads to better execution plans and, consequently, performance. The idea of partitioning is fundamental and central in aggregate queries. This concept can be used to define a class of queries called group queries. The main characteristic of a group query is that it can be evaluated in a partitioned (or groupwise) fashion, i.e. the underlying relation(s) can be partitioned (based on a set of attributes) into disjoint groups and each group can be processed separately, possibly in parallel. For example, a query that performs a complex operation (e.g. joins and/or selections and/or aggregations) within each group is a group query. To express it in SQL, one has to join/ correlate several views and/or subqueries on the grouping attributes. A naive plan (where the joins are executed) may be very expensive, even for relatively small base relations. On the other hand, a groupwise evaluation can lead to huge performance gains. We present a syntactic criterion to identify group queries in SQL and show that every group query can be expressed in a way that satisfies this criterion. This work is based on Chatziantoniou and Ross [Querying Multiple Features of Groups in Relational Databases. in: 22nd International Conference on Very Large Databases, VLDB, 1996, pp. 295-306]. The concept of group queries is useful not only in terms of evaluation, but also in terms of analyzing a complex decision support query that aggregates over different sets of attributes. In such a case the query may be decomposable to one or more query components, where each component is a group query. This observation allows parallel execution, multi-query processing and identification of special cases. We present in this paper two algorithms to decompose a complex aggregate query to its group query components. The value of groupwise processing has been recently recognized by the research community and implemented in at least a major commercial system. To be of use however in a relational system, partitioned evaluation has to be modeled as a relational operator. We review three different approaches for such art operator and propose a generalized groupwise operator. We also perform some experiments to show that naive optimization with the new operator incorporated without taking into consideration decompositions to group query components does not always lead to the most efficient plans. An extended syntax is another way to identify special frequent cases and apply efficient algorithms. Having specific operators for common operations contributes to the succinctness and optimizability of certain queries (e.g. datacubes). An extended syntax is presented with emphasis for multi-feature queries, a frequent and practical subclass of group queries that is amenable to specialized evaluation, involving (potentially repeated) selection, grouping and aggregation over the same groups. (c) 2005 Elsevier B.V. All rights reserved.", "paper_title": "Partitioned optimization of complex queries", "paper_id": "WOS:000242985300003"}