{"auto_keywords": [{"score": 0.049692788583269344, "phrase": "formal_methods"}, {"score": 0.008053169776215001, "phrase": "research_questions"}, {"score": 0.005927239166415188, "phrase": "software_projects"}, {"score": 0.005578224550255154, "phrase": "face_validity"}, {"score": 0.005433404532447303, "phrase": "data_sources"}, {"score": 0.00481495049065317, "phrase": "formal_methods_productivity"}, {"score": 0.004747183130811346, "phrase": "particularly_formal_verification"}, {"score": 0.0046332117780603635, "phrase": "large_highly_dependable_software-based_systems"}, {"score": 0.0044673416856925085, "phrase": "conventional_software_engineering"}, {"score": 0.004281284532043714, "phrase": "research_agenda"}, {"score": 0.004255342446883004, "phrase": "empirical_study"}, {"score": 0.004020640274574359, "phrase": "existing_literature"}, {"score": 0.0037681581962499453, "phrase": "gqm_goals"}, {"score": 0.00374531366198605, "phrase": "investigative_framework"}, {"score": 0.003574695610710444, "phrase": "easterbrook_et_al"}, {"score": 0.0033774069835885065, "phrase": "possible_metrics"}, {"score": 0.003336563638887121, "phrase": "extensive_use"}, {"score": 0.003274208090431613, "phrase": "empirical_studies"}, {"score": 0.003269582529879389, "phrase": "nicta"}, {"score": 0.0031974502006267163, "phrase": "code-level_formal_verification"}, {"score": 0.0030086877092638945, "phrase": "new_type"}, {"score": 0.0029965060407413898, "phrase": "project_context"}, {"score": 0.0029542561523176565, "phrase": "different_artefacts"}, {"score": 0.002930380574990973, "phrase": "formal_methods_projects"}, {"score": 0.002685558057339722, "phrase": "highest_level_concepts"}, {"score": 0.002547535564922075, "phrase": "micro_level"}, {"score": 0.0025167026017217926, "phrase": "significant_differences"}, {"score": 0.0024963543716522087, "phrase": "empirical_software_engineering"}, {"score": 0.002471149712847188, "phrase": "large_open_research_field"}, {"score": 0.0024511688853030168, "phrase": "empirical_software_engineering_community"}, {"score": 0.0023680327896318915, "phrase": "formal_methods_community"}, {"score": 0.0023063614119692476, "phrase": "effective_management"}, {"score": 0.002297016792528015, "phrase": "large_formal_methods_projects"}, {"score": 0.0022738201751000865, "phrase": "basic_metrics"}, {"score": 0.0022056233158107828, "phrase": "efficient_software_engineering_practice"}, {"score": 0.0021789194955896102, "phrase": "future_research"}, {"score": 0.0021394674440767124, "phrase": "emerging_field"}, {"score": 0.0021307975800397816, "phrase": "proof_engineering"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Empirical software engineering", " Productivity", " GQM", " Formal methods", " Formal verification", " Proof Engineering"], "paper_abstract": "Context: Formal methods, and particularly formal verification, is becoming more feasible to use in the engineering of large highly dependable software-based systems, but so far has had little rigorous empirical study. Its artefacts and activities are different to those of conventional software engineering, and the nature and drivers of productivity for formal methods are not yet understood. Objective: To develop a research agenda for the empirical study of productivity in software projects using formal methods and in particular formal verification. To this end we aim to identify research questions about productivity in formal methods, and survey existing literature on these questions to establish face validity of these questions. And further we aim to identify metrics and data sources relevant to these questions. Method: We define a space of GQM goals as an investigative framework, focusing on productivity from the perspective of managers of projects using formal methods. We then derive questions for these goals using Easterbrook et al.'s (2008) taxonomy of research questions. To establish face validity, we document the literature to date that reflects on these questions and then explore possible metrics related to these questions. Extensive use is made of literature concerning the L4.verified project completed within NICTA, as it is one of the few projects to achieve code-level formal verification for a large-scale industrially deployed software system. Results: We identify more than thirty research questions on the topic in need of investigation. These questions arise not just out of the new type of project context, but also because of the different artefacts and activities in formal methods projects. Prior literature supports the need for research on the questions in our catalogue, but as yet provides little evidence about them. Metrics are identified that would be needed to investigate the questions. Thus although it is obvious that at the highest level concepts such as size, effort, rework and so on are common to all software projects, in the case of formal methods, measurement at the micro level for these concepts will exhibit significant differences. Conclusions: Empirical software engineering for formal methods is a large open research field. For the empirical software engineering community our paper provides a view into the entities and research questions in this domain. For the formal methods community we identify some of the benefits that empirical studies could bring to the effective management of large formal methods projects, and list some basic metrics and data sources that could support empirical studies. Understanding productivity is important in its own right for efficient software engineering practice, but can also support future research on cost-effectiveness of formal methods, and on the emerging field of Proof Engineering. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "An empirical research agenda for understanding formal methods productivity", "paper_id": "WOS:000349729700006"}