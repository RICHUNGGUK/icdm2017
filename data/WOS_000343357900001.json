{"auto_keywords": [{"score": 0.039972769215014484, "phrase": "related_algorithms"}, {"score": 0.03170834931407811, "phrase": "instruction_sequences"}, {"score": 0.00481495049065317, "phrase": "customized_instruction_identification"}, {"score": 0.004734853555630616, "phrase": "increasing_importance"}, {"score": 0.004695303774351139, "phrase": "application_domain_specific_processor"}, {"score": 0.004559451202070545, "phrase": "significant_challenge"}, {"score": 0.004483585361583022, "phrase": "special-purpose_operations"}, {"score": 0.004390517953424082, "phrase": "customized_instruction"}, {"score": 0.004105435059094972, "phrase": "single_algorithm"}, {"score": 0.00403709306806495, "phrase": "target_application_domain"}, {"score": 0.003903789851015775, "phrase": "instruction_sets"}, {"score": 0.003838791650587681, "phrase": "whole_family"}, {"score": 0.003743310268453678, "phrase": "entire_range"}, {"score": 0.003574364535717202, "phrase": "compound_operations"}, {"score": 0.003456287408801543, "phrase": "domain-specific\"_instruction_set_architectures"}, {"score": 0.0028370498057725796, "phrase": "iterative_constructs"}, {"score": 0.0027203027216256013, "phrase": "commonly-occurring_instruction_sequences"}, {"score": 0.0026414426081951734, "phrase": "different_combinations"}, {"score": 0.0025541050375256992, "phrase": "domain-specific_special_operations"}, {"score": 0.0024182831453515782, "phrase": "library_function"}, {"score": 0.002358050109031317, "phrase": "case_studies"}, {"score": 0.0022800613046444563, "phrase": "thirteen_string_matching_algorithms"}, {"score": 0.002177011650568437, "phrase": "independent_dynamic_analysis_experiments"}, {"score": 0.002158780936704905, "phrase": "performance_improvement_measurements"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Customized instructions", " Special purpose operations", " Static analysis", " Domain-specific analysis"], "paper_abstract": "With the increasing importance of Application Domain Specific Processor (ADSP) design, a significant challenge is to identify special-purpose operations for implementation as a customized instruction. While many methodologies have been proposed for this purpose, they all work for a single algorithm chosen from the target application domain. Such algorithm-specific approaches are not suitable for designing instruction sets applicable to a whole family of related algorithms. For an entire range of related algorithms, this paper develops a methodology for identifying compound operations, as a basis for designing \"domain-specific\" Instruction Set Architectures (ISAs) that can efficiently run most of the algorithms in a given domain. Our methodology combines three different static analysis techniques to identify instruction sequences common to several related algorithms: identification of (non-branching) instruction sequences that occur commonly across the algorithms; identification of instruction sequences nested within iterative constructs that are thus executed frequently; and identification of commonly-occurring instruction sequences that span basic blocks. Choosing different combinations of these results enables us to design domain-specific special operations with different desired characteristics, such as performance or suitability as a library function. To demonstrate our approach, case studies are carried out for a family of thirteen string matching algorithms. Finally, the validity of our static analysis results is confirmed through independent dynamic analysis experiments and performance improvement measurements. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Domain-specific application analysis for customized instruction identification", "paper_id": "WOS:000343357900001"}