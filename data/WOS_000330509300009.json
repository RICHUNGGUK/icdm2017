{"auto_keywords": [{"score": 0.030584465532295452, "phrase": "manually_parallelized_version"}, {"score": 0.010180341166979731, "phrase": "mudflap"}, {"score": 0.008377758117580309, "phrase": "simulated_eight-core_system"}, {"score": 0.00481495049065317, "phrase": "automatic_parallelization_of_fine-grained_metafunctions"}, {"score": 0.004767261858417823, "phrase": "chip_multiprocessor"}, {"score": 0.004490842671590769, "phrase": "security_vulnerabilities"}, {"score": 0.004402295697276237, "phrase": "software_techniques"}, {"score": 0.004272724011826495, "phrase": "large_runtime_overheads"}, {"score": 0.0041469500929423595, "phrase": "automatic_thread_extraction_technique"}, {"score": 0.004092240621596351, "phrase": "fine-grained_checks"}, {"score": 0.004051680770486568, "phrase": "main_application"}, {"score": 0.003984968827278219, "phrase": "helper_threads"}, {"score": 0.003704196857903231, "phrase": "fine-grained_checking_codes"}, {"score": 0.003595097948724078, "phrase": "single_threaded_application"}, {"score": 0.0035358770665604657, "phrase": "customized_helper_threads"}, {"score": 0.0034660938095219846, "phrase": "relevant_fragments"}, {"score": 0.0034317185678527672, "phrase": "main_program's_behavior"}, {"score": 0.0032975819773787985, "phrase": "good_performance"}, {"score": 0.0030145766837536034, "phrase": "gcc."}, {"score": 0.002801983400946225, "phrase": "architectural_simulator"}, {"score": 0.0027649684074145028, "phrase": "fast_queueing_operations"}, {"score": 0.0026656724016739905, "phrase": "static_load_balance"}, {"score": 0.0024941578231560055, "phrase": "dynamic_load_balance"}, {"score": 0.0023336530061840244, "phrase": "better_speedups"}, {"score": 0.002287542098172185, "phrase": "manual_approach"}, {"score": 0.0022200746395981876, "phrase": "main_program"}, {"score": 0.0021049977753042253, "phrase": "serial_mudflap"}], "paper_keywords": ["Automatic parallelization", " helper computing", " chip multiprocessor"], "paper_abstract": "Due to the importance of reliability and security, prior studies have proposed inlining metafunctions into applications for detecting bugs and security vulnerabilities. However, because these software techniques add frequent, fine-grained instrumentation to programs, they often incur large runtime overheads. In this work, we consider an automatic thread extraction technique for removing these fine-grained checks from a main application and scheduling them on helper threads. In this way, we can leverage the resources available on a CMP to reduce the latency and overhead of fine-grained checking codes. Our parallelization strategy extracts metafunctions from a single threaded application and executes them in customized helper threads-threads constructed to mirror relevant fragments of the main program's behavior in order to keep communication and overhead low. To get good performance, we consider optimizations that reduce communication and balance work among many threads. We evaluate our parallelization strategy on Mudflap, a pointer-use checking tool in GCC. To show the benefits of our technique, we compare it to a manually parallelized version of Mudflap. We run our experiments on an architectural simulator with support for fast queueing operations. On a subset of SPECint 2000, our automatically parallelized code using static load balance is only 19% slower, on average, than the manually parallelized version on a simulated eight-core system. In addition, our automatically parallelized code using dynamic load balance is competitive, on average, to the manually parallelized version on a simulated eight-core system. Furthermore, all the applications except parser achieve better speedups with our automatic algorithms than with the manual approach. Also, our approach introduces very little overhead in the main program-it is kept under 100%, which is more than a 5.3x reduction compared to serial Mudflap.", "paper_title": "Automatic Parallelization of Fine-Grained Metafunctions on a Chip Multiprocessor", "paper_id": "WOS:000330509300009"}