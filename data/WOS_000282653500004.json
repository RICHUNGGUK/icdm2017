{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "automatic_modular"}, {"score": 0.004435885269134359, "phrase": "abstract_transformers"}, {"score": 0.004380265418103948, "phrase": "static_analysis"}, {"score": 0.004325339932975582, "phrase": "abstract_interpretation"}, {"score": 0.004164644263639545, "phrase": "linear_constraints"}, {"score": 0.003717368939083015, "phrase": "abstract_domain"}, {"score": 0.0034028574973016933, "phrase": "corresponding_abstract_transformer"}, {"score": 0.003235193484261443, "phrase": "program_transformation"}, {"score": 0.0031346115554600003, "phrase": "loop-free_code"}, {"score": 0.002980124909321296, "phrase": "least_fixed_points"}, {"score": 0.0027278178983579085, "phrase": "recursive_functions"}, {"score": 0.002609770322855842, "phrase": "data-flow_synchronous_programming_languages"}, {"score": 0.0023887436047824386, "phrase": "imperative_and_functional_programming"}, {"score": 0.002285335999629823, "phrase": "quantifier_elimination"}, {"score": 0.002256619934086924, "phrase": "symbolic_manipulation_techniques"}, {"score": 0.002228263890334039, "phrase": "linear_arithmetic_formulas"}, {"score": 0.0021317885325570604, "phrase": "nonlinear_constraints"}, {"score": 0.0021049977753042253, "phrase": "nonlinear_program_constructs"}], "paper_keywords": [""], "paper_abstract": "We propose a method for automatically generating abstract transformers for static analysis by abstract interpretation. The method focuses on linear constraints on programs operating on rational, real or floating-point variables and containing linear assignments and tests. Given the specification of an abstract domain,and a program block, our method automatically outputs an implementation of the corresponding abstract transformer. It is thus a form of program transformation. In addition to loop-free code, the same method also applies for obtaining least fixed points as functions of the precondition, which permits the analysis of loops and recursive functions. The motivation of our work is data-flow synchronous programming languages, used for building control-command embedded systems, but it also applies to imperative and functional programming. Our algorithms are based on quantifier elimination and symbolic manipulation techniques over linear arithmetic formulas. We also give less general results for nonlinear constraints and nonlinear program constructs.", "paper_title": "AUTOMATIC MODULAR ABSTRACTIONS FOR TEMPLATE NUMERICAL CONSTRAINTS", "paper_id": "WOS:000282653500004"}