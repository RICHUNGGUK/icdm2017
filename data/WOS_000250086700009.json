{"auto_keywords": [{"score": 0.004240116703465252, "phrase": "compositional_development_methods"}, {"score": 0.004180622964109706, "phrase": "concurrent_programs"}, {"score": 0.003813669883040509, "phrase": "underlying_concurrent_language"}, {"score": 0.003760137090849196, "phrase": "fine-grained_interleaving"}, {"score": 0.003503497128638099, "phrase": "operational_semantics"}, {"score": 0.0030630037175103032, "phrase": "structural_induction"}, {"score": 0.002998688867384969, "phrase": "key_lemma"}, {"score": 0.002793874145713024, "phrase": "extra_interference"}, {"score": 0.0023079225317714815, "phrase": "computation_history"}, {"score": 0.0021350169717509714, "phrase": "expressibility_issues"}, {"score": 0.0021049977753042253, "phrase": "auxiliary_variables"}], "paper_keywords": ["rely/guarantee reasoning", " structural operational semantics", " soundness", " structural induction", " concurrency"], "paper_abstract": "Various forms of rely/guarantee conditions have been used to record and reason about interference in ways that provide compositional development methods for concurrent programs. This article illustrates such a set of rules and proves their soundness. The underlying concurrent language allows fine-grained interleaving and nested concurrency; it is defined by an operational semantics; the proof that the rely/guarantee rules are consistent with that semantics (including termination) is by a structural induction. A key lemma which relates the states which can arise from the extra interference that results from taking a portion of the program out of context makes it possible to do the proofs without having to perform induction over the computation history. This lemma also offers a way to think about expressibility issues around auxiliary variables in rely/guarantee conditions.", "paper_title": "A structural proof of the soundness of rely/guarantee rules", "paper_id": "WOS:000250086700009"}