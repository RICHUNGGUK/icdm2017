{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "variational_lambda_calculus"}, {"score": 0.0047761092701293474, "phrase": "conditional_compilation"}, {"score": 0.004737579882204798, "phrase": "software_product_line_technologies"}, {"score": 0.004605147081797856, "phrase": "huge_number"}, {"score": 0.004567990533989851, "phrase": "different_programs"}, {"score": 0.004512814529823301, "phrase": "single_software_project"}, {"score": 0.004263972370406983, "phrase": "sheer_number"}, {"score": 0.004229556887896042, "phrase": "possible_variants"}, {"score": 0.004078078530972285, "phrase": "type_system"}, {"score": 0.003916098498242888, "phrase": "lambda_calculus"}, {"score": 0.003884479830773329, "phrase": "basic_constructs"}, {"score": 0.003670157084732341, "phrase": "brute-force_strategy"}, {"score": 0.003453584878128719, "phrase": "type_inference"}, {"score": 0.003384262486955773, "phrase": "entire_variational_expression"}, {"score": 0.0033029038236817372, "phrase": "type_error"}, {"score": 0.0031459887611258765, "phrase": "vlc_expressions"}, {"score": 0.003120568497402472, "phrase": "type_errors"}, {"score": 0.00303319936111073, "phrase": "ill-typed_variants"}, {"score": 0.0029965060407413898, "phrase": "incremental_development"}, {"score": 0.0029722900280316216, "phrase": "variational_programs"}, {"score": 0.0028541057064952876, "phrase": "variational_types"}, {"score": 0.002762941385784905, "phrase": "principal_typing_property"}, {"score": 0.0027184540871935284, "phrase": "underlying_unification_problem"}, {"score": 0.0026530590435527527, "phrase": "partial_unifiers"}, {"score": 0.0026103363762901423, "phrase": "result_types"}, {"score": 0.0023680327896318915, "phrase": "empirical_evaluation"}, {"score": 0.0022011501095573747, "phrase": "brute-force_approach"}, {"score": 0.0021049977753042253, "phrase": "inference_process"}], "paper_keywords": ["error-tolerant type systems", " variational lambda calculus", " variational type inference", " variational types"], "paper_abstract": "Conditional compilation and software product line technologies make it possible to generate a huge number of different programs from a single software project. Typing each of these programs individually is usually impossible due to the sheer number of possible variants. Our previous work has addressed this problem with a type system for variational lambda calculus (VLC), an extension of lambda calculus with basic constructs for introducing and organizing variation. Although our type inference algorithm is more efficient than the brute-force strategy of inferring the types of each variant individually, it is less robust since type inference will fail for the entire variational expression if any one variant contains a type error. In this work, we extend our type system to operate on VLC expressions containing type errors. This extension directly supports locating ill-typed variants and the incremental development of variational programs. It also has many subtle implications for the unification of variational types. We show that our extended type system possesses a principal typing property and that the underlying unification problem is unitary. Our unification algorithm computes partial unifiers that lead to result types that (1) contain errors in as few variants as possible and (2) are most general. Finally, we perform an empirical evaluation to determine the overhead of this extension compared to our previous work, to demonstrate the improvements over the brute-force approach, and to explore the effects of various error distributions on the inference process.", "paper_title": "An Error-Tolerant Type System for Variational Lambda Calculus", "paper_id": "WOS:000311296000005"}