{"auto_keywords": [{"score": 0.049312845289349906, "phrase": "regenerating_codes"}, {"score": 0.035366979368155665, "phrase": "minimum_distance"}, {"score": 0.02322730111336097, "phrase": "local_regeneration"}, {"score": 0.016742452639901182, "phrase": "local_codes"}, {"score": 0.005967111986270265, "phrase": "upper_bound"}, {"score": 0.00447045328907701, "phrase": "data_collection"}, {"score": 0.0043846936613643256, "phrase": "efficient_node_repair"}, {"score": 0.004218057615518714, "phrase": "failed_node"}, {"score": 0.004057728601458481, "phrase": "node_repair"}, {"score": 0.003992729692096799, "phrase": "locality_attempt"}, {"score": 0.003916098498242888, "phrase": "helper_nodes"}, {"score": 0.0036006068766833103, "phrase": "local_recovery"}, {"score": 0.0035658739518719907, "phrase": "erased_code_symbol"}, {"score": 0.0034974064973871833, "phrase": "multiple_erasures"}, {"score": 0.003153774948631967, "phrase": "second_direction"}, {"score": 0.00281635677605879, "phrase": "vector_alphabet"}, {"score": 0.0026570998719084153, "phrase": "vector-alphabet_codes"}, {"score": 0.00250682585023182, "phrase": "minimum_storage_regeneration"}, {"score": 0.002490670327530155, "phrase": "msr"}, {"score": 0.002466608618694819, "phrase": "minimum_bandwidth_regeneration"}, {"score": 0.002181270821530302, "phrase": "general_vector_code"}, {"score": 0.002132420504803564, "phrase": "performance_comparison"}, {"score": 0.0021049977753042253, "phrase": "fixed_block_length"}], "paper_keywords": ["Codes with local regeneration", " codes with locality", " concatenated codes", " distributed storage", " locally repairable codes", " minimum distance bound", " node repair", " pyramid codes", " regenerating codes", " uniform rank accumulation", " vector codes"], "paper_abstract": "Regenerating codes and codes with locality are two coding schemes that have recently been proposed, which in addition to ensuring data collection and reliability, also enable efficient node repair. In a situation where one is attempting to repair a failed node, regenerating codes seek to minimize the amount of data downloaded for node repair, while codes with locality attempt to minimize the number of helper nodes accessed. This paper presents results in two directions. In one, this paper extends the notion of codes with locality so as to permit local recovery of an erased code symbol even in the presence of multiple erasures, by employing local codes having minimum distance >2. An upper bound on the minimum distance of such codes is presented and codes that are optimal with respect to this bound are constructed. The second direction seeks to build codes that combine the advantages of both codes with locality as well as regenerating codes. These codes, termed here as codes with local regeneration, are codes with locality over a vector alphabet, in which the local codes themselves are regenerating codes. We derive an upper bound on the minimum distance of vector-alphabet codes with locality for the case when their constituent local codes have a certain uniform rank accumulation property. This property is possessed by both minimum storage regeneration (MSR) and minimum bandwidth regeneration (MBR) codes. We provide several constructions of codes with local regeneration which achieve this bound, where the local codes are either MSR or MBR codes. Also included in this paper, is an upper bound on the minimum distance of a general vector code with locality as well as the performance comparison of various code constructions of fixed block length and minimum distance.", "paper_title": "Codes With Local Regeneration and Erasure Correction", "paper_id": "WOS:000340273700015"}