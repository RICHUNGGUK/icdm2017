{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "embedded_systems"}, {"score": 0.004674952036988355, "phrase": "increasing_speed_gap"}, {"score": 0.003774164192882704, "phrase": "cache_locking"}, {"score": 0.003557653536102669, "phrase": "i-cache_locking_problem"}, {"score": 0.0032800230155217444, "phrase": "wcet"}, {"score": 0.002706659627293686, "phrase": "mrtc_benchmark_suite"}, {"score": 0.0026472970609754095, "phrase": "experimental_results"}, {"score": 0.0025324393547676623, "phrase": "average_improvements"}, {"score": 0.0023694065215394593, "phrase": "partial_locking_approach"}, {"score": 0.002120624523437494, "phrase": "longest_path"}, {"score": 0.0021049977753042253, "phrase": "based_dynamic_locking_approach"}], "paper_keywords": ["Worst-case execution time", " dynamic instruction cache locking", " minimum cut"], "paper_abstract": "Caches are widely used in embedded systems to bridge the increasing speed gap between processors and off-chip memory. However, caches make it significantly harder to compute the WCET(Worst Case Execution Time) of a task. To alleviate this problem, cache locking has been proposed. We investigate the I-cache locking problem, and propose a WCET-aware, min-cut based dynamic instruction cache locking approach for reducing the WCET of a single task. We have implemented our approach and compared it with the two state-of-the-art cache locking approaches by using a set of benchmarks from the MRTC benchmark suite. The experimental results show that our approach achieves the average improvements of 41%, 15% and 7% over the partial locking approach for the 256B, 512B and 1KB caches, respectively, and 7%, 18% and 17% over the longest path based dynamic locking approach for the 256B, 512B and 1KB caches, respectively.", "paper_title": "WCET-Aware Dynamic Instruction Cache Locking", "paper_id": "WOS:000341937800007"}