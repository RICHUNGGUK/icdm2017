{"auto_keywords": [{"score": 0.048200146520511834, "phrase": "long_latency_instructions"}, {"score": 0.009800608343131168, "phrase": "smt"}, {"score": 0.009484332713236437, "phrase": "iw"}, {"score": 0.00481495049065317, "phrase": "o-o-o_execution"}, {"score": 0.004747429622531595, "phrase": "resource_sharing_nature"}, {"score": 0.004725132736474305, "phrase": "simultaneous_multithreading"}, {"score": 0.004654779963297256, "phrase": "dcra"}, {"score": 0.00460435000174424, "phrase": "concurrent_threads"}, {"score": 0.0045719459699563895, "phrase": "instruction_scheduling_window"}, {"score": 0.004486640769041646, "phrase": "primary_shared_component"}, {"score": 0.004465563214219513, "phrase": "key_pipeline_structures"}, {"score": 0.004351386525975069, "phrase": "tight_constraints"}, {"score": 0.004170788475789279, "phrase": "resource_monopolization"}, {"score": 0.004141423024667467, "phrase": "low-ilp_threads"}, {"score": 0.004016533725269959, "phrase": "iw_utilization"}, {"score": 0.003978866233891427, "phrase": "affordable_performance"}, {"score": 0.0038679618585498597, "phrase": "existing_optimization"}, {"score": 0.0038316823300412798, "phrase": "smt_processors"}, {"score": 0.003795741788540908, "phrase": "fetch_policy"}, {"score": 0.0033500650321211718, "phrase": "controlling_fetch_policies"}, {"score": 0.0031360786664165093, "phrase": "long_latency_load"}, {"score": 0.0030702341640329546, "phrase": "streamline_buffer"}, {"score": 0.003005767951690914, "phrase": "order_execution"}, {"score": 0.0029775511937434797, "phrase": "instruction_replay"}, {"score": 0.0029150253706493852, "phrase": "conventional_iw"}, {"score": 0.002741653546972843, "phrase": "fp_benchmarks"}, {"score": 0.002703127902345925, "phrase": "long_latency_loads"}, {"score": 0.0025184494222081576, "phrase": "effective_design"}, {"score": 0.0024830524267591713, "phrase": "baseline_smt_architecture"}, {"score": 0.002391067964886602, "phrase": "iw_full_rate"}, {"score": 0.0023353121226049062, "phrase": "average_ipc"}, {"score": 0.00232431758517087, "phrase": "mixed_workloads"}, {"score": 0.00229164285862567, "phrase": "mem_workloads"}, {"score": 0.0022701147119844425, "phrase": "cpu_workloads"}, {"score": 0.002201532080841558, "phrase": "similar_enhancements"}], "paper_keywords": ["Instruction scheduling window (IW)", " simultaneous multithreading (SMT)", " resource contention", " instruction streamlining"], "paper_abstract": "The resource sharing nature of Simultaneous Multithreading (SMT) processors and the presence of long latency instructions from concurrent threads make the instruction scheduling window (IW), which is a primary shared component among key pipeline structures in SMT, a performance bottleneck. Due to the tight constraints on its physical size, the IW faces more severe pressure to handle the instructions from various threads while attempting to avoid resource monopolization by some low-ILP threads. It is particularly challenging to optimize the efficiency and fairness in IW utilization to fulfill the affordable performance by SMT under the shadow of long latency instructions. Most of the existing optimization, schemes in SMT processors rely on the fetch policy to control the instructions that are allowed to enter the pipeline, while little effort is put to control the long latency instructions that are already located in the IW. In this paper, we propose streamline buffers to handle the long latency instructions that have already entered the pipeline and clog the IW, while the controlling fetch policies take time to react. Each streamline buffer extracts from IW and holds a chain of instructions from a thread that are stalled by dependency on a long latency load. When the load value returns, the streamline buffer then serves these instructions directly to in-order execution, avoiding any instruction replay. This is done in supplement to the conventional IW that serves in parallel the other instructions for out-of-order (o-o-o) execution, Analysis of SPEC2000 integer and FP benchmarks reveals that instructions dependent on long latency loads, typically have their first source operand ready within 5 percent-15 percent of their total wait time in the IW. Our scheme is able to utilize this asymmetry in source operands' ready time to achieve a complexity effective design. As compared to the baseline SMT architecture, our design when working in conjunction with earlier proposed ICOUNT.2.8 fetch policy for 4-threads effectively reduces the IW full rate by 9.4 percent (11 percent for 2-thread), improves average IPC for MIXED workloads by 9.6 percent (8 percent for MEM workloads and 4.4 percent for CPU workloads), and fairness by 7.56 percent (7.24 percent for 2-thread). Similar enhancements are observed when run in conjunction with an RR.2.8 fetch policy. Further, our scheme when combined with DCRA improves the performance on the average by 21.7 percent, while DCRA improves by 16.3 percent when run alone.", "paper_title": "Optimizing Instruction Scheduling through Combined In-Order and O-O-O Execution in SMT Processors", "paper_id": "WOS:000265089500009"}