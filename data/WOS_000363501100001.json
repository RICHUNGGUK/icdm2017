{"auto_keywords": [{"score": 0.047748521831607424, "phrase": "shared_libraries"}, {"score": 0.00774049069051372, "phrase": "host_application"}, {"score": 0.00481495049065317, "phrase": "shared_library_sandboxing"}, {"score": 0.004499910169464113, "phrase": "unknown_provenance"}, {"score": 0.0044047527104545525, "phrase": "accidental_bugs"}, {"score": 0.0040726680518382965, "phrase": "custom_tool_chains"}, {"score": 0.004029359223675788, "phrase": "significant_modifications"}, {"score": 0.0038744481564444173, "phrase": "single_address_space_programming"}, {"score": 0.0037924666577694222, "phrase": "guest_code"}, {"score": 0.0037387746981660717, "phrase": "substantial_performance_overheads"}, {"score": 0.003633652174971415, "phrase": "libvm"}, {"score": 0.0033001333942688778, "phrase": "single_address_space"}, {"score": 0.0032418062548293745, "phrase": "system_call_inter-positioning_layer"}, {"score": 0.003161870571621082, "phrase": "shared_library's_functionality"}, {"score": 0.003083899825125453, "phrase": "contemporary_hardware-virtualization_support"}, {"score": 0.003029382820031577, "phrase": "reasonable_performance_overheads"}, {"score": 0.0028511121935559072, "phrase": "software-based_mechanism"}, {"score": 0.0027316100642958544, "phrase": "existing_shared_library_manipulation_functions"}, {"score": 0.0026171036268367713, "phrase": "existing_programs"}, {"score": 0.002525347599743456, "phrase": "immediate_benefits"}, {"score": 0.002419466507425567, "phrase": "unintentional_programming_errors"}, {"score": 0.002309754152767196, "phrase": "shared_library"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["system call inter-positioning", " component isolation", " dependable systems", " information security", " hardware virtualization", " component software"], "paper_abstract": "Many software applications extend their functionality by dynamically loading libraries into their allocated address space. However, shared libraries are also often of unknown provenance and quality and may contain accidental bugs or, in some cases, deliberately malicious code. Most sandboxing techniques that address these issues require recompilation of the libraries using custom tool chains, require significant modifications to the libraries, do not retain the benefits of single address space programming, do not completely isolate guest code, or incur substantial performance overheads. In this paper, we present LibVM, a sandboxing architecture for isolating libraries within a host application without requiring any modifications to the shared libraries themselves, while still retaining the benefits of a single address space and also introducing a system call inter-positioning layer that allows complete arbitration over a shared library's functionality. We show how to utilize contemporary hardware-virtualization support towards this end with reasonable performance overheads, and, in the absence of such hardware support, our model can also be implemented using a software-based mechanism. We ensure that our implementation conforms as closely as possible to existing shared library manipulation functions, minimizing the amount of effort needed to apply such isolation to existing programs. Our experimental results show that it is easy to gain immediate benefits in scenarios where the goal is to guard the host application against unintentional programming errors when using shared libraries, as well as in more complex scenarios, where a shared library is suspected of being actively hostile. In both cases, no changes are required to the shared libraries themselves. Copyright (c) 2014 John Wiley & Sons, Ltd.", "paper_title": "LibVM: an architecture for shared library sandboxing", "paper_id": "WOS:000363501100001"}