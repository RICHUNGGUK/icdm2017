{"auto_keywords": [{"score": 0.049465088868450476, "phrase": "sdn"}, {"score": 0.00481495049065317, "phrase": "correct_network_virtualization"}, {"score": 0.004692227830462433, "phrase": "underlying_infrastructure"}, {"score": 0.0044369056710423065, "phrase": "logical_or_virtual_entity"}, {"score": 0.004286708921931472, "phrase": "virtual_abstractions"}, {"score": 0.004106063237069123, "phrase": "single_\"big_switch"}, {"score": 0.003949974260471287, "phrase": "distributed_set"}, {"score": 0.003916098498242888, "phrase": "physical_devices"}, {"score": 0.003865826699096508, "phrase": "key_question"}, {"score": 0.0037348894128879082, "phrase": "multiple_physical_elements"}, {"score": 0.003577414339646767, "phrase": "application_developer"}, {"score": 0.003426556090707852, "phrase": "physical_big_switch"}, {"score": 0.0033391018638565715, "phrase": "multiple_physical_switches"}, {"score": 0.003050166508545763, "phrase": "-physical_mapping_techniques"}, {"score": 0.00295950473406239, "phrase": "virtual_\"big_switch"}, {"score": 0.0029089095588612007, "phrase": "physical_network"}, {"score": 0.0028715299874549245, "phrase": "incorrect_application-level_behavior"}, {"score": 0.0027741761880779535, "phrase": "incorrect_behaviors"}, {"score": 0.0024906610581090223, "phrase": "practical_notions"}, {"score": 0.002448061472257196, "phrase": "new_systems"}, {"score": 0.002416589459425828, "phrase": "new_analytical_framework"}, {"score": 0.0023447155524245655, "phrase": "first_steps"}, {"score": 0.0023145690608400425, "phrase": "end-to-end_correctness"}, {"score": 0.0021789194955896124, "phrase": "research_vision"}, {"score": 0.002150900082318562, "phrase": "virtualization_systems"}, {"score": 0.0021049977753042253, "phrase": "physical_mappings"}], "paper_keywords": ["Network Virtualization", " One Big Switch", " Correctness"], "paper_abstract": "In SDN, the underlying infrastructure is usually abstracted for applications that can treat the network as a logical or virtual entity. Commonly, the \"mappings\" between virtual abstractions and their actual physical implementations are not one-to-one, e.g., a single \"big switch\" abstract object might be implemented using a distributed set of physical devices. A key question is, what abstractions could be mapped to multiple physical elements while faithfully preserving their native semantics? E.g., can an application developer always expect her abstract \"big switch\" to act exactly as a physical big switch, despite being implemented using multiple physical switches in reality? We show that the answer to that question is \"no\" for existing virtual-to-physical mapping techniques: behavior can differ between the virtual \"big switch\" and the physical network, providing incorrect application-level behavior. We also show that that those incorrect behaviors occur despite the fact that the most pervasive correctness invariants, such as per-packet consistency, are preserved throughout. These examples demonstrate that for practical notions of correctness, new systems and a new analytical framework are needed. We take the first steps by defining end-to-end correctness, a correctness condition that focuses on applications only, and outline a research vision to obtain virtualization systems with correct virtual to physical mappings.", "paper_title": "Towards Correct Network Virtualization", "paper_id": "WOS:000350564600014"}