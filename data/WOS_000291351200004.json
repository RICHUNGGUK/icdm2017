{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "dcc"}, {"score": 0.004735519962945449, "phrase": "dependable_cache_coherence_multicore_architecture"}, {"score": 0.004683292152590589, "phrase": "cache_coherence"}, {"score": 0.004530023871441992, "phrase": "functionally-correct_operation"}, {"score": 0.0044800522651664695, "phrase": "shared_memory_multicores"}, {"score": 0.004430629452265786, "phrase": "traditional_directory-based_hardware_coherence_protocols"}, {"score": 0.004191540451296395, "phrase": "complex_logic"}, {"score": 0.004076858589744185, "phrase": "coherence_states"}, {"score": 0.004031865694174726, "phrase": "technology_scaling"}, {"score": 0.00396530196547293, "phrase": "miniaturization_levels"}, {"score": 0.00392153537973826, "phrase": "manufacturing_imperfections"}, {"score": 0.0038782499819752423, "phrase": "device_unreliability"}, {"score": 0.0037931018103829427, "phrase": "hard_errors"}, {"score": 0.003730465168354817, "phrase": "serious_dependability_challenge"}, {"score": 0.0036892809673917592, "phrase": "broken_or_degraded_functionality"}, {"score": 0.003628352506247126, "phrase": "coherence_protocol"}, {"score": 0.0035290250358997904, "phrase": "non-operational_processor"}, {"score": 0.0034707339811048403, "phrase": "visible_performance_loss"}, {"score": 0.0033015555065209865, "phrase": "dependable_cache_coherence_architecture"}, {"score": 0.003175676186323053, "phrase": "traditional_directory_protocol"}, {"score": 0.003123203316511694, "phrase": "novel_execution-migration-based_architecture"}, {"score": 0.0024054226746197706, "phrase": "appropriate_core"}, {"score": 0.0023136311468961125, "phrase": "coherence_mechanisms"}, {"score": 0.0022253345930383257, "phrase": "dcc_architecture"}, {"score": 0.0021763973978248005, "phrase": "architectural_extensions"}, {"score": 0.0021049977753042253, "phrase": "directory_and_execution_migration_protocols"}], "paper_keywords": ["Dependable architecture", " cache coherence", " multicores"], "paper_abstract": "Cache coherence lies at the core of functionally-correct operation of shared memory multicores. Traditional directory-based hardware coherence protocols scale to large core counts, but they incorporate complex logic and directories to track coherence states. Technology scaling has reached miniaturization levels where manufacturing imperfections, device unreliability and occurrence of hard errors pose a serious dependability challenge. Broken or degraded functionality of the coherence protocol can lead to a non-operational processor or user visible performance loss. In this paper, we propose a dependable cache coherence architecture (DCC) that combines the traditional directory protocol with a novel execution-migration-based architecture to ensure dependability that is transparent to the programmer. Our architecturally redundant execution migration architecture only permits one copy of data to be cached anywhere in the processor: when a thread accesses an address not locally cached on the core it is executing on, it migrates to the appropriate core and continues execution there. Both coherence mechanisms can co-exist in the DCC architecture and we present architectural extensions to seamlessly transition between the directory and execution migration protocols.", "paper_title": "DCC: A Dependable Cache Coherence Multicore Architecture", "paper_id": "WOS:000291351200004"}