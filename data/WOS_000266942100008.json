{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "inductive_computations"}, {"score": 0.0047559432344272, "phrase": "graphs_defined_by_clique-width_expressions._labelling_problems"}, {"score": 0.0039040344230094164, "phrase": "inductively_computable_function_d"}, {"score": 0.0037159680715717056, "phrase": "n_vertices"}, {"score": 0.0033251716926666437, "phrase": "vertex_x"}, {"score": 0.0028670988845838296, "phrase": "constant_time"}, {"score": 0.002487296495786493, "phrase": "syntactic_tree"}, {"score": 0.0023967582707115354, "phrase": "inductive_computation"}, {"score": 0.002295277579105177, "phrase": "monadic_second_order_logic"}, {"score": 0.0021845387990972543, "phrase": "explicit_labelling_scheme"}, {"score": 0.0021049977753042253, "phrase": "exponential_size"}], "paper_keywords": ["Terms", " graphs", " clique-width", " labeling schemes", " inductive computation"], "paper_abstract": "Labelling problems for graphs consist in building distributed data structures, making it possible to check a given graph property or to compute a given function, the arguments of which are vertices. For an inductively computable function D, if G is a graph with n vertices and of clique-width at most k, where k is fixed, we can associate with each vertex x of G a piece of information (bit sequence) lab(x) of length O(log(2)(n)) such that we can compute D in constant time, using only the labels of its arguments. The preprocessing can be done in time O(h.n) where h is the height of the syntactic tree of G. We perform an inductive computation, without using the tools of monadic second order logic. This enables us to give an explicit labelling scheme and to avoid constants of exponential size.", "paper_title": "INDUCTIVE COMPUTATIONS ON GRAPHS DEFINED BY CLIQUE-WIDTH EXPRESSIONS", "paper_id": "WOS:000266942100008"}