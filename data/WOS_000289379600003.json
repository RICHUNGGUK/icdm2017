{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "class_hashing"}, {"score": 0.004742511243894382, "phrase": "object-oriented_implementation"}, {"score": 0.004618342952383313, "phrase": "run-time_overhead"}, {"score": 0.004583464412234181, "phrase": "object-oriented_languages"}, {"score": 0.00444655284354007, "phrase": "multiple_inheritance"}, {"score": 0.004412965940679449, "phrase": "dynamic_loading"}, {"score": 0.004330099613414957, "phrase": "java_interfaces"}, {"score": 0.004264923517966271, "phrase": "previous_article"}, {"score": 0.004184825434585617, "phrase": "novel_approach"}, {"score": 0.0041374874583908535, "phrase": "perfect_hashing"}, {"score": 0.004106225442735525, "phrase": "truly_constant-time"}, {"score": 0.0040444053843446326, "phrase": "subtype_testing"}, {"score": 0.004013843843250455, "phrase": "method_invocation"}, {"score": 0.0039684322717435045, "phrase": "dynamic_loading_setting"}, {"score": 0.003908678575537341, "phrase": "first_study"}, {"score": 0.0038207243221070166, "phrase": "driesen's_abstract_computational_model"}, {"score": 0.0037065115435101887, "phrase": "large-scale_benchmarks"}, {"score": 0.0036645642553325215, "phrase": "space_aspect"}, {"score": 0.0033582976109650608, "phrase": "new_results"}, {"score": 0.0033329032920236994, "phrase": "perfect_class_hashing"}, {"score": 0.0032087739900195232, "phrase": "new_hashing_functions"}, {"score": 0.0031724417545242315, "phrase": "inverse_problem"}, {"score": 0.0031010029460927864, "phrase": "best_class_identifiers"}, {"score": 0.0030311679447397725, "phrase": "overall_hashtable_size"}, {"score": 0.002996840657035727, "phrase": "optimizing_approach"}, {"score": 0.0029182434479165884, "phrase": "single-inheritance_hierarchies"}, {"score": 0.00286336417751658, "phrase": "extended_testbed"}, {"score": 0.002841701708055512, "phrase": "random_class_loading"}, {"score": 0.0028095140358025, "phrase": "cautious_assumptions"}, {"score": 0.002746225320405654, "phrase": "sensible_class-loading_order"}, {"score": 0.0026338658998573752, "phrase": "java-like_multiple-subtyping_hierarchies"}, {"score": 0.0025260919226344305, "phrase": "prm_compiler_testbed"}, {"score": 0.002459810433812049, "phrase": "coloring_technique"}, {"score": 0.0023952639120005193, "phrase": "single-inheritance_implementation"}, {"score": 0.0023412849215629986, "phrase": "overall_conclusion"}, {"score": 0.0022454559805729717, "phrase": "space_standpoints"}, {"score": 0.0022200068884960836, "phrase": "bit-wise_and_hashing_function"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["object-oriented programming", " dynamic loading", " multiple inheritance", " late binding", " subtype test", " perfect hashing"], "paper_abstract": "Late binding and subtyping create run-time overhead for object-oriented languages, especially in the context of both multiple inheritance and dynamic loading, for instance for JAVA interfaces. In a previous article, we proposed a novel approach based on perfect hashing and truly constant-time hashtables for implementing subtype testing and method invocation in a dynamic loading setting. In this first study, we based our efficiency assessment on Driesen's abstract computational model for the time aspect, and on large-scale benchmarks for the space aspect. The conclusions were that the technique was promising but required further research in order to assess its scalability. This article presents some new results on perfect class hashing that enhance its interest. We propose and test both new hashing functions and an inverse problem that amounts to selecting the best class identifiers in order to minimize the overall hashtable size. This optimizing approach is proven to be optimal for single-inheritance hierarchies. Experiments within an extended testbed with random class loading and under cautious assumptions about what should be a sensible class-loading order show that perfect class hashing scales up gracefully, especially on JAVA-like multiple-subtyping hierarchies. Furthermore, perfect class hashing is implemented in the PRM compiler testbed, and compared here with the coloring technique, which amounts to maintaining the single-inheritance implementation in multiple inheritance. The overall conclusion is that the approach is efficient from both time and space standpoints with the bit-wise and hashing function. In contrast, the poor time efficiency of modulus hashing function on most processors is confirmed. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "Perfect class hashing and numbering for object-oriented implementation", "paper_id": "WOS:000289379600003"}