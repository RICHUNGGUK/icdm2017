{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "safe_futures"}, {"score": 0.012611036866267024, "phrase": "future-annotated_program"}, {"score": 0.004701556483912018, "phrase": "well-known_programming_construct"}, {"score": 0.004590820632326585, "phrase": "sequential_programs"}, {"score": 0.004240116703465252, "phrase": "transparent_annotations"}, {"score": 0.004026598712747509, "phrase": "sequential_program"}, {"score": 0.0037336520904376687, "phrase": "safety_property"}, {"score": 0.003517458289610994, "phrase": "mutable_references"}, {"score": 0.0034895911869254146, "phrase": "language_abstractions"}, {"score": 0.0033402088717816416, "phrase": "non-local_control-flow"}, {"score": 0.0031845067058084583, "phrase": "data_dependences"}, {"score": 0.0031342307827666675, "phrase": "program's_sequential_counterpart"}, {"score": 0.002964415652865295, "phrase": "higher-order_functional_language"}, {"score": 0.0029409171055888804, "phrase": "first-class_references"}, {"score": 0.0027485326424697095, "phrase": "potentially_unsafe_action"}, {"score": 0.002662393295121998, "phrase": "greater_concurrency"}, {"score": 0.0026099289298770023, "phrase": "static_analysis"}, {"score": 0.002548331088496964, "phrase": "runtime_behavior"}, {"score": 0.00252812242767189, "phrase": "instrumented_programs"}, {"score": 0.0023069016803337365, "phrase": "continuation's_action"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Concurrent programming", " Parallel programming", " Safe futures", " Exception handling"], "paper_abstract": "A future is a well-known programming construct used to introduce concurrency into sequential programs. Computations annotated as futures are executed asynchronously and run concurrently with their continuations. Typically, futures are not transparent annotations: a program with futures need not produce the same result as the sequential program from which it was derived. Safe futures guarantee that a future-annotated program produces the same result as its sequential counterpart. The safety property is trivially satisfied in languages without side-effects or exceptions. In the presence of mutable references and language abstractions, such as exceptions, which permit the expression of non-local control-flow, ensuring safety requires that the future-annotated program adhere to control and data dependences imposed by the program's sequential counterpart. In this paper, we present a formulation of safe futures for a higher-order functional language with first-class references and exceptions. Safety can be guaranteed at runtime by blocking a continuation from performing a potentially unsafe action before its futures have completed. To enable greater concurrency, we develop a static analysis and instrumentation and formalize the runtime behavior for instrumented programs that allows a continuation to proceed before its futures complete, as long as its actions are determined to be safe. A continuation's action is safe if it is not control or data dependent on actions that may subsequently be performed by its futures. Published by Elsevier B.V.", "paper_title": "Dependence analysis for safe futures", "paper_id": "WOS:000303186500004"}