{"auto_keywords": [{"score": 0.04415653596856239, "phrase": "range_iterators"}, {"score": 0.03585290810389686, "phrase": "constraint_implementations"}, {"score": 0.00481495049065317, "phrase": "generic_constraint_implementations"}, {"score": 0.004466519142879166, "phrase": "genetic_constraint"}, {"score": 0.004301834610818624, "phrase": "variable_views"}, {"score": 0.0031845067058084613, "phrase": "single_generic_implementation"}, {"score": 0.003125175084962886, "phrase": "different_views"}, {"score": 0.003066945490483524, "phrase": "different_constraints"}, {"score": 0.0029816229984366374, "phrase": "wide_range"}, {"score": 0.0025892330566358503, "phrase": "domain_operations"}, {"score": 0.0021652891317252994, "phrase": "different_implementation_techniques"}, {"score": 0.0021049977753042253, "phrase": "presented_architecture"}], "paper_keywords": [""], "paper_abstract": "This paper introduces an architecture for genetic constraint implementations based on variable views and range iterators. Views allow, for example, to scale, translate, and negate variables. The paper shows how to make constraint implementations generic and how to reuse a single generic implementation with different views for different constraints. A wide range of applications of views exemplifies their usefulness and their potential for simplifying constraint implementations. We introduce domain operations compatible with views based on range iterators. The paper evaluates the applicability of the approach as well as different implementation techniques for the presented architecture.", "paper_title": "Views and iterators for generic constraint implementations", "paper_id": "WOS:000238569200009"}