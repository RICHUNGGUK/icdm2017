{"auto_keywords": [{"score": 0.04615357950283948, "phrase": "simd_instructions"}, {"score": 0.0072919348118095605, "phrase": "multiple_cores"}, {"score": 0.005857676792060594, "phrase": "key-index_pairs"}, {"score": 0.00481495049065317, "phrase": "cache-friendly_algorithm"}, {"score": 0.004386887374401584, "phrase": "cache_memory"}, {"score": 0.004352974291381373, "phrase": "today's_processors"}, {"score": 0.004122781047853192, "phrase": "high-performance_in-memory_sorting_algorithm"}, {"score": 0.003874512990986722, "phrase": "frequently_used_approach"}, {"score": 0.0037853015963603682, "phrase": "key_and_index"}, {"score": 0.003698136685049485, "phrase": "integer_value"}, {"score": 0.0036129756342188047, "phrase": "simd"}, {"score": 0.0034753508746887957, "phrase": "sorted_key-index_pairs"}, {"score": 0.00326594229173048, "phrase": "integer_values"}, {"score": 0.003178326919668771, "phrase": "existing_high-performance_sorting_implementations"}, {"score": 0.003141498438356646, "phrase": "simd-based_multiway_mergesort"}, {"score": 0.003033546013625887, "phrase": "frequent_cache"}, {"score": 0.0029867619862229853, "phrase": "final_rearranging_phase"}, {"score": 0.002861782260525497, "phrase": "single-thread_performance"}, {"score": 0.002742017872865778, "phrase": "multiway_mergesort"}, {"score": 0.0026788122684116224, "phrase": "costly_random_accesses"}, {"score": 0.0024784363584530976, "phrase": "better_single-thread_performance"}, {"score": 0.0024496978447849835, "phrase": "key-index_approach"}, {"score": 0.002319918823705175, "phrase": "better_performance"}, {"score": 0.00224013518726087, "phrase": "optimized_radix"}, {"score": 0.0021049977753042253, "phrase": "higher_scalability"}], "paper_keywords": [""], "paper_abstract": "This paper describes our new algorithm for sorting an array of structures by efficiently exploiting the SIMD instructions and cache memory of today's processors. Recently, multiway mergesort implemented with SIMD instructions has been used as a high-performance in-memory sorting algorithm for sorting integer values. For sorting an array of structures with SIMD instructions, a frequently used approach is to first pack the key and index for each record into an integer value, sort the key-index pairs using SIMD instructions, then rearrange the records based on the sorted key-index pairs. This approach can efficiently exploit SIMD instructions because it sorts the key-index pairs while packed into integer values; hence, it can use existing high-performance sorting implementations of the SIMD-based multiway mergesort for integers. However, this approach has frequent cache misses in the final rearranging phase due to its random and scattered memory accesses so that this phase limits both single-thread performance and scalability with multiple cores. Our approach is also based on multiway mergesort, but it can avoid costly random accesses for rearranging the records while still efficiently exploiting the SIMD instructions. Our results showed that our approach exhibited up to 2.1x better single-thread performance than the key-index approach implemented with SIMD instructions when sorting 512M 16-byte records on one core. Our approach also yielded better performance when we used multiple cores. Compared to an optimized radix sort, our vectorized multiway mergesort achieved better performance when the each record is large. Our vectorized multiway mergesort also yielded higher scalability with multiple cores than the radix sort.", "paper_title": "SIMD- and Cache-Friendly Algorithm for Sorting an Array of Structures", "paper_id": "WOS:000362283300014"}