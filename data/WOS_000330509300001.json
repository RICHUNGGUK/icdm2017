{"auto_keywords": [{"score": 0.0421165608758285, "phrase": "modern_machines"}, {"score": 0.01381741697961095, "phrase": "single-core_machines"}, {"score": 0.012504609414287233, "phrase": "multiple_concurrent_compiler_threads"}, {"score": 0.01221406888415223, "phrase": "best_jit_compilation_policy"}, {"score": 0.00481495049065317, "phrase": "single_and_multilevel_jit_compilation_policy"}, {"score": 0.004538045400396629, "phrase": "managed_languages"}, {"score": 0.004484720263913375, "phrase": "java"}, {"score": 0.00436661740263741, "phrase": "conservative_jit_compilation_policy"}, {"score": 0.004289686492089571, "phrase": "good_runtime_performance"}, {"score": 0.004251728624599691, "phrase": "application_progress"}, {"score": 0.003983404013173127, "phrase": "abundant_computing_resources"}, {"score": 0.003936461984681817, "phrase": "virtual_machines"}, {"score": 0.0034963129868796033, "phrase": "multitier_jit_compilation_policies"}, {"score": 0.0034550911223507064, "phrase": "existing_and_future_vms"}, {"score": 0.0034143536023161403, "phrase": "best_program_performance"}, {"score": 0.003314591878914152, "phrase": "novel_experiments"}, {"score": 0.0032852337992126564, "phrase": "new_vm_configurations"}, {"score": 0.0032368785020224695, "phrase": "compiler_aggressiveness"}, {"score": 0.0032177356154317895, "phrase": "optimization_levels"}, {"score": 0.003114449258490065, "phrase": "industry-standard_oracle_hotspot_java_vm"}, {"score": 0.0028832679581901176, "phrase": "dynamic_compilers"}, {"score": 0.0028492532869274743, "phrase": "earlier_results"}, {"score": 0.002807297104719042, "phrase": "conservative_jit_compilation"}, {"score": 0.0027010719929751, "phrase": "free_compilation_resources"}, {"score": 0.0025681878215171976, "phrase": "diminishing_returns"}, {"score": 0.0024783327548305316, "phrase": "free_resources"}, {"score": 0.0024563633541195124, "phrase": "compiler_queue_backup"}, {"score": 0.002427372728532664, "phrase": "hot_methods"}, {"score": 0.0023916139749419188, "phrase": "program_performance"}, {"score": 0.002301081571414049, "phrase": "accurately_prioritizing_jit_method"}, {"score": 0.0022337748928022887, "phrase": "smallest_hardware_budget"}, {"score": 0.0021813467128927347, "phrase": "tiered_compilation_policy"}], "paper_keywords": ["Virtual machines", " dynamic compilation", " multicore", " Java"], "paper_abstract": "Dynamic or Just-in-Time (JIT) compilation is essential to achieve high-performance emulation for programs written in managed languages, such as Java and C#. It has been observed that a conservative JIT compilation policy is most effective to obtain good runtime performance without impeding application progress on single-core machines. At the same time, it is often suggested that a more aggressive dynamic compilation strategy may perform best on modern machines that provide abundant computing resources, especially with virtual machines (VMs) that are also capable of spawning multiple concurrent compiler threads. However, comprehensive research on the best JIT compilation policy for such modern processors and VMs is currently lacking. The goal of this work is to explore the properties of single-tier and multitier JIT compilation policies that can enable existing and future VMs to realize the best program performance on modern machines. In this work, we design novel experiments and implement new VM configurations to effectively control the compiler aggressiveness and optimization levels (if and when methods are compiled) in the industry-standard Oracle HotSpot Java VM to achieve this goal. We find that the best JIT compilation policy is determined by the nature of the application and the speed and effectiveness of the dynamic compilers. We extend earlier results showing the suitability of conservative JIT compilation on single-core machines for VMs with multiple concurrent compiler threads. We show that employing the free compilation resources (compiler threads and hardware cores) to aggressively compile more program methods quickly reaches a point of diminishing returns. At the same time, we also find that using the free resources to reduce compiler queue backup (compile selected hot methods early) significantly benefits program performance, especially for slower (highly optimizing) JIT compilers. For such compilers, we observe that accurately prioritizing JIT method compiles is crucial to realize the most performance benefit with the smallest hardware budget. Finally, we show that a tiered compilation policy, although complex to implement, greatly alleviates the impact of more and early JIT compilation of programs on modern machines.", "paper_title": "Exploring Single and Multilevel JIT Compilation Policy for Modern Machines", "paper_id": "WOS:000330509300001"}