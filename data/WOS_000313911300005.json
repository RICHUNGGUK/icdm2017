{"auto_keywords": [{"score": 0.026033701006803814, "phrase": "partially-defined_values"}, {"score": 0.004815007700063964, "phrase": "haskell"}, {"score": 0.0031712256091350316, "phrase": "light-weight_class_law_testing_framework"}, {"score": 0.0027054473441439422, "phrase": "class_law"}, {"score": 0.0024883835349005863, "phrase": "class_laws"}, {"score": 0.0022696277881969896, "phrase": "standard_lazy_and_strict_implementations"}, {"score": 0.0021049977753042253, "phrase": "expected_laws"}], "paper_keywords": ["design", " languages", " verification", " laws", " classes", " testing", " state monad"], "paper_abstract": "The specification of a class in Haskell often starts with stating, in comments, the laws that should be satisfied by methods defined in instances of the class, followed by the type of the methods of the class. This paper develops a framework that supports testing such class laws using QuickCheck. Our framework is a light-weight class law testing framework, which requires a limited amount of work per class law, and per datatype for which the class law is tested. We also show how to test class laws with partially-defined values. Using partially-defined values, we show that the standard lazy and strict implementations of the state monad do not satisfy the expected laws.", "paper_title": "Testing Type Class Laws", "paper_id": "WOS:000313911300005"}