{"auto_keywords": [{"score": 0.0319925883999622, "phrase": "query_time"}, {"score": 0.004466519142879166, "phrase": "efficient_solutions"}, {"score": 0.003649585593445665, "phrase": "longest_common_prefix"}, {"score": 0.003401148484767927, "phrase": "natural_generalization"}, {"score": 0.003353521531649663, "phrase": "classical_lcp_problem"}, {"score": 0.0025290375256888883, "phrase": "longest_lcp"}, {"score": 0.0024819051319092994, "phrase": "lcp"}, {"score": 0.0022378101636842296, "phrase": "arbitrary_small_constant_epsilon"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Data structures", " LCP", " Pattern matching"], "paper_abstract": "In this paper, we define the Range LCP problem as follows. Preprocess a string S, of length n, to enable efficient solutions of the following query: Given [i, j], O < i <= j <= n, compute max(l,ke[i..j]) LCP(S-l, S-k), where LCP(S-l, S-k) is the length of the longest common prefix of the suffixes of S starting at locations t and k. This is a natural generalization of the classical LCP problem. We provide algorithms with the following complexities: 1. Preprocessing Time: O(|S|), Space: O(|5|), Query Time: O(|j - i| log logn). 2. Preprocessing Time: none, space: O(|j - i| log |j - i|), Query Time: O (|j - i| log |j - i|). However, the query just gives the pairs with the longest LCP, not the LCP itself. 3. Preprocessing Time: O(|S| log(2) |S|), Space: O(|S| log(1+epsilon) |S|) for arbitrary small constant epsilon, Query Time: O(log log |S|). (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "Range LCP", "paper_id": "WOS:000336882100004"}