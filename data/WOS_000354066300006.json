{"auto_keywords": [{"score": 0.048152320835937894, "phrase": "linear_space"}, {"score": 0.00481495049065317, "phrase": "faster_text_indexing"}, {"score": 0.004790306679000464, "phrase": "suffix_trees"}, {"score": 0.004765788394931875, "phrase": "suffix_arrays"}, {"score": 0.004550669123303854, "phrase": "linear_time"}, {"score": 0.004527371799277529, "phrase": "polynomially_sized_alphabets"}, {"score": 0.004401342842183475, "phrase": "worst-case_deterministic_time_bounds"}, {"score": 0.004224237734979006, "phrase": "query_size"}, {"score": 0.0041703614123283165, "phrase": "alphabet_size"}, {"score": 0.004002513373645485, "phrase": "text_size"}, {"score": 0.003861175855298779, "phrase": "additive_cost"}, {"score": 0.0036210413727507827, "phrase": "worst_case"}, {"score": 0.0035021127041237887, "phrase": "super-linear_construction_time"}, {"score": 0.0034308688638878286, "phrase": "novel_way"}, {"score": 0.003292685392413911, "phrase": "space_and_construction_time"}, {"score": 0.003250651390184808, "phrase": "query_time"}, {"score": 0.0032009160232892046, "phrase": "integer_alphabets"}, {"score": 0.003176333519010176, "phrase": "linear_range"}, {"score": 0.0030562154156203217, "phrase": "arbitrary_constant_c."}, {"score": 0.002814886483566627, "phrase": "online_version"}, {"score": 0.0027014453885055075, "phrase": "indexing_queries"}, {"score": 0.0025992391074270097, "phrase": "suffix_tree"}, {"score": 0.0025792654256039187, "phrase": "suffix_list"}, {"score": 0.002539776172315069, "phrase": "suffix_array"}, {"score": 0.0024186620196958867, "phrase": "suffix_trist"}, {"score": 0.0023511948097484662, "phrase": "online_construction"}, {"score": 0.0023331227492950422, "phrase": "linear-space_suffix_tree"}, {"score": 0.0022104400388951654, "phrase": "current_text"}, {"score": 0.0021049977753042253, "phrase": "best_currently_known_worst-case_deterministic_bound"}], "paper_keywords": ["Data structures", " Indexing", " Pattern matching"], "paper_abstract": "Suffix trees and suffix arrays are two of the most widely used data structures for text indexing. Each uses linear space and can be constructed in linear time for polynomially sized alphabets. However, when it comes to answering queries with worst-case deterministic time bounds, the prior does so in O(mlog|I |) pound time, where m is the query size, |I | pound is the alphabet size, and the latter does so in O(m+logn) time, where n is the text size. If one wants to output all appearances of the query, an additive cost of O(occ) time is sufficient, where occ is the size of the output. Notice that it is possible to obtain a worst case, deterministic query time of O(m) but at the cost of super-linear construction time or space usage. We propose a novel way of combining the two into, what we call, a suffix tray. The space and construction time remain linear and the query time improves to O(m+log|I |) pound for integer alphabets from a linear range, i.e. I aS pound,{1,aEuro broken vertical bar,cn}, for an arbitrary constant c. The construction and query are deterministic. Here also an additive O(occ) time is sufficient if one desires to output all appearances of the query. We also consider the online version of indexing, where the text arrives online, one character at a time, and indexing queries are answered in tandem. In this variant we create a cross between a suffix tree and a suffix list (a dynamic variant of suffix array) to be called a suffix trist; it supports queries in O(m+log|I |) pound time. The suffix trist also uses linear space. Furthermore, if there exists an online construction for a linear-space suffix tree such that the cost of adding a character is worst-case deterministic f(n,|I |) pound (n is the size of the current text), then one can further update the suffix trist in O(f(n,|I |)+log|I pound |) pound time. The best currently known worst-case deterministic bound for f(n,|I |) pound is O(logn) time.", "paper_title": "Suffix Trays and Suffix Trists: Structures for Faster Text Indexing", "paper_id": "WOS:000354066300006"}