{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "atlas"}, {"score": 0.004682414867878963, "phrase": "non-volatile_memory_consistency"}, {"score": 0.004630423009638876, "phrase": "non-volatile_main_memory"}, {"score": 0.004477870190590885, "phrase": "phase_change"}, {"score": 0.003916098498242888, "phrase": "separate_persistent_data_storage_format"}, {"score": 0.003256526411907174, "phrase": "durability_semantics"}, {"score": 0.003220315882881027, "phrase": "lock-based_code"}, {"score": 0.00306227185008558, "phrase": "globally_consistent_state"}, {"score": 0.002895721231882758, "phrase": "failure-atomic_sections"}, {"score": 0.002815864555488112, "phrase": "existing_critical_sections"}, {"score": 0.0027535633837592597, "phrase": "log-based_implementation"}, {"score": 0.0026330549554033876, "phrase": "consistent_state"}, {"score": 0.0023675132064088803, "phrase": "cpu_caches"}, {"score": 0.0023281003994670714, "phrase": "core_implementation_bottleneck"}, {"score": 0.0022893422054387235, "phrase": "partial_solutions"}, {"score": 0.002263861731320045, "phrase": "experimental_results"}], "paper_keywords": ["non-volatile memory", " locks", " transactions", " persistence", " durability", " consistency semantics", " logging"], "paper_abstract": "Non-volatile main memory, such as memristors or phase change memory, can revolutionize the way programs persist data. In-memory objects can themselves be persistent without the need for a separate persistent data storage format. However, the challenge is to ensure that such data remains consistent if a failure occurs during execution. In this paper, we present our system, called Atlas, which adds durability semantics to lock-based code, typically allowing us to automatically maintain a globally consistent state even in the presence of failures. We identify failure-atomic sections of code based on existing critical sections and describe a log-based implementation that can be used to recover a consistent state after a failure. We discuss several subtle semantic issues and implementation tradeoffs. We confirm the ability to rapidly flush CPU caches as a core implementation bottleneck and suggest partial solutions. Experimental results confirm the practicality of our approach and provide insight into the overheads of such a system.", "paper_title": "Atlas: Leveraging Locks for Non-volatile Memory Consistency", "paper_id": "WOS:000348907400025"}