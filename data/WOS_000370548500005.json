{"auto_keywords": [{"score": 0.049479057100967866, "phrase": "supermalloc"}, {"score": 0.005044273840760119, "phrase": "htm"}, {"score": 0.00481495049065317, "phrase": "super_fast_multithreaded_malloc"}, {"score": 0.004366469575845106, "phrase": "htm."}, {"score": 0.004325339932975582, "phrase": "malloc-test_benchmark"}, {"score": 0.004254386545257621, "phrase": "physical_memory"}, {"score": 0.004022568869196957, "phrase": "dlmalloc"}, {"score": 0.003997260449163666, "phrase": "jemalloc"}, {"score": 0.003972110821530056, "phrase": "hoard"}, {"score": 0.003934681262271618, "phrase": "tbbmalloc"}, {"score": 0.003729121878378674, "phrase": "htm_supermalloc"}, {"score": 0.0035231224373946457, "phrase": "speed_variance"}, {"score": 0.003500945350055404, "phrase": "memory_footprint"}, {"score": 0.003467940281748612, "phrase": "code_size"}, {"score": 0.0034136194753440745, "phrase": "performance_advantages"}, {"score": 0.0030467560909122476, "phrase": "chunk_numbers"}, {"score": 0.003027568488234868, "phrase": "chunk_metadata"}, {"score": 0.002980124909321296, "phrase": "simple_array"}, {"score": 0.0028332303659245085, "phrase": "associativity_conflicts"}, {"score": 0.0027364508381415866, "phrase": "cache_lines"}, {"score": 0.0027106334164712057, "phrase": "nonaligned_huge_accesses"}, {"score": 0.002601535991493226, "phrase": "fullest_non-full_page"}, {"score": 0.002576988153314685, "phrase": "appropriate_size_class"}, {"score": 0.002544616720630384, "phrase": "size_class"}, {"score": 0.0022709326810964386, "phrase": "per-cpu_cache"}, {"score": 0.0022494973475924024, "phrase": "global_cache"}, {"score": 0.0021385392163052364, "phrase": "critical_section"}, {"score": 0.0021049977753042253, "phrase": "critical_sections"}], "paper_keywords": ["Memory Allocation Library", " malloc", " Virtual Memory"], "paper_abstract": "SuperMalloc is an implementation of malloc(3) originally designed for X86 Hardware Transactional Memory (HTM). It turns out that the same design decisions also make it fast even without HTM. For the malloc-test benchmark, which is one of the most difficult workloads for an allocator, with one thread SuperMalloc is about 2.1 times faster than the best of DLmalloc, JEmalloc, Hoard, and TBBmalloc; with 8 threads and HTM, SuperMalloc is 2.75 times faster; and on 32 threads without HTM SuperMalloc is 3.4 times faster. SuperMalloc generally compares favorably with the other allocators on speed, scalability, speed variance, memory footprint, and code size. SuperMalloc achieves these performance advantages using less than half as much code as the alternatives. SuperMalloc exploits the fact that although physical memory is always precious, virtual address space on a 64-bit machine is relatively cheap. It allocates 2 MiB chunks which contain objects all the same size. To translate chunk numbers to chunk metadata, SuperMalloc uses a simple array (most of which is uncommitted to physical memory). SuperMalloc takes care to avoid associativity conflicts in the cache: most of the size classes are a prime number of cache lines, and nonaligned huge accesses are randomly aligned within a page. Objects are allocated from the fullest non-full page in the appropriate size class. For each size class, SuperMalloc employs a 10-object per-thread cache, a per-CPU cache that holds about a level-2-cache worth of objects per size class, and a global cache that is organized to allow the movement of many objects between a per-CPU cache and the global cache using O (1) instructions. SuperMalloc prefetches everything it can before starting a critical section, which makes the critical sections run fast, and for HTM improves the odds that the transaction will commit.", "paper_title": "SuperMalloc: A Super Fast Multithreaded Malloc for 64-bit Machines", "paper_id": "WOS:000370548500005"}