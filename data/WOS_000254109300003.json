{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "mobile_code_safety"}, {"score": 0.01546243005379812, "phrase": "pcc"}, {"score": 0.010698402284013392, "phrase": "consumer_side"}, {"score": 0.010306429520367661, "phrase": "acc"}, {"score": 0.009969762971430216, "phrase": "abstract_interpretation"}, {"score": 0.004774937143916685, "phrase": "proof-carrying_code"}, {"score": 0.004656871909510407, "phrase": "general_approach"}, {"score": 0.004337900700685262, "phrase": "intended_benefit"}, {"score": 0.004266067096140677, "phrase": "program_consumer"}, {"score": 0.00417793854311445, "phrase": "certificate_w.r.t"}, {"score": 0.003990385737207714, "phrase": "certificate_checker"}, {"score": 0.003716894849271535, "phrase": "original_proof"}, {"score": 0.003670608022642996, "phrase": "practical_uptake"}, {"score": 0.003418958653159371, "phrase": "proving_programs"}, {"score": 0.0033482708495261864, "phrase": "costly_verification_process"}, {"score": 0.003306559295382181, "phrase": "efficient_checking_procedure"}, {"score": 0.0031712256091350316, "phrase": "abstraction-carrying_code"}, {"score": 0.0029291198314113608, "phrase": "large_body"}, {"score": 0.0028091907694771613, "phrase": "overall_pcc_scheme"}, {"score": 0.0027054473441439422, "phrase": "expressive_class"}, {"score": 0.002682917193736698, "phrase": "safety_policies"}, {"score": 0.0026164433143193015, "phrase": "different_abstract_domains"}, {"score": 0.002530359917257626, "phrase": "abstract_model"}, {"score": 0.0024573577356299765, "phrase": "standard_static_analyzers"}, {"score": 0.0022886952510350416, "phrase": "single_pass"}, {"score": 0.0021049977753042253, "phrase": "abstract_interpretation_techniques"}], "paper_keywords": ["logic programming", " static analysis", " abstract interpretation", " program verification", " mobile code safety"], "paper_abstract": "Proof-Carrying Code (PCC) is a general approach to mobile code safety in which programs are augmented with a certificate (or proof). The intended benefit is that the program consumer can locally validate the certificate w.r.t. the \"untrusted\" program by means of a certificate checker-a process which should be much simpler, efficient, and automatic than generating the original proof. The practical uptake of PCC greatly depends on the existence of a variety of enabling technologies which allow both proving programs correct and replacing a costly verification process by an efficient checking procedure on the consumer side. In this work we propose Abstraction-Carrying Code (ACC), a novel approach which uses abstract interpretation as enabling technology. We argue that the large body of applications of abstract interpretation to program verification is amenable to the overall PCC scheme. In particular, we rely on an expressive class of safety policies which can be defined over different abstract domains. We use an abstraction (or abstract model) of the program computed by standard static analyzers as a certificate. The validity of the abstraction on the consumer side is checked in a single pass by a very efficient and specialized abstract-interpreter. We believe that ACC brings the expressiveness, flexibility and automation which is inherent in abstract interpretation techniques to the area of mobile code safety.", "paper_title": "Abstraction-carrying code: a model for mobile code safety", "paper_id": "WOS:000254109300003"}