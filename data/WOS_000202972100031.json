{"auto_keywords": [{"score": 0.0353385937542054, "phrase": "compressor"}, {"score": 0.004815001979053219, "phrase": "concurrent"}, {"score": 0.004627244470096107, "phrase": "widely_used_mark-and-sweep_garbage_collector"}, {"score": 0.0042734067085669885, "phrase": "large_long-running_realistic_applications"}, {"score": 0.004198510172614725, "phrase": "web_application_servers"}, {"score": 0.004106725110985659, "phrase": "fragmentation_problem"}, {"score": 0.0039815737219022675, "phrase": "heap_compaction"}, {"score": 0.003709595902020469, "phrase": "efficient_concurrent_collectors"}, {"score": 0.0036445446531633368, "phrase": "production_runtime_systems"}, {"score": 0.0035178323426661626, "phrase": "efficient_non-intrusive_compactor"}, {"score": 0.003080548510001051, "phrase": "entire_heap"}, {"score": 0.0030399188412691914, "phrase": "single_condensed_area"}, {"score": 0.0029733865110222785, "phrase": "objects'_order"}, {"score": 0.0029212075318449616, "phrase": "pause_times"}, {"score": 0.0028572658971252616, "phrase": "acceptable_runs"}, {"score": 0.002832081745025006, "phrase": "large_heaps"}, {"score": 0.002733539375462443, "phrase": "first_compactor"}, {"score": 0.0025018875576502606, "phrase": "parallel_stop-the-world_manner"}, {"score": 0.002436289099444074, "phrase": "program_threads"}, {"score": 0.002161695357601592, "phrase": "jikes_research_rvm"}], "paper_keywords": ["runtime systems", " memory management", " compaction", " garbage collection", " concurrent garbage collection"], "paper_abstract": "The widely used Mark-and-Sweep garbage collector has a drawback in that it does not move objects during collection. As a result, large long-running realistic applications, such as Web application servers, frequently face the fragmentation problem. To eliminate fragmentation, a heap compaction is run periodically. However, compaction typically imposes very long undesirable pauses in the application. While efficient concurrent collectors are ubiquitous in production runtime systems ( such as JVMs), an efficient non-intrusive compactor is still missing. In this paper we present the Compressor, a novel compaction algorithm that is concurrent, parallel, and incremental. The Compressor compacts the entire heap to a single condensed area, while preserving the objects' order, but reduces pause times significantly, thereby allowing acceptable runs on large heaps. Furthermore, the Compressor is the first compactor that requires only a single heap pass. As such, it is the most efficient compactors known today, even when run in a parallel Stop-the-World manner (i.e., when the program threads are halted). Thus, to the best of our knowledge, the Compressor is the most efficient compactor known today. The Compressor was implemented on a Jikes Research RVM and we provide measurements demonstrating its qualities.", "paper_title": "The compressor: Concurrent, incremental, and parallel compaction", "paper_id": "WOS:000202972100031"}