{"auto_keywords": [{"score": 0.02901263621919025, "phrase": "ground_terms"}, {"score": 0.00481495049065317, "phrase": "rule-based_languages"}, {"score": 0.004712726613162057, "phrase": "human_thinking"}, {"score": 0.004294145092032327, "phrase": "pattern-based_searches"}, {"score": 0.00409895142748329, "phrase": "white_cars"}, {"score": 0.004040688646993605, "phrase": "station_wagons"}, {"score": 0.003464150192089816, "phrase": "powerful_extensions"}, {"score": 0.0034394269654205094, "phrase": "pattern-based_programming_languages"}, {"score": 0.003415126887962806, "phrase": "ml"}, {"score": 0.003366307879000591, "phrase": "stratego"}, {"score": 0.0033422900449448837, "phrase": "maude"}, {"score": 0.0033184257258618375, "phrase": "elan"}, {"score": 0.003294746430215784, "phrase": "tom"}, {"score": 0.003111211706454155, "phrase": "tom_language"}, {"score": 0.003055977395076106, "phrase": "formally_the_semantics"}, {"score": 0.0029909851863915283, "phrase": "syntactic_case"}, {"score": 0.0029064676523923886, "phrase": "specific_theory"}, {"score": 0.0028446460307503343, "phrase": "arbitrary_equational_theory"}, {"score": 0.002834470668509792, "phrase": "c._we"}, {"score": 0.0027941308786390033, "phrase": "classical_notion"}, {"score": 0.002591554263245753, "phrase": "general_techniques"}, {"score": 0.002509284173541882, "phrase": "syntactical_case"}, {"score": 0.0024036292057373803, "phrase": "specific_and_very_useful_case"}, {"score": 0.0021662599012740127, "phrase": "alldiff_standard_predicate"}, {"score": 0.0021507795710951384, "phrase": "constraint_programming"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Pattern matching", " List matching", " Complement problem", " Equational problem", " Anti-pattern", " Disunification", " Associativity", " Equational theory", " Rule-based language", " Pattern-based language"], "paper_abstract": "Negation is intrinsic to human thinking and most of the time when searching for something, we base our patterns on both positive and negative conditions. This should be naturally reflected in software that provide pattern-based searches. We would like for example to specify that we search for white cars that are not station wagons, or that we search for a list of objects that does not contain two identical elements. In this paper we extend the notion of pattern to the one of anti-pattern, i.e. patterns that may contain complement symbols. This concept is appropriate to design powerful extensions to pattern-based programming languages like ML, ASF+SDF, Stratego, MAUDE, ELAN or Tom and we show how this is used to extend the expressiveness and usability of the Tom language. We further define formally the semantics of anti-patterns both in the syntactic case, i.e. when the symbols have no specific theory associated, and modulo an arbitrary equational theory C. We then extend the classical notion of matching between patterns and ground terms to matching between anti-patterns and ground terms. Solving such problems can be performed either using general techniques as disunification, which we exemplify in the syntactical case, or more tailored and efficient approaches, which we chose to illustrate on the specific and very useful case of associativity, possibly with a unity. This allows us to be generic enough to give in this framework a very simple and natural expression of, for instance, the AllDiff standard predicate of constraint programming. (C) 2010 Elsevier Ltd. All rights reserved.", "paper_title": "Anti-patterns for rule-based languages", "paper_id": "WOS:000276860200003"}