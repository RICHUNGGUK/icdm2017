{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "featherweight_java"}, {"score": 0.004768104290288521, "phrase": "dynamic_and_static_overloading"}, {"score": 0.004607686390487483, "phrase": "multi_java"}, {"score": 0.004430920292612374, "phrase": "encapsulated_multi-methods"}, {"score": 0.004366387782457736, "phrase": "dynamic_overloading"}, {"score": 0.004323886831151445, "phrase": "multi-methods"}, {"score": 0.004240116703465252, "phrase": "overloaded_methods"}, {"score": 0.003940122359770492, "phrase": "standard_overloading"}, {"score": 0.003863758357292741, "phrase": "useful_and_flexible_mechanism"}, {"score": 0.0035381580196637633, "phrase": "java"}, {"score": 0.0033361232750221863, "phrase": "proposed_extension"}, {"score": 0.002937318465594425, "phrase": "possible_ambiguities"}, {"score": 0.0028106505443369545, "phrase": "invocation_expressions"}, {"score": 0.0026501935378083663, "phrase": "static_annotation"}, {"score": 0.002548331088496964, "phrase": "well-typed_program"}, {"score": 0.0024383967028975616, "phrase": "annotation_mechanism"}, {"score": 0.002391067964886602, "phrase": "static_overloading"}, {"score": 0.002356173823922118, "phrase": "smooth_way"}, {"score": 0.002265586601922693, "phrase": "formal_basis"}, {"score": 0.002232519579957707, "phrase": "actual_implementation"}, {"score": 0.0021361800485636823, "phrase": "java-like_languages"}], "paper_keywords": ["Object-oriented languages", " Featherweight Java", " Multi-methods", " Static overloading", " Dynamic overloading", " Type system"], "paper_abstract": "We propose FMJ (Featherweight Multi Java), an extension of Featherweight Java with encapsulated multi-methods thus providing dynamic overloading. Multi-methods (collections of overloaded methods associated to the same message, whose selection takes place dynamically instead of statically as in standard overloading) are a useful and flexible mechanism which enhances re-usability and separation of responsibilities. However, many mainstream languages, such as, e.g., Java, do not provide it, resorting to only static overloading. The proposed extension is conservative and type safe: both \"message-not-understood\" and \"message-ambiguous\" are statically ruled out. Possible ambiguities are checked during type checking only on method invocation expressions, without requiring to inspect all the classes of a program. A static annotation with type information guarantees that in a well-typed program no ambiguity can arise at run-time. This annotation mechanism also permits modeling static overloading in a smooth way. Our core language can be used as the formal basis for an actual implementation of dynamic (and static) overloading in Java-like languages. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Featherweight Java with dynamic and static overloading", "paper_id": "WOS:000265390900002"}