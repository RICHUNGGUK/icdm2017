{"auto_keywords": [{"score": 0.0452514208810669, "phrase": "strong_equivalence"}, {"score": 0.04485893372439868, "phrase": "ordinary_equivalence"}, {"score": 0.043069853910456694, "phrase": "iff_p"}, {"score": 0.031391892260794224, "phrase": "uniform_equivalence"}, {"score": 0.004699778175535453, "phrase": "answer-set_programming"}, {"score": 0.004615202066192795, "phrase": "answer-set_semantics"}, {"score": 0.004559661374976129, "phrase": "numerous_different_notions"}, {"score": 0.004532141038197266, "phrase": "program_equivalence"}, {"score": 0.004265871391568953, "phrase": "different_concepts"}, {"score": 0.00400304045240329, "phrase": "context_r"}, {"score": 0.0037223583464229097, "phrase": "strong_and_ordinary_equivalence"}, {"score": 0.0036663981146086103, "phrase": "theoretical_tools"}, {"score": 0.0036332251283046997, "phrase": "incomplete_programs"}, {"score": 0.003546218640291191, "phrase": "syntactic_structure"}, {"score": 0.0035141291835319682, "phrase": "considered_context_programs"}, {"score": 0.0033074704429032543, "phrase": "latter_approach"}, {"score": 0.0032577270508271305, "phrase": "properly_different_equivalence_notions"}, {"score": 0.003189336613974265, "phrase": "former_approach"}, {"score": 0.0031035049228517715, "phrase": "\"reasonable\"_syntactic_restriction"}, {"score": 0.0029120808249746533, "phrase": "arbitrary_sets"}, {"score": 0.0028595832692215766, "phrase": "program_rules"}, {"score": 0.0027574024919144635, "phrase": "equivalence_notions"}, {"score": 0.002548331088496964, "phrase": "rule_heads"}, {"score": 0.002405618568415162, "phrase": "rule_bodies"}, {"score": 0.0023479408542211875, "phrase": "general_semantical_characterization"}, {"score": 0.002326669201839705, "phrase": "known_ones"}, {"score": 0.002229915931723092, "phrase": "special_cases"}, {"score": 0.0021896891011033105, "phrase": "complexity_bounds"}, {"score": 0.0021307025018139835, "phrase": "possible_implementation_method"}, {"score": 0.0021049977753042253, "phrase": "dedicated_systems"}], "paper_keywords": ["answer-set programming", " strong equivalence", " relativized equivalence"], "paper_abstract": "Logic programming under the answer-set semantics nowadays deals with numerous different notions of program equivalence. This is due to the fact that equivalence for substitution (known as strong equivalence) and ordinary equivalence are different concepts. The former holds, given programs P and Q, iff P can be faithfully replaced by Q within any context R, while the latter holds iff P and Q provide the same output, that is, they have the same answer sets. Notions in between strong and ordinary equivalence have been introduced as theoretical tools to compare incomplete programs and are defined by either restricting the syntactic structure of the considered context programs R or by bounding the set A of atoms allowed to occur in R (relativized equivalence). For the latter approach, different v yield properly different equivalence notions, in general. For the former approach, however, it turned out that any \"reasonable\" syntactic restriction to R coincides with either ordinary, strong, or uniform equivalence (for uniform equivalence, the context ranges over arbitrary sets of facts, rather than program rules). In this paper, we propose a parameterization for equivalence notions which takes care of both such kinds of restrictions simultaneously by bounding, on the one hand, the atoms which are allowed to occur in the rule heads of the context and, on the other hand, the atoms which are allowed to occur in the rule bodies of the context. We introduce a general semantical characterization which includes known ones as SE-models (for strong equivalence) or UE-models (for uniform equivalence) as special cases. Moreover, we provide complexity bounds for the problem in question and sketch a possible implementation method making use of dedicated systems for checking ordinary equivalence.", "paper_title": "A common view on strong, uniform, and other notions of equivalence in answer-set programming", "paper_id": "WOS:000254430200004"}