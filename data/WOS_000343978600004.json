{"auto_keywords": [{"score": 0.03682252724874875, "phrase": "mm"}, {"score": 0.010063814482426669, "phrase": "fault_tolerance"}, {"score": 0.007835916170819184, "phrase": "fn"}, {"score": 0.005848299469069398, "phrase": "fm_multitolerance"}, {"score": 0.00481495049065317, "phrase": "existing_fault-intolerant_program"}, {"score": 0.004706206193274572, "phrase": "multiple_classes"}, {"score": 0.00459990650330792, "phrase": "potentially_different_level"}, {"score": 0.004025787455454387, "phrase": "legitimate_states"}, {"score": 0.003604576287781528, "phrase": "six_categories"}, {"score": 0.0035772012773052065, "phrase": "multitolerant_programs-ff"}, {"score": 0.003469972035503256, "phrase": "mn"}, {"score": 0.0034304408099591487, "phrase": "nn"}, {"score": 0.0029675701595142656, "phrase": "mn_multitolerance"}, {"score": 0.0029115112555515277, "phrase": "polynomial_time"}, {"score": 0.002867425368894356, "phrase": "state_space"}, {"score": 0.0027499652021456835, "phrase": "np"}, {"score": 0.0023784664152543718, "phrase": "multiple_faults"}, {"score": 0.0022375675189464715, "phrase": "mm_multitolerance"}, {"score": 0.002186904773823281, "phrase": "real-world_multitolerant_programs"}, {"score": 0.002129243122440408, "phrase": "design_decisions"}], "paper_keywords": ["Design", " Verification", " Reliability", " Fault tolerance", " multitolerance", " formal methods", " program synthesis"], "paper_abstract": "We focus on the problem of adding multitolerance to an existing fault-intolerant program. A multitolerant program tolerates multiple classes of faults and provides a potentially different level of fault tolerance to each of them. We consider three levels of fault tolerance, namely failsafe (i. e., satisfy safety in the presence of faults), nonmasking (i.e., recover to legitimate states after the occurrence of faults), and masking (both). For the case where the program is subject to two classes of faults, we consider six categories of multitolerant programs-FF, FN, FM, MM, MN, and NN, where F, N, and M represent failsafe, nonmasking, and masking levels of tolerance provided to each class of fault. We show that the problem of adding FF, NN, and MN multitolerance can be solved in polynomial time (in the state space of the program). However, the problem is NP-complete for adding FN, MM, and FM multitolerance. We note that the hardness of adding MM and FM multitolerance is especially atypical given that MM and FM multitolerance can be added efficiently under more restricted scenarios where multiple faults occur simultaneously in the same computation. We also present heuristics for managing the complexity of MM multitolerance. Finally, we present real-world multitolerant programs and discuss the trade-off involved in design decisions while developing such programs.", "paper_title": "The Complexity of Adding Multitolerance", "paper_id": "WOS:000343978600004"}