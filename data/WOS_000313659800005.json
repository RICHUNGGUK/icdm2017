{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "read_barriers"}, {"score": 0.015068988042376935, "phrase": "forwarding_pointers"}, {"score": 0.01346063765393457, "phrase": "shared_heap"}, {"score": 0.004713162564945179, "phrase": "managed_languages"}, {"score": 0.004515967518891287, "phrase": "copied_objects"}, {"score": 0.0044047527104545525, "phrase": "multicore_environment"}, {"score": 0.004373480870285314, "phrase": "thread-local_heaps"}, {"score": 0.004205395707787349, "phrase": "local_heap"}, {"score": 0.004000741805312148, "phrase": "store_operation"}, {"score": 0.003846926701870193, "phrase": "copy_operation"}, {"score": 0.0038060092376105414, "phrase": "forwarding_pointer"}, {"score": 0.003725470458263889, "phrase": "original_object"}, {"score": 0.0036596534390380287, "phrase": "copied_object"}, {"score": 0.0032533888943254144, "phrase": "managed_runtime"}, {"score": 0.003105979498529766, "phrase": "sufficient_degree"}, {"score": 0.0029652292779277782, "phrase": "stalled_actions"}, {"score": 0.002912803994461996, "phrase": "next_local_collection"}, {"score": 0.0027413748388534025, "phrase": "runtime_techniques"}, {"score": 0.0025984901976634726, "phrase": "incoming_references"}, {"score": 0.0024895500851796603, "phrase": "multiple_copies"}, {"score": 0.002454258761940649, "phrase": "program_semantics"}, {"score": 0.0023263181681045715, "phrase": "intel"}, {"score": 0.0022608057001451414, "phrase": "experimental_results"}, {"score": 0.002220806891955454, "phrase": "parallel_benchmarks"}, {"score": 0.002173739308244513, "phrase": "notable_performance_gains"}, {"score": 0.0021049977753042253, "phrase": "additional_complexity"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Management", " Measurement", " Performance", " barrier elimination", " private heaps", " parallel and concurrent collection", " cleanliness", " concurrent programming", " functional languages"], "paper_abstract": "Managed languages typically use read barriers to interpret forwarding pointers introduced to keep track of copied objects. For example, in a multicore environment with thread-local heaps and a global, shared heap, an object initially allocated on a local heap may be copied to a shared heap if it becomes the source of a store operation whose target location resides on the shared heap. As part of the copy operation, a forwarding pointer may be established in the original object to point to the copied object. This level of indirection avoids the need to update all of the references to the object that has been copied. In this paper, we consider the design of a managed runtime that eliminates read barriers. Our design is premised on the availability of a sufficient degree of concurrency to stall operations that would otherwise necessitate the copy. Stalled actions are deferred until the next local collection, avoiding exposing forwarding pointers to the mutator. In certain important cases, procrastination is unnecessary - lightweight runtime techniques can sometimes be used to allow objects to be eagerly copied when their set of incoming references is known, or when it can be determined that having multiple copies would not violate program semantics. We evaluate our techniques on 3 platforms: a 16-core AMD64 machine, a 48-core Intel SCC, and an 864-core Azul Vega 3. Experimental results over a range of parallel benchmarks indicate that our approach leads to notable performance gains (20 - 32% on average) without incurring any additional complexity.", "paper_title": "Eliminating Read Barriers through Procrastination and Cleanliness", "paper_id": "WOS:000313659800005"}