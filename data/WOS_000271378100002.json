{"auto_keywords": [{"score": 0.050078231441403664, "phrase": "language_implementation"}, {"score": 0.02658974894956529, "phrase": "clr"}, {"score": 0.004779876533667754, "phrase": "proper_compositionality"}, {"score": 0.004710489616113198, "phrase": "compiler_developer"}, {"score": 0.004508286991825192, "phrase": "large_language"}, {"score": 0.0044104497301196794, "phrase": "smaller_languages"}, {"score": 0.0043305354943056875, "phrase": "small_language_implementations"}, {"score": 0.0039665679106594106, "phrase": "different_applications"}, {"score": 0.0038946650372062783, "phrase": "domain-specific_languages"}, {"score": 0.003810093416457147, "phrase": "language_composition"}, {"score": 0.003713736138854327, "phrase": "grammar_level"}, {"score": 0.0035541673947328163, "phrase": "corresponding_ambiguities"}, {"score": 0.0034516024325468653, "phrase": "single_parser"}, {"score": 0.00336428077531883, "phrase": "tight_coupling"}, {"score": 0.0033397385936467204, "phrase": "grammar_modules"}, {"score": 0.0032433414042726356, "phrase": "independent_development"}, {"score": 0.0032196786163178107, "phrase": "language_features"}, {"score": 0.0030925761790620027, "phrase": "novel_parsing_algorithm"}, {"score": 0.0030509395728225445, "phrase": "component"}, {"score": 0.0029380187414193653, "phrase": "code-level_compositionality"}, {"score": 0.002863652837038965, "phrase": "separate_parser"}, {"score": 0.002832359116458113, "phrase": "grammar_component"}, {"score": 0.0027006464509273806, "phrase": "general_lr"}, {"score": 0.0026419338604879404, "phrase": "return_actions"}, {"score": 0.0026035011274172753, "phrase": "parsing_action"}, {"score": 0.0023324855762635616, "phrase": "loose_coupling"}, {"score": 0.0023154527779996213, "phrase": "parser_components"}, {"score": 0.0022077244919858218, "phrase": "ambiguous_token_definitions"}, {"score": 0.002175594509651082, "phrase": "island_grammars"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Component-based software development", " LR parsing", " Parser generator"], "paper_abstract": "A language implementation with proper compositionality, enables a compiler developer to divide-and-conquer the complexity of building a large language by constructing a set of smaller languages. Ideally, these small language implementations should be independent of each other such that they can be designed, implemented and debugged individually, and later be reused in different applications (e.g.. building domain-specific languages). However, the language composition offered by several existing parser generators resides at the grammar level, which means all the grammar modules need to be composed together and all corresponding ambiguities have to be resolved before generating a single parser for the language. This produces tight coupling between grammar modules, which harms information hiding and affects independent development of language features. To address this problem, we have developed a novel parsing algorithm that we call Component-based LR (CLR) parsing, which provides code-level compositionality for language development by producing a separate parser for each grammar component. In addition to shift and reduce actions, the algorithm extends general LR parsing by introducing switch and return actions to empower the parsing action to jump from one parser to another. Our experimental evaluation demonstrates that CLR increases the comprehensibility, reusability, changeability and independent development ability of the language implementation. Moreover, the loose coupling among parser components enables CLR to describe grammars that contain LR parsing conflicts or require ambiguous token definitions, such as island grammars and embedded languages. (C) 2009 Elsevier Ltd. All rights reserved.", "paper_title": "Component-based LR parsing", "paper_id": "WOS:000271378100002"}