{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "historical_moving_object_trajectories"}, {"score": 0.004681226806682058, "phrase": "paper_studies"}, {"score": 0.00422177384286051, "phrase": "r-tree-based_structures"}, {"score": 0.0034984340449789745, "phrase": "knn_search"}, {"score": 0.0034332736827447654, "phrase": "arbitrary_values"}, {"score": 0.0030097975788892896, "phrase": "single_access"}, {"score": 0.0028986672783671147, "phrase": "qualifying_nodes"}, {"score": 0.002765490759189057, "phrase": "final_result"}, {"score": 0.002564985233317994, "phrase": "memory_space_consumption"}, {"score": 0.002248366278757655, "phrase": "extensive_experiments"}, {"score": 0.0022064376000055764, "phrase": "synthetic_and_real_datasets"}, {"score": 0.0021450029487459403, "phrase": "bfpknn"}], "paper_keywords": [""], "paper_abstract": "This paper studies k-nearest-neighbor (kNN) search on R-tree-based structures storing historical information about trajectories. We develop BFPkNN, an efficient best-first based algorithm for handling kNN search with arbitrary values of k, which is I/O optimal, i.e., it performs a single access only to those qualifying nodes that may contain the final result. Furthermore, in order to save memory space consumption and reduce CPU overhead further, several effective pruning heuristics are also proposed. Finally, extensive experiments with synthetic and real datasets show that BFPkNN outperforms its competitor significantly in both efficiency and scalability in all cases.", "paper_title": "BFPkNN: An efficient k-nearest-neighbor search algorithm for historical moving object trajectories", "paper_id": "WOS:000241754200008"}