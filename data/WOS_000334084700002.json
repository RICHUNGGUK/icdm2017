{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "matrix_code"}, {"score": 0.007926176288534176, "phrase": "code_matrix"}, {"score": 0.004524624065803229, "phrase": "mathematical_semantics"}, {"score": 0.004444921827311577, "phrase": "heuristic_power"}, {"score": 0.004251728624599691, "phrase": "functional_and_logic_programming"}, {"score": 0.0029789104204803137, "phrase": "logical_conditions"}, {"score": 0.002537880772794665, "phrase": "abstract_machine"}, {"score": 0.002427372728532664, "phrase": "dual-state_machine"}, {"score": 0.002220551141101661, "phrase": "classical_finite-state_machine"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Programming methodology", " Program verification", " Finite-state machines"], "paper_abstract": "Matrix Code gives imperative programming a mathematical semantics and heuristic power comparable in quality to functional and logic programming. A program in Matrix Code is developed incrementally from a specification in pre/post-condition form. The computations of a code matrix are characterized by powers of the matrix when it is interpreted as a transformation in a space of vectors of logical conditions. Correctness of a code matrix is expressed in terms of a fixpoint of the transformation. The abstract machine for Matrix Code is the dual-state machine, which we present as a variant of the classical finite-state machine. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Matrix Code", "paper_id": "WOS:000334084700002"}