{"auto_keywords": [{"score": 0.048679801278110287, "phrase": "multi-core_processors"}, {"score": 0.025877153951041055, "phrase": "design_decisions"}, {"score": 0.00481495049065317, "phrase": "quantitative_metrics"}, {"score": 0.00475413908468027, "phrase": "computer_architects"}, {"score": 0.004276216827737399, "phrase": "large-scale_challenge"}, {"score": 0.004116139569480336, "phrase": "compiler_improvements"}, {"score": 0.004081385289516914, "phrase": "language_extensions"}, {"score": 0.003995772867224968, "phrase": "case_studies"}, {"score": 0.003813669883040509, "phrase": "experimental_tools"}, {"score": 0.0036864465771943933, "phrase": "expert_knowledge"}, {"score": 0.003593812067062062, "phrase": "multi-core_programming"}, {"score": 0.0035183910023550246, "phrase": "whole_software_industry"}, {"score": 0.0033865859510157238, "phrase": "mass_parallelization"}, {"score": 0.0032321559007422087, "phrase": "application_specification"}, {"score": 0.003204841443605308, "phrase": "algorithm_design"}, {"score": 0.003150900886669123, "phrase": "application_characterization"}, {"score": 0.003097865379563127, "phrase": "parallelization_strategies"}, {"score": 0.003071682293903262, "phrase": "data_layouts"}, {"score": 0.0030071857666598193, "phrase": "proper_software_design"}, {"score": 0.0028216858159564808, "phrase": "quantitative_application_characterization"}, {"score": 0.0021870332034407817, "phrase": "effective_parallel_applications_development"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["application characterization", " metric", " software design", " concurrency", " locality"], "paper_abstract": "When computer architects reinvented parallelism through multi-core processors, application parallelization became a problem. Now that multi-cores have penetrated from handhelds to supercomputers, parallelization becomes a large-scale challenge. A lot of research is going into compiler improvements, language extensions, frameworks and application/platform case studies. Whereas fairly successful, these solutions are based on experimental tools, trial-and-error, and expert knowledge, and do not bring multi-core programming into reach for the whole software industry. We believe that the challenge of \"mass parallelization\" must be tackled more systematically. Development begins at application specification and algorithm design, followed by application characterization with trade-offs in parallelization strategies and data layouts. Only with a proper software design, implementation and optimization can start. In this article, we focus on quantitative application characterization for such a systematic approach. We introduce a set of metrics to characterize applications and show how they can be used. We present our interpretation of the results and suggest ways to use them to guide design decisions. We conclude that metrics can be used to understand applications and design decisions early on. Therefore, this characterization brings us closer to effective parallel applications development for multi-core processors. Copyright (C) 2011 John Wiley & Sons, Ltd.", "paper_title": "Parallel application characterization with quantitative metrics", "paper_id": "WOS:000300977700002"}