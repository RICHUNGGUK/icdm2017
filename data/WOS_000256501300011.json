{"auto_keywords": [{"score": 0.03229148068424557, "phrase": "mc"}, {"score": 0.004616560363089716, "phrase": "managed_runtime_environments"}, {"score": 0.004460309246062286, "phrase": "multi-core_architectures"}, {"score": 0.004426308135681733, "phrase": "multi-threaded_applications"}, {"score": 0.0041316803676012155, "phrase": "heap_fragmentation"}, {"score": 0.004084510791138056, "phrase": "fast_linear_object_allocation"}, {"score": 0.004022451267521423, "phrase": "object_demographics"}, {"score": 0.003976523732243618, "phrase": "unreachable_objects"}, {"score": 0.003711723285313348, "phrase": "virtual_memory_pages"}, {"score": 0.0035586268203884673, "phrase": "virtual_address_space"}, {"score": 0.0035179764329354877, "phrase": "standard_operating_system"}, {"score": 0.003308862957060602, "phrase": "clustering_behavior"}, {"score": 0.0031360786664165093, "phrase": "pointer_adjustment"}, {"score": 0.00307657476125683, "phrase": "mapping_collector"}, {"score": 0.0029951555610569225, "phrase": "virtual_memory_operations"}, {"score": 0.002938317647182056, "phrase": "free_space"}, {"score": 0.0028170314398963704, "phrase": "nearly-single-phase_compactor"}, {"score": 0.002731971103291716, "phrase": "previously_reported_compactors"}, {"score": 0.0026698611202305694, "phrase": "effective_mre-os_coordination"}, {"score": 0.0025892330566358503, "phrase": "non-moving_collector"}, {"score": 0.0025596276616952516, "phrase": "efficient_parallel"}, {"score": 0.002540078552743003, "phrase": "concurrent_compaction"}, {"score": 0.0024073421672242486, "phrase": "generational_garbage_collection_framework"}, {"score": 0.002361632539339945, "phrase": "java_virtual"}, {"score": 0.0021956951486095805, "phrase": "pause_times"}, {"score": 0.0021049977753042253, "phrase": "parallel_and_concurrent_compactors"}], "paper_keywords": ["algorithms", " languages", " performance", " virtual memory", " compaction", " parallel", " concurrent"], "paper_abstract": "Parallel and concurrent garbage collectors are increasingly employed by managed runtime environments (MREs) to maintain scalability, as multi-core architectures and multi-threaded applications become pervasive. Moreover, state-of-the-art MREs commonly implement compaction to eliminate heap fragmentation and enable fast linear object allocation. Our empirical analysis of object demographics reveals that unreachable objects in the heap tend to form clusters large enough to be effectively managed at the granularity of virtual memory pages. Even though processes can manipulate the mapping of the virtual address space through the standard operating system (OS) interface on most platforms, extant parallel/concurrent compactors do not do so to exploit this clustering behavior and instead achieve compaction by performing, relatively expensive, object moving and pointer adjustment. We introduce the Mapping Collector (MC), which leverages virtual memory operations to reclaim and consolidate free space without moving objects and updating pointers. MC is a nearly-single-phase compactor that is simpler and more efficient than previously reported compactors that comprise two to four phases. Through effective MRE-OS coordination, MC maintains the simplicity of a non-moving collector while providing efficient parallel and concurrent compaction. We implement both stop-the-world and concurrent MC in a generational garbage collection framework within the open-source HotSpot Java Virtual Machine. Our experimental evaluation using a multiprocessor indicates that MC significantly increases throughput and scalability as well as reduces pause times, relative to state-of-the-art, parallel and concurrent compactors.", "paper_title": "The Mapping Collector: Virtual memory support for generational, parallel, and concurrent compaction", "paper_id": "WOS:000256501300011"}