{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "xml_queries"}, {"score": 0.014534392069569455, "phrase": "materialized_views"}, {"score": 0.012214314760607288, "phrase": "query_performance"}, {"score": 0.004747314816584038, "phrase": "inverted_lists_evaluation_model"}, {"score": 0.004707188147442449, "phrase": "holistic_stack-based_algorithms"}, {"score": 0.004562923889976588, "phrase": "large_persistent_xml_data"}, {"score": 0.004348580182733617, "phrase": "novel_approach"}, {"score": 0.0042152598699753165, "phrase": "exactly_the_inverted_sublists"}, {"score": 0.004028572475177205, "phrase": "view_materializations"}, {"score": 0.004005823201694909, "phrase": "compressed_bitmaps"}, {"score": 0.003927203683176278, "phrase": "materialization_space"}, {"score": 0.003882970272082245, "phrase": "optimization_operations"}, {"score": 0.0038610400240820307, "phrase": "cpu-efficient_bitwise_operations"}, {"score": 0.0035666632046674153, "phrase": "xml_tree"}, {"score": 0.0034966325163550177, "phrase": "tree-pattern_views"}, {"score": 0.003078028357912228, "phrase": "overall_query_evaluation_cost"}, {"score": 0.0029920129598858545, "phrase": "tree_pattern_queries"}, {"score": 0.0029415584202462444, "phrase": "view_configurations"}, {"score": 0.0028674628275126824, "phrase": "main_memory"}, {"score": 0.0024120247307686084, "phrase": "structural_indexes"}, {"score": 0.0022919762167777427, "phrase": "structural_index_approach"}, {"score": 0.0022725559033018572, "phrase": "test_cases"}, {"score": 0.0021778895748464024, "phrase": "best_candidate"}, {"score": 0.0021049977753042253, "phrase": "inverted_lists_model"}], "paper_keywords": ["XPath query evaluation", " XML", " Materialized views", " View configuration"], "paper_abstract": "In recent years the inverted lists evaluation model along with holistic stack-based algorithms have been established as the most prominent techniques for evaluating XML queries on large persistent XML data. In this framework, we are using materialized views for optimizing XML queries. We consider a novel approach which instead of materializing the answer of a view materializes exactly the inverted sublists that are necessary for computing the answer of the view. This originality allows storing view materializations as compressed bitmaps, a solution that minimizes the materialization space and empowers performing optimization operations as CPU-efficient bitwise operations. To realize the potential of bitmap materialized views in optimizing query performance, we define and address the following problem (view configuration problem): given an XML tree and its schema find a template of tree-pattern views (view configuration) such that: (a) the views of this configuration can answer all the queries that can be issued against the schema, (b) their materialization fits in the space provided, and (c) evaluating the queries using these views minimizes the overall query evaluation cost. We consider an instance of this problem for tree pattern queries. Our intension is to find view configurations whose materializations are small enough to be stored in main memory. We find two candidate solution configurations and we identify cases where views can be excluded from materialization in a configuration without affecting query performance. In order to compare our approach with an approach which also can support the optimization of every query on the schema, we implemented an improvement of a state-of-the-art approach which is based on structural indexes. Our experimental results show that our approach is stable, greatly improves evaluating queries without materialized views, outperforms the structural index approach on all test cases and is very close to the optimal. These results characterize our approach as the best candidate for supporting the optimization of queries in the framework of the inverted lists model.", "paper_title": "Configuring bitmap materialized views for optimizing XML queries", "paper_id": "WOS:000354386500005"}