{"auto_keywords": [{"score": 0.03253253627295769, "phrase": "dijkstra's_algorithm"}, {"score": 0.011406166027511504, "phrase": "priority_queue"}, {"score": 0.009193352048295274, "phrase": "fibonacci_heaps"}, {"score": 0.00481495049065317, "phrase": "single_source"}, {"score": 0.004716520738331953, "phrase": "single_source_shortest_paths_problem"}, {"score": 0.004684157900507474, "phrase": "positive_edge_weights"}, {"score": 0.004479120557712926, "phrase": "theoretical_computer_science"}, {"score": 0.004372442291178139, "phrase": "practical_situations"}, {"score": 0.004253618550301311, "phrase": "polynomial_time"}, {"score": 0.004224428521448974, "phrase": "dijkstra"}, {"score": 0.004081385289516914, "phrase": "smallest_distance"}, {"score": 0.003956784357357341, "phrase": "shortest_path"}, {"score": 0.003822778117250714, "phrase": "general_theme"}, {"score": 0.0035804980565263024, "phrase": "dijkstra_implementation"}, {"score": 0.0033883824438527316, "phrase": "dijkstra's_approach"}, {"score": 0.0033654503607336047, "phrase": "omega"}, {"score": 0.0032848684681050745, "phrase": "n_vertices"}, {"score": 0.003097865379563127, "phrase": "fastest_implementation"}, {"score": 0.002841971477743441, "phrase": "dijkstra_procedure"}, {"score": 0.002822434555587263, "phrase": "ssspp"}, {"score": 0.0027551040319267446, "phrase": "comparison-based_model"}, {"score": 0.002670884656785558, "phrase": "new_data_structure"}, {"score": 0.002643386043540555, "phrase": "priority_queues"}, {"score": 0.0025014259919355453, "phrase": "phased_dijkstra"}, {"score": 0.0023265809733919547, "phrase": "data_structures"}, {"score": 0.0021940118003312397, "phrase": "graph_family"}, {"score": 0.0021049977753042253, "phrase": "sparse_and_dense_graphs"}], "paper_keywords": ["Single source shortest path", " Dijkstra's algorithm", " Priority queues", " Two-level heaps", " Edge relaxation"], "paper_abstract": "The single source shortest paths problem with positive edge weights (SSSPP) is one of the more widely studied problems in operations research and theoretical computer science, on account of its wide applicability to practical situations. This problem was first solved in polynomial time by Dijkstra, who showed that by extracting vertices with the smallest distance from the source and relaxing its outgoing edges, the shortest path to each vertex is obtained. Variations of this general theme have led to a number of algorithms which work well in practice. At the heart of a Dijkstra implementation is the technique used to implement a priority queue. It is well known that using Dijkstra's approach requires Omega (n log n)steps on a graph having n vertices, since it essentially sorts vertices based on their distances from the source. Accordingly, the fastest implementation of Dijkstra's algorithm on a graph with it vertices and in edges should take Omega (m + n . log n) time, and consequently, the Dijkstra procedure for SSSPP using Fibonacci Heaps is optimal in the comparison-based model. In this paper, we introduce a new data structure to implement priority queues called two-level heap (TLH) and a new variant of Dijkstra's algorithm called Phased Dijkstra. We contrast the performance of Dijkstra's algorithm (both the simple and the phased variants) using a number of data structures to implement the priority queue and empirically establish that TLH are far superior to Fibonacci heaps on every graph family considered. It is to be noted that our profiling includes both sparse and dense graphs.", "paper_title": "Two-level heaps: a new priority queue structure with applications to the single source shortest path problem", "paper_id": "WOS:000284239600002"}