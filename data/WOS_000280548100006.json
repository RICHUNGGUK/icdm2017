{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "atomic_blocks"}, {"score": 0.009920410651666897, "phrase": "tm"}, {"score": 0.004645057834614705, "phrase": "research_prototypes"}, {"score": 0.004535124351828787, "phrase": "transactional_memory"}, {"score": 0.0038043055953253047, "phrase": "implementation_details"}, {"score": 0.00374399358035391, "phrase": "exactly_what_kind"}, {"score": 0.003611751858608048, "phrase": "lock_inference"}, {"score": 0.0033745298175222056, "phrase": "conflict_rates"}, {"score": 0.00288736193515505, "phrase": "atomic_block"}, {"score": 0.0025101968585850474, "phrase": "windbg_debugger"}, {"score": 0.0024214310759759572, "phrase": "tm."}, {"score": 0.0023451553255837317, "phrase": "\"conflict_point_discovery\"_technique"}, {"score": 0.002121913011761504, "phrase": "genome_application"}, {"score": 0.0021049977753042253, "phrase": "stamp_tm_benchmark_suite"}], "paper_keywords": ["Languages", " Reliability", " Transactional Memory", " Debugging"], "paper_abstract": "With the emergence of research prototypes, programming using atomic blocks and transactional memory (TM) is becoming more attractive. This paper describes our experience building and using a debugger for programs written with these abstractions. We introduce three approaches: (i) debugging at the level of atomic blocks, where the programmer is shielded from implementation details (such as exactly what kind of TM is used, or indeed whether lock inference is used instead), (ii) debugging at the level of transactions, where conflict rates, read sets, write sets, and other TM internals are visible, and (iii) debug-time transactions, which let the programmer manipulate synchronization from within the debugger-e.g., enlarging the scope of an atomic block to try to identify a bug. In this paper we explain the rationale behind the new debugging approaches that we propose. We describe the design and implementation of an extension to the WinDbg debugger, enabling support for C# programs using atomic blocks and TM. We also demonstrate the design of a \"conflict point discovery\" technique for identifying program statements that introduce contention between transactions. We illustrate how these techniques can be used by optimizing a C# version of the Genome application from STAMP TM benchmark suite.", "paper_title": "Debugging Programs that use Atomic Blocks and Transactional Memory", "paper_id": "WOS:000280548100006"}