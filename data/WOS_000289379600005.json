{"auto_keywords": [{"score": 0.048923016754706936, "phrase": "moi"}, {"score": 0.00481495049065317, "phrase": "multi-output_instructions"}, {"score": 0.0047448515702010734, "phrase": "multi-output_instruction"}, {"score": 0.004540591176992658, "phrase": "multiple_outputs"}, {"score": 0.00428179779071721, "phrase": "embedded_processors"}, {"score": 0.00413767314434795, "phrase": "application-specific_architectures"}, {"score": 0.004017989546119125, "phrase": "high-level_programmability"}, {"score": 0.003940122359770492, "phrase": "widespread_acceptance"}, {"score": 0.003901754272977278, "phrase": "sophisticated_compiler_support"}, {"score": 0.0038448988429199086, "phrase": "programmable_cores"}, {"score": 0.0037336520904376687, "phrase": "traditional_tree-based_approaches"}, {"score": 0.0034355662264234864, "phrase": "fundamental_limitation"}, {"score": 0.003385480888810982, "phrase": "tree_representation"}, {"score": 0.0032714270066711835, "phrase": "optimal_code"}, {"score": 0.002880333728285514, "phrase": "new_methodology"}, {"score": 0.0028106505443369545, "phrase": "simple_instruction_set_descriptions"}, {"score": 0.0027832502848247303, "phrase": "graph-based_code_selectors"}, {"score": 0.0027026375053777543, "phrase": "provided_instructions"}, {"score": 0.002548331088496964, "phrase": "target_processor"}, {"score": 0.002356173823922118, "phrase": "application_level"}, {"score": 0.002254510319372956, "phrase": "architecture_exploration"}, {"score": 0.0022216045996270974, "phrase": "code_generators"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler/architecture co-design", " code generation", " embedded system", " ASIP", " ISS"], "paper_abstract": "A multi-output instruction (MOI) is an instruction that produces multiple outputs to its destination locations. Such inherently parallel instructions are becoming more and more popular in embedded processors, due to the advances in application-specific architectures. In order to provide high-level programmability and thus guarantee widespread acceptance, sophisticated compiler support for these programmable cores is necessary. However, traditional tree-based approaches for instruction selection, although very fast, fail to exploit MOIs mainly because of the fundamental limitation of the tree representation. In fact, to generate optimal code with MOIs requires a more general graph-based formulation of the instruction selection problem, which is at least NP-complete. In this paper we present a new methodology to automatically generate from simple instruction set descriptions, graph-based code selectors that can effectively utilize all provided instructions including MOIs. Our experimental results using a set of benchmarks on a target processor with various MOIs of up to two outputs demonstrate that our generated code selectors can quickly and effectively exploit many MOIs at the application level, and therefore are highly desirable both for architecture exploration and as code generators after architecture is fixed. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "Fast graph-based instruction selection for multi-output instructions", "paper_id": "WOS:000289379600005"}