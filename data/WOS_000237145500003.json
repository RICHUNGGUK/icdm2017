{"auto_keywords": [{"score": 0.039541503396406254, "phrase": "apls"}, {"score": 0.004527619017250708, "phrase": "new_api"}, {"score": 0.004294962474996283, "phrase": "development_process"}, {"score": 0.0033572130837348623, "phrase": "migration_tools"}, {"score": 0.003212663446866794, "phrase": "api_changes"}, {"score": 0.0028652153774536967, "phrase": "existing_applications"}, {"score": 0.002623669616798891, "phrase": "particular_categories"}, {"score": 0.0023604768913655463, "phrase": "refactoring-based_migration_tools"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["API evolution", " refactoring", " frameworks", " libraries", " component reuse", " backwards compatibility"], "paper_abstract": "Frameworks and libraries change their APIs. Migrating an application to the new API is tedious and disrupts the development process. Although some tools and ideas have been proposed to solve the evolution of APls, most updates are done manually. To better understand the requirements for migration tools, we studied the API changes of four frameworks and one library. We discovered that the changes that break existing applications are not random, but tend to fall into particular categories. Over 80% of these changes are refactorings. This suggests that refactoring-based migration tools should be used to update applications. Copyright (C) 2006 John Wiley & Sons, Ltd.", "paper_title": "How do APIs evolve? A story of refactoring", "paper_id": "WOS:000237145500003"}