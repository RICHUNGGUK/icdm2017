{"auto_keywords": [{"score": 0.04099087276544599, "phrase": "bpmatch"}, {"score": 0.00481495049065317, "phrase": "segmental_analysis"}, {"score": 0.004772367030970874, "phrase": "genomic_sequences"}, {"score": 0.00446471538346719, "phrase": "suitably_modified_suffix-tree_data_structure"}, {"score": 0.004289686492089576, "phrase": "fast_and_efficient_way"}, {"score": 0.004176813329075736, "phrase": "source_sequence_s"}, {"score": 0.004121490798711703, "phrase": "target_sequence_t"}, {"score": 0.004013025478863664, "phrase": "direct_and_reverse_segments"}, {"score": 0.003687960013746783, "phrase": "minimum_number"}, {"score": 0.0032416819339366712, "phrase": "significant_segments"}, {"score": 0.0031845067058084583, "phrase": "computed_segment-based_distance"}, {"score": 0.003128336741911927, "phrase": "worst_case"}, {"score": 0.003073154478201771, "phrase": "alphabet_dimension_d"}, {"score": 0.002537880772794665, "phrase": "minrep_parameter"}, {"score": 0.0022604585778195152, "phrase": "trivial_solution"}, {"score": 0.002220551141101661, "phrase": "single_segment_coincident"}, {"score": 0.0021910825909008946, "phrase": "whole_sequence"}, {"score": 0.0021333110194180997, "phrase": "self-covering_approach"}, {"score": 0.0021049977753042253, "phrase": "spectral_representation"}], "paper_keywords": ["Segmental analysis", " genomic sequences", " repeats", " inverted repeats", " coverage index"], "paper_abstract": "Here, we propose BpMatch: an algorithm that, working on a suitably modified suffix-tree data structure, is able to compute, in a fast and efficient way, the coverage of a source sequence S on a target sequence T, by taking into account direct and reverse segments, eventually overlapped. Using BpMatch, the operator should define a priori, the minimum length l of a segment and the minimum number of occurrences minRep, so that only segments longer than l and having a number of occurrences greater than minRep are considered to be significant. BpMatch outputs the significant segments found and the computed segment-based distance. On the worst case, assuming the alphabet dimension d is a constant, the time required by BpMatch to calculate the coverage is O(l(2)n). On the average, by setting l >= 2 log(d)(n), the time required to calculate the coverage is only O(n). BpMatch, thanks to the minRep parameter, can also be used to perform a self-covering: to cover a sequence using segments coming from itself, by avoiding the trivial solution of having a single segment coincident with the whole sequence. The result of the self-covering approach is a spectral representation of the repeats contained in the sequence. BpMatch is freely available on: www.sourceforge.net/projects/bpmatch/.", "paper_title": "BpMatch: An Efficient Algorithm for a Segmental Analysis of Genomic Sequences", "paper_id": "WOS:000304147000019"}