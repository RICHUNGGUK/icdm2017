{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "flow_information"}, {"score": 0.010580671251888479, "phrase": "wcet_analysis"}, {"score": 0.005586507991530927, "phrase": "source_level"}, {"score": 0.005029203800304908, "phrase": "machine_code"}, {"score": 0.004725385523804256, "phrase": "timing_analysis"}, {"score": 0.004672444473700524, "phrase": "steadily_growing_embedded-systems_market"}, {"score": 0.004551199992546761, "phrase": "real-time_constraints"}, {"score": 0.004269630481719451, "phrase": "worst-case_execution_time"}, {"score": 0.00419016653753787, "phrase": "software_components"}, {"score": 0.004066076430818046, "phrase": "additional_control-flow_information"}, {"score": 0.0038576618286586387, "phrase": "program_analysis"}, {"score": 0.003382017342396959, "phrase": "precise_wcet_bounds"}, {"score": 0.0032817813775647756, "phrase": "machine-code_level"}, {"score": 0.0028986672783671147, "phrase": "highly_optimized_code"}, {"score": 0.0027602925235474317, "phrase": "source_code"}, {"score": 0.002560162916190598, "phrase": "code_transformations"}, {"score": 0.0025219085140220773, "phrase": "optimizing_compiler"}, {"score": 0.0024287485834314027, "phrase": "manual_code_annotations"}, {"score": 0.002392453087295389, "phrase": "platform-independent_flow_information"}, {"score": 0.0022022878843247257, "phrase": "code_transformation"}, {"score": 0.0021530945641993152, "phrase": "flow-information_transformation"}, {"score": 0.0021049977753042253, "phrase": "tight_wcet_bounds"}], "paper_keywords": ["Worst-case execution time analysis", " Real-time languages", " Compiler optimizations", " Code transformation", " Abstract interpretation", " Graph transformation"], "paper_abstract": "The steadily growing embedded-systems market comprises many application domains in which real-time constraints must be satisfied. To guarantee that these constraints are met, the analysis of the worst-case execution time (WCET) of software components is mandatory. In general WCET analysis needs additional control-flow information, which may be provided manually by the user or calculated automatically by program analysis. For flexibility and simplicity reasons it is desirable to specify the flow information at the same level at which the program is developed, i.e., at the source level. In contrast, to obtain precise WCET bounds the WCET analysis has to be performed at machine-code level. Mapping and transforming the flow information from the source-level down to the machine code, where flow information is used in the WCET analysis, is challenging, even more so if the compiler generates highly optimized code. In this article we present a method for transforming flow information from source code to machine code. To obtain a mapping that is safe and accurate, flow information is transformed in parallel to code transformations performed by an optimizing compiler. This mapping is not only useful for transforming manual code annotations but also if platform-independent flow information is automatically calculated at the source level. We show that our method can be applied to every type of semantics-preserving code transformation. The precision of this flow-information transformation allows its users to calculate tight WCET bounds.", "paper_title": "Transforming flow information during code optimization for timing analysis", "paper_id": "WOS:000278028900003"}