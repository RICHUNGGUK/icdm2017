{"auto_keywords": [{"score": 0.028027825832051666, "phrase": "context_identifiers"}, {"score": 0.012203711028741458, "phrase": "c_programs"}, {"score": 0.00481495049065317, "phrase": "prior_work"}, {"score": 0.00475382761232911, "phrase": "call_path_profiles"}, {"score": 0.0046141941030386525, "phrase": "programmer-productivity_tools"}, {"score": 0.004497762477097628, "phrase": "path_profiles"}, {"score": 0.004328576620172571, "phrase": "additional_instructions"}, {"score": 0.003891140864902669, "phrase": "call_path"}, {"score": 0.003634587156159668, "phrase": "java_programs"}, {"score": 0.003527712410706358, "phrase": "innovative_technique"}, {"score": 0.0034828730516958807, "phrase": "minimal_information"}, {"score": 0.0034386016613475335, "phrase": "running_program"}, {"score": 0.0033232673019931206, "phrase": "full_call_paths"}, {"score": 0.003239304090565123, "phrase": "key_insight"}, {"score": 0.0030645676308053444, "phrase": "call_stack"}, {"score": 0.0029744042270542655, "phrase": "executing_function"}, {"score": 0.002936577024096783, "phrase": "good_indicators"}, {"score": 0.002572709810193776, "phrase": "function_activation_records"}, {"score": 0.002465210678474529, "phrase": "executed_instructions"}, {"score": 0.002159623311924437, "phrase": "correct_unique_call_path"}], "paper_keywords": ["Measurement", " Performance", " Profiling", " Call Path", " Calling Context", " Calling Context Tree", " Stack"], "paper_abstract": "Prior work has found call path profiles to be useful for optimizers and programmer-productivity tools. Unfortunately, previous approaches for collecting path profiles are expensive: they need to either execute additional instructions (to track calls and returns) or they need to walk the stack. The state-of-the-art techniques for call path profiling slow down the program by 7% (for C programs) and 20% (for Java programs). This paper describes an innovative technique that collects minimal information from the running program and later (offline) infers the full call paths from this information. The key insight behind our approach is that readily available information during program execution-the height of the call stack and the identity of the current executing function-are good indicators of calling context. We call this pair a context identifier. Because more than one call path may have the same context identifier, we show how to disambiguate context identifiers by changing the sizes of function activation records. This disambiguation has no overhead in terms of executed instructions. We evaluate our approach on the SPEC CPU 2006 C++ and C benchmarks. We show that collecting context identifiers slows down programs by 0.17% (geometric mean). We can map these context identifiers to the correct unique call path 80% of the time for C++ programs and 95% of the time for C programs.", "paper_title": "Inferred Call Path Profiling", "paper_id": "WOS:000271211300010"}