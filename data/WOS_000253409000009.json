{"auto_keywords": [{"score": 0.04973625252864221, "phrase": "smc"}, {"score": 0.03824987344645661, "phrase": "program_code"}, {"score": 0.032137152826463, "phrase": "local_reasoning"}, {"score": 0.00481495049065317, "phrase": "self-modifying_code"}, {"score": 0.004276610897002087, "phrase": "world's_critical_software_systems"}, {"score": 0.004230749292148046, "phrase": "runtime_code_generation"}, {"score": 0.0041703614123283165, "phrase": "dynamic_loading"}, {"score": 0.004110831924517065, "phrase": "os_boot_loader"}, {"score": 0.004081385289516914, "phrase": "just-in-time_compilation"}, {"score": 0.0039942998891989955, "phrase": "dynamic_code_encryption"}, {"score": 0.0037171648669537287, "phrase": "hoare_logic"}, {"score": 0.003690527690610707, "phrase": "type_system"}, {"score": 0.003385336776758738, "phrase": "simple_but_novel_hoare-logic-like_framework"}, {"score": 0.0032893028281789287, "phrase": "general_von-neumann_machine_code"}, {"score": 0.003161674440750158, "phrase": "code_memory"}, {"score": 0.0030171910207671205, "phrase": "separation_logic"}, {"score": 0.002910545717767559, "phrase": "regular_data_structure"}, {"score": 0.0027378045447760705, "phrase": "frame_rules"}, {"score": 0.002660198188186712, "phrase": "smc."}, {"score": 0.0025021765811679446, "phrase": "assembly_code"}, {"score": 0.00247529638625566, "phrase": "modern_cpus"}, {"score": 0.0024225070698478835, "phrase": "mips"}, {"score": 0.0022950308685133224, "phrase": "coq_proof_assistant"}, {"score": 0.0022218413146898887, "phrase": "realistic_examples"}, {"score": 0.0021278653331014614, "phrase": "spim_simulator"}], "paper_keywords": ["languages", " verification", " self-modifying code", " runtime code manipulation", " assembly code verification", " modular verification", " Hoare logic"], "paper_abstract": "Self-modifying code (SMC), in this paper, broadly refers to any program that loads, generates, or mutates code at runtime. It is widely used in many of the world's critical software systems to support runtime code generation and optimization, dynamic loading and linking, OS boot loader, just-in-time compilation, binary translation, or dynamic code encryption and obfuscation. Unfortunately, SMC is also extremely difficult to reason about: existing formal veri. cation techniques-including Hoare logic and type system consistently assume that program code stored in memory is fixed and immutable; this severely limits their applicability and power. This paper presents a simple but novel Hoare-logic-like framework that supports modular veri. cation of general von-Neumann machine code with runtime code manipulation. By dropping the assumption that code memory is fixed and immutable, we are forced to apply local reasoning and separation logic at the very beginning, and treat program code uniformly as regular data structure. We address the interaction between separation and code memory and show how to establish the frame rules for local reasoning even in the presence of SMC. Our framework is realistic, but designed to be highly generic, so that it can support assembly code under all modern CPUs (including both x86 and MIPS). Our system is expressive and fully mechanized. We prove its soundness in the Coq proof assistant and demonstrate its power by certifying a series of realistic examples and applications-all of which can directly run on the SPIM simulator or any stock x86 hardware.", "paper_title": "Certified self-modifying code", "paper_id": "WOS:000253409000009"}