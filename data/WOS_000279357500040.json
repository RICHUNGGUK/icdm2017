{"auto_keywords": [{"score": 0.039607689734690914, "phrase": "indirection_pointers"}, {"score": 0.00481495049065317, "phrase": "conquer_speed"}, {"score": 0.0046859752697029355, "phrase": "ubiquitous_organization"}, {"score": 0.00464976086880886, "phrase": "indexed_data"}, {"score": 0.004578165674080246, "phrase": "language_evolution"}, {"score": 0.0042035670399069485, "phrase": "heap_fragmentation"}, {"score": 0.004171065188039856, "phrase": "garbage_collection"}, {"score": 0.003981243132108877, "phrase": "sparse_and_over-provisioned_arrays"}, {"score": 0.003874512990986722, "phrase": "managed_languages"}, {"score": 0.0038296485293910026, "phrase": "array_layout"}, {"score": 0.0037414662674652805, "phrase": "fixed-size_discontiguous_memory_blocks"}, {"score": 0.0035850198321277418, "phrase": "significant_overhead"}, {"score": 0.0035024506353894644, "phrase": "real-time_deadlines"}, {"score": 0.003129317057177867, "phrase": "fixed-size_memory_blocks"}, {"score": 0.0030572112793962004, "phrase": "five_optimizations"}, {"score": 0.002975178815784779, "phrase": "first_n_array"}, {"score": 0.0025766822940260963, "phrase": "discontiguous_arrays"}, {"score": 0.0025567271683947547, "phrase": "prior_work"}, {"score": 0.0024688196796198766, "phrase": "time_efficiency"}, {"score": 0.0023932142697579506, "phrase": "best_z-ray_configuration"}, {"score": 0.0023380300046435187, "phrase": "unmodified_java_virtual_machine"}, {"score": 0.002293014162421338, "phrase": "previous_designs"}, {"score": 0.002205560249972527, "phrase": "z-ray_optimizations"}, {"score": 0.0021049977753042253, "phrase": "better_building_block"}], "paper_keywords": ["Performance", " Measurement", " Experimentation", " Heap", " Compression", " Arrays", " Arraylets", " Z-rays"], "paper_abstract": "Arrays are the ubiquitous organization for indexed data. Throughout programming language evolution, implementations have laid out arrays contiguously in memory. This layout is problematic in space and time. It causes heap fragmentation, garbage collection pauses in proportion to array size, and wasted memory for sparse and over-provisioned arrays. Because of array virtualization in managed languages, an array layout that consists of indirection pointers to fixed-size discontiguous memory blocks can mitigate these problems transparently. This design however incurs significant overhead, but is justified when real-time deadlines and space constraints trump performance. This paper proposes z-rays, a discontiguous array design with flexibility and efficiency. A z-ray has a spine with indirection pointers to fixed-size memory blocks called arraylets, and uses five optimizations: (1) inlining the first N array bytes into the spine, (2) lazy allocation, (3) zero compression, (4) fast array copy, and (5) arraylet copy-on-write. Whereas discontiguous arrays in prior work improve responsiveness and space efficiency, z-rays combine time efficiency and flexibility. On average, the best z-ray configuration performs within 12.7% of an unmodified Java Virtual Machine on 19 benchmarks, whereas previous designs have two to three times higher overheads. Furthermore, language implementers can configure z-ray optimizations for various design goals. This combination of performance and flexibility creates a better building block for past and future array optimization.", "paper_title": "Z-Rays: Divide Arrays and Conquer Speed and Flexibility", "paper_id": "WOS:000279357500040"}