{"auto_keywords": [{"score": 0.04418904933578093, "phrase": "redundancy-free_xml_storage_structures"}, {"score": 0.03976455706091998, "phrase": "scheme_trees"}, {"score": 0.00481495049065317, "phrase": "largest_redundancy-free_xml_storage_structure"}, {"score": 0.004694700982410345, "phrase": "polynomial_time"}, {"score": 0.004519908617935935, "phrase": "embedded_functional_dependencies"}, {"score": 0.004067635935640407, "phrase": "redundancy-free_xml_structures"}, {"score": 0.003982741546775355, "phrase": "storage_space"}, {"score": 0.0038996120252338556, "phrase": "update_anomalies"}, {"score": 0.003818210967854446, "phrase": "least_number"}, {"score": 0.003738502710504415, "phrase": "fewest_number"}, {"score": 0.0036296886647898094, "phrase": "data_elements"}, {"score": 0.0035389348527719404, "phrase": "general_problem"}, {"score": 0.0032387402145603412, "phrase": "boyce-codd_normal_form"}, {"score": 0.00305285084207725, "phrase": "acyclic_hypergraph"}, {"score": 0.0029890726032001224, "phrase": "bcnf"}, {"score": 0.002951444412262927, "phrase": "polynomial-time_algorithm"}, {"score": 0.002889778121878728, "phrase": "largest_possible_redundancy-free_xml_storage_structure"}, {"score": 0.0027123819773059127, "phrase": "generated_scheme_trees"}, {"score": 0.0026782279715171866, "phrase": "reasonable_heuristic"}, {"score": 0.002633355582628613, "phrase": "fewest_possible_scheme_trees"}, {"score": 0.002389514188569084, "phrase": "correctness_proof"}, {"score": 0.0023594160789762227, "phrase": "complexity_analysis"}, {"score": 0.0022522565004588113, "phrase": "experimental_results"}, {"score": 0.002233301265743633, "phrase": "randomly_generated_but_appropriately_constrained_hypergraphs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["XML data redundancy", " Large XML storage structures", " XML-Schema generation", " Acyclic hypergraphs"], "paper_abstract": "Given a hypergraph and a set of embedded functional dependencies, we investigate the problem of determining the conditions under which we can efficiently generate redundancy-free XML storage structures with as few scheme trees as possible. Redundancy-free XML structures guarantee both economy in storage space and the absence of update anomalies, and having the least number of scheme trees requires the fewest number of joins to navigate among the data elements. We know that the general problem is intractable. The problem may still be intractable even when the hypergraph is acyclic and each hyperedge is in Boyce-Codd normal form (BCNF). As we show here, however, given an acyclic hypergraph with each hyperedge in BCNF, a polynomial-time algorithm exists that generates a largest possible redundancy-free XML storage structure. Successively generating largest possible scheme trees from among hyperedges not already included in generated scheme trees constitutes a reasonable heuristic for finding the fewest possible scheme trees. For many practical cases, this heuristic finds the set of redundancy-free XML storage structures with the fewest number of scheme trees. In addition to a correctness proof and a complexity analysis showing that the algorithm is polynomial, we also give experimental results over randomly generated but appropriately constrained hypergraphs showing empirically that the algorithm is indeed polynomial. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Extracting a largest redundancy-free XML storage structure from an acyclic hypergraph in polynomial time", "paper_id": "WOS:000279971800006"}