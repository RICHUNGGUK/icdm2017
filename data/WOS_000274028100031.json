{"auto_keywords": [{"score": 0.03710335083466446, "phrase": "flanagan"}, {"score": 0.013626066487056913, "phrase": "felleisen"}, {"score": 0.00532220499089876, "phrase": "findler"}, {"score": 0.00481495049065317, "phrase": "higher-order_contracts"}, {"score": 0.004465126965932753, "phrase": "latent_contracts"}, {"score": 0.004314595541370065, "phrase": "type_system"}, {"score": 0.004255807517348647, "phrase": "manifest_contracts"}, {"score": 0.004212240534862585, "phrase": "refinement_types"}, {"score": 0.0039464466517932706, "phrase": "equivalent-different_ways"}, {"score": 0.003826441783705964, "phrase": "simple_type_system"}, {"score": 0.0035481809241908044, "phrase": "gronski"}, {"score": 0.0034284557556382815, "phrase": "latent_calculus"}, {"score": 0.0029578641378775633, "phrase": "translation_psi"}, {"score": 0.0028580007147015734, "phrase": "analogous_theorem"}, {"score": 0.002799703831407504, "phrase": "whole_framework"}, {"score": 0.0027805362553564336, "phrase": "dependent_contracts"}, {"score": 0.002733187900351625, "phrase": "free_variables"}, {"score": 0.0025429488129788103, "phrase": "dependent_versions"}, {"score": 0.002374063735432571, "phrase": "type_soundness"}, {"score": 0.0023497148309861303, "phrase": "substantial_result"}, {"score": 0.002193634795186667, "phrase": "latent_and_manifest_systems"}, {"score": 0.0021341390503944336, "phrase": "extended_translations"}], "paper_keywords": ["Languages", " Theory", " Contract", " refinement type", " dynamic checking", " blame", " precondition", " postcondition", " translation"], "paper_abstract": "Since Findler and Felleisen [2002] introduced higher-order contracts, many variants have been proposed. Broadly, these fall into two groups: some follow Findler and Felleisen in using latent contracts, purely dynamic checks that are transparent to the type system; others use manifest contracts, where refinement types record the most recent check that has been applied to each value. These two approaches are commonly assumed to be equivalent-different ways of implementing the same idea, one retaining a simple type system, and the other providing more static information. Our goal is to formalize and clarify this folklore understanding. Our work extends that of Gronski and Flanagan [2007], who defined a latent calculus lambda(C) and a manifest calculus lambda(H), gave a translation phi from lambda(C) to lambda(H), and proved that, if a lambda(C) term reduces to a constant, then so does its phi-image. We enrich their account with a translation psi from lambda(H) to lambda(C) and prove an analogous theorem. We then generalize the whole framework to dependent contracts, whose predicates can mention free variables. This extension is both pragmatically crucial, supporting a much more interesting range of contracts, and theoretically challenging. We define dependent versions of lambda(H) and two dialects (\"lax\" and \"picky\") of lambda(C), establish type soundness-a substantial result in itself, for lambda(H) and extend phi and psi accordingly. Surprisingly, the intuition that the latent and manifest systems are equivalent now breaks down: the extended translations preserve behavior in one direction but, in the other, sometimes yield terms that blame more.", "paper_title": "Contracts Made Manifest", "paper_id": "WOS:000274028100031"}