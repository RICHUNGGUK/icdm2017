{"auto_keywords": [{"score": 0.04027212582087888, "phrase": "right_arrow"}, {"score": 0.007740489563401459, "phrase": "heap_structures"}, {"score": 0.007515245798135249, "phrase": "strand"}, {"score": 0.005702714267207081, "phrase": "mso"}, {"score": 0.005572911743886919, "phrase": "structural_constraints"}, {"score": 0.004705278218845159, "phrase": "new_logic"}, {"score": 0.00458297991625839, "phrase": "heap-manipulating_programs"}, {"score": 0.004508174392347317, "phrase": "smt"}, {"score": 0.00401736307274363, "phrase": "mso-defined_relations"}, {"score": 0.0035680320746705064, "phrase": "monadic_second-order_logic"}, {"score": 0.0034981720122414153, "phrase": "additional_quantification"}, {"score": 0.003158367829177805, "phrase": "salient_aspects"}, {"score": 0.0030059656149799122, "phrase": "existential_and_universal_quantification"}, {"score": 0.00294707794932759, "phrase": "complex_combinations"}, {"score": 0.002832731124016696, "phrase": "linear_blocks"}, {"score": 0.0027498840401059418, "phrase": "boolean_combinations"}, {"score": 0.0027318042427022953, "phrase": "existential_and_universal_strand_formulas"}, {"score": 0.0026782730431380913, "phrase": "strand_formula"}, {"score": 0.0026171408377811687, "phrase": "powerful_decidable_fragments"}, {"score": 0.0024990202385797252, "phrase": "decision_procedure"}, {"score": 0.002402016201299179, "phrase": "quantifier-free_theory"}, {"score": 0.002378357925871225, "phrase": "underlying_data-logic"}, {"score": 0.002278496007505835, "phrase": "verification_conditions"}, {"score": 0.002175626278359828, "phrase": "mso_decision_procedure"}, {"score": 0.0021189380172266454, "phrase": "smt_solver"}, {"score": 0.0021049977753042253, "phrase": "integer_constraints"}], "paper_keywords": ["heap analysis", " SMT solvers", " monadic second-order logic", " combining decision procedures", " automata", " decidability"], "paper_abstract": "We define a new logic, STRAND, that allows reasoning with heap-manipulating programs using deductive verification and SMT solvers. STRAND logic (\"STRucture ANd Data\" logic) formulas express constraints involving heap structures and the data they contain; they are defined over a class of pointer-structures R defined using MSO-defined relations over trees, and are of the form. there exists(x) over right arrow for all(y) over right arrow phi((x) over right arrow, (y) over right arrow), where phi is a monadic second-order logic (MSO) formula with additional quantification that combines structural constraints as well as data-constraints, but where the data-constraints are only allowed to refer to (x) over right arrow and (y) over right arrow. The salient aspects of the logic are: (a) the logic is powerful, allowing existential and universal quantification over the nodes, and complex combinations of data and structural constraints; (b) checking Hoare-triples for linear blocks of statements with preconditions and post-conditions expressed as Boolean combinations of existential and universal STRAND formulas reduces to satisfiability of a STRAND formula; (c) there are powerful decidable fragments of STRAND, one semantically defined and one syntactically defined, where the decision procedure works by combining the theory of MSO over trees and the quantifier-free theory of the underlying data-logic. We demonstrate the effectiveness and practicality of the logic by checking verification conditions generated in proving properties of several heap-manipulating programs, using a tool that combines an MSO decision procedure over trees (MONA) with an SMT solver for integer constraints (Z3).", "paper_title": "Decidable Logics Combining Heap Structures and Data", "paper_id": "WOS:000286472700051"}