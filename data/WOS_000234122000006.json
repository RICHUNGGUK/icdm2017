{"auto_keywords": [{"score": 0.03887217598190441, "phrase": "yama"}, {"score": 0.010507885193128967, "phrase": "multiprocessor_systems"}, {"score": 0.00780532533419071, "phrase": "on-the-fly_deferred_reference_counting"}, {"score": 0.00703268184016045, "phrase": "old_generation"}, {"score": 0.004815038915936654, "phrase": "java"}, {"score": 0.004696608876994947, "phrase": "current_state-of-the-art_generational_garbage_collector"}, {"score": 0.004490842671590769, "phrase": "young_and_old_generation_garbage_collection"}, {"score": 0.004358676214574977, "phrase": "program_threads"}, {"score": 0.004209369306023422, "phrase": "garbage_collection"}, {"score": 0.0037913267098534887, "phrase": "pause_time"}, {"score": 0.0037350832473790007, "phrase": "on-the-fly_generational_garbage_collector"}, {"score": 0.0033639840192975835, "phrase": "leroy_gonthier"}, {"score": 0.0032324864013225166, "phrase": "sweep_garbage_collector"}, {"score": 0.0029111767710750117, "phrase": "young_generation"}, {"score": 0.002769568481822277, "phrase": "adaptive_tenuring_policy"}, {"score": 0.0027284410545226306, "phrase": "object_reference_count"}, {"score": 0.002701361707441567, "phrase": "survival_rate"}, {"score": 0.0025571463140118805, "phrase": "ibm_jikes_rvm"}, {"score": 0.002408565679880478, "phrase": "experimental_results"}, {"score": 0.0023846534541336326, "phrase": "standard_benchmark_programs"}, {"score": 0.0022799458141165587, "phrase": "extremely_low_pause_time"}, {"score": 0.002168975681697056, "phrase": "pause_time_reduction"}, {"score": 0.002136747803494932, "phrase": "better_response_times"}, {"score": 0.0021049977753042253, "phrase": "user_programs"}], "paper_keywords": ["garbage collection", " memory management", " Java", " programming languages", " Java virtual machine", " on-the-fly garbage collection"], "paper_abstract": "The current state-of-the-art generational garbage collector pauses all the program threads when it performs young and old generation garbage collection. As the number of program threads increases, the delay due to garbage collection also increases, thus restricting the scalability of the collector. In order to improve the scalability and reduce the pause time, an on-the-fly generational garbage collector called Yama is proposed for multiprocessor systems. This uses the on-the-fly deferred reference counting in the young generation and the DLG (Doligez Leroy Gonthier) on-the-fly mark and sweep garbage collector in the old generation. We have proposed and experimented with two novel variations of the on-the-fly deferred reference counting called Chitragupt1 and Chitragupt2 in the young generation. Yama does not pause all the application threads simultaneously. An adaptive tenuring policy based on object reference count and survival rate is also proposed. Yama has been implemented in the IBM Jikes RVM (Research Virtual Machine). The above claims are supported with experimental results for standard benchmark programs. The results show that Yama has an extremely low pause time in both the young and the old generation. The pause time reduction results in better response times for the user programs.", "paper_title": "Yama: A scalable generational garbage collector for Java in multiprocessor systems", "paper_id": "WOS:000234122000006"}