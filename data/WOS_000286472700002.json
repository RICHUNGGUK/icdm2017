{"auto_keywords": [{"score": 0.04107868567004354, "phrase": "strong_updates"}, {"score": 0.008911448812091738, "phrase": "flow-sensitive_analysis"}, {"score": 0.00481495049065317, "phrase": "efficient_strong_updates"}, {"score": 0.004668059458774745, "phrase": "sweet_spot"}, {"score": 0.004620093797504386, "phrase": "flow-insensitive_and_flow-sensitive_subset-based_points"}, {"score": 0.004231699728933577, "phrase": "million-line_programs"}, {"score": 0.004188198923320451, "phrase": "even_its_worst-case_requirements"}, {"score": 0.004081385289516914, "phrase": "cubic_time"}, {"score": 0.0033883824438527316, "phrase": "\"strong_update\"_analysis"}, {"score": 0.003234299589505403, "phrase": "flow-insensitive_analysis"}, {"score": 0.002977419551510206, "phrase": "key_enabling_insight"}, {"score": 0.0028567126120064546, "phrase": "dereferenced_points"}, {"score": 0.0027126684113045756, "phrase": "singleton_set"}, {"score": 0.00257586859792573, "phrase": "flow_sensitivity"}, {"score": 0.0025493457404304446, "phrase": "singleton_sets"}, {"score": 0.0025230952890994236, "phrase": "larger_sets"}, {"score": 0.0021714122348552747, "phrase": "standard_flow-insensitive_points"}, {"score": 0.0021049977753042253, "phrase": "llvm_compiler_infrastructure"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Languages", " Performance", " Verification", " points-to analysis", " flow sensitivity", " strong updates", " Andersen's analysis", " LLVM"], "paper_abstract": "This paper explores a sweet spot between flow-insensitive and flow-sensitive subset-based points-to analysis. Flow-insensitive analysis is efficient: it has been applied to million-line programs and even its worst-case requirements are quadratic space and cubic time. Flow-sensitive analysis is precise because it allows strong updates, so that points-to relationships holding in one program location can be removed from the analysis when they no longer hold in other locations. We propose a \"Strong Update\" analysis combining both features: it is efficient like flow-insensitive analysis, with the same worst-case bounds, yet its precision benefits from strong updates like flow-sensitive analysis. The key enabling insight is that strong updates are applicable when the dereferenced points-to set is a singleton, and a singleton set is cheap to analyze. The analysis therefore focuses flow sensitivity on singleton sets. Larger sets, which will not lead to strong updates, are modelled flow insensitively to maintain efficiency. We have implemented and evaluated the analysis as an extension of the standard flow-insensitive points-to analysis in the LLVM compiler infrastructure.", "paper_title": "Points-To Analysis with Efficient Strong Updates", "paper_id": "WOS:000286472700002"}