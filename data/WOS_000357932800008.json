{"auto_keywords": [{"score": 0.024259419201556918, "phrase": "logspace"}, {"score": 0.00481495049065317, "phrase": "computational_complexity_writing_polymorphic_functions"}, {"score": 0.004306205029641728, "phrase": "finite_number"}, {"score": 0.004211069233133584, "phrase": "canonical_elements"}, {"score": 0.0030451958332949735, "phrase": "different_levels"}, {"score": 0.0028795712616923462, "phrase": "higher-order_primitive_recursive_functions"}, {"score": 0.002574788013427524, "phrase": "finite_structures"}, {"score": 0.0024620842899061614, "phrase": "basic_complexity_classes"}], "paper_keywords": ["Theory", " Finite types", " System T", " higher-order primitive recursion", " complexity classes", " memoization"], "paper_abstract": "We address computational complexity writing polymorphic functions between finite types (i.e., types with a finite number of canonical elements), expressing costs in terms of the cardinality of these types. This allows us to rediscover, in a more syntactical setting, the known result that the different levels in the hierarchy of higher-order primitive recursive functions (Godel system T), when interpreted over finite structures, precisely capture basic complexity classes: functions of rank 1 characterize LOGSPACE, rank 2 PTIME, rank 3 PSPACE, rank 4 EXPTIME = DTIME(2(poly)), and so on.", "paper_title": "Computational Complexity Via Finite Types", "paper_id": "WOS:000357932800008"}