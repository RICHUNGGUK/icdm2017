{"auto_keywords": [{"score": 0.05004027943006041, "phrase": "huffman"}, {"score": 0.03446532675674728, "phrase": "cost_functions"}, {"score": 0.023808348905144973, "phrase": "np"}, {"score": 0.022860800219209144, "phrase": "leaf_costs"}, {"score": 0.004709567162738894, "phrase": "general_cost_functions"}, {"score": 0.004640590144749795, "phrase": "generalized_versions"}, {"score": 0.004406994912939125, "phrase": "individual_leaf"}, {"score": 0.004154332348800334, "phrase": "arbitrary_function"}, {"score": 0.004003798249233137, "phrase": "maximum_cost"}, {"score": 0.003858697684681798, "phrase": "known_results"}, {"score": 0.0037325918533747953, "phrase": "new_algorithms"}, {"score": 0.003705130724701598, "phrase": "hardness_proofs"}, {"score": 0.0036105923401756126, "phrase": "dynamic_programming_approach"}, {"score": 0.0035708152831417104, "phrase": "alphabetic_tree_problem"}, {"score": 0.0035054881943660096, "phrase": "arbitrary_cost_functions"}, {"score": 0.0032319109979344184, "phrase": "well-known_trick"}, {"score": 0.003091767402370757, "phrase": "\"monotonicity\"_property"}, {"score": 0.003012831982759529, "phrase": "generalized_huffman_tree_problem"}, {"score": 0.0029686314779877525, "phrase": "even_the_k-ary_version"}, {"score": 0.002903540062437197, "phrase": "generalized_version"}, {"score": 0.0028715299874549245, "phrase": "coin_collector_algorithm"}, {"score": 0.0028293982895615734, "phrase": "hirschberg"}, {"score": 0.002798388104216128, "phrase": "proc"}, {"score": 0.0024860616730750158, "phrase": "worst_case"}, {"score": 0.0024768883044869023, "phrase": "minimization_variants"}, {"score": 0.002404706573379854, "phrase": "nondecreasing_cost_functions"}, {"score": 0.0023519508354777215, "phrase": "computational_tractability"}, {"score": 0.0023003498123420237, "phrase": "huffman_tree_problem"}, {"score": 0.0021842976754894846, "phrase": "objective_function"}, {"score": 0.0021049977753042253, "phrase": "alphabetic_version"}], "paper_keywords": ["Optimal tree", " Binary tree", " Multi-ary tree", " Dynamic programming", " Huffman coding", " Alphabetic tree"], "paper_abstract": "We address generalized versions of the Huffman and Alphabetic Tree Problem where the cost caused by each individual leaf i, instead of being linear, depends on its depth in the tree by an arbitrary function. The objective is to minimize either the total cost or the maximum cost among all leaves. We review and extend the known results in this direction and devise a number of new algorithms and hardness proofs. It turns out that the Dynamic Programming approach for the Alphabetic Tree Problem can be extended to arbitrary cost functions, resulting in a time O(n (4)) optimal algorithm using space O(n (3)). We identify classes of cost functions where the well-known trick to reduce the runtime by a factor of n via a \"monotonicity\" property can be applied. For the generalized Huffman Tree Problem we show that even the k-ary version can be solved by a generalized version of the Coin Collector Algorithm of Larmore and Hirschberg (in Proc. SODA'90, pp. 310-318, 1990) when the cost functions are nondecreasing and convex. Furthermore, we give an O(n (2)logn) algorithm for the worst case minimization variants of both the Huffman and Alphabetic Tree Problem with nondecreasing cost functions. Investigating the limits of computational tractability, we show that the Huffman Tree Problem in its full generality is inapproximable unless P = NP, no matter if the objective function is the sum of leaf costs or their maximum. The alphabetic version becomes NP-hard when the leaf costs are interdependent.", "paper_title": "On the Huffman and Alphabetic Tree Problem with General Cost Functions", "paper_id": "WOS:000335752000005"}