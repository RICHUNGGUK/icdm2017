{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "scale_vector-thread_processor"}, {"score": 0.004481132747216135, "phrase": "complexity-effective_solution"}, {"score": 0.003975200317233532, "phrase": "highly_multithreaded_processing"}, {"score": 0.0032036590920314725, "phrase": "automated_and_iterative_design"}, {"score": 0.0028076592725295646, "phrase": "area-efficient_implementation"}, {"score": 0.0024901940672239784, "phrase": "core_area"}], "paper_keywords": ["design", " verification", " vector processors", " multithreaded processors", " vector-thread processors", " iterative VLSI design flow", " hybrid C plus plus /Verilog simulation", " procedural datapath preplacement"], "paper_abstract": "The Scale vector-thread processor is a complexity-effective solution for embedded computing which flexibly supports both vector and highly multithreaded processing. The 7.1-million transistor chip has 16 decoupled execution clusters, vector load and store units, and a nonblocking 32KB cache. An automated and iterative design and verification flow enabled a performance-, power-, and area-efficient implementation with two person-years of development effort. Scale has a core area of 16.6mm(2) in 180nm technology, and it consumes 400 mW - 1.1 W while running at 260 MHz.", "paper_title": "Implementing the scale vector-thread processor", "paper_id": "WOS:000258205900005"}