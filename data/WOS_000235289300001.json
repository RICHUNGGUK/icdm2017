{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java"}, {"score": 0.004624751696958501, "phrase": "multiprocessor_systems"}, {"score": 0.0045324756541157574, "phrase": "conventional_wisdom"}, {"score": 0.004419703921314433, "phrase": "reference_slots"}, {"score": 0.004331501320993783, "phrase": "atomic_or_synchronized_operations"}, {"score": 0.004016072233242585, "phrase": "novel_reference-counting_algorithm"}, {"score": 0.003935892934907777, "phrase": "multiprocessor_system"}, {"score": 0.0038186039088445524, "phrase": "synchronized_operation"}, {"score": 0.003487222504700868, "phrase": "second_novelty"}, {"score": 0.0033156708990372047, "phrase": "large_fraction"}, {"score": 0.0032658649336454923, "phrase": "reference-count_updates"}, {"score": 0.003152531962718477, "phrase": "reference-counting_traditional_overhead"}, {"score": 0.003058515297281172, "phrase": "full_proof"}, {"score": 0.0028642924503126154, "phrase": "live_objects"}, {"score": 0.002750934994181092, "phrase": "unreachable_objects"}, {"score": 0.0026420518944303716, "phrase": "sun_microsystems'_java_virtual_machine"}, {"score": 0.0024247382451294255, "phrase": "physical_memory"}, {"score": 0.0023170054862555896, "phrase": "extremely_low_latency"}, {"score": 0.0021479597698614373, "phrase": "sweep_algorithm"}, {"score": 0.0021049977753042253, "phrase": "original_jvm."}], "paper_keywords": ["languages", " algorithms", " programming languages", " memory management", " garbage collection", " reference-counting"], "paper_abstract": "Reference-counting is traditionally considered unsuitable for multiprocessor systems. According to conventional wisdom, the update of reference slots and reference-counts requires atomic or synchronized operations. In this work we demonstrate this is not the case by presenting a novel reference-counting algorithm suitable for a multiprocessor system that does not require any synchronized operation in its write barrier (not even a compare-and-swap type of synchronization). A second novelty of this algorithm is that it allows eliminating a large fraction of the reference-count updates, thus, drastically reducing the reference-counting traditional overhead. This article includes a full proof of the algorithm showing that it is safe (does not reclaim live objects) and live (eventually reclaims all unreachable objects). We have implemented our algorithm on Sun Microsystems' Java Virtual Machine (JVM) 1.2.2 and ran it on a four-way IBM Netfinity 8500R server with 550-MHz Intel Pentium III Xeon and 2 GB of physical memory. Our results show that the algorithm has an extremely low latency and throughput that is comparable to the stop-the-world mark and sweep algorithm used in the original JVM.", "paper_title": "An on-the-fly reference-counting garbage collector for Java", "paper_id": "WOS:000235289300001"}