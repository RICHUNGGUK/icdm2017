{"auto_keywords": [{"score": 0.03641415674406895, "phrase": "ldpc_codes"}, {"score": 0.015719716506582538, "phrase": "small_error-prone_substructures"}, {"score": 0.010084209624651992, "phrase": "proposed_algorithm"}, {"score": 0.008868364113661391, "phrase": "error_floor"}, {"score": 0.004534350070044418, "phrase": "np"}, {"score": 0.004141575435071002, "phrase": "binary_erasure_channels"}, {"score": 0.004001335931796133, "phrase": "general_memoryless_symmetric_channels"}, {"score": 0.003933000051147382, "phrase": "provable_hardness"}, {"score": 0.0037834649508375544, "phrase": "exhaustive_enumeration_algorithm"}, {"score": 0.003623949225126944, "phrase": "practical_short_lengths"}, {"score": 0.003486123304074186, "phrase": "sparse_connectivity"}, {"score": 0.0034118234596993836, "phrase": "stopping_sets"}, {"score": 0.0031166151196841308, "phrase": "central_theorem"}, {"score": 0.003037047249598515, "phrase": "new_provably_tight_upper_bound"}, {"score": 0.00295950473406239, "phrase": "iterative_decoding"}, {"score": 0.0028715299874549245, "phrase": "tree-pruning_technique"}, {"score": 0.0028346293790895024, "phrase": "upper_bound"}, {"score": 0.0026116610153271943, "phrase": "existing_non-exhaustive_ones"}, {"score": 0.002555950807368337, "phrase": "lower_bounds"}, {"score": 0.002437525632451029, "phrase": "worst_case_performance_guarantee"}, {"score": 0.0023447155524245655, "phrase": "target_error_rate"}, {"score": 0.0022848092812445533, "phrase": "monte_carlo_simulation"}, {"score": 0.0022651818270925704, "phrase": "numerical_experiments"}, {"score": 0.0021416404045850224, "phrase": "search_algorithm"}, {"score": 0.0021049977753042253, "phrase": "finite-length_code_optimization"}], "paper_keywords": ["Branch-and-bound", " error floors", " exhaustive search", " low-density parity-check (LDPC) codes", " stopping distance", " stopping/trapping sets", " support trees"], "paper_abstract": "It is proven in this work that it is NP-complete to exhaustively enumerate small error-prone substructures in arbitrary, finite-length low-density parity-check (LDPC) codes. Two error-prone patterns of interest include stopping sets for binary erasure channels (BECs) and trapping sets for general memoryless symmetric channels. Despite the provable hardness of the problem, this work provides an exhaustive enumeration algorithm that is computationally affordable when applied to codes of practical short lengths n approximate to 500. By exploiting the sparse connectivity of LDPC codes, the stopping sets of size <= 13 and the trapping sets of size <= 11 can be exhaustively enumerated. The central theorem behind the proposed algorithm is a new provably tight upper bound on the error rates of iterative decoding over BECs. Based on a tree-pruning technique, this upper bound can be iteratively sharpened until its asymptotic order equals that of the error floor. This feature distinguishes the proposed algorithm from existing non-exhaustive ones that correspond to finding lower bounds of the error floor. The upper bound also provides a worst case performance guarantee that is crucial to optimizing LDPC codes when the target error rate is beyond the reach of Monte Carlo simulation. Numerical experiments on both randomly and algebraically constructed LDPC codes demonstrate the efficiency of the search algorithm and its significant value for finite-length code optimization.", "paper_title": "Finding All Small Error-Prone Substructures in LDPC Codes", "paper_id": "WOS:000265713000004"}