{"auto_keywords": [{"score": 0.03734631623252398, "phrase": "droit"}, {"score": 0.019179235714196434, "phrase": "instruction-level_tracking"}, {"score": 0.009658241542907467, "phrase": "java_object_level"}, {"score": 0.008253237879017642, "phrase": "semantic_reconstruction"}, {"score": 0.00481495049065317, "phrase": "dynamic_alternation"}, {"score": 0.004764542405129454, "phrase": "dual-level_tainting_for_malware_analysis"}, {"score": 0.004640808212832262, "phrase": "android_malware"}, {"score": 0.004520272777451894, "phrase": "recent_research"}, {"score": 0.004472935829694716, "phrase": "existing_taint_techniques"}, {"score": 0.004311109608629196, "phrase": "deeper_instruction_level"}, {"score": 0.004265953661191515, "phrase": "object-level_tracking"}, {"score": 0.004111584914709491, "phrase": "java_byte-code"}, {"score": 0.0040047396607954325, "phrase": "native_ones"}, {"score": 0.0039006600544599537, "phrase": "finest_data_flow"}, {"score": 0.0037005154613244363, "phrase": "low_performance"}, {"score": 0.0032437952431945724, "phrase": "data_flow"}, {"score": 0.0031098631445657158, "phrase": "dalvik_vm"}, {"score": 0.003061072337623773, "phrase": "byte-code_execution"}, {"score": 0.002858313353461727, "phrase": "trigger-based_droit"}, {"score": 0.002740253546178098, "phrase": "efficient_manner"}, {"score": 0.0026689487424251907, "phrase": "dual-level_whole_image"}, {"score": 0.002492098272172066, "phrase": "dual_levels"}, {"score": 0.0023640560785711923, "phrase": "android_information-stealing_trojans"}, {"score": 0.0022904032758108775, "phrase": "java-based_malware"}, {"score": 0.0022307779508260205, "phrase": "native_code"}, {"score": 0.0021049977753042253, "phrase": "droidkungfu"}], "paper_keywords": ["mobile security", " malware analysis", " taint analysis", " information flow tracking", " binary translation", " Android operating system", " Dalvik virtual machine"], "paper_abstract": "Taint analysis for Android malware has received much attention in recent research. Existing taint techniques operate either at Java object level or at deeper instruction level. Object-level tracking is suitable for malware written in Java byte-code, but not for native ones. Instruction-level tracking captures the finest data flow. However, it leads to obscure semantic reconstruction and low performance. In this paper, we present DROIT, a taint tracker which dynamically alternates between object-level and instruction-level tracking on demands. DROIT tracks data flow at Java object level in general. When its Dalvik VM exits the byte-code execution, DROIT automatically switches to instruction-level tracking, and vice versa. The trigger-based DROIT can alternate between the two levels in an efficient manner, and can provide dual-level whole image of the data flow, rather than fragments. Tracking at the dual levels also eases the semantic reconstruction significantly. The experiment with Android information-stealing trojans showed that DROIT can handle Java-based malware, those composed in native code, and those alternating between the two levels (e.g., DroidKungFu), respectively.", "paper_title": "DROIT: Dynamic Alternation of Dual-Level Tainting for Malware Analysis", "paper_id": "WOS:000348091300006"}