{"auto_keywords": [{"score": 0.04331790253451432, "phrase": "output_code"}, {"score": 0.041725522589024386, "phrase": "register_allocator"}, {"score": 0.02322730111336099, "phrase": "register_allocation"}, {"score": 0.00751908741633109, "phrase": "value_flow"}, {"score": 0.00457138247462329, "phrase": "register_allocation_algorithms"}, {"score": 0.004340081802944066, "phrase": "target_machine_architectures"}, {"score": 0.004192392802008709, "phrase": "register_allocation_errors"}, {"score": 0.0038613835226952117, "phrase": "incorrect_output_code"}, {"score": 0.003697760799674494, "phrase": "test_data"}, {"score": 0.0034953361767153285, "phrase": "novel_data_flow_analyses"}, {"score": 0.0030166226457616616, "phrase": "error_locations"}, {"score": 0.002718627370925435, "phrase": "different_register_allocators"}, {"score": 0.0025364615261136655, "phrase": "sarac"}, {"score": 0.0022857899334246946, "phrase": "average_compile-time_overhead"}, {"score": 0.002236762786982225, "phrase": "modest_average_memory_overhead"}, {"score": 0.0021604924928015283, "phrase": "compiler_developers"}, {"score": 0.0021418339161425994, "phrase": "regression_testing"}, {"score": 0.0021049977753042253, "phrase": "command-line-enabled_debugging_pass"}], "paper_keywords": ["Languages", " Verification", " Register allocation"], "paper_abstract": "Although register allocation is critical for performance, the implementation of register allocation algorithms is difficult, due to the complexity of the algorithms and target machine architectures. It is particularly difficult to detect register allocation errors if the output code runs to completion, as bugs in the register allocator can cause the compiler to produce incorrect output code. The output code may even execute properly on some test data, but errors can remain. In this article, we propose novel data flow analyses to statically check that the value flow of the output code from the register allocator is the same as the value flow of its input code. The approach is accurate, fast, and can identify and report error locations and types. It is independent of the register allocator and uses only the input and output code of the register allocator. It can be used with different register allocators, including those that perform coalescing and rematerialization. The article describes our approach, called SARAC, and a tool that statically checks a register allocation and reports the errors and their types that it finds. The tool has an average compile-time overhead of only 8% and a modest average memory overhead of 85KB. Our techniques can be used by compiler developers during regression testing and as a command-line-enabled debugging pass for mysterious compiler behavior.", "paper_title": "Detecting Bugs in Register Allocation", "paper_id": "WOS:000277057700006"}