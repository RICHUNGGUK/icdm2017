{"auto_keywords": [{"score": 0.047815989577591644, "phrase": "embedded_systems"}, {"score": 0.03941780642037305, "phrase": "aotc"}, {"score": 0.03400555046881372, "phrase": "normal_execution_paths"}, {"score": 0.004815215771351813, "phrase": "java"}, {"score": 0.0044695432851061525, "phrase": "java_acceleration"}, {"score": 0.004242546312843817, "phrase": "time_compiler"}, {"score": 0.004072275820209647, "phrase": "java_virtual_machine"}, {"score": 0.00395273370234774, "phrase": "c_code"}, {"score": 0.0038510053729959074, "phrase": "machine_code"}, {"score": 0.003808209866576388, "phrase": "existing_c_compiler"}, {"score": 0.003601235776892337, "phrase": "exception_handier"}, {"score": 0.0035479614996805383, "phrase": "different_methods"}, {"score": 0.003508521802236789, "phrase": "call_stack"}, {"score": 0.0034824716857663114, "phrase": "control_transfer"}, {"score": 0.0033177813460815346, "phrase": "\"exceptional\"_event"}, {"score": 0.0031963987773420068, "phrase": "previous_aotcs"}, {"score": 0.0025556529150386168, "phrase": "simpler_solution"}, {"score": 0.0025178072071268534, "phrase": "exception_check"}, {"score": 0.0024897902536499005, "phrase": "method_call"}, {"score": 0.0024529174827030787, "phrase": "garbage_collection_check"}, {"score": 0.002363101338529545, "phrase": "sun's_cvm"}, {"score": 0.002285075675790214, "phrase": "stack_cutting"}, {"score": 0.0022428442879034614, "phrase": "similar_performance_benefit"}, {"score": 0.002193193339812606, "phrase": "hybrid_execution_environment"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["bytecode-to-C", " Java ahead-of-time compiler", " exception handling", " stack cutting", " Java virtual machine", " J2ME CDC"], "paper_abstract": "One of the most promising approaches to Java acceleration in embedded systems is a bytecode-to-C ahead-of-time compiler (AOTC). It improves the performance of a Java virtual machine (JVM) by translating bytecode into C code, which is then compiled into machine code via an existing C compiler. One important design issue in AOTC is efficient exception handling. Since the excepting point and the exception handier may locate in different methods on a call stack, control transfer between them should be streamlined, while an exception would be an \"exceptional\" event, so it should not slow down normal execution paths. Previous AOTCs often employed a technique called stack cutting based on a setjmp()/Iongjmp() pair, which we found is involved with too much performance overheads. Also, when the AOTC and the interpreter are employed concurrently (e.g., some methods are AOTCed while other methods are interpreted), the performance of normal execution paths is affected more seriously. This paper proposes a simpler solution based on an exception check after each method call, merged with garbage collection check for reducing its overhead. Our evaluation results on SPECjvm98 on Sun's CVM indicate that our technique can improve the performance of stack cutting by more than 25%. A similar performance benefit can be noted on a hybrid execution environment of both the AOTC and the interpreter. (C) 2007 Elsevier Ltd. All rights reserved.", "paper_title": "Efficient exception handling in Java bytecode-to-C ahead-of-time compiler for embedded systems", "paper_id": "WOS:000255262500003"}