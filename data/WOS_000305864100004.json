{"auto_keywords": [{"score": 0.0431953531151574, "phrase": "processor_extensions"}, {"score": 0.015719716506582538, "phrase": "constraint_programming_approach"}, {"score": 0.004771435352180973, "phrase": "reconfigurable_processor_extension_generation"}, {"score": 0.004457309741979921, "phrase": "hard_design_problems"}, {"score": 0.004357245559948974, "phrase": "specialized_processor_extensions"}, {"score": 0.004201774694043468, "phrase": "automatic_selection"}, {"score": 0.004051828608343507, "phrase": "efficient_application_compilation"}, {"score": 0.003996983218174335, "phrase": "newly_generated_extensions"}, {"score": 0.003942877273973905, "phrase": "discussed_approach"}, {"score": 0.0038368442918503072, "phrase": "ifpec"}, {"score": 0.003767738552860633, "phrase": "constraint_programming"}, {"score": 0.0036332251283046997, "phrase": "custom_instructions"}, {"score": 0.0034876091188625535, "phrase": "computational_patterns"}, {"score": 0.0033175095965171674, "phrase": "graph_representation"}, {"score": 0.0031271133933467575, "phrase": "subgraph_isomorphism"}, {"score": 0.0030988045934942587, "phrase": "connected_component_constraints"}, {"score": 0.0029610472910087176, "phrase": "application_scheduling"}, {"score": 0.002855251306715901, "phrase": "design_steps"}, {"score": 0.0027910516355928983, "phrase": "runtime_reconfigurable_cells"}, {"score": 0.002753224894944965, "phrase": "selected_extensions"}, {"score": 0.002548331088496964, "phrase": "different_heterogeneous_constraints"}, {"score": 0.0023802126605244438, "phrase": "cp_framework"}, {"score": 0.002316105585203396, "phrase": "simultaneously_extension_selection"}, {"score": 0.0021830553825770097, "phrase": "generated_results"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": ["Design", " Experimentation", " Reconfigurable architectures", " resource assignment", " scheduling", " system-level synthesis", " constraint programming"], "paper_abstract": "In this article, we present a constraint programming approach for solving hard design problems present when automatically designing specialized processor extensions. Specifically, we discuss our approach for automatic selection and synthesis of processor extensions as well as efficient application compilation for these newly generated extensions. The discussed approach is implemented in our integrated design framework, IFPEC, built using Constraint Programming (CP). In our framework, custom instructions, implemented as processor extensions, are defined as computational patterns and represented as graphs. This, along with the graph representation of an application, provides a way to use our CP framework equipped with subgraph isomorphism and connected component constraints for identification of processor extensions as well as their selection, application scheduling, binding, and routing. All design steps assume architectures composed of runtime reconfigurable cells, implementing selected extensions, tightly connected to a processor. An advantage of our approach is the possibility of combining different heterogeneous constraints to represent and solve all our design problems. Moreover, the flexibility and expressiveness of the CP framework makes it possible to solve simultaneously extension selection, application scheduling, and binding and improve the quality of the generated results. The article is largely illustrated with experimental results.", "paper_title": "Constraint Programming Approach to Reconfigurable Processor Extension Generation and Application Compilation", "paper_id": "WOS:000305864100004"}