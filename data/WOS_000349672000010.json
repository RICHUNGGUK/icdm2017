{"auto_keywords": [{"score": 0.04957466661795797, "phrase": "multi-core_systems"}, {"score": 0.04665103656723687, "phrase": "lazy_ibuddy_system"}, {"score": 0.004639712384096822, "phrase": "new_buddy_system"}, {"score": 0.004590820632326585, "phrase": "memory_allocation"}, {"score": 0.004240116703465252, "phrase": "widely_used_lazy_buddy_system"}, {"score": 0.004042635935882651, "phrase": "single_page_frames"}, {"score": 0.0039369107163201855, "phrase": "lazy_buddy_algorithm"}, {"score": 0.003874846042870413, "phrase": "linux"}, {"score": 0.003773449694108617, "phrase": "memory_blocks"}, {"score": 0.0037336520904376687, "phrase": "single_page_frame_requests"}, {"score": 0.0036553070575015344, "phrase": "lazy_layer"}, {"score": 0.0034299649219748513, "phrase": "memory_requests"}, {"score": 0.0033579708256295847, "phrase": "lock_contention"}, {"score": 0.003304965389155549, "phrase": "concurrent_accesses"}, {"score": 0.003150900886669123, "phrase": "first_problem"}, {"score": 0.0030847461428168614, "phrase": "page_frame"}, {"score": 0.0029253546782349875, "phrase": "multiple_page_frames"}, {"score": 0.002818692837561076, "phrase": "lazy_ibuddy_algorithm"}, {"score": 0.0027741761880779535, "phrase": "single_page_frame_allocation"}, {"score": 0.0026447893350441502, "phrase": "second_problem"}, {"score": 0.002575526825728026, "phrase": "main_memory"}, {"score": 0.002548331088496964, "phrase": "multiple_buddy_spaces"}, {"score": 0.0024947959375982614, "phrase": "fine-grained_locking_mechanism"}, {"score": 0.0021387992835532367, "phrase": "lazy_buddy_system"}], "paper_keywords": ["Dynamic memory manager", " splitting and coalescing", " Buddy algorithm"], "paper_abstract": "We present a new buddy system for memory allocation that we call the lazy iBuddy system. This system is motivated by two observations of the widely used lazy buddy system on multi-core systems. First, most memory requests are for single page frames. However, the lazy buddy algorithm used in Linux continuously splits and coalesces memory blocks for single page frame requests even though the lazy layer is employed. Second, on multi-core systems, responses to bursty memory requests are delayed by lock contention caused by concurrent accesses of the multi-cores. The lazy iBuddy system overcomes the first problem by managing each page frame individually and coalescing pages only when an allocation of multiple page frames is requested. We devise the lazy iBuddy algorithm so that single page frame allocation can be done in O(1). The second problem is alleviated by dividing main memory into multiple buddy spaces and applying a fine-grained locking mechanism. Performance evaluation results based on various workloads on the XEON 16core with 32 GB main memory show that the lazy iBuddy system can improve memory allocation/deallocation time by up to 47 percent with an average of 35 percent compared with the lazy buddy system for the various configurations that we considered.", "paper_title": "iBuddy: Inverse Buddy for Enhancing Memory Allocation/Deallocation Performance on Multi-Core Systems", "paper_id": "WOS:000349672000010"}