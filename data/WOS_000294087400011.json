{"auto_keywords": [{"score": 0.028818583867887944, "phrase": "random_access"}, {"score": 0.00481495049065317, "phrase": "interpolative_coding"}, {"score": 0.004779085953614184, "phrase": "integer_sequences"}, {"score": 0.00474348728309194, "phrase": "log-time_random_access"}, {"score": 0.0046382670208947605, "phrase": "common_data_types"}, {"score": 0.004552360432689039, "phrase": "primary_data"}, {"score": 0.004518442937844318, "phrase": "ancillary_structures"}, {"score": 0.004256005669252138, "phrase": "effective_compression"}, {"score": 0.004224286804379592, "phrase": "variable-length_coding"}, {"score": 0.004146015717402716, "phrase": "regular_alignment"}, {"score": 0.0034001358540125303, "phrase": "special_feature"}, {"score": 0.003362163770566293, "phrase": "auxiliary_index"}, {"score": 0.0030502854924662837, "phrase": "address_calculation"}, {"score": 0.0030275252142439213, "phrase": "sufficient_space"}, {"score": 0.0029602552900111407, "phrase": "worst_case"}, {"score": 0.0029271812818615042, "phrase": "additional_redundancy"}, {"score": 0.002883655046524374, "phrase": "regular_interpolative_coding"}, {"score": 0.00276725708403607, "phrase": "uniform_distribution"}, {"score": 0.0027363334666886912, "phrase": "time_complexity"}, {"score": 0.00264561514767961, "phrase": "source_size"}, {"score": 0.0024546155360991567, "phrase": "full_decoding"}, {"score": 0.0024090550572099688, "phrase": "accessed_integers"}, {"score": 0.002320449502337321, "phrase": "sequence_length"}, {"score": 0.002193600680263771, "phrase": "random_access_coding"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Source coding", " Data compression", " Random access", " Interpolative coding", " Inverted index"], "paper_abstract": "Sequences of integers are common data types, occurring either as primary data or ancillary structures. The sizes of sequences can be large, making compression an interesting option. Effective compression presupposes variable-length coding, which destroys the regular alignment of values. Yet it would often be desirable to access only a small subset of the entries, either by position (ordinal number) or by content (element value), without having to decode most of the sequence from the start. Here such a random access technique for compressed integers is described, with the special feature that no auxiliary index is needed. The solution applies a method called interpolative coding, which is one of the most efficient non-statistical codes for integers. Indexing is avoided by address calculation guaranteeing sufficient space for codes even in the worst case. The additional redundancy, compared to regular interpolative coding, is only about 1 bit per source integer for uniform distribution. The time complexity of random access is logarithmic with respect to the source size for both position-based and content-based retrieval. According to experiments, random access is faster than full decoding when the number of accessed integers is not more than approximately 0.75. n/log(2)n for sequence length n. The tests also confirm that the method is quite competitive with other approaches to random access coding, suggested in the literature. (C) 2010 Elsevier Ltd. All rights reserved.", "paper_title": "Interpolative coding of integer sequences supporting log-time random access", "paper_id": "WOS:000294087400011"}