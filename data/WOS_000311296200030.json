{"auto_keywords": [{"score": 0.05007852962010534, "phrase": "symbolic_execution"}, {"score": 0.004776297980616768, "phrase": "ranged_analysis"}, {"score": 0.0046621835537196754, "phrase": "novel_approach"}, {"score": 0.004477992162329249, "phrase": "systematic_exploration"}, {"score": 0.004442032546224076, "phrase": "bounded_execution_paths"}, {"score": 0.004388631450145507, "phrase": "test_input_generation"}, {"score": 0.0041144374213500715, "phrase": "real_resurgence"}, {"score": 0.003999907278478564, "phrase": "systematic_bug_finding"}, {"score": 0.0038728990904778678, "phrase": "primary_technical_challenge"}, {"score": 0.003810909603178837, "phrase": "inherent_complexity"}, {"score": 0.003765067028482197, "phrase": "path-based_exploration"}, {"score": 0.003417565253539315, "phrase": "test_input"}, {"score": 0.0032428780373184207, "phrase": "symbolic_execution_run"}, {"score": 0.002628747284714371, "phrase": "sequential_setting"}, {"score": 0.002597088221737922, "phrase": "single_worker_node"}, {"score": 0.0025554669315362424, "phrase": "parallel_setting"}, {"score": 0.002534906456854208, "phrase": "multiple_workers"}, {"score": 0.002494279207996077, "phrase": "enabling_technology"}, {"score": 0.0024247382451294255, "phrase": "state-of-the-art_symbolic_execution_tool_klee._experimental_results"}, {"score": 0.0023381630439887184, "phrase": "gnu_coreutils"}, {"score": 0.0023099954987126, "phrase": "unix_utilities"}, {"score": 0.0022546720211200893, "phrase": "significant_speedup"}, {"score": 0.0021479597698614373, "phrase": "average_speed-up"}], "paper_keywords": ["Algorithms", " Performance", " Test input as analysis state", " ranged analysis", " parallel symbolic execution", " incremental analysis", " KLEE"], "paper_abstract": "This paper introduces a novel approach to scale symbolic execution-a program analysis technique for systematic exploration of bounded execution paths-for test input generation. While the foundations of symbolic execution were developed over three decades ago, recent years have seen a real resurgence of the technique, specifically for systematic bug finding. However, scaling symbolic execution remains a primary technical challenge due to the inherent complexity of the path-based exploration that lies at core of the technique. Our key insight is that the state of the analysis can be represented highly compactly: a test input is all that is needed to effectively encode the state of a symbolic execution run. We present ranged symbolic execution, which embodies this insight and uses two test inputs to define a range, i.e., the beginning and end, for a symbolic execution run. As an application of our approach, we show how it enables scalability by distributing the path exploration-both in a sequential setting with a single worker node and in a parallel setting with multiple workers. As an enabling technology, we leverage the open-source, state-of-the-art symbolic execution tool KLEE. Experimental results using 71 programs chosen from the widely deployed GNU Coreutils set of Unix utilities show that our approach provides a significant speedup over KLEE. For example, using 10 worker cores, we achieve an average speed-up of 6.6X for the 71 programs.", "paper_title": "Scaling Symbolic Execution using Ranged Analysis", "paper_id": "WOS:000311296200030"}