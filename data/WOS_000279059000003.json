{"auto_keywords": [{"score": 0.04618870497358489, "phrase": "embedded_systems"}, {"score": 0.00481495049065317, "phrase": "architectural_leakage_power_minimization_of_scratchpad_memories"}, {"score": 0.004778088905211055, "phrase": "application-driven_subbanking"}, {"score": 0.004669180816745142, "phrase": "multiple_blocks"}, {"score": 0.004527804152066942, "phrase": "widely_used_technique"}, {"score": 0.004176640648520877, "phrase": "memory_access_patterns"}, {"score": 0.0041287394089001405, "phrase": "leakage_energy"}, {"score": 0.0040190868373730015, "phrase": "idle_memory_blocks"}, {"score": 0.0039274105882136775, "phrase": "proper_low-leakage_sleep_state"}, {"score": 0.003636605792981828, "phrase": "power_management_problem"}, {"score": 0.0035263833746562788, "phrase": "sleep_state"}, {"score": 0.0034993519231560637, "phrase": "additional_energy"}, {"score": 0.0033802431627410223, "phrase": "effective_solution"}, {"score": 0.0033030907500120397, "phrase": "leakage-aware_partitioning"}, {"score": 0.003240139593712436, "phrase": "disjoint_subblocks"}, {"score": 0.003154012038613403, "phrase": "scratchpad_memories"}, {"score": 0.0029090845459992737, "phrase": "solution_space"}, {"score": 0.0026523079380037706, "phrase": "nontrivial_property"}, {"score": 0.0025817653186901175, "phrase": "partition_boundaries"}, {"score": 0.0023995846112991625, "phrase": "optimal_solution"}, {"score": 0.002372015603684862, "phrase": "leakage-aware_partitioning_problem"}, {"score": 0.002326767693352058, "phrase": "different_sets"}, {"score": 0.002308910575113746, "phrase": "embedded_applications"}, {"score": 0.002273605493468005, "phrase": "total_energy_savings"}, {"score": 0.0021876814398268775, "phrase": "marginal_overhead"}, {"score": 0.0021708894366462153, "phrase": "execution_time"}, {"score": 0.0021294699637639564, "phrase": "effective_implementation"}, {"score": 0.0021049977753042253, "phrase": "low-leakage_sleep_state"}], "paper_keywords": ["Power optimization", " leakage power", " embedded design", " memory hierarchy", " scratchpad memory", " partitioning algorithm"], "paper_abstract": "Partitioning a memory into multiple blocks that can be independently accessed is a widely used technique to reduce its dynamic power. For embedded systems, its benefits can be even pushed further by properly matching the partition to the memory access patterns. When leakage energy comes into play, however, idle memory blocks must be put into a proper low-leakage sleep state to actually save energy when not accessed. In this case, the matching becomes an instance of the power management problem, because moving to and from this sleep state requires additional energy. In this work, we propose an effective solution to the problem of the leakage-aware partitioning of a memory into disjoint subblocks; in particular, we target scratchpad memories, which are commonly used in some embedded systems as a replacement for caches. We show that, although the solution space is extremely large (for a N-block partition, all the combinations of N - 1 address boundaries) and nonconvex, it is possible to prove a nontrivial property that considerably reduces the number of partition boundaries to be enumerated, therefore, making exhaustive exploration feasible. We are thus able to provide an optimal solution to the leakage-aware partitioning problem. Experiments on a different sets of embedded applications have shown that total energy savings larger than 60 percent on average can be obtained, with a marginal overhead in execution time, thanks to an effective implementation of the low-leakage sleep state.", "paper_title": "Architectural Leakage Power Minimization of Scratchpad Memories by Application-Driven Subbanking", "paper_id": "WOS:000279059000003"}