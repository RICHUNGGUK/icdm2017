{"auto_keywords": [{"score": 0.03904989962163052, "phrase": "adaptive_progress"}, {"score": 0.00481495049065317, "phrase": "simple_liveness_property"}, {"score": 0.004747997855358171, "phrase": "shared_object_implementations"}, {"score": 0.0040133278382101885, "phrase": "gradual_bridge"}, {"score": 0.003848088904418221, "phrase": "partially-synchronous_systems"}, {"score": 0.003096417317829492, "phrase": "safe_registers"}, {"score": 0.0028464607144683247, "phrase": "new_leader_election_abstraction"}, {"score": 0.002388487669097511, "phrase": "timely_leader"}, {"score": 0.0021049977753042253, "phrase": "abortable_registers"}], "paper_keywords": [""], "paper_abstract": "We introduce a simple liveness property for shared object implementations that is gracefully degrading depending on the degree of synchrony in each run. This property, called adaptive progress, provides a gradual bridge between obstruction-freedom and wait-freedom in partially-synchronous systems. We show that adaptive progress can be achieved using very weak shared objects. More precisely, every object has an implementation that ensures adaptive progress and uses only abortable registers (which are weaker than safe registers). As part of this work, we present a new leader election abstraction that processes can use to dynamically compete for leadership such that if there is at least one timely process among the current candidates for leadership, then a timely leader is eventually elected among the candidates. We also show that this abstraction can be implemented using abortable registers.", "paper_title": "Adaptive progress: a gracefully-degrading liveness property", "paper_id": "WOS:000280553200003"}