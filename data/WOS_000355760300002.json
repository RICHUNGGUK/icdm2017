{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "late_fusion"}, {"score": 0.03817032356847601, "phrase": "positive_samples"}, {"score": 0.03363896917055258, "phrase": "first_method"}, {"score": 0.0046676969718111765, "phrase": "recognition_accuracy"}, {"score": 0.004624401316503576, "phrase": "prediction_scores"}, {"score": 0.004595759852879717, "phrase": "multiple_classifiers"}, {"score": 0.004469042910390712, "phrase": "specific_feature"}, {"score": 0.004400153852462583, "phrase": "existing_methods"}, {"score": 0.004345804626592329, "phrase": "fixed_fusion_weight"}, {"score": 0.004071249707923223, "phrase": "different_subsets"}, {"score": 0.003778566972399296, "phrase": "information_propagation_process"}, {"score": 0.0037318666008429014, "phrase": "fusion_weights"}, {"score": 0.0037087324991876727, "phrase": "labeled_samples"}, {"score": 0.0036742989715836745, "phrase": "individual_unlabeled_samples"}, {"score": 0.0035951877427580006, "phrase": "higher_fusion_scores"}, {"score": 0.0035728978842974246, "phrase": "negative_samples"}, {"score": 0.0034959622587016222, "phrase": "optimal_fusion_weight"}, {"score": 0.0033262524445013303, "phrase": "fusion_score_rank_list"}, {"score": 0.0032953582866530966, "phrase": "better_accuracy"}, {"score": 0.003048782877550259, "phrase": "graph_laplacian"}, {"score": 0.0030298703815998173, "phrase": "ranksvm_style_constraints"}, {"score": 0.0029370480686919075, "phrase": "fast_gradient_projection_algorithm"}, {"score": 0.0029097582786754444, "phrase": "second_method"}, {"score": 0.0028917056916949744, "phrase": "infinite_push_sslf"}, {"score": 0.002803846342448628, "phrase": "laplacian"}, {"score": 0.0027857115172243226, "phrase": "infinite_push_constraints"}, {"score": 0.002708766459414734, "phrase": "optimization_problem"}, {"score": 0.00265038878247831, "phrase": "efficient_alternating_direction_method"}, {"score": 0.0026094602917828037, "phrase": "extensive_experiments"}, {"score": 0.002585206414738808, "phrase": "large-scale_image"}, {"score": 0.0025611773887867255, "phrase": "data_sets"}, {"score": 0.0024216102875733027, "phrase": "large_data_sets"}, {"score": 0.0023990982005125763, "phrase": "anchorgraph_model"}, {"score": 0.0022612912386120385, "phrase": "entire_graph"}, {"score": 0.0021049977753042253, "phrase": "sample_specific_fusion_weights"}], "paper_keywords": ["Image recognition", " video recognition", " late fusion", " infinite push", " l(infinity) norm"], "paper_abstract": "Late fusion is one of the most effective approaches to enhance recognition accuracy through combining prediction scores of multiple classifiers, each of which is trained by a specific feature or model. The existing methods generally use a fixed fusion weight for one classifier over all samples, and ignore the fact that each classifier may perform better or worse for different subsets of samples. In order to address this issue, we propose a novel sample specific late fusion (SSLF) method. Specifically, we cast late fusion into an information propagation process that diffuses the fusion weights of labeled samples to the individual unlabeled samples, and enforce positive samples to have higher fusion scores than negative samples. Upon this process, the optimal fusion weight for each sample is identified, while positive samples are pushed toward the top at the fusion score rank list to achieve better accuracy. In this paper, two SSLF methods are presented. The first method is ranking SSLF (R-SSLF), which is based on graph Laplacian with RankSVM style constraints. We formulate and solve the problem with a fast gradient projection algorithm; the second method is infinite push SSLF (I-SSLF), which combines graph Laplacian with infinite push constraints. I-SSLF is a l(infinity) norm constrained optimization problem and can be solved by an efficient alternating direction method of multipliers method. Extensive experiments on both large-scale image and video data sets demonstrate the effectiveness of our methods. In addition, in order to make our method scalable to support large data sets, the AnchorGraph model is employed to propagate information on a subset of samples (anchor points) and then reconstruct the entire graph to get the weights of all samples. To the best of our knowledge, this is the first method that supports learning of sample specific fusion weights for late fusion.", "paper_title": "Learning Sample Specific Weights for Late Fusion", "paper_id": "WOS:000355760300002"}