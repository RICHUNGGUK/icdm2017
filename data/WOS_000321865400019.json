{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "sound_optimisations"}, {"score": 0.011678002041562672, "phrase": "concurrency_compiler_bugs"}, {"score": 0.00458488025289647, "phrase": "correct_sequential_code"}, {"score": 0.004473982381245469, "phrase": "concurrency_memory_model"}, {"score": 0.004392565073466714, "phrase": "programming_language"}, {"score": 0.004312622975366676, "phrase": "subtle_compiler_bugs"}, {"score": 0.004157058883925715, "phrase": "miscompiled_functions"}, {"score": 0.004081385289516914, "phrase": "concurrent_contexts"}, {"score": 0.0036329805216306576, "phrase": "hard_problem"}, {"score": 0.0035233696341819437, "phrase": "differential_testing"}, {"score": 0.0034804536625952596, "phrase": "sequential_code"}, {"score": 0.002878140062594849, "phrase": "real_compilers"}, {"score": 0.0027741761880779535, "phrase": "common_compiler_optimisations"}, {"score": 0.0023798115577749225, "phrase": "memory_trace"}, {"score": 0.0023507916951658455, "phrase": "compiled_code"}, {"score": 0.0023079225317714815, "phrase": "reference_memory_trace"}, {"score": 0.002265833357217618, "phrase": "source_code"}, {"score": 0.0021441057555396013, "phrase": "latest_release"}, {"score": 0.0021049977753042253, "phrase": "gcc_compiler"}], "paper_keywords": ["C11/C++11 memory model", " compiler testing"], "paper_abstract": "Compilers sometimes generate correct sequential code but break the concurrency memory model of the programming language: these subtle compiler bugs are observable only when the miscompiled functions interact with concurrent contexts, making them particularly hard to detect. In this work we design a strategy to reduce the hard problem of hunting concurrency compiler bugs to differential testing of sequential code and build a tool that puts this strategy to work. Our first contribution is a theory of sound optimisations in the C11/C++11 memory model, covering most of the optimisations we have observed in real compilers and validating the claim that common compiler optimisations are sound in the C11/C++11 memory model. Our second contribution is to show how, building on this theory, concurrency compiler bugs can be identified by comparing the memory trace of compiled code against a reference memory trace for the source code. Our tool identified several mistaken write introductions and other unexpected behaviours in the latest release of the gcc compiler.", "paper_title": "Compiler Testing via a Theory of Sound Optimisations in the C11/C++11 Memory Model", "paper_id": "WOS:000321865400019"}