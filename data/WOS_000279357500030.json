{"auto_keywords": [{"score": 0.048445090360224895, "phrase": "sc"}, {"score": 0.00481495049065317, "phrase": "concurrent_programming_languages"}, {"score": 0.004732100994830163, "phrase": "shared-memory_multi-threaded_programming"}, {"score": 0.004190563478825626, "phrase": "sc_execution"}, {"score": 0.004161553532799662, "phrase": "data-race-free_programs"}, {"score": 0.004005537264228818, "phrase": "racy_programs"}, {"score": 0.0038286491141253584, "phrase": "safety_issue"}, {"score": 0.0037889466472096284, "phrase": "java_memory_model"}, {"score": 0.003685067218455088, "phrase": "drf_model"}, {"score": 0.0036341965226247028, "phrase": "weak_semantics"}, {"score": 0.003609024170287396, "phrase": "racy_executions"}, {"score": 0.0033433365160336842, "phrase": "compiler_writers"}, {"score": 0.0032743220621043023, "phrase": "compiler_optimizations"}, {"score": 0.003217896008931311, "phrase": "drfx_memory_model"}, {"score": 0.00301217724562369, "phrase": "memory_model"}, {"score": 0.002939048579115465, "phrase": "sc."}, {"score": 0.00266693888510356, "phrase": "mm_exception"}, {"score": 0.0025490131630603757, "phrase": "data_race"}, {"score": 0.002505054869094183, "phrase": "sc_violations"}, {"score": 0.002436289099444074, "phrase": "lightweight_form"}, {"score": 0.002419393934835993, "phrase": "conflict_detection"}, {"score": 0.0023611760395203106, "phrase": "aggressive_compiler"}, {"score": 0.002344800544183559, "phrase": "hardware_optimizations"}, {"score": 0.0023285383529595416, "phrase": "compiler-designated_program_regions"}, {"score": 0.002202427244004817, "phrase": "hardware_design"}, {"score": 0.0021419510072373756, "phrase": "performance_overhead"}, {"score": 0.0021049977753042253, "phrase": "hardware_requirements"}], "paper_keywords": ["Design", " Languages", " memory models", " sequential consistency", " data races", " memory model exception", " soft fences"], "paper_abstract": "The most intuitive memory model for shared-memory multi-threaded programming is sequential consistency (SC), but it disallows the use of many compiler and hardware optimizations thereby impacting performance. Data-race-free (DRF) models, such as the proposed C++0x memory model, guarantee SC execution for data-race-free programs. But these models provide no guarantee at all for racy programs, compromising the safety and debuggability of such programs. To address the safety issue, the Java memory model, which is also based on the DRF model, provides a weak semantics for racy executions. However, this semantics is subtle and complex, making it difficult for programmers to reason about their programs and for compiler writers to ensure the correctness of compiler optimizations. We present the DRFx memory model, which is simple for programmers to understand and use while still supporting many common optimizations. We introduce a memory model (MM) exception which can be signaled to halt execution. If a program executes without throwing this exception, then DRFx guarantees that the execution is SC. If a program throws an MM exception during an execution, then DRFx guarantees that the program has a data race. We observe that SC violations can be detected in hardware through a lightweight form of conflict detection. Furthermore, our model safely allows aggressive compiler and hardware optimizations within compiler-designated program regions. We formalize our memory model, prove several properties about this model, describe a compiler and hardware design suitable for DRFx, and evaluate the performance overhead due to our compiler and hardware requirements.", "paper_title": "DRFx: A Simple and Efficient Memory Model for Concurrent Programming Languages", "paper_id": "WOS:000279357500030"}