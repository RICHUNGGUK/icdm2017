{"auto_keywords": [{"score": 0.04620691760994069, "phrase": "parametric_trace"}, {"score": 0.009732520279543088, "phrase": "parametric_trace_analysis"}, {"score": 0.008038796279363138, "phrase": "parametric_property_monitoring_technique"}, {"score": 0.00481495049065317, "phrase": "parametric_monitoring._analysis"}, {"score": 0.004753034791339585, "phrase": "fundamental_role"}, {"score": 0.004661643892279938, "phrase": "runtime_verification"}, {"score": 0.004562148512826994, "phrase": "execution_traces"}, {"score": 0.004455143595587971, "phrase": "parameter_bindings"}, {"score": 0.004248572389983731, "phrase": "java_program"}, {"score": 0.004230272912967057, "phrase": "iterator_objects"}, {"score": 0.004122112628377632, "phrase": "trace_createlter"}, {"score": 0.0038552774380687773, "phrase": "collection_c"}, {"score": 0.003257572374586532, "phrase": "parametric_properties"}, {"score": 0.003187948687136388, "phrase": "specification_formalism"}, {"score": 0.0030862846914542596, "phrase": "existing_approaches"}, {"score": 0.0030729759775204864, "phrase": "common_notions"}, {"score": 0.003039953968859831, "phrase": "even_techniques"}, {"score": 0.002994316665299538, "phrase": "fundamental_study"}, {"score": 0.0029366424492849076, "phrase": "foundational_paper"}, {"score": 0.0029050812030814964, "phrase": "semantics-based_solution"}, {"score": 0.0028429697771869635, "phrase": "parametric_property"}, {"score": 0.002764200469887753, "phrase": "rigorous_understanding"}, {"score": 0.0026818043945415824, "phrase": "general-purpose_parametric_trace_slicing_technique"}, {"score": 0.0025738855219088782, "phrase": "slicing_technique"}, {"score": 0.002486373634642543, "phrase": "trace_slice"}, {"score": 0.002310141704837136, "phrase": "indexing_unrestricted_and_well-understood_non-parametric_property_monitors"}, {"score": 0.0022461020509136464, "phrase": "presented_parametric_trace_slicing"}, {"score": 0.0021838337603906667, "phrase": "runtime_overhead"}, {"score": 0.0021510212296341393, "phrase": "discussed_techniques"}, {"score": 0.002123288049106793, "phrase": "performance_expense"}, {"score": 0.0021049977753042253, "phrase": "existing_parametric_trace_monitoring_systems"}], "paper_keywords": ["runtime verification", " monitoring", " trace slicing"], "paper_abstract": "Analysis of execution traces plays a fundamental role in many program analysis approaches, such as runtime verification, testing, monitoring, and specification mining. Execution traces are frequently parametric, i.e., they contain events with parameter bindings. Each parametric trace usually consists of many meaningful trace slices merged together, each slice corresponding to one parameter binding. For example, a Java program creating iterator objects i(1) and i(2) over collection object c(1) may yield a trace createlter < c(1) i(1)> next < i(1)> createlter < c(1) i(2)> updateColl < c(1)> next < i(1)> parametric in collection c and iterator i, whose slices corresponding to instances \"c, i bar right arrow c(1), i(1)\" and \"c, i bar right arrow c(1), i(2)\" are createlter < c(1) i(1)> next < i(1)> updateColl < c(1)> next < i(1)> and, respectively, createlter < c(1) i(2)> updateColl < c(1)>. Several approaches have been proposed to specify and dynamically analyze parametric properties, but they have limitations: some in the specification formalism, others in the type of trace they support. Not unexpectedly, the existing approaches share common notions, intuitions, and even techniques and algorithms, suggesting that a fundamental study and understanding of parametric trace analysis is necessary. This foundational paper aims at giving a semantics-based solution to parametric trace analysis that is unrestricted by the type of parametric property or trace that can be analyzed. Our approach is based on a rigorous understanding of what a parametric trace/property/monitor is and how it relates to its non-parametric counter-part. A general-purpose parametric trace slicing technique is introduced, which takes each event in the parametric trace and dispatches it to its corresponding trace slices. This parametric trace slicing technique can be used in combination with any conventional, non-parametric trace analysis technique, by applying the later on each trace slice. As an instance, a parametric property monitoring technique is then presented, which processes each trace slice online. Thanks to the generality of parametric trace slicing, the parametric property monitoring technique reduces to encapsulating and indexing unrestricted and well-understood non-parametric property monitors (e.g., finite or push-down automata). The presented parametric trace slicing and monitoring techniques have been implemented and extensively evaluated. Measurements of runtime overhead confirm that the generality of the discussed techniques does not come at a performance expense when compared with existing parametric trace monitoring systems.", "paper_title": "SEMANTICS AND ALGORITHMS FOR PARAMETRIC MONITORING", "paper_id": "WOS:000302505000009"}