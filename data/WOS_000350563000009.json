{"auto_keywords": [{"score": 0.011037861291895146, "phrase": "mean-payoff_automata"}, {"score": 0.01019158568814603, "phrase": "polynomial_time"}, {"score": 0.00481495049065317, "phrase": "probabilistic_environments"}, {"score": 0.0047722145315845016, "phrase": "traditional_synthesis_question"}, {"score": 0.0046739596755881185, "phrase": "automatic_construction"}, {"score": 0.004483450050677258, "phrase": "preference_order"}, {"score": 0.004443643245632722, "phrase": "different_systems"}, {"score": 0.004339203636449911, "phrase": "probabilistic_assumption"}, {"score": 0.00430067200637091, "phrase": "possible_inputs"}, {"score": 0.0041995784967999985, "phrase": "weighted_automaton"}, {"score": 0.003957078581524691, "phrase": "higher_expected_value"}, {"score": 0.003852553673822629, "phrase": "omega-regular_specification"}, {"score": 0.003818859806161159, "phrase": "markov"}, {"score": 0.0035551969986263553, "phrase": "input_assumption"}, {"score": 0.0034715658596258018, "phrase": "measured_value"}, {"score": 0.0034407121288076783, "phrase": "safety_specifications"}, {"score": 0.0034202949436614723, "phrase": "quantitative_measures"}, {"score": 0.0033398265543234393, "phrase": "optimal_synthesis_problem"}, {"score": 0.0032612451286025555, "phrase": "markov_decision_process"}, {"score": 0.0031750418391373035, "phrase": "long-run_average_reward_objective"}, {"score": 0.0030819219279832224, "phrase": "general_omega-regular_specifications"}, {"score": 0.002921114512115261, "phrase": "mean-payoff_parity_objectives"}, {"score": 0.0028779496327516634, "phrase": "optimal_strategies"}, {"score": 0.0027115578750853673, "phrase": "finite-state_system"}, {"score": 0.0026477194580630963, "phrase": "epsilon-optimal_strategy"}, {"score": 0.0026241684260044414, "phrase": "bounded_counter"}, {"score": 0.0024431289979171505, "phrase": "optimal_finite-state_system"}, {"score": 0.0023018188296933923, "phrase": "underlying_algorithms"}, {"score": 0.0022610379771517966, "phrase": "qualitative_and_quantitative_specifications"}, {"score": 0.0022012144080075114, "phrase": "qualitative_specification"}, {"score": 0.0021751356291518716, "phrase": "quantitative_specification"}, {"score": 0.002117580079489708, "phrase": "experimental_results"}, {"score": 0.0021049977753042253, "phrase": "optimal_systems"}], "paper_keywords": ["Verification", " Languages", " Design", " Synthesis", " quantitative verification"], "paper_abstract": "The traditional synthesis question given a specification asks for the automatic construction of a system that satisfies the specification, whereas often there exists a preference order among the different systems that satisfy the given specification. Under a probabilistic assumption about the possible inputs, such a preference order is naturally expressed by a weighted automaton, which assigns to each word a value, such that a system is preferred if it generates a higher expected value. We solve the following optimal synthesis problem: given an omega-regular specification, a Markov chain that describes the distribution of inputs, and a weighted automaton that measures how well a system satisfies the given specification under the input assumption, synthesize a system that optimizes the measured value. For safety specifications and quantitative measures that are defined by mean-payoff automata, the optimal synthesis problem reduces to finding a strategy in a Markov decision process (MDP) that is optimal for a long-run average reward objective, which can be achieved in polynomial time. For general omega-regular specifications along with mean-payoff automata, the solution rests on a new, polynomial-time algorithm for computing optimal strategies in MDPs with mean-payoff parity objectives. Our algorithm constructs optimal strategies that consist of two memoryless strategies and a counter. The counter is in general not bounded. To obtain a finite-state system, we show how to construct an epsilon-optimal strategy with a bounded counter, for all epsilon > 0. Furthermore, we show how to decide in polynomial time if it is possible to construct an optimal finite-state system (i.e., a system without a counter) for a given specification. We have implemented our approach and the underlying algorithms in a tool that takes qualitative and quantitative specifications and automatically constructs a system that satisfies the qualitative specification and optimizes the quantitative specification, if such a system exists. We present some experimental results showing optimal systems that were automatically generated in this way.", "paper_title": "Measuring and Synthesizing Systems in Probabilistic Environments", "paper_id": "WOS:000350563000009"}