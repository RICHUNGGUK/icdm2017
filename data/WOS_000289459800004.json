{"auto_keywords": [{"score": 0.04836165556138413, "phrase": "symbolic_execution"}, {"score": 0.010612387000973441, "phrase": "test_data_generation"}, {"score": 0.0065831839596844155, "phrase": "lazy_symbolic_evaluation"}, {"score": 0.006232856958987056, "phrase": "intermediate_variables"}, {"score": 0.004558289038745564, "phrase": "computing_power"}, {"score": 0.004414907432703781, "phrase": "test_generation_tools"}, {"score": 0.00429558848734449, "phrase": "high_coverage"}, {"score": 0.00419861271409079, "phrase": "real_applications"}, {"score": 0.0039928721865882, "phrase": "complex_program_structures"}, {"score": 0.003867206750827, "phrase": "library_functions"}, {"score": 0.00349734405943853, "phrase": "lazy_evaluation_strategy"}, {"score": 0.003310684108128973, "phrase": "program_structures"}, {"score": 0.003091262582401731, "phrase": "traditional_symbolic_execution"}, {"score": 0.003021392767766593, "phrase": "former_well"}, {"score": 0.0027954035431845344, "phrase": "path_constraints"}, {"score": 0.0027073229284666294, "phrase": "concrete_values"}, {"score": 0.0026704265616705023, "phrase": "input_variables"}, {"score": 0.0024147474002390763, "phrase": "concrete_and_symbolic_values"}, {"score": 0.0022238315004700607, "phrase": "prototype_tool"}, {"score": 0.0021537217025910356, "phrase": "empirical_results"}], "paper_keywords": [""], "paper_abstract": "In the context of test data generation, symbolic execution gets more attention as computing power increases continuously. Experiments show that test generation tools based on symbolic execution can get high coverage and find bugs on real applications. However, symbolic execution still has limitations in handling some complex program structures such as pointers, arrays and library functions. To address the problem, this study proposes a technique called lazy symbolic execution, which combines symbolic execution with a lazy evaluation strategy. The authors approach is motivated by the observation that some program structures can be reasoned about symbolically and the others have to be evaluated concretely. Traditional symbolic execution can cope with the former well, whereas lazy symbolic evaluation is used to handle the latter. However, lazy symbolic evaluation introduces intermediate variables into path constraints. To eliminate those variables, concrete values for some input variables are first obtained by constraint solving or searching processes. Then, the given path is executed again using inputs consisting of concrete and symbolic values. The procedure is repeated until all intermediate variables are wiped out. The authors have implemented a prototype tool and performed some experiments. The empirical results show the effectiveness of their approach.", "paper_title": "Lazy symbolic execution for test data generation", "paper_id": "WOS:000289459800004"}