{"auto_keywords": [{"score": 0.049348918639928865, "phrase": "data_structures"}, {"score": 0.00481495049065317, "phrase": "concurrent_data_structures"}, {"score": 0.004778088905211055, "phrase": "efficient_implementations"}, {"score": 0.004562743714811391, "phrase": "concurrent_access"}, {"score": 0.004192730391924712, "phrase": "small_parts"}, {"score": 0.0041129284507136, "phrase": "linearizability"}, {"score": 0.004065721092116729, "phrase": "standard_correctness_criterion"}, {"score": 0.0039729853486821995, "phrase": "concurrent_object"}, {"score": 0.0036788184374592706, "phrase": "potential_concurrent_access"}, {"score": 0.003636605792981828, "phrase": "shared_data_structure"}, {"score": 0.0035399770257915466, "phrase": "verification_problem"}, {"score": 0.0033543281764294927, "phrase": "specific_types"}, {"score": 0.003290403747743492, "phrase": "previous_work"}, {"score": 0.003215295260684715, "phrase": "simulation-based_proof_conditions"}, {"score": 0.0030820072734233693, "phrase": "subtle_concurrent_algorithms"}, {"score": 0.002931569771634119, "phrase": "backward_simulation"}, {"score": 0.0028317319086202217, "phrase": "linearizable_algorithm"}, {"score": 0.0026218430041123164, "phrase": "linearizability_proof"}, {"score": 0.0025917270871556475, "phrase": "concurrent_queue"}, {"score": 0.0025521085778978042, "phrase": "herlihy_and_wing's_landmark_paper"}, {"score": 0.002446245096967702, "phrase": "numerous_other_approaches"}, {"score": 0.0023357478549318102, "phrase": "full_mechanisation"}, {"score": 0.0021376902861998865, "phrase": "interactive_prover"}, {"score": 0.0021049977753042253, "phrase": "kiv."}], "paper_keywords": ["Algorithms", " Verification", " Z", " refinement", " concurrent access", " linearizability", " nonatomic refinement", " theorem proving", " KIV"], "paper_abstract": "Efficient implementations of data structures such as queues, stacks or hash-tables allow for concurrent access by many processes at the same time. To increase concurrency, these algorithms often completely dispose with locking, or only lock small parts of the structure. Linearizability is the standard correctness criterion for such a scenario-where a concurrent object is linearizable if all of its operations appear to take effect instantaneously some time between their invocation and return. The potential concurrent access to the shared data structure tremendously increases the complexity of the verification problem, and thus current proof techniques for showing linearizability are all tailored to specific types of data structures. In previous work, we have shown how simulation-based proof conditions for linearizability can be used to verify a number of subtle concurrent algorithms. In this article, we now show that conditions based on backward simulation can be used to show linearizability of every linearizable algorithm, that is, we show that our proof technique is both sound and complete. We exemplify our approach by a linearizability proof of a concurrent queue, introduced in Herlihy and Wing's landmark paper on linearizability. Except for their manual proof, none of the numerous other approaches have successfully treated this queue. Our approach is supported by a full mechanisation: both the linearizability proofs for case studies like the queue, and the proofs of soundness and completeness have been carried out with an interactive prover, which is KIV.", "paper_title": "A Sound and Complete Proof Technique for Linearizability of Concurrent Data Structures", "paper_id": "WOS:000345570700006"}