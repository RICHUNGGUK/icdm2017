{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "chip_multiprocessors"}, {"score": 0.030961125428255173, "phrase": "communication_pattern"}, {"score": 0.00477190623242136, "phrase": "data_access_latency"}, {"score": 0.00438161736774803, "phrase": "nonuniform_cache_architectures"}, {"score": 0.004342430078306461, "phrase": "distributed_cache_banks"}, {"score": 0.00415166680936294, "phrase": "compiler-based_approach"}, {"score": 0.004114527599108729, "phrase": "leverage_data_access_locality"}, {"score": 0.004041238873048836, "phrase": "optimized_data_placement"}, {"score": 0.003951453722517865, "phrase": "on-chip_network"}, {"score": 0.0038985392250620483, "phrase": "proposed_experimental_compiler_framework"}, {"score": 0.0038636556112977226, "phrase": "novel_compilation_techniques"}, {"score": 0.003777800904236079, "phrase": "multithreaded_memory_access_patterns"}, {"score": 0.0036443694410100507, "phrase": "symbolic_mmaps"}, {"score": 0.003531474887552889, "phrase": "partitioning_algorithm"}, {"score": 0.003437486158494063, "phrase": "allocated_memory_blocks"}, {"score": 0.0033914308417007316, "phrase": "forked_threads"}, {"score": 0.0033459905006404207, "phrase": "analyzed_application"}, {"score": 0.0032277611129050234, "phrase": "data_ownership"}, {"score": 0.0026962411675196213, "phrase": "experimental_architecture"}, {"score": 0.0025316254589087973, "phrase": "shared_caching"}, {"score": 0.00247529638625566, "phrase": "closest_runtime_approximation"}, {"score": 0.0023557346035701096, "phrase": "comparable_performance"}, {"score": 0.002282667669149476, "phrase": "complex_centralized_network_configuration_system"}, {"score": 0.0022019274077124795, "phrase": "significant_runtime_complexity"}, {"score": 0.0021049977753042253, "phrase": "reconfigurable_network"}], "paper_keywords": ["Circuit switching", " network-on-chip", " communication", " data access pattern", " data partition"], "paper_abstract": "Data access latency, a limiting factor in the performance of chip multiprocessors, grows significantly with the number of cores in nonuniform cache architectures with distributed cache banks. To mitigate this effect, we use a compiler-based approach to leverage data access locality, choose an optimized data placement and efficiently configure the on-chip network. The proposed experimental compiler framework employs novel compilation techniques to discover and represent multithreaded memory access patterns (MMAPs). At runtime, symbolic MMAPs are resolved and used by a partitioning algorithm to choose a partition of allocated memory blocks among the forked threads in the analyzed application. This partition is used to enforce data ownership by associating the data with the core that executes the thread owning the data. Based on the partition, the communication pattern of the application can be extracted. We demonstrate how this information can be used in an experimental architecture to accelerate applications. In particular, our compiler assisted data partitioning approach shows a 20 percent speedup over shared caching and 5 percent speedup over the closest runtime approximation, first touch. By leveraging the communication pattern we can achieve a comparable performance to a system that uses a complex centralized network configuration system at runtime. Thus, our final system saves significant runtime complexity and achieves an 5.1 percent additional speedup through the addition of the reconfigurable network.", "paper_title": "Compiler-Assisted Data Distribution and Network Configuration for Chip Multiprocessors", "paper_id": "WOS:000308998100006"}