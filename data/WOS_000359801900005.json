{"auto_keywords": [{"score": 0.04973325992892519, "phrase": "software_adaptivity"}, {"score": 0.010612387000973441, "phrase": "online_tuning"}, {"score": 0.007058152915338251, "phrase": "self-adaptive_software"}, {"score": 0.004494570360108983, "phrase": "common_approach"}, {"score": 0.004381962669035583, "phrase": "dedicated_code"}, {"score": 0.004350308086118336, "phrase": "software_development_stage"}, {"score": 0.004256703909255889, "phrase": "code_fragments"}, {"score": 0.004075469816959996, "phrase": "contextual_changes"}, {"score": 0.0038737214010638745, "phrase": "original_builtin_adaptivity"}, {"score": 0.00376293585033711, "phrase": "new_code"}, {"score": 0.0036157418067192136, "phrase": "unexpected_environment"}, {"score": 0.003563651133299401, "phrase": "outdated_adaptation_decision_logic"}, {"score": 0.003525074461418428, "phrase": "technical_challenges"}, {"score": 0.003219368413618912, "phrase": "architecture-centric_application_framework"}, {"score": 0.003172969962401266, "phrase": "auxo"}, {"score": 0.0031272381208680613, "phrase": "existing_work"}, {"score": 0.002887210021573995, "phrase": "running_self-adaptive_software"}, {"score": 0.002675252546913683, "phrase": "self-adaptation_loop"}, {"score": 0.0025611773887867255, "phrase": "architecture_elements"}, {"score": 0.0024968877430444304, "phrase": "third_party"}, {"score": 0.0024788167298469455, "phrase": "potentially_the_operator"}, {"score": 0.0024519545383399773, "phrase": "augmented_software_entity"}, {"score": 0.0024253827365474734, "phrase": "explicit_domain_knowledge"}, {"score": 0.0023388674614404324, "phrase": "self-adaptation_concerns"}, {"score": 0.0023051296931856265, "phrase": "runtime_software_architecture"}, {"score": 0.002182881082103045, "phrase": "self-adaptive_application"}], "paper_keywords": ["software architecture", " self-adaptive software", " architecture style", " application framework", " software adaptation"], "paper_abstract": "Adaptivity is the capacity of software to adjust itself to changes in its environment. A common approach to achieving adaptivity is to introduce dedicated code during software development stage. However, since those code fragments are designed a priori, self-adaptive software cannot handle situations adequately when the contextual changes go beyond those that are originally anticipated. In this case, the original builtin adaptivity should be tuned. For example, new code should be added to provide the capacity to sense the unexpected environment or to replace outdated adaptation decision logic. The technical challenges in this process, especially that of tuning software adaptivity at runtime, cannot be understated. In this paper, we propose an architecture-centric application framework for self-adaptive software named Auxo. Similar to existing work, our framework supports the development and running of self-adaptive software. Furthermore, our framework supports the tuning of software adaptivity without requiring the running self-adaptive software to be terminated. In short, the architecture style that we are introducing can encapsulate not only general functional logic but also the concerns in the self-adaptation loop (such as sensing, decision, and execution) as architecture elements. As a result, a third party, potentially the operator or an augmented software entity equipped with explicit domain knowledge, is able to dynamically and flexibly adjust the self-adaptation concerns through modifying the runtime software architecture. To truly exercise, validate, and evaluate our approach, we describe a self-adaptive application that was deployed on the framework, and conducted several experiments involving self-adaptation and the online tuning of software adaptivity.", "paper_title": "Auxo: an architecture-centric framework supporting the online tuning of software adaptivity", "paper_id": "WOS:000359801900005"}