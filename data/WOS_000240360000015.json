{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "encapsulated_object-oriented_components"}, {"score": 0.004733901576706854, "phrase": "well-defined_boundary"}, {"score": 0.004575854901681043, "phrase": "internal_state"}, {"score": 0.004448169552315403, "phrase": "internal_calls"}, {"score": 0.004275347843870176, "phrase": "external_calls"}, {"score": 0.004203343568960231, "phrase": "target_objects"}, {"score": 0.004039995317682942, "phrase": "static_point"}, {"score": 0.003882970272082245, "phrase": "programmer's_interface"}, {"score": 0.0034279721355412285, "phrase": "dynamic_point"}, {"score": 0.0032760377953971248, "phrase": "component_state"}, {"score": 0.0031665087019813244, "phrase": "program_state"}, {"score": 0.0030433302702291116, "phrase": "tutorial_paper"}, {"score": 0.002975099633631871, "phrase": "encapsulated_components"}, {"score": 0.0028756028995504035, "phrase": "object-oriented_concepts"}, {"score": 0.0027325449069867222, "phrase": "flexible_notion"}, {"score": 0.0027017308406240563, "phrase": "hierarchical_encapsulation"}, {"score": 0.002671263324230699, "phrase": "confined_references"}, {"score": 0.0025819015229390663, "phrase": "encapsulation_concepts"}, {"score": 0.002552781867125423, "phrase": "ownership_types"}, {"score": 0.0024257447861185813, "phrase": "modular_behavioral_component_specifications"}, {"score": 0.0022919762167777427, "phrase": "simple_semantics"}, {"score": 0.0022278779300543548, "phrase": "alternative_solution"}, {"score": 0.002190280748985751, "phrase": "frame_problem"}, {"score": 0.002129020447793464, "phrase": "new_specification_methodology"}, {"score": 0.0021049977753042253, "phrase": "typical_programming_patterns"}], "paper_keywords": [""], "paper_abstract": "A well-defined boundary of components allows to encapsulate internal state and to distinguish between internal calls that remain inside the component and external calls that have target objects outside the component. From a static point of view, such boundaries define the programmer's interface to the component. In particular, they define the methods that can be called on the component. From a dynamic point of view, the boundaries separate the component state and those parts of the program state outside the component. In this tutorial paper, we investigate encapsulated components that are realized based on object-oriented concepts. We define a semantics that captures a flexible notion of hierarchical encapsulation with confined references. The semantics generalizes the encapsulation concepts of ownership types. It is used as a foundation for modular behavioral component specifications. In particular, it allows to provide a simple semantics for invariants and an alternative solution for the frame problem. We demonstrate this new specification methodology by typical programming patterns.", "paper_title": "Modular specification of encapsulated object-oriented components", "paper_id": "WOS:000240360000015"}