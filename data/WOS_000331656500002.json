{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "software_barriers"}, {"score": 0.013833897658256725, "phrase": "software_barrier_function"}, {"score": 0.004652016085325825, "phrase": "experience_report"}, {"score": 0.004513957235071457, "phrase": "software_barrier_synchronization"}, {"score": 0.0044369056710423065, "phrase": "informal_specification"}, {"score": 0.0041773934798743405, "phrase": "thread_halts"}, {"score": 0.003984141889010296, "phrase": "successful_software_barrier_call"}, {"score": 0.0035162927451540065, "phrase": "parallel_versions"}, {"score": 0.003486123304074186, "phrase": "major_numerical_algorithms"}, {"score": 0.0034118234596993836, "phrase": "scientific_computing"}, {"score": 0.003382547312072468, "phrase": "software_barrier_algorithms"}, {"score": 0.0030898642396380662, "phrase": "major_software_barrier_algorithms"}, {"score": 0.00306334226516593, "phrase": "off-the-shelf_automatic_verification_systems"}, {"score": 0.0030239842475439814, "phrase": "jahob"}, {"score": 0.0029214769181390653, "phrase": "checkfence"}, {"score": 0.0028591768694918, "phrase": "central_barrier"}, {"score": 0.002448061472257196, "phrase": "weak_memory_model"}, {"score": 0.0023548511815224098, "phrase": "novel_theorem_proving_method"}, {"score": 0.0021789194955896124, "phrase": "verification_systems"}, {"score": 0.0021049977753042253, "phrase": "new_challenges"}], "paper_keywords": ["Barrier", " Verification", " Invariant", " Safety", " Verifier", " Automation"], "paper_abstract": "We present an experience report on automating the verification of the software barrier synchronization primitive. The informal specification of the primitive is: when a thread calls the software barrier function, the thread halts until all other threads call their instances of the software barrier function. A successful software barrier call ensures that each thread has finished its portion of work before the threads start exchanging the results of these portions of work. While software barriers are widely used in parallel versions of major numerical algorithms and are indispensable in scientific computing, software barrier algorithms and their implementations scarcely have been verified. We improve the state of the art in proving the correctness of the major software barrier algorithms with off-the-shelf automatic verification systems such as Jahob, VCC, Boogie, Spin and Checkfence. We verify a central barrier, a C implementation of a barrier, a static tree barrier, a combining tree barrier, a dissemination barrier, a tournament barrier, a barrier with its client and a barrier on a weak memory model. In the process, we introduce a novel theorem proving method for proving validity of formulas containing cardinalities of comprehensions and improve the capabilities of one of the verification systems. Based on our experience, we propose new challenges in the verification of software barriers.", "paper_title": "On Automation in the Verification of Software Barriers: Experience Report", "paper_id": "WOS:000331656500002"}