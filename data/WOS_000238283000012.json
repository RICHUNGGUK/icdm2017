{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "control-flow_side_channel_attacks"}, {"score": 0.013850760574608524, "phrase": "control-flow_side_channels"}, {"score": 0.011907046154656917, "phrase": "side_channel_attacks"}, {"score": 0.004321118442104989, "phrase": "transformed_code"}, {"score": 0.004093453936415085, "phrase": "program_counter_transcript"}, {"score": 0.003935420482629049, "phrase": "program_counter"}, {"score": 0.003728000957725218, "phrase": "program_counter_transcript_model"}, {"score": 0.003584025547693836, "phrase": "timing_attacks"}, {"score": 0.003548905904860611, "phrase": "error_disclosure_attacks"}, {"score": 0.003428665921276366, "phrase": "generic_source"}, {"score": 0.0033617891884360606, "phrase": "source_transformation"}, {"score": 0.00307657476125683, "phrase": "static_checker"}, {"score": 0.0029576827451501956, "phrase": "program_counter_security"}, {"score": 0.0027741761880779535, "phrase": "resulting_code"}, {"score": 0.0026148807877309417, "phrase": "binary_modular_exponentiation"}, {"score": 0.0025892330566358503, "phrase": "real-world_implementations"}, {"score": 0.002428530921948425, "phrase": "performance_overhead"}, {"score": 0.002233301265743633, "phrase": "side_channel_security"}, {"score": 0.0021049977753042253, "phrase": "interesting_class"}], "paper_keywords": [""], "paper_abstract": "We introduce new methods for detecting control-flow side channel attacks, transforming C source code to eliminate such attacks, and checking that the transformed code is free of control-flow side channels. We model control-flow side channels with a program counter transcript, in which the value of the program counter at each step is leaked to an adversary. The program counter transcript model captures a class of side channel attacks that includes timing attacks and error disclosure attacks. Further, we propose a generic source-to-source transformation that produces programs provably secure against control-flow side channel attacks. We implemented this transform for C together with a static checker that conservatively checks x86 assembly for violations of program counter security; our checker allows us to compile with optimizations while retaining assurance the resulting code is secure. We then measured our technique's effect on the performance of binary modular exponentiation and real-world implementations in C of RC5 and IDEA: we found it has a performance overhead of at most 5x and a stack space overhead of at most 2x. Our approach to side channel security is practical, generally applicable, and provably secure against an interesting class of side channel attacks.", "paper_title": "The program counter security model: Automatic detection and removal of control-flow side channel attacks", "paper_id": "WOS:000238283000012"}