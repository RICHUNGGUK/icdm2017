{"auto_keywords": [{"score": 0.04287858727323994, "phrase": "input_size"}, {"score": 0.013771581997452296, "phrase": "individual_routines"}, {"score": 0.00481495049065317, "phrase": "input-sensitive_profiling"}, {"score": 0.004661446705304497, "phrase": "profiling_methodology"}, {"score": 0.00453113241842654, "phrase": "hidden_asymptotic_inefficiencies"}, {"score": 0.003567455727660992, "phrase": "collected_profiles"}, {"score": 0.0034817084307034955, "phrase": "performance_plots"}, {"score": 0.003439608110599787, "phrase": "trend_functions"}, {"score": 0.0034118234596993836, "phrase": "statistical_curve"}, {"score": 0.0033163269450817716, "phrase": "key_feature"}, {"score": 0.0030953529970646626, "phrase": "generic_code_fragment"}, {"score": 0.002984373546099842, "phrase": "effective_metric"}, {"score": 0.002696479050724968, "phrase": "asymptotic_bottlenecks"}, {"score": 0.0024963543716522087, "phrase": "real_applications"}, {"score": 0.0023776656246300063, "phrase": "valgrind_tool"}, {"score": 0.002320449502337321, "phrase": "extensive_experimental_evaluation"}, {"score": 0.0022281257694320433, "phrase": "comparable_performance"}, {"score": 0.002165688807780663, "phrase": "informative_plots"}, {"score": 0.0021394674440767124, "phrase": "single_runs"}, {"score": 0.0021221627745801478, "phrase": "typical_workloads"}], "paper_keywords": ["Algorithms", " Measurement", " Performance", " Performance profiling", " asymptotic analysis", " dynamic program analysis", " instrumentation"], "paper_abstract": "In this paper we present a profiling methodology and toolkit for helping developers discover hidden asymptotic inefficiencies in the code. From one or more runs of a program, our profiler automatically measures how the performance of individual routines scales as a function of the input size, yielding clues to their growth rate. The output of the profiler is, for each executed routine of the program, a set of tuples that aggregate performance costs by input size. The collected profiles can be used to produce performance plots and derive trend functions by statistical curve fitting or bounding techniques. A key feature of our method is the ability to automatically measure the size of the input given to a generic code fragment: to this aim, we propose an effective metric for estimating the input size of a routine and show how to compute it efficiently. We discuss several case studies, showing that our approach can reveal asymptotic bottlenecks that other profilers may fail to detect and characterize the workload and behavior of individual routines in the context of real applications. To prove the feasibility of our techniques, we implemented a Valgrind tool called aprof and performed an extensive experimental evaluation on the SPEC CPU2006 benchmarks. Our experiments show that aprof delivers comparable performance to other prominent Valgrind tools, and can generate informative plots even from single runs on typical workloads for most algorithmically-critical routines.", "paper_title": "Input-Sensitive Profiling", "paper_id": "WOS:000307582100009"}