{"auto_keywords": [{"score": 0.024586093495145706, "phrase": "magic"}, {"score": 0.00481495049065317, "phrase": "concurrent_message-passing_c_programs"}, {"score": 0.004473982381245469, "phrase": "model-checking_problem"}, {"score": 0.003334309053314909, "phrase": "pushdown_systems"}, {"score": 0.0031845067058084583, "phrase": "reachability_problem"}, {"score": 0.0026494723416072316, "phrase": "undecidable_problem"}, {"score": 0.00257735013358606, "phrase": "counterexample_guided_abstraction_refinement"}, {"score": 0.002329258721870127, "phrase": "model_checker"}, {"score": 0.002224510044064184, "phrase": "previously_unknown_bug"}, {"score": 0.0021049977753042253, "phrase": "windows_nt_bluetooth_driver"}], "paper_keywords": [""], "paper_abstract": "We consider the model-checking problem for C programs with (1) data ranging over very large domains, (2) (recursive) procedure calls, and (3) concurrent parallel components that communicate via synchronizing actions. We model such programs using communicating pushdown systems, and reduce the reachability problem for this model to deciding the emptiness of the intersection of two context-free languages L-1 and L-2. We tackle this undecidable problem using a CounterExample Guided Abstraction Refinement (CEGAR) scheme. We implemented our technique in the model checker MAGIC and found a previously unknown bug in a version of a Windows NT Bluetooth driver.", "paper_title": "Verifying concurrent message-passing C programs with recursive calls", "paper_id": "WOS:000236941100022"}