{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "data_permutations"}, {"score": 0.008650818643409332, "phrase": "simd_devices"}, {"score": 0.004728122501822142, "phrase": "widespread_presence"}, {"score": 0.0046597835420572825, "phrase": "today's_microprocessors"}, {"score": 0.004609175313390942, "phrase": "compiler_techniques"}, {"score": 0.004238929161010395, "phrase": "data_permutation_instructions"}, {"score": 0.004192872425727907, "phrase": "non-contiguous_and_misaligned_memory_references"}, {"score": 0.003998983496539902, "phrase": "crucial_importance"}, {"score": 0.003786337629480068, "phrase": "scalar_code"}, {"score": 0.0036508702548731383, "phrase": "isolated_data_reorganization_operation"}, {"score": 0.0035849585026689573, "phrase": "related_data_permutations"}, {"score": 0.003132693064568434, "phrase": "source_program"}, {"score": 0.0030761074505030184, "phrase": "generic_representation"}, {"score": 0.0029985954225814895, "phrase": "vector_accesses"}, {"score": 0.0029768089698126547, "phrase": "non-contiguous_and_misaligned_memory_locations"}, {"score": 0.0028702214190712036, "phrase": "optimization_algorithm"}, {"score": 0.002757365657304833, "phrase": "basic_block"}, {"score": 0.0026683288015968243, "phrase": "consecutive_permutations"}, {"score": 0.00250789768689397, "phrase": "code_generation_algorithm"}, {"score": 0.002489667521500195, "phrase": "generic_permutation_operations"}, {"score": 0.0024715695446993107, "phrase": "native_permutation_instructions"}, {"score": 0.002444668348634501, "phrase": "target_platform"}, {"score": 0.0022976536579329514, "phrase": "permutation_instructions"}, {"score": 0.002215329893200788, "phrase": "average_performance_improvement"}, {"score": 0.002183230464873613, "phrase": "vmx"}, {"score": 0.0021049977753042253, "phrase": "perfect_speedups"}], "paper_keywords": ["performance", " experimentation", " languages", " SIMD compilation", " data permutation", " optimization"], "paper_abstract": "The widespread presence of SIMD devices in today's microprocessors has made compiler techniques for these devices tremendously important. One of the most important and difficult issues that must be addressed by these techniques is the generation of the data permutation instructions needed for non-contiguous and misaligned memory references. These instructions are expensive and, therefore, it is of crucial importance to minimize their number to improve performance and, in many cases, enable speedups over scalar code. Although it is often difficult to optimize an isolated data reorganization operation, a collection of related data permutations can often be manipulated to reduce the number of operations. This paper presents a strategy to optimize all forms of data permutations. The strategy is organized into three steps. First, all data permutations in the source program are converted into a generic representation. These permutations can originate from vector accesses to non-contiguous and misaligned memory locations or result from compiler transformations. Second, an optimization algorithm is applied to reduce the number of data permutations in a basic block. By propagating permutations across statements and merging consecutive permutations whenever possible, the algorithm can significantly reduce the number of data permutations. Finally, a code generation algorithm translates generic permutation operations into native permutation instructions for the target platform. Experiments were conducted on various kinds of applications. The results show that up to 77% of the permutation instructions are eliminated and, as a result, the average performance improvement is 48% on VMX and 68% on SSE2. For several applications, near perfect speedups have been achieved on both platforms.", "paper_title": "Optimizing data permutations for SIMD devices", "paper_id": "WOS:000202972100011"}