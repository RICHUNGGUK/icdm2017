{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "linear"}, {"score": 0.004512814529823301, "phrase": "functional_pretty-printing"}, {"score": 0.004094639048362357, "phrase": "oppen's_pretty-printing_algorithm"}, {"score": 0.004024007169820807, "phrase": "haskell"}, {"score": 0.0035965032173588753, "phrase": "oppen's_imperative_solution"}, {"score": 0.003370565320453525, "phrase": "simpler_and_a_clear_structure"}, {"score": 0.0029126002350975634, "phrase": "lazy_evaluation"}, {"score": 0.0023970487263732737, "phrase": "higher-order_functions"}, {"score": 0.0021049977753042253, "phrase": "explicit_scheduling"}], "paper_keywords": [""], "paper_abstract": "We present two implementations of Oppen's pretty-printing algorithm in Haskell that meet the efficiency of Oppen's imperative Solution but have a simpler and a clear structure. We start with an implementation that uses lazy evaluation to simulate two co-operating processes. Then we present an implementation that uses higher-order functions for delimited continuations to simulate co-routines with explicit scheduling.", "paper_title": "Linear, bounded, functional pretty-printing", "paper_id": "WOS:000262322500001"}