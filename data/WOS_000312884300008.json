{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "concurrency_errors"}, {"score": 0.014389835652222679, "phrase": "concurrent_programs"}, {"score": 0.004761494044422926, "phrase": "object-oriented_programs"}, {"score": 0.004708651003872892, "phrase": "multicore"}, {"score": 0.00465634671242413, "phrase": "multi-threaded_processors"}, {"score": 0.004502943680955863, "phrase": "modern_processors"}, {"score": 0.0038725824361608243, "phrase": "concurrent_code"}, {"score": 0.003829548069657859, "phrase": "conventional_error_detection_methods"}, {"score": 0.0037658881407605445, "phrase": "model_checking"}, {"score": 0.003724034990158436, "phrase": "theorem_proving"}, {"score": 0.0036621225944272256, "phrase": "code_analysis"}, {"score": 0.0034437574674180365, "phrase": "indispensable_technique"}, {"score": 0.0032747835779400212, "phrase": "great_deal"}, {"score": 0.0032383707002544755, "phrase": "manual_work"}, {"score": 0.0030794433253250476, "phrase": "automatic_method"}, {"score": 0.0029612292670237505, "phrase": "object-oriented_languages"}, {"score": 0.0028635111041882956, "phrase": "heuristic_algorithm"}, {"score": 0.002800158709933889, "phrase": "test_cases"}, {"score": 0.0026478260192958924, "phrase": "test_case"}, {"score": 0.0025604233506352375, "phrase": "fast_method"}, {"score": 0.002475898613632249, "phrase": "actual_concurrency_error"}, {"score": 0.00244834685428352, "phrase": "anomalous_run_results"}, {"score": 0.002251227801482381, "phrase": "typical_java_classes"}, {"score": 0.0021049977753042253, "phrase": "previous_work"}], "paper_keywords": ["concurrency error", " dynamic test", " data race", " atomicity violations", " test case generation"], "paper_abstract": "Multicore and multi-threaded processors have become the norm for modern processors. Accordingly, concurrent programs have become more and more prevalent despite being difficult to write and understand. Although errors are highly likely to appear in concurrent code, conventional error detection methods such as model checking, theorem proving, and code analysis do not scale smoothly to concurrent programs. Testing is an indispensable technique for detecting concurrency errors, but it involves a great deal of manual work and is inefficient. This paper presents an automatic method for detecting concurrency errors in classes in object-oriented languages. The method uses a heuristic algorithm to automatically generate test cases that can effectively trigger errors. Then, each test case is executed automatically and a fast method is adopted to identify the actual concurrency error from anomalous run results. We have implemented a prototype of the method and applied it to some typical Java classes. Evaluation shows that our method is more effective and faster than previous work.", "paper_title": "An efficient method for detecting concurrency errors in object-oriented programs", "paper_id": "WOS:000312884300008"}