{"auto_keywords": [{"score": 0.04940203756018455, "phrase": "process-oriented_programming"}, {"score": 0.0416461944039994, "phrase": "concurrent_components"}, {"score": 0.00481495049065317, "phrase": "lightweight_communicating_processes"}, {"score": 0.004646496622257368, "phrase": "design_methodology"}, {"score": 0.004548253531664032, "phrase": "software_applications"}, {"score": 0.004389089062127892, "phrase": "concurrent_processes"}, {"score": 0.004296264970612285, "phrase": "typical_process-oriented_design"}, {"score": 0.004116440453049531, "phrase": "large_number"}, {"score": 0.004058180509184539, "phrase": "small_isolated_component_processes"}, {"score": 0.0038606630003037864, "phrase": "scalable_parallel_execution"}, {"score": 0.0037789720824759503, "phrase": "resulting_application"}, {"score": 0.0036990033106718183, "phrase": "shared-memory_and_distributed-memory_architectures"}, {"score": 0.00332375606483146, "phrase": "lightweight_processes"}, {"score": 0.0032766780632972363, "phrase": "communication_primitives"}, {"score": 0.0032073043728420817, "phrase": "runtime's_scheduler"}, {"score": 0.0031170783606525856, "phrase": "lock-free_algorithms"}, {"score": 0.0029441472095672397, "phrase": "multicore_systems"}, {"score": 0.0029024303666003153, "phrase": "heuristics_dynamically_group"}, {"score": 0.0028409576481842457, "phrase": "cache-affine_work_units"}, {"score": 0.0027218799769229596, "phrase": "work_units"}, {"score": 0.0026264601495742295, "phrase": "wait-free_work-stealing"}, {"score": 0.002342972434255588, "phrase": "process-oriented_software"}, {"score": 0.0021971473452127126, "phrase": "optimised_sequential_and_coarse-grain_threaded_designs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["Concurrency", " Multicore", " Process-oriented", " Scheduling"], "paper_abstract": "Process-oriented programming is a design methodology in which software applications are constructed from communicating concurrent processes. A typical process-oriented design involves the composition of a large number of small isolated component processes. These concurrent components allow for the scalable parallel execution of the resulting application on both shared-memory and distributed-memory architectures. In this paper we present a runtime designed to support process-oriented programming by providing lightweight processes and communication primitives. The runtime's scheduler, implemented using lock-free algorithms, automatically executes concurrent components in parallel on multicore systems. Heuristics dynamically group processes into cache-affine work units based on communication patterns. Work units are then distributed via wait-free work-stealing. Initial performance analysis shows that, using the algorithms presented in this paper, process-oriented software can execute with an efficiency approaching that of optimised sequential and coarse-grain threaded designs. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Multicore scheduling for lightweight communicating processes", "paper_id": "WOS:000303186500005"}