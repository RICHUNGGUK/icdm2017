{"auto_keywords": [{"score": 0.04902194563396072, "phrase": "iommu"}, {"score": 0.004772137871562584, "phrase": "employ_ring_buffers"}, {"score": 0.0044231966846655394, "phrase": "specific_memory_pages"}, {"score": 0.004211069233133584, "phrase": "buggy_drivers"}, {"score": 0.0040996651541091575, "phrase": "added_protection"}, {"score": 0.0036991458715587163, "phrase": "system_designers"}, {"score": 0.0034902664176377943, "phrase": "stale_information"}, {"score": 0.0034437574674180365, "phrase": "iotlb"}, {"score": 0.0033227310662785293, "phrase": "costly_invalidations"}, {"score": 0.0032492519841546682, "phrase": "high-bandwidth_devices"}, {"score": 0.003163212007747804, "phrase": "ssd_controllers"}, {"score": 0.0030656984915295275, "phrase": "circular_ring_buffers"}, {"score": 0.0027907771648224273, "phrase": "virtual_memory_page_table_hierarchy"}, {"score": 0.0026806139086152365, "phrase": "flat_table"}, {"score": 0.002621297299343551, "phrase": "exactly_one_iotlb_entry"}, {"score": 0.002574788013427524, "phrase": "new_translation"}, {"score": 0.0024620842899061614, "phrase": "explicit_invalidations"}, {"score": 0.002364865100579589, "phrase": "standard_networking_benchmarks"}, {"score": 0.002241171326888997, "phrase": "baseline_iommu"}, {"score": 0.0021049977753042253, "phrase": "iommu_protection"}], "paper_keywords": ["design", " experimentation", " performance", " I/O memory management unit"], "paper_abstract": "The IOMMU allows the OS to encapsulate I/O devices in their own virtual memory spaces, thus restricting their DMAs to specific memory pages. The OS uses the IOMMU to protect itself against buggy drivers and malicious/errant devices. But the added protection comes at a cost, degrading the throughput of I/O-intensive workloads by up to an order of magnitude. This cost has motivated system designers to trade off some safety for performance, e.g., by leaving stale information in the IOTLB for a while so as to amortize costly invalidations. We observe that high-bandwidth devices-like network and PCIe SSD controllers-interact with the OS via circular ring buffers that induce a sequential, predictable workload. We design a ring IOMMU (rIOMMU) that leverages this characteristic by replacing the virtual memory page table hierarchy with a circular, flat table. A flat table is adequately supported by exactly one IOTLB entry, making every new translation an implicit invalidation of the former and thus requiring explicit invalidations only at the end of I/O bursts. Using standard networking benchmarks, we show that rIOMMU provides up to 7.56x higher throughput relative to the baseline IOMMU, and that it is within 0.77-1.00x the throughput of a system without IOMMU protection.", "paper_title": "rIOMMU: Efficient IOMMU for I/O Devices that Employ Ring Buffers", "paper_id": "WOS:000370874900025"}