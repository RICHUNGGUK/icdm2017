{"auto_keywords": [{"score": 0.049613254104042076, "phrase": "high-level_languages"}, {"score": 0.00481495049065317, "phrase": "automatic_generation_of_library_bindings_using_static_analysis"}, {"score": 0.004540591176992658, "phrase": "c_software_development"}, {"score": 0.004474468584252318, "phrase": "large_libraries"}, {"score": 0.004240116703465252, "phrase": "cross-language_bindings"}, {"score": 0.004178351419209898, "phrase": "low-level_c_code"}, {"score": 0.0038261310307416475, "phrase": "mainstream_binding_generators"}, {"score": 0.0037888687452790953, "phrase": "extensive_manual_annotation"}, {"score": 0.0035902958977673313, "phrase": "modern_languages"}, {"score": 0.0034355662264234864, "phrase": "improved_binding-generation_strategy"}, {"score": 0.0033361232750221863, "phrase": "unannotated_library_source_code"}, {"score": 0.0031612033120065747, "phrase": "c's_low-level_type_system"}, {"score": 0.0028944757265206332, "phrase": "interprocedural_analyses"}, {"score": 0.002838319783373086, "phrase": "high-level_information"}, {"score": 0.002663208600887875, "phrase": "binding_generator"}, {"score": 0.0026243534128245886, "phrase": "python_programming_language"}, {"score": 0.0024264776194357993, "phrase": "hand-written_bindings"}, {"score": 0.002356173823922118, "phrase": "python_integration"}, {"score": 0.002321787726770895, "phrase": "prior_automated_approaches"}, {"score": 0.0022216045996270974, "phrase": "public_interfaces"}], "paper_keywords": ["Languages", " Reliability", " Experiments", " Human Factors", " FFI", " foreign function interfaces", " bindings", " libraries", " dataflow analysis", " modular static program analysis", " multi-language code reuse"], "paper_abstract": "High-level languages are growing in popularity. However, decades of C software development have produced large libraries of fast, time-tested, meritorious code that are impractical to recreate from scratch. Cross-language bindings can expose low-level C code to high-level languages. Unfortunately, writing bindings by hand is tedious and error-prone, while mainstream binding generators require extensive manual annotation or fail to offer the language features that users of modern languages have come to expect. We present an improved binding-generation strategy based on static analysis of unannotated library source code. We characterize three high-level idioms that are not uniquely expressible in C's low-level type system: array parameters, resource managers, and multiple return values. We describe a suite of interprocedural analyses that recover this high-level information, and we show how the results can be used in a binding generator for the Python programming language. In experiments with four large C libraries, we find that our approach avoids the mistakes characteristic of hand-written bindings while offering a level of Python integration unmatched by prior automated approaches. Among the thousands of functions in the public interfaces of these libraries, roughly 40% exhibit the behaviors detected by our static analyses.", "paper_title": "Automatic Generation of Library Bindings Using Static Analysis", "paper_id": "WOS:000267268400031"}