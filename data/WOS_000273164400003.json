{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "evaluating_complex_polynomials"}, {"score": 0.00471700544744796, "phrase": "efficient_hardware-oriented_method"}, {"score": 0.004416713079266374, "phrase": "linear_equations"}, {"score": 0.004204054047427536, "phrase": "simple_and_highly_regular_hardware"}, {"score": 0.003920128102807887, "phrase": "-real_transform"}, {"score": 0.0038720442355114045, "phrase": "complex_polynomial_evaluation_algorithm"}, {"score": 0.003824547895167011, "phrase": "convergence_conditions"}, {"score": 0.0035079364710988627, "phrase": "main_features"}, {"score": 0.0033388871136347704, "phrase": "m-bit_precision"}, {"score": 0.0031518989079229714, "phrase": "identical_modules"}, {"score": 0.0029027394930867902, "phrase": "serial-parallel_multiplier"}, {"score": 0.002867098884583832, "phrase": "carry-propagate_adder"}, {"score": 0.0027514186391258263, "phrase": "n-th_degree_complex_polynomial"}, {"score": 0.002629539710839523, "phrase": "successive_integer_powers"}, {"score": 0.0025972447844047515, "phrase": "complex_argument"}, {"score": 0.0025338369486914364, "phrase": "similar_implementation_cost"}, {"score": 0.0024821782596371536, "phrase": "straightforward_tradeoffs"}, {"score": 0.002166607745253829, "phrase": "proposed_method"}, {"score": 0.0021311850321045767, "phrase": "programmable_platforms"}], "paper_keywords": ["Complex polynomials", " Complex powers", " Complex-to-real transform", " Digit-by-digit algorithms", " Left-to-right evaluation"], "paper_abstract": "We propose an efficient hardware-oriented method for evaluating complex polynomials. The method is based on solving iteratively a system of linear equations. The solutions are obtained digit-by-digit on simple and highly regular hardware. The operations performed are defined over the reals. We describe a complex-to-real transform, a complex polynomial evaluation algorithm, the convergence conditions, and a corresponding design and implementation. The latency and the area are estimated for the radix-2 case. The main features of the method are: the latency of about m cycles for an m-bit precision; the cycle time independent of the precision; a design consisting of identical modules; and digit-serial connections between the modules. The number of modules, each roughly corresponding to serial-parallel multiplier without a carry-propagate adder, is 2(n + 1) for evaluating an n-th degree complex polynomial. The method can also be used to compute all successive integer powers of the complex argument with the same latency and a similar implementation cost. The design allows straightforward tradeoffs between latency and cost: a factor k decrease in cost leads to a factor k increase in latency. A similar tradeoff between precision, latency and cost exists. The proposed method is attractive for programmable platforms because of its regular and repetitive structure of simple hardware operators.", "paper_title": "An Efficient Method for Evaluating Complex Polynomials", "paper_id": "WOS:000273164400003"}