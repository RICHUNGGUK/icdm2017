{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "copattern_matching"}, {"score": 0.04819593306799231, "phrase": "expression_problem"}, {"score": 0.044975450332370666, "phrase": "first-class_functions"}, {"score": 0.0035778632599436024, "phrase": "higher-order_functions"}, {"score": 0.003071429173571846, "phrase": "full_defunctionalization"}, {"score": 0.0029504765287722465, "phrase": "codata_language"}, {"score": 0.0028115863316685937, "phrase": "data_language"}, {"score": 0.0027446057983474994, "phrase": "pattern_matching"}, {"score": 0.0021049977753042253, "phrase": "matrix_transposition"}], "paper_keywords": ["Defunctionalization", " Refunctionalization", " Codata", " Copattern Matching", " Uroboro", " Expression Problem"], "paper_abstract": "Defunctionalization and refunctionalization establish a correspondence between first-class functions and pattern matching, but the correspondence is not symmetric: Not all uses of pattern matching can be automatically refunctionalized to uses of higher-order functions. To remedy this asymmetry, we generalize from first-class functions to arbitrary codata. This leads us to full defunctionalization and refunctionalization between a codata language based on copattern matching and a data language based on pattern matching. We observe how programs can be written as matrices so that they are modularly extensible in one dimension but not the other. In this representation, defunctionalization and refunctionalization correspond to matrix transposition which effectively changes the dimension of extensibility a program supports. This suggests applications to the expression problem.", "paper_title": "Automatic Refunctionalization to a Language with Copattern Matching With Applications to the Expression Problem", "paper_id": "WOS:000367255800024"}