{"auto_keywords": [{"score": 0.03185896123808046, "phrase": "autoepistemic_logic"}, {"score": 0.02929712519086578, "phrase": "logic_programming"}, {"score": 0.00481495049065317, "phrase": "fixpoint_semantics"}, {"score": 0.004552981066668676, "phrase": "\"predicate_introduction"}, {"score": 0.004494570360108983, "phrase": "non-monotonic_logics"}, {"score": 0.004268293864953256, "phrase": "complex_formula"}, {"score": 0.004106063237069123, "phrase": "knowledge_representation_perspective"}, {"score": 0.003577414339646767, "phrase": "normal_form"}, {"score": 0.003382547312072468, "phrase": "predicate_introduction"}, {"score": 0.0033391018638565715, "phrase": "algebraic_framework"}, {"score": 0.003310447652300423, "phrase": "\"approximation_theory"}, {"score": 0.0032259472087775138, "phrase": "fixpoint_theory"}, {"score": 0.0031982609080278643, "phrase": "nonmonotone_operators"}, {"score": 0.0031435968684569112, "phrase": "main_semantics"}, {"score": 0.003037047249598515, "phrase": "default_logic"}, {"score": 0.0025230952890994236, "phrase": "general_method"}, {"score": 0.0024906610581090223, "phrase": "universal_quantifiers"}, {"score": 0.002294686545883412, "phrase": "companion_paper"}, {"score": 0.002132420504803564, "phrase": "nesting_depth"}, {"score": 0.0021049977753042253, "phrase": "modal_operator"}], "paper_keywords": [""], "paper_abstract": "We study the transformation of \"predicate introduction\" in non-monotonic logics. By this, we mean the act of replacing a complex formula by a newly defined predicate. From a knowledge representation perspective, such transformations can be used to eliminate redundancy or to simplify a theory. From a more practical point of view, they can also be used to transform a theory into a normal form imposed by certain inference programs or theorems. In this paper, we study predicate introduction in the algebraic framework of \"approximation theory\"; this is a fixpoint theory for nonmonotone operators that generalizes all main semantics of various non-monotonic logics, including logic programming, default logic and autoepistemic logic. We prove an abstract, algebraic equivalence result in this framework. This can then be used to show that, in logic programming, certain transformations are equivalence preserving under, among others, both the stable and well-founded semantics. Based on this result, we develop a general method of eliminating universal quantifiers in the bodies of rules. Our work is, however, also applicable beyond logic programming. In a companion paper, we demonstrate this, by using the same algebraic results to derive a transformation which reduces the nesting depth of the modal operator K in autoepistemic logic.", "paper_title": "Predicate introduction for logics with a fixpoint semantics. Part I: Logic programming", "paper_id": "WOS:000250383000009"}