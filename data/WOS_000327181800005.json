{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "software_measurement"}, {"score": 0.0046937237797352515, "phrase": "software_architecture"}, {"score": 0.004552255360140208, "phrase": "fundamental_organization"}, {"score": 0.004216880725292, "phrase": "system's_environment"}, {"score": 0.0040481944502103505, "phrase": "system's_design"}, {"score": 0.003807684498435389, "phrase": "large_software_system"}, {"score": 0.003711723285313348, "phrase": "holistic_model"}, {"score": 0.0036553070575015344, "phrase": "continuous_integration"}, {"score": 0.003563172322934695, "phrase": "system_artifacts"}, {"score": 0.003509006038574667, "phrase": "earlier_papers"}, {"score": 0.003438058620195309, "phrase": "unified_graph-based_approach"}, {"score": 0.0032336801561165113, "phrase": "software_system"}, {"score": 0.0030569913145731408, "phrase": "convenient_and_efficient_project_measurement"}, {"score": 0.002949598537993663, "phrase": "existing_software_metrics"}, {"score": 0.0027459678326877744, "phrase": "programming_language"}, {"score": 0.0026630475331025955, "phrase": "new_metrics"}, {"score": 0.0026091594819333654, "phrase": "programming_language_boundaries"}, {"score": 0.0024289743270061157, "phrase": "new_model"}, {"score": 0.002367676766637248, "phrase": "existing_tools"}, {"score": 0.0023079225317714815, "phrase": "graph_databases"}, {"score": 0.002272794656458419, "phrase": "convenient_implementation"}, {"score": 0.0022382002476510573, "phrase": "architectural_repository"}, {"score": 0.0022154296909169826, "phrase": "graph_query_languages"}, {"score": 0.0021928902836049384, "phrase": "graph_algorithms"}, {"score": 0.0021595094738887767, "phrase": "effective_way"}, {"score": 0.0021049977753042253, "phrase": "specialized_graph_views"}], "paper_keywords": ["software measurement", " architectural knowledge", " software architecture"], "paper_abstract": "The software architecture is typically defined as the fundamental organization of the system embodied in its components, their relationships to one another and to the system's environment. It also encompases principles governing the system's design and evolution. In order to manage the architecture of a large software system the architect needs a holistic model that supports continuous integration and verification for all system artifacts. In earlier papers we proposed a unified graph-based approach to the problem of managing knowledge about the architecture of a software system. In this paper we demonstrate that this approach facilitates convenient and efficient project measurement. First, we show how existing software metrics can be translated into our model in a way that is independent of the programming language. Second, we introduce new metrics that cross the programming language boundaries and are easily implementable using our approach. We conclude by demonstrating how the new model can be implemented using existing tools. In particular, graph databases are a convenient implementation of an architectural repository. Graph query languages and graph algorithms are an effective way to define metrics and specialized graph views.", "paper_title": "One Graph to Rule Them All Software Measurement and Management", "paper_id": "WOS:000327181800005"}