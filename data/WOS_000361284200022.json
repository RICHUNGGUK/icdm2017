{"auto_keywords": [{"score": 0.049675053299362504, "phrase": "input-output_examples"}, {"score": 0.00481495049065317, "phrase": "data_structure_transformations"}, {"score": 0.004634799977448855, "phrase": "example-guided_synthesis"}, {"score": 0.004537631845923196, "phrase": "recursive_data_structures"}, {"score": 0.004258128672571261, "phrase": "functional_language"}, {"score": 0.00422218060227958, "phrase": "higher-order_combinators"}, {"score": 0.004098725744818192, "phrase": "synthesized_program"}, {"score": 0.003995772867224968, "phrase": "simplest_program"}, {"score": 0.0034445472801689046, "phrase": "target_program"}, {"score": 0.003245900020944865, "phrase": "missing_subexpressions"}, {"score": 0.0031643005824589917, "phrase": "new_subproblem"}, {"score": 0.002762423953243486, "phrase": "best-first_enumeration"}, {"score": 0.0024320326084093465, "phrase": "large_set"}, {"score": 0.0024114635128122783, "phrase": "synthesis_problems"}, {"score": 0.0023408288327263316, "phrase": "nested_data_structures"}, {"score": 0.0022626276288355432, "phrase": "broad_scope"}, {"score": 0.0021049977753042253, "phrase": "world's_earliest_functional_pearl"}], "paper_keywords": ["Program synthesis", " programming by example", " data transformations", " search-based synthesis", " automated deduction"], "paper_abstract": "We present a method for example-guided synthesis of functional programs over recursive data structures. Given a set of input-output examples, our method synthesizes a program in a functional language with higher-order combinators like map and fold. The synthesized program is guaranteed to be the simplest program in the language to fit the examples. Our approach combines three technical ideas: inductive generalization, deduction, and enumerative search. First, we generalize the input-output examples into hypotheses about the structure of the target program. For each hypothesis, we use deduction to infer new input/output examples for the missing subexpressions. This leads to a new subproblem where the goal is to synthesize expressions within each hypothesis. Since not every hypothesis can be realized into a program that fits the examples, we use a combination of best-first enumeration and deduction to search for a hypothesis that meets our needs. We have implemented our method in a tool called lambda(2), and we evaluate this tool on a large set of synthesis problems involving lists, trees, and nested data structures. The experiments demonstrate the scalability and broad scope of lambda(2). A highlight is the synthesis of a program believed to be the world's earliest functional pearl.", "paper_title": "Synthesizing Data Structure Transformations from Input-Output Examples", "paper_id": "WOS:000361284200022"}