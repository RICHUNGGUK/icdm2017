{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "kinetic_facility_location"}, {"score": 0.00468991337957911, "phrase": "deterministic_kinetic_data_structure"}, {"score": 0.0046164478775379105, "phrase": "facility_location_problem"}, {"score": 0.004449452743965974, "phrase": "moving_points"}, {"score": 0.004155113657645735, "phrase": "accumulated_cost"}, {"score": 0.004089991141220082, "phrase": "whole_point"}, {"score": 0.003941964605885606, "phrase": "optimal_cost"}, {"score": 0.0035665344993417603, "phrase": "known_trajectory"}, {"score": 0.0035106041824568618, "phrase": "d-dimensional_euclidean_space"}, {"score": 0.0023516185395256505, "phrase": "maintenance_cost"}, {"score": 0.0021049977753042253, "phrase": "bounded_degree_polynomial"}], "paper_keywords": ["Facility location", " Kinetic data structure", " Approximation algorithm", " Deterministic algorithm"], "paper_abstract": "We present a deterministic kinetic data structure for the facility location problem that maintains a subset of the moving points as facilities such that, at any point of time, the accumulated cost for the whole point set is at most a constant factor larger than the optimal cost. In our scenario, each point can change its status between client and facility and moves continuously along a known trajectory in a d-dimensional Euclidean space, where d is a constant. Our kinetic data structure requires O(n(log(d)(n)+ log(nR))) space in total, where R := max(pi is an element of P) f(i).max(pi is an element of P)d(i)/min(pi is an element of P) f(i).min(pi is an element of P) d(i), P = {p(1), p(2), ... , p(n)} is the set of given points, and f(i), d(i) are the maintenance cost and the demand of a point pi, respectively. In case that each trajectory can be described by a bounded degree polynomial, we process O(n(2) log(2)(nR)) events, each requiring O(log(d+1)(n).log(nR)) time and O(log(nR)) status changes.", "paper_title": "Kinetic Facility Location", "paper_id": "WOS:000276265300008"}