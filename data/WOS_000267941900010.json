{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "fused_multiply-add"}, {"score": 0.004693476992528682, "phrase": "cody_and_waite_argument_reduction_technique"}, {"score": 0.004536244367689415, "phrase": "reasonably_large_arguments"}, {"score": 0.0037928847801943404, "phrase": "mild_assumptions"}, {"score": 0.003394891095032025, "phrase": "fully_accurate_result"}, {"score": 0.003038532168038562, "phrase": "full_working_precision"}, {"score": 0.0028139168128067343, "phrase": "fully_accurate_second_reduction_step"}, {"score": 0.002742787059497186, "phrase": "full_double_accuracy"}, {"score": 0.0024969812322112174, "phrase": "worst_cases"}, {"score": 0.0024547103576350233, "phrase": "argument_reduction"}, {"score": 0.00235213013487844, "phrase": "common_algorithms"}, {"score": 0.0021049977753042253, "phrase": "coq_automatic_proof_checker"}], "paper_keywords": ["Argument reduction", " fma", " formal proof", " Coq"], "paper_abstract": "The Cody and Waite argument reduction technique works perfectly for reasonably large arguments, but as the input grows, there are no bits left to approximate the constant with enough accuracy. Under mild assumptions, we show that the result computed with a fused multiply-add provides a fully accurate result for many possible values of the input with a constant almost accurate to the full working precision. We also present an algorithm for a fully accurate second reduction step to reach full double accuracy (all the significand bits of two numbers are accurate) even in the worst cases of argument reduction. Our work recalls the common algorithms and presents proofs of correctness. All the proofs are formally verified using the Coq automatic proof checker.", "paper_title": "Formally Verified Argument Reduction with a Fused Multiply-Add", "paper_id": "WOS:000267941900010"}