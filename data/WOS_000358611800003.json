{"auto_keywords": [{"score": 0.044476153128415595, "phrase": "thread_interleavings"}, {"score": 0.008772605436702793, "phrase": "simple_pattern"}, {"score": 0.00481495049065317, "phrase": "latent_data_races_cross-thread_interleaving"}, {"score": 0.004662705558154439, "phrase": "multi-threaded_applications"}, {"score": 0.004044064541716598, "phrase": "interleaving-insensitive_detection"}, {"score": 0.0038981499110532273, "phrase": "uniform_detection"}, {"score": 0.0035722806911457545, "phrase": "false_positives"}, {"score": 0.0035072146967082083, "phrase": "prohibitive_overhead"}, {"score": 0.0029586543333524904, "phrase": "lock_synchronizations"}, {"score": 0.002878140062594849, "phrase": "brief_study"}, {"score": 0.002825681384008326, "phrase": "new_and_complex_pattern"}, {"score": 0.0025420267431501367, "phrase": "simple_processing"}, {"score": 0.0024956789310376635, "phrase": "big_profit"}, {"score": 0.002461472107682778, "phrase": "previous_reordering-based_design"}, {"score": 0.0023079225317714815, "phrase": "execution_time"}, {"score": 0.00226583335721762, "phrase": "trace_size"}, {"score": 0.002224510044064184, "phrase": "stateof-the-art_reordering_technique"}, {"score": 0.002163930783583212, "phrase": "quick_filtering"}], "paper_keywords": ["data race", " happens-before", " thread interleaving"], "paper_abstract": "Data races are ubiquitous in multi-threaded applications, but they are by no means easy to detect. One of the most important reasons is the complexity of thread interleavings. A volume of research has been devoted to the interleaving-insensitive detection. However, all the previous work focuses on the uniform detection (unknown to the characteristics of thread interleavings), thereby making the detection defective in either reporting false positives or suffering from prohibitive overhead. To cope with the problem above, we propose an efficient, precise, and sound step-by-step resolution based on the characteristics of thread interleavings. We first try to tease apart the categories of thread interleavings from the several typical sources arising from the lock synchronizations. We then conduct a brief study and find a new and complex pattern the previous work cannot detect. It is also revealed that the simple pattern with the majority of thread interleavings can be resolved by a simple processing to achieve a big profit for the previous reordering-based design. Our final experimental results demonstrate the effectiveness of our empiricism-based approach, and show that 51.0% of execution time and 52.3% of trace size arising from the stateof-the-art reordering technique can be saved through a quick filtering of the simple pattern with a negligible (4.45%) performance overhead introduced on-the-fly.", "paper_title": "Understanding and identifying latent data races cross-thread interleaving", "paper_id": "WOS:000358611800003"}