{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "user_interfaces"}, {"score": 0.04504125061239473, "phrase": "user_interface_elements"}, {"score": 0.03821066921635996, "phrase": "property_models"}, {"score": 0.0047268728636719725, "phrase": "modern_applications"}, {"score": 0.004640398886726948, "phrase": "rich_set"}, {"score": 0.004597754207658615, "phrase": "interactive_features"}, {"score": 0.004058826900076531, "phrase": "application_programming_effort"}, {"score": 0.0038935506745975835, "phrase": "resulting_code"}, {"score": 0.0035828427627676075, "phrase": "large_part"}, {"score": 0.003484864867147635, "phrase": "user_interface"}, {"score": 0.0034052594710793664, "phrase": "reusable_libraries"}, {"score": 0.003358368814209542, "phrase": "application_specific_code"}, {"score": 0.003281643474564305, "phrase": "declarative_rules"}, {"score": 0.002991823455621222, "phrase": "accurate_information"}, {"score": 0.002950608985750058, "phrase": "currently_active_dependencies"}, {"score": 0.0027784560880013886, "phrase": "user_interface_functionality"}, {"score": 0.002702415623060517, "phrase": "generic_algorithms"}, {"score": 0.0025329623864528317, "phrase": "user_interface_widgets"}, {"score": 0.0024865237976623286, "phrase": "command_widgets"}, {"score": 0.002363150587804677, "phrase": "common_source"}, {"score": 0.002341384304635523, "phrase": "user-interface_defects"}, {"score": 0.002225196379204285, "phrase": "increased_reuse"}, {"score": 0.002204697943520258, "phrase": "reduced_defect_rates"}, {"score": 0.0021049977753042253, "phrase": "commercial_software_development_effort"}], "paper_keywords": ["Algorithms", " Design", " Software reuse", " Component software", " User interfaces", " Declarative specifications", " Constraint systems"], "paper_abstract": "User interfaces for modern applications must support a rich set of interactive features. It is commonplace to find applications with dependencies between values manipulated by user interface elements, conditionally enabled controls, and script record-ability and playback against different documents. A significant fraction of the application programming effort is devoted to implementing such functionality, and the resulting code is typically not reusable. This paper extends our \"property models\" approach to programming user interfaces. Property models allow a large part of the functionality of a user interface to be implemented in reusable libraries, reducing application specific code to a set of declarative rules. We describe how, as a by-product of computations that maintain the values of user interface elements, property models obtain accurate information of the currently active dependencies among those elements. This information enables further expanding the class of user interface functionality that we can encode as generic algorithms. In particular, we describe automating the decisions for the enablement of user interface widgets and activation of command widgets. Failing to disable or deactivate widgets correctly is a common source of user-interface defects, which our approach largely removes. We report on the increased reuse, reduced defect rates, and improved user interface design turnarounds in a commercial software development effort as a result of adopting our approach.", "paper_title": "Algorithms for User Interfaces", "paper_id": "WOS:000280547600016"}