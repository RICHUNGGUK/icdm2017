{"auto_keywords": [{"score": 0.03455018268948868, "phrase": "lam"}, {"score": 0.004736045157669388, "phrase": "approximate_overlaps"}, {"score": 0.004658426838467567, "phrase": "first_phase"}, {"score": 0.004408729661992651, "phrase": "total_length_n"}, {"score": 0.00433645229352341, "phrase": "error-rate_epsilon"}, {"score": 0.003820144626025562, "phrase": "edit_distance"}, {"score": 0.003757480190200645, "phrase": "inverted_right_perpendicular_epsilon"}, {"score": 0.003421245054271364, "phrase": "new_solution"}, {"score": 0.003309877074892399, "phrase": "backward_backtracking"}, {"score": 0.0027286224888843956, "phrase": "k-th_order_entropy"}, {"score": 0.0026986685585382347, "phrase": "sigma_the_alphabet_size"}, {"score": 0.0023900527169254744, "phrase": "q-gram_filters"}, {"score": 0.0021049977753042253, "phrase": "dna_reads"}], "paper_keywords": ["Suffix/prefix matching", " Approximate pattern matching"], "paper_abstract": "Finding approximate overlaps is the first phase of many sequence assembly methods. Given a set of strings of total length n and an error-rate epsilon, the goal is to find, for all-pairs of strings, their suffix/prefix matches (overlaps) that are within edit distance k = inverted right perpendicular epsilon linverted left perpendicular, where e is the length of the overlap. We propose a new solution for this problem based on backward backtracking (Lam, et al., 2008) and suffix filters (Karkkainen and Na, 2008). Our technique uses nH(k) + o(n log sigma) + r log r bits of space, where H-k is the k-th order entropy and sigma the alphabet size. In practice, it is more scalable in terms of space, and comparable in terms of time, than q-gram filters (Rasmussen, et al., 2006). Our method is also easy to parallelize and scales up to millions of DNA reads. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "Approximate all-pairs suffix/prefix overlaps", "paper_id": "WOS:000301904700006"}