{"auto_keywords": [{"score": 0.049655608595442394, "phrase": "stack-based_control_abstractions"}, {"score": 0.04580340075872882, "phrase": "stack_cutting"}, {"score": 0.04445718982496921, "phrase": "thread_context_switch"}, {"score": 0.00481495049065317, "phrase": "assembly_code"}, {"score": 0.004730512437775877, "phrase": "runtime"}, {"score": 0.004667541072056214, "phrase": "critical_components"}, {"score": 0.004605748839642513, "phrase": "modern_software"}, {"score": 0.004484596684703308, "phrase": "powerful_control_structures"}, {"score": 0.00421410521089045, "phrase": "stack_operations"}, {"score": 0.003959863717046575, "phrase": "known_formal_specifications"}, {"score": 0.003606890001721832, "phrase": "pcc"}, {"score": 0.003527550673371394, "phrase": "code_pointers"}, {"score": 0.0034963129868796033, "phrase": "exception_handlers"}, {"score": 0.003434662174045939, "phrase": "general_first-class_functions"}, {"score": 0.003374094774912924, "phrase": "continuation-passing_style"}, {"score": 0.0030868583963299698, "phrase": "general_first-class_code_pointers"}, {"score": 0.0030189426536422577, "phrase": "simple_but_flexible_hoare-style_framework"}, {"score": 0.002874726518572154, "phrase": "stackbased_control_abstractions"}, {"score": 0.002811464848641341, "phrase": "tail_call"}, {"score": 0.002761856557698856, "phrase": "weak_continuation"}, {"score": 0.0027131212233443137, "phrase": "stack_unwinding"}, {"score": 0.002689076130099546, "phrase": "multi-return_function_call"}, {"score": 0.0025605773834404253, "phrase": "specific_logic"}, {"score": 0.0025266078302900036, "phrase": "control_structure"}, {"score": 0.002470987929071079, "phrase": "reasoning_systems"}, {"score": 0.00241658945942583, "phrase": "generic_framework"}, {"score": 0.0023739321566540682, "phrase": "program_modules"}, {"score": 0.002321665383971456, "phrase": "different_pcc_systems"}, {"score": 0.0021813467128927347, "phrase": "complete_soundness_proof"}, {"score": 0.002152397315548125, "phrase": "full_verification"}, {"score": 0.0021049977753042253, "phrase": "coq_proof_assistant"}], "paper_keywords": ["assembly code verification", " modularity", " stack-based control abstractions", " proof-carrying code"], "paper_abstract": "Runtime stacks are critical components of any modern software they are used to implement powerful control structures such as function call/return, stack cutting and unwinding, coroutines, and thread context switch. Stack operations, however, are very hard to reason about: there are no known formal specifications for certifying C-style setjmp/longjmp, stack cutting and unwinding, or weak continuations ( in C--). In many proof-carrying code (PCC) systems, return code pointers and exception handlers are treated as general first-class functions ( as in continuation-passing style) even though both should have more limited scopes. In this paper we show that stack-based control abstractions follow a much simpler pattern than general first-class code pointers. We present a simple but flexible Hoare-style framework for modular verification of assembly code with all kinds of stackbased control abstractions, including function call/return, tail call, setjmp/longjmp, weak continuation, stack cutting, stack unwinding, multi-return function call, coroutines, and thread context switch. Instead of presenting a specific logic for each control structure, we develop all reasoning systems as instances of a generic framework. This allows program modules and their proofs developed in different PCC systems to be linked together. Our system is fully mechanized. We give the complete soundness proof and a full verification of several examples in the Coq proof assistant.", "paper_title": "Modular verification of assembly code with stack-based control abstractions", "paper_id": "WOS:000202972100035"}