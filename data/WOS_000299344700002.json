{"auto_keywords": [{"score": 0.030008161744448727, "phrase": "pearl-necklace_encoder"}, {"score": 0.027101864185063378, "phrase": "longest_path"}, {"score": 0.00481495049065317, "phrase": "pearl-necklace_encoders"}, {"score": 0.0047732596509542135, "phrase": "quantum_convolutional_codes"}, {"score": 0.004670597652149685, "phrase": "major_goals"}, {"score": 0.004630150894006861, "phrase": "quantum_information_processing"}, {"score": 0.0044524122425287005, "phrase": "practical_implementation"}, {"score": 0.004413846562278824, "phrase": "quantum_protocols"}, {"score": 0.00428146713705618, "phrase": "quantum_error_correction_account"}, {"score": 0.004135010810625326, "phrase": "particular_technique"}, {"score": 0.004099183062034004, "phrase": "quantum_error_correction"}, {"score": 0.003924629168434799, "phrase": "quantum_information"}, {"score": 0.0038906171474520756, "phrase": "quantum_convolutional_coding"}, {"score": 0.0037903327482565097, "phrase": "quantum_convolutional_code"}, {"score": 0.0036926236934657864, "phrase": "convolutional_encoder"}, {"score": 0.0036288825833675127, "phrase": "\"pearl-necklace\"_encoder"}, {"score": 0.0035662378173267647, "phrase": "pearl-necklace_representation"}, {"score": 0.0034143003168921114, "phrase": "research_literature"}, {"score": 0.0029961221584602405, "phrase": "acyclic_graph"}, {"score": 0.002868404184756447, "phrase": "gate_string"}, {"score": 0.002686935113435742, "phrase": "noncommuting_gates"}, {"score": 0.002462664392109308, "phrase": "minimal_amount"}, {"score": 0.002357632753637638, "phrase": "dynamic_programming_search"}, {"score": 0.002266931093770838, "phrase": "running_time"}, {"score": 0.0021049977753042253, "phrase": "gate_strings"}], "paper_keywords": ["Quantum communication", " quantum convolutional codes", " quantum shift register circuits", " quantum error correction"], "paper_abstract": "One of the major goals in quantum information processing is to reduce the overhead associated with the practical implementation of quantum protocols, and often, routines for quantum error correction account for most of this overhead. A particular technique for quantum error correction that may be useful for protecting a stream of quantum information is quantum convolutional coding. The encoder for a quantum convolutional code has a representation as a convolutional encoder or as a \"pearl-necklace\" encoder. In the pearl-necklace representation, it has not been particularly clear in the research literature how much quantum memory such an encoder would require for implementation. Here, we offer an algorithm that answers this question. The algorithm first constructs a weighted, directed acyclic graph where each vertex of the graph corresponds to a gate string in the pearl-necklace encoder, and each path through the graph represents a path through noncommuting gates in the encoder. We show that the weight of the longest path through the graph is equal to the minimal amount of memory needed to implement the encoder. A dynamic programming search through this graph determines the longest path. The running time for the construction of the graph and search through it is quadratic in the number of gate strings in the pearl-necklace encoder.", "paper_title": "Minimal-Memory Requirements for Pearl-Necklace Encoders of Quantum Convolutional Codes", "paper_id": "WOS:000299344700002"}