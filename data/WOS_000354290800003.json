{"auto_keywords": [{"score": 0.029420333683948755, "phrase": "policy_iteration"}, {"score": 0.00481495049065317, "phrase": "policy_iterations"}, {"score": 0.004598933498016774, "phrase": "game_theory"}, {"score": 0.004359078118356132, "phrase": "numerical_optimization_queries"}, {"score": 0.003797978200741566, "phrase": "static_analysis"}, {"score": 0.0032585499655442404, "phrase": "highly_numerical_codes"}, {"score": 0.0030648097361278856, "phrase": "control_command_applications"}, {"score": 0.0025110337774260773, "phrase": "required_steps"}, {"score": 0.002453934333239467, "phrase": "automatic_use"}, {"score": 0.0023435920614377306, "phrase": "numerical_templates"}, {"score": 0.0022211005680689666, "phrase": "analyzed_program"}, {"score": 0.0021049977753042253, "phrase": "numerical_solvers"}], "paper_keywords": ["Policy iterations", " Abstract interpretation", " Static analysis", " Quadratic templates", " Ellipsoids", " Lyapunov functions", " Widening", " Controllers"], "paper_abstract": "Policy iterations is a technique based on game theory that relies on a sequence of numerical optimization queries to compute the fixpoint of a set of equations. It has been proposed to support the static analysis of programs as an alternative to widening, when the latter is ineffective. This happens for instance with highly numerical codes, such as found at cores of control command applications. In this paper we present a complete, yet practical, description of the use of policy iteration in this context. We recall the rationale behind policy iteration and address required steps towards an automatic use of it: synthesis of numerical templates, floating point semantics of the analyzed program and issues with the accuracy of numerical solvers.", "paper_title": "Practical policy iterations", "paper_id": "WOS:000354290800003"}