{"auto_keywords": [{"score": 0.041170637589374566, "phrase": "test_sequences"}, {"score": 0.01557604867641885, "phrase": "functional_testing"}, {"score": 0.010387359519711026, "phrase": "experimental_analysis"}, {"score": 0.00481495049065317, "phrase": "test_sequence_generation"}, {"score": 0.004617949594931096, "phrase": "dynamic_test_sequences"}, {"score": 0.004554082077300675, "phrase": "formal_specification"}, {"score": 0.004491093879657087, "phrase": "traditional_testing_methods"}, {"score": 0.00432733352307636, "phrase": "source_code"}, {"score": 0.004092774981286263, "phrase": "classification_tree_method"}, {"score": 0.00398028819691605, "phrase": "transition_information"}, {"score": 0.0038350877633606052, "phrase": "ctm"}, {"score": 0.003678023470672862, "phrase": "combinatorial_testing_method"}, {"score": 0.0035603115570447467, "phrase": "minimal_test_sequences"}, {"score": 0.0034947408949397127, "phrase": "demanded_coverage_criteria"}, {"score": 0.003446353878654566, "phrase": "np-hard_problem"}, {"score": 0.0033828748627992193, "phrase": "search-based_approaches"}, {"score": 0.003244275497488318, "phrase": "optimal_test_sequences"}, {"score": 0.003125835572347772, "phrase": "search-based_technique"}, {"score": 0.0030825404960282713, "phrase": "greedy_algorithm"}, {"score": 0.0027188259793109264, "phrase": "shortest_valid_path"}, {"score": 0.0026811531172346676, "phrase": "full_class"}, {"score": 0.0025474193855847074, "phrase": "extended_classification_tree"}, {"score": 0.002331909406363425, "phrase": "greedy_deterministic_approach"}, {"score": 0.0022467024793003812, "phrase": "presented_algorithms"}, {"score": 0.0021848422732893926, "phrase": "professional_tool"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Functional testing", " Classification Tree Method", " Test sequence generation", " Search Based Software Engineering", " Genetic Algorithm", " Ant Colony Optimization"], "paper_abstract": "Context: The generation of dynamic test sequences from a formal specification, complementing traditional testing methods in order to find errors in the source code. Objective: In this paper we extend one specific combinatorial test approach, the Classification Tree Method (CTM), with transition information to generate test sequences. Although we use CTM, this extension is also possible for any combinatorial testing method. Method: The generation of minimal test sequences that fulfill the demanded coverage criteria is an NP-hard problem. Therefore, search-based approaches are required to find such (near) optimal test sequences. Results: The experimental analysis compares the search-based technique with a greedy algorithm on a set of 12 hierarchical concurrent models of programs extracted from the literature. Our proposed search-based approaches (GTSG and ACOts) are able to generate test sequences by finding the shortest valid path to achieve full class (state) and transition coverage. Conclusion: The extended classification tree is useful for generating of test sequences. Moreover, the experimental analysis reveals that our search-based approaches are better than the greedy deterministic approach, especially in the most complex instances. All presented algorithms are actually integrated into a professional tool for functional testing. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Search based algorithms for test sequence generation in functional testing", "paper_id": "WOS:000347022800025"}