{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "request-request_type_message-dependent_deadlocks"}, {"score": 0.03363896917055259, "phrase": "minimum_number"}, {"score": 0.013990964505657802, "phrase": "message-dependent_deadlocks"}, {"score": 0.00936799585190522, "phrase": "psmv_algorithm"}, {"score": 0.009218556088947566, "phrase": "first_step"}, {"score": 0.007307828553752608, "phrase": "psmv"}, {"score": 0.0045765783794477505, "phrase": "multiprocessor_system"}, {"score": 0.0042506731642425275, "phrase": "former_type"}, {"score": 0.004163249698532643, "phrase": "cyclic_paths"}, {"score": 0.004134508282135594, "phrase": "application's_channel_dependency_graph"}, {"score": 0.004068211098891734, "phrase": "mutual_dependency"}, {"score": 0.004049464259907096, "phrase": "different_control"}, {"score": 0.004030803459128259, "phrase": "data_messages"}, {"score": 0.003778370090947027, "phrase": "peer-to-peer_streaming_system"}, {"score": 0.003709183469543214, "phrase": "devastating_effects"}, {"score": 0.003675064945505722, "phrase": "streaming_protocols"}, {"score": 0.0036412591100201674, "phrase": "real-time_processing"}, {"score": 0.003624472560512797, "phrase": "continuous_data_streams"}, {"score": 0.0035335154419206634, "phrase": "proper_inclusion"}, {"score": 0.003517223847512266, "phrase": "virtual_channels"}, {"score": 0.0034448330250482374, "phrase": "selected_routing_path"}, {"score": 0.0033739270918502285, "phrase": "particular_communication_path"}, {"score": 0.0033044757952469593, "phrase": "multiple_existing_communication_flows"}, {"score": 0.0030196181347744372, "phrase": "sufficient_condition"}, {"score": 0.0029849147334986424, "phrase": "path_selection"}, {"score": 0.002971144970781373, "phrase": "minimum_vc_allocation"}, {"score": 0.002896535621940078, "phrase": "non-uniform_vcs"}, {"score": 0.002765636101369536, "phrase": "maximum_number"}, {"score": 0.0027092245886249002, "phrase": "np"}, {"score": 0.0026345365895389626, "phrase": "proposed_mixed_integral_linear_programming"}, {"score": 0.0025922289692173997, "phrase": "second_step"}, {"score": 0.002418453525649304, "phrase": "existing_application_mapping_algorithm"}, {"score": 0.002401728435862681, "phrase": "deadlock-free_mapping_results"}, {"score": 0.0023091093387071593, "phrase": "existing_flow_control"}, {"score": 0.0023037734979454746, "phrase": "based_deadlock_avoidance_method"}, {"score": 0.00227201579996746, "phrase": "deadlock_recovery_method"}, {"score": 0.0022355167967736326, "phrase": "buffers_size"}, {"score": 0.0021894478603175257, "phrase": "baseline_network_configuration"}, {"score": 0.002174303033371869, "phrase": "message_latency"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Streaming protocols", " Network-on-chip (NoC)", " Message-dependent deadlock", " Virtual channel"], "paper_abstract": "When an application is running on a network-on-chip (NoC)-based multiprocessor system-on-chip (MPSoC), two types of deadlocks may occur: (i) the routing-dependent deadlocks, and (ii) the message-dependent deadlocks. The former type of deadlocks can be avoided by removing any cyclic paths on the application's channel dependency graph. The message-dependent deadlocks, caused by mutual dependency of different control and/or data messages, on the other hand, are very complicated to deal with. In this paper, we focus our study on the request-request type message-dependent deadlocks which may appear in a peer-to-peer streaming system. This type of deadlocks can have devastating effects on applications using streaming protocols that often demands real-time processing over continuous data streams. We show that request-request type of deadlocks can be avoided by proper inclusion of virtual channels (VCs) for the links along the selected routing path. These VCs are not bounded to a particular communication path. Instead, they can be shared among multiple existing communication flows. In this paper, we have formally proved a sufficient condition that determines the minimum number of VCs actually needed for each link of a communication flow such that, request-request type message-dependent deadlocks can be completely avoided. Following this sufficient condition, we propose a path selection and minimum VC allocation (PSMV) algorithm to help determine the minimum number of non-uniform VCs for each link. The PSMV algorithm consists of two major steps. In the first step, we attempt to minimize the maximum number of VCs among all the links. This problem is NP-complete in nature, and it is solved using the proposed mixed integral linear programming (MILP)-based algorithm. In the second step, based on the solution suggested in the first step, the minimum number of VCs for each link is finally determined. The PSMV algorithm can literally be integrated with any existing application mapping algorithm to provide deadlock-free mapping results. One such deadlock-free mapping algorithm is suggested in this paper. Our experiments also show that, compared to an existing flow control based deadlock avoidance method (CTC) and a deadlock recovery method (DR), increase of buffers size in PSMV is within 5% compared to a baseline network configuration. The message latency of PSMV is the lowest among all three designs. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Avoiding request-request type message-dependent deadlocks in networks-on-chips", "paper_id": "WOS:000324960800005"}