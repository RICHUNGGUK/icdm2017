{"auto_keywords": [{"score": 0.04934553301452922, "phrase": "gpu"}, {"score": 0.004814958356640448, "phrase": "octree"}, {"score": 0.004668510065740584, "phrase": "continuous_cellular_automaton"}, {"score": 0.00445712058827745, "phrase": "dynamic_surface-based_models"}, {"score": 0.0043718794256931435, "phrase": "increasingly_larger_numbers"}, {"score": 0.0042388570312522, "phrase": "longer_time_periods"}, {"score": 0.004190019394361629, "phrase": "large_numbers"}, {"score": 0.00415777266387528, "phrase": "surface_points"}, {"score": 0.004109865377936045, "phrase": "octree_data_structure"}, {"score": 0.00398478333092707, "phrase": "low_memory_occupation"}, {"score": 0.003954109842050071, "phrase": "relatively_rapid_access"}, {"score": 0.0039085400187964196, "phrase": "stored_data"}, {"score": 0.0038634933357842302, "phrase": "evolution_rules"}, {"score": 0.003804234575698981, "phrase": "neighborhood_states"}, {"score": 0.0037749456215035856, "phrase": "extended_simulation_periods"}, {"score": 0.0036884198249734863, "phrase": "simplified_atomistic_propagation_models"}, {"score": 0.0036048399617046906, "phrase": "ca"}, {"score": 0.0034672240102960644, "phrase": "intrinsic_parallel_updating_nature"}, {"score": 0.003427246079774314, "phrase": "corresponding_simulations"}, {"score": 0.0033357416981328577, "phrase": "classical_central_processing_units"}, {"score": 0.0032092293346843224, "phrase": "sequential_execution"}, {"score": 0.0030166837276747816, "phrase": "efficient_adaptation"}, {"score": 0.002913483929932102, "phrase": "massively_parallel_computing_hardware"}, {"score": 0.0028798723050615788, "phrase": "graphics_processing_unit"}, {"score": 0.002792119634261638, "phrase": "cost-efficient_example"}, {"score": 0.0027599042621376624, "phrase": "parallel_architectures"}, {"score": 0.0027175263159330523, "phrase": "actual_simulations"}, {"score": 0.002665465323614577, "phrase": "surface_propagation"}, {"score": 0.002644920521740564, "phrase": "anisotropic_wet_chemical_etching"}, {"score": 0.0025942468561537682, "phrase": "computationally_challenging_process"}, {"score": 0.0025643086619242814, "phrase": "wide-spread_use"}, {"score": 0.0025054621733192283, "phrase": "continuous_ca_model"}, {"score": 0.002401053532270901, "phrase": "time_evolution"}, {"score": 0.002345944657572499, "phrase": "parallel_computations"}, {"score": 0.0023278569001363263, "phrase": "dynamically_evolving_surfaces"}, {"score": 0.00230098581403254, "phrase": "ca_methods"}, {"score": 0.0022136307563123256, "phrase": "support_data_structures"}, {"score": 0.002171202123281881, "phrase": "overall_computational_time"}, {"score": 0.0021544587602892466, "phrase": "memory_usage"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Parallel computing", " Dynamic surface", " Octree", " Graphics processing unit (GPU)", " Many-core processors", " Cellular automata (CA)", " Anisotropic wet etching"], "paper_abstract": "Presently, dynamic surface-based models are required to contain increasingly larger numbers of points and to propagate them over longer time periods. For large numbers of surface points, the octree data structure can be used as a balance between low memory occupation and relatively rapid access to the stored data. For evolution rules that depend on neighborhood states, extended simulation periods can be obtained by using simplified atomistic propagation models, such as the Cellular Automata (CA). This method, however, has an intrinsic parallel updating nature and the corresponding simulations are highly inefficient when performed on classical Central Processing Units (CPUs), which are designed for the sequential execution of tasks. In this paper, a series of guidelines is presented for the efficient adaptation of octree-based, CA simulations of complex, evolving surfaces into massively parallel computing hardware. A Graphics Processing Unit (GPU) is used as a cost-efficient example of the parallel architectures. For the actual simulations, we consider the surface propagation during anisotropic wet chemical etching of silicon as a computationally challenging process with a wide-spread use in microengineering applications. A continuous CA model that is intrinsically parallel in nature is used for the time evolution. Our study strongly indicates that parallel computations of dynamically evolving surfaces simulated using CA methods are significantly benefited by the incorporation of octrees as support data structures, substantially decreasing the overall computational time and memory usage. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Octree-based, GPU implementation of a continuous cellular automaton for the simulation of complex, evolving surfaces", "paper_id": "WOS:000287432200009"}