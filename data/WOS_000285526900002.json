{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "contextual_properties"}, {"score": 0.043720404506452044, "phrase": "space_improvement"}, {"score": 0.042504644619191075, "phrase": "memory_safety"}, {"score": 0.004768104290288521, "phrase": "untyped_lambda-calculus"}, {"score": 0.004562847483469705, "phrase": "general_method"}, {"score": 0.004409304640026443, "phrase": "arbitrary_contexts"}, {"score": 0.004219427915728969, "phrase": "observational_equivalence"}, {"score": 0.003503497128638099, "phrase": "sumii_et_al"}, {"score": 0.0034524248924699985, "phrase": "environmental_bisimulation_technique"}, {"score": 0.0033361232750221863, "phrase": "complete_characterization"}, {"score": 0.003287482882222731, "phrase": "proved_property"}, {"score": 0.003054681986032532, "phrase": "bisimulation-like_conditions"}, {"score": 0.002769650208851401, "phrase": "typical_data_structures"}, {"score": 0.002729246328390722, "phrase": "linked_lists"}, {"score": 0.0027026375053777543, "phrase": "binary_search_trees"}, {"score": 0.0026501935378083663, "phrase": "acyclic_graphs"}, {"score": 0.0026243534128245886, "phrase": "reference_counts"}, {"score": 0.002573424607574822, "phrase": "deletion_operations"}, {"score": 0.0024383967028975616, "phrase": "environmental_approach"}, {"score": 0.002414616656410503, "phrase": "contextual_equivalence"}, {"score": 0.0023104373174118458, "phrase": "unary_predicates"}, {"score": 0.0021678232353129472, "phrase": "non-monotone_store"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Environmental bisimulation", " Contextual equivalence", " Memory management and deallocation", " Local memory safety"], "paper_abstract": "We develop a general method for proving properties of programs under arbitrary contexts - including (but not limited to) observational equivalence, space improvement, and a form of memory safety of the programs - in untyped call-by-value A-calculus with first-class, dynamically allocated, higher-order references and deallocation. The method generalizes Sumii et al.'s environmental bisimulation technique, and gives a sound and complete characterization of each proved property, in the sense that the \"bisimilarity\" (the largest set satisfying the bisimulation-like conditions) equals the set of terms with the property to be proved. We give examples of contextual properties concerning typical data structures such as linked lists, binary search trees, and directed acyclic graphs with reference counts, all with deletion operations that release memory. This shows the scalability of the environmental approach from contextual equivalence to other binary relations (such as space improvement) and unary predicates (such as memory safety), as well as to languages with non-monotone store. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "A bisimulation-like proof method for contextual properties in untyped lambda-calculus with references and deallocation", "paper_id": "WOS:000285526900002"}