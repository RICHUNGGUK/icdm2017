{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "optimized_haskell"}, {"score": 0.00443308765153716, "phrase": "real-world_haskell_programs"}, {"score": 0.004138010495069077, "phrase": "compiler_optimizations"}, {"score": 0.0036553070575015344, "phrase": "source_code"}, {"score": 0.003555902292752528, "phrase": "program_behavior"}, {"score": 0.0031845067058084583, "phrase": "root_issue"}, {"score": 0.0030135741897058844, "phrase": "causality_analysis"}, {"score": 0.002931569771634119, "phrase": "functional_programs"}, {"score": 0.002318566141177149, "phrase": "glasgow_haskell_compiler"}, {"score": 0.0021940118003312397, "phrase": "performance_analysis"}, {"score": 0.0021049977753042253, "phrase": "aggressively_optimized_programs"}], "paper_keywords": ["Profiling", " Optimization", " Haskell", " Causality"], "paper_abstract": "Profiling real-world Haskell programs is hard, as compiler optimizations make it tricky to establish causality between the source code and program behavior. In this paper we attack the root issue by performing a causality analysis of functional programs under optimization. We apply our findings to build a novel profiling infrastructure on top of the Glasgow Haskell Compiler, allowing for performance analysis even of aggressively optimized programs.", "paper_title": "Causality of Optimized Haskell What is burning our cycles?", "paper_id": "WOS:000331119900013"}