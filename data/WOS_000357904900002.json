{"auto_keywords": [{"score": 0.04769632635828977, "phrase": "linked_data"}, {"score": 0.00481495049065317, "phrase": "linked_data_consumers"}, {"score": 0.004437613070853689, "phrase": "web_developer"}, {"score": 0.004068907083697369, "phrase": "development_stack"}, {"score": 0.0038271712887391015, "phrase": "background_processes"}, {"score": 0.003581412258960711, "phrase": "scripting_language"}, {"score": 0.0035269696779744266, "phrase": "simple_but_appropriate_type_system"}, {"score": 0.003104201872147936, "phrase": "stronger_type_assumptions"}, {"score": 0.003010496595090984, "phrase": "local_data"}, {"score": 0.002964706925144123, "phrase": "external_data"}, {"score": 0.002889928791032578, "phrase": "static_and_dynamic_typing"}, {"score": 0.002676692093594358, "phrase": "minimal_type_inference"}, {"score": 0.0026091594819333654, "phrase": "subject_reduction"}, {"score": 0.0025826247025542235, "phrase": "type_safety_results"}, {"score": 0.002479150189700726, "phrase": "statically_type"}, {"score": 0.00240426758768164, "phrase": "basic_runtime_type_errors"}, {"score": 0.0021705796895687864, "phrase": "web_developers"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Type systems", " Operational semantics", " Linked Data"], "paper_abstract": "We provide an introduction to the Web of Linked Data from the perspective of a Web developer who would like to build an application using Linked Data. We identify a weakness in the development stack, namely a lack of domain specific scripting languages for designing background processes that consume Linked Data. To address this weakness, we design a scripting language with a simple but appropriate type system. In our proposed architecture, some data is consumed from sources outside of the control of the system and some data is held locally. Stronger type assumptions can be made about the local data than about external data, hence our type system mixes static and dynamic typing. We prove that our type system is algorithmic; and can therefore be used for minimal type inference. We also prove subject reduction and type safety results, which justify our claim that our language is statically type checked and does not throw basic runtime type errors. Throughout, we relate our work to the W3C recommendations that drive Linked Data, so that our syntax is accessible to Web developers. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "Minimal type inference for Linked Data consumers", "paper_id": "WOS:000357904900002"}