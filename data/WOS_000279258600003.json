{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "event-driven_software"}, {"score": 0.04194133676529324, "phrase": "user_inputs"}, {"score": 0.04161068393029443, "phrase": "web-based_applications"}, {"score": 0.00471700544744796, "phrase": "event-driven_systems"}, {"score": 0.004659192888931046, "phrase": "ongoing_dialog"}, {"score": 0.004527024978801684, "phrase": "distributed_programs"}, {"score": 0.004398589723893764, "phrase": "received_messages"}, {"score": 0.004221379262804442, "phrase": "graphical_user_interfaces"}, {"score": 0.004101579688745222, "phrase": "interface_software"}, {"score": 0.00405127920820053, "phrase": "underlying_application"}, {"score": 0.00388800655625083, "phrase": "business_logic"}, {"score": 0.0035369291417564606, "phrase": "possible_interaction_sequences"}, {"score": 0.003352658916650986, "phrase": "complex_constraints"}, {"score": 0.0033115124244647736, "phrase": "exhaustive_nature"}, {"score": 0.003284361433827464, "phrase": "software_model_checking_techniques"}, {"score": 0.0031004173389196387, "phrase": "closed_systems"}, {"score": 0.0029509483926257645, "phrase": "open_system"}, {"score": 0.0027514186391258263, "phrase": "authors'_previous_work"}, {"score": 0.0026622351303038885, "phrase": "broadly_applicable_mechanisms"}, {"score": 0.002629539710839523, "phrase": "environment_behaviour"}, {"score": 0.002492425259337031, "phrase": "environment_models"}, {"score": 0.002461810159687652, "phrase": "precise_and_efficient_system_analysis"}, {"score": 0.002431570196486513, "phrase": "authors'_experience"}, {"score": 0.0023527296826339225, "phrase": "application_domain"}, {"score": 0.002333421318779658, "phrase": "generated_environments"}, {"score": 0.0022300169122921906, "phrase": "model_checking"}, {"score": 0.0021576973674470997, "phrase": "domain-specific_environment_generation"}, {"score": 0.0021049977753042253, "phrase": "environment_generation"}], "paper_keywords": [""], "paper_abstract": "Event-driven systems maintain an ongoing dialog with their environment. Examples include: distributed programs, where each process reacts to received messages by performing computation and sending messages to peers; graphical user interfaces (GUI), where the interface software and the underlying application react to user inputs and web-based applications, where presentation, business logic and storage tier functionality react to user inputs and response from other web-based services. Such applications are difficult to test because the set of possible interaction sequences between the system and its environment can be very large and governed by complex constraints. The exhaustive nature of software model checking techniques offers hope for effectively validating such systems, however, they only work for closed systems. Previously, the authors developed the Bandera Environment Generator, which given an open system, called a unit under analysis, closes it with a model of its environment. The authors' previous work on environment generation has focused on developing broadly applicable mechanisms for modelling environment behaviour. The generality of this approach often makes it difficult to produce environment models that enable precise and efficient system analysis. The authors' experience shows that by exploiting information about the application domain, generated environments can be made both more precise and more efficient for model checking. This study presents the concept of domain-specific environment generation, details techniques for customising environment generation for the domain of event-driven software, and assesses those techniques on the domains of GUI and web-based applications.", "paper_title": "Environment generation for validating event-driven software using model checking", "paper_id": "WOS:000279258600003"}