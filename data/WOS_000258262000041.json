{"auto_keywords": [{"score": 0.03789439700787632, "phrase": "inverse_texture_synthesis"}, {"score": 0.00481495049065317, "phrase": "synthesis_algorithms"}, {"score": 0.004278807087784626, "phrase": "homogeneous_patterns"}, {"score": 0.004154332348800334, "phrase": "manual_cropping"}, {"score": 0.004073359218158693, "phrase": "adequate_solution"}, {"score": 0.00376488621224566, "phrase": "iron_statue"}, {"score": 0.0036733470451885465, "phrase": "varying_moisture_levels"}, {"score": 0.0033617891884360606, "phrase": "traditional_forward_synthesis"}, {"score": 0.003296212583539166, "phrase": "large_globally_varying_texture"}, {"score": 0.0031845067058084583, "phrase": "small_texture"}, {"score": 0.0030464123943266673, "phrase": "small_compaction"}, {"score": 0.002943147037670826, "phrase": "original_texture"}, {"score": 0.0028574164693918433, "phrase": "new_textures"}, {"score": 0.0028293966058473476, "phrase": "user-supplied_controls"}, {"score": 0.0027334673433027086, "phrase": "real-time_synthesis"}, {"score": 0.002706659627293686, "phrase": "globally_varying_textures"}, {"score": 0.002667142091429728, "phrase": "gpu"}, {"score": 0.0026148807877309417, "phrase": "texture_memory"}, {"score": 0.002538687900036229, "phrase": "large_textures"}, {"score": 0.0024768883044869023, "phrase": "optimization_framework"}, {"score": 0.0023928819778638055, "phrase": "input_region"}, {"score": 0.002323142666222693, "phrase": "output_compaction"}, {"score": 0.002255431275670053, "phrase": "orientation_fields"}, {"score": 0.002233301265743633, "phrase": "anisotropic_textures"}, {"score": 0.0021896891011033105, "phrase": "high-frequency_regions"}, {"score": 0.0021049977753042253, "phrase": "existing_techniques"}], "paper_keywords": ["texture synthesis", " texture mapping", " GPU techniques"], "paper_abstract": "The quality and speed of most texture synthesis algorithms depend on a 2D input sample that is small and contains enough texture variations. However, little research exists on how to acquire such a sample. For homogeneous patterns this can be achieved via manual cropping, but no adequate solution exists for inhomogeneous or globally varying textures, i.e. patterns that are local but not stationary, such as rusting over an iron statue with appearance conditioned on varying moisture levels. We present inverse texture synthesis to address this issue. Our inverse synthesis runs in the opposite direction with respect to traditional forward synthesis: given a large globally varying texture, our algorithm automatically produces a small texture compaction that best summarizes the original. This small compaction can be used to reconstruct the original texture or to re-synthesize new textures under user-supplied controls. More important, our technique allows real-time synthesis of globally varying textures on a GPU, where the texture memory is usually too small for large textures. We propose an optimization framework for inverse texture synthesis, ensuring that each input region is properly encoded in the output compaction. Our optimization process also automatically computes orientation fields for anisotropic textures containing both low- and high-frequency regions, a situation difficult to handle via existing techniques.", "paper_title": "Inverse texture synthesis", "paper_id": "WOS:000258262000041"}