{"auto_keywords": [{"score": 0.0450678547644915, "phrase": "scheme"}, {"score": 0.00481495049065317, "phrase": "hygienic_macros"}, {"score": 0.004684157900507474, "phrase": "scheme_macros"}, {"score": 0.004556901872357751, "phrase": "powerful_api"}, {"score": 0.004482206282876944, "phrase": "compiler_front_end"}, {"score": 0.004408729661992651, "phrase": "lisp_macros"}, {"score": 0.004241914481080374, "phrase": "source_programs"}, {"score": 0.004172360444377281, "phrase": "small_core_language"}, {"score": 0.004103942174451674, "phrase": "lisp_systems"}, {"score": 0.003970439654470374, "phrase": "lexical_scoping"}, {"score": 0.0039053194919285725, "phrase": "advanced_scheme_macro_systems"}, {"score": 0.00379914165379475, "phrase": "source_location"}, {"score": 0.0036958398682001015, "phrase": "scheme_programmers"}, {"score": 0.0035953368057880593, "phrase": "ultimate_abstraction"}, {"score": 0.003478321590910367, "phrase": "typical_scheme_programming_environment"}, {"score": 0.0033837135367113004, "phrase": "macro_development"}, {"score": 0.002883439044844259, "phrase": "stepping_debugger"}, {"score": 0.002789528662623221, "phrase": "macro_expansion"}, {"score": 0.0026986685585382347, "phrase": "macro_expansion_process"}, {"score": 0.0026543514413663893, "phrase": "linear_rewriting_sequence"}, {"score": 0.0026252106881752067, "phrase": "annotated_terms"}, {"score": 0.002539689093411356, "phrase": "binding_structure"}, {"score": 0.0023507916951658455, "phrase": "programmer's_level"}, {"score": 0.002261666793030715, "phrase": "syntactic_forms"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Macros", " Debugging", " Syntactic abstraction", " Scheme"], "paper_abstract": "Over the past two decades, Scheme macros have evolved into a powerful API for the compiler front end. Like Lisp macros, their predecessors, Scheme macros expand source programs into a small core language; unlike Lisp systems, Scheme macro expanders preserve lexical scoping, and advanced Scheme macro systems handle other important properties such as source location. Using such macros, Scheme programmers now routinely develop the ultimate abstraction; embedded domain-specific programming languages. Unfortunately, a typical Scheme programming environment provides little support for macro development. This lack makes it difficult for programmers to debug their macros and for novices to study the behavior of macros. In response, we have developed a stepping debugger specialized to the concerns of macro expansion. This debugger presents the macro expansion process as a linear rewriting sequence of annotated terms; it graphically illustrates the binding structure of the program as expansion reveals it; and it adapts to the programmer's level of abstraction, hiding details of syntactic forms that the programmer considers built-in. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Debugging hygienic macros", "paper_id": "WOS:000278243200003"}