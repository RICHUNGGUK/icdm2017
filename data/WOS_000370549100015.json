{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "implicit_parallelism"}, {"score": 0.004671588539217021, "phrase": "static_analysis_techniques_compilers"}, {"score": 0.004578382275810468, "phrase": "lazy_functional_languages"}, {"score": 0.003487222504700868, "phrase": "main_thread"}, {"score": 0.0031208772639433145, "phrase": "runtime_performance"}, {"score": 0.002821247621250663, "phrase": "static_analyses'_poor_prediction"}, {"score": 0.0024247382451294255, "phrase": "iterative_profile-directed_improvement"}, {"score": 0.0023287359930308864, "phrase": "well-studied_static_analysis_techniques"}, {"score": 0.0021697677572213086, "phrase": "higher_performance_gains"}, {"score": 0.0021049977753042253, "phrase": "static_analysis"}], "paper_keywords": ["Implicit Parallelism", " Lazy Functional Languages", " Automatic Parallelism", " Strictness Analysis", " Projections", " Iterative Compilation", " Feedback Directed Compilation"], "paper_abstract": "Using static analysis techniques compilers for lazy functional languages can be used to identify parts of a program that can be legitimately evaluated in parallel and ensure that those expressions are executed concurrently with the main thread of execution. These techniques can produce improvements in the runtime performance of a program, but are limited by the static analyses' poor prediction of runtime performance. This paper outlines the development of a system that uses iterative profile-directed improvement in addition to well-studied static analysis techniques. This allows us to achieve higher performance gains than through static analysis alone.", "paper_title": "Improving Implicit Parallelism", "paper_id": "WOS:000370549100015"}