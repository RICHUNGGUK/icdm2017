{"auto_keywords": [{"score": 0.02885810654409676, "phrase": "application_run"}, {"score": 0.00481495049065317, "phrase": "high-end_parallel_systems"}, {"score": 0.0046848707075530256, "phrase": "high_end_systems"}, {"score": 0.004642292792558686, "phrase": "event-based_traces"}, {"score": 0.004537525607322823, "phrase": "root_cause"}, {"score": 0.004414907432703781, "phrase": "complex_performance_problems"}, {"score": 0.004315249628884236, "phrase": "highly_parallel_systems"}, {"score": 0.004256533389293113, "phrase": "high-end_architectures"}, {"score": 0.0042178318724732005, "phrase": "tens_to_hundreds_of_thousands"}, {"score": 0.004122604238556912, "phrase": "application_scalability_challenges"}, {"score": 0.004085115444878828, "phrase": "new_heights"}, {"score": 0.003956558420993431, "phrase": "event-based_data"}, {"score": 0.003832031470970347, "phrase": "large_volume"}, {"score": 0.0037971749182744334, "phrase": "collected_data"}, {"score": 0.0037626342268042997, "phrase": "tool_overhead"}, {"score": 0.0036776458116294986, "phrase": "data_files"}, {"score": 0.003433987036569199, "phrase": "new_measurement_technique"}, {"score": 0.003265591844292821, "phrase": "performance_problems"}, {"score": 0.0031339552246625463, "phrase": "greatly_reduced_data_volume"}, {"score": 0.003091262582401731, "phrase": "trace_profiling_technique"}, {"score": 0.0029396242707327986, "phrase": "repeated_behavior"}, {"score": 0.0027573101010593863, "phrase": "parallel_processes"}, {"score": 0.0026949679939994226, "phrase": "trace_profiling"}, {"score": 0.0025744696954056404, "phrase": "summary_information"}, {"score": 0.002539379289856756, "phrase": "event_patterns"}, {"score": 0.0023927516438886445, "phrase": "behavior_categories"}, {"score": 0.0022962183207691188, "phrase": "performance_data"}, {"score": 0.0022238315004700607, "phrase": "performance_behaviors"}, {"score": 0.002163600705898299, "phrase": "execution_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Performance measurement", " Event tracing", " Parallel performance tools"], "paper_abstract": "Accurate performance analysis of high end systems requires event-based traces to correctly identify the root cause of a number of the complex performance problems that arise on these highly parallel systems. These high-end architectures contain tens to hundreds of thousands of processors, pushing application scalability challenges to new heights. Unfortunately, the collection of event-based data presents scalability challenges itself: the large volume of collected data increases tool overhead, and results in data files that are difficult to store and analyze. Our solution to these problems is a new measurement technique called trace profiling that collects the information needed to diagnose performance problems that traditionally require traces, but at a greatly reduced data volume. The trace profiling technique reduces the amount of data stored by capitalizing on the repeated behavior of programs, and on the similarity of the behavior and performance of parallel processes in an application run. Trace profiling is a hybrid between profiling and tracing, collecting summary information about the event patterns in an application run. Because the data has already been classified into behavior categories, we can present reduced, partially analyzed performance data to the user, highlighting the performance behaviors that comprised most of the execution time. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Trace profiling: Scalable event tracing on high-end parallel systems", "paper_id": "WOS:000303221300002"}