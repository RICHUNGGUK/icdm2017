{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "nominal_datatypes"}, {"score": 0.047905977291456965, "phrase": "nominal_datatype_package"}, {"score": 0.04154041880609474, "phrase": "alpha-equivalence_classes"}, {"score": 0.0038889162424692995, "phrase": "pitts"}, {"score": 0.0037820003983334476, "phrase": "general_conditions"}, {"score": 0.0033515736929172644, "phrase": "structural_recursion"}, {"score": 0.0032292292848296617, "phrase": "clever_proof"}, {"score": 0.003054009753601139, "phrase": "primitive-recursion_combinator"}, {"score": 0.0025592969422491476, "phrase": "auxiliary_constructions"}, {"score": 0.0024429654627197393, "phrase": "proving_tools"}, {"score": 0.0021049977753042253, "phrase": "essential_prerequisite"}], "paper_keywords": ["lambda-calculus", " proof assistants", " nominal logic", " primitive recursion"], "paper_abstract": "The nominal datatype package implements an infrastructure in Isabelle/HOL for defining languages involving binders and for reasoning conveniently about alpha-equivalence classes. Pitts stated some general conditions under which functions over alpha-equivalence classes can be defined by a form of structural recursion and gave a clever proof for the existence of a primitive-recursion combinator. We give a version of this proof that works directly over nominal datatypes and does not rely upon auxiliary constructions, We further introduce proving tools and a heuristic that made the automation of our proof tractable. This automation is an essential prerequisite for the nominal datatype package to become useful.", "paper_title": "A recursion combinator for nominal datatypes implemented in Isabelle/HOL", "paper_id": "WOS:000240085600041"}