{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "new_worklist_algorithm"}, {"score": 0.004658426838467567, "phrase": "large_class"}, {"score": 0.0046073860169839305, "phrase": "flow-sensitive_data-flow_analyses"}, {"score": 0.00443308765153716, "phrase": "pointer_analysis"}, {"score": 0.004265354774450696, "phrase": "interprocedural_analyses"}, {"score": 0.0040366412779632085, "phrase": "individual_procedures"}, {"score": 0.0038838500580958744, "phrase": "interprocedural_analysis"}, {"score": 0.003716273882758735, "phrase": "large_parts"}, {"score": 0.003478321590910367, "phrase": "sparse_nature"}, {"score": 0.00325555555110395, "phrase": "interprocedural_def-use_chains"}, {"score": 0.002915437843874821, "phrase": "flow_values"}, {"score": 0.0028360962841331634, "phrase": "sparse_analysis"}, {"score": 0.0027286224888843956, "phrase": "precomputed_def-use_chains"}, {"score": 0.0026107601878587816, "phrase": "costly_analysis"}, {"score": 0.0024299678474208023, "phrase": "def-use_chains"}, {"score": 0.0022994427535192514, "phrase": "precise_pointer_information"}, {"score": 0.0022368274529152342, "phrase": "large_programs"}, {"score": 0.0021520139248317333, "phrase": "analysis_time"}], "paper_keywords": [""], "paper_abstract": "This paper presents a new worklist algorithm that significantly speeds up a large class of flow-sensitive data-flow analyses, including typestate error checking and pointer analysis. Our algorithm works particularly well for interprocedural analyses. By contrast, traditional algorithms work well for individual procedures but do not scale well to interprocedural analysis because they spend too much time unnecessarfly re-analyzing large parts of the program. Our algorithm solves this problem by exploiting the sparse nature of many analyses. The key to our approach is the use of interprocedural def-use chains, which allows our algorithm to re-analyze only those parts of the program that are affected by changes in the flow values. Unlike other techniques for sparse analysis, our algorithm does not rely on precomputed def-use chains, since this computation can itself require costly analysis, particularly in the presence of pointers. Instead, we compute def-use chains on the fly during the analysis, along with precise pointer information. When applied to large programs such as nn, our techniques improve analysis time by up to 90%-from 1974s to 190s-over a state of the art algorithm.", "paper_title": "Efficient flow-sensitive interprocedural data-flow analysis in the presence of pointers", "paper_id": "WOS:000237082300002"}