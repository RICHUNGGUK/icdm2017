{"auto_keywords": [{"score": 0.03596176205294269, "phrase": "fibonacci_codes"}, {"score": 0.00481495049065317, "phrase": "fibonacci_compression_codes"}, {"score": 0.004721162131188487, "phrase": "recent_publications"}, {"score": 0.004154332348800334, "phrase": "integral_number"}, {"score": 0.003993958025223994, "phrase": "compression_applications"}, {"score": 0.003916098498242888, "phrase": "large_alphabets"}, {"score": 0.003584025547693836, "phrase": "similar_properties"}, {"score": 0.0031223774204093713, "phrase": "binary_representations"}, {"score": 0.0029722900280316216, "phrase": "fibonacci_numbers"}, {"score": 0.002914288956035066, "phrase": "order_m"}, {"score": 0.002538687900036229, "phrase": "previous_work"}, {"score": 0.002346160830406661, "phrase": "compression_efficiency"}, {"score": 0.0021682027434117095, "phrase": "dense_codes"}], "paper_keywords": ["text compression", " Fibonacci codes", " dense codes"], "paper_abstract": "Recent publications advocate the use of various variable length codes for which each codeword consists of an integral number of bytes in compression applications using large alphabets. This paper shows that another tradeoff with similar properties can be obtained by Fibonacci codes. These are fixed codeword sets, using binary representations of integers based on Fibonacci numbers of order m >= 2. Fibonacci codes have been used before, and this paper extends previous work presenting several novel features. In particular, the compression efficiency is analyzed and compared to that of dense codes, and various table-driven decoding routines are suggested.", "paper_title": "On the Usefulness of Fibonacci Compression Codes", "paper_id": "WOS:000279185400007"}