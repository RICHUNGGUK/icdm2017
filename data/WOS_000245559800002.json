{"auto_keywords": [{"score": 0.042456351563769805, "phrase": "performance_improvements"}, {"score": 0.030995143592261312, "phrase": "memory_access_latency"}, {"score": 0.02619743897401912, "phrase": "operation_parallelism"}, {"score": 0.00481495049065317, "phrase": "optimized_compiler_approach"}, {"score": 0.0047587234712024775, "phrase": "generic_reconfigurable_array_architecture"}, {"score": 0.004487241576747549, "phrase": "major_bottlenecks"}, {"score": 0.004331811712726697, "phrase": "limited_memory"}, {"score": 0.0041653916552844535, "phrase": "limited_bandwidth"}, {"score": 0.003958529104387973, "phrase": "architectural_characteristics"}, {"score": 0.0037915057447460133, "phrase": "architectural_parameters"}, {"score": 0.0037471850931318942, "phrase": "performance_speedups"}, {"score": 0.003688892770976908, "phrase": "pes'_local_rams"}, {"score": 0.0035056109035307716, "phrase": "data_reuse_values"}, {"score": 0.0034375594065869032, "phrase": "internal_interconnection_network"}, {"score": 0.0033444934455768623, "phrase": "external_memories"}, {"score": 0.0032539388572032563, "phrase": "data_transfer_burden"}, {"score": 0.0032158817866929563, "phrase": "bus_network"}, {"score": 0.0031782684007251403, "phrase": "novel_mapping_algorithm"}, {"score": 0.003092200512475624, "phrase": "list_scheduling_technique"}, {"score": 0.003056029284235528, "phrase": "experimental_results"}, {"score": 0.002892729377519916, "phrase": "interconnection_network"}, {"score": 0.0028588847851995533, "phrase": "processing_element's_local_ram_size"}, {"score": 0.002727409429089543, "phrase": "flexible_architecture_template"}, {"score": 0.002501835053002899, "phrase": "richer_interconnection_topology"}, {"score": 0.002340357706078868, "phrase": "considered_set"}, {"score": 0.0021383149182448522, "phrase": "pe's_local_ram"}], "paper_keywords": ["coarse-grained reconfigurable arrays", " compiler techniques", " data reuse", " data bandwidth bottleneck", " reconfigurable computing"], "paper_abstract": "Several mesh-like coarse-grained reconfigurable architectures have been devised in the last few years accompanied with their corresponding mapping flows. One of the major bottlenecks in mapping algorithms on these architectures is the limited memory access bandwidth. Only a few mapping methodologies encountered the problem of the limited bandwidth while none has explored how the performance improvements are affected, from the architectural characteristics. We study in this paper the impact that the architectural parameters have on performance speedups achieved when the PEs' local RAMs are used for storing the variables with data reuse opportunities. The data reuse values are transferred in the internal interconnection network instead of being fetched, from external memories, in order to reduce the data transfer burden on the bus network. A novel mapping algorithm is also proposed that uses a list scheduling technique. The experimental results quantified the trade-offs that exist between the performance improvements and the memory access latency, the interconnection network and the processing element's local RAM size. For this reason, our mapping methodology targets on a flexible architecture template, which permits such an exploration. More specifically, the experiments showed that the improvements increase with the memory access latency, while a richer interconnection topology can improve the operation parallelism by a factor of 1.4 on average. Finally, for the considered set of benchmarks, the operation parallelism has been improved from 8.6% to 85.1% from the application of our methodology, and by having each PE's Local RAM a size of 8 words.", "paper_title": "Design space exploration of an optimized compiler approach for a generic reconfigurable array architecture", "paper_id": "WOS:000245559800002"}