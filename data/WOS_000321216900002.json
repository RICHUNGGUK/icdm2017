{"auto_keywords": [{"score": 0.04312119725754665, "phrase": "multiple_memory_banks"}, {"score": 0.00481495049065317, "phrase": "memory_profile_analysis"}, {"score": 0.0047527118741586055, "phrase": "automatic_synthesis"}, {"score": 0.004691273968935458, "phrase": "pointers_code"}, {"score": 0.0045411156682300695, "phrase": "main_advantages"}, {"score": 0.004482400730101345, "phrase": "high-level_synthesis"}, {"score": 0.004424469189821106, "phrase": "hls"}, {"score": 0.004012885020428863, "phrase": "current_hls_systems"}, {"score": 0.003960972732123083, "phrase": "parallel_memory_references"}, {"score": 0.0038843558517333327, "phrase": "explicit_array_declarations"}, {"score": 0.0038092152998069786, "phrase": "source_code"}, {"score": 0.0034322572683276654, "phrase": "dynamic_data_structures"}, {"score": 0.0033222630615013763, "phrase": "automatic_memory_partitioning"}, {"score": 0.0031741489723036255, "phrase": "general_data_structures"}, {"score": 0.0029933487820771217, "phrase": "increased_parallelism"}, {"score": 0.002878556952876824, "phrase": "source_code_instrumentation"}, {"score": 0.0027145478956494356, "phrase": "linear_memory_access_patterns"}, {"score": 0.0026619761089539595, "phrase": "memory_traces"}, {"score": 0.002576603426735759, "phrase": "data_structures"}, {"score": 0.002543224008253855, "phrase": "disjoint_memory_regions"}, {"score": 0.0024297565926197505, "phrase": "parallel_memory_access"}, {"score": 0.0023062508214156123, "phrase": "memory_segments"}, {"score": 0.0022177498761722773, "phrase": "significant_improvements"}, {"score": 0.0021049977753042253, "phrase": "memory_banks"}], "paper_keywords": ["Design", " Algorithms", " Performance", " Reconfigurable computing", " memory analysis", " memory banks"], "paper_abstract": "One of the main advantages of high-level synthesis (HLS) is the ability to synthesize circuits that can access multiple memory banks in parallel. Current HLS systems synthesize parallel memory references based on explicit array declarations in the source code. We consider the need to synthesize not only array references but also memory operations targeting pointers and dynamic data structures. This paper describes Automatic Memory Partitioning, a method for automatically synthesizing general data structures (arrays and pointers) into multiple memory banks for increased parallelism and performance. We use source code instrumentation to collect memory traces in order to detect linear memory access patterns. The memory traces are used to split data structures into disjoint memory regions and determine which segments may benefit from parallel memory access. We present an algorithm for allocating memory segments into multiple memory banks. Experiments show significant improvements in performance while conserving the number of memory banks.", "paper_title": "Using Memory Profile Analysis for Automatic Synthesis of Pointers Code", "paper_id": "WOS:000321216900002"}