{"auto_keywords": [{"score": 0.05007825983900011, "phrase": "engineering_security"}, {"score": 0.048883121206786694, "phrase": "goal-oriented_security_requirements"}, {"score": 0.03176366948404099, "phrase": "acceptance_test_cases"}, {"score": 0.03137521356425705, "phrase": "requirements_model"}, {"score": 0.03111897185314078, "phrase": "fades"}, {"score": 0.026072637004191244, "phrase": "fades_automated_bridge"}, {"score": 0.004734448316824488, "phrase": "formal_software_security_specifications"}, {"score": 0.004463096299091981, "phrase": "provably_secure_software"}, {"score": 0.004333283735537634, "phrase": "formal_requirements_elaboration"}, {"score": 0.004278807087784626, "phrase": "limited_scalability"}, {"score": 0.00413684709497912, "phrase": "informal_or_semi-formal_methods"}, {"score": 0.004102096151528319, "phrase": "large-scale_software_development"}, {"score": 0.003982741546775355, "phrase": "highly_secure_software"}, {"score": 0.003660452313567116, "phrase": "first_goal-oriented_software_security_engineering_approach"}, {"score": 0.0032250961348210473, "phrase": "software_development_lifecycle"}, {"score": 0.0030657684627749364, "phrase": "automated_derivation"}, {"score": 0.00287759989638073, "phrase": "security_implementation"}, {"score": 0.002723862897844177, "phrase": "automated_process"}, {"score": 0.002655697256976997, "phrase": "b_specifications"}, {"score": 0.002389514188569084, "phrase": "formal_design"}, {"score": 0.0023395610923736595, "phrase": "empirical_validation"}, {"score": 0.0023100907305651872, "phrase": "security_engineering_practitioners"}, {"score": 0.0022713722522505592, "phrase": "formal_methods"}, {"score": 0.0022238834225283594, "phrase": "extensive_results"}, {"score": 0.002131857309586904, "phrase": "secure_software"}, {"score": 0.0021049977753042253, "phrase": "cost-effective_manner"}], "paper_keywords": [""], "paper_abstract": "Formal methods have long been advocated for the development of provably secure software. However, the lack of formal requirements elaboration and the limited scalability afforded by such methods have led to employing informal or semi-formal methods for large-scale software development. In our effort to produce highly secure software in a systematic, provable and cost-effective manner, the authors have proposed formal analysis and design for engineering security (FADES) as the first goal-oriented software security engineering approach that provides an automated bridge between the goal-oriented semi-formal Knowledge Acquisition for autOmated Specifications (KAOS) framework and the B formal method. Automating the transition from requirements to specifications; considered one of the most difficult steps in the software development lifecycle, is vital to the success of FADES. Further, the automated derivation of a suite of acceptance test cases from the requirements model in FADES provides means to verify security implementation against the requirements model. In this study, the authors propose an automated process using FADES to systematically derive B specifications and a suite of acceptance test cases from goal-oriented security requirements. Further, the authors empirically validate the effectiveness of the FADES automated bridge that paves the grounds for formal design and implementation. The empirical validation involves both security engineering practitioners and experts in formal methods for security. The extensive results obtained demonstrate the effectiveness of the FADES automated bridge in producing secure software in a cost-effective manner.", "paper_title": "Formal analysis and design for engineering security automated derivation of formal software security specifications from goal-oriented security requirements", "paper_id": "WOS:000276591800005"}