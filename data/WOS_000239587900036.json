{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "best_hyperplane"}, {"score": 0.004741395005218184, "phrase": "simple_budget_perceptron"}, {"score": 0.004621279527317074, "phrase": "on-line_classification_algorithms"}, {"score": 0.004235095881928715, "phrase": "smoothly_changing_classifiers"}, {"score": 0.0041490029730869345, "phrase": "shifting_bounds"}, {"score": 0.004106612344123407, "phrase": "kernel-based_classifiers"}, {"score": 0.003861175855298779, "phrase": "support_vectors"}, {"score": 0.0037057255600764475, "phrase": "eviction_policy"}, {"score": 0.0030327408069772293, "phrase": "shifting_perceptron_algorithm"}, {"score": 0.002986329509791943, "phrase": "best_known_shifting_bounds"}, {"score": 0.0029255474957478474, "phrase": "unlimited_budget"}, {"score": 0.0027646829399573434, "phrase": "perceptron_algorithm"}, {"score": 0.0027363971333961967, "phrase": "simplest_possible_eviction_policy"}, {"score": 0.00266693888510356, "phrase": "random_support_vector"}, {"score": 0.0026126405272417783, "phrase": "new_one"}, {"score": 0.002393907896783117, "phrase": "budget_restrictions"}, {"score": 0.002262209824105154, "phrase": "optimal_trade-off_u"}, {"score": 0.002193447487477984, "phrase": "budget_b"}, {"score": 0.002159852420283463, "phrase": "u_of"}, {"score": 0.0021377414429251647, "phrase": "largest_classifier"}, {"score": 0.0021049977753042253, "phrase": "comparison_sequence"}], "paper_keywords": [""], "paper_abstract": "Shifting bounds for on-line classification algorithms ensure good performance on any sequence of examples that is well predicted by a sequence of smoothly changing classifiers. When proving shifting bounds for kernel-based classifiers, one also faces the problem of storing a number of support vectors that can grow unboundedly, unless an eviction policy is used to keep this number under control. In this paper, we show that shifting and on-line learning on a budget can be combined surprisingly well. First, we introduce and analyze a shifting Perceptron algorithm achieving the best known shifting bounds while using an unlimited budget. Second, we show that by applying to the Perceptron algorithm the simplest possible eviction policy, which discards a random support vector each time a new one comes in, we achieve a shifting bound close to the one we obtained with no budget restrictions. More importantly, we show that our randomized algorithm strikes the optimal trade-off U = Theta(root B) between budget B and norm U of the largest classifier in the comparison sequence.", "paper_title": "Tracking the best hyperplane with a simple budget perceptron", "paper_id": "WOS:000239587900036"}