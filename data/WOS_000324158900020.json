{"auto_keywords": [{"score": 0.0402368601405761, "phrase": "reemu"}, {"score": 0.016829365601857715, "phrase": "crew_protocol"}, {"score": 0.00980745285836168, "phrase": "deterministic_replay"}, {"score": 0.00481495049065317, "phrase": "parallel_full-system_emulator"}, {"score": 0.004783232571029632, "phrase": "full-system_emulation"}, {"score": 0.004720419202969916, "phrase": "extremely_useful_tool"}, {"score": 0.004643055780443262, "phrase": "systems_software"}, {"score": 0.00461246494886034, "phrase": "operating_systems"}, {"score": 0.0045218909699308385, "phrase": "current_full-system_emulators"}, {"score": 0.004346020686558718, "phrase": "concurrency_bugs"}, {"score": 0.004218602458288531, "phrase": "essentially_multi-threaded_systems_software"}, {"score": 0.004067910470129423, "phrase": "parallel_full-system_emulators"}, {"score": 0.004014452814186653, "phrase": "comprehensive_study"}, {"score": 0.0039096275435779124, "phrase": "application-level_replay_systems"}, {"score": 0.0036714667610391535, "phrase": "dynamic_binary_translator"}, {"score": 0.0036472537997966938, "phrase": "faithful_replay"}, {"score": 0.0035993041437026225, "phrase": "scalable_and_efficient_record"}, {"score": 0.0035519826240477444, "phrase": "multicore_machines"}, {"score": 0.0034250209479036392, "phrase": "memory_systems"}, {"score": 0.0033355353594739707, "phrase": "performance_bottlenecks"}, {"score": 0.003313530464737521, "phrase": "frequent_lock_operations"}, {"score": 0.0031950646670695546, "phrase": "seqlock-like_design"}, {"score": 0.003153041030690117, "phrase": "serious_contention"}, {"score": 0.003132236287543072, "phrase": "possible_starvation"}, {"score": 0.0031115683920520773, "phrase": "instrumentation_code_tracking_dependence"}, {"score": 0.003050376875258722, "phrase": "shared_memory_object"}, {"score": 0.0029805015010906013, "phrase": "required_log_files"}, {"score": 0.002931569771634119, "phrase": "minimal_local_information"}, {"score": 0.002883439044844259, "phrase": "shared_memory_location"}, {"score": 0.0028173769301594745, "phrase": "offline_log_processing_tool"}, {"score": 0.002789528662623221, "phrase": "precise_shared_memory_dependence"}, {"score": 0.0026986685585382347, "phrase": "automatic_lock_clustering_mechanism"}, {"score": 0.0026455755027979533, "phrase": "uncontended_memory_objects"}, {"score": 0.0025678829712650437, "phrase": "lock_operations"}, {"score": 0.002427286272201272, "phrase": "efficient_record"}, {"score": 0.002395336706478158, "phrase": "full-system_environments"}, {"score": 0.0023326907270271153, "phrase": "performance_evaluation"}, {"score": 0.002271679416337276, "phrase": "intel_multicore_machine"}, {"score": 0.002154392046210367, "phrase": "coremu"}, {"score": 0.0021330830123432614, "phrase": "five_parsec_benchmarks"}], "paper_keywords": ["Algorithms", " Performance", " Reliability", " Scalable", " Deterministic Replay", " Full-system Emulator"], "paper_abstract": "Full-system emulation has been an extremely useful tool in developing and debugging systems software like operating systems and hypervisors. However, current full-system emulators lack the support for deterministic replay, which limits the reproducibility of concurrency bugs that is indispensable for analyzing and debugging the essentially multi-threaded systems software. This paper analyzes the challenges in supporting deterministic replay in parallel full-system emulators and makes a comprehensive study on the sources of non-determinism. Unlike application-level replay systems, our system, called ReEmu, needs to log sources of non-determinism in both the guest software stack and the dynamic binary translator for faithful replay. To provide scalable and efficient record and replay on multicore machines, ReEmu makes several notable refinements to the CREW protocol that replays shared memory systems. First, being aware of the performance bottlenecks in frequent lock operations in the CREW protocol, ReEmu refines the CREW protocol with a seqlock-like design, to avoid serious contention and possible starvation in instrumentation code tracking dependence of racy accesses on a shared memory object. Second, to minimize the required log files, ReEmu only logs minimal local information regarding accesses to a shared memory location, but instead relies on an offline log processing tool to derive precise shared memory dependence for faithful replay. Third, ReEmu adopts an automatic lock clustering mechanism that clusters a set of uncontended memory objects to a bulk to reduce the frequencies of lock operations, which noticeably boost performance. Our prototype ReEmu is based on our open-source COREMU system and supports scalable and efficient record and replay of full-system environments (both x64 and ARM). Performance evaluation shows that ReEmu has very good performance scalability on an Intel multicore machine. It incurs only 68.9% performance overhead on average (ranging from 51.8% to 94.7%) over vanilla COREMU to record five PARSEC benchmarks running on a 16-core emulated system.", "paper_title": "Scalable Deterministic Replay in a Parallel Full-system Emulator", "paper_id": "WOS:000324158900020"}