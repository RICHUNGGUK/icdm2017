{"auto_keywords": [{"score": 0.04948948915272366, "phrase": "static_slicing"}, {"score": 0.04107868567004354, "phrase": "potential_error_locations"}, {"score": 0.00481495049065317, "phrase": "auto-correction_capability"}, {"score": 0.004716520738331953, "phrase": "dynamic_ranking"}, {"score": 0.004677711903652145, "phrase": "rtl_datapath_designs"}, {"score": 0.0045443671106012405, "phrase": "digital_systems"}, {"score": 0.004360412703519539, "phrase": "major_problem"}, {"score": 0.004324521292490181, "phrase": "economic_issue"}, {"score": 0.004132312946154097, "phrase": "existing_debugging_approaches"}, {"score": 0.003948613642680196, "phrase": "small_set"}, {"score": 0.003726533059542558, "phrase": "ever-growing_usage"}, {"score": 0.0036958398682001015, "phrase": "digital_signal_processing"}, {"score": 0.0036202043425301042, "phrase": "computer_graphics"}, {"score": 0.003590383760209319, "phrase": "embedded_systems_applications"}, {"score": 0.003502382624110703, "phrase": "polynomial_computations"}, {"score": 0.0034165310204389682, "phrase": "effective_method"}, {"score": 0.0031845067058084583, "phrase": "formal_debugging_approach"}, {"score": 0.0031193028729331667, "phrase": "dynamic_ranking_methods"}, {"score": 0.002907405102646616, "phrase": "true_errors"}, {"score": 0.002847858807513713, "phrase": "multiple_design_errors"}, {"score": 0.0028243822059448266, "phrase": "error_candidates"}, {"score": 0.0026324658253309673, "phrase": "mutation-based_technique"}, {"score": 0.002504880563070155, "phrase": "multiple_bugs"}, {"score": 0.002315367926547472, "phrase": "experimental_results"}, {"score": 0.0022773309395419427, "phrase": "proposed_technique"}, {"score": 0.0022122603123901114, "phrase": "even_multiple_bugs"}, {"score": 0.0021940118003312397, "phrase": "high_confidence"}, {"score": 0.0021669202726173928, "phrase": "short_run_time"}, {"score": 0.0021401625519713577, "phrase": "complex_designs"}, {"score": 0.0021049977753042253, "phrase": "rtl_code"}], "paper_keywords": ["Formal verification", " equivalence checking", " debugging and correction", " decision diagram", " RTL datapath designs"], "paper_abstract": "By increasing the complexity of digital systems, verification and debugging of such systems have become a major problem and economic issue. Although many computer aided design (CAD) solutions have been suggested to enhance efficiency of existing debugging approaches, they are still suffering from lack of providing a small set of potential error locations and also automatic correction mechanisms. On the other hand, the ever-growing usage of digital signal processing (DSP), computer graphics and embedded systems applications that can be modeled as polynomial computations in their datapath designs, necessitate an effective method to deal with their verification, debugging and correction. In this paper, we introduce a formal debugging approach based on static slicing and dynamic ranking methods to derive a reduced ordered set of potential error locations. In addition, to speed up finding true errors in the presence of multiple design errors, error candidates are sorted in decreasing order of their probability of being an error. After that, a mutation-based technique is employed to automatically correct bugs even in the case of multiple bugs. In order to evaluate the effectiveness of our approach, we have applied it to several industrial designs. The experimental results show that the proposed technique enables us to locate and correct even multiple bugs with high confidence in a short run time even for complex designs of up to several thousand lines of RTL code.", "paper_title": "A Scalable Formal Debugging Approach with Auto-Correction Capability Based on Static Slicing and Dynamic Ranking for RTL Datapath Designs", "paper_id": "WOS:000354414500005"}