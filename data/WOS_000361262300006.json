{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "sequential_erlang_programs"}, {"score": 0.004646496622257368, "phrase": "declarative_debugger"}, {"score": 0.0042354707960660706, "phrase": "unexpected_result"}, {"score": 0.003752126270661821, "phrase": "erroneous_program_function"}, {"score": 0.002861302930564756, "phrase": "extensive_benchmark"}, {"score": 0.002683304054823427, "phrase": "already_existing_debugging_tools"}, {"score": 0.0026077803487003, "phrase": "erlang_tracer"}, {"score": 0.002570817338292482, "phrase": "dialyzer"}, {"score": 0.0024108455980729284, "phrase": "formal_calculus"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Erlang", " Zoom debugging", " Declarative debugging"], "paper_abstract": "We present a declarative debugger for sequential Erlang programs. The tool is started when a program produces some unexpected result, and proceeds asking questions to the user about the correctness of some subcomputations until an erroneous program function is found. Then, the user can refine the granularity by zooming in the function, checking the values bound to variables and the if/case/try-catch branches taken during the execution. We show by means of an extensive benchmark that the result is a usable, scalable tool that complements already existing debugging tools such as the Erlang tracer and Dialyzer. Since the technique is based on a formal calculus, we are able to prove the soundness and completeness of the approach. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "A zoom-declarative debugger for sequential Erlang programs", "paper_id": "WOS:000361262300006"}