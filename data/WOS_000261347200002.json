{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "zero_counting"}, {"score": 0.004328856052035968, "phrase": "distinct_real_zeros"}, {"score": 0.003542557455905503, "phrase": "ambient_space"}, {"score": 0.0033482708495261864, "phrase": "polynomials'_degree"}, {"score": 0.00320453237792, "phrase": "condition_number"}, {"score": 0.003028727936200845, "phrase": "exponential_number"}, {"score": 0.0028986672783671147, "phrase": "finite-precision_arithmetic"}, {"score": 0.0028446460307503343, "phrase": "major_feature"}, {"score": 0.0026055251533586804, "phrase": "returned_output"}, {"score": 0.002158505888557746, "phrase": "parallel_polynomial_time"}, {"score": 0.0021049977753042253, "phrase": "log_d"}], "paper_keywords": ["Counting algorithms", " Polynomial systems", " Finite precision"], "paper_abstract": "We describe an algorithm to count the number of distinct real zeros of a polynomial (square) system f. The algorithm performs O(log(nDk(f))) iterations (grid refinements) where n is the number of polynomials (as well as the dimension of the ambient space), D is a bound on the polynomials' degree, and k(f) is a condition number for the system. Each iteration uses an exponential number of operations. The algorithm uses finite-precision arithmetic and a major feature of our results is a bound for the precision required to ensure that the returned output is correct which is polynomial in n and D and logarithmic in k(f). The algorithm parallelizes well in the sense that each iteration can be computed in parallel polynomial time in n, log D and log(k(f)). (C) 2008 Elsevier Inc. All rights reserved.", "paper_title": "A numerical algorithm for zero counting, I: Complexity and accuracy", "paper_id": "WOS:000261347200002"}