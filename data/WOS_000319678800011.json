{"auto_keywords": [{"score": 0.036912100113873546, "phrase": "large_packet_buffers"}, {"score": 0.026096171321061252, "phrase": "pcpi_structure"}, {"score": 0.00481495049065317, "phrase": "flow_queue_management"}, {"score": 0.004715109042114676, "phrase": "high_speed_packet_scheduling"}, {"score": 0.004686963264680882, "phrase": "priority_queues"}, {"score": 0.0046589847106386605, "phrase": "essential_building_blocks"}, {"score": 0.004617328272121826, "phrase": "advanced_per-flow_service_disciplines"}, {"score": 0.004508048086020253, "phrase": "high-speed_network_links"}, {"score": 0.004481132747216135, "phrase": "scalable_priority_queue_implementation"}, {"score": 0.004335932873514455, "phrase": "queue_elements"}, {"score": 0.004310040700905537, "phrase": "real_time"}, {"score": 0.004059438255358923, "phrase": "huge_number"}, {"score": 0.00384633057714983, "phrase": "novel_solutions"}, {"score": 0.003600944099419042, "phrase": "real-time_sorting"}, {"score": 0.003526186748088922, "phrase": "dram-based_implementation"}, {"score": 0.0033618733765472517, "phrase": "pi"}, {"score": 0.003018994916933712, "phrase": "u"}, {"score": 0.002919287408226361, "phrase": "priority_keys"}, {"score": 0.00274932545791351, "phrase": "hardware-optimized_instructions"}, {"score": 0.0026521229155782654, "phrase": "pi_and_cpi_structures"}, {"score": 0.002604814679863312, "phrase": "time_complexity"}, {"score": 0.0025583481578439894, "phrase": "processor_word_length"}, {"score": 0.0024384399939984163, "phrase": "amortized_constant_time"}, {"score": 0.0022085455097790537, "phrase": "scalable_management"}, {"score": 0.0021821915946356168, "phrase": "line_speeds"}, {"score": 0.002124036931047162, "phrase": "high-performance_network_processing_applications"}, {"score": 0.0021049977753042253, "phrase": "advanced_per-flow_scheduling"}], "paper_keywords": ["Priority queues", " per-flow scheduling", " pipelined data structure"], "paper_abstract": "Priority queues are essential building blocks for implementing advanced per-flow service disciplines and hierarchical quality-of-service at high-speed network links. Scalable priority queue implementation requires solutions to two fundamental problems. The first is to sort queue elements in real time at ever increasing line speeds (e. g., at OC-768 rates). The second is to store a huge number of packets (e. g., millions of packets). In this paper, we propose novel solutions by decomposing the problem into two parts, a succinct priority index (PI) in SRAM that can efficiently maintain a real-time sorting of priorities, coupled with a DRAM-based implementation of large packet buffers. In particular, we propose three related novel succinct PI data structures for implementing highspeed PIs: a PI, a counting priority index (CPI), and a pipelined counting priority index (pCPI). We show that all three structures can be very compactly implemented in SRAM using only Theta(U)space, where U is the size of the universe required to implement the priority keys (time stamps). We also show that our proposed PI structures can be implemented very efficiently as well by leveraging hardware-optimized instructions that are readily available in modern 64-bit processors. The operations on the PI and CPI structures take Theta(log(W) U) time complexity, where W is the processor word length (i.e., W = 64). Alternatively, operations on the pCPI structure take amortized constant time with only Theta(log(W) (U) pipeline stages (e. g., only four pipeline stages for U = 16 million). Finally, we show the application of our proposed PI structures for the scalable management of large packet buffers at line speeds. The pCPI structure can be implemented efficiently in high-performance network processing applications such as advanced per-flow scheduling with quality-of-service guarantee.", "paper_title": "Per-Flow Queue Management with Succinct Priority Indexing Structures for High Speed Packet Scheduling", "paper_id": "WOS:000319678800011"}