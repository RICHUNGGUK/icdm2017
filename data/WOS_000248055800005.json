{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "fault_detectors"}, {"score": 0.004748556604045108, "phrase": "transient_faults"}, {"score": 0.0036468482216440233, "phrase": "failure_detectors"}, {"score": 0.003129623571496151, "phrase": "memory_corruption"}, {"score": 0.002761340122199076, "phrase": "specific_tasks"}, {"score": 0.0022101055924375725, "phrase": "quick_detection"}, {"score": 0.0021049977753042253, "phrase": "implementation_designer_hints"}], "paper_keywords": ["distributed systems", " transient faults", " fault detectors", " self-stabilization"], "paper_abstract": "We present fault detectors for transient faults, (i.e., corruptions of the memory of the processors, but not of the code of the processors). We distinguish fault detectors for tasks (i.e., the problem to be solved) from failure detectors for implementations (i.e., the algorithm that solves the problem). The aim of our fault detectors is to detect a memory corruption as soon as possible. We study the amount of memory needed by the fault detectors for some specific tasks, and give bounds for each task. The amount of memory is related to the size and the number of views that a processor has to maintain to ensure a quick detection. This work may give the implementation designer hints concerning the techniques and resources that are required for implementing a task.", "paper_title": "Transient fault detectors", "paper_id": "WOS:000248055800005"}