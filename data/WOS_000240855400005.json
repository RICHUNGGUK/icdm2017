{"auto_keywords": [{"score": 0.04774633807425784, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "java_concurrency"}, {"score": 0.004631637679516574, "phrase": "managing_concurrency"}, {"score": 0.004504969093304219, "phrase": "guarded_region_abstraction"}, {"score": 0.004054299982508618, "phrase": "new_techniques"}, {"score": 0.0038354405231002323, "phrase": "transparently_scalable_and_robust_concurrent_applications"}, {"score": 0.003628352506247126, "phrase": "existing_mutual_exclusion_monitors"}, {"score": 0.003490056936165004, "phrase": "priority_inversion"}, {"score": 0.0033757067564871494, "phrase": "program_execution"}, {"score": 0.003319939715683536, "phrase": "consistent_state"}, {"score": 0.003175676186323053, "phrase": "java_semantics"}, {"score": 0.003123203316511694, "phrase": "second_technique"}, {"score": 0.002970914475538276, "phrase": "revocable_monitors"}, {"score": 0.002921815042028607, "phrase": "guarded_regions"}, {"score": 0.0028895324165046166, "phrase": "lightweight_transactions"}, {"score": 0.002718231974492536, "phrase": "multiprocessor_platforms"}, {"score": 0.0024323098907299027, "phrase": "detailed_performance_study"}, {"score": 0.0022253345930383257, "phrase": "java_monitors"}, {"score": 0.0021885300925245516, "phrase": "mutual_exclusion"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["isolation", " atomicity", " concurrency", " synchronization", " Java", " speculation"], "paper_abstract": "This paper proposes two approaches to managing concurrency in Java using a guarded region abstraction. Both approaches use revocation of such regions-the ability to undo their effects automatically and transparently. These new techniques alleviate many of the constraints that inhibit construction of transparently scalable and robust concurrent applications. The first solution, revocable monitors, augments existing mutual exclusion monitors with the ability to dynamically resolve priority inversion and deadlock, by reverting program execution to a consistent state when such situations are detected, while preserving Java semantics. The second technique, transactional monitors, extends the functionality of revocable monitors by implementing guarded regions as lightweight transactions that can be executed concurrently (or in parallel on multiprocessor platforms). The presentation includes discussion of design and implementation issues for both schemes, as well as a detailed performance study to compare their behavior with the traditional, state-of-the-art implementation of Java monitors based on mutual exclusion. Copyright (c) 2006 John Wiley & Sons, Ltd.", "paper_title": "Revocation techniques for Java concurrency", "paper_id": "WOS:000240855400005"}