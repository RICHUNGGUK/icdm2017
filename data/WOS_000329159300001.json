{"auto_keywords": [{"score": 0.04360247103779728, "phrase": "fpga_brook"}, {"score": 0.011924499334284641, "phrase": "hardware_implementation"}, {"score": 0.009130552826709699, "phrase": "commercial_behavioral_synthesis_tool"}, {"score": 0.00481495049065317, "phrase": "streaming_applications_implemented"}, {"score": 0.00450231514359539, "phrase": "novel_compilation_flow"}, {"score": 0.004320055598195391, "phrase": "streaming_programming_language"}, {"score": 0.004253618550301311, "phrase": "streaming_language"}, {"score": 0.004039423410198574, "phrase": "existing_brook_language"}, {"score": 0.003956784357357341, "phrase": "system_designers"}, {"score": 0.003370907075333389, "phrase": "multiple_hardware_units"}, {"score": 0.0032848684681050745, "phrase": "hardware_units"}, {"score": 0.0032176163279340206, "phrase": "fifo_buffers"}, {"score": 0.003151736708029235, "phrase": "small_memory_modules"}, {"score": 0.003103236567135892, "phrase": "fpgas"}, {"score": 0.0030554300179552415, "phrase": "fpga_brook_automated_design_flow"}, {"score": 0.0030083825666563898, "phrase": "source-to-source_compiler"}, {"score": 0.0026570998719084153, "phrase": "benchmark_applications"}, {"score": 0.0025230952890994236, "phrase": "experimental_results"}, {"score": 0.0023467391904246834, "phrase": "significantly_better_results"}, {"score": 0.0023225701080913388, "phrase": "corresponding_implementations"}, {"score": 0.0022053994402287925, "phrase": "automated_design_flow"}, {"score": 0.0021601997088758957, "phrase": "streaming_applications"}, {"score": 0.0021049977753042253, "phrase": "promising_methodology"}], "paper_keywords": ["Design", " Languages", " Performance", " Data parallelism", " task parallelism", " replication", " throughput", " scalability", " high-level synthesis", " parallel reduction", " field-programmable gate arrays", " streaming", " behavioral synthesis"], "paper_abstract": "This article describes the design and implementation of a novel compilation flow that implements circuits in FPGAs from a streaming programming language. The streaming language supported is called FPGA Brook and is based on the existing Brook language. It allows system designers to express applications in a way that exposes parallelism, which can be exploited through hardware implementation. FPGA Brook supports replication, allowing parts of an application to be implemented as multiple hardware units operating in parallel. Hardware units are interconnected through FIFO buffers which use the small memory modules available in FPGAs. The FPGA Brook automated design flow uses a source-to-source compiler, developed as a part of this work, and combines it with a commercial behavioral synthesis tool to generate the hardware implementation. A suite of benchmark applications was developed in FPGA Brook and implemented using our design flow. Experimental results indicate that performance of many applications scales well with replication. Our benchmark applications also achieve significantly better results than corresponding implementations using a commercial behavioral synthesis tool. We conclude that using an automated design flow for implementation of streaming applications in FPGAs is a promising methodology.", "paper_title": "Exploiting Task- and Data-Level Parallelism in Streaming Applications Implemented in FPGAs", "paper_id": "WOS:000329159300001"}