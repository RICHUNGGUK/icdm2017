{"auto_keywords": [{"score": 0.046591905845561485, "phrase": "source_codes"}, {"score": 0.044510087499644545, "phrase": "code_clones"}, {"score": 0.01588990333541561, "phrase": "generic_pipeline_model"}, {"score": 0.010528904161239997, "phrase": "code_clone_detection"}, {"score": 0.010282334609845347, "phrase": "code_clone"}, {"score": 0.00481495049065317, "phrase": "enhancing_generic_pipeline_model"}, {"score": 0.004701556483912018, "phrase": "conquer_approach"}, {"score": 0.004590820632326585, "phrase": "identical_copies"}, {"score": 0.0043945048085683005, "phrase": "current_code_clone_research"}, {"score": 0.004173244935967375, "phrase": "software_developers"}, {"score": 0.003947358102140903, "phrase": "maintenance_cost"}, {"score": 0.0038696708318671446, "phrase": "textual_based_comparison_approach"}, {"score": 0.0038390240716280302, "phrase": "token_based_comparison"}, {"score": 0.0037935066882208235, "phrase": "based_comparison_approach"}, {"score": 0.003588100032858716, "phrase": "legacy_system"}, {"score": 0.0034619440946558186, "phrase": "code_clones_increases"}, {"score": 0.002737615043512257, "phrase": "concatenation_process"}, {"score": 0.0026203386550421558, "phrase": "better_input"}, {"score": 0.002558495760339272, "phrase": "smaller_part"}, {"score": 0.0025382066972107777, "phrase": "source_code_files"}, {"score": 0.002488183412451029, "phrase": "large_chunk"}, {"score": 0.002439143581855858, "phrase": "single_pipeline"}, {"score": 0.002372103459168231, "phrase": "proposed_approach"}, {"score": 0.0022977342663599042, "phrase": "java_code_clone_detector"}, {"score": 0.002147333949483224, "phrase": "overall_runtime_performance"}, {"score": 0.0021049977753042253, "phrase": "existing_generic_pipeline_model"}], "paper_keywords": ["Code clone detection", " divide and conquer approach", " generic pipeline model"], "paper_abstract": "Code clone is known as identical copies of the same instances or fragments of source codes in software. Current code clone research focuses on the detection and analysis of code clones in order to help software developers identify code clones in source codes and reuse the source codes in order to decrease the maintenance cost. Many approaches such as textual based comparison approach, token based comparison and tree based comparison approach have been used to detect code clones. As software grows and becomes a legacy system, the complexity of these approaches in detecting code clones increases. Thus, this scenario makes it more difficult to detect code clones. Generic pipeline model is the most recent code clone detection that comprises five processes which are parsing process, pre-processing process, pooling process, comparing processes and filtering process to detect code clone. This research highlights the enhancement of the generic pipeline model using divide and conquer approach that involves concatenation process. The aim of this approach is to produce a better input for the generic pipeline model by processing smaller part of source code files before focusing on the large chunk of source codes in a single pipeline. We implement and apply the proposed approach with the support of a tool called Java Code Clone Detector (JCCD). The result obtained shows an improvement in the rate of code clone detection and overall runtime performance as compared to the existing generic pipeline model.", "paper_title": "Enhancing Generic Pipeline Model for Code Clone Detection using Divide and Conquer Approach", "paper_id": "WOS:000360783800013"}