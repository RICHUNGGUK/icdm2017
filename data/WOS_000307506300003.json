{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "specification_mining"}, {"score": 0.004768378525561471, "phrase": "execution_traces"}, {"score": 0.004653900688892822, "phrase": "likely_program_invariants"}, {"score": 0.004390192910013225, "phrase": "evolution_related_tasks"}, {"score": 0.004243289764306128, "phrase": "scenario-based_specification_mining"}, {"score": 0.004141365648080381, "phrase": "data-mining_algorithm"}, {"score": 0.003964007795174772, "phrase": "live_sequence_charts"}, {"score": 0.0035965032173588753, "phrase": "value-based_invariants"}, {"score": 0.003527181559366122, "phrase": "likely_invariants"}, {"score": 0.0034760655218366, "phrase": "specific_program_points"}, {"score": 0.00312310128226407, "phrase": "mining_algorithms"}, {"score": 0.0030628762739398855, "phrase": "scenario-specific_invariants"}, {"score": 0.003018468582368033, "phrase": "general_ones"}, {"score": 0.0029747028229638625, "phrase": "resulting_suggested_specifications"}, {"score": 0.0028890603352364273, "phrase": "modal_scenarios"}, {"score": 0.0028471655497661528, "phrase": "scenario-specific_value-based_invariants"}, {"score": 0.0027383842769094354, "phrase": "object_properties"}, {"score": 0.002659527314613792, "phrase": "mining_algorithm"}, {"score": 0.0026209522797963447, "phrase": "visual_presentation"}, {"score": 0.0025829353063908256, "phrase": "mined_scenarios"}, {"score": 0.002545468362709126, "phrase": "standard_development_environment"}, {"score": 0.002424450174817922, "phrase": "case_studies"}, {"score": 0.002400944221804575, "phrase": "promising_results"}, {"score": 0.002366110899738696, "phrase": "expressive_specifications"}, {"score": 0.0023431692392929353, "phrase": "real_programs"}, {"score": 0.0021049977753042253, "phrase": "program_comprehension"}], "paper_keywords": ["Specification mining", " Dynamic analysis", " Live sequence charts", " Value-based invariants"], "paper_abstract": "Specification mining takes execution traces as input and extracts likely program invariants, which can be used for comprehension, verification, and evolution related tasks. In this work we integrate scenario-based specification mining, which uses a data-mining algorithm to suggest ordering constraints in the form of live sequence charts, an inter-object, visual, modal, scenario-based specification language, with mining of value-based invariants, which detects likely invariants holding at specific program points. The key to the integration is a technique we call scenario-based slicing, running on top of the mining algorithms to distinguish the scenario-specific invariants from the general ones. The resulting suggested specifications are rich, consisting of modal scenarios annotated with scenario-specific value-based invariants, referring to event parameters and participating object properties. We have implemented the mining algorithm and the visual presentation of the mined scenarios within a standard development environment. An evaluation of our work over a number of case studies shows promising results in extracting expressive specifications from real programs, which could not be extracted previously. The more expressive the mined specifications, the higher their potential to support program comprehension and testing.", "paper_title": "Scenario-based and value-based specification mining: better together", "paper_id": "WOS:000307506300003"}