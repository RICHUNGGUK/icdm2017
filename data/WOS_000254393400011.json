{"auto_keywords": [{"score": 0.040108824253493075, "phrase": "gpu"}, {"score": 0.00481495049065317, "phrase": "adaptive_mesh_refinement"}, {"score": 0.004762284232953939, "phrase": "gpu."}, {"score": 0.004658426838467567, "phrase": "flexible_gpu_kernel"}, {"score": 0.004384504920139083, "phrase": "arbitrary_topology"}, {"score": 0.004241914481080374, "phrase": "small_amount"}, {"score": 0.004195418010131832, "phrase": "gpu_memory"}, {"score": 0.004058951880810154, "phrase": "adaptive_refinement_patterns"}, {"score": 0.0036958398682001015, "phrase": "additional_topology_data_structure"}, {"score": 0.0035953368057880593, "phrase": "adaptive_refinement"}, {"score": 0.003459191419478298, "phrase": "per-vertex_depth-tag"}, {"score": 0.0033651019362620866, "phrase": "usual_position"}, {"score": 0.0030808211830129304, "phrase": "correct_refinement_pattern"}, {"score": 0.0029805015010906013, "phrase": "refined_connectivity"}, {"score": 0.002915437843874821, "phrase": "coarse_polygon"}, {"score": 0.0028360962841331634, "phrase": "refined_patch"}, {"score": 0.0026838147966444783, "phrase": "vertex_shader"}, {"score": 0.002610760187858779, "phrase": "geometric_refinement"}, {"score": 0.0025537498849101596, "phrase": "bezier"}, {"score": 0.0024842242921857705, "phrase": "procedural_geometry_synthesis"}, {"score": 0.00240328454980006, "phrase": "refinement_engine"}, {"score": 0.0023507916951658455, "phrase": "multipass_rendering"}, {"score": 0.002286781334850213, "phrase": "fragment_processing"}, {"score": 0.002261666793030715, "phrase": "special_preprocess"}, {"score": 0.002224510044064184, "phrase": "input_mesh_structure"}, {"score": 0.0021049977753042253, "phrase": "vertex_shading_capabilities"}], "paper_keywords": ["adaptive mesh refinement", " real-time geometry synthesis", " GPU techniques", " displacement mapping"], "paper_abstract": "We present a flexible GPU kernel for adaptive on-the-fly refinement of meshes with arbitrary topology. By simply reserving a small amount of GPU memory to store a set of adaptive refinement patterns, on-the-fly refinement is performed by the GPU, without any preprocessing nor additional topology data structure. The level of adaptive refinement can be controlled by specifying a per-vertex depth-tag, in addition to usual position, normal, color and texture coordinates. This depth-tag is used by the kernel to instanciate the correct refinement pattern, which will map a refined connectivity on the input coarse polygon. Finally, the refined patch produced for each triangle can be displaced by the vertex shader using any kind of geometric refinement, such as Bezier patch smoothing, scalar valued displacement, procedural geometry synthesis or subdivision surfaces. This refinement engine does neither require multipass rendering nor any use of fragment processing nor special preprocess of the input mesh structure. It can be implemented on any GPU with vertex shading capabilities.", "paper_title": "A flexible kernel for adaptive mesh refinement on GPU", "paper_id": "WOS:000254393400011"}