{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "source_code"}, {"score": 0.048503710649335126, "phrase": "keyword_searches"}, {"score": 0.04157802264496638, "phrase": "existing_approaches"}, {"score": 0.04051970974935309, "phrase": "approximate_matches"}, {"score": 0.004610058444728656, "phrase": "search_effectiveness"}, {"score": 0.004458375125223899, "phrase": "programmer's_ability"}, {"score": 0.004326113419290302, "phrase": "desired_code"}, {"score": 0.0037713445867641393, "phrase": "complex_specifications"}, {"score": 0.00368397861425962, "phrase": "novel_approach"}, {"score": 0.003659389341948856, "phrase": "semantic_code_search"}, {"score": 0.003354223660940168, "phrase": "lightweight_specifications"}, {"score": 0.0032985137109323827, "phrase": "output_examples"}, {"score": 0.003243726030199957, "phrase": "semantic_search"}, {"score": 0.00318984544993994, "phrase": "smt_solver"}, {"score": 0.003136857047565403, "phrase": "program_fragments"}, {"score": 0.003003157931633302, "phrase": "symbolic_analysis"}, {"score": 0.002953261517737546, "phrase": "programmer-provided_specification"}, {"score": 0.002799108452696824, "phrase": "yahoo"}, {"score": 0.00278040931148792, "phrase": "pipes"}, {"score": 0.0027342365978762027, "phrase": "sql"}, {"score": 0.002539802613867161, "phrase": "relevant_code"}, {"score": 0.002407155340052809, "phrase": "search_precision"}, {"score": 0.0022890828779208016, "phrase": "user_specifications"}, {"score": 0.00227378279992074, "phrase": "exact_matches"}, {"score": 0.0021191645265024855, "phrase": "underlying_factors"}, {"score": 0.0021049977753042253, "phrase": "mitigation_strategies"}], "paper_keywords": ["Verification", " Languages", " Experimentation", " Semantic code search", " symbolic analysis", " SMT solvers", " lightweight specification"], "paper_abstract": "Programmers frequently search for source code to reuse using keyword searches. The search effectiveness in facilitating reuse, however, depends on the programmer's ability to specify a query that captures how the desired code may have been implemented. Further, the results often include many irrelevant matches that must be filtered manually. More semantic search approaches could address these limitations, yet existing approaches are either not flexible enough to find approximate matches or require the programmer to define complex specifications as queries. We propose a novel approach to semantic code search that addresses several of these limitations and is designed for queries that can be described using a concrete input/output example. In this approach, programmers write lightweight specifications as inputs and expected output examples. Unlike existing approaches to semantic search, we use an SMT solver to identify programs or program fragments in a repository, which have been automatically transformed into constraints using symbolic analysis, that match the programmer-provided specification. We instantiated and evaluated this approach in subsets of three languages, the Java String library, Yahoo! Pipes mashup language, and SQL select statements, exploring its generality, utility, and trade-offs. The results indicate that this approach is effective at finding relevant code, can be used on its own or to filter results from keyword searches to increase search precision, and is adaptable to find approximate matches and then guide modifications to match the user specifications when exact matches do not already exist. These gains in precision and flexibility come at the cost of performance, for which underlying factors and mitigation strategies are identified.", "paper_title": "Solving the Search for Source Code", "paper_id": "WOS:000336444200006"}