{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "closed_interval"}, {"score": 0.0047631192993526465, "phrase": "ordered_pair"}, {"score": 0.004728874038094706, "phrase": "real_numbers"}, {"score": 0.004152725837204292, "phrase": "closed_intervals"}, {"score": 0.003712964709503484, "phrase": "interval-merging_problem"}, {"score": 0.003646516176920946, "phrase": "minimum-cardinality_set"}, {"score": 0.0025682543875086934, "phrase": "parallel_time"}, {"score": 0.0025040655195012465, "phrase": "erew_pram"}, {"score": 0.002406415352892016, "phrase": "j._moreover"}, {"score": 0.0023125643872311994, "phrase": "sorted_endpoints"}, {"score": 0.0021049977753042253, "phrase": "erew_pram."}], "paper_keywords": ["design and analysis of algorithms", " parallel algorithms", " data structures", " interval-merging", " PRAM"], "paper_abstract": "A closed interval is an ordered pair of real numbers [x, y], with x <= y. The interval [x,y] represents the set {i is an element of R\\x <= i <= y}. Given a set of closed intervals J = {[a(1), b(1)], [a(2), b(2)]...., [a(k), b(k)]}, the Interval-Merging Problem is to find a minimum-cardinality set of intervals M(J) = {[x(1), y(1)], [x(2), y(2)],..., [x(j), y(j)]}, j <= k, such that the real numbers represented by J = boolean OR(k)(i=1) [a(i), b(i)] equal those represented by M (J) = boolean OR(j)(i=1) [x(i), y(i)]. In this paper, we show the problem can be solved in O(dlog d) sequential time, and in O(log d) parallel time using O(d) processors on an EREW PRAM, where d is the number of the endpoints of J. Moreover, if the input is given as a set of sorted endpoints, then the problem can be solved in O(d) sequential time, and in O(logd) parallel time using O(d/logd) processors on an EREW PRAM. (C) 2006 Elsevier Inc. All rights reserved.", "paper_title": "The interval-merging problem", "paper_id": "WOS:000242509400013"}