{"auto_keywords": [{"score": 0.04680325931611557, "phrase": "real-time_tasks"}, {"score": 0.011019966636575876, "phrase": "ptp"}, {"score": 0.005278682866356046, "phrase": "cache_pollution"}, {"score": 0.00483206342570513, "phrase": "general-purpose_tasks"}, {"score": 0.004814973679329111, "phrase": "cache"}, {"score": 0.004754508686783305, "phrase": "mixed_general-purpose"}, {"score": 0.004730543931242763, "phrase": "real-time_systems"}, {"score": 0.004664179585014193, "phrase": "cap"}, {"score": 0.004600870784042767, "phrase": "communication_overhead"}, {"score": 0.004577676867295466, "phrase": "multi-core_processors"}, {"score": 0.004554599340747326, "phrase": "off-chip_main_memories"}, {"score": 0.00450879114634833, "phrase": "virtualization_execution_environment"}, {"score": 0.004452175350191922, "phrase": "real-time_operating_systems"}, {"score": 0.004429728547427956, "phrase": "rtos"}, {"score": 0.004363058588000252, "phrase": "last_level_cache"}, {"score": 0.004297388539539564, "phrase": "general_purpose_operating_systems"}, {"score": 0.004275717966220406, "phrase": "gpos"}, {"score": 0.004222016401120075, "phrase": "bare_metal"}, {"score": 0.004179539137961248, "phrase": "current_hypervisors"}, {"score": 0.00406490838469981, "phrase": "virtual_machines"}, {"score": 0.003923532450854754, "phrase": "real-time_task"}, {"score": 0.003815896197756218, "phrase": "virtual_machine"}, {"score": 0.0036924762294207633, "phrase": "cache_resources"}, {"score": 0.0036738448109068025, "phrase": "heavy_general-purpose_tasks"}, {"score": 0.00363138683374817, "phrase": "page_table"}, {"score": 0.0033625487056259348, "phrase": "cache_usage"}, {"score": 0.003245520963944678, "phrase": "cache_space"}, {"score": 0.0031484483754909026, "phrase": "general_purpose_tasks"}, {"score": 0.0031010029460927864, "phrase": "different_proportions"}, {"score": 0.003015863240915893, "phrase": "proper_cache_ratio"}, {"score": 0.0029779376998814084, "phrase": "response_time"}, {"score": 0.002925639486548828, "phrase": "dynamic_cache_optimization_policy"}, {"score": 0.002816635287470419, "phrase": "daemon-like_thread"}, {"score": 0.0026843601001365876, "phrase": "pip"}, {"score": 0.0026438880533289893, "phrase": "dedicated_core"}, {"score": 0.002571266312964923, "phrase": "shared_physical_cache"}, {"score": 0.002551808022780891, "phrase": "soft_real-time_task"}, {"score": 0.0024629269908287405, "phrase": "considerable_advantage"}, {"score": 0.002347222150391637, "phrase": "better_response"}, {"score": 0.002242613989995648, "phrase": "high_cache_utilization"}, {"score": 0.0021920675160664806, "phrase": "experimental_results"}, {"score": 0.002164479005233624, "phrase": "real-time_performance"}, {"score": 0.002137236968970666, "phrase": "gp_performance"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Cache", " Soft real-time", " Hypervisor", " Multi-core"], "paper_abstract": "Shared cache has been widely used to lessen the communication overhead between multi-core processors and off-chip main memories. In a virtualization execution environment, real-time tasks supported by real-time operating systems (RTOS) need to share the last level cache with other general purpose tasks (supported by general purpose operating systems (GPOS) or execute on bare metal). Since current hypervisors are not aware of the attributes of tasks in the virtual machines, real-time tasks cannot be adequately supported by the hypervisor. Therefore, real-time task will suffer from many cache misses, and the response of a virtual machine may be poor due to cache pollution, especially if real-time tasks compete for cache resources with heavy general-purpose tasks. To address this issue, we propose two cache optimization management policies. One is cache partitioning (CAP) - which isolates the cache statically for real-time tasks and general-purpose tasks using page coloring. Hence the predictability of cache usage is greatly increased. CAP reduces both cache pollution, and the amount of cache space that real-time tasks use, even if other cache is not used by general purpose tasks. We also study allocating different proportions of the cache for real-time tasks and find that, a proper cache ratio is optimal to guarantee response time. Due to this, another dynamic cache optimization policy is proposed, called page table prefetching (PTP). PTP employs a daemon-like thread to maintain the cache, so as to make the contents used by real-time tasks be in cache. PIP is implemented by utilizing a dedicated core assigned to general-purpose tasks to do prefectching of a page table into shared physical cache for a soft real-time task. As the page table is referenced frequently by tasks, PTP gives a considerable advantage because fewer TLB misses occur. The results from the Cyclitest and CPUspec2006 benchmarks show that both CAP and PTP can provide better response for real-time tasks. CAP has benefits due to its simplicity, but PTP has advantages in flexibility and high cache utilization due to its dynamic cached maintenance. In addition, the experimental results show that PTP improves real-time performance more but sacrifices some GP performance. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Cache isolation for virtualization of mixed general-purpose and real-time systems", "paper_id": "WOS:000330201800023"}