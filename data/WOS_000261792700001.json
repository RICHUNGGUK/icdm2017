{"auto_keywords": [{"score": 0.03523678573169407, "phrase": "johnson"}, {"score": 0.022561942034190874, "phrase": "cache"}, {"score": 0.020603961902913775, "phrase": "siam"}, {"score": 0.004926202881986376, "phrase": "io"}, {"score": 0.0032830808525570903, "phrase": "g.n._frederickson"}, {"score": 0.0032263862712733934, "phrase": "d.b._johnson"}, {"score": 0.002906138793910919, "phrase": "efficient_algorithm"}, {"score": 0.0027822459052173113, "phrase": "smallest_element"}, {"score": 0.0021420294823879292, "phrase": "block_size"}, {"score": 0.0021049977753042253, "phrase": "memory_transfers"}], "paper_keywords": ["Algorithms", " Cache-oblivious algorithms", " Matrix selection"], "paper_abstract": "Let X[0 . . n - 1] and Y[0 . . m - 1] be two sorted arrays, and define the m x n matrix A by A[j][i] = X[i] + Y[j]. Frederickson and Johnson [G.N. Frederickson, D.B. Johnson. Generalized selection and ranking: Sorted matrices, SIAM J. Computing 13 (1984) 14-30] gave an efficient algorithm for selecting the kill smallest element from A. We show how to make this algorithm IO-efficient. Our cache-oblivious algorithm performs O ((m + n)/ B) IOs, where B is the block size of memory transfers. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Cache-oblivious selection in sorted X+Y matrices", "paper_id": "WOS:000261792700001"}