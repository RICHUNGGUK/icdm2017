{"auto_keywords": [{"score": 0.04917331388552706, "phrase": "symbolic_execution"}, {"score": 0.008649224075953414, "phrase": "error_detection"}, {"score": 0.00481495049065317, "phrase": "steering_symbolic_execution"}, {"score": 0.004656647251517823, "phrase": "promising_testing"}, {"score": 0.004612376827433774, "phrase": "analysis_methodology"}, {"score": 0.004482063543727601, "phrase": "program's_execution_space"}, {"score": 0.004397230847865867, "phrase": "test_cases"}, {"score": 0.004355415885815204, "phrase": "high_coverage"}, {"score": 0.004112711391952791, "phrase": "enormous_number"}, {"score": 0.004073590964805314, "phrase": "program_paths"}, {"score": 0.004034841146538891, "phrase": "real-world_programs"}, {"score": 0.0032382660477699695, "phrase": "specific_type"}, {"score": 0.0032074366230426727, "phrase": "path_spectra"}, {"score": 0.0029996699429582835, "phrase": "full_path_information"}, {"score": 0.0029569247903654477, "phrase": "path_exploration"}, {"score": 0.002859533151305368, "phrase": "frequency_distributions"}, {"score": 0.00283229915062791, "phrase": "explored_length-n_subpaths"}, {"score": 0.002661474607275484, "phrase": "test_coverage"}, {"score": 0.0025492740347584737, "phrase": "klee"}, {"score": 0.0023954743066925714, "phrase": "evaluation_results"}, {"score": 0.0023613185213421173, "phrase": "gnu_coreutils_programs"}, {"score": 0.0022401855403251653, "phrase": "program-specific_information"}, {"score": 0.00220823903315848, "phrase": "different_degrees"}, {"score": 0.0021049977753042253, "phrase": "traditional_strategies"}], "paper_keywords": ["less traveled", " path spectra", " symbolic execution"], "paper_abstract": "Symbolic execution is a promising testing and analysis methodology. It systematically explores a program's execution space and can generate test cases with high coverage. One significant practical challenge for symbolic execution is how to effectively explore the enormous number of program paths in real-world programs. Various heuristics have been proposed for guiding symbolic execution, but they are generally inefficient and ad-hoc. In this paper, we introduce a novel, unified strategy to guide symbolic execution to less explored parts of a program. Our key idea is to exploit a specific type of path spectra, namely the length-n subpath program spectra, to systematically approximate full path information for guiding path exploration. In particular, we use frequency distributions of explored length-n subpaths to prioritize \"less traveled\" parts of the program to improve test coverage and error detection. We have implemented our general strategy in KLEE, a state-of-the-art symbolic execution engine. Evaluation results on the GNU Coreutils programs show that (1) varying the length n captures program-specific information and exhibits different degrees of effectiveness, and (2) our general approach outperforms traditional strategies in both coverage and error detection.", "paper_title": "Steering Symbolic Execution to Less Traveled Paths", "paper_id": "WOS:000327697300002"}