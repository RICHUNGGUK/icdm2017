{"auto_keywords": [{"score": 0.03139550414351371, "phrase": "np"}, {"score": 0.00481495049065317, "phrase": "software-controlled_local_memories"}, {"score": 0.0045726187330434025, "phrase": "power-efficient_access"}, {"score": 0.0043144799365586375, "phrase": "local_memory_allocation"}, {"score": 0.0041773934798743405, "phrase": "linearized_programs"}, {"score": 0.004044645056447888, "phrase": "weighted_interval-graph_coloring_problem"}, {"score": 0.003816197777388722, "phrase": "color_interval"}, {"score": 0.0033971539563683174, "phrase": "graph-theoretical_decision_problem"}, {"score": 0.003289117944111902, "phrase": "classical_ship-building_problem"}, {"score": 0.0031233388358844188, "phrase": "complexity_properties"}, {"score": 0.003004494701922268, "phrase": "submarine-building_problem"}, {"score": 0.0027982016314450717, "phrase": "linear_time"}, {"score": 0.0027622407190589326, "phrase": "not-so-proper_interval_graphs"}, {"score": 0.002622947550220266, "phrase": "proper_interval_graphs"}, {"score": 0.0025394700487126414, "phrase": "clustering_heuristic"}, {"score": 0.00247460024299964, "phrase": "interval_graph"}, {"score": 0.002427035025924384, "phrase": "not-so-proper_interval_graph"}, {"score": 0.002319566486828135, "phrase": "local_memory_assignment"}, {"score": 0.002202547013259953, "phrase": "large_number"}, {"score": 0.0021742244283295986, "phrase": "randomly_generated_interval_graphs"}, {"score": 0.002132420504803564, "phrase": "statistical_features"}, {"score": 0.0021049977753042253, "phrase": "standard_local_memory_allocation_benchmarks"}], "paper_keywords": ["Algorithms", " Performance", " Local memory", " scratchpad memory", " memory allocation", " compiler"], "paper_abstract": "Compilers use software-controlled local memories to provide fast, predictable, and power-efficient access to critical data. We show that the local memory allocation for straight-line, or linearized programs is equivalent to a weighted interval-graph coloring problem. This problem is new when allowing a color interval to \"wrap around,\" and we call it the submarine-building problem. This graph-theoretical decision problem differs slightly from the classical ship-building problem, and exhibits very interesting and unusual complexity properties. We demonstrate that the submarine-building problem is NP-complete, while it is solvable in linear time for not-so-proper interval graphs, an extension of the the class of proper interval graphs. We propose a clustering heuristic to approximate any interval graph into a not-so-proper interval graph, decoupling spill code generation from local memory assignment. We apply this heuristic to a large number of randomly generated interval graphs reproducing the statistical features of standard local memory allocation benchmarks, comparing with state-of-the-art heuristics.", "paper_title": "A Decoupled Local Memory Allocator", "paper_id": "WOS:000313911800011"}