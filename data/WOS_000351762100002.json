{"auto_keywords": [{"score": 0.04746804074835708, "phrase": "reactive_systems"}, {"score": 0.03588055272496736, "phrase": "data_flow_analyses"}, {"score": 0.02788690362495344, "phrase": "tcc_programs"}, {"score": 0.00481495049065317, "phrase": "temporal_concurrent_constraint_programs"}, {"score": 0.004781357546476652, "phrase": "timed_concurrent_constraint_programming"}, {"score": 0.004681971826924847, "phrase": "declarative_model"}, {"score": 0.004350040802144489, "phrase": "universal_tcc_formalism"}, {"score": 0.0040133278382101885, "phrase": "private_names"}, {"score": 0.003943636379643578, "phrase": "mobile_systems"}, {"score": 0.003916098498242888, "phrase": "security_protocols"}, {"score": 0.0038078492247427594, "phrase": "denotational_semantics"}, {"score": 0.003663857375787215, "phrase": "\"_semantics"}, {"score": 0.0036002125374696237, "phrase": "closure_operators"}, {"score": 0.0034278075289561213, "phrase": "general_framework"}, {"score": 0.0033564619316337634, "phrase": "utcc_programs"}, {"score": 0.0033330104902937413, "phrase": "abstract_interpretation_techniques"}, {"score": 0.00329813918116714, "phrase": "concrete_and_abstract_semantics"}, {"score": 0.0029792474431139067, "phrase": "abstract_domain"}, {"score": 0.002937745193225725, "phrase": "different_analyses"}, {"score": 0.002767696345005216, "phrase": "abstract_domains"}, {"score": 0.002729133029776093, "phrase": "logic_programming"}, {"score": 0.002422249273477746, "phrase": "abstract_semantics"}, {"score": 0.002388487669097511, "phrase": "secrecy_flaw"}, {"score": 0.002363474907331799, "phrase": "security_protocol"}, {"score": 0.0021049977753042253, "phrase": "optimizing_compilation"}], "paper_keywords": ["timed concurrent constraint programming", " process calculi", " abstract interpretation", " denotational semantics", " reactive systems"], "paper_abstract": "Timed Concurrent Constraint Programming (tcc) is a declarative model for concurrency offering a logic for specifying reactive systems, i.e., systems that continuously interact with the environment. The universal tcc formalism (utcc) is an extension of tcc with the ability to express mobility. Here mobility is understood as communication of private names as typically done for mobile systems and security protocols. In this paper we consider the denotational semantics for tcc, and extend it to a \"collecting\" semantics for utcc based on closure operators over sequences of constraints. Relying on this semantics, we formalize a general framework for data flow analyses of tcc and utcc programs by abstract interpretation techniques. The concrete and abstract semantics that we propose are compositional, thus allowing us to reduce the complexity of data flow analyses. We show that our method is sound and parametric with respect to the abstract domain. Thus, different analyses can be performed by instantiating the framework. We illustrate how it is possible to reuse abstract domains previously defined for logic programming to perform, for instance, a groundness analysis for tcc programs. We show the applicability of this analysis in the context of reactive systems. Furthermore, we also make use of the abstract semantics to exhibit a secrecy flaw in a security protocol. We also show how it is possible to make an analysis which may show that tcc programs are suspension-free. This can be useful for several purposes, such as for optimizing compilation or for debugging.", "paper_title": "Abstract interpretation of temporal concurrent constraint programs", "paper_id": "WOS:000351762100002"}