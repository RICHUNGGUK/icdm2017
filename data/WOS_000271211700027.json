{"auto_keywords": [{"score": 0.04889648139490369, "phrase": "haskell"}, {"score": 0.036827300108695844, "phrase": "ag"}, {"score": 0.00481495049065317, "phrase": "attribute_grammars_fly_first-class"}, {"score": 0.004735651915966323, "phrase": "aspect_oriented_programming"}, {"score": 0.004657653216262924, "phrase": "attribute_grammars"}, {"score": 0.004431246962597134, "phrase": "recursive_computations"}, {"score": 0.004394592555435104, "phrase": "data_types"}, {"score": 0.004077995480957875, "phrase": "new_data_types"}, {"score": 0.00402748353567517, "phrase": "type_alternatives"}, {"score": 0.00396110232316167, "phrase": "new_operations"}, {"score": 0.003928321515373316, "phrase": "existing_data_types"}, {"score": 0.003721735062704032, "phrase": "e._g._type_checking"}, {"score": 0.003615016816532732, "phrase": "interactive_development"}, {"score": 0.003585089792133518, "phrase": "proper_error_reporting"}, {"score": 0.003424850089214916, "phrase": "combinator_library"}, {"score": 0.003354393040689453, "phrase": "previous_attempts"}, {"score": 0.0033266163944946185, "phrase": "embedding_ags"}, {"score": 0.003285380677401785, "phrase": "domain-specific_language"}, {"score": 0.003231191164622055, "phrase": "extensible_records"}, {"score": 0.003177892611195514, "phrase": "haskell's_type_system"}, {"score": 0.002900037689072025, "phrase": "ag_patterns"}, {"score": 0.0027934768366077397, "phrase": "ag_well-formedness"}, {"score": 0.0026796495639791426, "phrase": "typed_embedding"}, {"score": 0.0025385621498128243, "phrase": "hlist-like_typed_heterogeneous_collections"}, {"score": 0.0024452510143564057, "phrase": "well-formedness_conditions"}, {"score": 0.002424984362388813, "phrase": "type-level_predicates"}, {"score": 0.002268769196700254, "phrase": "common_programming_patterns"}, {"score": 0.0022220423638260015, "phrase": "typical_use_cases"}, {"score": 0.0021225958499898182, "phrase": "realistic_example"}, {"score": 0.0021049977753042253, "phrase": "type-class-based_type-level_programming"}], "paper_keywords": ["Design", " Languages", " Performance", " Standardization", " Attribute Grammars", " Class system", " Lazy evaluation", " Type-level programming", " Haskell", " HList"], "paper_abstract": "Attribute Grammars (AGs), a general-purpose formalism for describing recursive computations over data types, avoid the trade-off which arises when building software incrementally: should it be easy to add new data types and data type alternatives or to add new operations on existing data types? However, AGs are usually implemented as a pre-processor, leaving e. g. type checking to later processing phases and making interactive development, proper error reporting and debugging difficult. Embedding AG into Haskell as a combinator library solves these problems. Previous attempts at embedding AGs as a domain-specific language were based on extensible records and thus exploiting Haskell's type system to check the well-formedness of the AG, but fell short in compactness and the possibility to abstract over oft occurring AG patterns. Other attempts used a very generic mapping for which the AG well-formedness could not be statically checked. We present a typed embedding of AG in Haskell satisfying all these requirements. The key lies in using HList-like typed heterogeneous collections (extensible polymorphic records) and expressing AG well-formedness conditions as type-level predicates (i.e., type-class constraints). By further type-level programming we can also express common programming patterns, corresponding to the typical use cases of monads such as Reader, Writer and State. The paper presents a realistic example of type-class-based type-level programming in Haskell.", "paper_title": "Attribute Grammars Fly First-Class How to do Aspect Oriented Programming in Haskell", "paper_id": "WOS:000271211700027"}