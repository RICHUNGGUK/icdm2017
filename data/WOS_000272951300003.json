{"auto_keywords": [{"score": 0.04701834127382451, "phrase": "space_complexity"}, {"score": 0.00482999301690427, "phrase": "time"}, {"score": 0.004586531354697466, "phrase": "lower_bounds"}, {"score": 0.004234456398783788, "phrase": "k-cas_primitives"}, {"score": 0.004061584718427419, "phrase": "concurrent_objects"}, {"score": 0.003855347387268162, "phrase": "overly_restrictive_use"}, {"score": 0.0036595438031512217, "phrase": "lower_bound"}, {"score": 0.0034978813769575233, "phrase": "collect_object"}, {"score": 0.0028392545452904762, "phrase": "collect_implementation_round_complexity"}, {"score": 0.0028097829999199596, "phrase": "k-cas_operations"}, {"score": 0.0026762323224804197, "phrase": "total_step_complexity"}, {"score": 0.002648448458159033, "phrase": "key_objects"}, {"score": 0.0023285383529595416, "phrase": "single-writer_snapshot"}, {"score": 0.0021049977753042253, "phrase": "exactly_k_base_objects"}], "paper_keywords": ["Compare&swap (CAS)", " k-compare&swap (k-CAS)", " conditional synchronization primitives", " round complexity", " collect", " counter", " stack", " queue"], "paper_abstract": "This paper presents lower bounds on the time and space complexity of implementations that use k-compare& swap (k-CAS) synchronization primitives. We prove that using k-CAS primitives can improve neither the time nor the space complexity of implementations of widely used concurrent objects, such as counter, stack, queue, and collect. Surprisingly, overly restrictive use of k-CAS may even increase the space complexity required by such implementations. We prove a lower bound of Omega(log(2) n) on the round complexity of implementations of a collect object using read, write, and k-CAS, for any k, where n is the number of processes in the system. There is an implementation of collect with O(log(2) n) round complexity that uses only reads and writes. Thus, our lower bound establishes that k-CAS is no stronger than read and write for collect implementation round complexity. For k-CAS operations that return the values of all the objects they access, we prove that the total step complexity of implementing key objects such as counters, stacks, and queues is Omega(n log(k) n). We also prove that k-CAS cannot improve the space complexity of implementing many objects (including counter, stack, queue, and single-writer snapshot). An implementation has to use at least n base objects even if k-CAS is allowed, and if all operations (other than read) swap exactly k base objects, then it must use at least k . n base objects.", "paper_title": "Time and Space Lower Bounds for Implementations Using k-CAS", "paper_id": "WOS:000272951300003"}