{"auto_keywords": [{"score": 0.02827025156412822, "phrase": "parallel_regions"}, {"score": 0.017312815984993506, "phrase": "data_parallelism"}, {"score": 0.00481495049065317, "phrase": "safe_data_parallelism_for_general_streaming"}, {"score": 0.004688321299229397, "phrase": "possibly_infinite_streams"}, {"score": 0.004654779963297256, "phrase": "linear_scalability"}, {"score": 0.00451659023910662, "phrase": "high_throughput"}, {"score": 0.004468684611798047, "phrase": "low_latency_requirements"}, {"score": 0.004327981760540394, "phrase": "operator_graphs"}, {"score": 0.00421410521089045, "phrase": "data_tuples"}, {"score": 0.004169394481182493, "phrase": "general_streaming_applications"}, {"score": 0.003767517649628532, "phrase": "parallel_systems"}, {"score": 0.0036488111139918135, "phrase": "large_clusters"}, {"score": 0.003261934055562238, "phrase": "previous_data"}, {"score": 0.003244567402785763, "phrase": "parallel_optimizations"}, {"score": 0.0030270132320276096, "phrase": "runtime_system"}, {"score": 0.002931569771634119, "phrase": "general_stream_processing"}, {"score": 0.002824005136794786, "phrase": "transformed_program"}, {"score": 0.0027349450784503273, "phrase": "original_sequential_version"}, {"score": 0.0026205405415623525, "phrase": "operator_selectivity"}, {"score": 0.002470987929071079, "phrase": "distributed_runtime_system"}], "paper_keywords": ["Data processing", " distributed computing", " parallel programming"], "paper_abstract": "Streaming applications process possibly infinite streams of data and often have both high throughput and low latency requirements. They are comprised of operator graphs that produce and consume data tuples. General streaming applications use stateful, selective, and user-defined operators. The stream programming model naturally exposes task and pipeline parallelism, enabling it to exploit parallel systems of all kinds, including large clusters. However, data parallelism must either be manually introduced by programmers, or extracted as an optimization by compilers. Previous data parallel optimizations did not apply to selective, stateful and user-defined operators. This article presents a compiler and runtime system that automatically extracts data parallelism for general stream processing. Data-parallelization is safe if the transformed program has the same semantics as the original sequential version. The compiler forms parallel regions while considering operator selectivity, state, partitioning, and graph dependencies. The distributed runtime system ensures that tuples always exit parallel regions in the same order they would without data parallelism, using the most efficient strategy as identified by the compiler. Our experiments using 100 cores across 14 machines show linear scalability for parallel regions that are computation-bound, and near linear scalability when tuples are shuffled across parallel regions.", "paper_title": "Safe Data Parallelism for General Streaming", "paper_id": "WOS:000348053400016"}