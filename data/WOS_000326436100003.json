{"auto_keywords": [{"score": 0.0500773937478301, "phrase": "functional_languages"}, {"score": 0.03514549768352576, "phrase": "haskell"}, {"score": 0.03457952219113133, "phrase": "erlang"}, {"score": 0.004782872056480552, "phrase": "refactoring"}, {"score": 0.004518442937844318, "phrase": "typical_refactorings"}, {"score": 0.004458375125223899, "phrase": "function_extraction"}, {"score": 0.004086853315059217, "phrase": "program_transformation"}, {"score": 0.004019024264498125, "phrase": "source_code"}, {"score": 0.003939107874750185, "phrase": "'core'_language"}, {"score": 0.0037713445867641393, "phrase": "code_base"}, {"score": 0.0036963349119571104, "phrase": "single_function_definition"}, {"score": 0.0035270425911920595, "phrase": "automated_support"}, {"score": 0.003399466007862412, "phrase": "building_tools"}, {"score": 0.003365477675675987, "phrase": "functional_programs"}, {"score": 0.0032546105164772995, "phrase": "wrangler"}, {"score": 0.003136857047565403, "phrase": "functional_programming_languages"}, {"score": 0.003003157931633302, "phrase": "larger_example"}, {"score": 0.002943381865409788, "phrase": "system_design"}, {"score": 0.0029041917003677234, "phrase": "system_implementation"}, {"score": 0.0026797398345997114, "phrase": "particular_refactorings"}, {"score": 0.0024725918236048632, "phrase": "core_tools"}, {"score": 0.0024152394732063908, "phrase": "test_frameworks"}, {"score": 0.0023592142778542055, "phrase": "code_clones"}, {"score": 0.0022061853706148945, "phrase": "general_conclusions"}, {"score": 0.0021049977753042253, "phrase": "general_value"}], "paper_keywords": [""], "paper_abstract": "Refactoring is the process of changing the design of a program without changing what it does. Typical refactorings, such as function extraction and generalisation, are intended to make a program more amenable to extension, more comprehensible and so on. Refactorings differ from other sorts of program transformation in being applied to source code, rather than to a 'core' language within a compiler, and also in having an effect across a code base, rather than to a single function definition, say. Because of this, there is a need to give automated support to the process. This paper reflects on our experience of building tools to refactor functional programs written in Haskell (HaRe) and Erlang (Wrangler). We begin by discussing what refactoring means for functional programming languages, first in theory, and then in the context of a larger example. Next, we address system design and details of system implementation as well as contrasting the style of refactoring and tooling for Haskell and Erlang. Building both tools led to reflections about what particular refactorings mean, as well as requiring analyses of various kinds, and we discuss both of these. We also discuss various extensions to the core tools, including integrating the tools with test frameworks; facilities for detecting and eliminating code clones; and facilities to make the systems extensible by users. We then reflect on our work by drawing some general conclusions, some of which apply particularly to functional languages, while many others are of general value.", "paper_title": "Refactoring tools for functional languages", "paper_id": "WOS:000326436100003"}