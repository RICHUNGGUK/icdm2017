{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "atomic_features"}, {"score": 0.004135010810625326, "phrase": "pessimistic_concurrency_control_scheme"}, {"score": 0.004046020290832207, "phrase": "race_conditions"}, {"score": 0.0037411604449359794, "phrase": "initial_scoop_model"}, {"score": 0.0036926236934657864, "phrase": "transactional_semantics"}, {"score": 0.003504670673093149, "phrase": "distributed_object-oriented_programs"}, {"score": 0.0034143003168921114, "phrase": "partial_failures"}, {"score": 0.003340768341189764, "phrase": "programming_language_support"}, {"score": 0.00326881479036966, "phrase": "atomicity_properties"}, {"score": 0.0032404677650217407, "phrase": "particular_features"}, {"score": 0.0030888830649190282, "phrase": "application_programmer"}, {"score": 0.002868404184756449, "phrase": "reliable_distributed_software"}, {"score": 0.002583597507349819, "phrase": "eiffel_programming_language"}, {"score": 0.0022967713922705, "phrase": "back_-_backward_recovery"}, {"score": 0.0022472527731744974, "phrase": "non-atomic_ones"}, {"score": 0.0021987994275190314, "phrase": "compensation_mechanisms"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["transactions", " concurrency", " compensation", " objects", " SCOOP"], "paper_abstract": "SCOOP (Simple Concurrent Object-Oriented Programming) is a model of concurrency that builds on the concept of contracts for synchronizing accesses to objects. This model is based on a pessimistic concurrency control scheme whose reservation semantics avoids race conditions altogether-alas at the expense of parallelism. In this paper we propose to extend the initial SCOOP model by adding transactional semantics, aspiring to an increase of performance but also reliability of distributed object-oriented programs executing in the presence of partial failures. Our solution consists in programming language support for the specification of atomicity properties of particular features (routines or attributes). With such support, the application programmer is assisted by the compiler in composing atomic features, which substantially alleviates the task of constructing reliable distributed software. We investigate the impact of concepts such as nesting, inheritance, polymorphism, and contracts in such a statically typed approach, illustrated in the context of the Eiffel programming language. in particular, we depict how our solution enables the composition of atomic features from not only elementary atomic features (such as updates applied to variables which can be rolled back - backward recovery) but also from non-atomic ones by making use of compensation mechanisms (forward recovery). (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "Composing atomic features", "paper_id": "WOS:000241921200003"}