{"auto_keywords": [{"score": 0.004695900553353526, "phrase": "floating-point_experts"}, {"score": 0.004608539830653038, "phrase": "mathematical_formulas"}, {"score": 0.004466519142879166, "phrase": "imprecise_results"}, {"score": 0.0043560464825349275, "phrase": "floating-point_arithmetic"}, {"score": 0.0037246656582642272, "phrase": "unbounded_exponent_range"}, {"score": 0.003587235362628753, "phrase": "square_root"}, {"score": 0.003454858296390957, "phrase": "floating-point_number"}, {"score": 0.0033905067962602515, "phrase": "exactly_vertical_bar"}, {"score": 0.0031448288291084, "phrase": "floating-point_computation"}, {"score": 0.002341958851390876, "phrase": "coq_proof_assistant"}, {"score": 0.002298288831092204, "phrase": "flocq_library"}], "paper_keywords": ["Floating-point", " formal proof", " square", " square root", " radix", " Coq"], "paper_abstract": "Floating-point experts know that mathematical formulas may fail or give imprecise results when implemented in floating-point arithmetic. This article describes an example where, surprisingly, it is absolutely not the case. Indeed, using radix 2 and an unbounded exponent range, the computation of the square root of the square of a floating-point number a is exactly vertical bar a vertical bar. A consequence is the fact that the floating-point computation of a/root(a(2) + b(2)) is always in the interval [-1, 1]. This removes the need for a test when calling an arccos or an arcsin on this value. For more guarantees, this property was formally checked using the Coq proof assistant and the Flocq library. The conclusion will give hints on what happens without assumptions and in other radices, where the behavior is very different.", "paper_title": "Stupid is as Stupid Does: Taking the Square Root of the Square of a Floating-Point Number", "paper_id": "WOS:000365196900004"}