{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java"}, {"score": 0.004527024978801684, "phrase": "novel_technique"}, {"score": 0.004416713079266374, "phrase": "static_race_detection"}, {"score": 0.00430907756010007, "phrase": "java_programs"}, {"score": 0.0036703791815812328, "phrase": "static_analyses"}, {"score": 0.0033664873319204027, "phrase": "memory_accesses"}, {"score": 0.0026953359825383624, "phrase": "multi-threaded_java_programs"}, {"score": 0.0021576973674470997, "phrase": "serious_and_previously_unknown_concurrency_bugs"}], "paper_keywords": ["static race detection", " Java", " synchronization", " concurrency", " multi-threading"], "paper_abstract": "We present a novel technique for static race detection in Java programs, comprised of a series of stages that employ a combination of static analyses to successively reduce the pairs of memory accesses potentially involved in a race. We have implemented our technique and applied it to a suite of multi-threaded Java programs. Our experiments show that it is precise, scalable, and useful, reporting tens to hundreds of serious and previously unknown concurrency bugs in large, widely-used programs with few false alarms.", "paper_title": "Effective static race detection for Java", "paper_id": "WOS:000202972100027"}