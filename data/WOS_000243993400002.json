{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "search_problems"}, {"score": 0.04063508760036862, "phrase": "logic_programming"}, {"score": 0.004534136929881113, "phrase": "search_problem"}, {"score": 0.004399905285945236, "phrase": "logic_theory"}, {"score": 0.004269630481719451, "phrase": "problem_solutions"}, {"score": 0.003800093834008562, "phrase": "answer_sets"}, {"score": 0.003687512797620773, "phrase": "predicate_logic"}, {"score": 0.0036188435232325337, "phrase": "effective_implementations"}, {"score": 0.003578255090799811, "phrase": "asp_paradigm"}, {"score": 0.003459191419478298, "phrase": "answer-set_semantics"}, {"score": 0.003407549468745519, "phrase": "similar_scope"}, {"score": 0.0032694619052789768, "phrase": "predicate_calculus"}, {"score": 0.003220643255032943, "phrase": "encoding_search_problems"}, {"score": 0.003148774338287351, "phrase": "expressive_power"}, {"score": 0.003043957650600757, "phrase": "npmv."}, {"score": 0.002953711377604328, "phrase": "computational_approaches"}, {"score": 0.002931569771634119, "phrase": "model_finding"}, {"score": 0.0028769371032728733, "phrase": "latter_issue"}, {"score": 0.0028233196851239753, "phrase": "two-pronged_approach"}, {"score": 0.0026483647033436674, "phrase": "computing_models"}, {"score": 0.002628506002255396, "phrase": "propositional_theories"}, {"score": 0.0025409639091476363, "phrase": "pseudo-boolean_constraints"}, {"score": 0.0024014759148123736, "phrase": "pseudo-boolean_satisfiability"}, {"score": 0.0022441378838655712, "phrase": "native_solvers"}, {"score": 0.0021530945641993152, "phrase": "experimental_results"}, {"score": 0.002128910637262527, "phrase": "computational_effectiveness"}, {"score": 0.0021049977753042253, "phrase": "overall_approach"}], "paper_keywords": ["theory", " language", " satisfiability", " pseudo-Boolean constraints", " predicate logic", " search problems", " constraints"], "paper_abstract": "The answer-set programming (ASP) paradigm is a way of using logic to solve search problems. Given a search problem, to solve it one designs a logic theory so that models of this theory represent problem solutions. To compute a solution to the problem, one computes a model of the theory. Several answer-set programming formalisms have been developed on the basis of logic programming with the semantics of answer sets. In this article we show that predicate logic also gives rise to effective implementations of the ASP paradigm, similar in spirit to logic programming with the answer-set semantics and with a similar scope of applicability. Specifically, we propose two logics based on predicate calculus as formalisms for encoding search problems. We show that the expressive power of these logics is given by the class NPMV. We demonstrate their use in programming and discuss computational approaches to model finding. To address this latter issue, we follow a two-pronged approach. On the one hand, we show that the problem can be reduced to that of computing models of propositional theories and, more generally, of collections of pseudo-Boolean constraints. Consequently, programs (solvers) developed in the areas of propositional and pseudo-Boolean satisfiability can be used to compute models of theories in our logics. On the other hand, we develop native solvers designed specifically to exploit features of our formalisms. We present experimental results demonstrating the computational effectiveness of the overall approach.", "paper_title": "Predicate-calculus-based logics for modeling and solving search problems", "paper_id": "WOS:000243993400002"}