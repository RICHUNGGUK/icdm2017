{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "fiat"}, {"score": 0.015318345178453941, "phrase": "abstract_data_types"}, {"score": 0.01093515868607037, "phrase": "query_structures"}, {"score": 0.0046176782475198085, "phrase": "proof_assistant"}, {"score": 0.004382364826200616, "phrase": "coq_proof_assistant_supporting_refinement"}, {"score": 0.0042692243768616455, "phrase": "efficient_functional_programs"}, {"score": 0.004202741104973709, "phrase": "high_degree"}, {"score": 0.0040942189695983185, "phrase": "refinement_process"}, {"score": 0.004030449969901066, "phrase": "proof_trail"}, {"score": 0.003926359151817743, "phrase": "normal_coq_kernel"}, {"score": 0.003610929883213109, "phrase": "private_data"}, {"score": 0.003251920460276645, "phrase": "sql-like_query"}, {"score": 0.0030062165552187086, "phrase": "sql-inspired_notation"}, {"score": 0.002823050755743821, "phrase": "mathematical_sets"}, {"score": 0.0023499703712897293, "phrase": "sql_indexes"}, {"score": 0.002289180040240783, "phrase": "useful_views"}, {"score": 0.002253461585851626, "phrase": "abstract_data"}, {"score": 0.002172266188075892, "phrase": "new_programming_modularity_possibilities"}, {"score": 0.002127186380459509, "phrase": "automated_refinement_system"}, {"score": 0.0021049977753042253, "phrase": "proved-correct_rules"}], "paper_keywords": [""], "paper_abstract": "We present Fiat, a library for the Coq proof assistant supporting refinement of declarative specifications into efficient functional programs with a high degree of automation. Each refinement process leaves a proof trail, checkable by the normal Coq kernel, justifying its soundness. We focus on the synthesis of abstract data types that package methods with private data. We demonstrate the utility of our framework by applying it to the synthesis of query structures abstract data types with SQL-like query and insert operations. Fiat includes a library for writing specifications of query structures in SQL-inspired notation, expressing operations over relations (tables) in terms of mathematical sets. This library includes a suite of tactics for automating the refinement of specifications into efficient, correct-by-construction OCaml code. Using these tactics, a programmer can generate such an implementation completely automatically by only specifying the equivalent of SQL indexes, data structures capturing useful views of the abstract data. Throughout we speculate on the new programming modularity possibilities enabled by an automated refinement system with proved-correct rules.", "paper_title": "Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant", "paper_id": "WOS:000354800500055"}