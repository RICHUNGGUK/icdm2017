{"auto_keywords": [{"score": 0.04404291878285864, "phrase": "jmm_causality_requirements"}, {"score": 0.00481495049065317, "phrase": "java_causality_requirements"}, {"score": 0.004563427013973105, "phrase": "shared_memory_accesses"}, {"score": 0.004490552331642995, "phrase": "multithreaded_java_program"}, {"score": 0.004395185177346749, "phrase": "memory_accesses"}, {"score": 0.004055176557424983, "phrase": "post-mortem_verification"}, {"score": 0.003844754596985996, "phrase": "np"}, {"score": 0.003451766520526601, "phrase": "slightly_stronger_memory_model"}, {"score": 0.0033602844686125375, "phrase": "actual_execution_order"}, {"score": 0.0033243718810317254, "phrase": "read_actions"}, {"score": 0.002985631781749091, "phrase": "aforementioned_simplifications"}, {"score": 0.002890887778279196, "phrase": "non-polynomial_version"}, {"score": 0.0028446460307503343, "phrase": "short_test_sequences"}, {"score": 0.0024868972942701582, "phrase": "causality_test_case"}, {"score": 0.002407941567598653, "phrase": "public_discussion"}, {"score": 0.002174041708084857, "phrase": "permissible_-_axe"}, {"score": 0.0021049977753042253, "phrase": "formal_model"}], "paper_keywords": ["concurrency", " complexity", " Java", " memory model", " multi-threading", " verification", " shared memory"], "paper_abstract": "The Java Memory Model (JMM) formalizes the behavior of shared memory accesses in a multithreaded Java program. Dependencies between memory accesses are acyclic, as defined by the JMM causality requirements. We study the problem of post-mortem verification of these requirements and prove that the task is NP-complete. We then argue that in some cases the task may be simplified either by considering a slightly stronger memory model or by tracing the actual execution order of Read actions in each thread. Our verification algorithm has two versions: a polynomial version, to be used when one of the aforementioned simplifications is possible, and a non-polynomial version - for short test sequences only - to be used in all other cases. Finally, we argue that the JMM causality requirements could benefit from some fine-tuning. Our examination of causality test case 6 (presented in the public discussion of the JMM) clearly shows that some useful compiler optimizations - which one would expect to be permissible - axe in fact prohibited by the formal model.", "paper_title": "Verification of the Java causality requirements", "paper_id": "WOS:000237451000016"}