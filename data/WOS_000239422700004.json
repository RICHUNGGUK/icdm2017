{"auto_keywords": [{"score": 0.04367732323962223, "phrase": "recursion_scheme"}, {"score": 0.00481495049065317, "phrase": "generic_programming"}, {"score": 0.004717723626157272, "phrase": "sized_types"}, {"score": 0.004483120978156604, "phrase": "polytypic_or_generic_program"}, {"score": 0.004347972379250724, "phrase": "concrete_recursive_type"}, {"score": 0.003807684498435389, "phrase": "instantiation_type"}, {"score": 0.003438058620195309, "phrase": "generic_program"}, {"score": 0.0029196116767956273, "phrase": "traditional_methods"}, {"score": 0.002556359086441866, "phrase": "program_type"}, {"score": 0.0023079225317714815, "phrase": "type-based_termination"}, {"score": 0.0021049977753042253, "phrase": "sized_polytypic_programming"}], "paper_keywords": [""], "paper_abstract": "Instances of a polytypic or generic program for a concrete recursive type often exhibit a recursion scheme that is derived from the recursion scheme of the instantiation type. In practice, the programs obtained from a generic program are usually terminating, but the proof of termination cannot be carried out with traditional methods as term orderings alone, since termination often crucially relies on the program type. This problem is tackled by an adaption of type-based termination to generic programming, and a framework for sized polytypic programming is described.", "paper_title": "Towards generic programming with sized types", "paper_id": "WOS:000239422700004"}