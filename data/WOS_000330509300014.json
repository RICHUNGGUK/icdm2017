{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "tile_size_selection"}, {"score": 0.009374906876192114, "phrase": "optimal_tile_size"}, {"score": 0.009177610571184755, "phrase": "tiled_codes"}, {"score": 0.004763785973620115, "phrase": "loop_tiling"}, {"score": 0.004713162564945179, "phrase": "widely_used_loop_transformation"}, {"score": 0.004663074596384574, "phrase": "data_locality"}, {"score": 0.004613516457919661, "phrase": "data_reuse"}, {"score": 0.004548253531664032, "phrase": "tiled_code"}, {"score": 0.004452078350485375, "phrase": "different_sizes"}, {"score": 0.004389089062127892, "phrase": "significant_variation"}, {"score": 0.0038332390893263844, "phrase": "direct-mapped_cache"}, {"score": 0.0035822005511799036, "phrase": "auto-tuning_models"}, {"score": 0.003544088803300751, "phrase": "exhaustive_search"}, {"score": 0.0035063811070537233, "phrase": "large_space"}, {"score": 0.003371508176308189, "phrase": "new_analytical_model"}, {"score": 0.0033001333942688778, "phrase": "high_set_associativity"}, {"score": 0.0032766780632972363, "phrase": "modern_caches"}, {"score": 0.0032418062548293745, "phrase": "conflict_misses"}, {"score": 0.0029971349193857093, "phrase": "simd_unit"}, {"score": 0.002975826686621829, "phrase": "modern_processors"}, {"score": 0.0028207566216121856, "phrase": "previous_models"}, {"score": 0.002751174423568564, "phrase": "robust_model"}, {"score": 0.0025343769150179764, "phrase": "previous_analytical_models"}, {"score": 0.002454258761940649, "phrase": "single_level"}, {"score": 0.0024022553322977165, "phrase": "average_performance_improvement"}, {"score": 0.0022287497627555895, "phrase": "tile_size"}, {"score": 0.0021659920594094407, "phrase": "best_performing_size"}, {"score": 0.0021352776064254195, "phrase": "extensive_search"}, {"score": 0.0021049977753042253, "phrase": "analytical_model"}], "paper_keywords": ["Loop tiling", " tile size selection", " multilevel cache", " vectorization"], "paper_abstract": "Loop tiling is a widely used loop transformation to enhance data locality and allow data reuse. In the tiled code, however, tiles of different sizes can lead to significant variation in performance. Thus, selection of an optimal tile size is critical to performance of tiled codes. In the past, tile size selection has been attempted using both static analytical and dynamic empirical (auto-tuning) models. Past work using static models assumed a direct-mapped cache for the purpose of analysis and thus proved to be less robust. On the other hand, the auto-tuning models involve an exhaustive search in a large space of tiled codes. In this article, we propose a new analytical model for tile size selection that leverages the high set associativity in modern caches to minimize conflict misses. Our tile size selection model targets data reuse in multiple levels of cache. In addition, it considers the interaction of tiling with the SIMD unit in modern processors in estimating the optimal tile size. We find that these factors, not considered in previous models, are critical in developing a robust model for tile size selection. We implement our tile size selection model in a polyhedral compiler and test it on 12 benchmark kernels using two different problem sizes. Our model outperforms the previous analytical models that are based on reusing data in a single level of cache and achieves an average performance improvement of 9.7% and 20.4%, respectively, over the best square (cubic) tiles for the two problem sizes. In addition, the tile size chosen by our tile size selection algorithm is similar to the best performing size obtained through an extensive search, validating the analytical model underlying the algorithm.", "paper_title": "Tile Size Selection Revisited", "paper_id": "WOS:000330509300014"}