{"auto_keywords": [{"score": 0.04885877600670671, "phrase": "execution_state"}, {"score": 0.030906183150139214, "phrase": "proposed_technique"}, {"score": 0.015719716506582538, "phrase": "recursive_hierarchical_state_machines"}, {"score": 0.01244747484805983, "phrase": "agent_state_execution"}, {"score": 0.0047839735747931605, "phrase": "agent_execution_state_capture"}, {"score": 0.004632039024076267, "phrase": "agent-based_and_multi-agent_systems"}, {"score": 0.004513957235071457, "phrase": "agent_checkpointing"}, {"score": 0.004456044928556639, "phrase": "strong_mobility"}, {"score": 0.004413096646892175, "phrase": "basic_mechanisms"}, {"score": 0.004328432545135587, "phrase": "fault_tolerance"}, {"score": 0.004300572109650207, "phrase": "load_balancing"}, {"score": 0.0042591158963728665, "phrase": "transparent_migration"}, {"score": 0.00415050117148714, "phrase": "currently_available_platforms"}, {"score": 0.004031603526620806, "phrase": "standard_java_virtual_machine"}, {"score": 0.003954229201647876, "phrase": "important_feature"}, {"score": 0.0037550532530811935, "phrase": "system-level_approaches"}, {"score": 0.0036710872046569532, "phrase": "underlying_virtual_machine"}, {"score": 0.003588991941539972, "phrase": "application-level_approaches"}, {"score": 0.003531474887552889, "phrase": "system_layer"}, {"score": 0.003486123304074186, "phrase": "sophisticated_agent_programming_models"}, {"score": 0.0033971539563683174, "phrase": "coarse-grain_capture"}, {"score": 0.003278504512223807, "phrase": "application-level_technique"}, {"score": 0.0032259472087775138, "phrase": "programmable_-grain_capture"}, {"score": 0.0031032109441552287, "phrase": "statement-driven_state_capture"}, {"score": 0.002985130390111069, "phrase": "agent-oriented_type"}, {"score": 0.002899519426587381, "phrase": "single-threaded_agent_program"}, {"score": 0.0028438387403045555, "phrase": "dsc"}, {"score": 0.0027982016314450717, "phrase": "agent_data"}, {"score": 0.002717937009041744, "phrase": "original_agent_program_semantics"}, {"score": 0.0026314443645799913, "phrase": "agent_program"}, {"score": 0.0025313393509878907, "phrase": "java"}, {"score": 0.0024826176951198166, "phrase": "jade_framework"}, {"score": 0.002357391911165024, "phrase": "generic_java-like_agent_language"}, {"score": 0.002304606411453748, "phrase": "jade_agents"}, {"score": 0.0022749744354271816, "phrase": "jade_dscstarbehaviour_framework"}, {"score": 0.0022384684697329097, "phrase": "translator_tool"}, {"score": 0.0022168460543913787, "phrase": "simple_yet_effective_running_example"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software agents", " Distilled StateCharts", " Execution state capture", " JADE", " Strong mobility"], "paper_abstract": "The capture of the execution state of agents in agent-based and multi-agent systems is a system feature needed to enable agent checkpointing, persistency and strong mobility that are basic mechanisms supporting more complex, distributed policies and algorithms for fault tolerance, load balancing, and transparent migration. Unfortunately, the majority of the currently available platforms for agents, particularly those based on the standard Java Virtual Machine, do not provide this important feature at the system-level. Several system-level and application-level approaches have been to date proposed for agent state execution capture. Although system-level approaches are effective, they modify the underlying virtual machine so endangering compatibility. Conversely, application-level approaches do not modify any system layer but they provide sophisticated agent programming models and/or agent converters that only allow a coarse-grain capture of agent state execution. In this paper, we propose an application-level technique that allows for a programmable -grain capture of the execution state of agents ranging from a per-instruction to a statement-driven state capture. The technique is based on the Distilled StateCharts Star (DSC*) formalism that offers an agent-oriented type of recursive hierarchical state machines. According to the proposed technique a single-threaded agent program can be translated into a DSC* machine, containing agent data, code and execution state, by preserving the original agent program semantics. The proposed technique can notably be applied to any agent program written through an imperative-style, procedural or object-oriented programming language. Currently, it is implemented in Java and fully integrated into the JADE framework, being JADE one of the most diffused agent platforms. In particular, agents, which are specified through a generic Java-like agent language, can be automatically translated into JADE agents according to the JADE DSCStarBehaviour framework by means of a translator tool. A simple yet effective running example is used to exemplify the proposed technique from modeling to implementation. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "An application-level technique based on recursive hierarchical state machines for agent execution state capture", "paper_id": "WOS:000318134400010"}