{"auto_keywords": [{"score": 0.024879940848179342, "phrase": "slp"}, {"score": 0.00481495049065317, "phrase": "extracting_superword_level_parallelism"}, {"score": 0.004317109072311102, "phrase": "specific_type"}, {"score": 0.004272456401437226, "phrase": "data_parallelism"}, {"score": 0.004055998173160551, "phrase": "prior_research"}, {"score": 0.003993216345115755, "phrase": "significant_performance_savings"}, {"score": 0.0038106195546165574, "phrase": "simd_instructions"}, {"score": 0.0037516215763875225, "phrase": "application_code"}, {"score": 0.003434085751246066, "phrase": "novel_automated_compiler_framework"}, {"score": 0.003380897678672156, "phrase": "superword_level_parallelism_exploitation"}, {"score": 0.0033285306462537884, "phrase": "key_part"}, {"score": 0.0031928040608991543, "phrase": "statement_generation"}, {"score": 0.0031597433845085092, "phrase": "data_layout_optimization"}, {"score": 0.0031107911390188055, "phrase": "first_stage"}, {"score": 0.0029994894380575604, "phrase": "statement_grouping"}, {"score": 0.002968424524565369, "phrase": "statement_scheduling"}, {"score": 0.0028921584725218642, "phrase": "primary_goals"}, {"score": 0.0028325548627901004, "phrase": "simd_parallelism"}, {"score": 0.0026888503045081505, "phrase": "superword_statements"}, {"score": 0.0026609940110902666, "phrase": "global_data"}, {"score": 0.002512850690695835, "phrase": "complementary_optimization"}, {"score": 0.002435542816459651, "phrase": "memory_space"}, {"score": 0.002360607691114015, "phrase": "memory_operations"}, {"score": 0.0021831803612759855, "phrase": "performance_improvements"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_slp_optimization_algorithm"}], "paper_keywords": ["Design", " Algorithms", " Languages", " Experimentation", " Performance", " SLP", " SIMD", " Scheduling", " Data Layout", " Compiler"], "paper_abstract": "SIMD (single-instruction multiple-data) instruction set extensions are quite common today in both high performance and embedded microprocessors, and enable the exploitation of a specific type of data parallelism called SLP (Superword Level Parallelism). While prior research shows that significant performance savings are possible when SLP is exploited, placing SIMD instructions in an application code manually can be very difficult and error prone. In this paper, we propose a novel automated compiler framework for improving superword level parallelism exploitation. The key part of our framework consists of two stages: superword statement generation and data layout optimization. The first stage is our main contribution and has two phases, statement grouping and statement scheduling, of which the primary goals are to increase SIMD parallelism and, more importantly, capture more superword reuses among the superword statements through global data access and reuse pattern analysis. Further, as a complementary optimization, our data layout optimization organizes data in memory space such that the price of memory operations for SLP is minimized. The results from our compiler implementation and tests on two systems indicate performance improvements as high as 15.2% over a state-of-the-art SLP optimization algorithm.", "paper_title": "A Compiler Framework for Extracting Superword Level Parallelism", "paper_id": "WOS:000307582100031"}