{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cronus"}, {"score": 0.009819331814946814, "phrase": "general_nested_loops"}, {"score": 0.00471700544744796, "phrase": "parallel_code_generation"}, {"score": 0.004659192888931046, "phrase": "computational_geometry_methods"}, {"score": 0.004380540407926982, "phrase": "complex_loop_bodies"}, {"score": 0.004204054047427536, "phrase": "uniform_loop-carried_dependencies"}, {"score": 0.003952513974962462, "phrase": "optimal_scheduling_hyperplane"}, {"score": 0.0039040344230094164, "phrase": "quickhull_algorithm"}, {"score": 0.003793206550770237, "phrase": "previously_used_methods"}, {"score": 0.0036553070575015344, "phrase": "simple_and_efficient_dynamic_rule"}, {"score": 0.0035369291417564606, "phrase": "runtime_scheduling"}, {"score": 0.0034935290662899488, "phrase": "loop_iterations"}, {"score": 0.0034506596895901003, "phrase": "optimal_hyperplane"}, {"score": 0.0034083145672246067, "phrase": "scheduling_policy"}, {"score": 0.00338037259057507, "phrase": "data_locality"}, {"score": 0.003257432325797907, "phrase": "efficient_runtime_library"}, {"score": 0.0031910685060552485, "phrase": "communication_minimization"}, {"score": 0.0030623570435946977, "phrase": "berkeley_upc."}, {"score": 0.002999955539996569, "phrase": "extensive_testing"}, {"score": 0.0029147175927233546, "phrase": "floyd-steinberg"}, {"score": 0.0027856252557826467, "phrase": "fsbm"}, {"score": 0.0027176309244222, "phrase": "experimental_results"}, {"score": 0.002651291854234327, "phrase": "parallel_code"}, {"score": 0.0022300169122921906, "phrase": "shared-memory_systems"}, {"score": 0.0022117133940361025, "phrase": "cronus_outperforms_upc"}, {"score": 0.002157697367447098, "phrase": "test_case"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["general loops", " dynamic scheduling", " code generation", " shared and distributed memory architectures"], "paper_abstract": "This paper describes CRONUS, a platform for parallelizing general nested loops. General nested loops contain complex loop bodies (assignments, conditionals, repetitions) and exhibit uniform loop-carried dependencies. The novelty Of CRONUS is twofold: ( 1) it determines the optimal scheduling hyperplane using the QuickHull algorithm, which is more efficient than previously used methods, and (2) it implements a simple and efficient dynamic rule (successive dynamic scheduling) for the runtime scheduling of the loop iterations along the optimal hyperplane. This scheduling policy enhances data locality and improves the makespan. CRONUS provides an efficient runtime library, specifically designed for communication minimization, that performs better than more generic systems, such as Berkeley UPC. Its performance was evaluated through extensive testing. Three representative case studies are examined: the Floyd-Steinberg dithering algorithm, the Transitive Closure algorithm, and the FSBM motion estimation algorithm. The experimental results corroborate the efficiency of the parallel code. The tests show speedup ranging from 1.18 (Out of the ideal 4) to 12.29 (Out of the ideal 16) on distributed-systems and 3.60 (out of 4) to 15.79 (out of 16) on shared-memory systems. CRONUS Outperforms UPC by 5-95% depending on the test case. (C) 2007 Elsevier Inc. All rights reserved.", "paper_title": "CRONUS: A platform for parallel code generation based on computational geometry methods", "paper_id": "WOS:000258800900009"}