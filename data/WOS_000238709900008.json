{"auto_keywords": [{"score": 0.046556461636962906, "phrase": "terminal_propagation"}, {"score": 0.027084146457518735, "phrase": "average_improvement"}, {"score": 0.00481495049065317, "phrase": "min-cut_placements"}, {"score": 0.0046544807197808095, "phrase": "strong_multilevel_partitioners"}, {"score": 0.00459568664065473, "phrase": "top-down_min-cut_placers"}, {"score": 0.004499334809770281, "phrase": "modern_placer_implementations"}, {"score": 0.004404994123834589, "phrase": "important_step"}, {"score": 0.0043678116213858, "phrase": "min-cut_placers"}, {"score": 0.004240116703465252, "phrase": "global-placement_wirelength_assumptions"}, {"score": 0.004116139569480336, "phrase": "repartitioning_problem"}, {"score": 0.0039119492240482, "phrase": "physical_design"}, {"score": 0.0036553070575015344, "phrase": "in-depth_manner"}, {"score": 0.0034886660821793576, "phrase": "future_cell_locations"}, {"score": 0.0034299649219748513, "phrase": "present_terminal_propagations"}, {"score": 0.003259702394241964, "phrase": "placement_feedback"}, {"score": 0.003150900886669123, "phrase": "accurate_terminal_propagation"}, {"score": 0.0031242709509664806, "phrase": "feedback_iteration"}, {"score": 0.003097865379563127, "phrase": "controller_insertion"}, {"score": 0.0030457198309616694, "phrase": "feedback_response"}, {"score": 0.002994449398035894, "phrase": "substantial_reductions"}, {"score": 0.0029691377785333872, "phrase": "placement_wirelength"}, {"score": 0.002906789844521509, "phrase": "capo"}, {"score": 0.0027274643070540733, "phrase": "gsrc_bookshelf"}, {"score": 0.0026475981474045414, "phrase": "standard_benchmark_circuits"}, {"score": 0.002592026232146442, "phrase": "ibm"}, {"score": 0.0024527767211457046, "phrase": "peko_benchmarks"}, {"score": 0.0023507916951658455, "phrase": "consistent_improvements"}, {"score": 0.0023309080951251335, "phrase": "routed_wirelength"}, {"score": 0.0022434880661725493, "phrase": "acceptable_increase"}, {"score": 0.002224510044064184, "phrase": "placement_runtime"}, {"score": 0.0021049977753042253, "phrase": "congestion_maps"}], "paper_keywords": ["min-cut partitioning", " routing", " terminal propagation", " VLSI placement"], "paper_abstract": "The advent of strong multilevel partitioners has made top-down min-cut placers a favored choice for modern placer implementations. Terminal propagation is an important step in min-cut placers because it translates partitioning results into global-placement wirelength assumptions. In this work, the repartitioning problem is carefully reexamined (Proc. ACM/IEEE Int. Symp. Physical Design, p. 18, 1997) in the context of terminal propagation and studied in an in-depth manner. Abstractly, it was observed that in repartitioning, future cell locations are used for present terminal propagations and that this can be conceptually regarded as a form of placement feedback. This concept was utilized to achieve accurate terminal propagation via feedback iteration and controller insertion to fine-tune the feedback response. This yields substantial reductions in placement wirelength. Implementing our approach in Capo [version 8.7 (Proc. ACM/IEEE Design Automation Conf., p. 477, 2000 and GSRC Bookshelf)] and applying it to standard benchmark circuits yields up to 14% wirelength reductions for the IBM benchmarks with an average improvement of 5.5% and up to 10% reductions for the Peko benchmarks with an average improvement of 5.37%. Experiments also show consistent improvements for routed wirelength, yielding up to 9% wirelength reductions and 5.8% average reduction with acceptable increase in placement runtime. In practice, the method proposed significantly improves routability without building congestion maps and also reduces the number of vias.", "paper_title": "Wirelength minimization for min-cut placements via placement feedback", "paper_id": "WOS:000238709900008"}