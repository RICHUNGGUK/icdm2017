{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "embedded_control_systems"}, {"score": 0.004779876533667754, "phrase": "hard_real-time_constraints"}, {"score": 0.004378309349451268, "phrase": "worst-case_execution_times"}, {"score": 0.0041294419262414995, "phrase": "problem_specification"}, {"score": 0.004084372444216856, "phrase": "task's_code"}, {"score": 0.0039665679106594106, "phrase": "safe_and_tight_bounds"}, {"score": 0.003838078705946304, "phrase": "loop_bounds"}, {"score": 0.003810093416457147, "phrase": "architectural_features"}, {"score": 0.003633079011725194, "phrase": "dynamic_memory"}, {"score": 0.0034139056533151, "phrase": "static_memory"}, {"score": 0.0032079118323314424, "phrase": "task_execution_times"}, {"score": 0.0030925761790620027, "phrase": "unsafe_hard_real-time_system_design"}, {"score": 0.0030032915123993837, "phrase": "effective_approach"}, {"score": 0.0029380187414193653, "phrase": "software-initiated_dram_refresh"}, {"score": 0.002853183476661506, "phrase": "pure_software"}, {"score": 0.002710557619357275, "phrase": "predictable_timings"}, {"score": 0.0026613618933208467, "phrase": "classical_hardware_auto-refresh"}, {"score": 0.002622647280008795, "phrase": "implementation_details"}, {"score": 0.002565626044684815, "phrase": "multiple_concrete_embedded_platforms"}, {"score": 0.0025006623485285895, "phrase": "different_schemes"}, {"score": 0.002401875938287542, "phrase": "variable_latency_memory_references"}, {"score": 0.0023756164484983874, "phrase": "data-flow_framework"}, {"score": 0.0023496433751182162, "phrase": "static_timing_analysis"}, {"score": 0.0023154527779996213, "phrase": "task's_memory_latencies"}, {"score": 0.002265095354846931, "phrase": "resulting_predictable_execution_behavior"}, {"score": 0.0021835829960683666, "phrase": "additional_benefit"}, {"score": 0.0021676351850669017, "phrase": "reduced_access_delays"}], "paper_keywords": ["Real-time systems", " DRAM", " Worst-case execution time", " Timing analysis", " DRAM refresh", " Timing predictability"], "paper_abstract": "Embedded control systems with hard real-time constraints require that deadlines are met at all times or the system may malfunction with potentially catastrophic consequences. Schedulability theory can assure deadlines for a given task set when periods and worst-case execution times (WCETs) of tasks are known. While periods are generally derived from the problem specification, a task's code needs to be statically analyzed to derive safe and tight bounds on its WCET. Such static timing analysis abstracts from program input and considers loop bounds and architectural features, such as pipelining and caching. However, unpredictability due to dynamic memory (DRAM) refresh cannot be accounted for by such analysis, which limits its applicability to systems with static memory (SRAM). In this paper, we assess the impact of DRAM refresh on task execution times and demonstrate how predictability is adversely affected leading to unsafe hard real-time system design. We subsequently contribute a novel and effective approach to overcome this problem through software-initiated DRAM refresh. We develop (1) a pure software and (2) a hybrid hardware/software refresh scheme. Both schemes provide predictable timings and fully replace the classical hardware auto-refresh. We discuss implementation details based on this design for multiple concrete embedded platforms and experimentally assess the benefits of different schemes on these platforms. We further formalize the integration of variable latency memory references into a data-flow framework suitable for static timing analysis to bound a task's memory latencies with regard to their WCET. The resulting predictable execution behavior in the presence of DRAM refresh combined with the additional benefit of reduced access delays is unprecedented, to the best of our knowledge.", "paper_title": "Making DRAM refresh predictable", "paper_id": "WOS:000293950900003"}