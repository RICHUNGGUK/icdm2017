{"auto_keywords": [{"score": 0.041382425963584706, "phrase": "cpu_task"}, {"score": 0.03465288598351081, "phrase": "wcet"}, {"score": 0.02669728541597324, "phrase": "cpu_tasks"}, {"score": 0.00481495049065317, "phrase": "dma_interference"}, {"score": 0.004741845603430361, "phrase": "hard-real-time_embedded_systems"}, {"score": 0.00463428201074214, "phrase": "dma"}, {"score": 0.004426308135681733, "phrase": "cycle-stealing_mode_transfers_data"}, {"score": 0.004195449185056436, "phrase": "cpu."}, {"score": 0.0041316803676012155, "phrase": "concurrent_contention"}, {"score": 0.003334309053314909, "phrase": "worst-case_execution_time"}, {"score": 0.00288255520607591, "phrase": "dynamic-programming_technique"}, {"score": 0.002435190484324197, "phrase": "exhaustive_simulations"}, {"score": 0.0023798115577749225, "phrase": "widely-used_embedded_processor"}], "paper_keywords": ["hard-real-time systems", " worst-case execution time", " cycle-stealing DMA I/O", " concurrent execution", " embedded systems"], "paper_abstract": "A DMA controller that operates in the cycle-stealing mode transfers data by stealing bus cycles from the CPU. The concurrent contention for the I/O bus by a CPU task and a cycle-stealing DMA I/O task retards their progress and extends their execution times. In this paper we first describe a method for bounding the worst-case execution time (WCET) of a CPU task when cycle-stealing DMA I/O is present. We next use the dynamic-programming technique to develop a method for bounding the WCET of a cycle-stealing DMA I/O task executing concurrently with a set of CPU tasks. We conducted exhaustive simulations on a widely-used embedded processor. The experimental results demonstrate that our methods tightly bound the WCETs of CPU tasks and of cycle-stealing DMA I/O tasks.", "paper_title": "Bounding DMA interference on hard-real-time embedded systems", "paper_id": "WOS:000241017600015"}