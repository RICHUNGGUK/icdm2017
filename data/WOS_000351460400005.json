{"auto_keywords": [{"score": 0.046827692927246076, "phrase": "crash_reproduction"}, {"score": 0.028806905038962178, "phrase": "original_crashes"}, {"score": 0.00481495049065317, "phrase": "stack_trace_based_automatic_crash_reproduction"}, {"score": 0.00476323161560059, "phrase": "symbolic_execution"}, {"score": 0.004712065638657606, "phrase": "software_crash_reproduction"}, {"score": 0.004636340567075841, "phrase": "necessary_first_step"}, {"score": 0.004028796143006953, "phrase": "record-replay_approaches"}, {"score": 0.00394264312173188, "phrase": "recorded_crashes"}, {"score": 0.0038375280115736958, "phrase": "substantial_performance_overhead"}, {"score": 0.003796267885124202, "phrase": "program_executions"}, {"score": 0.00342568771304873, "phrase": "performance_overhead"}, {"score": 0.003352388337911934, "phrase": "existing_post-failure-process_approaches"}, {"score": 0.003158776195052182, "phrase": "scalability_issues"}, {"score": 0.003107935254560724, "phrase": "object_creation_challenge"}, {"score": 0.0030086877092638945, "phrase": "automatic_crash_reproduction_framework"}, {"score": 0.0029763124376934813, "phrase": "collected_crash_stack_traces"}, {"score": 0.002928399649340438, "phrase": "proposed_approach"}, {"score": 0.002881255933884771, "phrase": "efficient_backward_symbolic_execution"}, {"score": 0.0028348690177346448, "phrase": "novel_method_sequence_composition_approach"}, {"score": 0.002789226820897593, "phrase": "unit_test_cases"}, {"score": 0.0026710653215026685, "phrase": "additional_runtime_overhead"}, {"score": 0.002410058288617039, "phrase": "exploitable_crashes"}, {"score": 0.002345707314211983, "phrase": "useful_reproductions"}, {"score": 0.002198173002125907, "phrase": "comparison_study"}, {"score": 0.0021049977753042253, "phrase": "existing_crash_reproduction_approaches"}], "paper_keywords": ["Crash reproduction", " static analysis", " symbolic execution", " test case generation", " optimization"], "paper_abstract": "Software crash reproduction is the necessary first step for debugging. Unfortunately, crash reproduction is often labor intensive. To automate crash reproduction, many techniques have been proposed including record-replay and post-failure-process approaches. Record-replay approaches can reliably replay recorded crashes, but they incur substantial performance overhead to program executions. Alternatively, post-failure-process approaches analyse crashes only after they have occurred. Therefore they do not incur performance overhead. However, existing post-failure-process approaches still cannot reproduce many crashes in practice because of scalability issues and the object creation challenge. This paper proposes an automatic crash reproduction framework using collected crash stack traces. The proposed approach combines an efficient backward symbolic execution and a novel method sequence composition approach to generate unit test cases that can reproduce the original crashes without incurring additional runtime overhead. Our evaluation study shows that our approach successfully exploited 31 (59.6 percent) of 52 crashes in three open source projects. Among these exploitable crashes, 22 (42.3 percent) are useful reproductions of the original crashes that reveal the crash triggering bugs. A comparison study also demonstrates that our approach can effectively outperform existing crash reproduction approaches.", "paper_title": "STAR: Stack Trace Based Automatic Crash Reproduction via Symbolic Execution", "paper_id": "WOS:000351460400005"}