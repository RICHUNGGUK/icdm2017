{"auto_keywords": [{"score": 0.039494532809444774, "phrase": "api"}, {"score": 0.004640808212832262, "phrase": "side_effects"}, {"score": 0.004592214823540993, "phrase": "functional_languages"}, {"score": 0.004243552607799184, "phrase": "general_semantic_viewpoint"}, {"score": 0.004155113657645735, "phrase": "unified_framework"}, {"score": 0.004089991141220082, "phrase": "shared_state"}, {"score": 0.0040047396607954325, "phrase": "deterministic_concurrency"}, {"score": 0.0039006600544599537, "phrase": "modified_state_transformer"}, {"score": 0.0036043137580229873, "phrase": "broad_conditions"}, {"score": 0.003330406613112555, "phrase": "small_deterministic_haskell_language_extension"}, {"score": 0.0032954888655173666, "phrase": "curio"}, {"score": 0.0031929098985796814, "phrase": "runtime_checks"}, {"score": 0.002997203022420553, "phrase": "small_components"}, {"score": 0.0029346624184926305, "phrase": "individual_shared_variables"}, {"score": 0.002711506442590442, "phrase": "substantial_apis"}, {"score": 0.0025858215477025117, "phrase": "inter-process_communication"}, {"score": 0.002492098272172066, "phrase": "smaller_components"}, {"score": 0.002242577809454225, "phrase": "dynamic_allocation"}, {"score": 0.0021498955164659145, "phrase": "small_extensions"}, {"score": 0.0021049977753042253, "phrase": "process_locality"}], "paper_keywords": ["monads", " effects", " I/O", " concurrency", " determinism"], "paper_abstract": "The problem of expressing I/O and side effects in functional languages is a well-established one. This paper addresses this problem from a general semantic viewpoint by giving a unified framework for describing shared state, I/O and deterministic concurrency. We develop a modified state transformer which lets us mathematically model the API, then investigate and machine verify some broad conditions under which confluence holds. This semantics is used as the basis for a small deterministic Haskell language extension called CURIO, which enforces determinism using runtime checks. Our confluence condition is first shown to hold for a variety of small components, such as individual shared variables, 1-to-1 communication channels, and I-structures. We then show how models of substantial APIs ( like a modification of Haskell's file I/O API which permits inter-process communication) may be constructed from these smaller components using \"combinators\" in such a way that determinism is always preserved. We describe combinators for product, name-indexing and dynamic allocation, the last of which requires some small extensions to cater for process locality.", "paper_title": "Modelling deterministic concurrent I/O", "paper_id": "WOS:000202972400015"}