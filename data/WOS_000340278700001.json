{"auto_keywords": [{"score": 0.047188363272757154, "phrase": "bounded-degree_graphs"}, {"score": 0.03245069428857952, "phrase": "proximity_parameter"}, {"score": 0.00481495049065317, "phrase": "sublinear_time"}, {"score": 0.004674457608503586, "phrase": "simple_cycles"}, {"score": 0.004302413946305072, "phrase": "c-k-"}, {"score": 0.0036770435321756903, "phrase": "polylogarithmic_length"}, {"score": 0.003444861556939966, "phrase": "polylogarithmic_factors"}, {"score": 0.0034143536023161403, "phrase": "foregoing_results"}, {"score": 0.003314591878914152, "phrase": "one-sided_error_property_testing_algorithms"}, {"score": 0.0032852337992126564, "phrase": "bounded-degree_graphs_model"}, {"score": 0.0031892326681931295, "phrase": "n-vertex_graphs"}, {"score": 0.0031422859551159506, "phrase": "one-sided_error"}, {"score": 0.002935050614509531, "phrase": "one-sided_error_cycle-freeness_testing"}, {"score": 0.002857719256931572, "phrase": "minor-free_property"}, {"score": 0.002832396300207349, "phrase": "two-sided_error_tester"}, {"score": 0.0026612920049803473, "phrase": "input_graph"}, {"score": 0.002637705034367748, "phrase": "simple_cycle"}, {"score": 0.0025079304766764616, "phrase": "fixed_tree_t"}, {"score": 0.002470987929071079, "phrase": "t-minor_freeness"}, {"score": 0.0024490834773668153, "phrase": "one-sided_error_tester"}, {"score": 0.002314783782656802, "phrase": "general_graphs"}, {"score": 0.0022470772167953123, "phrase": "actual_number"}, {"score": 0.0021049977753042253, "phrase": "wiley_periodicals"}], "paper_keywords": ["sublinear-time algorithms", " property testing", " bounded-degree graphs", " one-sided versus two-sided error probability"], "paper_abstract": "We present sublinear-time (randomized) algorithms for finding simple cycles of length at least k3 and tree-minors in bounded-degree graphs. The complexity of these algorithms is related to the distance of the graph from being C-k-minor free (resp., free from having the corresponding tree-minor). In particular, if the graph is (1)-far from being cycle-free (i.e., a constant fraction of the edges must be deleted to make the graph cycle-free), then the algorithm finds a cycle of polylogarithmic length in time O</mml:mover>(<mml:msqrt>N</mml:msqrt>), where N denotes the number of vertices. This time complexity is optimal up to polylogarithmic factors. The foregoing results are the outcome of our study of the complexity of one-sided error property testing algorithms in the bounded-degree graphs model. For example, we show that cycle-freeness of N-vertex graphs can be tested with one-sided error within time complexity O</mml:mover>(poly(1/E)<mml:msqrt>N</mml:msqrt>), where denotes the proximity parameter. This matches the known (<mml:msqrt>N</mml:msqrt>) query lower bound for one-sided error cycle-freeness testing, and contrasts with the fact that any minor-free property admits a two-sided error tester of query complexity that only depends on . We show that the same upper bound holds for testing whether the input graph has a simple cycle of length at least k, for any k3. On the other hand, for any fixed tree T, we show that T-minor freeness has a one-sided error tester of query complexity that only depends on the proximity parameter . Our algorithm for finding cycles in bounded-degree graphs extends to general graphs, where distances are measured with respect to the actual number of edges. Such an extension is not possible with respect to finding tree-minors in o<mml:mo stretchy=\"false\">(<mml:msqrt>N</mml:msqrt><mml:mo stretchy=\"false\">) complexity. (c) 2012 Wiley Periodicals, Inc. Random Struct. Alg., 45, 139-184, 2014", "paper_title": "Finding Cycles and Trees in Sublinear Time", "paper_id": "WOS:000340278700001"}