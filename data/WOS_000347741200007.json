{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "vm_design"}, {"score": 0.004484596684703308, "phrase": "virtual_machines"}, {"score": 0.00421410521089045, "phrase": "best_vms"}, {"score": 0.003465350958971198, "phrase": "rpython_language"}, {"score": 0.003374094774912924, "phrase": "jit_vms"}, {"score": 0.003005539334280134, "phrase": "vm_implementation"}, {"score": 0.00260657976055413, "phrase": "rpython_vms"}, {"score": 0.0023424328921363585, "phrase": "performance_levels"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Virtual machines", " Meta-tracing", " Programming languages"], "paper_abstract": "Most modern languages are implemented using Virtual Machines (VMs). While the best VMs use Just-In-Time (JIT) compilers to achieve good performance, JITs are costly to implement, and few VMs therefore come with one. The RPython language allows tracing JIT VMs to be automatically created from an interpreter, changing the economics of VM implementation. In this paper, we explain, through two concrete VMs, how meta-tracing RPython VMs can be designed and optimised, and, experimentally, the performance levels one might reasonably expect from them. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "The impact of meta-tracing on VM design and implementation", "paper_id": "WOS:000347741200007"}