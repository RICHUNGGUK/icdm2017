{"auto_keywords": [{"score": 0.0360928067982632, "phrase": "spl"}, {"score": 0.008713751772586915, "phrase": "ibm_streams_processing_language"}, {"score": 0.008584340708143833, "phrase": "big_data"}, {"score": 0.004488946121663966, "phrase": "programming_language"}, {"score": 0.004444203710097833, "phrase": "ibm_infosphere"}, {"score": 0.004122490120202936, "phrase": "\"big_data"}, {"score": 0.003980400251874277, "phrase": "continuous_data_streams"}, {"score": 0.003940706575253453, "phrase": "high_data-transfer_rates"}, {"score": 0.0038819939903840723, "phrase": "streams"}, {"score": 0.003785836059995376, "phrase": "high_throughput"}, {"score": 0.0037480753312398754, "phrase": "short_response"}, {"score": 0.0036370297611938796, "phrase": "performance_demands"}, {"score": 0.003459191419478298, "phrase": "commodity_servers"}, {"score": 0.003306559295382181, "phrase": "distributed_system"}, {"score": 0.0028877818105020434, "phrase": "code_reuse"}, {"score": 0.002816246391862638, "phrase": "code-generation_interface"}, {"score": 0.0027603306208583735, "phrase": "java"}, {"score": 0.0026516890043911836, "phrase": "well-structured_and_concise_applications"}, {"score": 0.0025989960809479104, "phrase": "higher-order_composite_operators"}, {"score": 0.002560162916190598, "phrase": "stream_sub-graphs"}, {"score": 0.0024842242921857705, "phrase": "static_checking"}, {"score": 0.002447101794397243, "phrase": "optimization_opportunities"}, {"score": 0.0023864566654035924, "phrase": "strong_type_system"}, {"score": 0.002362620540317279, "phrase": "user-defined_operator_models"}, {"score": 0.0022925278792429553, "phrase": "language_overview"}, {"score": 0.0021049977753042253, "phrase": "language_design"}], "paper_keywords": [""], "paper_abstract": "The IBM Streams Processing Language (SPL) is the programming language for IBM InfoSphere (R) Streams, a platform for analyzing Big Data in motion. By \"Big Data in motion,\" we mean continuous data streams at high data-transfer rates. InfoSphere Streams processes such data with both high throughput and short response times. To meet these performance demands, it deploys each application on a cluster of commodity servers. SPL abstracts away the complexity of the distributed system, instead exposing a simple graph-of-operators view to the user. SPL has several innovations relative to prior streaming languages. For performance and code reuse, SPL provides a code-generation interface to C++ and Java (R). To facilitate writing well-structured and concise applications, SPL provides higher-order composite operators that modularize stream sub-graphs. Finally, to enable static checking while exposing optimization opportunities, SPL provides a strong type system and user-defined operator models. This paper provides a language overview, describes the implementation including optimizations such as fusion, and explains the rationale behind the language design.", "paper_title": "IBM Streams Processing Language: Analyzing Big Data in motion", "paper_id": "WOS:000323322800008"}