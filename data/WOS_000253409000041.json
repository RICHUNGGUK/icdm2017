{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "execution_omission_errors"}, {"score": 0.00828958197378575, "phrase": "dynamic_slices"}, {"score": 0.006900573614706038, "phrase": "dynamic_analysis"}, {"score": 0.006492991283568714, "phrase": "implicit_dependences"}, {"score": 0.006076743460666194, "phrase": "dynamic_information"}, {"score": 0.005474374569011867, "phrase": "faulty_code"}, {"score": 0.004243486865567692, "phrase": "dynamic_slicing"}, {"score": 0.004049501224016734, "phrase": "executed_statements"}, {"score": 0.003830647710561999, "phrase": "challenging_task"}, {"score": 0.003450154514800989, "phrase": "relevant_slices"}, {"score": 0.003285002755070217, "phrase": "dynamic_dependences"}, {"score": 0.003210652026669616, "phrase": "conservative_nature"}, {"score": 0.0031897187361850103, "phrase": "static_analysis"}, {"score": 0.003168921495806216, "phrase": "overly_large_slices"}, {"score": 0.0030569295881497176, "phrase": "fully_dynamic_solution"}, {"score": 0.0027261830963078706, "phrase": "dynamic_method"}, {"score": 0.002664446536828292, "phrase": "omitted_code"}, {"score": 0.0026212045623658932, "phrase": "relevant_predicates"}, {"score": 0.0024391051991149663, "phrase": "fault_candidate_sets"}, {"score": 0.0023298518405721782, "phrase": "single_implicit_dependence"}, {"score": 0.002314647987893668, "phrase": "predicate_switching"}, {"score": 0.0022109570100232352, "phrase": "small_number"}, {"score": 0.002160862869106241, "phrase": "root_cause"}, {"score": 0.0021049977753042253, "phrase": "proposed_technique"}], "paper_keywords": ["debugging", " execution omission", " relevant slicing", " implicit dependence", " potential dependence", " and predicate switching"], "paper_abstract": "Execution omission errors are known to be difficult to locate using dynamic analysis. These errors lead to a failure at runtime because of the omission of execution of some statements that would have been executed if the program had no errors. Since dynamic analysis is typically designed to focus on dynamic information arising from executed statements, and statements whose execution is omitted do not produce dynamic information, detection of execution omission errors becomes a challenging task. For example, while dynamic slices are very effective in capturing faulty code for other types of errors, they fail to capture faulty code in presence of execution omission errors. To address this issue relevant slices have been defined to consider certain static dependences (called potential dependences) in addition to dynamic dependences. However, due to the conservative nature of static analysis, overly large slices are produced. In this paper, we propose a fully dynamic solution to locating execution omission errors using dynamic slices. We introduce the notion of implicit dependences which are dependences that are normally invisible to dynamic slicing due to the omission of execution of some statements. We design a dynamic method that forces the execution of the omitted code by switching outcomes of relevant predicates such that those implicit dependences are exposed and become available for dynamic slicing. Dynamic slices can be computed and effectively pruned to produce fault candidate sets containing the execution omission errors. We solve two main problems: verifying the existence of a single implicit dependence through predicate switching, and recovering the implicit dependences in a demand driven manner such that a small number of verifications are required before the root cause is captured. Our experiments show that the proposed technique is highly effective in capturing execution omission errors.", "paper_title": "Towards locating execution omission errors", "paper_id": "WOS:000253409000041"}