{"auto_keywords": [{"score": 0.043453500997964904, "phrase": "type_constructors"}, {"score": 0.04251153857508317, "phrase": "data_constructors"}, {"score": 0.004814966223571471, "phrase": "datatypes"}, {"score": 0.004706453355638515, "phrase": "algebraic_datatypes"}, {"score": 0.004626680470601208, "phrase": "manifest_contract_system"}, {"score": 0.004445739135694758, "phrase": "contract_information"}, {"score": 0.0043703658695579085, "phrase": "refinement_types"}, {"score": 0.003899385109646589, "phrase": "positive_integers"}, {"score": 0.003419943984098415, "phrase": "user-defined_datatype_pos_list"}, {"score": 0.0024560114164181765, "phrase": "syntactic_translation"}, {"score": 0.002373276186210053, "phrase": "equivalent_refinements"}, {"score": 0.0022287497627555895, "phrase": "different_but_compatible_datatypes"}, {"score": 0.0021908807203548345, "phrase": "int_list"}, {"score": 0.0021049977753042253, "phrase": "manifest_contract_calculus"}], "paper_keywords": ["Languages", " Design", " Theory", " algebraic datatypes", " datatype translation", " contract checking", " refinement types"], "paper_abstract": "We study algebraic datatypes in a manifest contract system, a software contract system where contract information occurs as refinement types. We first compare two simple approaches: refinements on type constructors and refinements on data constructors. For example, lists of positive integers can be described by {l:int list vertical bar for all (lambda(y.y) > 0) l} in the former, whereas by a user-defined datatype pos_list with cons of type {x:int vertical bar x > 0} x pos_list -> pos_list in the latter. The two approaches are complementary: the former makes it easier for a programmer to write types and the latter enables more efficient contract checking. To take the best of both worlds, we propose (1) a syntactic translation from refinements on type constructors to equivalent refinements on data constructors and (2) dynamically checked casts between different but compatible datatypes such as int list and pos_list. We define a manifest contract calculus lambda(H)(dt) to formalize the semantics of the casts and prove that the translation is correct.", "paper_title": "Manifest Contracts for Datatypes", "paper_id": "WOS:000354800500016"}