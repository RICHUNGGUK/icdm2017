{"auto_keywords": [{"score": 0.04761249774253216, "phrase": "lcis"}, {"score": 0.010612387000973441, "phrase": "longest_common_increasing_subsequence"}, {"score": 0.004501774379030109, "phrase": "multiple_sequences"}, {"score": 0.004394910907549057, "phrase": "lcis_problem"}, {"score": 0.00433200902751133, "phrase": "fundamental_issue"}, {"score": 0.004208881856146758, "phrase": "whole_genome_alignment"}, {"score": 0.004050116768809519, "phrase": "efficient_algorithm"}, {"score": 0.0038047474331318974, "phrase": "log_log"}, {"score": 0.0034725269588525534, "phrase": "ordered_pairs"}, {"score": 0.0030790429005600898, "phrase": "n_numbers"}, {"score": 0.0026268961477241026, "phrase": "total_number"}, {"score": 0.00247944491239733, "phrase": "previous_results"}, {"score": 0.0021049977753042253, "phrase": "l_log_log"}], "paper_keywords": ["design and analysis of algorithms", " longest common increasing subsequence"], "paper_abstract": "We study the problem of finding a longest common increasing subsequence (LCIS) of multiple sequences of numbers. The LCIS problem is a fundamental issue in various application areas, including the whole genome alignment. In this paper we give an efficient algorithm to find the LCIS of two sequences in O(min(r log l, nl +r) log log n+Sort(n)) time where n is the length of each sequence and r is the number of ordered pairs of positions at which the two sequences match, e is the length of the LCIS, and Sort(n) is the time to sort n numbers. For in sequences where m >= 3, we find the LCIS in O(min(mr(2), r log l log(m) r) + m.Sort(n)) time where r is the total number of m-tuples of positions at which the m sequences match. The previous results find the LCIS of two sequences in O(n(2)) and O(nl log log n+Sort(n)) time. Our algorithm is faster when r is relatively small, e.g., for r < min(n(2)/(log l log log n), nl/ log l).", "paper_title": "Efficient algorithms for finding a longest common increasing subsequence", "paper_id": "WOS:000244645900007"}