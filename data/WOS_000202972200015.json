{"auto_keywords": [{"score": 0.031647339792668025, "phrase": "shim"}, {"score": 0.00481495049065317, "phrase": "shim_models"}, {"score": 0.004720419202969916, "phrase": "concurrent_systems"}, {"score": 0.004506968388996092, "phrase": "sequential_systems"}, {"score": 0.0041084684278314305, "phrase": "higher-level_models"}, {"score": 0.003896717568943166, "phrase": "usual_challenges"}, {"score": 0.0036472537997966938, "phrase": "shim_model"}, {"score": 0.0035519826240477444, "phrase": "deterministic_concurrency"}, {"score": 0.0027437235598539904, "phrase": "tail-recursive_code"}, {"score": 0.00250073564820402, "phrase": "communication_pattern"}, {"score": 0.0024678216843278806, "phrase": "multiple_processes"}, {"score": 0.002387415084371473, "phrase": "far_less_overhead"}], "paper_keywords": ["algorithms", " performance", " concurrency", " embedded systems", " computed gotos", " code synthesis", " the SHIM model"], "paper_abstract": "Programming concurrent systems is substantially more difficult than programming sequential systems, yet most embedded systems need concurrency. We believe this should be addressed through higher-level models of concurrency that eliminate many of the usual challenges, such as nondeterminism arising from races. The SHIM model of computation provides deterministic concurrency, and there already exist ways of implementing it in hardware and software. In this work, we describe how to produce more efficient C code from SHIM systems. We propose two techniques: a largely mechanical one that produces tail-recursive code for simulating concurrency, and a more clever one that statically analyzes the communication pattern of multiple processes to produce code with far less overhead. Experimentally, we find our tail-recursive technique produces code that runs roughly twice as fast as a baseline; our statically-scheduled code can run up to twelve times faster.", "paper_title": "Efficient code generation from SHIM models", "paper_id": "WOS:000202972200015"}