{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "optimized_code"}, {"score": 0.04973174391930041, "phrase": "scr_specifications"}, {"score": 0.04340844662767981, "phrase": "code_generator"}, {"score": 0.004728122501822142, "phrase": "promising_trend"}, {"score": 0.0046938292389998824, "phrase": "software_development"}, {"score": 0.004642852977065663, "phrase": "increasing_adoption"}, {"score": 0.004609175313390942, "phrase": "model-driven_design"}, {"score": 0.004428248351415723, "phrase": "abstract_model"}, {"score": 0.004380143676997257, "phrase": "required_program_behavior"}, {"score": 0.004269919513035607, "phrase": "statecharts"}, {"score": 0.004238929790959616, "phrase": "stateflow"}, {"score": 0.004028220740657591, "phrase": "executable_program"}, {"score": 0.003624361893008392, "phrase": "mechanized_analysis"}, {"score": 0.0035719191251314918, "phrase": "automatic_generation"}, {"score": 0.003419084516677794, "phrase": "hand-crafted_code"}, {"score": 0.003272767888056937, "phrase": "inefficient_code"}, {"score": 0.0031099353574309606, "phrase": "efficient_code"}, {"score": 0.0030205408413942272, "phrase": "scr_tabular_notation"}, {"score": 0.0028702214190712036, "phrase": "numerous_embedded_systems"}, {"score": 0.002828688767023151, "phrase": "scr"}, {"score": 0.0027876981671591202, "phrase": "automated_method"}, {"score": 0.0026976845075643314, "phrase": "efficient_method"}, {"score": 0.002678078466226442, "phrase": "automatic_code_generation"}, {"score": 0.002582159550634798, "phrase": "experimental_evaluation"}, {"score": 0.0025170626402362633, "phrase": "execution-flow_graph"}, {"score": 0.002256117165288155, "phrase": "optimized_graph"}, {"score": 0.0022234280592615756, "phrase": "seven_benchmarks"}, {"score": 0.0021752783872387173, "phrase": "significant_performance_improvements"}, {"score": 0.0021359494324422997, "phrase": "large_specifications"}, {"score": 0.0021049977753042253, "phrase": "code_generation"}], "paper_keywords": ["performance", " languages", " code generation", " code synthesis", " SCR", " requirements specifications", " formal specifications", " optimization"], "paper_abstract": "A promising trend in software development is the increasing adoption of model-driven design. In this approach, a developer first constructs an abstract model of the required program behavior in a language, such as Statecharts or Stateflow, and then uses a code generator to automatically transform the model into an executable program. This approach has many advantages - typically, a model is not only more concise than code and hence more understandable, it is also more amenable to mechanized analysis. Moreover, automatic generation of code from a model usually produces code with fewer errors than hand-crafted code. One serious problem, however, is that a code generator may produce inefficient code. To address this problem, this paper describes a method for generating efficient code from SCR (Software Cost Reduction) specifications. While the SCR tabular notation and tools have been used successfully to specify, simulate, and verify numerous embedded systems, until now SCR has lacked an automated method for generating optimized code. This paper describes an efficient method for automatic code generation from SCR specifications, together with an implementation and an experimental evaluation. The method first synthesizes an execution-flow graph from the specification, then applies three optimizations to the graph, namely, input slicing, simplification, and output slicing, and then automatically generates code from the optimized graph. Experiments on seven benchmarks demonstrate that the method produces significant performance improvements in code generated from large specifications. Moreover, code generation is relatively fast, and the code produced is relatively compact.", "paper_title": "Generating optimized code from SCR specifications", "paper_id": "WOS:000202972200016"}