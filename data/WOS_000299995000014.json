{"auto_keywords": [{"score": 0.0497141445691543, "phrase": "software-defined_conflicts"}, {"score": 0.00481495049065317, "phrase": "hardware_transactional_memory"}, {"score": 0.004529093447865156, "phrase": "transactional_conflict"}, {"score": 0.004443276312972159, "phrase": "variable_one"}, {"score": 0.004195418010131832, "phrase": "atomic_language_construct"}, {"score": 0.003545024951402821, "phrase": "particular_algorithm"}, {"score": 0.0034911335714333507, "phrase": "performance-motivated_construct"}, {"score": 0.0032710562699144814, "phrase": "local_definition"}, {"score": 0.002949598537993663, "phrase": "coarse_synchronization_style"}, {"score": 0.00290473242917264, "phrase": "tm_programming_model"}, {"score": 0.0028170314398963704, "phrase": "proposed_construct"}, {"score": 0.0027635643494432365, "phrase": "use_cases"}, {"score": 0.0027424619603260837, "phrase": "real_applications"}, {"score": 0.002482320290902079, "phrase": "hardware_tm_design"}, {"score": 0.002444544487772349, "phrase": "software_construct"}, {"score": 0.002316788811533867, "phrase": "significant_reductions"}, {"score": 0.0021539955106204354, "phrase": "nearly_all_benchmarks"}, {"score": 0.0021212055097236527, "phrase": "average_reduction"}, {"score": 0.0021049977753042253, "phrase": "execution_time"}], "paper_keywords": ["Design", " Performance", " Hardware transactional memory", " conflict detection", " atomic block"], "paper_abstract": "In this paper we investigate the benefits of turning the concept of transactional conflict from its traditionally fixed definition into a variable one that can be dynamically controlled in software. We propose the extension of the atomic language construct with an attribute that specifies the definition of conflict, so that programmers can write code which adjusts what kinds of conflicts are to be detected, relaxing or tightening the conditions according to the forms of interference that can be tolerated by a particular algorithm. Using this performance-motivated construct, specific conflict information can be associated with portions of code, as each transaction is provided with a local definition that applies while it executes. We find that defining conflicts in software makes possible the removal of dependencies which arise as a result of the coarse synchronization style encouraged by the TM programming model. We illustrate the use of the proposed construct in a variety of use cases with real applications, showing how programmers can take advantage of their knowledge about the problem and other global information not available at rim-time. We describe how to implement a hardware TM design that utilizes this software construct. Our experiments reveal that leveraging software-defined conflicts, the programmer is able to achieve significant reductions in the number of aborts -over 50% for most applications. At 16 threads, our system with software-defined conflicts outperforms LogTM-SE in nearly all benchmarks, reaching an average reduction in execution time of 18%.", "paper_title": "Hardware Transactional Memory with Software-Defined Conflicts", "paper_id": "WOS:000299995000014"}