{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "adaptive_sorting"}, {"score": 0.004581505405526037, "phrase": "permutation_pi"}, {"score": 0.003802135020791801, "phrase": "compressed_data_structure_encoding_pi"}, {"score": 0.0030017207229983385, "phrase": "worst_case"}, {"score": 0.00265038878247831, "phrase": "data_structure"}, {"score": 0.0023990982005125763, "phrase": "improved_adaptive_sorting_algorithm"}, {"score": 0.002325554982412043, "phrase": "compressed_data_structures"}, {"score": 0.0022683432490549064, "phrase": "adaptive_sorting_algorithms"}, {"score": 0.0021851480717840484, "phrase": "practical_and_theoretical_interest"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["Compression", " Permutations", " Succinct data structures", " Adaptive sorting"], "paper_abstract": "We prove that, given a permutation pi over [1..n] formed of nRuns sorted blocks of sizes given by the vector R = (r(1), . . . , r(nruns)), there exists a compressed data structure encoding pi in n(1 +H(R)) = n + Sigma(nRuns)(i=1)r(i) log(2) n/r(1) <= n(1 + log(2) nRuns) bits while supporting access to the values of pi 0 and pi(-1) () in time O(lognRuns/log log n) in the worst case and O(H(R)/log log n) on average, when the argument is uniformly distributed over [1..n]. This data structure can be constructed in time O(n(1 + H(R))), which yields an improved adaptive sorting algorithm. Similar results on compressed data structures for permutations and adaptive sorting algorithms are proved for other preorder measures of practical and theoretical interest. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "On compressing permutations and adaptive sorting", "paper_id": "WOS:000327827200009"}