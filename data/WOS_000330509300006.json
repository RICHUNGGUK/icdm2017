{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "llc"}, {"score": 0.00481495049065317, "phrase": "first-level_caches"}, {"score": 0.004642105253191792, "phrase": "single_cache"}, {"score": 0.0045635714806240135, "phrase": "pipeline_design"}, {"score": 0.004519290293998132, "phrase": "simple_way"}, {"score": 0.0043464021636703066, "phrase": "unified_cache"}, {"score": 0.004304219099917458, "phrase": "unified_lower-level_caches"}, {"score": 0.004252063063815893, "phrase": "memory_requests"}, {"score": 0.004180100198863114, "phrase": "instruction_requests"}, {"score": 0.004089355874644056, "phrase": "new_technique"}, {"score": 0.00394245456672012, "phrase": "set-associative_caches"}, {"score": 0.003904176555928861, "phrase": "vsc."}, {"score": 0.0038287275986210543, "phrase": "unified_approaches"}, {"score": 0.0037092087467846075, "phrase": "power_consumption"}, {"score": 0.0036286495901153605, "phrase": "cache_resources"}, {"score": 0.003455816485737094, "phrase": "data_requirements"}, {"score": 0.00336428077531883, "phrase": "shadow_tags"}, {"score": 0.0033315975831074932, "phrase": "last_evicted_line"}, {"score": 0.0031267359296488118, "phrase": "global_selector_vsc"}, {"score": 0.003111539527089348, "phrase": "vsc"}, {"score": 0.003066264912163443, "phrase": "saturation_counter"}, {"score": 0.0030143100083252516, "phrase": "cache_miss"}, {"score": 0.002934434236130622, "phrase": "duel-like_mechanism"}, {"score": 0.0027809588979112393, "phrase": "cache_hierarchy_power_consumption"}, {"score": 0.0027006464509273806, "phrase": "standard_baseline"}, {"score": 0.002648394103700668, "phrase": "fixed_latency_designs"}, {"score": 0.002622647280008795, "phrase": "split_baseline"}, {"score": 0.0026035011274172753, "phrase": "single-core_system"}, {"score": 0.002584494385587982, "phrase": "variable_latency_st-vsc"}, {"score": 0.0025406818152943853, "phrase": "average_ipc"}, {"score": 0.002485438220894522, "phrase": "multicore_systems"}, {"score": 0.002473325513637559, "phrase": "even_the_slower_fixed_latency_st-vsc_and_gs-vsc_designs"}, {"score": 0.002390169493468952, "phrase": "four-core_system"}, {"score": 0.002326794132784762, "phrase": "lower_cache_levels"}, {"score": 0.0022706362238089227, "phrase": "performance_degradation"}, {"score": 0.002259567976244663, "phrase": "power_consumption_reduction"}, {"score": 0.0022104232660412767, "phrase": "single_level"}], "paper_keywords": ["Virtually split design", " shadow tags", " global selector", " first-level cache memories"], "paper_abstract": "First-level caches are usually split for both instructions and data instead of unifying them in a single cache. Although that approach eases the pipeline design and provides a simple way to independently treat data and instructions, its global hit rate is usually smaller than that of a unified cache. Furthermore, unified lower-level caches usually behave and process memory requests disregarding whether they are data or instruction requests. In this article, we propose a new technique aimed to balance the amount of space devoted to instructions and data for optimizing set-associative caches: the Virtually Split Cache or VSC. Our technique combines the sharing of resources from unified approaches with the bandwidth and parallelism that split configurations provide, thus reducing power consumption while not degrading performance. Our design dynamically adjusts cache resources devoted to instructions and data depending on their particular demand. Two VSC designs are proposed in order to track the instructions and data requirements. The Shadow Tag VSC (ST-VSC) is based on shadow tags that store the last evicted line related to data and instructions in order to determine how well the cache would work with one more way per set devoted to each kind. The Global Selector VSC (GS-VSC) uses a saturation counter that is updated every time a cache miss occurs either under an instruction or data request applying a duel-like mechanism. Experiments with a variable and a fixed latency VSC show that ST-VSC and GS-VSC reduce on average the cache hierarchy power consumption by 29% and 24%, respectively, with respect to a standard baseline. As for performance, while the fixed latency designs virtually match the split baseline in a single-core system, a variable latency ST-VSC and GS-VSC increase the average IPC by 2.5% and 2%, respectively. In multicore systems, even the slower fixed latency ST-VSC and GS-VSC designs improve the baseline IPC by 3.1% and 2.5%, respectively, in a four-core system thanks to the reduction in the bandwidth demanded from the lower cache levels. This is in contrast with many techniques that trade performance degradation for power consumption reduction. VSC particularly benefits embedded processors with a single level of cache, where up to an average 9.2% IPC improvement is achieved. Interestingly, we also find that partitioning the LLC for instructions and data can improve performance around 2%.", "paper_title": "Virtually Split Cache: An Efficient Mechanism to Distribute Instructions and Data", "paper_id": "WOS:000330509300006"}