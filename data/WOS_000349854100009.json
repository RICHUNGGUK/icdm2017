{"auto_keywords": [{"score": 0.049178471674397164, "phrase": "scj"}, {"score": 0.03932998546834823, "phrase": "scj_programs"}, {"score": 0.00481495049065317, "phrase": "mission-based_programming"}, {"score": 0.004769444094319619, "phrase": "safety-critical_java"}, {"score": 0.004635477242873163, "phrase": "recent_technology"}, {"score": 0.0045052562941109734, "phrase": "memory_model"}, {"score": 0.004462909670068632, "phrase": "java"}, {"score": 0.003962899903266524, "phrase": "comprehensive_and_sound_techniques"}, {"score": 0.003906804492585634, "phrase": "formal_specification"}, {"score": 0.0032766780632972363, "phrase": "general_use"}, {"score": 0.003199687131875466, "phrase": "scj_mission_specifications"}, {"score": 0.0031393948330209224, "phrase": "parallel_handlers"}, {"score": 0.003022186855664124, "phrase": "scj_programming_paradigm"}, {"score": 0.002881793492919646, "phrase": "circus_family"}, {"score": 0.0028409576481842457, "phrase": "state-rich_reactive_models"}, {"score": 0.0027741761880779535, "phrase": "class_objects"}, {"score": 0.0027479040199262393, "phrase": "real-time_properties"}, {"score": 0.002683304054823427, "phrase": "sequential_and_centralised_circus_specification"}, {"score": 0.0025954008219792337, "phrase": "circus_models"}, {"score": 0.002570817338292482, "phrase": "scj_program_designs"}, {"score": 0.002486589906779091, "phrase": "refinement_laws"}, {"score": 0.002371018116266096, "phrase": "important_step"}, {"score": 0.0022393843660697484, "phrase": "refinement_strategy"}, {"score": 0.0021049977753042253, "phrase": "rigorous_manner"}], "paper_keywords": ["SCJ", " Models", " Refinement", " Laws", " Patterns", " Automation", " Proof", " Circus"], "paper_abstract": "Safety-Critical Java (SCJ) is a recent technology that changes the execution and memory model of Java in such a way that applications can be statically analysed and certified for their real-time properties and safe use of memory. Our interest is in the development of comprehensive and sound techniques for the formal specification, refinement, design, and implementation of SCJ programs, using a correct-by-construction approach. As part of this work, we present here an account of laws and patterns that are of general use for the refinement of SCJ mission specifications into designs of parallel handlers, as they are used in the SCJ programming paradigm. Our refinement notation is a combination of languages from the Circus family, supporting state-rich reactive models with the addition of class objects and real-time properties. Starting from a sequential and centralised Circus specification, our laws permit refinement into Circus models of SCJ program designs. Automation and proof of the refinement laws is examined here, too. Our work is an important step towards eliciting laws of programming for SCJ and fits into a refinement strategy that we have developed previously to derive SCJ programs from specifications in a rigorous manner.", "paper_title": "Laws of mission-based programming", "paper_id": "WOS:000349854100009"}