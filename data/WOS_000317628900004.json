{"auto_keywords": [{"score": 0.04900470777854888, "phrase": "software_systems"}, {"score": 0.0317638439001368, "phrase": "conjectured_model"}, {"score": 0.015719716506582538, "phrase": "model_inference"}, {"score": 0.013014855256672328, "phrase": "software_system"}, {"score": 0.004559661374976129, "phrase": "behavioral_traces"}, {"score": 0.004278807087784626, "phrase": "software_models"}, {"score": 0.0041637779492720295, "phrase": "model_checking"}, {"score": 0.004070276454809864, "phrase": "model_inference_techniques"}, {"score": 0.0040334640350288, "phrase": "structural_and_design_information"}, {"score": 0.003871869188502677, "phrase": "formal_model"}, {"score": 0.0037506567448470163, "phrase": "passive_model_inference"}, {"score": 0.0036332251283046997, "phrase": "active_model_inference"}, {"score": 0.0033630629374009576, "phrase": "model_inference_phase"}, {"score": 0.0033175095965171674, "phrase": "membership_queries"}, {"score": 0.003056819704624705, "phrase": "testing_phase"}, {"score": 0.00266693888510356, "phrase": "different_counterexample_processing_methods"}, {"score": 0.0025716240685409513, "phrase": "efficient_counterexample_processing_method"}, {"score": 0.002536763634539386, "phrase": "counterexample_processing_method"}, {"score": 0.0023479408542211875, "phrase": "improved_version"}], "paper_keywords": [""], "paper_abstract": "For software systems, models can be learned from behavioral traces, available specifications, knowledge of experts, and other such sources. Software models help to steer testing and model checking of software systems. The model inference techniques extract structural and design information of a software system and present it as a formal model. This chapter briefly discusses the passive model inference and goes on to present the active model inference of software systems using the algorithm L*. This algorithm switches between model inference and testing phases. In model inference phase it asks membership queries and records answers in a table to conjecture a model of a software system under inference. In testing phase it compares a conjectured model with the system under inference. If a test for a conjectured model fails, a counterexample is provided which helps to improve the conjectured model. Different counterexample processing methods are presented and analyzed to identify an efficient counterexample processing method. A counterexample processing method is said to be efficient if it helps to infer a model with fewer membership queries. An improved version of L* is provided which avoids asking queries for some rows and columns of the table which helps to learn models with fewer queries.", "paper_title": "Model Inference and Testing", "paper_id": "WOS:000317628900004"}