{"auto_keywords": [{"score": 0.036633049739012116, "phrase": "linearizability"}, {"score": 0.00481495049065317, "phrase": "modular_fine-grained"}, {"score": 0.004663396040465122, "phrase": "coarse-grained_external_synchronization"}, {"score": 0.004565007074039171, "phrase": "data_structures"}, {"score": 0.004492573860101133, "phrase": "concurrent_threads"}, {"score": 0.0043511221096418475, "phrase": "internal_synchronization"}, {"score": 0.0042820680211904235, "phrase": "stronger_progress_guarantees"}, {"score": 0.004236639288852276, "phrase": "better_performance"}, {"score": 0.0038079353103469865, "phrase": "art_approaches"}, {"score": 0.003668333531296882, "phrase": "concurrent_abstract_predicates"}, {"score": 0.0036100762867678415, "phrase": "important_limitations"}, {"score": 0.003404244237372396, "phrase": "ownership_transfer"}, {"score": 0.003332332086930163, "phrase": "concurrent_abstract_predicates-based_specification_approach"}, {"score": 0.0030758904011907533, "phrase": "novel_approach"}, {"score": 0.0029630461161780203, "phrase": "fully_general_specification"}, {"score": 0.002931569771634119, "phrase": "fine-grained_concurrent_data_structures"}, {"score": 0.0027791193706247267, "phrase": "ghost_code"}, {"score": 0.0027058852678238632, "phrase": "operation's_specification"}, {"score": 0.002662871928330334, "phrase": "specific_client_scenario"}, {"score": 0.002578880352208335, "phrase": "simple_form"}, {"score": 0.0025514745448798385, "phrase": "higher-order_programming"}, {"score": 0.002549992389021184, "phrase": "verifast"}, {"score": 0.0023802825369325354, "phrase": "coq_proof_assistant"}, {"score": 0.0021049977753042253, "phrase": "multiple-compare-and-swap_algorithm"}], "paper_keywords": ["Verification", " fine-grained concurrency", " separation logic"], "paper_abstract": "Compared to coarse-grained external synchronization of operations on data structures shared between concurrent threads, fine-grained, internal synchronization can offer stronger progress guarantees and better performance. However, fully specifying operations that perform internal synchronization modularly is a hard, open problem. The state of the art approaches, based on linearizability or on concurrent abstract predicates, have important limitations on the expressiveness of specifications. Linearizability does not support ownership transfer, and the concurrent abstract predicates-based specification approach requires hardcoding a particular usage protocol. In this paper, we propose a novel approach that lifts these limitations and enables fully general specification of fine-grained concurrent data structures. The basic idea is that clients pass the ghost code required to instantiate an operation's specification for a specific client scenario into the operation in a simple form of higher-order programming. We machine-checked the theory of the paper using the Coq proof assistant. Furthermore, we implemented the approach in our program verifier VeriFast and used it to verify two challenging fine-grained concurrent data structures from the literature: a multiple-compare-and-swap algorithm and a lock-coupling list.", "paper_title": "Expressive Modular Fine-Grained Concurrency Specification", "paper_id": "WOS:000286472700023"}