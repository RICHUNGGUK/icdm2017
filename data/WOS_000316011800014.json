{"auto_keywords": [{"score": 0.03760156015498388, "phrase": "mapreduce"}, {"score": 0.00481495049065317, "phrase": "mapreduce_stage_barrier"}, {"score": 0.004726052718910578, "phrase": "mapreduce_model"}, {"score": 0.0044968982227349625, "phrase": "reduce_stages"}, {"score": 0.0028917056916949744, "phrase": "wide_variety"}, {"score": 0.002855934865505357, "phrase": "mapreduce_applications"}, {"score": 0.002803104254950008, "phrase": "seven_classes"}, {"score": 0.00266693888510356, "phrase": "better_job_completion_times"}, {"score": 0.0026175952455594277, "phrase": "traditional_mapreduce_framework"}, {"score": 0.0023694065215394593, "phrase": "disk-intensive_work"}, {"score": 0.0021049977753042253, "phrase": "best_case"}], "paper_keywords": ["MapReduce", " Data-intensive computing"], "paper_abstract": "The MapReduce model uses a barrier between the Map and Reduce stages. This provides simplicity in both programming and implementation. However, in many situations, this barrier hurts performance because it is overly restrictive. Hence, we develop a method to break the barrier in MapReduce in a way that improves efficiency. Careful design of our barrier-less MapReduce framework results in equivalent generality and retains ease of programming. We motivate our case with, and experimentally study our barrier-less techniques in, a wide variety of MapReduce applications divided into seven classes. Our experiments show that our approach can achieve better job completion times than a traditional MapReduce framework. This is due primarily to the interleaving of I/O and computation, and forgoing disk-intensive work. We achieve a reduction in job completion times that is 25% on average and 87% in the best case.", "paper_title": "Breaking the MapReduce stage barrier", "paper_id": "WOS:000316011800014"}