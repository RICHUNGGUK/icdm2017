{"auto_keywords": [{"score": 0.03363896917055258, "phrase": "seeker"}, {"score": 0.023227289074286093, "phrase": "method_sequences"}, {"score": 0.01051151064858913, "phrase": "high-coverage_testing"}, {"score": 0.0086406675705783, "phrase": "candidate_programs"}, {"score": 0.006513449312514701, "phrase": "dynamic_analysis"}, {"score": 0.004633429997452688, "phrase": "modern_object-oriented_programs"}, {"score": 0.0043738432231020885, "phrase": "proper_method_sequences"}, {"score": 0.004311241567238011, "phrase": "desired_objects"}, {"score": 0.004270003565426343, "phrase": "method_parameters"}, {"score": 0.003992129945230457, "phrase": "program_synthesis"}, {"score": 0.0038415095105632157, "phrase": "user-specified_intent"}, {"score": 0.0036611708297251645, "phrase": "desired_object_states"}, {"score": 0.0035741900278634616, "phrase": "automatic_generation"}, {"score": 0.0035399770257915466, "phrase": "desired_method_sequences"}, {"score": 0.0033737457695128233, "phrase": "multiple_classes"}, {"score": 0.003325410433297401, "phrase": "specific_primitive_values"}, {"score": 0.0032308006242867224, "phrase": "novel_approach"}, {"score": 0.0030938932434437178, "phrase": "large_search_space"}, {"score": 0.0030203487665054806, "phrase": "static_and_dynamic_analyses"}, {"score": 0.0027697290872182477, "phrase": "not-covered_branches"}, {"score": 0.002730023736069673, "phrase": "candidate_sequences"}, {"score": 0.002601727192945944, "phrase": "statically_generated_sequences"}, {"score": 0.002340250894008014, "phrase": "higher_branch_coverage"}, {"score": 0.0023178219772486868, "phrase": "def-use_coverage"}, {"score": 0.0021049977753042253, "phrase": "existing_tools"}], "paper_keywords": ["Languages", " Experimentation", " Object-oriented testing", " Symbolic execution"], "paper_abstract": "High-coverage testing is challenging. Modern object-oriented programs present additional challenges for testing. One key difficulty is the generation of proper method sequences to construct desired objects as method parameters. In this paper, we cast the problem as an instance of program synthesis that automatically generates candidate programs to satisfy a user-specified intent. In our setting, candidate programs are method sequences, and desired object states specify an intent. Automatic generation of desired method sequences is difficult due to its large search space-sequences often involve methods from multiple classes and require specific primitive values. This paper introduces a novel approach, called Seeker, to intelligently navigate the large search space. Seeker synergistically combines static and dynamic analyses: (1) dynamic analysis generates method sequences to cover branches; (2) static analysis uses dynamic analysis information for not-covered branches to generate candidate sequences; and (3) dynamic analysis explores and eliminates statically generated sequences. For evaluation, we have implemented Seeker and demonstrate its effectiveness on four subject applications totalling 28K LOC. We show that Seeker achieves higher branch coverage and def-use coverage than existing state-of-the-art approaches. We also show that Seeker detects 34 new defects missed by existing tools.", "paper_title": "Synthesizing Method Sequences for High-Coverage Testing", "paper_id": "WOS:000298294500013"}