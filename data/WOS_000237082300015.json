{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "real_world"}, {"score": 0.004747620102130588, "phrase": "polyhedral_model"}, {"score": 0.00461575768501871, "phrase": "powerful_framework"}, {"score": 0.004529881123652277, "phrase": "high_level_loop_transformations"}, {"score": 0.004424768776701965, "phrase": "optimizing_compilers"}, {"score": 0.004362870617347183, "phrase": "generally_accepted_ideas"}, {"score": 0.004085221464783815, "phrase": "dependence_analysis"}, {"score": 0.004047020753789236, "phrase": "irregular_access_patterns"}, {"score": 0.00375395061615019, "phrase": "wide_code_regions"}, {"score": 0.003684048704119722, "phrase": "new_algorithms"}, {"score": 0.0035648266669315943, "phrase": "target_code"}, {"score": 0.0034494494982242187, "phrase": "code_generation_step"}, {"score": 0.003291051334991867, "phrase": "new_software_tools"}, {"score": 0.003066945490483524, "phrase": "strong_optimization_potential"}, {"score": 0.0028986672783671147, "phrase": "code_generation"}, {"score": 0.0027916287357898544, "phrase": "high_control_overhead"}, {"score": 0.002726740692380339, "phrase": "scalable_code_generation_methods"}, {"score": 0.0026384167183586015, "phrase": "increasingly_complex_program_transformations"}, {"score": 0.0023789822182914877, "phrase": "code_generation_quality"}, {"score": 0.002291089893848235, "phrase": "best_state-of-the-art_code_generation_tool"}, {"score": 0.0021551222226685648, "phrase": "new_algorithm"}, {"score": 0.0021249064184347658, "phrase": "code_performance"}, {"score": 0.0021049977753042253, "phrase": "strided_domains"}], "paper_keywords": [""], "paper_abstract": "The polyhedral model is known to be a powerful framework to reason about high level loop transformations. Recent developments in optimizing compilers broke some generally accepted ideas about the limitations of this model. First, thanks to advances in dependence analysis for irregular access patterns, its applicability which was supposed to be limited to very simple loop nests has been extended to wide code regions. Then, new algorithms made it possible to compute the target code for hundreds of statements while this code generation step was expected not to be scalable. Such theoretical advances and new software tools allowed actors from both academia and industry to study more complex and realistic cases. Unfortunately, despite strong optimization potential of a given transformation for e.g., parallelism or data locality, code generation may still be challenging or result in high control overhead. This paper presents scalable code generation methods that make possible the application of increasingly complex program transformations. By studying the transformations themselves, we show how it is possible to benefit from their properties to dramatically improve both code generation quality and space/time complexity, with respect to the best state-of-the-art code generation tool. In addition, we build on these improvements to present a new algorithm improving generated code performance for strided domains and reindexed schedules.", "paper_title": "Polyhedral code generation in the real world", "paper_id": "WOS:000237082300015"}