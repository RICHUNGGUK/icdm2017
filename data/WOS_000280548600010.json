{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrent_write_barriers"}, {"score": 0.004723372980599603, "phrase": "concurrent"}, {"score": 0.004633429997452688, "phrase": "incremental_collectors"}, {"score": 0.004416079619543104, "phrase": "correct_synchronisation"}, {"score": 0.004011366422179016, "phrase": "particular_barriers"}, {"score": 0.003934970057482768, "phrase": "particular_systems"}, {"score": 0.003714368305523811, "phrase": "somewhat_fewer_studies"}, {"score": 0.0032777653153451265, "phrase": "floating_garbage"}, {"score": 0.0029203055813347874, "phrase": "different_barrier_choices"}, {"score": 0.0026268961477241026, "phrase": "increasing_importance"}, {"score": 0.0025767987652419054, "phrase": "emerging_architectures"}, {"score": 0.002208853811052348, "phrase": "processor_architecture"}, {"score": 0.0021049977753042253, "phrase": "garbage_collection_algorithm"}], "paper_keywords": ["Measurement", " Performance", " Languages", " Language implementation", " Memory management", " Garbage collection", " Java"], "paper_abstract": "Concurrent and incremental collectors require barriers to ensure correct synchronisation between mutator and collector. The overheads imposed by particular barriers on particular systems have been widely studied. Somewhat fewer studies have also compared barriers in terms of their termination properties or the volume of floating garbage they generate. Until now, the consequences for locality of different barrier choices has not been studied, although locality will be of increasing importance for emerging architectures. This paper provides a study of the locality of concurrent write barriers, independent of the processor architecture, virtual machine, compiler or garbage collection algorithm.", "paper_title": "The Locality of Concurrent Write Barriers", "paper_id": "WOS:000280548600010"}