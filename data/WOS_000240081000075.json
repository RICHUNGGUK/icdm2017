{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "iterative_modulo_scheduling"}, {"score": 0.004767826806287385, "phrase": "high_performance_multi-issue_dsps"}, {"score": 0.004494570360108983, "phrase": "high_performance_multi-issue_digital_signal_processors"}, {"score": 0.004236908273106904, "phrase": "idle_state_functional_units"}, {"score": 0.004154332348800334, "phrase": "reduced_idle_units"}, {"score": 0.004073359218158693, "phrase": "positively_significant_impact"}, {"score": 0.003954837422946628, "phrase": "complex_instructions"}, {"score": 0.003783606115056291, "phrase": "mac"}, {"score": 0.003709693561373117, "phrase": "data_dependence_complexity"}, {"score": 0.003584025547693836, "phrase": "signal_processing_applications"}, {"score": 0.003531474887552889, "phrase": "modulo_scheduling_freedom"}, {"score": 0.003428665921276366, "phrase": "limiting_factor"}, {"score": 0.003378385493203297, "phrase": "iterative_modulo_scheduler"}, {"score": 0.0031223774204093713, "phrase": "application_loop_code"}, {"score": 0.003091767402370757, "phrase": "dependence_complexity"}, {"score": 0.0030017207229983385, "phrase": "dependence_constraint"}, {"score": 0.0027878797103973313, "phrase": "intrinsic_cyclic_dependencies"}, {"score": 0.0026020254041372723, "phrase": "based_dependence"}, {"score": 0.0024768883044869023, "phrase": "limited_cases"}, {"score": 0.0023928819778638055, "phrase": "loop_unrolling"}, {"score": 0.002323142666222693, "phrase": "huge_code_size_increment"}, {"score": 0.002255431275670053, "phrase": "relaxed_dependence_techniques"}, {"score": 0.002233301265743633, "phrase": "general_cases"}, {"score": 0.0022005118194652704, "phrase": "np-hard_problem"}, {"score": 0.0021682027434117095, "phrase": "complex_assignments"}, {"score": 0.002125859121671525, "phrase": "functional_units"}], "paper_keywords": ["code generation and optimization", " application specific embedded software design", " software pipelining", " dependence analysis", " high performance DSPs"], "paper_abstract": "An iterative modulo scheduling is very important for compilers targeting high performance multi-issue digital signal processors. This is because these processors are often severely limited by idle state functional units and thus the reduced idle units can have a positively significant impact on their performance. However, complex instructions, which are used in most recent DSPs such as mac, usually increase data dependence complexity, and such complex dependencies that exist in signal processing applications often restrict modulo scheduling freedom and therefore, become a limiting factor of the iterative modulo scheduler. In this work, we propose a technique that efficiently reselects instructions of an application loop code considering dependence complexity, which directly resolve the dependence constraint. That is specifically featured for accelerating software pipelining performance by minimizing length of intrinsic cyclic dependencies. To take advantage of this feature, few existing compilers support a loop unrolling based dependence relaxing technique, but only use them for some limited cases. This is mainly because the loop unrolling typically occurs an overhead of huge code size increment, and the iterative modulo scheduling with relaxed dependence techniques for general cases is an NP-hard problem that necessitates complex assignments of registers and functional units. Our technique uses a heuristic to efficiently handle this problem in pre-stage of iterative modulo scheduling without loop unrolling.", "paper_title": "Instruction re-selection for iterative modulo scheduling on high performance multi-issue DSPs", "paper_id": "WOS:000240081000075"}