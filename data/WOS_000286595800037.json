{"auto_keywords": [{"score": 0.04032963393643778, "phrase": "oigj"}, {"score": 0.005235474441885261, "phrase": "immutable_cyclic_structures"}, {"score": 0.00481495049065317, "phrase": "generic_java"}, {"score": 0.0047650691627251825, "phrase": "java_language"}, {"score": 0.004715702140552199, "phrase": "important_notions"}, {"score": 0.0045547927862194856, "phrase": "unwanted_aliasing"}, {"score": 0.004219774794569897, "phrase": "representation_exposure"}, {"score": 0.004161553532799662, "phrase": "immutability_contracts"}, {"score": 0.0040899006497687115, "phrase": "ownership_immutability_generic_java"}, {"score": 0.004005537264228818, "phrase": "backward-compatible_purely-static_language_extension"}, {"score": 0.00386876598761639, "phrase": "core_calculus"}, {"score": 0.0037889466472096284, "phrase": "featherweight_java"}, {"score": 0.003621588555525458, "phrase": "case_studies"}, {"score": 0.003485744667868367, "phrase": "\"cooking_phase"}, {"score": 0.0032629585038738856, "phrase": "ownership_information"}, {"score": 0.003140524241432171, "phrase": "cooking_phase"}, {"score": 0.0027137301650680175, "phrase": "previous_ownership_languages"}, {"score": 0.002630085891013006, "phrase": "-check_more_good_code"}, {"score": 0.0025578967205807843, "phrase": "visitor_patterns"}, {"score": 0.0024963543716522087, "phrase": "sun's_java"}, {"score": 0.002427826856342292, "phrase": "clone_method"}, {"score": 0.002344800544183559, "phrase": "previous_work"}, {"score": 0.0023285383529595416, "phrase": "major_refactoring"}, {"score": 0.002312388685547026, "phrase": "existing_code"}, {"score": 0.002233301265743633, "phrase": "well-designed_code"}, {"score": 0.0021871503075921537, "phrase": "programmer_effort"}, {"score": 0.0021049977753042253, "phrase": "mainstream_community"}], "paper_keywords": ["Experimentation", " Languages", " Theory"], "paper_abstract": "The Java language lacks the important notions of ownership (an object owns its representation to prevent unwanted aliasing) and immutability (the division into mutable, immutable, and readonly data and references). Programmers are prone to design errors, such as representation exposure or violation of immutability contracts. This paper presents Ownership Immutability Generic Java (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined a core calculus for OIGJ, based on Featherweight Java, and proved it sound. We also implemented OIGJ and performed case studies on 33,000 lines of code. Creation of immutable cyclic structures requires a \"cooking phase\" in which the structure is mutated but the outside world cannot observe this mutation. OIGJ uses ownership information to facilitate creation of immutable cyclic structures, by safely prolonging the cooking phase even after the constructor finishes. OIGJ is easy for a programmer to use, and it is easy to implement (flow-insensitive, adding only 14 rules to those of Java). Yet, OIGJ is more expressive than previous ownership languages, in the sense that it can type-check more good code. OIGJ can express the factory and visitor patterns, and OIGJ can type-check Sun's java. util collections (except for the clone method) without refactoring and with only a small number of annotations. Previous work required major refactoring of existing code in order to fit its ownership restrictions. Forcing refactoring of well-designed code is undesirable because it costs programmer effort, degrades the design, and hinders adoption in the mainstream community.", "paper_title": "Ownership and Immutability in Generic Java", "paper_id": "WOS:000286595800037"}