{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "noise_identification"}, {"score": 0.004745260932479212, "phrase": "software_architecture_recovery_techniques"}, {"score": 0.0046993598473345395, "phrase": "software_systems'_concrete_architecture"}, {"score": 0.004586531354697466, "phrase": "intended_architecture"}, {"score": 0.004498213310668266, "phrase": "program_comprehension_activities"}, {"score": 0.00443308765153716, "phrase": "software_architecture_recovery"}, {"score": 0.004263972370406983, "phrase": "large_and_complex_systems"}, {"score": 0.0040222701316738295, "phrase": "omnipresent_and_utility_classes"}, {"score": 0.0039447744176901054, "phrase": "system_structure"}, {"score": 0.003906586074865932, "phrase": "omnipresent_classes"}, {"score": 0.00386876598761639, "phrase": "crosscutting_concerns"}, {"score": 0.0037942165191367366, "phrase": "elementary_domain_concepts"}, {"score": 0.003614044704141927, "phrase": "necessary_preprocessing_step"}, {"score": 0.0035616743422949766, "phrase": "program_comprehension_techniques"}, {"score": 0.003493021648360933, "phrase": "undocumented_systems"}, {"score": 0.0033433365160336842, "phrase": "automated_methodology"}, {"score": 0.0031690434364310435, "phrase": "noisy_classes"}, {"score": 0.0029602552900111407, "phrase": "classes'_usage_significance"}, {"score": 0.002875027551180213, "phrase": "system's_subgraphs"}, {"score": 0.0026986685585382347, "phrase": "usage_significance"}, {"score": 0.0026337482179592422, "phrase": "component_rank"}, {"score": 0.00247215300812495, "phrase": "software_artifacts"}, {"score": 0.002400944221804575, "phrase": "experimental_results"}, {"score": 0.0023546121947302877, "phrase": "proposed_methodology"}, {"score": 0.002220900173110114, "phrase": "existing_algorithms"}, {"score": 0.002199363362666037, "phrase": "software_systems"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Noise identification", " Omnipresent classes", " Software architecture recovery"], "paper_abstract": "Software systems' concrete architecture often drifts from the intended architecture throughout their evolution. Program comprehension activities, like software architecture recovery, become very demanding, especially for large and complex systems due to the existence of noise, which is created by omnipresent and utility classes that obscure the system structure. Omnipresent classes represent crosscutting concerns, utilities or elementary domain concepts. The identification and filtering of noise is a necessary preprocessing step before attempting program comprehension techniques, especially for undocumented systems. In this paper, we propose an automated methodology for noise identification. Our methodology is based on the notion that noisy classes are widely used in a system, directly or indirectly. We combine classes' usage significance with their participation in the system's subgraphs, in order to identify the classes that are persistently used. Usage significance is measured according to Component Rank, a well-established metric in the literature, which ranks software artifacts according to their usage significance. The experimental results show that the proposed methodology successfully captures classes that produce noise and improves the results of existing algorithms for software systems' architectural decomposition. (C) 2015 Elsevier Inc. All rights reserved.", "paper_title": "An automated approach for noise identification to assist software architecture recovery techniques", "paper_id": "WOS:000358699700009"}