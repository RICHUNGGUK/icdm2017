{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "malware_analysis"}, {"score": 0.004648609688625397, "phrase": "primary_step"}, {"score": 0.004332894955218135, "phrase": "malware_binary"}, {"score": 0.004257360656055417, "phrase": "reverse_engineer"}, {"score": 0.0041586840496756474, "phrase": "extensive_effort"}, {"score": 0.00408617426304956, "phrase": "resulting_assembly_code"}, {"score": 0.0038534477978822133, "phrase": "assembly_code"}, {"score": 0.0038085117064624208, "phrase": "future_references"}, {"score": 0.003591542373891629, "phrase": "assembly_code_clone_search_system"}, {"score": 0.0035496495489801667, "phrase": "scalclone"}, {"score": 0.003447035529485425, "phrase": "assembly_code_clone_detection_systems"}, {"score": 0.0032315723330399375, "phrase": "code_clones"}, {"score": 0.0030653094605910727, "phrase": "previously_analyzed_malware_binaries"}, {"score": 0.0027579362569638945, "phrase": "high_recall_rate"}, {"score": 0.0026624684547385718, "phrase": "malware_analysts"}, {"score": 0.002600661525224505, "phrase": "exact_and_inexact_clones"}, {"score": 0.002570296816631395, "phrase": "different_token_normalization_levels"}, {"score": 0.0024667783849055634, "phrase": "scalable_system"}, {"score": 0.0024236964502593254, "phrase": "database_model"}, {"score": 0.002381365139274329, "phrase": "large-scale_assembly_code_search"}, {"score": 0.0022854384756395116, "phrase": "real-life_malware_binaries"}, {"score": 0.002193367454830741, "phrase": "assembly_code_clones"}, {"score": 0.002129877319760485, "phrase": "different_scenarios"}, {"score": 0.0021049977753042253, "phrase": "code_mutations"}], "paper_keywords": ["Assembly code clone detection", " Malware analysis", " Reverse engineering", " Software fingerprinting", " Software security"], "paper_abstract": "Reverse engineering is the primary step to analyze a piece of malware. After having disassembled a malware binary, a reverse engineer needs to spend extensive effort analyzing the resulting assembly code, and then documenting it through comments in the assembly code for future references. In this paper, we have developed an assembly code clone search system called ScalClone based on our previous work on assembly code clone detection systems. The objective of the system is to identify the code clones of a target malware from a collection of previously analyzed malware binaries. Our new contributions are summarized as follows: First, we introduce two assembly code clone search methods for malware analysis with a high recall rate. Second, our methods allow malware analysts to discover both exact and inexact clones at different token normalization levels. Third, we present a scalable system with a database model to support large-scale assembly code search. Finally, experimental results on real-life malware binaries suggest that our proposed methods can effectively identify assembly code clones with the consideration of different scenarios of code mutations. (C) 2015 Elsevier Ltd. All rights reserved.", "paper_title": "Scalable code clone search for malware analysis", "paper_id": "WOS:000366160500005"}