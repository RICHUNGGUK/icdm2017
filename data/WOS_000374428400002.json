{"auto_keywords": [{"score": 0.04930986456658361, "phrase": "wu"}, {"score": 0.00481495049065317, "phrase": "software_development_architecture_for_job-level_algorithms."}, {"score": 0.004586531354697466, "phrase": "general_distributed_computing_approach"}, {"score": 0.004512814529823301, "phrase": "job-level"}, {"score": 0.004345363360869553, "phrase": "jl_computing"}, {"score": 0.00427550604912774, "phrase": "search_tree"}, {"score": 0.004161553532799662, "phrase": "client_process"}, {"score": 0.004094639048362357, "phrase": "search_tree_nodes"}, {"score": 0.003879234831701853, "phrase": "game-playing_programs"}, {"score": 0.0038168424095396205, "phrase": "node_operations"}, {"score": 0.0037352048741373816, "phrase": "coarse-grain_jobs"}, {"score": 0.003334309053314909, "phrase": "jl_computing_approach"}, {"score": 0.0032629585038738856, "phrase": "general_jl_search_framework"}, {"score": 0.003210446135114967, "phrase": "common_modules"}, {"score": 0.003074495313651187, "phrase": "jl_development"}, {"score": 0.0028968858148006823, "phrase": "jl_proof-number_search"}, {"score": 0.002789226820897593, "phrase": "jl_upper_confidence_bound"}, {"score": 0.0026710653215026685, "phrase": "case_studies"}, {"score": 0.0025857324180891526, "phrase": "jl_search_framework"}, {"score": 0.002410058288617039, "phrase": "new_jl_applications"}, {"score": 0.002320449502337321, "phrase": "jl_framework"}, {"score": 0.0021049977753042253, "phrase": "new_jl_application_development_and_software_maintenance_efforts"}], "paper_keywords": [""], "paper_abstract": "Recently, Wu et al. introduced a general distributed computing approach, named Job-Level (JL) Computing. In JL computing, a search tree is maintained by a client process, while search tree nodes are evaluated, expanded, or generated by leveraging game-playing programs. These node operations are encapsulated as coarse-grain jobs, each requiring tens of seconds or more of running the programs. This article presents an abstraction of the JL computing approach and develops a general JL search framework so that common modules may be reused for various JL applications, making JL development easier. We describe in detail the implementation of the JL Proof-number Search (JL-PNS) and JL Upper Confidence Bound Search (JL-UCT) as case studies in the application of the JL search framework. In our case studies, only hundreds of lines of code are required for new JL applications, while the code for the JL framework consists of more than ten thousand lines of code. It demonstrates that this framework can be used to greatly reduce new JL application development and software maintenance efforts.", "paper_title": "SOFTWARE DEVELOPMENT ARCHITECTURE FOR JOB-LEVEL ALGORITHMS", "paper_id": "WOS:000374428400002"}