{"auto_keywords": [{"score": 0.03861839791936737, "phrase": "application_threads"}, {"score": 0.00481495049065317, "phrase": "java_application_performance"}, {"score": 0.004768649568826951, "phrase": "multicore_hardware"}, {"score": 0.004413846562278824, "phrase": "increasing_numbers"}, {"score": 0.004329331617724, "phrase": "modern-day_multicore_processors"}, {"score": 0.004205570965859848, "phrase": "multi-threaded_managed_language_applications"}, {"score": 0.004026505114417176, "phrase": "server_domain"}, {"score": 0.003987755561492638, "phrase": "managed_languages"}, {"score": 0.003949377440799037, "phrase": "performance_studies"}, {"score": 0.0038737214010638745, "phrase": "additional_virtual_machine_threads"}, {"score": 0.0035679633126097115, "phrase": "modern_multicore_machines"}, {"score": 0.0035336109352157763, "phrase": "multiple_sockets"}, {"score": 0.0034995881411519925, "phrase": "dynamic_frequency_scaling_options"}, {"score": 0.003161474881435185, "phrase": "java_applications"}, {"score": 0.0028421434495262796, "phrase": "jvm_threads"}, {"score": 0.002655894070657161, "phrase": "clock_frequency"}, {"score": 0.002630299922281952, "phrase": "isolated_threads"}, {"score": 0.002542642270762272, "phrase": "multi-threaded_dacapo_benchmarks"}, {"score": 0.0023990982005125763, "phrase": "intel_nehalem"}, {"score": 0.002177600561610171, "phrase": "first_but_important_step"}, {"score": 0.0021254913611527455, "phrase": "managed_language_performance"}, {"score": 0.0021049977753042253, "phrase": "modern_hardware"}], "paper_keywords": ["Performance", " Measurement", " Performance Analysis", " Multicore", " Managed Languages", " Java"], "paper_abstract": "While there have been many studies of how to schedule applications to take advantage of increasing numbers of cores in modern-day multicore processors, few have focused on multi-threaded managed language applications which are prevalent from the embedded to the server domain. Managed languages complicate performance studies because they have additional virtual machine threads that collect garbage and dynamically compile, closely interacting with application threads. Further complexity is introduced as modern multicore machines have multiple sockets and dynamic frequency scaling options, broadening opportunities to reduce both power and running time. In this paper, we explore the performance of Java applications, studying how best to map application and virtual machine (JVM) threads to a multicore, multi-socket environment. We explore both the cost of separating JVM threads from application threads, and the opportunity to speed up or slow down the clock frequency of isolated threads. We perform experiments with the multi-threaded DaCapo benchmarks and pseudojbb2005 running on the Jikes Research Virtual Machine, on a dual-socket, 8-core Intel Nehalem machine to reveal several novel, and sometimes counter-intuitive, findings. We believe these insights are a first but important step towards understanding and optimizing managed language performance on modern hardware.", "paper_title": "Exploring Multi-Threaded Java Application Performance on Multicore Hardware", "paper_id": "WOS:000311296200017"}