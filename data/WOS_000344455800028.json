{"auto_keywords": [{"score": 0.03253253627295769, "phrase": "swift"}, {"score": 0.010945942024763147, "phrase": "top-down_and_bottom-up_analyses"}, {"score": 0.00481495049065317, "phrase": "interprocedural_analysis"}, {"score": 0.004749106104067268, "phrase": "interprocedural_static_analyses"}, {"score": 0.003970439654470374, "phrase": "top-down_analyses"}, {"score": 0.0038624981944755813, "phrase": "ineffective_reuse"}, {"score": 0.003757480190200645, "phrase": "bottom-up_analyses"}, {"score": 0.0036553070575015344, "phrase": "inefficient_computation"}, {"score": 0.0034118234596993836, "phrase": "hybrid_approach_swift"}, {"score": 0.002643386043540555, "phrase": "type-state_analysis"}, {"score": 0.002399970113552336, "phrase": "kloc"}, {"score": 0.002302619021497886, "phrase": "conventional_approaches"}, {"score": 0.0021049977753042253, "phrase": "larger_programs"}], "paper_keywords": [""], "paper_abstract": "Interprocedural static analyses are broadly classified into top-down and bottom-up, depending upon how they compute, instantiate, and reuse procedure summaries. Both kinds of analyses are challenging to scale: top-down analyses are hindered by ineffective reuse of summaries whereas bottom-up analyses are hindered by inefficient computation and instantiation of summaries. This paper presents a hybrid approach SWIFT that combines top-down and bottom-up analyses in a manner that gains their benefits without suffering their drawbacks. SWIFT is general in that it is parametrized by the top-down and bottom-up analyses it combines. We show an instantiation of SWIFT on a type-state analysis and evaluate it on a suite of 12 Java programs of size 60-250 KLOC each. SWIFT outperforms both conventional approaches, finishing on all the programs while both of those approaches fail on the larger programs.", "paper_title": "Hybrid Top-down and Bottom-up Interprocedural Analysis", "paper_id": "WOS:000344455800028"}