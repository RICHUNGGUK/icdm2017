{"auto_keywords": [{"score": 0.049754507386661914, "phrase": "stream_processing_applications"}, {"score": 0.04325124255431723, "phrase": "multicore_processors"}, {"score": 0.00481495049065317, "phrase": "data_stream_processing"}, {"score": 0.004749913509007163, "phrase": "online_analytics"}, {"score": 0.004701710196317656, "phrase": "high-rate_data_sources"}, {"score": 0.004529093447865156, "phrase": "live_results"}, {"score": 0.004483120978156604, "phrase": "timely_manner"}, {"score": 0.004437613070853689, "phrase": "data_flow_graph_representation"}, {"score": 0.004318494608235021, "phrase": "stream_computing_tasks"}, {"score": 0.004188287972391714, "phrase": "possible_runtime_exploitation"}, {"score": 0.003993472712847928, "phrase": "rich_set"}, {"score": 0.003966388754366831, "phrase": "parallelization_opportunities"}, {"score": 0.0038467574225322086, "phrase": "combinatorial_number"}, {"score": 0.003820664678548735, "phrase": "possible_configurations"}, {"score": 0.0037562016088622447, "phrase": "best_configuration"}, {"score": 0.0036305081978734127, "phrase": "multiple_runs"}, {"score": 0.003532977898022071, "phrase": "different_phases"}, {"score": 0.003391556348707911, "phrase": "autopipelining_solution"}, {"score": 0.0032668821950788502, "phrase": "streaming_applications"}, {"score": 0.003222687723450745, "phrase": "effective_and_transparent_way"}, {"score": 0.0030936482163040823, "phrase": "good_utilization"}, {"score": 0.0029900592229516187, "phrase": "pipeline_parallelism"}, {"score": 0.0027931421106359875, "phrase": "application_developers"}, {"score": 0.002690406375639144, "phrase": "light-weight_runtime_profiling_scheme"}, {"score": 0.002547663224855668, "phrase": "best_places"}, {"score": 0.0025217522723800204, "phrase": "data_flow_graph"}, {"score": 0.0024961041872030073, "phrase": "additional_parallelism"}, {"score": 0.0024623110626032364, "phrase": "adaptive_control_scheme"}, {"score": 0.002428974327006118, "phrase": "right_level"}, {"score": 0.0023475891378276735, "phrase": "industrial-strength_stream_processing_system"}, {"score": 0.0022766712610014484, "phrase": "synthetic_workloads"}, {"score": 0.0022382002476510573, "phrase": "real-world_applications"}, {"score": 0.0021049977753042253, "phrase": "application_code"}], "paper_keywords": ["Stream processing", " parallelization", " autopipelining"], "paper_abstract": "Stream processing applications use online analytics to ingest high-rate data sources, process them on-the-fly, and generate live results in a timely manner. The data flow graph representation of these applications facilitates the specification of stream computing tasks with ease, and also lends itself to possible runtime exploitation of parallelization on multicore processors. While the data flow graphs naturally contain a rich set of parallelization opportunities, exploiting them is challenging due to the combinatorial number of possible configurations. Furthermore, the best configuration is dynamic in nature; it can differ across multiple runs of the application, and even during different phases of the same run. In this paper, we propose an autopipelining solution that can take advantage of multicore processors to improve throughput of streaming applications, in an effective and transparent way. The solution is effective in the sense that it provides good utilization of resources by dynamically finding and exploiting sources of pipeline parallelism in streaming applications. It is transparent in the sense that it does not require any hints from the application developers. As a part of our solution, we describe a light-weight runtime profiling scheme to learn resource usage of operators comprising the application, an optimization algorithm to locate best places in the data flow graph to explore additional parallelism, and an adaptive control scheme to find the right level of parallelism. We have implemented our solution in an industrial-strength stream processing system. Our experimental evaluation based on microbenchmarks, synthetic workloads, as well as real-world applications confirms that our design is effective in optimizing the throughput of stream processing applications without requiring any changes to the application code.", "paper_title": "Autopipelining for Data Stream Processing", "paper_id": "WOS:000326501400004"}