{"auto_keywords": [{"score": 0.03687202483753312, "phrase": "numa"}, {"score": 0.004592340708764929, "phrase": "rapid_growth"}, {"score": 0.004552981066668676, "phrase": "multi-core_multi-chip_machines"}, {"score": 0.004379977556546879, "phrase": "new_machines"}, {"score": 0.004195418010131832, "phrase": "concurrent_algorithms"}, {"score": 0.004159446063902181, "phrase": "synchronization_primitives"}, {"score": 0.004088421020408183, "phrase": "building_blocks"}, {"score": 0.0040186038781533946, "phrase": "today's_applications"}, {"score": 0.003546722347907148, "phrase": "reader-writer_lock_algorithms"}, {"score": 0.003296212583539166, "phrase": "higher_concurrency"}, {"score": 0.0032398798149196432, "phrase": "better_back-to-back_batching"}, {"score": 0.0030501665085457606, "phrase": "g_technique"}, {"score": 0.0029467742734417255, "phrase": "numa-friendly_fashion"}, {"score": 0.002810292047426252, "phrase": "simple_distributed_reader_counter_implementations"}, {"score": 0.0027741761880779535, "phrase": "numa-friendly_concurrency"}, {"score": 0.0027150087516999047, "phrase": "end_result"}, {"score": 0.0026570998719084153, "phrase": "surprisingly_simple_numa-aware_algorithms"}, {"score": 0.0026116610153271943, "phrase": "state-of-the-art_reader-writer_locks"}, {"score": 0.002437525632451029, "phrase": "realistic_setting"}, {"score": 0.0022457226013538343, "phrase": "heavy_use"}, {"score": 0.002226430168622392, "phrase": "pthread_reader-writer_locks"}, {"score": 0.0021049977753042253, "phrase": "prior_alternatives"}], "paper_keywords": ["Algorithms", " Design", " Performance", " NUMA", " hierarchical locks", " mutual exclusion", " reader-writer locks"], "paper_abstract": "Non-Uniform Memory Access (NUMA) architectures are gaining importance in mainstream computing systems due to the rapid growth of multi-core multi-chip machines. Extracting the best possible performance from these new machines will require us to revisit the design of the concurrent algorithms and synchronization primitives which form the building blocks of many of today's applications. This paper revisits one such critical synchronization primitive - the reader-writer lock. We present what is, to the best of our knowledge, the first family of reader-writer lock algorithms tailored to NUMA architectures. We present several variations which trade fairness between readers and writers for higher concurrency among readers and better back-to-back batching of writers from the same NUMA node. Our algorithms leverage the lock cohort in g technique to manage synchronization between writers in a NUMA-friendly fashion, binary flags to coordinate readers and writers, and simple distributed reader counter implementations to enable NUMA-friendly concurrency among readers. The end result is a collection of surprisingly simple NUMA-aware algorithms that outperform the state-of-the-art reader-writer locks by up to a factor of 10 in our microbench-mark experiments. To evaluate our algorithms in a realistic setting we also present performance results of the kccachetest benchmark of the Kyoto-Cabin et distribution, an open-source database which makes heavy use of pthread reader-writer locks. Our locks boost the performance of kccachetest by up to 40% over the best prior alternatives.", "paper_title": "NUMA-Aware Reader-Writer Locks", "paper_id": "WOS:000324158900015"}