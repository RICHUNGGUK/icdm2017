{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "intersection_types"}, {"score": 0.004481132747216135, "phrase": "intersection_type_operator"}, {"score": 0.004441059405327222, "phrase": "meta-level_operator"}, {"score": 0.004335932873514455, "phrase": "direct_logical_counterpart"}, {"score": 0.00429715240295033, "phrase": "curry-howard_isomorphism_sense"}, {"score": 0.004120694410890683, "phrase": "intuitionistic_conjunction"}, {"score": 0.00408383113155665, "phrase": "intersection_type_system"}, {"score": 0.004035190488387378, "phrase": "type_inference_system"}, {"score": 0.003916098498242888, "phrase": "meta-level_nature"}, {"score": 0.0038810583785936505, "phrase": "intersection_operator"}, {"score": 0.003789137457228946, "phrase": "equivalent_typed_system"}, {"score": 0.003526186748088922, "phrase": "entirely_satisfactory_answer"}, {"score": 0.0033914308417007316, "phrase": "main_results"}, {"score": 0.003321008590273796, "phrase": "logical_interpretation"}, {"score": 0.0032716011062067286, "phrase": "proposed_typed_lambda_calculi"}, {"score": 0.0031845067058084613, "phrase": "new_proposal"}, {"score": 0.0031559919178954644, "phrase": "true_intersection"}, {"score": 0.0031465436619697385, "phrase": "typed_lambda_calculus"}, {"score": 0.003109031770476385, "phrase": "meta-level_notion"}, {"score": 0.0030627682280971328, "phrase": "typable_term"}, {"score": 0.0030262520433471333, "phrase": "intersection_type_inference"}, {"score": 0.0029901699209266435, "phrase": "corresponding_typed_term"}, {"score": 0.002919287408226361, "phrase": "untyped_term"}, {"score": 0.0028844769395018595, "phrase": "type_decorations"}, {"score": 0.0028586409810976367, "phrase": "typed_term"}, {"score": 0.0027575842698911173, "phrase": "main_idea"}, {"score": 0.0027165361453855095, "phrase": "relevant_parallel_term_constructor"}, {"score": 0.0026760974046034854, "phrase": "intersection_type_constructor"}, {"score": 0.00262048982464897, "phrase": "parallel_share"}, {"score": 0.0025278307267360216, "phrase": "free_typed_variables"}, {"score": 0.002467880918630221, "phrase": "typed_terms"}, {"score": 0.0023451553255837317, "phrase": "parallel_term"}, {"score": 0.0023241387549221408, "phrase": "synchronized_way"}, {"score": 0.002282667669149476, "phrase": "third_rule"}, {"score": 0.002269008698686152, "phrase": "local_renaming"}, {"score": 0.0022419349154472806, "phrase": "free_typed_variable"}, {"score": 0.0021304214257321, "phrase": "type_refinement"}, {"score": 0.0021049977753042253, "phrase": "particular_resource"}], "paper_keywords": ["intersection types", " lambda calculus", " type inference", " Church style", " Curry style", " parallelism", " shared resources"], "paper_abstract": "Intersection types are well known to type theorists mainly for two reasons. Firstly, they type all and only the strongly normalizable lambda terms. Secondly, the intersection type operator is a meta-level operator, that is, there is no direct logical counterpart in the Curry-Howard isomorphism sense. In particular, its meta-level nature implies that it does not correspond to the intuitionistic conjunction. The intersection type system is naturally a type inference system (system a la Curry), but the meta-level nature of the intersection operator does not allow to easily design an equivalent typed system (system a la Church). There are many proposals in the literature to design such systems, but none of them gives an entirely satisfactory answer to the problem. In this paper, we will review the main results in the literature both on the logical interpretation of intersection types and on proposed typed lambda calculi. The core of this paper is a new proposal for a true intersection typed lambda calculus, without any meta-level notion. Namely, any typable term (in the intersection type inference) has a corresponding typed term (which is the same as the untyped term by erasing the type decorations and the typed term constructors) with the same type, and vice versa. The main idea is to introduce a relevant parallel term constructor which corresponds to the intersection type constructor, in such a way that terms in parallel share the same resources, that is, the same context of free typed variables. Three rules allow us to generate all typed terms. The first two rules, Application and Lambda-abstraction, are performed on all the components of a parallel term in a synchronized way. Finally, via the third rule of Local Renaming, once a free typed variable is bounded by lambda-abstraction, each of the terms in parallel can do its local renaming, with type refinement, of that particular resource. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "A typed lambda calculus with intersection types", "paper_id": "WOS:000256461400008"}