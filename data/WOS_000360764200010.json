{"auto_keywords": [{"score": 0.03188855882134159, "phrase": "domain_experts"}, {"score": 0.015719716506582538, "phrase": "model_scalability"}, {"score": 0.015502027791888846, "phrase": "software_development"}, {"score": 0.010868283273979795, "phrase": "scaling_tasks"}, {"score": 0.010687049704919738, "phrase": "model_transformation_languages"}, {"score": 0.009633706689162736, "phrase": "complex_model_transformation_language"}, {"score": 0.004774393182616134, "phrase": "important_aspect"}, {"score": 0.004641641877674012, "phrase": "software_models"}, {"score": 0.004576650486542461, "phrase": "design_forces"}, {"score": 0.004487181594905386, "phrase": "system_features"}, {"score": 0.0043994539995390325, "phrase": "additional_users"}, {"score": 0.0042891660310426976, "phrase": "base_model"}, {"score": 0.004205293427426673, "phrase": "base_model_elements"}, {"score": 0.00407678138571414, "phrase": "larger_and_more_complex_model"}, {"score": 0.004042416569959828, "phrase": "new_design_requirements"}, {"score": 0.003974550062454033, "phrase": "modeling_tools"}, {"score": 0.003863951933933301, "phrase": "different_purposes"}, {"score": 0.0036621924435239358, "phrase": "basic_point-and-click_editing_operations"}, {"score": 0.003590535800280948, "phrase": "manual_model_scaling"}, {"score": 0.0033742996685636687, "phrase": "scaling_process"}, {"score": 0.0033552975070941416, "phrase": "entirely_manual_operations"}, {"score": 0.0032343566763490916, "phrase": "model_transformation_rules"}, {"score": 0.003198025698778023, "phrase": "model_transformation_language"}, {"score": 0.003135422638024283, "phrase": "great_deal"}, {"score": 0.0030567248254315827, "phrase": "metamodel_concepts"}, {"score": 0.0029134070107177915, "phrase": "negative_influence"}, {"score": 0.0027455847214706572, "phrase": "model_scalability_tasks"}, {"score": 0.0027070693607577, "phrase": "significant_domain_experience"}, {"score": 0.002661561550301736, "phrase": "demonstration-based_approach"}, {"score": 0.0026390945749753926, "phrase": "model_scaling"}, {"score": 0.002602069171788284, "phrase": "model_transformation"}, {"score": 0.0025011314534445707, "phrase": "concrete_model_instances"}, {"score": 0.002473016235563624, "phrase": "model_replication_processes"}, {"score": 0.0024383151463193793, "phrase": "user's_operations"}, {"score": 0.002417728087149033, "phrase": "inference_engine"}, {"score": 0.0023973144298770517, "phrase": "user's_demonstration"}, {"score": 0.0023770727209879885, "phrase": "model_transformation_patterns"}, {"score": 0.002147071287303209, "phrase": "model_instances"}, {"score": 0.0021049977753042253, "phrase": "underlying_abstract_metamodel_definitions"}], "paper_keywords": ["Model evolution", " Model scalability", " Model transformation by demonstration"], "paper_abstract": "An important aspect during software development is the ability to evolve and scale software models in order to handle design forces, such as enlarging and upgrading system features, or allocating more resources to handle additional users. Model scalability is the ability to refactor a base model, by adding or replicating the base model elements, connections or substructures, in order to build a larger and more complex model to satisfy new design requirements. Although a number of modeling tools have been developed to create and edit models for different purposes, mechanisms to scale models have not been well supported. In most situations, models are manually scaled using the basic point-and-click editing operations provided by the modeling environment. Manual model scaling is often tedious and error-prone, especially when the model to be scaled has hundreds or thousands of elements and the scaling process involves entirely manual operations. Although model scaling tasks can be automated by using model transformation languages, writing model transformation rules requires learning a model transformation language, as well as possessing a great deal of knowledge about the metamodel. Model transformation languages and metamodel concepts are often difficult for domain experts to understand. This requirement to learn a complex model transformation language exerts a negative influence on the usage of models by domain experts in software development. For instance, domain experts may be prevented from contributing to model scalability tasks from which they have significant domain experience. This paper presents a demonstration-based approach to automate model scaling. Instead of writing model transformation rules explicitly, users demonstrate how to scale models by directly editing the concrete model instances and simulate the model replication processes. By recording a user's operations, an inference engine analyzes the user's demonstration and generalizes model transformation patterns automatically, which can be reused to scale up other model instances. Using this approach, users are able to automate scaling tasks without learning a complex model transformation language. In addition, because the demonstration is performed on model instances, users are isolated from the underlying abstract metamodel definitions.", "paper_title": "A demonstration-based model transformation approach to automate model scalability", "paper_id": "WOS:000360764200010"}