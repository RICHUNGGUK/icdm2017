{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "resolution_calculus"}, {"score": 0.0043560464825349275, "phrase": "nontrivial_and_time_consuming_task"}, {"score": 0.003875424718379985, "phrase": "fault_detection"}, {"score": 0.0035648266669315943, "phrase": "fault_localization"}, {"score": 0.0032517484445814334, "phrase": "program's_behavior"}, {"score": 0.0031712256091350316, "phrase": "correctness_assumptions"}, {"score": 0.003092690568543981, "phrase": "fault_localization_task"}, {"score": 0.002966084234963723, "phrase": "consistent_assumptions"}, {"score": 0.0028209599545587745, "phrase": "non-monotonic_reasoning_process"}, {"score": 0.002530359917257626, "phrase": "previous_approach"}, {"score": 0.0023665766694993535, "phrase": "trace_analysis"}, {"score": 0.0021049977753042253, "phrase": "search_assumptions"}], "paper_keywords": [""], "paper_abstract": "Detecting and localizing a fault within a program is a nontrivial and time consuming task. Most of the efforts spent for automating the task have focused on fault detection. In this paper we shift the focus on fault localization. We introduce a resolution calculus that allows for representing the program's behavior based on correctness assumptions. The fault localization task is reduced to finding consistent assumptions which are represented as a non-monotonic reasoning process where efficient algorithms exist. Finally, we compare our approach with a previous approach to fault localization that is based on trace analysis. As a result we can show that our approach is less sensitive to search assumptions.", "paper_title": "Fundamentals of debugging using a resolution calculus", "paper_id": "WOS:000236901100021"}