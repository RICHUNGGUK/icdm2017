{"auto_keywords": [{"score": 0.004736820055728928, "phrase": "generic_programming"}, {"score": 0.00447316895126645, "phrase": "overloaded_functions"}, {"score": 0.003924121879214595, "phrase": "different_approaches"}, {"score": 0.0038603905208013482, "phrase": "datatype-generic_programming"}, {"score": 0.0036753171449945654, "phrase": "design_space"}, {"score": 0.003414153126809511, "phrase": "\"scrap_your_boilerplate\"_approach"}, {"score": 0.003223883109446599, "phrase": "three-dimensional_design_space"}, {"score": 0.0022477377970612847, "phrase": "different_overloading_mechanisms"}, {"score": 0.0022111720236287547, "phrase": "type_representations"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Generic programming", " Type classes", " Haskell 98", " Language design"], "paper_abstract": "Support for generic programming consists of three essential ingredients: support for overloaded functions, a run-time type representation, and a generic view on data. Different approaches to datatype-generic programming occupy different points in this design space. In this article, we revisit the \"Scrap your boilerplate\" approach and identify its location within the three-dimensional design space. The characteristic features of \"Scrap your boilerplate\" are its two generic views, the 'spine' view for consuming and transforming data, and the 'type-spine' view for producing data. We show how to combine these views with different overloading mechanisms and type representations. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Generic programming in 3D", "paper_id": "WOS:000266671700006"}