{"auto_keywords": [{"score": 0.026859818135756067, "phrase": "flat_system"}, {"score": 0.00481495049065317, "phrase": "basic_formalisms"}, {"score": 0.004600596158672458, "phrase": "preorder_checking"}, {"score": 0.004424441580112395, "phrase": "flat_finite-state_system"}, {"score": 0.0039097293657870584, "phrase": "simulation_checking"}, {"score": 0.0038591802189770737, "phrase": "exptime"}, {"score": 0.003615845091983304, "phrase": "non-flat_implementation"}, {"score": 0.0033222630615013737, "phrase": "parallel_components"}, {"score": 0.003012919635505122, "phrase": "considered_problems"}, {"score": 0.002974002462735747, "phrase": "pspace"}, {"score": 0.0026274936167233515, "phrase": "synchronous_non-flat_system"}, {"score": 0.0023826870912207324, "phrase": "trace_containment"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Behavioral preorders and equivalences", " Preorder and equivalence checking", " Non-flat finite-state systems", " Timed automata", " Computational complexity"], "paper_abstract": "We investigate the complexity of preorder checking when the specification is a flat finite-state system whereas the implementation is either a non-flat finite-state system or a standard timed automaton. In both cases, we show that simulation checking is EXPTIME-hard, and for the case of a non-flat implementation, the result holds even if there is no synchronization between the parallel components and their alphabets of actions are pairwise disjoint. Moreover, we show that the considered problems become PSPACE-complete when the specification is assumed to be deterministic. Additionally, we establish that comparing a synchronous non-flat system with no hiding and a flat system is PSPACE-hard for any relation between trace containment and bisimulation equivalence, even if the flat system is assumed to be fixed. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Hardness of preorder checking for basic formalisms", "paper_id": "WOS:000296940300001"}