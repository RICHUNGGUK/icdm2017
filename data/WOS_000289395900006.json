{"auto_keywords": [{"score": 0.03843856552198327, "phrase": "input_points"}, {"score": 0.03687202483753312, "phrase": "surface_patches"}, {"score": 0.00481495049065317, "phrase": "efficient_implementation"}, {"score": 0.0045726187330434025, "phrase": "multi-layer_peeling_algorithm"}, {"score": 0.004379977556546879, "phrase": "memory_and_time_efficient_surface_reconstruction_algorithm"}, {"score": 0.004088421020408183, "phrase": "normal_information"}, {"score": 0.003816197777388722, "phrase": "main_memory"}, {"score": 0.0032398798149196432, "phrase": "multiple_layers"}, {"score": 0.003050166508545763, "phrase": "out-of-core_octree"}, {"score": 0.0029214769181390653, "phrase": "memory_usage"}, {"score": 0.0025449518236394103, "phrase": "spatial_coherence"}, {"score": 0.0023346234464901978, "phrase": "large_point_sets"}, {"score": 0.002236055625099805, "phrase": "good_outputs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Surface reconstruction", " Layer-peeling", " Large data", " Octree"], "paper_abstract": "We present a memory and time efficient surface reconstruction algorithm for large sets of points, without normal information, that may not fit within the main memory. Our algorithm treats the input points as forming layers of surface patches, and then performs reconstruction by working on multiple layers of surface patches concurrently based on an out-of-core octree. Additionally, the memory usage of the algorithm can be pre-estimated through a few simple quantities in relation to the spatial coherence of the input points. Tests on the algorithm with large point sets verify that it produces good outputs too. (C) 2010 Elsevier Ltd. All rights reserved.", "paper_title": "Efficient implementation of point set reconstruction by multi-layer peeling algorithm", "paper_id": "WOS:000289395900006"}