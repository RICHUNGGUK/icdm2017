{"auto_keywords": [{"score": 0.047302204764271674, "phrase": "lock-free_queues"}, {"score": 0.00481495049065317, "phrase": "lock-free_and_combining_techniques"}, {"score": 0.004749106104067268, "phrase": "practical_and_scalable_fifo_queue"}, {"score": 0.004234129588974058, "phrase": "contention_level"}, {"score": 0.004195418010131832, "phrase": "parallel_execution"}, {"score": 0.004119049028319832, "phrase": "-based_queues"}, {"score": 0.004025531820226182, "phrase": "single-threaded_sequential_combiner_executions"}, {"score": 0.0037747835341722636, "phrase": "different_approach"}, {"score": 0.0036052633308076933, "phrase": "practical_and_scalable_concurrent_queue_algorithm"}, {"score": 0.003459191419478298, "phrase": "high_scalability"}, {"score": 0.0034118234596993836, "phrase": "parameter_tuning"}, {"score": 0.003213920601037463, "phrase": "scott_queue"}, {"score": 0.002711109302199029, "phrase": "life_cycle"}, {"score": 0.0025420267431501367, "phrase": "huge_advantages"}, {"score": 0.002518746501941657, "phrase": "prior_work"}, {"score": 0.0024956789310376635, "phrase": "efficient_implementation"}, {"score": 0.0024501740852758505, "phrase": "dedicated_memory_management_schemes"}, {"score": 0.0023079225317714815, "phrase": "performance_bottleneck"}, {"score": 0.002214297250267208, "phrase": "synchronized_life_cycle"}, {"score": 0.0021441057555396013, "phrase": "application_developers"}, {"score": 0.0021049977753042253, "phrase": "memory_management"}], "paper_keywords": ["Concurrent queue", " lock-free queue", " combining-based queue", " memory reclamation", " compare-and-swap", " swap"], "paper_abstract": "Concurrent FIFO queues can be generally classified into lock-free queues and combining-based queues. Lock-free queues require manual parameter tuning to control the contention level of parallel execution, while combining-based queues encounter a bottleneck of single-threaded sequential combiner executions at a high concurrency level. In this paper, we introduce a different approach using both lock-free techniques and combining techniques synergistically to design a practical and scalable concurrent queue algorithm. As a result, we have achieved high scalability without any parameter tuning: on an 80-thread average throughput in our experimental results, our queue algorithm outperforms the most widely used Michael and Scott queue by 14.3 times, the best-performing combining-based queue by 1.6 times, and the best performing x86-dependent lock-free queue by 1.7 percent. In addition, we designed our algorithm in such a way that the life cycle of a node is the same as that of its element. This has huge advantages over prior work: efficient implementation is possible without dedicated memory management schemes, which are supported only in some languages, may cause a performance bottleneck, or are patented. Moreover, the synchronized life cycle between an element and its node enables application developers to further optimize memory management.", "paper_title": "Integrating Lock-Free and Combining Techniques for a Practical and Scalable FIFO Queue", "paper_id": "WOS:000356138700011"}