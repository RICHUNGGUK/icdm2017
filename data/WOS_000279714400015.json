{"auto_keywords": [{"score": 0.046448599314105624, "phrase": "context_switching"}, {"score": 0.00805031561257911, "phrase": "thread_contexts"}, {"score": 0.006594296432978715, "phrase": "first-class_code_pointers"}, {"score": 0.005747140320081177, "phrase": "conventional_implementation"}, {"score": 0.00481495049065317, "phrase": "thread_context_switching"}, {"score": 0.004767826806287385, "phrase": "recent_efforts"}, {"score": 0.004721162131188487, "phrase": "foundational_certified_software_systems"}, {"score": 0.004598933498016774, "phrase": "thread_context"}, {"score": 0.004406994912939125, "phrase": "single_logic_system"}, {"score": 0.0042508289538799905, "phrase": "different_abstraction_levels"}, {"score": 0.004181678027929924, "phrase": "heavyweight_extensions"}, {"score": 0.004140726362519362, "phrase": "logic_system"}, {"score": 0.003865033938931324, "phrase": "simpler_and_more_natural_specifications"}, {"score": 0.003423042581201533, "phrase": "abstraction_work"}, {"score": 0.0033233797886807375, "phrase": "second_approach"}, {"score": 0.0032372213689015844, "phrase": "clear_abstraction"}, {"score": 0.003132647746420474, "phrase": "hold_pointers"}, {"score": 0.0030115953761477503, "phrase": "program_specifications"}, {"score": 0.0028762499230524812, "phrase": "opaque_structures"}, {"score": 0.00266693888510356, "phrase": "direct_support"}, {"score": 0.0021825034787117986, "phrase": "higher_abstraction_level"}, {"score": 0.0021049977753042253, "phrase": "global_program_invariant"}], "paper_keywords": ["program verification", " context switching", " proof-carrying code", " program safety"], "paper_abstract": "With recent efforts to build foundational certified software systems, two different approaches have been proposed to certify thread context switching. One is to certify both threads and context switching in a single logic system, and the other certifies threads and context switching at different abstraction levels. The former requires heavyweight extensions in the logic system to support first-class code pointers and recursive specifications. Moreover, the specification for context switching is very complex. The latter supports simpler and more natural specifications, but it requires the contexts of threads to be abstracted away completely when threads are certified. As a result, the conventional implementation of context switching used in most systems needs to be revised to make the abstraction work. In this paper, we extend the second approach to certify the conventional implementation, where the clear abstraction for threads is unavailable since both threads and context switching hold pointers of thread contexts. To solve this problem, we allow the program specifications for threads to refer to pointers of thread contexts. Thread contexts are treated as opaque structures, whose contents are unspecified and should never be accessed by the code of threads. Therefore, the advantage of avoiding the direct support of first-class code pointers is still preserved in our method. Besides, our new approach is also more lightweight. Instead of using two different logics to certify threads and context switching, we employ only one program logic with two different specifications for the context switching. One is used to certify the implementation itself, and the more abstract one is used as an interface between threads and context switching at a higher abstraction level. The consistency between the two specifications are enforced by the global program invariant.", "paper_title": "Certification of Thread Context Switching", "paper_id": "WOS:000279714400015"}