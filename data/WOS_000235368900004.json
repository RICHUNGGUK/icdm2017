{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "arora"}, {"score": 0.012093043644318778, "phrase": "abp"}, {"score": 0.005699654735970251, "phrase": "plaxton"}, {"score": 0.004773904938276846, "phrase": "blumofe"}, {"score": 0.00443878620915958, "phrase": "multiprocessor_load"}, {"score": 0.004216434794603139, "phrase": "highly_efficient_scheme"}, {"score": 0.00409188863874203, "phrase": "array-based_double-ended_queues"}, {"score": 0.004005176784823524, "phrase": "low_cost_synchronization"}, {"score": 0.003971006689166329, "phrase": "local_and_stealing_processes"}, {"score": 0.0038868464660354626, "phrase": "algorithm's_synchronization_protocol"}, {"score": 0.0037558704408683905, "phrase": "fixed_size_arrays"}, {"score": 0.003582928547553209, "phrase": "multiprogrammed_environments"}, {"score": 0.003432604816716035, "phrase": "significant_drawback"}, {"score": 0.003359816816853762, "phrase": "memory_inefficiency"}, {"score": 0.0030969799559421806, "phrase": "hard-to-predict_level"}, {"score": 0.00296698375549856, "phrase": "expensive_and_application-specific_overflow_mechanism"}, {"score": 0.0028916124463906983, "phrase": "first_dynamic_memory_work-stealing_algorithm"}, {"score": 0.0028060889647071787, "phrase": "novel_way"}, {"score": 0.0027347937102326285, "phrase": "dynamic-sized_work"}, {"score": 0.0026767629720554397, "phrase": "synchronization_conflicts"}, {"score": 0.002477837342313456, "phrase": "original_abp_algorithm"}, {"score": 0.002404522326122611, "phrase": "new_algorithm"}, {"score": 0.002353483216544667, "phrase": "memory_efficiency"}, {"score": 0.0022936610196951962, "phrase": "observable_performance_penalty"}, {"score": 0.0021049977753042253, "phrase": "application-specific_overflow_mechanisms"}], "paper_keywords": ["concurrent programming", " load balancing", " work stealing", " lock-free", " data structures"], "paper_abstract": "The non-blocking work-stealing algorithm of Arora, Blumofe, and Plaxton (hencheforth ABP work-stealing) is on its way to becoming the multiprocessor load balancing technology of choice in both industry and academia. This highly efficient scheme is based on a collection of array-based double-ended queues (deques) with low cost synchronization among local and stealing processes. Unfortunately, the algorithm's synchronization protocol is strongly based on the use of fixed size arrays, which are prone to overflows, especially in the multiprogrammed environments for which they are designed. This is a significant drawback since, apart from memory inefficiency, it means that the size of the deque must be tailored to accommodate the effects of the hard-to-predict level of multiprogramming, and the implementation must include an expensive and application-specific overflow mechanism. This paper presents the first dynamic memory work-stealing algorithm. It is based on a novel way of building non-blocking dynamic-sized work stealing deques by detecting synchronization conflicts based on \"pointer-crossing\" rather than \"gaps between indexes\" as in the original ABP algorithm. As we show, the new algorithm dramatically increases robustness and memory efficiency, while causing applications no observable performance penalty. We therefore believe it can replace array-based ABP work stealing deques, eliminating the need for application-specific overflow mechanisms.", "paper_title": "A dynamic-sized nonblocking work stealing deque", "paper_id": "WOS:000235368900004"}