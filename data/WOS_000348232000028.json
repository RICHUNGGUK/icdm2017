{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "energy-efficient_mapping"}, {"score": 0.0047555023078686386, "phrase": "moldable_streaming_tasks"}, {"score": 0.004726052718910578, "phrase": "manycore_systems"}, {"score": 0.004682218325765133, "phrase": "effectively_massively_parallel_architectures"}, {"score": 0.004638788604042707, "phrase": "major_challenge"}, {"score": 0.004610058444728656, "phrase": "stream_programming"}, {"score": 0.004455179735772526, "phrase": "energy-optimal_code"}, {"score": 0.004332322079100859, "phrase": "parallelizable_or_moldable_tasks"}, {"score": 0.0042921238100956174, "phrase": "generic_manycore_processor"}, {"score": 0.004265531504874966, "phrase": "dynamic_discrete_frequency"}, {"score": 0.004225950334493496, "phrase": "streaming_task_collections"}, {"score": 0.004186734905572505, "phrase": "classical_task_sets"}, {"score": 0.003910016472705627, "phrase": "user_level"}, {"score": 0.0038737214010638745, "phrase": "data-driven_way"}, {"score": 0.003743487506598038, "phrase": "intermediate_results"}, {"score": 0.0036288825833675127, "phrase": "pipelined_task_graph"}, {"score": 0.00353972102514233, "phrase": "crown_scheduling"}, {"score": 0.0034634973175137486, "phrase": "combined_optimization"}, {"score": 0.0034420211080526094, "phrase": "resource_allocation"}, {"score": 0.0033262524445013303, "phrase": "task_collections"}, {"score": 0.0032749212355657215, "phrase": "energy_efficiency"}, {"score": 0.0032445022888094636, "phrase": "throughput_constraint"}, {"score": 0.0031944286166257466, "phrase": "optimal_offline_algorithms"}, {"score": 0.0031746155143471725, "phrase": "separate_and_integrated_crown_scheduling"}, {"score": 0.003145125312514813, "phrase": "integer_linear_programming"}, {"score": 0.0030678130623191372, "phrase": "restricting_assumption"}, {"score": 0.003048782877550259, "phrase": "speedup_behavior"}, {"score": 0.0030017207229983385, "phrase": "fast_heuristic_longest_task"}, {"score": 0.0029830992938695033, "phrase": "lowest_group"}, {"score": 0.0029007322268096276, "phrase": "lpt"}, {"score": 0.0028470613150369823, "phrase": "load-balanced_mapping"}, {"score": 0.0027869030538370445, "phrase": "height"}, {"score": 0.002759823989317719, "phrase": "crown_frequency"}, {"score": 0.002700348931172875, "phrase": "feedback_loop_heuristics"}, {"score": 0.002675252546913683, "phrase": "binary_search"}, {"score": 0.0026586509901026126, "phrase": "simulated_annealing"}, {"score": 0.002633941112839883, "phrase": "crown_allocation"}, {"score": 0.0025932659540059875, "phrase": "ilp_models"}, {"score": 0.0025691622090542325, "phrase": "generic_manycore_architecture"}, {"score": 0.002521623057264411, "phrase": "small_and_medium-sized_streaming_task_collections"}, {"score": 0.00231111848128734, "phrase": "makespan_and_energy_consumption"}, {"score": 0.0022472527731744974, "phrase": "phase-separated_crown_scheduling_technique"}, {"score": 0.0021049977753042253, "phrase": "better_solutions"}], "paper_keywords": ["Design", " Algorithms", " Performance", " Multicore", " manycore", " parallel energy", " scheduling", " mapping", " frequency scaling", " streaming"], "paper_abstract": "Exploiting effectively massively parallel architectures is a major challenge that stream programming can help facilitate. We investigate the problem of generating energy-optimal code for a collection of streaming tasks that include parallelizable or moldable tasks on a generic manycore processor with dynamic discrete frequency scaling. Streaming task collections differ from classical task sets in that all tasks are running concurrently, so that cores typically run several tasks that are scheduled round-robin at user level in a data-driven way. A stream of data flows through the tasks and intermediate results may be forwarded to other tasks, as in a pipelined task graph. In this article, we consider crown scheduling, a novel technique for the combined optimization of resource allocation, mapping, and discrete voltage/frequency scaling for moldable streaming task collections in order to optimize energy efficiency given a throughput constraint. We first present optimal offline algorithms for separate and integrated crown scheduling based on integer linear programming (ILP). We make no restricting assumption about speedup behavior. We introduce the fast heuristic Longest Task, Lowest Group (LTLG) as a generalization of the Longest Processing Time (LPT) algorithm to achieve a load-balanced mapping of parallel tasks, and the Height heuristic for crown frequency scaling. We use them in feedback loop heuristics based on binary search and simulated annealing to optimize crown allocation. Our experimental evaluation of the ILP models for a generic manycore architecture shows that at least for small and medium-sized streaming task collections even the integrated variant of crown scheduling can be solved to optimality by a state-of-the-art ILP solver within a few seconds. Our heuristics produce makespan and energy consumption close to optimality within the limits of the phase-separated crown scheduling technique and the crown structure. Their optimization time is longer than the one of other algorithms we test, but our heuristics consistently produce better solutions.", "paper_title": "Fast Crown Scheduling Heuristics for Energy-Efficient Mapping and Scaling of Moldable Streaming Tasks on Manycore Systems", "paper_id": "WOS:000348232000028"}