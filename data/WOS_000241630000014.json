{"auto_keywords": [{"score": 0.04882655221850924, "phrase": "recoder"}, {"score": 0.01571972112494028, "phrase": "compost"}, {"score": 0.01558361564481007, "phrase": "compass"}, {"score": 0.01504741982991026, "phrase": "invasive_software_composition"}, {"score": 0.010690574406026844, "phrase": "recoder_framework"}, {"score": 0.004506171772318298, "phrase": "compass_aspect-oriented_connectors"}, {"score": 0.004311352359122141, "phrase": "program_evolution_and_bridge_architectural_mismatches"}, {"score": 0.0038602215057106917, "phrase": "program_analysis"}, {"score": 0.0036932254391253134, "phrase": "basic_tool"}, {"score": 0.0036445446531633368, "phrase": "sophisticated_source_code_analyses"}, {"score": 0.0035648266669315943, "phrase": "common_transformations"}, {"score": 0.0034868462688262864, "phrase": "java_meta_programs"}, {"score": 0.00344087639309216, "phrase": "necessary_component"}, {"score": 0.0031774686451753477, "phrase": "custom_transformations"}, {"score": 0.0030264946886983833, "phrase": "glue_code"}, {"score": 0.0028826733506942554, "phrase": "comfortable_scripting_language"}, {"score": 0.002807118943000936, "phrase": "scripting_language"}, {"score": 0.00278237555651743, "phrase": "declarative_specifications"}, {"score": 0.0027456676902333304, "phrase": "program_points"}, {"score": 0.0026267609106294817, "phrase": "imperative_specifications"}, {"score": 0.002512990657100351, "phrase": "bridging_interaction_mismatches"}, {"score": 0.002490833392316362, "phrase": "software_components"}, {"score": 0.002447101794397243, "phrase": "architectural_elements"}, {"score": 0.002382936364692606, "phrase": "aspect-oriented_connectors"}, {"score": 0.002361923085067681, "phrase": "source_code_transformations"}, {"score": 0.0022696277881969896, "phrase": "general_model"}, {"score": 0.0021809311689473493, "phrase": "compass_model"}, {"score": 0.0021049977753042253, "phrase": "join_points"}], "paper_keywords": [""], "paper_abstract": "Program analyses and transformations are means to support program evolution and bridge architectural mismatches in component composition. The Program Structures Group at the University of Karlsruhe and the FZI Karlsruhe; that we are or have been members of, have developed a suite of program analysis and transformation tools to attack these problems. The basic tool Recoder offers sophisticated source code analyses and a library of common transformations in the form of Java meta programs to perform necessary component and interaction adapations. This library can be extended by the Recoder framework that offers means for implementing custom transformations. A transformation can also be a generator to produce glue code, for example. Inject/J uses Recoder and offers a comfortable scripting language for implementing transformations. The scripting language combines declarative specifications of the program points, where the transformation should be applied, with imperative specifications of the transformation itself. COMPASS is focused on bridging interaction mismatches among software components. It introduces architectural elements like components, ports and aspect-oriented connectors as source code transformations based on the Recoder framework. COMPOST defines the general model of invasive software composition, where the ports of the COMPASS model are just one kind of hooks. Hooks are join points, i.e. part of a component that may be extended or replaced.", "paper_title": "The COMPOST, COMPASS, Inject/J and RECODER tool suite for invasive software composition: Invasive composition with COMPASS aspect-oriented connectors", "paper_id": "WOS:000241630000014"}