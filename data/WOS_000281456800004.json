{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "longest_increasing_subsequence"}, {"score": 0.003865826699096508, "phrase": "increasing_subsequence"}, {"score": 0.0032259472087775138, "phrase": "ram_model"}, {"score": 0.0027622407190589326, "phrase": "new_bound"}, {"score": 0.002709161672473817, "phrase": "open_question"}, {"score": 0.0025892330566358503, "phrase": "longest_common_subsequence"}, {"score": 0.0024586427394152196, "phrase": "lis_computation"}, {"score": 0.002319566486828135, "phrase": "r_pairs"}, {"score": 0.002202547013259953, "phrase": "length_k._crown_copyright"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Design and analysis of algorithms", " Longest increasing subsequence", " Longest common subsequence", " Data structures", " Priority queue", " Dynamic programming"], "paper_abstract": "We consider the complexity of computing a longest increasing subsequence (LIS) parameterised by the length of the output. Namely, we show that the maximal length k of an increasing subsequence of a permutation of the set of integers {1, 2, ..., n) can be computed in time O(n log log k) in the RAM model, improving the previous 30-year bound of O(n log k). The algorithm also improves on the previous O(n log log n) bound. The optimality of the new bound is an open question. Reducing the computation of a longest common subsequence (LCS) between two strings to an LIS computation leads to a simple O(n log log n)-time algorithm for two sequences having r pairs of matching symbols and an LCS of length k. Crown Copyright (C) 2010 Published by Elsevier Inc. All rights reserved.", "paper_title": "Fast computation of a longest increasing subsequence and application", "paper_id": "WOS:000281456800004"}