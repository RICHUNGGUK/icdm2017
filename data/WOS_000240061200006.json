{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "memory_reuse"}, {"score": 0.004681971826924847, "phrase": "chr._two_constraint_handling_rules_compiler_optimizations"}, {"score": 0.00436530211426514, "phrase": "memory_footprint"}, {"score": 0.0042446888127531945, "phrase": "chr_programs"}, {"score": 0.0036382660173943393, "phrase": "suspension_terms"}, {"score": 0.0034884152484429207, "phrase": "internal_chr_constraint_representation"}, {"score": 0.003162252895465901, "phrase": "constraint_removal"}, {"score": 0.0023551955270737215, "phrase": "k.u.leuven_chr_system"}, {"score": 0.002289993730291136, "phrase": "significant_memory_savings"}, {"score": 0.0021049977753042253, "phrase": "classical_and_well-known_benchmarks"}], "paper_keywords": [""], "paper_abstract": "Two Constraint Handling Rules compiler optimizations that drastically reduce the memory footprint of CHR programs are introduced. The reduction is the result of reusing suspension terms, the internal CHR constraint representation, and avoiding the overhead of constraint removal followed by insertion. The optimizations are defined formally and their correctness is proved. Both optimizations were implemented in the K.U.Leuven CHR system. Significant memory savings and speedups were measured on classical and well-known benchmarks.", "paper_title": "Memory reuse for CHR", "paper_id": "WOS:000240061200006"}