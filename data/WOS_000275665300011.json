{"auto_keywords": [{"score": 0.04407953898448545, "phrase": "planning_domain"}, {"score": 0.01903156191639501, "phrase": "safe_permissive_plan"}, {"score": 0.010612387000973441, "phrase": "partial_observability"}, {"score": 0.009148059196468357, "phrase": "safety_property"}, {"score": 0.008955903554649461, "phrase": "reachability_goal"}, {"score": 0.006650673294893383, "phrase": "safe_plan"}, {"score": 0.004763895422211728, "phrase": "traditional_planning"}, {"score": 0.004713379149462482, "phrase": "reachability_goals"}, {"score": 0.004663396040465122, "phrase": "full_observability"}, {"score": 0.004444921827311577, "phrase": "novel_solution"}, {"score": 0.0043511221096418475, "phrase": "reachability_planning"}, {"score": 0.0031930184711888867, "phrase": "active_learning"}, {"score": 0.003159106878239524, "phrase": "regular_languages"}, {"score": 0.0031255543155487234, "phrase": "symbolic_model_checking"}, {"score": 0.0030758904011907533, "phrase": "planning_method"}, {"score": 0.002884979280317279, "phrase": "efficient_active_learning_algorithm"}, {"score": 0.0023675986784123656, "phrase": "safe_string"}, {"score": 0.002220551141101661, "phrase": "proposed_technique"}, {"score": 0.0021276181317652163, "phrase": "safe_permissive_plans"}], "paper_keywords": ["Active learning", " automated planning", " partial observability", " symbolic model checking"], "paper_abstract": "Traditional planning assumes reachability goals and/or full observability. In this paper, we propose a novel solution for safety and reachability planning with partial observability. Given a planning domain, a safety property, and a reachability goal, we automatically learn a safe permissive plan to guide the planning domain so that the safety property is not violated and that can force the planning domain to eventually reach states that satisfy the reachability goal, regardless of how the planning domain behaves. Our technique is based on the active learning of regular languages and symbolic model checking. The planning method first learns a safe plan using the L* algorithm, which is an efficient active learning algorithm for regular languages. We then check whether the safe plan learned is also permissive by Alternating-time Temporal Logic (ATL) model checking. If the plan is permissive, it is indeed a safe permissive plan. Otherwise, we identify and add a safe string to converge a safe permissive plan. We describe an implementation of the proposed technique and demonstrate that our tool can efficiently construct safe permissive plans for four sets of examples.", "paper_title": "Active Learning of Plans for Safety and Reachability Goals With Partial Observability", "paper_id": "WOS:000275665300011"}