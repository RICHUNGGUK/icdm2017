{"auto_keywords": [{"score": 0.04747057536702851, "phrase": "signal_functions"}, {"score": 0.00481495049065317, "phrase": "settable_and_non-interfering_signal_functions"}, {"score": 0.004783358523770212, "phrase": "frp."}, {"score": 0.00446384610114756, "phrase": "continuous_input_signals"}, {"score": 0.004434547543497673, "phrase": "continuous_output_signals"}, {"score": 0.00390000531646629, "phrase": "discrete_changes"}, {"score": 0.0038743931383378558, "phrase": "program_behavior"}, {"score": 0.0037119497772861165, "phrase": "higher-order_notion"}, {"score": 0.0035097199745427496, "phrase": "yampa"}, {"score": 0.0032858160838749196, "phrase": "program_optimization"}, {"score": 0.003242773742700232, "phrase": "causal_commutative_arrows"}, {"score": 0.0029960701622407924, "phrase": "just-in-time_compilation"}, {"score": 0.0026085220231994955, "phrase": "noninterference_law"}, {"score": 0.0025405829212597586, "phrase": "arrowized_frp_program"}, {"score": 0.002482585701725093, "phrase": "statically_limited_bounds"}, {"score": 0.002433926157079375, "phrase": "unused_streams"}, {"score": 0.002362715032126801, "phrase": "settable_signal_function"}, {"score": 0.0023317365065820554, "phrase": "signal_function"}, {"score": 0.0022560515732199062, "phrase": "previous_state"}, {"score": 0.0022118223311537954, "phrase": "canonical_uses"}, {"score": 0.0021972723598946446, "phrase": "higherorder_switchers"}, {"score": 0.00215419297939962, "phrase": "suitable_first-order_design"}, {"score": 0.0021189380172266454, "phrase": "broader_range"}, {"score": 0.0021049977753042253, "phrase": "static_optimizations"}], "paper_keywords": ["Functional Reactive Programming", " Arrows", " Arrow-Choice", " Switch"], "paper_abstract": "Functional Reactive Programming (FRP) provides a method for programming continuous, reactive systems by utilizing signal functions that, abstractly, transform continuous input signals into continuous output signals. These signals may also be streams of events, and indeed, by allowing signal functions themselves to be the values carried by these events (in essence, signals of signal functions), one can conveniently make discrete changes in program behavior by \"switching\" into and out of these signal functions. This higher-order notion of switching is common among many FRP systems, in particular those based on arrows, such as Yampa. Although convenient, the power of switching is often an overkill and can pose problems for certain types of program optimization (such as causal commutative arrows [14]), as it causes the structure of the program to change dynamically at run-time. Without a notion of just-in-time compilation or related idea, which itself is beset with problems, such optimizations are not possible at compile time. This paper introduces two new ideas that obviate, in a predominance of cases, the need for switching. The first is a noninterference law for arrows with choice that allows an arrowized FRP program to dynamically alter its own structure (within statically limited bounds) as well as abandon unused streams. The other idea is a notion of a settable signal function that allows a signal function to capture its present state and later be restarted from some previous state. With these two features, canonical uses of higherorder switchers can be replaced with a suitable first-order design, thus enabling a broader range of static optimizations.", "paper_title": "Settable and Non-Interfering Signal Functions for FRP", "paper_id": "WOS:000349143000019"}