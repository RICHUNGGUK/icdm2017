{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "sequential_morphological_filters"}, {"score": 0.004189337956225294, "phrase": "size_distributions"}, {"score": 0.0041170581247889654, "phrase": "sequential_filters"}, {"score": 0.003941746077126688, "phrase": "efficient_implementation"}, {"score": 0.0035507457285983268, "phrase": "time-delayed_data"}, {"score": 0.003459191419478298, "phrase": "recent_algorithm"}, {"score": 0.0027822459052173113, "phrase": "dedicated_hardware"}, {"score": 0.0027104531025934865, "phrase": "rectangular_structuring_elements"}, {"score": 0.002663620639539737, "phrase": "programmable_size"}, {"score": 0.0023990982005125763, "phrase": "low_latency_and_memory_requirements"}, {"score": 0.0021420294823879292, "phrase": "long_concatenations"}, {"score": 0.0021049977753042253, "phrase": "high-resolution_images"}], "paper_keywords": ["Mathematical morphology", " Serial filters", " Real-time implementation", " Dedicated hardware"], "paper_abstract": "Many useful morphological filters are built as more or less long concatenations of erosions and dilations: openings, closings, size distributions, sequential filters, etc. An efficient implementation of these concatenations would allow all the sequentially concatenated operators run simultaneously, on the time-delayed data. A recent algorithm (see below) for the morphological dilation/erosion allows such inter-operator parallelism. This paper introduces an additional, intra-operator level of parallelism in this dilation/erosion algorithm. Realized in a dedicated hardware, for rectangular structuring elements with programmable size, such an implementation allows obtaining previously unachievable, real-time performances for these traditionally costly operators. Low latency and memory requirements are the main benefits when the performance is not deteriorated even for long concatenations or high-resolution images.", "paper_title": "Parallel implementation of sequential morphological filters", "paper_id": "WOS:000336034100003"}