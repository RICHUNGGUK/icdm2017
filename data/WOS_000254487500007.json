{"auto_keywords": [{"score": 0.03994932833136189, "phrase": "goodman"}, {"score": 0.00481495049065317, "phrase": "sequentially_consistent_programs"}, {"score": 0.004775335634705251, "phrase": "processor_consistent_platforms"}, {"score": 0.0046970764288494764, "phrase": "distributed_algorithms"}, {"score": 0.0046392209103157936, "phrase": "strong_memory_consistency_guarantees"}, {"score": 0.0045820747375409435, "phrase": "system_implementations"}, {"score": 0.0045443671106012405, "phrase": "weaker_guarantees"}, {"score": 0.004506968388996092, "phrase": "better_performance"}, {"score": 0.004236074477264561, "phrase": "sequential_consistency"}, {"score": 0.0041666157975446564, "phrase": "weaker_consistency_models"}, {"score": 0.0039323225960857956, "phrase": "shared_variables"}, {"score": 0.0038678251731669865, "phrase": "processor_consistency"}, {"score": 0.003560807940070886, "phrase": "mutual_exclusion"}, {"score": 0.0033465923623290034, "phrase": "arbitrary_programs"}, {"score": 0.0032780806856932423, "phrase": "sequentially_consistent_memory_semantics"}, {"score": 0.003190581563649244, "phrase": "vitanyi"}, {"score": 0.003171358146412577, "phrase": "pc-g_consistency_semantics"}, {"score": 0.003093595537995837, "phrase": "simple_program_transformation"}, {"score": 0.0029437270961011077, "phrase": "pc-g_memory_system"}, {"score": 0.0028243822059448266, "phrase": "even_a_substantial_generalization"}, {"score": 0.002709862658377861, "phrase": "even_a_very_restricted_class"}, {"score": 0.0025892330566358503, "phrase": "general_compiler"}, {"score": 0.002497046893915047, "phrase": "tromp"}, {"score": 0.002494531100339247, "phrase": "specific_n-process_programs"}, {"score": 0.0024232694434408093, "phrase": "special_case"}, {"score": 0.0022306602656266545, "phrase": "first_algorithm"}, {"score": 0.002184943946549964, "phrase": "weak_memory_system"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["memory consistency models", " processor consistency", " sequential consistency", " Test&Set", " wait-freedom", " program transformation"], "paper_abstract": "Designers of distributed algorithms typically assume strong memory consistency guarantees, but system implementations provide weaker guarantees for better performance and scalability. This motivates the study of how to implement programs designed for sequential consistency on platforms with weaker consistency models. Typically, such implementations are impossible using only read and write operations to shared variables. One variant of processor consistency originally proposed by Goodman and called here PC-G is an exception because it provides just enough consistency to implement mutual exclusion using only reads and writes. This paper investigates the existence of compilers to convert arbitrary programs that use shared read/write variables with sequentially consistent memory semantics, to programs that use read/write variables with PC-G consistency semantics. We first provide a simple program transformation, and prove that it correctly compiles any 2-process program to a PC-G memory system, while preserving wait-freedom. We next prove that even a substantial generalization of this transformation cannot be a compiler for even a very restricted class of 3-process programs. Even though our program transformation is not a general compiler for three or more processes, it does correctly transform some specific n-process programs. In particular, for the special case of the (necessarily randomized) Test&Set algorithm of Tromp and Vitanyi, our transformation extends to any number of processes, thus providing the first algorithm for expected wait-free Test&Set on any weak memory system, using only read/write variables. (C) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Implementing sequentially consistent programs on processor consistent platforms", "paper_id": "WOS:000254487500007"}