{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "functional_languages"}, {"score": 0.011082137791149605, "phrase": "live_objects"}, {"score": 0.01074473191916877, "phrase": "next_free_bit"}, {"score": 0.008358427643755034, "phrase": "proposed_method"}, {"score": 0.004716113134313215, "phrase": "memory_management_system"}, {"score": 0.004477765573115626, "phrase": "efficient_non-moving_garbage_collection_algorithm"}, {"score": 0.004340553321613485, "phrase": "performance_evaluation"}, {"score": 0.003967235882351874, "phrase": "allocation_sizes"}, {"score": 0.0037535816047183845, "phrase": "exceptionally_large_objects"}, {"score": 0.0037276938184125532, "phrase": "actual_space"}, {"score": 0.0035637052288771706, "phrase": "fixed_size_allocation_segments"}, {"score": 0.0035147084172295123, "phrase": "allocation_segment"}, {"score": 0.003201088113538101, "phrase": "meta-level_bitmaps"}, {"score": 0.0030814613175385672, "phrase": "current_bit_position"}, {"score": 0.0030496164547515565, "phrase": "bitmap_hierarchy"}, {"score": 0.002956037056206635, "phrase": "small_constant_time"}, {"score": 0.002845541839157798, "phrase": "worst_case"}, {"score": 0.0026276369627747896, "phrase": "generational_gc"}, {"score": 0.0026004698404274483, "phrase": "multiple_bitmaps"}, {"score": 0.0023847032316716503, "phrase": "functional_language"}, {"score": 0.002271773887265199, "phrase": "multiple_native_threads"}, {"score": 0.0022020103573658035, "phrase": "full-scale_standard_ml_compiler"}, {"score": 0.0021049977753042253, "phrase": "generational_copying_collector"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Non-moving Garbage Collection", " Bitmap Marking", " Generational Collectors", " SML#"], "paper_abstract": "Motivated by developing a memory management system that allows functional languages to seamlessly inter-operate with C, we propose an efficient non-moving garbage collection algorithm based on bitmap marking and report its implementation and performance evaluation. In our method, the heap consists of sub-heaps {H(i) vertical bar c <= i <= B} of exponentially increasing allocation sizes (H(i) for 2(i) bytes) and a special sub-heap for exceptionally large objects. Actual space for each sub-heap is dynamically allocated and reclaimed from a pool of fixed size allocation segments. In each allocation segment, the algorithm maintains a bitmap representing the set of live objects. Allocation is done by searching for the next free bit in the bitmap. By adding meta-level bitmaps that summarize the contents of bitmaps hierarchically and maintaining the current bit position in the bitmap hierarchy, the next free bit can be found in a small constant time for most cases, and in log(32)(segmentSize) time in the worst case on a 32-bit architecture. The collection is done by clearing the bitmaps and tracing live objects. The algorithm can be extended to generational GC by maintaining multiple bitmaps for the same heap space. The proposed method does not require compaction and objects are not moved at all. This property is significant for a functional language to inter-operate with C, and it should also be beneficial in supporting multiple native threads. The proposed method has been implemented in a full-scale Standard ML compiler. Our benchmark tests show that our non-moving collector performs as efficiently as a generational copying collector designed for functional languages.", "paper_title": "An Efficient Non-Moving Garbage Collector for Functional Languages", "paper_id": "WOS:000297632700020"}