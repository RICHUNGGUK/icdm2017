{"auto_keywords": [{"score": 0.050078231442313555, "phrase": "xml_data"}, {"score": 0.048756712287817174, "phrase": "xpath"}, {"score": 0.015375120296714648, "phrase": "structural_patterns"}, {"score": 0.004788057423546704, "phrase": "xml_query_languages"}, {"score": 0.004514550005798812, "phrase": "tree-pattern_queries-tpqs"}, {"score": 0.004389831166704716, "phrase": "xml_tree"}, {"score": 0.004353088808931991, "phrase": "key_operation"}, {"score": 0.004328764169068557, "phrase": "xml_query_evaluation"}, {"score": 0.004292530731019078, "phrase": "multiple_previous_algorithms"}, {"score": 0.00416223958248046, "phrase": "tree-pattern_queries"}, {"score": 0.0040928394196673955, "phrase": "flexible_querying"}, {"score": 0.0040020953332147785, "phrase": "query_classes"}, {"score": 0.0038805854107176116, "phrase": "efficient_nonmain-memory_evaluation_algorithms"}, {"score": 0.0037103745996558686, "phrase": "called_partial_tree-pattern_queries"}, {"score": 0.003557564469096288, "phrase": "broad_fragment"}, {"score": 0.003326006954887031, "phrase": "inference_rules"}, {"score": 0.00329813918116714, "phrase": "structural_relationship_derivation"}, {"score": 0.003206916619690171, "phrase": "query_unsatisfiability"}, {"score": 0.0031889761655961345, "phrase": "node_redundancy"}, {"score": 0.003083415089790538, "phrase": "acyclic_graphs"}, {"score": 0.003049007968098012, "phrase": "\"same-path\"_constraints"}, {"score": 0.0029981136735805197, "phrase": "existing_efficient_evaluation_algorithms"}, {"score": 0.002834505099882888, "phrase": "simpler_queries"}, {"score": 0.0027793709534214214, "phrase": "structural_summary"}, {"score": 0.0026948844239238334, "phrase": "equivalent_set"}, {"score": 0.002642458851766937, "phrase": "algorithm_partialpathjoin"}, {"score": 0.0026203032979824647, "phrase": "ptpq"}, {"score": 0.0026056359564738413, "phrase": "partial-path_queries"}, {"score": 0.0025264171945423254, "phrase": "partialtreestack"}, {"score": 0.002505232141865839, "phrase": "original_polynomial_time_holistic_algorithm"}, {"score": 0.002415459080723135, "phrase": "first_algorithm"}, {"score": 0.002342008661341529, "phrase": "inverted_lists_evaluation_model"}, {"score": 0.002309362871282009, "phrase": "theoretical_analysis"}, {"score": 0.002226592967032469, "phrase": "extensive_experimental_evaluation"}, {"score": 0.0021049977753042253, "phrase": "state-of-the_art_xquery_engine"}], "paper_keywords": ["XML query processing", " XPath query evaluation", " tree-pattern query", " partial tree-pattern query"], "paper_abstract": "XML query languages typically allow the specification of structural patterns using XPath. Usually, these structural patterns are in the form of trees (Tree-Pattern Queries-TPQs). Finding the occurrences of such patterns in an XML tree is a key operation in XML query evaluation. The multiple previous algorithms presented for this operation focus mainly on the evaluation of tree-pattern queries. Recently, requirements for flexible querying of XML data have motivated the consideration of query classes that are more expressive and flexible than TPQs for which efficient nonmain-memory evaluation algorithms are not known. In this paper, we consider a class of queries, called Partial Tree-Pattern Queries (PTPQs), which generalize and strictly contain TPQs. PTPQs represent a broad fragment of XPath which is very useful in practice. In order to process PTPQs, we introduce a set of sound and complete inference rules to characterize structural relationship derivation. We provide necessary and sufficient conditions for detecting query unsatisfiability and node redundancy. We also show that PTPQs can be represented as directed acyclic graphs augmented with the \"same-path\" constraints. In order to leverage existing efficient evaluation algorithms for less expressive classes of queries, we design two approaches that evaluate a PTPQ by decomposing it into a set of simpler queries: algorithm IndexTPQGen, exploits a structural summary of the XML data and evaluates a PTPQ by generating an equivalent set of TPQs and unioning their answers. Algorithm PartialPathJoin decomposes the PTPQ into partial-path queries, and merge-joins their solutions. We also develop PartialTreeStack, an original polynomial time holistic algorithm for PTPQs. To the best of our knowledge, this is the first algorithm to support the evaluation of such a broad structural fragment of XPath in the inverted lists evaluation model. We provide a theoretical analysis of our algorithm and identify cases where it is asymptotically optimal. An extensive experimental evaluation shows that it is more efficient, robust, and stable than the other two and it outperforms a state-of-the art XQuery engine on PTPQs.", "paper_title": "Processing and Evaluating Partial Tree Pattern Queries on XML Data", "paper_id": "WOS:000309914400010"}