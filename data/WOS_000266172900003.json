{"auto_keywords": [{"score": 0.04844631776293273, "phrase": "source_level"}, {"score": 0.04602278391010143, "phrase": "merged_program"}, {"score": 0.040767795791582725, "phrase": "embedded_systems"}, {"score": 0.00481495049065317, "phrase": "independent_programs"}, {"score": 0.004284596323560538, "phrase": "underlying_compiler"}, {"score": 0.004257678082997577, "phrase": "cpu."}, {"score": 0.004164644263639545, "phrase": "execution_time"}, {"score": 0.0037646178256430345, "phrase": "dean"}, {"score": 0.0037056529033273693, "phrase": "thrint_compiler"}, {"score": 0.0036476222647061243, "phrase": "assembly_level"}, {"score": 0.0036132394176383582, "phrase": "main_contribution"}, {"score": 0.003545439507880801, "phrase": "efficient_algorithm"}, {"score": 0.0031247264362609614, "phrase": "different_nesting_and_execution_frequency_levels"}, {"score": 0.002999012736727594, "phrase": "different_number"}, {"score": 0.0029520153163594435, "phrase": "future_mergings"}, {"score": 0.002878342135479895, "phrase": "proposed_algorithm"}, {"score": 0.0028421959620622355, "phrase": "matching_process"}, {"score": 0.002815383690003621, "phrase": "merging_problems"}, {"score": 0.002788823648033457, "phrase": "deep_nested_structure"}, {"score": 0.0027106334164712057, "phrase": "function_calls"}, {"score": 0.0026850589169993143, "phrase": "extensive_use"}, {"score": 0.002576988153314685, "phrase": "previous_works"}, {"score": 0.002544616720630384, "phrase": "final_tool"}, {"score": 0.002520604609793834, "phrase": "first_complete_system"}, {"score": 0.0024654516678953658, "phrase": "profile_and_structure_based_matching"}, {"score": 0.0023512871357696022, "phrase": "independent_threads"}, {"score": 0.002256619934086924, "phrase": "proposed_merging_technique"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Compilers", " Source-level", " Merging"], "paper_abstract": "In here we describe a technique to merge at source level two (and hence more) independent C programs. Due to the independence of the programs, the merged program has more parallelism that can be extracted by the underlying compiler and CPU. Thus it is expected that the execution time of the merged program will be better than the time obtained by executing the two programs separately. The usefulness of such merging for embedded systems has been studied and demonstrated by the works of Dean and others with the Thrint compiler for merging threads at Assembly level. The main contribution of this work is an efficient algorithm for matching sub-components considering the inside structure of the sub-components and not only their execution frequency. Two novel techniques for balancing the merge of sub-components are presented: Residual loop merging (RLM) as a way to merge loops with different nesting and execution frequency levels. Using the remaining iterations formed after merging two non-equal loops (loops with different number of iterations) in future mergings of other loops. These two abilities allow the proposed algorithm to simplify the matching process and overcome merging problems related to deep nested structure. We also consider the problem of merging function calls and make extensive use of cloning (and not only inlining as is the case with previous works). The final tool is the first complete system for merging C-programs at source level supporting profile and structure based matching. The main use of merging is to speed up embedded systems that usually execute independent threads or processes that can potentially be merged. Our experimental results suggest that the proposed merging technique can speedup the execution of two independent programs by 10%-20% for about half of mergings that have been tested. (C) 2009 Elsevier Inc. All rights reserved.", "paper_title": "Source level merging of independent programs", "paper_id": "WOS:000266172900003"}