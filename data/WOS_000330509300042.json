{"auto_keywords": [{"score": 0.029478702665943008, "phrase": "task_graphs"}, {"score": 0.010358144685918036, "phrase": "many-core_processors"}, {"score": 0.008713127977936122, "phrase": "strong_scaling"}, {"score": 0.00481495049065317, "phrase": "task_dataflow_execution"}, {"score": 0.004785682967399109, "phrase": "processor_architectures"}, {"score": 0.004641980000471692, "phrase": "multiple_processing_cores"}, {"score": 0.004599712603988837, "phrase": "single_chip"}, {"score": 0.004557828309570373, "phrase": "overall_performance"}, {"score": 0.004262060185430346, "phrase": "multicore_and_single-core_processors"}, {"score": 0.004146645277287799, "phrase": "concurrent_programs"}, {"score": 0.004121423202649493, "phrase": "high_degrees"}, {"score": 0.003913112416104065, "phrase": "memory_bandwidth_constraints"}, {"score": 0.0038538647865057757, "phrase": "increasingly_finer-grain_parallelism"}, {"score": 0.003749462025612395, "phrase": "processing_cores"}, {"score": 0.003715291088032481, "phrase": "task_dataflow_programming_models"}, {"score": 0.0036814304184738774, "phrase": "high_potential"}, {"score": 0.0036478772206217282, "phrase": "parallel_programming"}, {"score": 0.003559884222226099, "phrase": "precisely_all_intertask_dependences"}, {"score": 0.003474006363785606, "phrase": "task_dataflow_runtime_system"}, {"score": 0.0034318447871577503, "phrase": "intertask_dependences"}, {"score": 0.0032483404695661296, "phrase": "task_dataflow_graph"}, {"score": 0.0030746180465357374, "phrase": "account_dependences"}, {"score": 0.0030372887922081706, "phrase": "task_graph"}, {"score": 0.003000411392166266, "phrase": "important_overheads"}, {"score": 0.002805422862625723, "phrase": "efficient_schemes"}, {"score": 0.0027127202051739608, "phrase": "programming_model"}, {"score": 0.002631098941504841, "phrase": "task_arguments"}, {"score": 0.0024675803902400916, "phrase": "key_concepts"}, {"score": 0.0024525461181496753, "phrase": "efficient_management"}, {"score": 0.002349834016814399, "phrase": "graph_representations"}, {"score": 0.0022721515777319044, "phrase": "fourth_edgeless_scheme"}, {"score": 0.00218364206035443, "phrase": "graph_representation"}, {"score": 0.002130893364230495, "phrase": "edgeless_scheme"}, {"score": 0.0021179060760390597, "phrase": "least_overhead"}, {"score": 0.0021049977753042253, "phrase": "nearly_all_situations"}], "paper_keywords": ["Design", " Algorithms", " Performance", " Task dataflow", " scheduling"], "paper_abstract": "Processor architectures has taken a turn toward many-core processors, which integrate multiple processing cores on a single chip to increase overall performance, and there are no signs that this trend will stop in the near future. Many-core processors are harder to program than multicore and single-core processors due to the need for writing parallel or concurrent programs with high degrees of parallelism. Moreover, many-cores have to operate in a mode of strong scaling because of memory bandwidth constraints. In strong scaling, increasingly finer-grain parallelism must be extracted in order to keep all processing cores busy. Task dataflow programming models have a high potential to simplify parallel programming because they alleviate the programmer from identifying precisely all intertask dependences when writing programs. Instead, the task dataflow runtime system detects and enforces intertask dependences during execution based on the description of memory accessed by each task. The runtime constructs a task dataflow graph that captures all tasks and their dependences. Tasks are scheduled to execute in parallel, taking into account dependences specified in the task graph. Several papers report important overheads for task dataflow systems, which severely limits the scalability and usability of such systems. In this article, we study efficient schemes to manage task graphs and analyze their scalability. We assume a programming model that supports input, output, and in/out annotations on task arguments, as well as commutative in/out and reductions. We analyze the structure of task graphs and identify versions and generations as key concepts for efficient management of task graphs. Then, we present three schemes to manage task graphs building on graph representations, hypergraphs, and lists. We also consider a fourth edgeless scheme that synchronizes tasks using integers. Analysis using microbenchmarks shows that the graph representation is not always scalable and that the edgeless scheme introduces least overhead in nearly all situations.", "paper_title": "Analysis of Dependence Tracking Algorithms for Task Dataflow Execution", "paper_id": "WOS:000330509300042"}