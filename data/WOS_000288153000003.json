{"auto_keywords": [{"score": 0.043429710921929404, "phrase": "cryptographic_protocols"}, {"score": 0.00481495049065317, "phrase": "secure_implementations"}, {"score": 0.004324521292490181, "phrase": "security_properties"}, {"score": 0.004218602458288531, "phrase": "source_code"}, {"score": 0.004081385289516914, "phrase": "access_control_mechanisms"}, {"score": 0.0039813976794342, "phrase": "underlying_type_theory"}, {"score": 0.0037886833451021723, "phrase": "refinement_types"}, {"score": 0.0035755653799043, "phrase": "first-order_logic"}, {"score": 0.003459191419478298, "phrase": "formal_cryptographic_primitives"}, {"score": 0.0033743949483348626, "phrase": "active_adversaries"}, {"score": 0.0032916702592724217, "phrase": "type_theory"}, {"score": 0.0032109670662222416, "phrase": "-typed_programs"}, {"score": 0.0031582637043009562, "phrase": "assertion-based_security_properties"}, {"score": 0.0030052718739167696, "phrase": "realistic_threat_model"}, {"score": 0.0029559346879594254, "phrase": "key_compromise"}, {"score": 0.002789528662623221, "phrase": "enhanced_typechecker"}, {"score": 0.0026107601878587816, "phrase": "verification_conditions"}, {"score": 0.0024842242921857705, "phrase": "smt_solver"}, {"score": 0.002344311033783139, "phrase": "checked_examples"}, {"score": 0.0022492129111567824, "phrase": "first_tool"}, {"score": 0.0021940118003312397, "phrase": "authentication_properties"}], "paper_keywords": ["Security", " Verification"], "paper_abstract": "We present the design and implementation of a typechecker for verifying security properties of the source code of cryptographic protocols and access control mechanisms. The underlying type theory is a lambda-calculus equipped with refinement types for expressing pre- and post-conditions within first-order logic. We derive formal cryptographic primitives and represent active adversaries within the type theory. Well-typed programs enjoy assertion-based security properties, with respect to a realistic threat model including key compromise. The implementation amounts to an enhanced typechecker for the general-purpose functional language F(#); typechecking generates verification conditions that are passed to an SMT solver. We describe a series of checked examples. This is the first tool to verify authentication properties of cryptographic protocols by typechecking their source code.", "paper_title": "Refinement Types for Secure Implementations", "paper_id": "WOS:000288153000003"}