{"auto_keywords": [{"score": 0.0400977412860071, "phrase": "interface_grammar"}, {"score": 0.010612387000973441, "phrase": "interface_grammars"}, {"score": 0.007644030453554602, "phrase": "semantic_predicates"}, {"score": 0.005182715120239653, "phrase": "ejb_stub"}, {"score": 0.005048406423502405, "phrase": "ejb_clients"}, {"score": 0.0047920120174595555, "phrase": "modular_software_model"}, {"score": 0.004757808064423294, "phrase": "verification_techniques"}, {"score": 0.004712580464900024, "phrase": "state_enumeration"}, {"score": 0.004667780781335814, "phrase": "model_checking"}, {"score": 0.004503525064934708, "phrase": "state_space"}, {"score": 0.004471370994268206, "phrase": "increasing_number"}, {"score": 0.004202105650903394, "phrase": "verification_tool"}, {"score": 0.004132411680987228, "phrase": "semiautomated_approach"}, {"score": 0.003939565240409143, "phrase": "current_verification_effort"}, {"score": 0.0038927709937268675, "phrase": "interface_specification_language"}, {"score": 0.0037467181883031973, "phrase": "method_invocations"}, {"score": 0.003623407818632102, "phrase": "nested_call_sequences"}, {"score": 0.0035632774896594524, "phrase": "interface_specification_formalisms"}, {"score": 0.003529364798514874, "phrase": "finite_state_machines"}, {"score": 0.0034132461323346714, "phrase": "java"}, {"score": 0.0033405160833063904, "phrase": "additional_interface_constraints"}, {"score": 0.0032929299316035864, "phrase": "interface_compiler"}, {"score": 0.003146652729098066, "phrase": "resulting_stub"}, {"score": 0.0031241559930784914, "phrase": "table-driven_parser"}, {"score": 0.003043031131345537, "phrase": "look-ahead_symbol"}, {"score": 0.002978220908815587, "phrase": "parser_stack"}, {"score": 0.002845883666777154, "phrase": "semantic_actions"}, {"score": 0.0028120435199134497, "phrase": "right-hand_side"}, {"score": 0.002791932344920906, "phrase": "production_rules"}, {"score": 0.002598543802992702, "phrase": "state_space_exploration"}, {"score": 0.0025614999929672, "phrase": "state_space_explosion"}, {"score": 0.0025310328434864256, "phrase": "executable_environment"}, {"score": 0.002459378389923385, "phrase": "case_study"}, {"score": 0.0024185182010749273, "phrase": "enterprise_javabeans"}, {"score": 0.0023954743066925714, "phrase": "persistence_interface"}, {"score": 0.002327648608736437, "phrase": "ejb_interface_grammar"}, {"score": 0.002299956534922594, "phrase": "jpf_model_checker"}, {"score": 0.002125253412774528, "phrase": "jpf"}, {"score": 0.0021049977753042253, "phrase": "ejb_components"}], "paper_keywords": ["specification languages", " model checking", " interface grammars", " modular verification"], "paper_abstract": "Verification techniques that rely on state enumeration (such as model checking) face two important challenges: 1) state space explosion: exponential increase in the state space with the increasing number of components and 2) environment generation: modeling components that are either not available for analysis or that are outside the scope of the verification tool at hand. We propose a semiautomated approach for attacking these two problems. In our approach, interfaces for the components that are outside the scope of the current verification effort are specified using an interface specification language based on grammars. Specifically, an interface grammar for a component specifies the sequences of method invocations that are allowed by that component. Using interface grammars, one can specify nested call sequences that cannot be specified using interface specification formalisms that rely on finite state machines. Moreover, our interface grammars allow specification of semantic predicates and actions, which are Java code segments that can be used to express additional interface constraints. We have built an interface compiler that takes the interface grammar for a component as input and generates a stub for that component. The resulting stub is a table-driven parser. Invocation of a method within the component becomes the look-ahead symbol for the stub/parser. The stub/parser uses a parser stack, the look-ahead, and a parse table to guide the parsing. The semantic predicates and semantic actions that appear on the right-hand side of the production rules are executed when they appear at the top of the stack. The stub/parser generated from the interface grammar of a component can be used to replace that component during state space exploration, either to assuage the state space explosion or to provide an executable environment for the component that is being verified. We conducted a case study by writing an interface grammar for the Enterprise JavaBeans (EJB) persistence interface. Using our interface compiler, we automatically generated an EJB stub using the EJB interface grammar. We used the JPF model checker to check EJB clients using this automatically generated EJB stub. Our results show that EJB clients can be verified efficiently with JPF using our approach, whereas they cannot be verified with JPF directly since JPF cannot handle EJB components.", "paper_title": "Interface grammars for modular software model checking", "paper_id": "WOS:000259456600004"}