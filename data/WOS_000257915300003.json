{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "nocker's_strictness_analysis"}, {"score": 0.04869227050760362, "phrase": "strictness_analysis"}, {"score": 0.00893357264045796, "phrase": "functional_core_language"}, {"score": 0.008846841024988951, "phrase": "contextual_semantics"}, {"score": 0.008076559087562956, "phrase": "sal"}, {"score": 0.0047061353684963655, "phrase": "nocker's_method"}, {"score": 0.0045997680394590365, "phrase": "clean_compiler"}, {"score": 0.004525259757290933, "phrase": "effective_way"}, {"score": 0.004466519142879166, "phrase": "lazy_functional_languages"}, {"score": 0.004322978834992164, "phrase": "clark"}, {"score": 0.004294813202198633, "phrase": "hankin"}, {"score": 0.004266870236535282, "phrase": "hunt"}, {"score": 0.0041703614123283165, "phrase": "abstract_reduction_rules"}, {"score": 0.003945001936004421, "phrase": "wider_range"}, {"score": 0.003919299546627271, "phrase": "strictness-based_optimizations"}, {"score": 0.0038056875126935607, "phrase": "cycle_detection_rules"}, {"score": 0.0035999631751991385, "phrase": "nocker's_strictness_analysis_algorithm"}, {"score": 0.003507023579658917, "phrase": "higher_order"}, {"score": 0.0034388914613623857, "phrase": "lambda_calculus"}, {"score": 0.0032529303004879325, "phrase": "set_constants"}, {"score": 0.0031175178621644464, "phrase": "different_evaluation_demands"}, {"score": 0.0030369955065974222, "phrase": "new_set_constants"}, {"score": 0.0030171910207671205, "phrase": "recursive_equations"}, {"score": 0.0029877254536170017, "phrase": "greatest_fixpoint_semantics"}, {"score": 0.002958546790146313, "phrase": "operational_semantics"}, {"score": 0.00293927773220579, "phrase": "lr"}, {"score": 0.002910545717767559, "phrase": "small-step_semantics"}, {"score": 0.002717277008333612, "phrase": "nontermination_checker"}, {"score": 0.002587115505155995, "phrase": "exact_analysis"}, {"score": 0.0024631735269020735, "phrase": "whnf."}, {"score": 0.0023995115472744376, "phrase": "\"essential\"_reductions"}, {"score": 0.0023374910885214815, "phrase": "new_insights"}, {"score": 0.0023222375006409675, "phrase": "call-by-need_lambda_calculi"}, {"score": 0.0022696277881969896, "phrase": "functional_programming_languages"}, {"score": 0.0022037303797015073, "phrase": "correctness_result"}, {"score": 0.0021538105256661833, "phrase": "clean"}, {"score": 0.002105006134901062, "phrase": "haskell"}], "paper_keywords": [""], "paper_abstract": "This paper proves correctness of Nocker's method of strictness analysis, implemented in the Clean compiler, which is an effective way for strictness analysis in lazy functional languages based on their operational semantics. We improve upon the work Clark, Hankin and Hunt did on the correctness of the abstract reduction rules in two aspects. Our correctness proof is based on a functional core language and a contextual semantics, thus proving a wider range of strictness-based optimizations as correct, and our method fully considers the cycle detection rules, which contribute to the strength of Nocker's strictness analysis. Our algorithm SAL is a reformulation of Nocker's strictness analysis algorithm in a functional core language LR. This is a higher order call-by-need lambda calculus with case, constructors, letrec, and seq, which is extended during strictness analysis by set constants like Top or Inf, denoting sets of expressions, which indicate different evaluation demands. It is also possible to define new set constants by recursive equations with a greatest fixpoint semantics. The operational semantics of LR is a small-step semantics. Equality of expressions is defined by a contextual semantics that observes termination of expressions. Basically, SAL is a nontermination checker. The proof of its correctness and hence of Nocker's strictness analysis is based mainly on an exact analysis of the lengths of evaluations, i.e., normal-order reduction sequences to WHNF. The main measure being the number of \"essential\" reductions in evaluations. Our tools and results provide new insights into call-by-need lambda calculi, the role of sharing in functional programming languages, and into strictness analysis in general. The correctness result provides a foundation for Nocker's strictness analysis in Clean, and also for its use in Haskell.", "paper_title": "Safety of Nocker's strictness analysis", "paper_id": "WOS:000257915300003"}