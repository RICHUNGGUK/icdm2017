{"auto_keywords": [{"score": 0.04789396098417503, "phrase": "order_processors"}, {"score": 0.00481495049065317, "phrase": "superscalar_in-order_processors"}, {"score": 0.004489327204473076, "phrase": "lower_design_complexity"}, {"score": 0.00436530211426514, "phrase": "reduced_design_complexity"}, {"score": 0.004224911726496726, "phrase": "performance_estimates"}, {"score": 0.004127394241838696, "phrase": "application-microarchitecture_interaction"}, {"score": 0.0038301525703886585, "phrase": "application's_dynamic_instruction_stream"}, {"score": 0.003672427620845944, "phrase": "interinstruction_dependences"}, {"score": 0.0036382660173943393, "phrase": "functional_unit_contention"}, {"score": 0.0035211747962710246, "phrase": "detailed_cycle-level_simulations"}, {"score": 0.003472149546470424, "phrase": "design_space_exploration"}, {"score": 0.0033919477901198716, "phrase": "mechanistic_analytical_performance_model"}, {"score": 0.0032827577713351336, "phrase": "internal_mechanisms"}, {"score": 0.0031919592786945126, "phrase": "mechanistic_performance_model"}, {"score": 0.003003726508522467, "phrase": "average_performance_prediction_error"}, {"score": 0.0029343128039167185, "phrase": "detailed_cycle-accurate_simulation"}, {"score": 0.002422249273477746, "phrase": "space_exploration"}, {"score": 0.00237733844863506, "phrase": "optimum_number"}, {"score": 0.0023551955270737215, "phrase": "functional_units"}, {"score": 0.0021649437083408425, "phrase": "compiler-architecture_interactions"}, {"score": 0.0021049977753042253, "phrase": "compiler_optimizations"}], "paper_keywords": ["Design", " Experimentation", " Measurement", " Performance", " Superscalar in-order processors", " processor design space exploration", " functional units", " inter-instruction dependences", " performance modeling", " cycle stacks"], "paper_abstract": "Superscalar in-order processors form an interesting alternative to out-of-order processors because of their energy efficiency and lower design complexity. However, despite the reduced design complexity, it is nontrivial to get performance estimates or insight in the application-microarchitecture interaction without running slow, detailed cycle-level simulations, because performance highly depends on the order of instructions within the application's dynamic instruction stream, as in-order processors stall on interinstruction dependences and functional unit contention. To limit the number of detailed cycle-level simulations needed during design space exploration, we propose a mechanistic analytical performance model that is built from understanding the internal mechanisms of the processor. The mechanistic performance model for superscalar in-order processors is shown to be accurate with an average performance prediction error of 3.2% compared to detailed cycle-accurate simulation using gem5. We also validate the model against hardware, using the ARM Cortex-A8 processor and show that it is accurate within 10% on average. We further demonstrate the usefulness of the model through three case studies: (1) design space exploration, identifying the optimum number of functional units for achieving a given performance target; (2) program-machine interactions, providing insight into microarchitecture bottlenecks; and (3) compiler-architecture interactions, visualizing the impact of compiler optimizations on performance.", "paper_title": "Mechanistic Analytical Modeling of Superscalar In-Order Processor Performance", "paper_id": "WOS:000348232000016"}