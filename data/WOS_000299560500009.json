{"auto_keywords": [{"score": 0.008713768692145006, "phrase": "burrows-wheeler_transform"}, {"score": 0.006261875348764904, "phrase": "whole_human_genome"}, {"score": 0.005453379709253245, "phrase": "space_usage"}, {"score": 0.0047747348769918, "phrase": "wavelet_tree"}, {"score": 0.00471503739362446, "phrase": "repetitive_structures"}, {"score": 0.004592079050299752, "phrase": "prior_methods"}, {"score": 0.00446481608187988, "phrase": "modern_genomic_sequences"}, {"score": 0.0042455945330942746, "phrase": "local_repetitive_structures"}, {"score": 0.004210114198411514, "phrase": "better_understood"}, {"score": 0.004174929128880472, "phrase": "large_and_complex_interspersed_ones"}, {"score": 0.0040882422992520925, "phrase": "maximal_repeats"}, {"score": 0.003953256858638655, "phrase": "space-efficient_way"}, {"score": 0.0038711548651825917, "phrase": "maximal_repeat"}, {"score": 0.00377487157059352, "phrase": "suffix_array"}, {"score": 0.0035148319209810128, "phrase": "massive_data"}, {"score": 0.00325893016361821, "phrase": "space-efficient_manner"}, {"score": 0.0031512402798625056, "phrase": "wavelet_trees"}, {"score": 0.0031117775337824853, "phrase": "data_sets"}, {"score": 0.003072807453368781, "phrase": "natural_language_texts"}, {"score": 0.0030470980812086247, "phrase": "protein_data"}, {"score": 0.002500987934534128, "phrase": "massive_texts"}, {"score": 0.0023879771786116228, "phrase": "external_memory"}, {"score": 0.0023481578019624843, "phrase": "first_time"}, {"score": 0.002299313860419974, "phrase": "desktop_computer"}, {"score": 0.0022609695885550058, "phrase": "actual_internal_memory_usage"}, {"score": 0.0021049977753042253, "phrase": "general-purpose_open-source_software"}], "paper_keywords": ["Repeats", " maximal repeats", " Burrows-Wheeler transform", " wavelet trees"], "paper_abstract": "Finding repetitive structures in genomes and proteins is important to understand their biological functions. Many data compressors for modern genomic sequences rely heavily on finding repeats in the sequences. Small-scale and local repetitive structures are better understood than large and complex interspersed ones. The notion of maximal repeats captures all the repeats in the data in a space-efficient way. Prior work on maximal repeat finding used either a suffix tree or a suffix array along with other auxiliary data structures. Their space usage is 19-50 times the text size with the best engineering efforts, prohibiting their usability on massive data such as the whole human genome. We focus on finding all the maximal repeats from massive texts in a time- and space-efficient manner. Our technique uses the Burrows-Wheeler Transform and wavelet trees. For data sets consisting of natural language texts and protein data, the space usage of our method is no more than three times the text size. For genomic sequences stored using one byte per base, the space usage of our method is less than double the sequence size. Our space-efficient method keeps the timing performance fast. In fact, our method is orders of magnitude faster than the prior methods for processing massive texts such as the whole human genome, since the prior methods must use external memory. For the first time, our method enables a desktop computer with 8 GB internal memory (actual internal memory usage is less than 6 GB) to find all the maximal repeats in the whole human genome in less than 17 hours. We have implemented our method as general-purpose open-source software for public use.", "paper_title": "Efficient Maximal Repeat Finding Using the Burrows-Wheeler Transform and Wavelet Tree", "paper_id": "WOS:000299560500009"}