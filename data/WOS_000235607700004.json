{"auto_keywords": [{"score": 0.036954893243603605, "phrase": "williams"}, {"score": 0.005001399919104399, "phrase": "floyd"}, {"score": 0.00481495049065317, "phrase": "unbounded_universes"}, {"score": 0.0046118021635786315, "phrase": "distinct_keys"}, {"score": 0.004449045430179066, "phrase": "logarithmic_searching"}, {"score": 0.0041703614123283165, "phrase": "logarithmic_updating"}, {"score": 0.003909065355459264, "phrase": "logarithmic_time"}, {"score": 0.003690527690610707, "phrase": "natural_question"}, {"score": 0.00326572165784246, "phrase": "fundamental_issue"}, {"score": 0.0032190636347671675, "phrase": "additional_space"}, {"score": 0.0028689475587958917, "phrase": "implicit_data_structures"}, {"score": 0.002448704249007665, "phrase": "recent_result"}, {"score": 0.0021821915946356168, "phrase": "flat_implicit_tree"}, {"score": 0.0021049977753042253, "phrase": "first_data_structure"}], "paper_keywords": [""], "paper_abstract": "An array of n distinct keys can be sorted for logarithmic searching or can be organized as a heap for logarithmic updating, but it is unclear how to attain logarithmic time for both searching and updating. This natural question dates back to the heap of Williams and Floyd in the sixties and relates to the fundamental issue whether additional space besides those for the keys gives more computational power in dictionaries and how data ordering helps. Implicit data structures were introduced in the eighties with this goal, providing the best bound of O(log(2) n) time. until a recent result showing O(log(2) n/log log n) time. In this paper we describe the flat implicit tree, which is the first data structure obtaining O(log n) time for search and (amortized) update using an array of n cells.", "paper_title": "Optimal implicit dictionaries over unbounded universes", "paper_id": "WOS:000235607700004"}