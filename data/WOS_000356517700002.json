{"auto_keywords": [{"score": 0.04951738916270167, "phrase": "genetic_programming"}, {"score": 0.032876428585481, "phrase": "desired_intermediate_computation_states"}, {"score": 0.030511826971011288, "phrase": "semantic_backpropagation"}, {"score": 0.00481495049065317, "phrase": "designing_search_operators"}, {"score": 0.004592905436175987, "phrase": "search_algorithm"}, {"score": 0.004329630571352367, "phrase": "desired_final_computation_state"}, {"score": 0.0040097139701644165, "phrase": "program_needs"}, {"score": 0.00387011040370557, "phrase": "evolutionary_search_process"}, {"score": 0.003584025547693836, "phrase": "nontrivial_tasks"}, {"score": 0.0035210572541244664, "phrase": "long_programs"}, {"score": 0.0033984088755183287, "phrase": "semantic_backpropagation_algorithm"}, {"score": 0.0030374213037172803, "phrase": "random_desired_operator"}, {"score": 0.0030017207229983385, "phrase": "approximately_geometric_semantic_crossover"}, {"score": 0.002931569771634119, "phrase": "intermediate_states"}, {"score": 0.0027796495180095657, "phrase": "original_programming_task"}, {"score": 0.002651213849567608, "phrase": "exhaustive_search"}, {"score": 0.0025587867729949037, "phrase": "standard_genetic_search_operators"}, {"score": 0.002426137929553724, "phrase": "symbolic_regression"}, {"score": 0.0023976048394496446, "phrase": "boolean_benchmarks"}, {"score": 0.0023277282036119106, "phrase": "additional_analysis"}, {"score": 0.0021049977753042253, "phrase": "search_process"}], "paper_keywords": ["Geometric crossover", " mutation", " problem decomposition", " program synthesis", " reversible computing", " semantics"], "paper_abstract": "In genetic programming, a search algorithm is expected to produce a program that achieves the desired final computation state (desired output). To reach that state, an executing program needs to traverse certain intermediate computation states. An evolutionary search process is expected to autonomously discover such states. This can be difficult for nontrivial tasks that require long programs to be solved. The semantic backpropagation algorithm proposed in this paper heuristically inverts the execution of evolving programs to determine the desired intermediate computation states. Two search operators, random desired operator and approximately geometric semantic crossover, use the intermediate states determined by semantic backpropagation to define subtasks of the original programming task, which are then solved using an exhaustive search. The operators outperform the standard genetic search operators and other semantic-aware operators when compared on a suite of symbolic regression and Boolean benchmarks. This result and additional analysis conducted in this paper indicate that semantic backpropagation helps evolution to identify the desired intermediate computation states and makes the search process more efficient.", "paper_title": "Semantic Backpropagation for Designing Search Operators in Genetic Programming", "paper_id": "WOS:000356517700002"}