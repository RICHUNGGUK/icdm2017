{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "simple_grammars"}, {"score": 0.004736563452994885, "phrase": "prefix-free_language"}, {"score": 0.004176321608449849, "phrase": "polynomial_time"}, {"score": 0.0040192915527630995, "phrase": "simple_context-free_grammar"}, {"score": 0.0038470175104007524, "phrase": "canonical_representation"}, {"score": 0.003784328428527216, "phrase": "simple_language"}, {"score": 0.003682100144121148, "phrase": "prime_normal_form"}, {"score": 0.0035630518377071916, "phrase": "simple_grammar"}, {"score": 0.0031411751440831165, "phrase": "best_previously_known_algorithm"}, {"score": 0.0024815011359381692, "phrase": "total_size"}, {"score": 0.0023107372754933887, "phrase": "shortest_string_derivable"}, {"score": 0.0021049977753042253, "phrase": "caucal's_algorithm"}], "paper_keywords": [""], "paper_abstract": "A prefix-free language is a prime if it cannot be decomposed into a concatenation of two prefix-free languages. We show that we can check in polynomial time if a language generated by a simple context-free grammar is a prime. Our algorithm computes a canonical representation of a simple language, converting its arbitrary simple grammar into Prime Normal Form (PNF); a simple grammar is in PNF if all its non-terminals define primes. We also improve the complexity of testing the equivalence of simple grammars. The best previously known algorithm for this problem worked in O(n(13)) time. We improve it to O(n(7) log(2) n) and O(n(5) polylog nu) deterministic time, and O(n(4) polylog n) randomized time, where n is the total size of the grammars involved, and nu is the length of a shortest string derivable from a nonterminal, maximized over all nonterminals. Our improvement is based on a version of Caucal's algorithm from [1].", "paper_title": "Prime normal form and equivalence of simple grammars", "paper_id": "WOS:000236480300007"}