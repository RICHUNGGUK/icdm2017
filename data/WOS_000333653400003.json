{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "floating-point_bounds"}, {"score": 0.004642604455537883, "phrase": "careful_devising"}, {"score": 0.004422325007817267, "phrase": "possible_inputs"}, {"score": 0.0037301606780397456, "phrase": "expected_results"}, {"score": 0.0032629585038738856, "phrase": "common_pitfalls"}, {"score": 0.0029244418026475832, "phrase": "noninterval_arithmetic_computation"}, {"score": 0.0027184540871935284, "phrase": "bisection_methods"}, {"score": 0.002526938673434697, "phrase": "floating-point_arithmetic"}, {"score": 0.0022371907579775796, "phrase": "practical_introduction"}, {"score": 0.0021049977753042253, "phrase": "floating-point_computation"}], "paper_keywords": ["Algorithms", " Reliability", " Experimentation", " Floating-point number", " IEEE 754 standard", " interval arithmetic", " midpoint", " rounding error"], "paper_abstract": "The algorithm that computes the midpoint of an interval with floating-point bounds requires some careful devising to handle all possible inputs correctly. We review several implementations from prominent C/C++ interval arithmetic packages and analyze their potential failure to deliver the expected results. We then show how to amend them to avoid common pitfalls. The results presented are also relevant to noninterval arithmetic computation such as the implementation of bisection methods. Enough background on IEEE 754 floating-point arithmetic is provided for this article to serve as a practical introduction to the analysis of floating-point computation.", "paper_title": "How Do You Compute the Midpoint of an Interval?", "paper_id": "WOS:000333653400003"}