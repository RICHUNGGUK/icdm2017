{"auto_keywords": [{"score": 0.04583367827568684, "phrase": "sequential_consistency"}, {"score": 0.00481495049065317, "phrase": "efficient_sequentially"}, {"score": 0.004483909657713567, "phrase": "simple_protocol"}, {"score": 0.004175533280178052, "phrase": "shared_memory_abstraction"}, {"score": 0.004029359223675788, "phrase": "local_memories"}, {"score": 0.003725470458263889, "phrase": "reliable_channels"}, {"score": 0.003371508176308189, "phrase": "strong_synchronization_mechanism"}, {"score": 0.0032533888943254144, "phrase": "atomic_broadcast"}, {"score": 0.0030078460113945136, "phrase": "shared_object"}, {"score": 0.002923214590192792, "phrase": "methodological_point"}, {"score": 0.0025525322651112365, "phrase": "noteworthy_property"}, {"score": 0.0024281181691350085, "phrase": "write_operation"}, {"score": 0.0022447206386952126, "phrase": "current_local_state"}], "paper_keywords": ["distributed systems", " distributed shared memory", " sequential consistency"], "paper_abstract": "The paper proposes a simple protocol that ensures sequential consistency. The protocol assumes that the shared memory abstraction is supported by the local memories of nodes that can communicate only by exchanging messages through reliable channels. Unlike other sequential consistency protocols, the one proposed here does not rely on a strong synchronization mechanism, such as an atomic broadcast primitive or a central node managing a copy of every shared object. From a methodological point of view, the protocol is built incrementally starting from the very definition of sequential consistency. It has the noteworthy property that a process that issues a write operation never has to wait for other processes. Depending on the current local state, most read operations issued also have the same property.", "paper_title": "A Methodological Construction of an Efficient Sequentially Consistent Distributed Shared Memory", "paper_id": "WOS:000283666800015"}