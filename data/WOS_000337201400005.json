{"auto_keywords": [{"score": 0.04975844688475772, "phrase": "multi-party_communication_complexity"}, {"score": 0.03868879525125654, "phrase": "general_topologies"}, {"score": 0.02913263115158322, "phrase": "fault-tolerant_communication_complexity"}, {"score": 0.02431777675002257, "phrase": "unionsizecp"}, {"score": 0.00481495049065317, "phrase": "fault_tolerance"}, {"score": 0.004718897469501381, "phrase": "distributed_computation"}, {"score": 0.004593787100061613, "phrase": "multiple_distributed_players"}, {"score": 0.00454772672262359, "phrase": "key_focus"}, {"score": 0.004517275498868226, "phrase": "distributed_computing_research"}, {"score": 0.004111672925576111, "phrase": "fault-tolerant_way"}, {"score": 0.004043158538239064, "phrase": "communication_complexity"}, {"score": 0.003805788648230075, "phrase": "node_crash_failures"}, {"score": 0.003406091279580424, "phrase": "simpler_failure-free_setting"}, {"score": 0.003271361898648331, "phrase": "account_failures'_impact"}, {"score": 0.0029672941061574375, "phrase": "sum_aggregate_function"}, {"score": 0.002821247621250663, "phrase": "non-fault-tolerant_and_fault-tolerant_communication_complexity"}, {"score": 0.0026823700218343506, "phrase": "non-fault-tolerant_communication_complexity"}, {"score": 0.0026111116934081284, "phrase": "\"amended\"_version"}, {"score": 0.0024742098091226203, "phrase": "max_aggregate_function"}, {"score": 0.0023523750536537102, "phrase": "novel_reduction"}, {"score": 0.0023287359930308864, "phrase": "new_two-party_problem"}, {"score": 0.002251637552201872, "phrase": "novel_cycle_promise"}, {"score": 0.002214048743052355, "phrase": "key_enabler"}, {"score": 0.0021479597698614355, "phrase": "cycle_promise"}, {"score": 0.0021049977753042253, "phrase": "fundamental_role"}], "paper_keywords": ["Aggregate functions", " communication complexity", " fault tolerance", " promise problems"], "paper_abstract": "Multi-party communication complexity involves distributed computation of a function over inputs held by multiple distributed players. A key focus of distributed computing research, since the very beginning, has been to tolerate failures. It is thus natural to ask \"If we want to compute a certain function in a fault-tolerant way, what will the communication complexity be?\" For this question, this article will focus specifically on (i) tolerating node crash failures, and (ii) computing the function over general topologies (instead of, e.g., just cliques). One way to approach this question is to first develop results in a simpler failure-free setting, and then \"amend\" the results to take into account failures' impact. Whether this approach is effective largely depends on how big a difference failures can make. This article proves that the impact of failures is significant, at least for the Sum aggregate function in general topologies: As our central contribution, we prove that there exists (at least) an exponential gap between the non-fault-tolerant and fault-tolerant communication complexity of Sum. This gap attests that fault-tolerant communication complexity needs to be studied separately from non-fault-tolerant communication complexity, instead of being considered as an \"amended\" version of the latter. Such exponential gap is not obvious: For some other functions such as the MAX aggregate function, the gap is only logarithmic. Part of our results are obtained via a novel reduction from a new two-party problem UNIONSIZECP that we introduce. UNIONSIZECP comes with a novel cycle promise, which is the key enabler of our reduction. We further prove that this cycle promise and UNIONSIZECP likely play a fundamental role in reasoning about fault-tolerant communication complexity.", "paper_title": "The Cost of Fault Tolerance in Multi-Party Communication Complexity", "paper_id": "WOS:000337201400005"}