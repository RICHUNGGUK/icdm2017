{"auto_keywords": [{"score": 0.05007797586658863, "phrase": "typestate-oriented_programming"}, {"score": 0.04257085650569971, "phrase": "access_permissions"}, {"score": 0.04232366983239522, "phrase": "state_guarantees"}, {"score": 0.0390040400649695, "phrase": "tsop"}, {"score": 0.028228783993655172, "phrase": "gft"}, {"score": 0.0047283116134926645, "phrase": "legal_operations"}, {"score": 0.004699778175535453, "phrase": "imperative_objects"}, {"score": 0.004573483858954342, "phrase": "typestate_checker"}, {"score": 0.004437115547184535, "phrase": "object_method"}, {"score": 0.00418907090251818, "phrase": "prior_work"}, {"score": 0.004138637076221288, "phrase": "modular_typestate_checking"}, {"score": 0.003919064949140323, "phrase": "primitive_language_concept"}, {"score": 0.0038953958723049287, "phrase": "typestate_checkers"}, {"score": 0.003860158978186175, "phrase": "additional_verification_layer"}, {"score": 0.003802135020791801, "phrase": "existing_language"}, {"score": 0.0035677736570659813, "phrase": "plaid_programming_language"}, {"score": 0.003378385493203297, "phrase": "plaid_objects"}, {"score": 0.003160466312198169, "phrase": "nominal_object-oriented_language"}, {"score": 0.0031035049228517715, "phrase": "typestate_change"}, {"score": 0.0030847461428168614, "phrase": "typestate_checking"}, {"score": 0.0030661003993462665, "phrase": "primitive_concepts"}, {"score": 0.003010834638993771, "phrase": "statically_typed_language-featherweight_typestate"}, {"score": 0.0029565620771207003, "phrase": "object_references"}, {"score": 0.0028595832692215766, "phrase": "novel_flow-sensitive_permission-based_type_system"}, {"score": 0.002675039053570178, "phrase": "gradually_typed_language-gradual_featherweight_typestate"}, {"score": 0.0025872705784794198, "phrase": "gradual_typing"}, {"score": 0.002502374576203785, "phrase": "static_and_dynamic_checking"}, {"score": 0.0024721971183379867, "phrase": "runtime_checks"}, {"score": 0.0024349853033241663, "phrase": "gradual_type_system"}, {"score": 0.002383825621519496, "phrase": "dynamically_safe_code"}, {"score": 0.0023550744328020966, "phrase": "static_type_checker"}, {"score": 0.002117811223107415, "phrase": "features-typestate"}], "paper_keywords": ["Languages", " Design", " Reliability", " Theory", " Verification", " Access permissions", " gradual typing", " types", " typestates"], "paper_abstract": "Typestate reflects how the legal operations on imperative objects can change at runtime as their internal state changes. A typestate checker can statically ensure, for instance, that an object method is only called when the object is in a state for which the operation is well defined. Prior work has shown how modular typestate checking can be achieved thanks to access permissions and state guarantees. However, typestate was not treated as a primitive language concept: typestate checkers are an additional verification layer on top of an existing language. In contrast, a typestate-oriented programming (TSOP) language directly supports expressing typestates. For example, in the Plaid programming language, the typestate of an object directly corresponds to its class, and that class can change dynamically. Plaid objects have not only typestate-dependent interfaces but also typestate-dependent behaviors and runtime representations. This article lays foundations for TSOP by formalizing a nominal object-oriented language with mutable state that integrates typestate change and typestate checking as primitive concepts. We first describe a statically typed language-Featherweight Typestate (FT)-where the types of object references are augmented with access permissions and state guarantees. We describe a novel flow-sensitive permission-based type system for FT. Because static typestate checking is still too rigid for some applications, we then extend this language into a gradually typed language-Gradual Featherweight Typestate (GFT). This language extends the notion of gradual typing to account for typestate: gradual typestate checking seamlessly combines static and dynamic checking by automatically inserting runtime checks into programs. The gradual type system of GFT allows programmers to write dynamically safe code even when the static type checker can only partly verify it. Categories and Subject Descriptors: D. 3.1 [Programming Languages]: Formal Definitions and Theory-Semantics; D.3.3 [Programming Languages]: Language Constructs and Features-Typestate; D.2.10 [Software Engineering]: Design-Representation", "paper_title": "Foundations of Typestate-Oriented Programming", "paper_id": "WOS:000344622700002"}