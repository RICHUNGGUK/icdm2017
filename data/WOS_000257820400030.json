{"auto_keywords": [{"score": 0.030867698336472526, "phrase": "xmem"}, {"score": 0.008696989742032505, "phrase": "object_serialization"}, {"score": 0.00481495049065317, "phrase": "cross-runtime_communication"}, {"score": 0.004718230196581402, "phrase": "contemporary_enterprise_applications"}, {"score": 0.004543708337879809, "phrase": "multiple_tiers"}, {"score": 0.004478308876320956, "phrase": "web_container"}, {"score": 0.0044524122425287005, "phrase": "application_server"}, {"score": 0.004413846562278824, "phrase": "database_engine"}, {"score": 0.004189337956225294, "phrase": "system_complexity"}, {"score": 0.004153041453795458, "phrase": "fault_containment"}, {"score": 0.004093241899787004, "phrase": "isolated_mre_instances"}, {"score": 0.004010960493946656, "phrase": "expensive_cross-tier_communication"}, {"score": 0.003918940000819495, "phrase": "remote_procedure"}, {"score": 0.003784837517869512, "phrase": "single_host"}, {"score": 0.003752032410115961, "phrase": "communication_overhead"}, {"score": 0.0036979855349860134, "phrase": "increasing_numbers"}, {"score": 0.00367658459781873, "phrase": "available_processing_cores"}, {"score": 0.0034995881411519925, "phrase": "co-located_mres"}, {"score": 0.0034692468245671243, "phrase": "fast_inter-process_communication_mechanisms"}, {"score": 0.003350480663660326, "phrase": "standard_operating_system_service"}, {"score": 0.0032830808525570903, "phrase": "growing_need"}, {"score": 0.002897710777957041, "phrase": "virtual_memory_mapping"}, {"score": 0.002855934865505357, "phrase": "object_sharing"}, {"score": 0.0027984556312357673, "phrase": "shared_objects"}, {"score": 0.0027661298116867013, "phrase": "local_objects"}, {"score": 0.0027341763737751467, "phrase": "field_access"}, {"score": 0.002702591051318831, "phrase": "garbage_collection"}, {"score": 0.0026791410961432677, "phrase": "method_invocation"}, {"score": 0.002594880866651459, "phrase": "private_pointers"}, {"score": 0.0025500402081330394, "phrase": "easy_integration"}, {"score": 0.002520576658199164, "phrase": "existing_communication_technologies"}, {"score": 0.0025059724686541263, "phrase": "software_systems"}, {"score": 0.0024770184175668983, "phrase": "rmi"}, {"score": 0.002462664392109308, "phrase": "jndi"}, {"score": 0.0024483957724144314, "phrase": "jdbc"}, {"score": 0.0024130810599110398, "phrase": "network_sockets"}, {"score": 0.0023168823213024856, "phrase": "java_virtual"}, {"score": 0.0022702274881448692, "phrase": "core_communication_technologies"}, {"score": 0.002218054404179068, "phrase": "open-source_server_applications"}, {"score": 0.0021607883988873492, "phrase": "response_time"}, {"score": 0.0021049977753042253, "phrase": "network_communication"}], "paper_keywords": ["design", " experimentation", " languages", " management", " measurement", " performance", " interprocess communication", " managed runtimes", " shared memory", " transparent", " type-safe", " garbage collection", " synchronization", " class loading", " parallel"], "paper_abstract": "Developers commonly build contemporary enterprise applications using type-safe, component-based platforms, such as J2EE, and architect them to comprise multiple tiers, such as a web container, application server, and database engine. Administrators increasingly execute each tier in its own managed runtime environment (MRE) to improve reliability and to manage system complexity through the fault containment and modularity offered by isolated MRE instances. Such isolation, however, necessitates expensive cross-tier communication based on protocols such as object serialization and remote procedure calls. Administrators commonly co-locate communicating MREs on a single host to reduce communication overhead and to better exploit increasing numbers of available processing cores. However, state-of-the-art MREs offer no support for more efficient communication between co-located MREs, while fast inter-process communication mechanisms, such as shared memory, are widely available as a standard operating system service on most modern platforms. To address this growing need, we present the design and implementation of XMem - type-safe, transparent, shared memory support for co-located MREs. XMem guarantees type-safety through coordinated, parallel, multi-process class loading and garbage collection. To avoid introducing any level of indirection, XMem manipulates virtual memory mapping. In addition, object sharing in XMem is fully transparent: shared objects are identical to local objects in terms of field access, synchronization, garbage collection, and method invocation, with the only difference being that shared-to-private pointers are disallowed. XMem facilitates easy integration and use by existing communication technologies and software systems, such as RMI, JNDI, JDBC, serialization/XML, and network sockets. We have implemented XMem in the open-source, production-quality HotSpot Java Virtual Machine. Our experimental evaluation, based on core communication technologies underlying J2EE, as well as using open-source server applications, indicates that XMem significantly improves throughput and response time by avoiding the overheads imposed by object serialization and network communication.", "paper_title": "XMem: Type-safe, transparent, shared memory for cross-runtime communication and coordination", "paper_id": "WOS:000257820400030"}