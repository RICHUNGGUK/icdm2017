{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "discriminative_bloom_filters"}, {"score": 0.049636680610423214, "phrase": "hash_tables"}, {"score": 0.00466102244911872, "phrase": "network_applications"}, {"score": 0.00432733352307636, "phrase": "moderate_loads"}, {"score": 0.004228016636379321, "phrase": "high_loads"}, {"score": 0.00399881984083004, "phrase": "access_time"}, {"score": 0.003943481134959376, "phrase": "non-deterministic_performance"}, {"score": 0.003644001325962353, "phrase": "multi-threaded_parallel_systems"}, {"score": 0.003414467360488913, "phrase": "hash_operations"}, {"score": 0.0032593915869553714, "phrase": "novel_fast_collision-free_hashing_scheme"}, {"score": 0.003140401552000472, "phrase": "fast_and_deterministic_hash_table_lookup"}, {"score": 0.0031113406457373427, "phrase": "dbf"}, {"score": 0.003068242064611088, "phrase": "compact_summary"}, {"score": 0.0030257422786589723, "phrase": "on-chip_memory"}, {"score": 0.00290173234777844, "phrase": "parallel_bloom_filters"}, {"score": 0.0028087949095629955, "phrase": "element_lookup"}, {"score": 0.0027827907725673845, "phrase": "parallel_membership_checks"}, {"score": 0.002744234034162797, "phrase": "on-chip_dbf"}, {"score": 0.00269365253474335, "phrase": "possible_discriminator_value"}, {"score": 0.0025952620596908773, "phrase": "discriminator_value"}, {"score": 0.0025355968118803956, "phrase": "possible_bucket"}, {"score": 0.002500456462028735, "phrase": "off-chip_hash_table"}, {"score": 0.002420339995088838, "phrase": "dbf-based_scheme"}, {"score": 0.0022052711621931144, "phrase": "off-chip_memory_accesses"}, {"score": 0.0021646022201798247, "phrase": "previous_schemes"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Network processing", " Hash table", " Bloom filter", " Cuckoo hashing", " Collision-free hashing"], "paper_abstract": "Hash tables are widely used in network applications, as they can achieve O(1) query, insert, and delete operations at moderate loads. However, at high loads, collisions are prevalent in the table, which increases the access time and induces non-deterministic performance. Slow rates and non-determinism can considerably hurt the performance and scalability of hash tables in the multi-threaded parallel systems such as ASIC/FPGA and multi-core. So it is critical to keep the hash operations faster and more deterministic. This paper presents a novel fast collision-free hashing scheme using Discriminative Bloom Filters (DBFs) to achieve fast and deterministic hash table lookup. DBF is a compact summary stored in on-chip memory. It is composed of an array of parallel Bloom filters organized by the discriminator. Each element lookup performs parallel membership checks on the on-chip DBF to produce a possible discriminator value. Then, the element plus the discriminator value is hashed to a possible bucket in an off-chip hash table for validating the match. This DBF-based scheme requires one off-chip memory access per lookup as well as less off-chip memory usage. Experiments show that our scheme achieves up to 8.5-fold reduction in the number of off-chip memory accesses per lookup than previous schemes. (C) 2013 Elsevier Ltd. All rights reserved.", "paper_title": "Fast and deterministic hash table lookup using discriminative bloom filters", "paper_id": "WOS:000316091900007"}