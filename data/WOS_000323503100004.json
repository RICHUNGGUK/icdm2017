{"auto_keywords": [{"score": 0.0369398824318344, "phrase": "candidate_pairs"}, {"score": 0.01277733323901457, "phrase": "inverted_index"}, {"score": 0.00481495049065317, "phrase": "scalable_processing_of_string_similarity_join"}, {"score": 0.004738078275822989, "phrase": "string_similarity_join"}, {"score": 0.004662427600500598, "phrase": "basic_operation"}, {"score": 0.004466519142879166, "phrase": "string_pairs"}, {"score": 0.004324985524216987, "phrase": "similarity_function"}, {"score": 0.004255902303152008, "phrase": "user-specified_threshold"}, {"score": 0.00409895142748329, "phrase": "considerable_interest"}, {"score": 0.0040334640350288, "phrase": "new_algorithms"}, {"score": 0.0038431888954930083, "phrase": "efficient_string_similarity_joins"}, {"score": 0.003701401653850141, "phrase": "two-step_filter-and-refine_approach"}, {"score": 0.0030834712590249863, "phrase": "poor_filtering_power"}, {"score": 0.0030017207229983385, "phrase": "high_verification_cost"}, {"score": 0.002859977408815691, "phrase": "filtering_power"}, {"score": 0.002724909017963099, "phrase": "multiple_prefix_filtering_method"}, {"score": 0.002681315076008658, "phrase": "different_global_orderings"}, {"score": 0.002460295872115956, "phrase": "parallel_extension"}, {"score": 0.0023189818169615135, "phrase": "mapreduce_framework"}, {"score": 0.0022696277881969896, "phrase": "extensive_experiments"}, {"score": 0.002209406458446019, "phrase": "real_and_synthetic_data_sets"}, {"score": 0.0021049977753042253, "phrase": "existing_approaches"}], "paper_keywords": ["Similarity join", " multiple filtering", " MapReduce"], "paper_abstract": "The string similarity join is a basic operation of many applications that need to find all string pairs from a collection given a similarity function and a user-specified threshold. Recently, there has been considerable interest in designing new algorithms with the assistant of an inverted index to support efficient string similarity joins. These algorithms typically adopt a two-step filter-and-refine approach in identifying similar string pairs: 1) generating candidate pairs by traversing the inverted index; and 2) verifying the candidate pairs by computing the similarity. However, these algorithms either suffer from poor filtering power (which results in high verification cost), or incur too much computational cost to guarantee the filtering power. In this paper, we propose a multiple prefix filtering method based on different global orderings such that the number of candidate pairs can be reduced significantly. We also propose a parallel extension of the algorithm that is efficient and scalable in a MapReduce framework. We conduct extensive experiments on both centralized and Hadoop systems using both real and synthetic data sets, and the results show that our proposed approach outperforms existing approaches in both efficiency and scalability.", "paper_title": "Efficient and Scalable Processing of String Similarity Join", "paper_id": "WOS:000323503100004"}