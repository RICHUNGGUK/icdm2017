{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "open_modules"}, {"score": 0.004616624583337195, "phrase": "simple_module_calculus"}, {"score": 0.004308304400698582, "phrase": "external_definitions"}, {"score": 0.004218602458288531, "phrase": "kernel_model"}, {"score": 0.004180730376667435, "phrase": "computational_paradigm"}, {"score": 0.004143196873246147, "phrase": "standard_execution"}, {"score": 0.004044740057668712, "phrase": "single_computation"}, {"score": 0.003586336325832857, "phrase": "basic_terms"}, {"score": 0.003104086547947925, "phrase": "module_operations"}, {"score": 0.002984990015496695, "phrase": "lambda_abstractions"}, {"score": 0.0028791027911595976, "phrase": "mutually_recursive_definitions"}, {"score": 0.002793730385549585, "phrase": "traditional_module_calculi"}, {"score": 0.002776961266279729, "phrase": "recursive_lambda_calculi"}, {"score": 0.002686509402739493, "phrase": "different_ways"}, {"score": 0.0026068329296254087, "phrase": "required_component"}, {"score": 0.0025678829712650437, "phrase": "purely_static_type_system"}, {"score": 0.0025219085140220773, "phrase": "static_and_run-time_checks"}, {"score": 0.0024693083555454133, "phrase": "call-by-need_strategy"}, {"score": 0.002311013816721592, "phrase": "lambda_calculi"}, {"score": 0.002290227534601535, "phrase": "module_features"}, {"score": 0.0021824773921574636, "phrase": "information_content"}, {"score": 0.0021049977753042253, "phrase": "local_substitution_rules"}], "paper_keywords": [""], "paper_abstract": "We present a simple module calculus where selection and execution of a component is possible on open modules, that is, modules that still need to import some external definitions. Hence, it provides a kernel model for a computational paradigm in which standard execution (that is, execution of a single computation described by a fragment of code) can be interleaved with operations at the meta-level, which can manipulate in various ways the context in which this computation takes place. Formally, this is achieved by introducing configurations as basic terms. These are, roughly speaking, pairs consisting of an (open, mutually recursive) collection of named components and a term representing a program running in the context of these components. Configurations can be manipulated by classical module/fragment operators, hence reduction steps can be either execution steps of the program or steps that perform module operations (called reconfiguration steps). Since configurations combine the features of lambda abstractions (first-class functions), records, environments with mutually recursive definitions and modules, the calculus extends and integrates both traditional module calculi and recursive lambda calculi. We state confluence of the calculus, and propose different ways to prevent errors arising from the lack of some required component, either by a purely static type system or by a combination of static and run-time checks. Moreover, we define a call-by-need strategy that performs module simplification only when needed and only once, leading to a generalisation of call-by-need lambda calculi that includes module features. We prove the soundness and completeness of this strategy using an approach based on information content, which also allows us to preserve confluence, even when local substitution rules are added to the calculus.", "paper_title": "A calculus of open modules: call-by-need strategy and confluence", "paper_id": "WOS:000249229800004"}