{"auto_keywords": [{"score": 0.04871565848141454, "phrase": "evolutionary_algorithm"}, {"score": 0.008219734168955906, "phrase": "kleinberg"}, {"score": 0.00481495049065317, "phrase": "time-stamped_sequences"}, {"score": 0.004584193430305955, "phrase": "time-stamped_data_sequences"}, {"score": 0.004492406361795448, "phrase": "irc_conversations"}, {"score": 0.004466519142879166, "phrase": "scientific_journal_articles"}, {"score": 0.004440780432053927, "phrase": "weblog_postings"}, {"score": 0.004215677131963292, "phrase": "higher-than-normal_frequency"}, {"score": 0.004048483412089098, "phrase": "online_world"}, {"score": 0.004013524489681638, "phrase": "increasing_number"}, {"score": 0.003990385737207714, "phrase": "periodic_content_producers"}, {"score": 0.003832092687255493, "phrase": "online_sequences"}, {"score": 0.0036907133026806327, "phrase": "event_sequences"}, {"score": 0.0035340293330075483, "phrase": "time_intervals"}, {"score": 0.0034732277874585968, "phrase": "optimal_fit"}, {"score": 0.0034134687245359406, "phrase": "optimization_procedure"}, {"score": 0.0031296996688485617, "phrase": "dynamic_programming_algorithms"}, {"score": 0.0030758329792764196, "phrase": "memory_and_efficiency_requirements"}, {"score": 0.0029794666460666646, "phrase": "long_sequences"}, {"score": 0.0029197159945990015, "phrase": "alternative_search_methods"}, {"score": 0.0026846436189970446, "phrase": "classical_dynamic_programming_algorithms"}, {"score": 0.0026460656993236354, "phrase": "shorter_time"}, {"score": 0.002608040688794517, "phrase": "different_cost_functions"}, {"score": 0.0025780134737796085, "phrase": "new_one"}, {"score": 0.0025557195732514915, "phrase": "better_fits"}, {"score": 0.0024899850926034567, "phrase": "real-world_data"}, {"score": 0.002425937226012825, "phrase": "finite_state_automata"}, {"score": 0.002363532907211947, "phrase": "uniform_distribution"}, {"score": 0.0023295585212850154, "phrase": "geometric_distribution"}, {"score": 0.002211235429059514, "phrase": "fast_fit"}, {"score": 0.0021731423856364003, "phrase": "new_data"}, {"score": 0.0021049977753042253, "phrase": "original_subsequence"}], "paper_keywords": ["Evolutionary algorithms", " Event tracking", " Data time-stamped sequences", " Burst detection"], "paper_abstract": "This paper presents an evolutionary algorithm for modeling the arrival dates in time-stamped data sequences such as newscasts, e-mails, IRC conversations, scientific journal articles or weblog postings. These models are applied to the detection of buzz (i.e. terms that occur with a higher-than-normal frequency) in them, which has attracted a lot of interest in the online world with the increasing number of periodic content producers. That is why in this paper we have used this kind of online sequences to test our system, though it is also valid for other types of event sequences. The algorithm assigns frequencies (number of events per time unit) to time intervals so that it produces an optimal fit to the data. The optimization procedure is a trade off between accurately fitting the data and avoiding too many frequency changes, thus overcoming the noise inherent in these sequences. This process has been traditionally performed using dynamic programming algorithms, which are limited by memory and efficiency requirements. This limitation can be a problem when dealing with long sequences, and suggests the application of alternative search methods with some degree of uncertainty to achieve tractability, such as the evolutionary algorithm proposed in this paper. This algorithm is able to reach the same solution quality as those classical dynamic programming algorithms, but in a shorter time. We also test different cost functions and propose a new one that yields better fits than the one originally proposed by Kleinberg on real-world data. Finally, several distributions of states for the finite state automata are tested, with the result that an uniform distribution produces much better fits than the geometric distribution also proposed by Kleinberg. We also present a variant of the evolutionary algorithm, which achieves a fast fit of a sequence extended with new data, by taking advantage of the fit obtained for the original subsequence.", "paper_title": "Automatic detection of trends in time-stamped sequences: an evolutionary approach", "paper_id": "WOS:000270883200002"}