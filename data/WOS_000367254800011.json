{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "production_parallel_programs"}, {"score": 0.004768378525561471, "phrase": "large_scientific_code_bases"}, {"score": 0.004608879242346434, "phrase": "runtime_libraries"}, {"score": 0.004520132822496416, "phrase": "multiple_programming_languages"}, {"score": 0.0043477114072437316, "phrase": "conservative_synchronization_patterns"}, {"score": 0.004284755353695709, "phrase": "suboptimal_performance"}, {"score": 0.004121275290411653, "phrase": "context-sensitive_dynamic_optimizations"}, {"score": 0.003983334573043943, "phrase": "program_execution"}, {"score": 0.0038499929374478125, "phrase": "data_race_detection"}, {"score": 0.0037392451233558234, "phrase": "redundant_barriers"}, {"score": 0.003631671435460452, "phrase": "initial_learning"}, {"score": 0.003527181559366122, "phrase": "future_instances"}, {"score": 0.003092842645798083, "phrase": "nwchem"}, {"score": 0.002861062731782219, "phrase": "global_arrays"}, {"score": 0.0028333356794133053, "phrase": "comex"}, {"score": 0.0028058765785670546, "phrase": "dmapp"}, {"score": 0.002765198291345984, "phrase": "mpi."}, {"score": 0.002711842889248926, "phrase": "surprisingly_high_fraction"}, {"score": 0.00259554612218815, "phrase": "production_runs"}, {"score": 0.0025578967205807843, "phrase": "redundancy_elimination"}, {"score": 0.0025207920578878894, "phrase": "application_speedups"}, {"score": 0.002389276641014013, "phrase": "valuable_insight"}, {"score": 0.0023546121947302877, "phrase": "application_behavior"}, {"score": 0.002297949552105756, "phrase": "nwchem_developers"}, {"score": 0.002199363362666037, "phrase": "holistic_context-sensitive_analyses"}, {"score": 0.0021569129153653777, "phrase": "domain_science"}, {"score": 0.0021049977753042253, "phrase": "associated_runtime_software_stack"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Barrier Elision", " Synchronization", " PGAS", " NWChem", " HPC", " Dynamic Analysis", " Dynamic Optimization"], "paper_abstract": "Large scientific code bases are often composed of several layers of runtime libraries, implemented in multiple programming languages. In such situation, programmers often choose conservative synchronization patterns leading to suboptimal performance. In this paper, we present context-sensitive dynamic optimizations that elide barriers redundant during the program execution. In our technique, we perform data race detection alongside the program to identify redundant barriers in their calling contexts; after an initial learning, we start eliding all future instances of barriers occurring in the same calling context. We present an automatic on-the-fly optimization and a multi-pass guided optimization. We apply our techniques to NWChem-a 6 million line computational chemistry code written in C/C++/Fortran that uses several runtime libraries such as Global Arrays, ComEx, DMAPP, and MPI. Our technique elides a surprisingly high fraction of barriers (as many as 63%) in production runs. This redundancy elimination translates to application speedups as high as 14% on 2048 cores. Our techniques also provided valuable insight about the application behavior, later used by NWChem developers. Overall, we demonstrate the value of holistic context-sensitive analyses that consider the domain science in conjunction with the associated runtime software stack.", "paper_title": "Barrier Elision for Production Parallel Programs", "paper_id": "WOS:000367254800011"}