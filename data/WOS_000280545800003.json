{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multithreaded_programs"}, {"score": 0.004641351004344458, "phrase": "end-to-end_security"}, {"score": 0.004119049028319832, "phrase": "sensitive_information"}, {"score": 0.0038981499110532273, "phrase": "mobile_code"}, {"score": 0.0035233696341819437, "phrase": "enforcement_mechanisms"}, {"score": 0.003427540517249369, "phrase": "information_security"}, {"score": 0.003097865379563127, "phrase": "modular_extensions"}, {"score": 0.0030414140732789186, "phrase": "sequential_semantics"}, {"score": 0.002985988377995789, "phrase": "sequential_security_typing"}, {"score": 0.00290473242917264, "phrase": "sequential_security-type_preserving_compilation"}, {"score": 0.0024389277933858054, "phrase": "multithreaded_source_programs"}, {"score": 0.0023725232579531273, "phrase": "sequential_ones"}, {"score": 0.0021049977753042253, "phrase": "wide_class"}], "paper_keywords": ["Security", " Language", " Noninterference", " type systems", " schedulers", " compilers"], "paper_abstract": "End-to-End security of mobile code requires that the code neither intentionally nor accidentally propagates sensitive information to an adversary. Although mobile code is commonly multithreaded low-level code, there lack enforcement mechanisms that ensure information security for such programs. The modularity is three-fold: we give modular extensions of sequential semantics, sequential security typing, and sequential security-type preserving compilation that allow us enforcing security for multithreaded programs. Thanks to the modularity, there are no more restrictions on multithreaded source programs than on sequential ones, and yet we guarantee that their compilations are provably secure for a wide class of schedulers.", "paper_title": "Security of Multithreaded Programs by Compilation", "paper_id": "WOS:000280545800003"}