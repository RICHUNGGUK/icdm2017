{"auto_keywords": [{"score": 0.04613389471316297, "phrase": "np"}, {"score": 0.010177802838850124, "phrase": "probabilistic_polynomial-time_algorithms"}, {"score": 0.008202700062539437, "phrase": "worst_case"}, {"score": 0.00481495049065317, "phrase": "np_languages"}, {"score": 0.0043399888458640025, "phrase": "bpp"}, {"score": 0.004055652445791872, "phrase": "probabilistic_polynomial-time_algorithm"}, {"score": 0.00389404213807752, "phrase": "polynomially_samplable_distribution"}, {"score": 0.0035095935622207956, "phrase": "first_worst-case"}, {"score": 0.0034780071331554003, "phrase": "average-case_reduction"}, {"score": 0.003036832649117453, "phrase": "pre-requisite_assumption"}, {"score": 0.0029959082125682918, "phrase": "one-way_functions"}, {"score": 0.002942196368747418, "phrase": "even_if_not_a_sufficient_assumption"}, {"score": 0.0027867539356701302, "phrase": "fixed_distribution"}, {"score": 0.0027367816003722252, "phrase": "np-complete_languages"}, {"score": 0.0026634937939104177, "phrase": "quasi-polynomial_time"}, {"score": 0.0023571835517819124, "phrase": "independent_interest"}, {"score": 0.0021925693701505245, "phrase": "sat"}], "paper_keywords": ["average-case complexity", " worst-case to average-case reductions", " foundations of cryptography", " pseudo classes"], "paper_abstract": "We prove that if NP not subset of BPP, i.e., if SAT is worst-case hard, then for every probabilistic polynomial-time algorithm trying to decide SAT, there exists some polynomially samplable distribution that is hard for it. That is, the algorithm often errs on inputs from this distribution. This is the first worst-case to average-case reduction for NP of any kind. We stress however, that this does not mean that there exists one fixed samplable distribution that is hard for all probabilistic polynomial-time algorithms, which is a pre-requisite assumption needed for one-way functions and cryptography (even if not a sufficient assumption). Nevertheless, we do show that there is a fixed distribution on instances of NP-complete languages, that is samplable in quasi-polynomial time and is hard for all probabilistic polynomial-time algorithms (unless NP is easy in the worst case). Our results are based on the following lemma that may be of independent interest: Given the description of an efficient (probabilistic) algorithm that fails to solve SAT in the worst case, we can efficiently generate at most three Boolean formulae (of increasing lengths) such that the algorithm errs on at least one of them.", "paper_title": "If NP languages are hard on the worst-case, then it is easy to find their hard instances", "paper_id": "WOS:000252462800004"}