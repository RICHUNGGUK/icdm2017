{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "embedded_software"}, {"score": 0.004694092086199672, "phrase": "aspect-oriented_software_testing"}, {"score": 0.00459568664065473, "phrase": "important_alternative"}, {"score": 0.004556901872357751, "phrase": "conventional_procedural_and_object-oriented_testing_techniques"}, {"score": 0.004151188559520802, "phrase": "industrial_application"}, {"score": 0.004081385289516914, "phrase": "first_study"}, {"score": 0.004012751049253625, "phrase": "code-level_aspects"}, {"score": 0.0039620308501590795, "phrase": "non-functional_properties"}, {"score": 0.003829877278269543, "phrase": "test_aspect_code"}, {"score": 0.0037495207047193034, "phrase": "high-level_requirements"}, {"score": 0.003593812067062062, "phrase": "test_aspects"}, {"score": 0.0035183910023550246, "phrase": "second_study"}, {"score": 0.003459191419478298, "phrase": "high-level_visual_scenario-based_models"}, {"score": 0.003204841443605308, "phrase": "scenario-based_tests"}, {"score": 0.0031110402375026016, "phrase": "live_sequence_charts"}, {"score": 0.0030457198309616694, "phrase": "test_code"}, {"score": 0.0029691377785333872, "phrase": "modified_version"}, {"score": 0.0026930689173215766, "phrase": "tracer"}, {"score": 0.0026252106881752067, "phrase": "model-based_trace_visualization"}, {"score": 0.0024632148715152393, "phrase": "conventional_techniques"}, {"score": 0.0021319959284827896, "phrase": "technological_and_other_barriers"}, {"score": 0.0021049977753042253, "phrase": "future_successful_use"}], "paper_keywords": ["Software testing", " Aspect-oriented programming", " Embedded software", " Case studies"], "paper_abstract": "Aspect-oriented software testing is emerging as an important alternative to conventional procedural and object-oriented testing techniques. This paper reports experiences from two case studies where aspects were used for the testing of embedded software in the context of an industrial application. In the first study, we used code-level aspects for testing non-functional properties. The methodology we used for deriving test aspect code was based on translating high-level requirements into test objectives, which were then implemented using test aspects in AspectC++. In the second study, we used high-level visual scenario-based models for the test specification, test generation, and aspect-based test execution. To specify scenario-based tests, we used a UML2-compliant variant of live sequence charts. To automatically generate test code from the models, a modified version of the S2A Compiler, outputting AspectC++ code, was used. Finally, to examine the results of the tests, we used the Tracer, a prototype tool for model-based trace visualization and exploration. The results of the two case studies show that aspects offer benefits over conventional techniques in the context of testing embedded software; these benefits are discussed in detail. Finally, towards the end of the paper, we also discuss the lessons learned, including the technological and other barriers to the future successful use of aspects in the testing of embedded software in industry.", "paper_title": "Using aspects for testing of embedded software: experiences from two industrial case studies", "paper_id": "WOS:000334917700003"}