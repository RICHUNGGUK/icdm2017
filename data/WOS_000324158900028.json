{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "data_layout_optimization_for_gpgpu_architectures"}, {"score": 0.004596295252559861, "phrase": "general-purpose_applications"}, {"score": 0.00443308765153716, "phrase": "gpgpu_architectures"}, {"score": 0.0043875257506180865, "phrase": "new_programming_models"}, {"score": 0.004342430078306461, "phrase": "e._g."}, {"score": 0.004297795905522757, "phrase": "compute_unified_device_architecture"}, {"score": 0.004081385289516914, "phrase": "programming_general-purpose_computations"}, {"score": 0.003936389070602614, "phrase": "high-performance_cuda_codes"}, {"score": 0.0035866734383189396, "phrase": "memory_space"}, {"score": 0.0034236045013591437, "phrase": "unique_features"}, {"score": 0.003370907075333389, "phrase": "custom_gpgpu_memory_hierarchy"}, {"score": 0.0032176163279340206, "phrase": "automatic_data_layout_transformation_framework"}, {"score": 0.003151736708029235, "phrase": "key_issues"}, {"score": 0.0030872017736888113, "phrase": "gpgpu_memory_hierarchy"}, {"score": 0.0028127163745564777, "phrase": "widely_applicable_strategy"}, {"score": 0.002755104031926742, "phrase": "novel_concept"}, {"score": 0.0025100713447593773, "phrase": "affine_loop_nests"}, {"score": 0.0023834640793589414, "phrase": "coarse_grain_and_fine_grain_parallelization_levels"}, {"score": 0.0022168460543913787, "phrase": "nvidia_cuda_gpu_device"}, {"score": 0.002137947680862631, "phrase": "proposed_data_transformation_approach"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Experimentation", " GPGPU", " Data Layout Transformation", " CUDA", " Optimization"], "paper_abstract": "GPUs are being widely used in accelerating general-purpose applications, leading to the emergence of GPGPU architectures. New programming models, e. g., Compute Unified Device Architecture (CUDA), have been proposed to facilitate programming general-purpose computations in GPGPUs. However, writing high-performance CUDA codes manually is still tedious and difficult. In particular, the organization of the data in the memory space can greatly affect the performance due to the unique features of a custom GPGPU memory hierarchy. In this work, we propose an automatic data layout transformation framework to solve the key issues associated with a GPGPU memory hierarchy (i.e., channel skewing, data coalescing, and bank conflicts). Our approach employs a widely applicable strategy based on a novel concept called data localization. Specifically, we try to optimize the layout of the arrays accessed in affine loop nests, for both the device memory and shared memory, at both coarse grain and fine grain parallelization levels. We performed an experimental evaluation of our data layout optimization strategy using 15 benchmarks on an NVIDIA CUDA GPU device. The results show that the proposed data transformation approach brings around 4.3X speedup on average.", "paper_title": "Data Layout Optimization for GPGPU Architectures", "paper_id": "WOS:000324158900028"}