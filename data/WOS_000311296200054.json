{"auto_keywords": [{"score": 0.03432017230737595, "phrase": "oscilloscope"}, {"score": 0.02631246491296812, "phrase": "similar_bugs"}, {"score": 0.008713761037964679, "phrase": "debugging_knowledge"}, {"score": 0.004786620949516712, "phrase": "trace-based_bug_search"}, {"score": 0.004722100796933258, "phrase": "bql"}, {"score": 0.0042914569949699015, "phrase": "similar_bug"}, {"score": 0.004069352078974872, "phrase": "similar_symptoms"}, {"score": 0.00384731849108269, "phrase": "systematic_capture"}, {"score": 0.0036914757355166966, "phrase": "core_challenge"}, {"score": 0.0035210572541244664, "phrase": "semantic_bug_information"}, {"score": 0.003469426649835834, "phrase": "execution_traces"}, {"score": 0.0034185505275141077, "phrase": "bug_semantics"}, {"score": 0.0033684179374769605, "phrase": "novel_tool"}, {"score": 0.003348570667660301, "phrase": "language_support"}, {"score": 0.003165739628969694, "phrase": "bug_trace"}, {"score": 0.002940248454513279, "phrase": "target_bug"}, {"score": 0.0027469703311742647, "phrase": "flexible_query_language"}, {"score": 0.002659064774118166, "phrase": "open_infrastructure"}, {"score": 0.002620040660435039, "phrase": "trace_collection_engine"}, {"score": 0.0025815972882443842, "phrase": "hadoop"}, {"score": 0.002404706573379854, "phrase": "oscilloscope_records"}, {"score": 0.0023905240285582658, "phrase": "up-loads_bug"}, {"score": 0.0023139986108451967, "phrase": "junit_test"}, {"score": 0.002246553137021003, "phrase": "popular_open-source_projects"}, {"score": 0.0021049977753042253, "phrase": "open_bugs"}], "paper_keywords": ["Design", " Languages", " Reliability", " OSCILLOSCOPE", " reusing debugging knowledge"], "paper_abstract": "Some bugs, among the millions that exist, are similar to each other. One bug-fixing tactic is to search for similar bugs that have been reported and resolved in the past. A fix for a similar bug can help a developer understand a bug, or even directly fix it. Studying bugs with similar symptoms, programmers may determine how to detect or resolve them. To speed debugging, we advocate the systematic capture and reuse of debugging knowledge, much of which is currently wasted. The core challenge here is how to search for similar bugs. To tackle this problem, we exploit semantic bug information in the form of execution traces, which precisely capture bug semantics. This paper introduces novel tool and language support for semantically querying and analyzing bugs. We describe OSCILLOSCOPE, an Eclipse plugin, that uses a bug trace to exhaustively search its database for similar bugs and return their bug reports. OSCILLOSCOPE displays the traces of the bugs it returns against the trace of the target bug, so a developer can visually examine the quality of the matches. OSCILLOSCOPE rests on our bug query language (BQL), a flexible query language over traces. To realize OSCILLOSCOPE, we developed an open infrastructure that consists of a trace collection engine, BQL, a Hadoop-based query engine for BQL, a trace-indexed bug database, as well as a web-based frontend. OSCILLOSCOPE records and up-loads bug traces to its infrastructure; it does so automatically when a JUnit test fails. We evaluated OSCILLOSCOPE on bugs collected from popular open-source projects. We show that OSCILLOSCOPE accurately and efficiently finds similar bugs, some of which could have been immediately used to fix open bugs.", "paper_title": "Reusing Debugging Knowledge via Trace-based Bug Search", "paper_id": "WOS:000311296200054"}