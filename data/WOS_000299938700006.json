{"auto_keywords": [{"score": 0.042980055209087153, "phrase": "coherence_controller"}, {"score": 0.038297744818989336, "phrase": "winning_processor"}, {"score": 0.015068988042376935, "phrase": "shared_data"}, {"score": 0.00481495049065317, "phrase": "effcient_handling_of_lock_hand-off"}, {"score": 0.004787595063253874, "phrase": "dsm_multiprocessors"}, {"score": 0.004760394308239882, "phrase": "buffering_coherence_controllers"}, {"score": 0.004706453355638515, "phrase": "parallel_programs"}, {"score": 0.004666397248938625, "phrase": "major_performance_bottleneck"}, {"score": 0.0046398818698302835, "phrase": "multiprocessor_systems"}, {"score": 0.00438283914152565, "phrase": "lock_hand-off"}, {"score": 0.0034297140422566577, "phrase": "key_observation"}, {"score": 0.003371508176308189, "phrase": "hardware_mechanism"}, {"score": 0.003166384930533443, "phrase": "lock_line"}, {"score": 0.0031215289677725693, "phrase": "inexpensive_implementation"}, {"score": 0.003007846011394511, "phrase": "critical_section"}, {"score": 0.0028087048250773766, "phrase": "whole_parallel_computation"}, {"score": 0.002585539416877115, "phrase": "low_synchronization_rates"}, {"score": 0.0025343769150179764, "phrase": "large_amount"}, {"score": 0.002519945420045647, "phrase": "synchronization_activity"}, {"score": 0.002442025065383455, "phrase": "execution_time"}, {"score": 0.002421194376091249, "phrase": "lock_stall_time"}, {"score": 0.002286781334850213, "phrase": "previously_proposed_technique"}, {"score": 0.0021971473452127126, "phrase": "significantly_lower_execution_time"}, {"score": 0.0021784009230363627, "phrase": "bypassing_scheme"}, {"score": 0.0021049977753042253, "phrase": "key_hardware_and_software_parameters"}], "paper_keywords": ["distributed shared memory multiprocessors", " synchronization", " buffer coherence controller", " request bypass"], "paper_abstract": "Synchronization in parallel programs is a major performance bottleneck in multiprocessor systems. Shared data is protected by locks and a lot of time is spent on the competition arising at the lock hand-off. In order to be serialized, requests to the same cache line can either be bounced (NACKed) or buffered in the coherence controller. In this paper, we focus mainly on systems whose coherence controllers buffer requests. In a lock hand-off, a burst of requests to the same line arrive at the coherence controller. During lock hand-off only the requests from the winning processor contribute to progress of the computation, since the winning processor is the only one that will advance the work. This key observation leads us to propose a hardware mechanism we call request bypassing, which allows requests from the winning processor to bypass the requests buffered in the coherence controller keeping the lock line. We present an inexpensive implementation of request bypassing that reduces the time spent on all the execution phases of a critical section (acquiring the lock, accessing shared data, and releasing the lock) and which, as a consequence, speeds up the whole parallel computation. This mechanism requires neither compiler or programmer support nor ISA or coherence protocol changes. By simulating a 32-processor system, we show that using request bypassing does not degrade but rather improves performance in three applications with low synchronization rates, while in those having a large amount of synchronization activity (the remaining four), we see reductions in execution time and in lock stall time ranging from 14% to 39% and from 52% to 71%, respectively. We compare request bypassing with a previously proposed technique called read combining and with a system that bounces requests, observing a significantly lower execution time with the bypassing scheme. Finally, we analyze the sensitivity of our results to some key hardware and software parameters.", "paper_title": "Effcient Handling of Lock Hand-off in DSM Multiprocessors with Buffering Coherence Controllers", "paper_id": "WOS:000299938700006"}