{"auto_keywords": [{"score": 0.04923064775074392, "phrase": "free_tree"}, {"score": 0.00481495049065317, "phrase": "frequent_free_tree_mining"}, {"score": 0.004563427013973105, "phrase": "computational_biology"}, {"score": 0.004530894050040479, "phrase": "pattern_recognition"}, {"score": 0.00449859196755507, "phrase": "computer_networks"}, {"score": 0.004466519142879166, "phrase": "xml_databases"}, {"score": 0.004294145092032327, "phrase": "computationally_efficient_algorithm"}, {"score": 0.0041136473765874815, "phrase": "frequently-occurred_free_trees"}, {"score": 0.0037615180375561805, "phrase": "canditate_generation"}, {"score": 0.0036815763368083197, "phrase": "frequency_counting_step"}, {"score": 0.0035648266669315943, "phrase": "candidate_requent_free_tree"}, {"score": 0.003464150192089816, "phrase": "subgraph_isomorphism_problem"}, {"score": 0.0034040582903493016, "phrase": "np"}, {"score": 0.003318423751430509, "phrase": "key_issue"}, {"score": 0.0032246835734680377, "phrase": "false_positives"}, {"score": 0.0031902155632863236, "phrase": "candidate_generation_step"}, {"score": 0.0030889995517870525, "phrase": "false_positive_reduction"}, {"score": 0.002896071795090179, "phrase": "candidate_generation"}, {"score": 0.002824331600674865, "phrase": "infrequent_candidates"}, {"score": 0.002724909017963099, "phrase": "complete_set"}, {"score": 0.0027054473441439422, "phrase": "frequent_free_trees"}, {"score": 0.002647890142618442, "phrase": "graph_database"}, {"score": 0.0026289770980696286, "phrase": "growing_vertices"}, {"score": 0.0026008598632891837, "phrase": "limited_range"}, {"score": 0.0023024126375034066, "phrase": "extensive_experimental_studies"}, {"score": 0.0022777800735119405, "phrase": "real_application_dataset"}, {"score": 0.002253410447951689, "phrase": "synthetic_dataset"}, {"score": 0.002229300966775032, "phrase": "experiment_results"}, {"score": 0.002174041708084857, "phrase": "up-to-date_algorithms"}, {"score": 0.0021201492891323587, "phrase": "mining_frequent_free_trees"}, {"score": 0.0021049977753042253, "phrase": "large_graph_databases"}], "paper_keywords": ["structural pattern mining", " graph database", " free tree"], "paper_abstract": "Free tree, as a special undirected, acyclic and connected graph, is extensively used in computational biology, pattern recognition, computer networks, XML databases, etc. In this paper, we present a computationally efficient algorithm F3TM (Fast Frequent Free Tree Mining) to find all frequently-occurred free trees in a graph database, D = {g(1), g(2), ... , G(N}). Two key steps of F3TM are canditate generation and frequency counting. The frequency counting step is to compute how many graphs in D containing a candidate requent free tree, which is proved to be the subgraph isomorphism problem in nature and is NP-complete. Therefore, the key issue becomes how to reduce the number of false positives in the candidate generation step. Based on our observations, the cost of false positive reduction can be prohibitive itself. In this paper, we focus ourselves on how to reduce the candidate generation cost and minimize the number of infrequent candidates being generated. We prove a theorem that the complete set of frequent free trees can be discovered from a graph database by growing vertices on a limited range of positions of a free tree. We propose two pruning algorithms, namely, automorphism-based pruning and canonical mapping-based pruning, which significantly reduce the candidate generation cost. We conducted extensive experimental studies using a real application dataset and a synthetic dataset. The experiment results show that our algorithm F3TM outperforms the up-to-date algorithms by an order of magnitude in mining frequent free trees in large graph databases.", "paper_title": "Fast frequent free tree mining in graph databases", "paper_id": "WOS:000252830100003"}