{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "common_ancestor"}, {"score": 0.006187049736655051, "phrase": "lowest_common_ancestor"}, {"score": 0.0046221918332842995, "phrase": "directed_acyclic_graph"}, {"score": 0.003708289015692081, "phrase": "all-pairs_common_ancestor"}, {"score": 0.003503497128638099, "phrase": "all-pairs_junction"}, {"score": 0.00343256439490901, "phrase": "apca"}, {"score": 0.0033937776228549557, "phrase": "existence_version"}, {"score": 0.003378385493203297, "phrase": "bender_et_al"}, {"score": 0.0033326252993345685, "phrase": "apca_existence"}, {"score": 0.003170060683860338, "phrase": "fast_boolean_matrix_multiplication"}, {"score": 0.003105857752110456, "phrase": "kowaluk"}, {"score": 0.003091767402370757, "phrase": "lingas"}, {"score": 0.003056819704624705, "phrase": "aplca"}, {"score": 0.0028552516608068073, "phrase": "apj."}, {"score": 0.002778385486855157, "phrase": "essentially_the_time"}, {"score": 0.0027594936602962075, "phrase": "transitive_closure"}, {"score": 0.002722093453065922, "phrase": "vertices_s"}, {"score": 0.0026248126327476306, "phrase": "s._a_lowest_common_ancestor"}, {"score": 0.002462841318533952, "phrase": "k-aplca_problems"}, {"score": 0.002305589818994465, "phrase": "k-apca_problem"}, {"score": 0.002208035721125305, "phrase": "essentially_optimal_algorithm"}, {"score": 0.0021436720821474973, "phrase": "k-aplca_problem"}], "paper_keywords": ["algorithm", " directed acyclic graph", " common ancestor", " fast matrix multiplication"], "paper_abstract": "A common ancestor of two vertices u, v in a directed acyclic graph is a vertex w that can reach both. A {u, v}-junction is a common ancestor w so that there are two paths, one from w to u and the other from w to v, that are internally vertex-disjoint. A lowest common ancestor (LCA) of u and v is a common ancestor w so that no other common ancestor of u and v is reachable from w. Every {u, v}-LCA is a {u, v}-junction, but the converse is not true. Similarly, not every common ancestor is a junction. The all-pairs common ancestor (APCA) problem computes (or determines the non-existence of) a common ancestor for all pairs of vertices. Similarly defined are the all-pairs junction (APJ) and the all-pairs LCA (APLCA) problems. The APCA problem also has an existence version. Bender et al. obtained an algorithm for APCA existence by reduction to transitive closure. Their algorithm runs in (O) over tilde (n(omega)) time where omega < 2.376 is the exponent of fast Boolean matrix multiplication and n is the number of vertices. Kowaluk and Lingas obtained an algorithm for APLCA whose running time is O (n(2+1)/((4-omega))) <= o(n(2.616)). Our main result is an <(O)over tilde> (n(omega)) time algorithm for APJ. Thus, junctions for all pairs can also be computed in essentially the time needed for transitive closure. For a subset of vertices S, a common ancestor of S is a vertex that can reach each vertex of S. A lowest common ancestor of S is a common ancestor to of S so that no other common ancestor of S is reachable from w. For k >= 2, the k-APCA and the k-APLCA problems are to find, respectively, a common ancestor and a lowest common ancestor for each k-set of vertices. We prove that for all fixed k >= 8, the k-APCA problem can be solved in (O) over tilde (n(k)) time, thereby obtaining an essentially optimal algorithm. We also prove that for all k >= 4, the k-APLCA problem can be solved in (O) over tilde (n(k+1/2)) time. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "All-pairs disjoint paths from a common ancestor in O (n(omega)) time", "paper_id": "WOS:000256199100011"}