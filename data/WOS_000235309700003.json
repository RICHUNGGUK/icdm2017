{"auto_keywords": [{"score": 0.038059560103908784, "phrase": "atomicity_violations"}, {"score": 0.015719716506582538, "phrase": "multithreaded_programs"}, {"score": 0.009815985709570952, "phrase": "block-based_algorithm"}, {"score": 0.004772831182829751, "phrase": "atomicity"}, {"score": 0.004710306419574744, "phrase": "correctness_condition"}, {"score": 0.004669085371587273, "phrase": "concurrent_systems"}, {"score": 0.004468304427278713, "phrase": "concurrent_execution"}, {"score": 0.00427612041204006, "phrase": "serial_execution"}, {"score": 0.0035705347414368726, "phrase": "subtle_errors"}, {"score": 0.00346223706087128, "phrase": "traditional_debugging_and_testing_techniques"}, {"score": 0.0033572130837348623, "phrase": "runtime_detection"}, {"score": 0.003101503914610488, "phrase": "commutativity_properties"}, {"score": 0.002941913249957503, "phrase": "relevant_information"}, {"score": 0.0024451427672857458, "phrase": "multilockset_algorithm"}, {"score": 0.0024130437638400404, "phrase": "data_races"}, {"score": 0.0023918783117166326, "phrase": "dynamic_escape_analysis"}, {"score": 0.0021049977753042253, "phrase": "reduction-based_algorithm"}], "paper_keywords": ["concurrent programming", " testing and debugging", " Java", " data race", " atomicity"], "paper_abstract": "Atomicity is a correctness condition for concurrent systems. Informally, atomicity is the property that every concurrent execution of a set of transactions is equivalent to some serial execution of the same transactions. In multithreaded programs, executions of procedures ( or methods) can be regarded as transactions. Correctness in the presence of concurrency typically requires atomicity of these transactions. Tools that automatically detect atomicity violations can uncover subtle errors that are hard to find with traditional debugging and testing techniques. This paper describes two algorithms for runtime detection of atomicity violations and compares their cost and effectiveness. The reduction-based algorithm checks atomicity based on commutativity properties of events in a trace; the block-based algorithm efficiently represents the relevant information about a trace as a set of blocks (i.e., pairs of events plus associated synchronizations) and checks atomicity by comparing each block with other blocks. To improve the efficiency and accuracy of both algorithms, we incorporate a multilockset algorithm for checking data races, dynamic escape analysis, and happen-before analysis. Experiments show that both algorithms are effective in finding atomicity violations. The block-based algorithm is more accurate but more expensive than the reduction-based algorithm.", "paper_title": "Runtime analysis of atomicity for multithreaded programs", "paper_id": "WOS:000235309700003"}