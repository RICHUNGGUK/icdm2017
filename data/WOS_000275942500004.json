{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "global_snapshots"}, {"score": 0.015492998098236694, "phrase": "existing_algorithms"}, {"score": 0.0047797212183363835, "phrase": "large_distributed_systems"}, {"score": 0.004675565200598801, "phrase": "distributed_systems"}, {"score": 0.0045736684402340275, "phrase": "underlying_topology"}, {"score": 0.004360412703519539, "phrase": "global_snapshot"}, {"score": 0.004281053243493438, "phrase": "first_class_use_control_messages"}, {"score": 0.0040366412779632085, "phrase": "n_processors"}, {"score": 0.00396315099839886, "phrase": "second_class_use_control_messages"}, {"score": 0.0038624981944755813, "phrase": "vector_counter_method"}, {"score": 0.0037643920253363776, "phrase": "multiple_control_messages"}, {"score": 0.0036553070575015344, "phrase": "message_history"}, {"score": 0.0034464962568390265, "phrase": "large_systems"}, {"score": 0.003408688677676014, "phrase": "logical_topology"}, {"score": 0.0033712944392793195, "phrase": "communication_layer"}, {"score": 0.0033343665797631932, "phrase": "mpi"}, {"score": 0.002985988377995789, "phrase": "grid-based_algorithm"}, {"score": 0.002673957615079041, "phrase": "size_messages"}, {"score": 0.0026446021865907197, "phrase": "tree-based_algorithm"}, {"score": 0.002539689093411356, "phrase": "total_number"}, {"score": 0.00247509835229599, "phrase": "centralized_algorithm"}, {"score": 0.00226583335721762, "phrase": "centralized_and_tree-based_algorithms"}, {"score": 0.002175913488493802, "phrase": "message_complexity"}, {"score": 0.0021049977753042253, "phrase": "stable_predicates"}], "paper_keywords": ["Checkpointing", " global snapshots", " stable predicates"], "paper_abstract": "Existing algorithms for global snapshots in distributed systems are not scalable when the underlying topology is complete. There are primarily two classes of existing algorithms for computing a global snapshot. Algorithms in the first class use control messages of size O(1) but require O(N) space and O(N) messages per processor in a network with N processors. Algorithms in the second class use control messages (such as rotating tokens with vector counter method) of size O(N), use multiple control messages per channel, or require recording of message history. As a result, algorithms in both of these classes are not efficient in large systems when the logical topology of the communication layer such as MPI is complete. In this paper, we propose three scalable algorithms for global snapshots: a grid-based, a tree-based, and a centralized algorithm. The grid-based algorithm uses O(N) space but only O(root N) messages per processor each of size O(root N). The tree-based and centralized algorithms use only O(1) size messages. The tree-based algorithm requires O(1) space and O(log N log(W/N)) messages per processor where W is the total number of messages in transit. The centralized algorithm requires O(1) space and O(log(W/N)) messages per processor. We also have a matching lower bound for this problem. We also present hybrid of centralized and tree-based algorithms that allow trade-off between the decentralization and the message complexity. Our algorithms have applications in checkpointing, detecting stable predicates, and implementing synchronizers.", "paper_title": "Efficient Algorithms for Global Snapshots in Large Distributed Systems", "paper_id": "WOS:000275942500004"}