{"auto_keywords": [{"score": 0.0497037705756037, "phrase": "predicate_abstraction"}, {"score": 0.004815404499144809, "phrase": "templates"}, {"score": 0.0045748683993128425, "phrase": "quantified_and_boolean_structure"}, {"score": 0.004195418010131832, "phrase": "different_strengths"}, {"score": 0.0040176151419992956, "phrase": "required_sophisticated_program_invariants"}, {"score": 0.00398618614165204, "phrase": "smt"}, {"score": 0.00384731849108269, "phrase": "iterative_approach"}, {"score": 0.003728000957725218, "phrase": "least_fixed-point"}, {"score": 0.003640938643675543, "phrase": "greatest_fixed-point"}, {"score": 0.0035699363258657212, "phrase": "third_algorithm"}, {"score": 0.0035141291835319682, "phrase": "based_approach"}, {"score": 0.0034185505275141077, "phrase": "key_idea"}, {"score": 0.003299460925313939, "phrase": "invariant_discovery"}, {"score": 0.0032350961776525075, "phrase": "optimal_solutions"}, {"score": 0.0030494153169181334, "phrase": "template_formula"}, {"score": 0.0029547698888028697, "phrase": "preliminary_experiments"}, {"score": 0.002807178116892454, "phrase": "small_but_complicated_programs"}, {"score": 0.0027415611720084006, "phrase": "program_properties"}, {"score": 0.0025436978068459565, "phrase": "full_correctness_proofs"}, {"score": 0.002332322771009122, "phrase": "worst-case_upper_bounds"}, {"score": 0.0022333012657436307, "phrase": "previously_considered_properties"}, {"score": 0.0021049977753042253, "phrase": "previous_techniques"}], "paper_keywords": ["Languages", " Verification", " Theory", " Algorithms", " Predicate abstraction", " Quantified Invariants", " Template Invariants", " Iterative Fixed-point", " Constraint-based Fixed-point", " Weakest Preconditions", " SMT Solvers"], "paper_abstract": "We address the problem of automatically generating invariants with quantified and boolean structure for proving the validity of given assertions or generating pre-conditions under which the assertions are valid. We present three novel algorithms, having different strengths, that combine template and predicate abstraction based formalisms to discover required sophisticated program invariants using SMT solvers. Two of these algorithms use an iterative approach to compute fixed-points ( one computes a least fixed-point and the other computes a greatest fixed-point), while the third algorithm uses a constraint based approach to encode the fixed-point. The key idea in all these algorithms is to reduce the problem of invariant discovery to that of finding optimal solutions for unknowns ( over conjunctions of some predicates from a given set) in a template formula such that the formula is valid. Preliminary experiments using our implementation of these algorithms show encouraging results over a benchmark of small but complicated programs. Our algorithms can verify program properties that, to our knowledge, have not been automatically verified before. In particular, our algorithms can generate full correctness proofs for sorting algorithms ( which requires nested universally-existentially quantified invariants) and can also generate preconditions required to establish worst-case upper bounds of sorting algorithms. Furthermore, for the case of previously considered properties, in particular sortedness in sorting algorithms, our algorithms take less time than reported by previous techniques.", "paper_title": "Program Verification using Templates over Predicate Abstraction", "paper_id": "WOS:000267268400020"}