{"auto_keywords": [{"score": 0.03926758950205556, "phrase": "data_parallel_regions"}, {"score": 0.03889478330403322, "phrase": "gpu"}, {"score": 0.015615587943492834, "phrase": "heterogeneous_processors"}, {"score": 0.014051700728315634, "phrase": "control_flow"}, {"score": 0.010195682832952089, "phrase": "matlab."}, {"score": 0.00481495049065317, "phrase": "matlab_programs_for_synergistic_execution"}, {"score": 0.004751337071088713, "phrase": "matlab"}, {"score": 0.00470396687329822, "phrase": "array_language"}, {"score": 0.004626255242038005, "phrase": "rapid_prototyping"}, {"score": 0.004474645041899596, "phrase": "production_code"}, {"score": 0.004444921827311577, "phrase": "numerical_and_scientific_applications"}, {"score": 0.004415395176043526, "phrase": "typical_matlab_programs"}, {"score": 0.004386063799793622, "phrase": "abundant_data_parallelism"}, {"score": 0.004270665568018583, "phrase": "scalar_regions"}, {"score": 0.0041721750101390825, "phrase": "program's_execution_time"}, {"score": 0.004144452614362445, "phrase": "today's_computer_systems"}, {"score": 0.004116913661033223, "phrase": "tremendous_computing_power"}, {"score": 0.004048860957751714, "phrase": "traditional_cpu_cores"}, {"score": 0.004021954624114115, "phrase": "throughput_oriented_accelerators"}, {"score": 0.003981928669805484, "phrase": "graphics_processing"}, {"score": 0.003651245743840663, "phrase": "program_performance"}, {"score": 0.0034963129868796033, "phrase": "megha"}, {"score": 0.003415619374740772, "phrase": "matlab_programs"}, {"score": 0.003381607100127276, "phrase": "synergistic_execution"}, {"score": 0.0032489004068215407, "phrase": "programmer_input"}, {"score": 0.0031422859551159506, "phrase": "compiler_optimizations"}, {"score": 0.0028715299874549245, "phrase": "constrained_graph_clustering_problem"}, {"score": 0.0028052155436760528, "phrase": "identified_kernels"}, {"score": 0.0027404283412788997, "phrase": "kernel_execution"}, {"score": 0.0026240423738883704, "phrase": "data_transfer"}, {"score": 0.002546368390189036, "phrase": "required_data_movement"}, {"score": 0.0025125868638809284, "phrase": "basic_blocks"}, {"score": 0.002470987929071079, "phrase": "data_flow_analysis"}, {"score": 0.0024545413637350765, "phrase": "edge_splitting_strategy"}, {"score": 0.0022806798371116698, "phrase": "required_data_transfer"}, {"score": 0.0022579435307530944, "phrase": "proposed_compiler"}, {"score": 0.0022279798606617356, "phrase": "experimental_evaluation"}, {"score": 0.0021910825909008946, "phrase": "matlab_benchmarks"}, {"score": 0.0021476098263617954, "phrase": "geometric_mean_speedup"}, {"score": 0.0021191072118924067, "phrase": "data_parallel_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "native_execution"}], "paper_keywords": ["Algorithms", " Languages", " Performance"], "paper_abstract": "MATLAB is an array language, initially popular for rapid prototyping, but is now being increasingly used to develop production code for numerical and scientific applications. Typical MATLAB programs have abundant data parallelism. These programs also have control flow dominated scalar regions that have an impact on the program's execution time. Today's computer systems have tremendous computing power in the form of traditional CPU cores and throughput oriented accelerators such as graphics processing units(GPUs). Thus, an approach that maps the control flow dominated regions to the CPU and the data parallel regions to the GPU can significantly improve program performance. In this paper, we present the design and implementation of MEGHA, a compiler that automatically compiles MATLAB programs to enable synergistic execution on heterogeneous processors. Our solution is fully automated and does not require programmer input for identifying data parallel regions. We propose a set of compiler optimizations tailored for MATLAB. Our compiler identifies data parallel regions of the program and composes them into kernels. The problem of combining statements into kernels is formulated as a constrained graph clustering problem. Heuristics are presented to map identified kernels to either the CPU or GPU so that kernel execution on the CPU and the GPU happens synergistically and the amount of data transfer needed is minimized. In order to ensure required data movement for dependencies across basic blocks, we propose a data flow analysis and edge splitting strategy. Thus our compiler automatically handles composition of kernels, mapping of kernels to CPU and GPU, scheduling and insertion of required data transfer. The proposed compiler was implemented and experimental evaluation using a set of MATLAB benchmarks shows that our approach achieves a geometric mean speedup of 19.8X for data parallel benchmarks over native execution of MATLAB.", "paper_title": "Automatic Compilation of MATLAB Programs for Synergistic Execution on Heterogeneous Processors", "paper_id": "WOS:000294609500014"}