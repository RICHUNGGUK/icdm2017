{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "adaptive_adversary"}, {"score": 0.015052903595801586, "phrase": "byzantine_agreement"}, {"score": 0.003990385737207714, "phrase": "total_number"}, {"score": 0.0038191874409949423, "phrase": "high_probability"}, {"score": 0.003125175084962886, "phrase": "synchronous_communication"}, {"score": 0.003066945490483524, "phrase": "rushing_adversary"}, {"score": 0.0025409639091476363, "phrase": "private_channels"}, {"score": 0.0021049977753042253, "phrase": "first_algorithm"}], "paper_keywords": ["Theory", " Byzantine agreement", " consensus", " Samplers", " Peer-to-peer", " secret-sharing", " Monte Carlo Algorithms", " distributed computing"], "paper_abstract": "We describe an algorithm for Byzantine agreement that is scalable in the sense that each processor sends only (O) over tilde(root n) bits, where n is the total number of processors. Our algorithm succeeds with high probability against an adaptive adversary, which can take over processors at any time during the protocol, up to the point of taking over arbitrarily close to a 1/3 fraction. We assume synchronous communication but a rushing adversary. Moreover, our algorithm works in the presence of flooding: processors controlled by the adversary can send out any number of messages. We assume the existence of private channels between all pairs of processors but make no other cryptographic assumptions. Finally, our algorithm has latency that is polylogarithmic in n. To the best of our knowledge, ours is the first algorithm to solve Byzantine agreement against an adaptive adversary, while requiring o(n(2)) total bits of communication.", "paper_title": "Breaking the O(n(2)) Bit Barrier: Scalable Byzantine Agreement with an Adaptive Adversary", "paper_id": "WOS:000292766900005"}