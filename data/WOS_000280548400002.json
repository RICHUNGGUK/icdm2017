{"auto_keywords": [{"score": 0.04978895903400394, "phrase": "crosscut"}, {"score": 0.017641445339419658, "phrase": "abstraction_level"}, {"score": 0.00866685098638759, "phrase": "end_use"}, {"score": 0.004814959548929134, "phrase": "replay"}, {"score": 0.004756805752518494, "phrase": "deterministic_record-replay"}, {"score": 0.004670896353428476, "phrase": "fault_tolerance"}, {"score": 0.00450368324850566, "phrase": "record-replay_solution"}, {"score": 0.004462819565604272, "phrase": "system_administrator"}, {"score": 0.0037301606780397456, "phrase": "end_user"}, {"score": 0.003531474887552889, "phrase": "semantic_mismatch"}, {"score": 0.003353521531649663, "phrase": "customizable_replay_stages"}, {"score": 0.0033230588808076267, "phrase": "special-purpose_logs"}, {"score": 0.003292872031718798, "phrase": "end_users"}, {"score": 0.003194209418929854, "phrase": "replay_logs"}, {"score": 0.0028715299874549245, "phrase": "sensitive_data"}, {"score": 0.0027854565462509095, "phrase": "replay_log"}, {"score": 0.0027685531038981847, "phrase": "higher-level_platforms"}, {"score": 0.0027350565588356228, "phrase": "perl"}, {"score": 0.0027184544918006977, "phrase": "valgrind"}, {"score": 0.0026530590435527527, "phrase": "additional_analysis_code"}, {"score": 0.002636956926079255, "phrase": "replay_time"}, {"score": 0.002597126785932806, "phrase": "replayed_components"}, {"score": 0.002406799309495983, "phrase": "vmware_workstation's_record-replay_capabilities"}, {"score": 0.0023560464785206095, "phrase": "different_replay_environments"}, {"score": 0.0022168460543913787, "phrase": "sensitive_information"}, {"score": 0.0021049977753042253, "phrase": "replay_debugging"}], "paper_keywords": ["Design", " Experimentation", " Performance", " Security", " Design", " Experimentation", " Performance", " Security", " Replay", " Virtual Machines"], "paper_abstract": "Deterministic record-replay has many useful applications, ranging from fault tolerance and forensics to reproducing and diagnosing bugs. When choosing a record-replay solution, the system administrator must choose a priori how comprehensively to record the execution and at what abstraction level to record it. Unfortunately, these choices may not match well with how the recording is eventually used. A recording may contain too little information to support the end use of replay, or it may contain more sensitive information than is allowed to be shown to the end user of replay. Similarly, fixing the abstraction level at the time of recording often leads to a semantic mismatch with the end use of replay. This paper describes how to remedy these problems by adding customizable replay stages to create special-purpose logs for the end users of replay. Our system, called Crosscut, allows replay logs to be \"sliced\" along time and abstraction boundaries. Using this approach, users can create slices that include only the processes, applications, or components of interest, excluding parts that handle sensitive data. Users can also retarget the abstraction level of the replay log to higher-level platforms, such as Perl or Valgrind. Execution can then be augmented with additional analysis code at replay time, without disturbing the replayed components in the slice. Crosscut thus uses replay itself to transform logs into a more efficient, secure, and usable form for replay-based applications. Our current Crosscut prototype builds on VMware Workstation's record-replay capabilities, and supports a variety of different replay environments. We show how Crosscut can create slices of only the parts of the computation of interest and thereby avoid leaking sensitive information, and we show how to retarget the abstraction level of the log to enable more convenient use during replay debugging.", "paper_title": "Multi-stage Replay with Crosscut", "paper_id": "WOS:000280548400002"}