{"auto_keywords": [{"score": 0.04517963074875062, "phrase": "ilp"}, {"score": 0.00481495049065317, "phrase": "hypothesis_space"}, {"score": 0.004612147352416241, "phrase": "inductive_logic_programming"}, {"score": 0.004494570360108983, "phrase": "powerful_and_well-developed_abstraction"}, {"score": 0.004456044928556639, "phrase": "multi-relational_data_mining_techniques"}, {"score": 0.004268293864953256, "phrase": "ilp_systems"}, {"score": 0.004213519983188569, "phrase": "efficiency_problems"}, {"score": 0.004141575435071002, "phrase": "complex_problems"}, {"score": 0.004001335931796133, "phrase": "novel_technique"}, {"score": 0.003799796252156605, "phrase": "constructed_clause"}, {"score": 0.0036710872046569532, "phrase": "mode_directed_inverse_entailment_approach"}, {"score": 0.003577414339646767, "phrase": "bottom_clause"}, {"score": 0.0034562118159899772, "phrase": "generated_clauses"}, {"score": 0.0031166151196841308, "phrase": "bottom_clauses"}, {"score": 0.00306334226516593, "phrase": "extra_information"}, {"score": 0.0027503564589458837, "phrase": "ilp_algorithm"}, {"score": 0.0022848092812445533, "phrase": "hypothesis'_value"}, {"score": 0.0022651818270925704, "phrase": "theory-level_search"}, {"score": 0.002236055625099805, "phrase": "cross-validation_evaluation_procedures"}, {"score": 0.0021232402128269906, "phrase": "real_applications"}, {"score": 0.0021049977753042253, "phrase": "considerable_speedups"}], "paper_keywords": ["Mode Directed Inverse Entailment", " Efficiency", " Data Structures", " Compilation"], "paper_abstract": "Inductive Logic Programming (ILP) is a powerful and well-developed abstraction for multi-relational data mining techniques. Despite the considerable success of ILP, deployed ILP systems still have efficiency problems when applied to complex problems. In this paper we propose a novel technique that avoids the procedure of deducing each example to evaluate each constructed clause. The technique is based on the Mode Directed Inverse Entailment approach to ILP, where a bottom clause is generated for each example and the generated clauses are subsets of the literals of such bottom clause. We propose to store in a prefix-tree all clauses that can be generated from all bottom clauses together with some extra information. We show that this information is sufficient to estimate the number of examples that can be deduced from a clause and present an ILP algorithm that exploits this representation. We also present an extension of the algorithm where each prefix-tree is computed only once (compiled) per example. The evaluation of hypotheses requires only basic and efficient operations on trees. This proposal avoids re-computation of hypothesis' value in theory-level search, in cross-validation evaluation procedures and in parameter tuning. Both proposals are empirically evaluated on real applications and considerable speedups were observed.", "paper_title": "Compile the Hypothesis Space: Do it Once, Use it Often", "paper_id": "WOS:000262453700004"}