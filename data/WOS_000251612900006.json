{"auto_keywords": [{"score": 0.049779077903973595, "phrase": "unmanaged_code"}, {"score": 0.00481495049065317, "phrase": ".net_security"}, {"score": 0.0040379950810436995, "phrase": "growing_class"}, {"score": 0.004012686357543403, "phrase": "mobile_code"}, {"score": 0.003987558444832893, "phrase": "microsoft"}, {"score": 0.003950103621065539, "phrase": ".net_framework"}, {"score": 0.003839894670436311, "phrase": "machine-independent_byte-code"}, {"score": 0.003779996603264111, "phrase": "virtual_machine"}, {"score": 0.003744505496142733, "phrase": "important_feature"}, {"score": 0.0036285822640427525, "phrase": "native_libraries"}, {"score": 0.003594507685403249, "phrase": "legacy_code"}, {"score": 0.0035273120781708655, "phrase": "windows_api._such_native_code"}, {"score": 0.003439661147299417, "phrase": "managed_code"}, {"score": 0.003354180941665089, "phrase": "unmanaged_native_code"}, {"score": 0.0030907252217934477, "phrase": "framework's_security_mechanisms"}, {"score": 0.0029855707714361813, "phrase": ".net_application"}, {"score": 0.0028930745799089683, "phrase": "sandboxing_mechanism"}, {"score": 0.0027683608802260636, "phrase": "security_policy"}, {"score": 0.0026573612772397832, "phrase": "windows_api"}, {"score": 0.002566913022636081, "phrase": "unmanaged_parts"}, {"score": 0.0024485031231407522, "phrase": "potentially_unsafe_code"}, {"score": 0.0024254832239892017, "phrase": "issue_system"}, {"score": 0.002380089119791563, "phrase": ".net_security_policy"}, {"score": 0.002320879380255764, "phrase": ".net_runtime"}, {"score": 0.0021998931213841567, "phrase": "generally_acceptable_performance_penalty"}, {"score": 0.002138410677608455, "phrase": "presented_architecture"}, {"score": 0.0021049977753042253, "phrase": "first_solution"}], "paper_keywords": [".NET security", " unmanaged code", " sandboxing"], "paper_abstract": "The number of applications that are downloaded from the Internet and executed on-the-fly is increasing every day. Unfortunately, not all of these applications are benign, and, often, users are unsuspecting and unaware of the intentions of a program. To facilitate and secure this growing class of mobile code, Microsoft introduced the .NET framework, a new development and runtime environment where machine-independent byte-code is executed by a virtual machine. An important feature of this framework is that it allows access to native libraries to support legacy code or to directly invoke the Windows API. Such native code is called unmanaged (as opposed to managed code). Unfortunately, the execution of unmanaged native code is not restricted by the. NET security model, and, thus, could provide the attacker with a mechanism to completely circumvent the framework's security mechanisms if the user decides to grant execute permission to the .NET application. The approach described in this paper uses a sandboxing mechanism to prevent an attacker from executing malicious, unmanaged code that is not permitted by the security policy. Our sandbox is implemented as two security layers, one on top of the Windows API and one in the kernel. Also, managed and unmanaged parts of an application are automatically separated and executed in two different processes. This ensures that potentially unsafe code can neither issue system calls not permitted by the .NET security policy nor tamper with the memory of the .NET runtime. Our proof-of-concept implementation is transparent to applications and secures unmanaged code with a generally acceptable performance penalty. To the best of our knowledge, the presented architecture and implementation is the first solution to secure unmanaged code in .NET.", "paper_title": "Extending .NET security to unmanaged code", "paper_id": "WOS:000251612900006"}