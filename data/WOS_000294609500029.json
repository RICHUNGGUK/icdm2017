{"auto_keywords": [{"score": 0.03994855929694926, "phrase": "sydit"}, {"score": 0.008099951903008008, "phrase": "edit_script"}, {"score": 0.007570181860809219, "phrase": "derived_edit_script"}, {"score": 0.00481495049065317, "phrase": "software_modifications"}, {"score": 0.0044990584725586764, "phrase": "multiple_contexts"}, {"score": 0.004463278123628969, "phrase": "existing_tools"}, {"score": 0.0044277810648955624, "phrase": "systematic_program_transformation"}, {"score": 0.004087910779160781, "phrase": "related_example"}, {"score": 0.003912189642066724, "phrase": "program_transformation_tool"}, {"score": 0.0038810583785936505, "phrase": "sydit."}, {"score": 0.0038348235692738783, "phrase": "example_edit"}, {"score": 0.003640730820018083, "phrase": "new_program_locations"}, {"score": 0.0035544816252832375, "phrase": "relative_position"}, {"score": 0.0034702685641070283, "phrase": "new_location"}, {"score": 0.0034016119212097826, "phrase": "unchanged_statements"}, {"score": 0.0031402604946939743, "phrase": "new_context"}, {"score": 0.0031152526492532785, "phrase": "different_identifier_names"}, {"score": 0.002898930717812433, "phrase": "five_large_software_projects"}, {"score": 0.002818909613625567, "phrase": "high_coverage"}, {"score": 0.0024408799645640323, "phrase": "human_programmers"}, {"score": 0.0023171750718791713, "phrase": "edit_scripts"}, {"score": 0.0022803854904010347, "phrase": "programmer_productivity"}, {"score": 0.0021561514733516676, "phrase": "automated_program_repair"}, {"score": 0.0021304214257321, "phrase": "program_transformations"}, {"score": 0.0021049977753042253, "phrase": "similar_contexts"}], "paper_keywords": ["Algorithm", " Measurement", " Experimentation", " Software evolution", " program transformation", " program differencing", " empirical study"], "paper_abstract": "Software modifications are often systematic-they consist of similar, but not identical, program changes to multiple contexts. Existing tools for systematic program transformation are limited because they require programmers to manually prescribe edits or only suggest a location to edit with a related example. This paper presents the design and implementation of a program transformation tool called SYDIT. Given an example edit, SYDIT generates a context-aware, abstract edit script, and then applies the edit script to new program locations. To correctly encode a relative position of the edits in a new location, the derived edit script includes unchanged statements on which the edits are control and data dependent. Furthermore, to make the edit script applicable to a new context using different identifier names, the derived edit script abstracts variable, method, and type names. The evaluation uses 56 systematic edit pairs from five large software projects as an oracle. SYDIT has high coverage and accuracy. For 82% of the edits (46/56), SYDIT matches the context and applies an edit, producing code that is 96% similar to the oracle. Overall, SYDIT mimics human programmers correctly on 70% (39/56) of the edits. Generation of edit scripts seeks to improve programmer productivity by relieving developers from tedious, error-prone, manual code updates. It also has the potential to guide automated program repair by creating program transformations applicable to similar contexts.", "paper_title": "Systematic Editing: Generating Program Transformations from an Example", "paper_id": "WOS:000294609500029"}