{"auto_keywords": [{"score": 0.0485973663751699, "phrase": "vulnerability_signatures"}, {"score": 0.011959650950015813, "phrase": "vulnerability_signature"}, {"score": 0.005928966520813289, "phrase": "regular_expression"}, {"score": 0.005719992399439577, "phrase": "design_space"}, {"score": 0.00481495049065317, "phrase": "automated_generation"}, {"score": 0.00479338027764693, "phrase": "vulnerability-based_signatures"}, {"score": 0.004582897918101983, "phrase": "program_vulnerability"}, {"score": 0.004511423799053534, "phrase": "particular_exploit"}, {"score": 0.004303591748086452, "phrase": "vulnerable_program"}, {"score": 0.004208002469225673, "phrase": "zero_false_positives"}, {"score": 0.004123781267600542, "phrase": "signature_creation"}, {"score": 0.004041238873048836, "phrase": "runtime_monitor"}, {"score": 0.003872347256711097, "phrase": "vulnerability_signature_generation"}, {"score": 0.00384633057714983, "phrase": "analysis_centric"}, {"score": 0.0036525695910152893, "phrase": "full_turing-complete_language"}, {"score": 0.0035794251590584563, "phrase": "particular_point"}, {"score": 0.003406713877432236, "phrase": "unique_properties"}, {"score": 0.0033384763254777697, "phrase": "program_binary"}, {"score": 0.0032863459256972896, "phrase": "multiple-path_vulnerabilities"}, {"score": 0.003264253442030387, "phrase": "multiple-path_vulnerability"}, {"score": 0.0031559919178954644, "phrase": "web_server"}, {"score": 0.0031067021349681116, "phrase": "url_handling_routine"}, {"score": 0.002983452428997431, "phrase": "multiple_paths"}, {"score": 0.002910545717767559, "phrase": "new_algorithms"}, {"score": 0.0028650782572073896, "phrase": "enumerating_vulnerable_paths"}, {"score": 0.0028394155559913125, "phrase": "exponential_explosion"}, {"score": 0.0028076592725295646, "phrase": "new_approach"}, {"score": 0.0027825094419000637, "phrase": "logical_semantics"}, {"score": 0.00277001889871322, "phrase": "multiple_vulnerable_program_paths"}, {"score": 0.0026303345295125265, "phrase": "formal_definition"}, {"score": 0.0025892330566358503, "phrase": "computational_complexity"}, {"score": 0.0024864612830452254, "phrase": "specific_techniques"}, {"score": 0.0024421008630165046, "phrase": "language_classes"}, {"score": 0.0023770362063833903, "phrase": "prototype_system"}, {"score": 0.0023241387549221408, "phrase": "single_exploit"}, {"score": 0.002262209824105154, "phrase": "small_program"}, {"score": 0.0021529183360603434, "phrase": "multiple_program_paths"}, {"score": 0.002114495969857587, "phrase": "viable_option"}, {"score": 0.0021049977753042253, "phrase": "signature_generation"}], "paper_keywords": ["Vulnerability", " vulnerability signature", " intrusion detection", " intrusion prevention", " polymorphic worm", " Turing machine signature", " regular expression signature", " symbolic signature"], "paper_abstract": "In this paper, we explore the problem of creating vulnerability signatures. A vulnerability signature is based on a program vulnerability and is not specific to any particular exploit. The advantage of vulnerability signatures is that their quality can be guaranteed. In particular, we create vulnerability signatures from the vulnerable program itself, such that they are guaranteed to have zero false positives by construction. We show how to automate signature creation for vulnerabilities that can be detected by a runtime monitor. There is no one right signature representation for a vulnerability. We introduce a formalism and way of thinking about vulnerability signature generation that is analysis centric instead of representation specific. In particular, a signature can be represented in many ways, from using regular expression to using a full Turing-complete language. Previous systems have mostly focused on a particular point in the design space. We show how to approximate the language of a vulnerability in many different language classes, each of which has unique properties and benefits, by performing analysis on the program binary and vulnerability. Our approach also considers multiple-path vulnerabilities. A multiple-path vulnerability is a vulnerability that can be exploited through several different code paths. For example, a Web server may have a vulnerability in a URL handling routine that is called for many different types of requests. We demonstrate techniques that can create signatures that cover multiple paths an exploit may take. We have had to develop new algorithms to cope with the problem where enumerating vulnerable paths leads to an exponential explosion. We develop a new approach that captures the logical semantics of multiple vulnerable program paths in O(n(2)) space (where n is the size of the program) instead of exponential. We provide a formal definition of a vulnerability signature and investigate the computational complexity of creating and matching vulnerability signatures. We systematically explore the design space of vulnerability signatures. We also provide specific techniques for creating vulnerability signatures in a variety of language classes. In order to demonstrate our techniques, we have built a prototype system. Our experiments show that we can, using a single exploit, automatically generate a vulnerability signature as a regular expression, as a small program, or as a system of constraints. We demonstrate techniques for creating signatures of vulnerabilities that can be exploited via multiple program paths. Our results indicate that our approach is a viable option for signature generation, especially when guarantees are desired.", "paper_title": "Theory and Techniques for Automated Generation of Vulnerability-Based Signatures", "paper_id": "WOS:000260558800003"}