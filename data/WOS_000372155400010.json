{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "runtime_verification"}, {"score": 0.007679090399941186, "phrase": "java"}, {"score": 0.006917689326837358, "phrase": "aspectj"}, {"score": 0.004658426838467567, "phrase": "program's_execution_trace"}, {"score": 0.004218602458288531, "phrase": "current_approaches"}, {"score": 0.004172360444377281, "phrase": "static_deployment"}, {"score": 0.004103942174451674, "phrase": "verification_logic"}, {"score": 0.003948613642680196, "phrase": "limited_set"}, {"score": 0.003615217162972726, "phrase": "production_systems"}, {"score": 0.003555902292752528, "phrase": "popular_system"}, {"score": 0.003219835797056762, "phrase": "aforementioned_limitations"}, {"score": 0.0030135741897058844, "phrase": "extensible_join-point_model"}, {"score": 0.0028675712105299496, "phrase": "javamop_framework"}, {"score": 0.00282048824450047, "phrase": "dynamic_deployment_api"}, {"score": 0.0027741761880779535, "phrase": "new_mop_specification_translator"}, {"score": 0.0026986685585382347, "phrase": "domain-specific_aspect_language"}, {"score": 0.002610760317398998, "phrase": "disl"}, {"score": 0.0025678829712650437, "phrase": "open_join-point_model"}, {"score": 0.002470547930651519, "phrase": "case_study"}, {"score": 0.0024434201175883674, "phrase": "lambda_expressions"}, {"score": 0.002261666793030715, "phrase": "javamop"}, {"score": 0.0022368274529152342, "phrase": "load-time_weaving"}, {"score": 0.002175913488493802, "phrase": "runtime_overhead"}, {"score": 0.0021049977753042253, "phrase": "memory_usage"}], "paper_keywords": ["Runtime verification", " Monitor-Oriented Programming (MOP)", " dynamic program analysis", " dynamic deployment"], "paper_abstract": "Runtime verification validates the correctness of a program's execution trace. Much work has been done on improving the expressiveness and efficiency of runtime verification. However, current approaches require static deployment of the verification logic and are often restricted to a limited set of events that can be captured and analyzed, hindering the adoption of runtime verification in production systems. A popular system for runtime verification in Java, JavaMOP (Monitor-Oriented Programming in Java), suffers from the aforementioned limitations due to its dependence on AspectJ, which supports neither dynamic weaving nor an extensible join-point model. In this article, we extend the JavaMOP framework with a dynamic deployment API and a new MOP specification translator, which targets the domain-specific aspect language DiSL instead of AspectJ; DiSL offers an open join-point model that allows for extensions. A case study on lambda expressions in Java8 demonstrates the extensibility of our approach. Moreover, in comparison with JavaMOP using load-time weaving, our implementation reduces runtime overhead by 32%, and heap memory usage by 13%, on average.", "paper_title": "Flexible and Extensible Runtime Verification for Java (Extended Version)", "paper_id": "WOS:000372155400010"}