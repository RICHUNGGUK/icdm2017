{"auto_keywords": [{"score": 0.04392958050460296, "phrase": "pf_engines"}, {"score": 0.0417204448387405, "phrase": "hash_tables"}, {"score": 0.04076135969409861, "phrase": "hash_table"}, {"score": 0.03470635444778384, "phrase": "overflow_problem"}, {"score": 0.00481495049065317, "phrase": "packet_forwarding"}, {"score": 0.004776360477283921, "phrase": "associative_memory_architectures"}, {"score": 0.004649936560866145, "phrase": "increasingly_stringent_throughput_requirements"}, {"score": 0.004612662942073808, "phrase": "growing_size"}, {"score": 0.0045879792359519375, "phrase": "ip_forwarding_tables"}, {"score": 0.004490552331642995, "phrase": "incoming_packet's_ip_address"}, {"score": 0.00441883624011048, "phrase": "forwarding_table"}, {"score": 0.004383406949799696, "phrase": "matching_process"}, {"score": 0.004313394602841915, "phrase": "increasingly_higher_wire_speed"}, {"score": 0.004244495734923587, "phrase": "low_power_consumption"}, {"score": 0.004055176557424983, "phrase": "set_associative_memory"}, {"score": 0.004001112159558637, "phrase": "hardware_implementations"}, {"score": 0.0038226070564362697, "phrase": "single_memory_cycle"}, {"score": 0.003771631577951067, "phrase": "classic_hashing_downsides"}, {"score": 0.003517276620998936, "phrase": "good_average_case_search_performance"}, {"score": 0.0034610501297253895, "phrase": "worst_case_performance"}, {"score": 0.0031335830806256777, "phrase": "multiple_hash_functions"}, {"score": 0.0030587157474484612, "phrase": "aforementioned_solutions"}, {"score": 0.0029936654764403216, "phrase": "first_scheme"}, {"score": 0.0028142341431886407, "phrase": "chap"}, {"score": 0.002724909017963099, "phrase": "classical_side_effects"}, {"score": 0.0027102997281261733, "phrase": "predefined_hash"}, {"score": 0.002561539797590314, "phrase": "second_scheme"}, {"score": 0.0025409639091476363, "phrase": "progressive_hashing"}, {"score": 0.002493592357827492, "phrase": "general_multiple_hash_scheme"}, {"score": 0.0024339783012484032, "phrase": "basic_idea"}, {"score": 0.0024211282589746263, "phrase": "ph"}, {"score": 0.002306543826130521, "phrase": "hash_functions"}, {"score": 0.0022880115261460212, "phrase": "progressive_fashion"}, {"score": 0.0022213218042340735, "phrase": "high-performance_hardware_implementations"}, {"score": 0.002191652909911584, "phrase": "constant_worst-case_memory_access_time"}, {"score": 0.0021507795710951384, "phrase": "real_ip_lookup_tables"}], "paper_keywords": ["Hardware hashing", " Set associative memory", " IP lookup", " Packet forwarding", " Hash schemes"], "paper_abstract": "Building a high performance IP packet forwarding (PF) engine remains a challenge due to increasingly stringent throughput requirements and the growing size of IP forwarding tables. The router has to match the incoming packet's IP address against all entries in the forwarding table. The matching process has to be done at increasingly higher wire speed: hence, scalability and low power consumption are critical for PF engines. Various hash table based schemes have been considered for use in PF engines. Set associative memory can be used for hardware implementations of hash tables with the property that each bucket of a hash table can be searched in a single memory cycle. However, the classic hashing downsides, such as collisions and worst case memory access time have to be dealt with. While open addressing hash tables, in general, provide good average case search performance, their memory utilization and worst case performance can degrade quickly due to collisions (that lead to bucket overflows). The two standard solutions to the overflow problem are either to use predefined probing (e.g., linear or quadratic probing) or to use multiple hash functions. This work presents two new simple hash schemes that extend both aforementioned solutions to tackle the overflow problem efficiently. The first scheme is a hash probing scheme that is called Content-based HAsh Probing (CHAP). As the name suggests, CHAP, based on the content of the hash table, avoids the classical side effects of predefined hash probing methods (i.e., primary and secondary clustering phenomena) and at the same time reduces the overflow. The second scheme, called Progressive Hashing (PH), is a general multiple hash scheme that reduces the overflow as well. The basic idea of PH is to split the prefixes into groups where each group is assigned one hash function, then reuse some hash functions in a progressive fashion to reduce the overflow. Both schemes are amenable to high-performance hardware implementations with low overflow and constant worst-case memory access time. We show by experimenting with real IP lookup tables and synthetic traces that both schemes outperform other existing hashing schemes. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "Advanced hashing schemes for packet forwarding using set associative memory architectures", "paper_id": "WOS:000284984200001"}