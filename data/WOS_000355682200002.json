{"auto_keywords": [{"score": 0.033537667883606945, "phrase": "state_machine"}, {"score": 0.00481495049065317, "phrase": "piggyback_runtime_monitoring"}, {"score": 0.0047555023078686386, "phrase": "object-oriented_programs"}, {"score": 0.0046676969718111765, "phrase": "runtime_monitor"}, {"score": 0.004199766284749713, "phrase": "independent_piece"}, {"score": 0.003946650265907885, "phrase": "relevant_events"}, {"score": 0.0035507457285983268, "phrase": "appropriate_state_machine"}, {"score": 0.0034851070574149993, "phrase": "present_paper"}, {"score": 0.003336614511719501, "phrase": "object's_member_fields"}, {"score": 0.00265038878247831, "phrase": "\"piggyback\"_runtime_monitoring"}, {"score": 0.0024595996811420566, "phrase": "object's_own_state_variables"}, {"score": 0.002340081450249521, "phrase": "real-world_benchmarks"}, {"score": 0.002226357953581725, "phrase": "monitoring_process"}, {"score": 0.0021580985506699105, "phrase": "incurred_runtime"}, {"score": 0.0021049977753042253, "phrase": "classical_solutions"}], "paper_keywords": ["Runtime monitoring", " Preconditions", " Interface contract", " Object-oriented programming"], "paper_abstract": "A runtime monitor enforcing a constraint on sequences of method calls on an object involves the implementation of an independent piece of code called a monitor. This monitor intercepts relevant events in the program and must keep track of the state of the sequence by updating an appropriate state machine. The present paper stems from the observation that an object's member fields must already contain an encoding of that state machine and that a monitor essentially duplicates operations that the object performs internally. Rather than maintaining a state machine in parallel, the paper puts forward the concept of \"piggyback\" runtime monitoring, where the monitor relies as much as possible on the object's own state variables to perform its task. Experiments on real-world benchmarks show that this approach greatly simplifies the monitoring process and drastically reduces the incurred runtime overhead compared to classical solutions.", "paper_title": "On piggyback runtime monitoring of object-oriented programs", "paper_id": "WOS:000355682200002"}