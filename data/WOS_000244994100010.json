{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "new_class"}, {"score": 0.004424268136268051, "phrase": "undirected_graph"}, {"score": 0.004358676214574977, "phrase": "c_subset"}, {"score": 0.0034660938095219846, "phrase": "shortest_path"}, {"score": 0.003347259612209552, "phrase": "f_subset"}, {"score": 0.00239657981537094, "phrase": "multiprocessor_architectures"}, {"score": 0.0022799458141165587, "phrase": "infinite_square"}, {"score": 0.0022573076362326135, "phrase": "king_grid"}, {"score": 0.002234893735225432, "phrase": "infinite_triangular_lattice"}, {"score": 0.0022127018991294047, "phrase": "hexagonal_mesh"}, {"score": 0.002168975681697056, "phrase": "binary_hypercube"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["fault tolerance", " parallel processing", " identification", " optimal code"], "paper_abstract": "Assume that G = (V, E) is an undirected graph, and C subset of V. For every v is an element of V, we denote I-r(v) = {u is an element of C: d(u, v) <= r}, where d(u, v) denotes the number of edges on any shortest path from u to v. For every F subset of V, we denote I-r(F) = boolean OR(v is an element of F) I-r(v). We study codes C with the property that if I-r(F) = I-r(F') and F not equal F', then both F and F' have size at least l + 1. Such codes can be used in the maintenance of multiprocessor architectures. We consider the cases when G is the infinite square or king grid, infinite triangular lattice or hexagonal mesh, or a binary hypercube. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "On a new class of identifying codes in graphs", "paper_id": "WOS:000244994100010"}