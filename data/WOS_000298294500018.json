{"auto_keywords": [{"score": 0.03543121398886005, "phrase": "program_state"}, {"score": 0.03127616605838267, "phrase": "strobe"}, {"score": 0.00481495049065317, "phrase": "familiar_and_widely_used_bug_detection_technique"}, {"score": 0.004216434794603139, "phrase": "data_structure_invariants"}, {"score": 0.00418046991987597, "phrase": "heap_analyses"}, {"score": 0.004039639718055365, "phrase": "extreme_slowdowns"}, {"score": 0.0039035351575463103, "phrase": "assertion_evaluation"}, {"score": 0.0038702288460744274, "phrase": "program_execution"}, {"score": 0.0037558704408683905, "phrase": "separate_checking_threads"}, {"score": 0.003582928547553209, "phrase": "asynchronous_evaluation"}, {"score": 0.0034919649825540396, "phrase": "synchronous_evaluation"}, {"score": 0.003316884515934182, "phrase": "checking_threads"}, {"score": 0.003232653376857698, "phrase": "consistent_snapshot"}, {"score": 0.002904040426340639, "phrase": "asynchronous_assertion"}, {"score": 0.002854645802851, "phrase": "single-and_multi-threaded_java_applications"}, {"score": 0.0027821202902740846, "phrase": "java_virtual_machine"}, {"score": 0.0025424508991051483, "phrase": "necessary_synchronization"}, {"score": 0.0025099367332615794, "phrase": "multiple_concurrent_checking_threads"}, {"score": 0.0024566655761509276, "phrase": "data_races"}, {"score": 0.0024252458095689847, "phrase": "main_program_threads"}, {"score": 0.0023333715029833007, "phrase": "synchronous_checking"}, {"score": 0.0023035249767734286, "phrase": "tolerable_overheads"}, {"score": 0.0021599099979586946, "phrase": "heavy-weight_assertions"}, {"score": 0.0021049977753042253, "phrase": "crushing_slowdowns"}], "paper_keywords": ["Reliability", " Performance", " Experimentation", " Assertions", " concurrent checking", " heap snapshot", " dynamic analysis", " data structure invariants"], "paper_abstract": "Assertions are a familiar and widely used bug detection technique. Traditional assertion checking, however, is performed synchronously, imposing its full cost on the runtime of the program. As a result, many useful kinds of checks, such as data structure invariants and heap analyses, are impractical because they lead to extreme slowdowns. We present a solution that decouples assertion evaluation from program execution: assertions are checked asynchronously by separate checking threads while the program continues to execute. Our technique guarantees that asynchronous evaluation always produces the same result as synchronous evaluation, even if the program concurrently modifies the program state. The checking threads evaluate each assertion on a consistent snapshot of the program state as it existed at the moment the assertion started. We implemented our technique in a system called STROBE, which supports asynchronous assertion checking in both single-and multi-threaded Java applications. STROBE runs inside the Java virtual machine and uses copy-on-write to construct snapshots incrementally, on-the-fly. Our system includes all necessary synchronization to support multiple concurrent checking threads, and to prevent data races with the main program threads. We find that asynchronous checking significantly outperforms synchronous checking, incurring tolerable overheads - in the range of 10% to 50% over no checking at all - even for heavy-weight assertions that would otherwise result in crushing slowdowns.", "paper_title": "Asynchronous Assertions", "paper_id": "WOS:000298294500018"}