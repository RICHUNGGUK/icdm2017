{"auto_keywords": [{"score": 0.04381652051820687, "phrase": "program_logics"}, {"score": 0.01467146151221059, "phrase": "software_behaviours"}, {"score": 0.00481495049065317, "phrase": "unified_theory_of_program"}, {"score": 0.004539005582217309, "phrase": "staggering_diversity"}, {"score": 0.0044426140044122545, "phrase": "modern_and_future_computing"}, {"score": 0.004233119608341877, "phrase": "unified_theory"}, {"score": 0.004055176557424983, "phrase": "general_class"}, {"score": 0.0038846843242954935, "phrase": "software_engineering"}, {"score": 0.003802135020791801, "phrase": "hennessy-milner_logic"}, {"score": 0.0037615180375561805, "phrase": "typed_pi-calculi"}, {"score": 0.003701401653850141, "phrase": "possible_foundation"}, {"score": 0.003526735797659508, "phrase": "singular_position"}, {"score": 0.0034890505116128606, "phrase": "computational_calculi"}, {"score": 0.0033965836912510385, "phrase": "sequential_and_concurrent_programs"}, {"score": 0.0033602844686125375, "phrase": "name_passing_processes"}, {"score": 0.003306559295382181, "phrase": "semantic_information"}, {"score": 0.0031504667809625344, "phrase": "linear_logic"}, {"score": 0.0031167895790050405, "phrase": "game_semantics"}, {"score": 0.002859977408815691, "phrase": "process_logic"}, {"score": 0.0027991418754844347, "phrase": "observational_content"}, {"score": 0.002610198789888055, "phrase": "uniform_basis"}, {"score": 0.0025546627686955656, "phrase": "case_study"}, {"score": 0.002473560912156024, "phrase": "hoare_logic"}, {"score": 0.002447101794397243, "phrase": "sequential_programs"}, {"score": 0.002407941567598653, "phrase": "rely-guarantee_logic"}, {"score": 0.002382182688788248, "phrase": "shared_variable_concurrency"}, {"score": 0.0023189818169615135, "phrase": "proposed_framework"}, {"score": 0.0022696277881969896, "phrase": "unifying_basis"}, {"score": 0.0022333012657436307, "phrase": "fundamental_notions"}, {"score": 0.002127765807039172, "phrase": "different_kinds"}, {"score": 0.0021049977753042253, "phrase": "concurrent_computing"}], "paper_keywords": ["the pi-calculus", " types", " Hoare logics", " Hennessy-Milner logics", " relay-guarantee logic", " logical full abstraction"], "paper_abstract": "Facing staggering diversity of software behaviours in modern and future computing, we argue for the need of a unified theory of program logics, which can capture a general class of software behaviours, as a foundation of software engineering. We propose Hennessy-Milner logic for typed pi-calculi as a possible foundation of such a theory. The pi-calculus is in a singular position among computational calculi through its ability to embed sequential and concurrent programs as name passing processes without losing semantic information, and through its connection to other basic semantic theories such as linear logic and game semantics. The embedding of programs in processes leads to the embedding of program logics in the process logic, where the observational content of a given program logic is made explicit, analysed and justified on a uniform basis. As a case study, we show embedding of Hoare logic for sequential programs and a rely-guarantee logic for shared variable concurrency, suggesting that the proposed framework can offer a unifying basis to capture fundamental notions in program logics such as partial/total correctness, sequentiality and different kinds of concurrent computing.", "paper_title": "A Unified Theory of Program Logics: An Approach based on the pi-Calculus", "paper_id": "WOS:000285625100007"}