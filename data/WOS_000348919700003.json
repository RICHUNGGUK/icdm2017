{"auto_keywords": [{"score": 0.03623869198838893, "phrase": "host_language"}, {"score": 0.00481495049065317, "phrase": "dataflow_languages"}, {"score": 0.004779876533667754, "phrase": "natural_support"}, {"score": 0.004659108142668152, "phrase": "dynamic_applications"}, {"score": 0.0043305354943056875, "phrase": "one-way_dataflow_constraints"}, {"score": 0.004205660924155212, "phrase": "interactive_applications"}, {"score": 0.004084372444216856, "phrase": "imperative_language"}, {"score": 0.003981106369547929, "phrase": "general_paradigm"}, {"score": 0.003937649447496154, "phrase": "performance-critical_reactive_applications"}, {"score": 0.0038946650372062783, "phrase": "efficient_incremental_computations"}, {"score": 0.0037823114064881357, "phrase": "ordinary_statements"}, {"score": 0.003741016338085083, "phrase": "imperative_host_language"}, {"score": 0.003633079011725194, "phrase": "special_memory_locations"}, {"score": 0.003541182515693916, "phrase": "reactive_objects"}, {"score": 0.003476963781647026, "phrase": "legal_type"}, {"score": 0.003401431460601017, "phrase": "primitive_data_types"}, {"score": 0.002905914725757534, "phrase": "constraintsolving_mechanism"}, {"score": 0.0028116863172018593, "phrase": "elementary_operations"}, {"score": 0.002680932410366204, "phrase": "formal_semantics"}, {"score": 0.0026419338604879404, "phrase": "concrete_embodiment"}, {"score": 0.0025190541346053405, "phrase": "conventional_platforms"}, {"score": 0.0024284249875593253, "phrase": "common_coding_idioms"}, {"score": 0.0024106932919085097, "phrase": "relevant_applications"}, {"score": 0.00239309075766136, "phrase": "reactive_scenarios"}, {"score": 0.0023669270875629226, "phrase": "incremental_computation"}, {"score": 0.0023496433751182162, "phrase": "observer_design_pattern"}, {"score": 0.0023324855762635616, "phrase": "data_structure_repair"}, {"score": 0.002306982970571251, "phrase": "software_visualization"}, {"score": 0.0022321322970228308, "phrase": "problem-specific_change_propagation_algorithms"}, {"score": 0.0021835829960683666, "phrase": "language-centric_approaches"}, {"score": 0.0021597049163247476, "phrase": "self-adjusting_computation"}, {"score": 0.0021049977753042253, "phrase": "proposed_approach"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Languages", " Reactive programming", " dataflow programming", " imperative programming", " one-way dataflow constraints", " constraint solving", " incremental computation", " observer design pattern", " data structure repair", " software visualization"], "paper_abstract": "Dataflow languages provide natural support for specifying constraints between objects in dynamic applications, where programs need to react efficiently to changes in their environment. In this article, we show that one-way dataflow constraints, largely explored in the context of interactive applications, can be seamlessly integrated in any imperative language and can be used as a general paradigm for writing performance-critical reactive applications that require efficient incremental computations. In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as \"reactive.\" Reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures. Statements defining constraints are automatically re-executed every time their input memory locations change, letting a program behave like a spreadsheet where the values of some variables depend on the values of other variables. The constraintsolving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects. We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers. We discuss common coding idioms and relevant applications to reactive scenarios, including incremental computation, observer design pattern, data structure repair, and software visualization. The performance of our implementation is compared to problem-specific change propagation algorithms, as well as to language-centric approaches such as self-adjusting computation and subject/observer communication mechanisms, showing that the proposed approach is efficient in practice.", "paper_title": "Reactive Imperative Programming with Dataflow Constraints", "paper_id": "WOS:000348919700003"}