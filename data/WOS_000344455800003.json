{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "data_races"}, {"score": 0.04977091365029326, "phrase": "structured_parallel_programs"}, {"score": 0.04885877600670675, "phrase": "parallel_software"}, {"score": 0.04737369799623328, "phrase": "sequential_program"}, {"score": 0.03969638742493934, "phrase": "parallel_programming"}, {"score": 0.004737879690862494, "phrase": "common_workflow"}, {"score": 0.0043846936613643256, "phrase": "parallel_tasks"}, {"score": 0.0038038900382901864, "phrase": "special_attention"}, {"score": 0.003577414339646767, "phrase": "hardest_step"}, {"score": 0.0034081501761600067, "phrase": "parallel_programs"}, {"score": 0.0033752674784204412, "phrase": "static-only_or_dynamic-only_approaches"}, {"score": 0.003257379945810655, "phrase": "static_approaches"}, {"score": 0.0031233388358844188, "phrase": "medium_or_large-scale_software"}, {"score": 0.0030832123624449028, "phrase": "pointer-based_data_structures"}, {"score": 0.003033776234384367, "phrase": "dynamic_approaches"}, {"score": 0.002927780883930371, "phrase": "single_input"}, {"score": 0.0028530201960995896, "phrase": "original_source_program"}, {"score": 0.0026743419827100225, "phrase": "novel_coupling"}, {"score": 0.0026570998719084153, "phrase": "static_and_dynamic_analyses"}, {"score": 0.0025725382476862305, "phrase": "concrete_test_input"}, {"score": 0.0024191966390855048, "phrase": "\"finish\"_placements"}, {"score": 0.0023497779149212737, "phrase": "static_scoping_rules"}, {"score": 0.0022897425998475362, "phrase": "empirical_results"}, {"score": 0.0022749744354271816, "phrase": "standard_benchmarks"}, {"score": 0.002260301305523054, "phrase": "student_homework_submissions"}, {"score": 0.0022384684697329097, "phrase": "parallel_computing_course"}, {"score": 0.0021049977753042253, "phrase": "repaired_code"}], "paper_keywords": ["Algorithms", " Languages", " Verification", " Data race", " Program repair", " Structured parallelism", " Async", " Finish"], "paper_abstract": "A common workflow for developing parallel software is as follows: 1) start with a sequential program, 2) identify subcomputations that should be converted to parallel tasks, 3) insert synchronization to achieve the same semantics as the sequential program, and repeat steps 2) and 3) as needed to improve performance. Though this is not the only approach to developing parallel software, it is sufficiently common to warrant special attention as parallel programming becomes ubiquitous. This paper focuses on automating step 3), which is usually the hardest step for developers who lack expertise in parallel programming. Past solutions to the problem of repairing parallel programs have used static-only or dynamic-only approaches, both of which incur significant limitations in practice. Static approaches can guarantee soundness in many cases but are limited in precision when analyzing medium or large-scale software with accesses to pointer-based data structures in multiple procedures. Dynamic approaches are more precise, but their proposed repairs are limited to a single input and are not reflected back in the original source program. In this paper, we introduce a hybrid static+dynamic test-driven approach to repairing data races in structured parallel programs. Our approach includes a novel coupling between static and dynamic analyses. First, we execute the program on a concrete test input and determine the set of data races for this input dynamically. Next, we compute a set of \"finish\" placements that prevent these races and also respects the static scoping rules of the program while maximizing parallelism. Empirical results on standard benchmarks and student homework submissions from a parallel computing course establish the effectiveness of our approach with respect to compile-time overhead, precision, and performance of the repaired code.", "paper_title": "Test-Driven Repair of Data Races in Structured Parallel Programs", "paper_id": "WOS:000344455800003"}