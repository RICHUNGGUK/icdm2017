{"auto_keywords": [{"score": 0.043720404506452044, "phrase": "proposed_method"}, {"score": 0.04035919930938948, "phrase": "state_classes"}, {"score": 0.038317712805750026, "phrase": "end-to-end_delays"}, {"score": 0.00481495049065317, "phrase": "temporal_analysis"}, {"score": 0.004768104290288521, "phrase": "time_petri_nets"}, {"score": 0.0046986841646790315, "phrase": "task's_end-to-end_delay"}, {"score": 0.004496402246090618, "phrase": "real-time_systems"}, {"score": 0.004366387782457736, "phrase": "configurable_state_class_method"}, {"score": 0.00428179779071721, "phrase": "petri_nets"}, {"score": 0.0041174821422410544, "phrase": "flexible_state_class_structure"}, {"score": 0.004057495982111461, "phrase": "firing_domain"}, {"score": 0.003959447096055027, "phrase": "kernel_domain"}, {"score": 0.0038827100184187805, "phrase": "basic_evolution"}, {"score": 0.003520687960750365, "phrase": "uniform_representation"}, {"score": 0.0034863899423238707, "phrase": "time_constraints"}, {"score": 0.0031457622320220364, "phrase": "firing_rules"}, {"score": 0.0030847461428168614, "phrase": "basic_timing_operations"}, {"score": 0.0027561164046279413, "phrase": "scalable_way"}, {"score": 0.0027159094186967247, "phrase": "new_timing_operations"}, {"score": 0.0026632323847975608, "phrase": "petri"}, {"score": 0.002573424607574822, "phrase": "arbitrary_end-to-end_delays"}, {"score": 0.002333193766510394, "phrase": "firing_transitions"}, {"score": 0.0022434880661725493, "phrase": "maximum_number"}, {"score": 0.0021999341184897217, "phrase": "configurable_and_kernel_domains"}, {"score": 0.002146676231930341, "phrase": "existing_state_class_methods"}, {"score": 0.0021049977753042253, "phrase": "better_performance"}], "paper_keywords": ["End-to-end delay analysis", " quantitative analysis", " state classes", " time Petri nets"], "paper_abstract": "A task's end-to-end delay in its execution is a key requirement to real-time systems. This paper presents a configurable state class method based on time Petri nets for their quantitative analysis. The proposed method has a flexible state class structure. A firing domain is separated into a kernel domain that supports the basic evolution of state classes, and a configurable domain that is used to evaluate end-to-end delays. Since both domains adopt a uniform representation for time constraints, end-to-end delays can be computed synchronously with the evolution of state classes via the same firing rules. Firing rules are decomposed into basic timing operations. This treatment not only makes the calculation of end-to-end delays more flexible, but also provides a scalable way to add new timing operations into a time Petri net model. The proposed method computes arbitrary end-to-end delays along a trace with time O(ml(2)) and space O(l(2)), where m is the number of firing transitions along the trace and l is the maximum number of transitions in configurable and kernel domains. Compared with the existing state class methods, it has better performance and flexibility in on-the-fly computation of end-to-end delays.", "paper_title": "A Configurable State Class Method for Temporal Analysis of Time Petri Nets", "paper_id": "WOS:000333118300008"}