{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "false_alarms"}, {"score": 0.009528121626612018, "phrase": "abstract_interpretation"}, {"score": 0.004771672073078768, "phrase": "buffer_overflow_analysis"}, {"score": 0.004728780808284175, "phrase": "smt_solvers"}, {"score": 0.00468627326602559, "phrase": "buffer_overflow_detection"}, {"score": 0.004644146045859622, "phrase": "static_analysis"}, {"score": 0.004561019117546361, "phrase": "powerful_tool"}, {"score": 0.0045200127552893704, "phrase": "software_programmers"}, {"score": 0.004459190343665408, "phrase": "difficult_bugs"}, {"score": 0.00441909542037375, "phrase": "c_programs"}, {"score": 0.0043793594257092805, "phrase": "sound_static_analysis"}, {"score": 0.00418595288276353, "phrase": "false_alarm_problem"}, {"score": 0.0037052054802048707, "phrase": "large_software"}, {"score": 0.0034467039994594065, "phrase": "increased_false_alarms"}, {"score": 0.003134503353065008, "phrase": "buffer_overflow_alarms"}, {"score": 0.00298238929037041, "phrase": "limited_areas"}, {"score": 0.002915701586760994, "phrase": "potential_false_alarms"}, {"score": 0.0028120802837806234, "phrase": "precise_analysis"}, {"score": 0.0027491902732542013, "phrase": "large_c_programs"}, {"score": 0.002687702958515561, "phrase": "symbolic_execution"}, {"score": 0.0026514708899935333, "phrase": "potential_alarms"}, {"score": 0.002603918128553617, "phrase": "previous_analysis"}, {"score": 0.002455168454109375, "phrase": "state-of-art_smt_solver"}, {"score": 0.0023571835517819124, "phrase": "substantial_number"}, {"score": 0.0022836785412390544, "phrase": "test_cases"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Buffer overflow", " Program analysis", " False alarm", " SMT solver"], "paper_abstract": "Buffer overflow detection using static analysis can provide a powerful tool for software programmers to find difficult bugs in C programs. Sound static analysis based on abstract interpretation, however, often suffers from false alarm problem. Although more precise abstraction can reduce the number of the false alarms in general, the cost to perform such analysis is often too high to be practical for large software. On the other hand, less precise abstraction is likely to be scalable in exchange for the increased false alarms. In order to attain both precision and scalability, we present a method that first applies less precise abstraction to find buffer overflow alarms fast, and selectively applies a more precise analysis only to the limited areas of code around the potential false alarms. In an attempt to develop the precise analysis of alarm filtering for large C programs, we perform a symbolic execution over the potential alarms found in the previous analysis, which is based on the abstract interpretation. Taking advantage of a state-of-art SMT solver, our precise analysis efficiently filters out a substantial number of false alarms. Our experiment with the test cases from three open source programs shows that our filtering method can reduce about 68% of false alarms on average. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Filtering false alarms of buffer overflow analysis using SMT solvers", "paper_id": "WOS:000273372400007"}