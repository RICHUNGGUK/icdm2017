{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "guarded_recursion"}, {"score": 0.025043697333957997, "phrase": "finite_observations"}, {"score": 0.004781777766309739, "phrase": "total_functional_programming"}, {"score": 0.004732444672509326, "phrase": "beguiling_vision"}, {"score": 0.003858936100805083, "phrase": "infinite_amount"}, {"score": 0.0037276938184125532, "phrase": "finite_time"}, {"score": 0.0036891952845575036, "phrase": "theoretical_underpinning"}, {"score": 0.003663749926218976, "phrase": "productive_programming"}, {"score": 0.0036384794303356413, "phrase": "infinite_output"}, {"score": 0.003576060405460302, "phrase": "category_theoretic_notion"}, {"score": 0.003551392586900308, "phrase": "final_coalgebras"}, {"score": 0.0034424690391411093, "phrase": "non-well-founded_codata"}, {"score": 0.0033484464719654105, "phrase": "well-founded_data"}, {"score": 0.0032121901685844803, "phrase": "productive_coprogramming"}, {"score": 0.003157061070428828, "phrase": "proof_assistants"}, {"score": 0.0031461995015365624, "phrase": "coq"}, {"score": 0.0031244424960907937, "phrase": "agda"}, {"score": 0.0030601947866320403, "phrase": "syntactic_guardedness_checkers"}, {"score": 0.002997269132281551, "phrase": "self-recursive_calls"}, {"score": 0.002825898877873034, "phrase": "syntactic_checks"}, {"score": 0.0026735591005209117, "phrase": "nakano"}, {"score": 0.0025914765323897604, "phrase": "flexible_and_compositional_type-based_approach"}, {"score": 0.002319503690965857, "phrase": "infinite_data"}, {"score": 0.0022327484973125936, "phrase": "clock_variables"}, {"score": 0.0022096550791379033, "phrase": "nakano's_guarded_recursion"}, {"score": 0.0021049977753042253, "phrase": "infinite_codata"}], "paper_keywords": ["Languages", " Theory", " Types", " Recursion", " coalgebras", " corecursion", " guarded recursion", " total functional programming"], "paper_abstract": "Total functional programming offers the beguiling vision that, just by virtue of the compiler accepting a program, we are guaranteed that it will always terminate. In the case of programs that are not intended to terminate, e. g., servers, we are guaranteed that programs will always be productive. Productivity means that, even if a program generates an infinite amount of data, each piece will be generated in finite time. The theoretical underpinning for productive programming with infinite output is provided by the category theoretic notion of final coalgebras. Hence, we speak of coprogramming with non-well-founded codata, as a dual to programming with well-founded data like finite lists and trees. Systems that offer facilities for productive coprogramming, such as the proof assistants Coq and Agda, currently do so through syntactic guardedness checkers, which ensure that all self-recursive calls are guarded by a use of a constructor. Such a check ensures productivity. Unfortunately, these syntactic checks are not compositional, and severely complicate coprogramming. Guarded recursion, originally due to Nakano, is tantalising as a basis for a flexible and compositional type-based approach to coprogramming. However, as we show, guarded recursion by itself is not suitable for coprogramming due to the fact that there is no way to make finite observations on pieces of infinite data. In this paper, we introduce the concept of clock variables that index Nakano's guarded recursion. Clock variables allow us to \"close over\" the generation of infinite codata, and to make finite observations, something that is not possible with guarded recursion alone.", "paper_title": "Productive Coprogramming with Guarded Recursion", "paper_id": "WOS:000327696700019"}