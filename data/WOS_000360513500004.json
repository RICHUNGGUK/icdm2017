{"auto_keywords": [{"score": 0.04119237718901736, "phrase": "binary_translator"}, {"score": 0.03420572160549086, "phrase": "corresponding_architecture_states"}, {"score": 0.015719716506582538, "phrase": "binary_translation"}, {"score": 0.015236594823031496, "phrase": "binary_code"}, {"score": 0.01379462953341482, "phrase": "mistranslated_instructions"}, {"score": 0.00474638212068261, "phrase": "important_technique"}, {"score": 0.004719227665313307, "phrase": "porting_programs"}, {"score": 0.004494570360108983, "phrase": "virtual_machines"}, {"score": 0.004183393072178239, "phrase": "application_program"}, {"score": 0.004030157055463817, "phrase": "automatic_validation_tools"}, {"score": 0.003961330917648707, "phrase": "hidden_problems"}, {"score": 0.0038713805573219297, "phrase": "new_validation_tool"}, {"score": 0.0038492126993451337, "phrase": "binary_translators"}, {"score": 0.0037834649508375544, "phrase": "original_binary_code"}, {"score": 0.003751011827704279, "phrase": "translated_binary_code"}, {"score": 0.003603193055343792, "phrase": "stored_values"}, {"score": 0.0035213462189102713, "phrase": "memory_cells"}, {"score": 0.003481120202034407, "phrase": "third_process"}, {"score": 0.003382547312072468, "phrase": "wrong_architecture_states"}, {"score": 0.0029637603945517313, "phrase": "architecture_states"}, {"score": 0.0028550709503536494, "phrase": "special_care"}, {"score": 0.0028305586112921583, "phrase": "memory_layouts"}, {"score": 0.0027741761880779535, "phrase": "corresponding_system"}, {"score": 0.0027424619603260837, "phrase": "exactly_the_same_values"}, {"score": 0.002530359917257626, "phrase": "architecture-state-comparison_problems"}, {"score": 0.0024586427394152196, "phrase": "automatic_validation"}, {"score": 0.00241658945942583, "phrase": "validation-block_method"}, {"score": 0.002327919463510933, "phrase": "instruction-level_validation"}, {"score": 0.002294686545883412, "phrase": "quick_validation"}, {"score": 0.002268441347979241, "phrase": "extremely_fast_validation"}, {"score": 0.002185195325707735, "phrase": "different_binary_translators"}], "paper_keywords": ["Binary translation", " Validation", " ARM", " QEMU", " Architecture state"], "paper_abstract": "Binary translation is an important technique for porting programs as it allows binary code for one platform to execute on another. It is widely used in virtual machines and emulators. However, implementing a correct (and efficient) binary translator is still very challenging because many delicate details must be handled smartly. Manually identifying mistranslated instructions in an application program is difficult, especially when the application is large. Therefore, automatic validation tools are needed urgently to uncover hidden problems in a binary translator. We developed a new validation tool for binary translators. In our validation tool, the original binary code and the translated binary code run simultaneously. Both versions of the binary code continuously send their architecture states and the stored values, which are the values stored into memory cells, to a third process, the validator. Since most mistranslated instructions will result in wrong architecture states during execution, our validator can catch most mistranslated instructions emitted by a binary translator by comparing the corresponding architecture states. Corresponding architecture states may differ due to (1) translation errors, (2) different (but correct) memory layouts, and (3) return values of certain system calls. The need to differentiate the three sources of differences makes comparing architecture states very difficult, if not impossible. in our validator, we take special care to make memory layouts exactly the same and make the corresponding system calls always return exactly the same values in the original and in the. translated binaries. Therefore, any differences in the corresponding architecture states indicate mistranslated instructions emitted by the binary translator. Besides solving the architecture-state-comparison problems, we also propose several methods to speed up the automatic validation. The first is the validation-block method, which reduces the number of validations while keeping the accuracy of instruction-level validation. The second is quick validation, which provides extremely fast validation at the expense of less accurate error information. Our validator can be applied to different binary translators. In our experiment, the validator has successfully validated programs translated by static, dynamic, and hybrid binary translators. (C) 2015 Elsevier Ltd. All rights reserved.", "paper_title": "Automatic validation for binary translation", "paper_id": "WOS:000360513500004"}