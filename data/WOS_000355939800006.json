{"auto_keywords": [{"score": 0.02997165440966494, "phrase": "second_result"}, {"score": 0.00481495049065317, "phrase": "approximate_full-text_indexing"}, {"score": 0.004547564208690591, "phrase": "indexing_texts"}, {"score": 0.004294962474996283, "phrase": "text_t"}, {"score": 0.004257360656055417, "phrase": "n_characters"}, {"score": 0.00416478405812793, "phrase": "size_sigma"}, {"score": 0.004020813632357377, "phrase": "data_structure"}, {"score": 0.003780692127133743, "phrase": "edit_distance"}, {"score": 0.0036499505265403377, "phrase": "length_m."}, {"score": 0.00346223706087128, "phrase": "first_result"}, {"score": 0.0033868916699805224, "phrase": "unbounded_alphabet"}, {"score": 0.0028652153774536967, "phrase": "cole_et_al"}, {"score": 0.002753891109273246, "phrase": "constant_alphabet"}, {"score": 0.002705808393126695, "phrase": "compressed_text_indices"}, {"score": 0.002623669616798891, "phrase": "first_variant"}, {"score": 0.002381365139274329, "phrase": "second_variant"}, {"score": 0.0021805201234139475, "phrase": "previously_best_results"}, {"score": 0.0021613897794439227, "phrase": "constant_alphabets"}, {"score": 0.0021330078238529443, "phrase": "lam_et_al"}, {"score": 0.0021049977753042253, "phrase": "chan_et_al"}], "paper_keywords": ["Compressed index", " Edit distance", " Approximate string matching"], "paper_abstract": "In this paper we are interested in indexing texts for substring matching queries with one edit error. That is, given a text T of n characters over an alphabet of size sigma, we are asked to build a data structure that answers the following query: find all the occ substrings of the text that are at edit distance at most 1 from a given string q of length m. In this paper we show two new results for this problem. The first result, suitable for an unbounded alphabet, uses O(nlog (epsilon) n) (where epsilon is any constant such that 0 <epsilon < 1) words of space and answers to queries in time O(m+occ). This improves simultaneously in space and time over the result of Cole et al. The second result, suitable only for a constant alphabet, relies on compressed text indices and comes in two variants: the first variant uses O(nlog (epsilon) n) bits of space and answers to queries in time O(m+occ), while the second variant uses O(nloglogn) bits of space and answers to queries in time O((m+occ)loglogn). This second result improves on the previously best results for constant alphabets achieved in Lam et al. and Chan et al.", "paper_title": "Improved Space-Time Tradeoffs for Approximate Full-Text Indexing with One Edit Error", "paper_id": "WOS:000355939800006"}