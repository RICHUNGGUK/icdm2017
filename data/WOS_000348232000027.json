{"auto_keywords": [{"score": 0.02417637699135323, "phrase": "openstream"}, {"score": 0.00481495049065317, "phrase": "dynamic_dataflow_parallelization"}, {"score": 0.004767261858417823, "phrase": "tiled_programs"}, {"score": 0.004720043307726269, "phrase": "task-parallel_languages"}, {"score": 0.004513255056769647, "phrase": "expressive_mechanisms"}, {"score": 0.0044685410845412745, "phrase": "intertask_synchronization"}, {"score": 0.004272724011826495, "phrase": "data-driven_execution_semantics"}, {"score": 0.004188459638572375, "phrase": "starss_research_language"}, {"score": 0.0038102613924627647, "phrase": "improved_scalability"}, {"score": 0.0037724857647796813, "phrase": "load_balancing"}, {"score": 0.0037350832473790007, "phrase": "memory_latency_hiding"}, {"score": 0.0036070601923916196, "phrase": "memory_bandwidth"}, {"score": 0.003500812175550438, "phrase": "side_effect"}, {"score": 0.003448863509392547, "phrase": "power_consumption"}, {"score": 0.0032975819773787985, "phrase": "systematic_approach"}, {"score": 0.0032486392192981944, "phrase": "loop_nests"}, {"score": 0.0030906666356950887, "phrase": "simple_and_effective_heuristic"}, {"score": 0.002984665318717504, "phrase": "dependence_type"}, {"score": 0.002955050521440921, "phrase": "communication_pattern"}, {"score": 0.0027557911038816256, "phrase": "numerical_computations"}, {"score": 0.002701361707441567, "phrase": "linear_algebra"}, {"score": 0.0026745503978347143, "phrase": "structured_grids"}, {"score": 0.0026480044868438875, "phrase": "image_processing"}, {"score": 0.0026086775334428617, "phrase": "proposed_static_analysis"}, {"score": 0.0025827837420330816, "phrase": "code_generation"}, {"score": 0.0025066304722422463, "phrase": "full-blown_dependence_resolver"}, {"score": 0.0023028105026714533, "phrase": "ppcg_compiler"}, {"score": 0.002158179521369965, "phrase": "explicit_intertask_dependences"}, {"score": 0.002126111716875142, "phrase": "lightweight_runtime"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": ["Languages", " Performance", " Compilers", " Task Parallelism", " Dataflow", " point-to-point synchronization", " auto-parallelization", " polyhedral framework", " polyhedral compiler", " tiling", " dynamic wavefront", " dependence partitioning", " tile dependences"], "paper_abstract": "Task-parallel languages are increasingly popular. Many of them provide expressive mechanisms for intertask synchronization. For example, OpenMP 4.0 will integrate data-driven execution semantics derived from the StarSs research language. Compared to the more restrictive data-parallel and fork-join concurrency models, the advanced features being introduced into task-parallelmodels in turn enable improved scalability through load balancing, memory latency hiding, mitigation of the pressure on memory bandwidth, and, as a side effect, reduced power consumption. In this article, we develop a systematic approach to compile loop nests into concurrent, dynamically constructed graphs of dependent tasks. We propose a simple and effective heuristic that selects the most profitable parallelization idiom for every dependence type and communication pattern. This heuristic enables the extraction of interband parallelism (cross-barrier parallelism) in a number of numerical computations that range from linear algebra to structured grids and image processing. The proposed static analysis and code generation alleviates the burden of a full-blown dependence resolver to track the readiness of tasks at runtime. We evaluate our approach and algorithms in the PPCG compiler, targeting OpenStream, a representative dataflow task-parallel language with explicit intertask dependences and a lightweight runtime. Experimental results demonstrate the effectiveness of the approach.", "paper_title": "Compiler/Runtime Framework for Dynamic Dataflow Parallelization of Tiled Programs", "paper_id": "WOS:000348232000027"}