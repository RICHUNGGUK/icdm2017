{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "javascript"}, {"score": 0.011156630821592135, "phrase": "virtual_machines"}, {"score": 0.004723322467153553, "phrase": "js_of_ocaml_compiler"}, {"score": 0.0043738432231020885, "phrase": "ocaml_bytecode"}, {"score": 0.004050116768809519, "phrase": "static_single-assignment_intermediate_representation"}, {"score": 0.0035173498506324476, "phrase": "high-level_language"}, {"score": 0.003450329424861292, "phrase": "sensible_choice"}, {"score": 0.0028830690329478465, "phrase": "existing_installation"}, {"score": 0.0028281000453392272, "phrase": "development_tools"}, {"score": 0.0027920359090544107, "phrase": "already-compiled_libraries"}, {"score": 0.00236289633510808, "phrase": "javascript_compiler"}, {"score": 0.0022302306304023602, "phrase": "web_browsers"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler", " OCaml", " JavaScript", " bytecode"], "paper_abstract": "We present the design and implementation of a compiler from OCaml bytecode to JavaScript. The compiler first translates the bytecode into a static single-assignment intermediate representation on which optimizations are performed, before generating JavaScript. We believe that taking bytecode as an input instead of a high-level language is a sensible choice. Virtual machines provide a very stable API. Such a compiler is thus easy to maintain. It is also convenient to use, and it can just be added to an existing installation of the development tools. Already-compiled libraries can be used directly, with no need to reinstall anything. Finally, some virtual machines are the target of several languages. A bytecode to JavaScript compiler would make it possible to retarget all these languages to Web browsers at once. Copyright (C) 2013 John Wiley & Sons, Ltd.", "paper_title": "From bytecode to JavaScript: the Js_of_ocaml compiler", "paper_id": "WOS:000339479400005"}