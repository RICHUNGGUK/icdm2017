{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "magic_wands"}, {"score": 0.014125456693413863, "phrase": "magic_wand"}, {"score": 0.006863571296803753, "phrase": "separation_logic"}, {"score": 0.004739056045644449, "phrase": "static_verification"}, {"score": 0.004489810932879285, "phrase": "incomplete_resources"}, {"score": 0.004391013899148212, "phrase": "missing_resources"}, {"score": 0.004213240903095234, "phrase": "completed_resources"}, {"score": 0.0041074234667687875, "phrase": "magic_wand_operator"}, {"score": 0.004055511503825102, "phrase": "loop_invariants"}, {"score": 0.003978866233891427, "phrase": "data_structure"}, {"score": 0.003916098498242888, "phrase": "imperative_version"}, {"score": 0.0038626224541741735, "phrase": "annotated_java_programs"}, {"score": 0.003789608730945311, "phrase": "chalice"}, {"score": 0.003709974534103202, "phrase": "motivating_example"}, {"score": 0.0033084729942065142, "phrase": "program_annotator"}, {"score": 0.002997628439369723, "phrase": "permission_exchange"}, {"score": 0.002912963877144772, "phrase": "extra_resources"}, {"score": 0.002821685815956478, "phrase": "witness_information"}, {"score": 0.0026224255640133758, "phrase": "vercors_tool"}, {"score": 0.0025646139644088803, "phrase": "chalice_programs"}, {"score": 0.0024921488266216024, "phrase": "boogiepl"}, {"score": 0.002468450551616404, "phrase": "appropriate_proof_obligations"}, {"score": 0.0022578275190855124, "phrase": "abstract_predicates"}, {"score": 0.0022434880661725493, "phrase": "permission_parameters"}, {"score": 0.0021049977753042253, "phrase": "linked_list"}], "paper_keywords": ["Formal methods", " Program verification", " Correctness proofs", " Mechanical verification", " Specification techniques", " Separation logic"], "paper_abstract": "This paper discusses static verification of programs that have been specified using separation logic with magic wands. Magic wands are used to specify incomplete resources in separation logic, i.e., if missing resources are provided, a magic wand allows one to exchange these for the completed resources. One of the applications of the magic wand operator is to describe loop invariants for algorithms that traverse a data structure, such as the imperative version of the tree delete problem (Challenge 3 from the VerifyThis@FM2012 Program Verification Competition), which is the motivating example for our work. Most separation logic-based static verification tools do not provide support for magic wands, possibly because validity of formulas containing the magic wand is, by itself, undecidable. To avoid this problem, in our approach the program annotator has to provide a witness for the magic wand, thus circumventing undecidability due to the use of magic wands. A witness is an object that encodes both instructions for the permission exchange that is specified by the magic wand and the extra resources needed during that exchange. We show how this witness information is used to encode a specification with magic wands as a specification without magic wands. Concretely, this approach is used in the VerCors tool set: annotated Java programs are encoded as Chalice programs. Chalice then further translates the program to BoogiePL, where appropriate proof obligations are generated. Besides our encoding of magic wands, we also discuss the encoding of other aspects of annotated Java programs into Chalice, and in particular, the encoding of abstract predicates with permission parameters. We illustrate our approach on the tree delete algorithm, and on the verification of an iterator of a linked list.", "paper_title": "Witnessing the elimination of magic wands", "paper_id": "WOS:000362687300008"}