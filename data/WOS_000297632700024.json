{"auto_keywords": [{"score": 0.04561838947368895, "phrase": "input_program"}, {"score": 0.03856581696447045, "phrase": "different_terms"}, {"score": 0.03799635259867219, "phrase": "different_types"}, {"score": 0.00481495049065317, "phrase": "typed_self-interpretation"}, {"score": 0.004300830853119242, "phrase": "canonical_representation"}, {"score": 0.004064653055162238, "phrase": "major_progress"}, {"score": 0.004023120753104693, "phrase": "statically-typed_languages"}, {"score": 0.0038414347726177024, "phrase": "hofer"}, {"score": 0.0037632749713937637, "phrase": "first_typed_self-recogniser"}, {"score": 0.0035565113234273926, "phrase": "key_feature"}, {"score": 0.003343841875107018, "phrase": "kind_system"}, {"score": 0.003176333519010176, "phrase": "first_statically-typed_language"}, {"score": 0.0027789349951704177, "phrase": "factorisation_calculus"}, {"score": 0.002708401145726539, "phrase": "jay"}, {"score": 0.0025726416100664853, "phrase": "factorisation_operator"}, {"score": 0.002468938912850425, "phrase": "pattern-matching_functions"}, {"score": 0.0022047613106966745, "phrase": "system_f"}], "paper_keywords": ["Languages", " Theory", " self-interpretation", " pattern matching"], "paper_abstract": "Self-interpreters can be roughly divided into two sorts: self-recognisers that recover the input program from a canonical representation, and self-enactors that execute the input program. Major progress for statically-typed languages was achieved in 2009 by Rendel, Ostermann, and Hofer who presented the first typed self-recogniser that allows representations of different terms to have different types. A key feature of their type system is a type: type rule that renders the kind system of their language inconsistent. In this paper we present the first statically-typed language that not only allows representations of different terms to have different types, and supports a self-recogniser, but also supports a self-enactor. Our language is a factorisation calculus in the style of Jay and Given-Wilson, a combinatory calculus with a factorisation operator that is powerful enough to support the pattern-matching functions necessary for a self-interpreter. This allows us to avoid a type: type rule. Indeed, the types of System F are sufficient. We have implemented our approach and our experiments support the theory.", "paper_title": "Typed Self-Interpretation by Pattern Matching", "paper_id": "WOS:000297632700024"}