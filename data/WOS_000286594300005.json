{"auto_keywords": [{"score": 0.04954033184026153, "phrase": "classical_linear_logic"}, {"score": 0.03921658896613619, "phrase": "session_types"}, {"score": 0.02835704402028157, "phrase": "lolliproc"}, {"score": 0.004815115673797792, "phrase": "concurrency"}, {"score": 0.004707190245066263, "phrase": "curry-howard"}, {"score": 0.00447341965028879, "phrase": "intuitionistic_fragment"}, {"score": 0.004423061344624088, "phrase": "linear_logic"}, {"score": 0.004251210982670317, "phrase": "programming_languages"}, {"score": 0.00417961150804265, "phrase": "full_power"}, {"score": 0.004132546937996706, "phrase": "linear_logic-including_double-negation_elimination"}, {"score": 0.0037959868107895053, "phrase": "concurrent_programs-e.g"}, {"score": 0.003546513036085932, "phrase": "concurrent_programming"}, {"score": 0.003332210257373994, "phrase": "concurrency_primitives"}, {"score": 0.0032946562900625187, "phrase": "lambda_calculi"}, {"score": 0.0030606302942851027, "phrase": "concurrent_functional_programming"}, {"score": 0.003009022147559257, "phrase": "language_lolliproc"}, {"score": 0.0029415584202462444, "phrase": "simple_primitives"}, {"score": 0.002843180211561427, "phrase": "direct_logical_interpretation"}, {"score": 0.0026262033625248445, "phrase": "simple_process_calculus"}, {"score": 0.0022919762167777427, "phrase": "strong_normalization"}, {"score": 0.002253299769886694, "phrase": "confluence_results"}, {"score": 0.0021049977753042253, "phrase": "race_conditions"}], "paper_keywords": ["Design", " Languages", " Theory", " Linear logic", " Concurrency", " Type systems"], "paper_abstract": "While many type systems based on the intuitionistic fragment of linear logic have been proposed, applications in programming languages of the full power of linear logic-including double-negation elimination-have remained elusive. Meanwhile, linearity has been used in many type systems for concurrent programs-e.g., session types-which suggests applicability to the problems of concurrent programming, but the ways in which linearity has interacted with concurrency primitives in lambda calculi have remained somewhat ad-hoc. In this paper we connect classical linear logic and concurrent functional programming in the language Lolliproc, which provides simple primitives for concurrency that have a direct logical interpretation and that combine to provide the functionality of session types. Lolliproc features a simple process calculus \"under the hood\" but hides the machinery of processes from programmers. We illustrate Lolliproc by example and prove soundness, strong normalization, and confluence results, which, among other things, guarantees freedom from deadlocks and race conditions.", "paper_title": "Lolliproc: to Concurrency from Classical Linear Logic via Curry-Howard and Control", "paper_id": "WOS:000286594300005"}