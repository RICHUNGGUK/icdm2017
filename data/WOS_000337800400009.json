{"auto_keywords": [{"score": 0.03626275334087338, "phrase": "utility_models"}, {"score": 0.00481495049065317, "phrase": "application_utility_models"}, {"score": 0.004652016085325825, "phrase": "thread_counts"}, {"score": 0.004533427352547707, "phrase": "today's_multiprocessor_systems"}, {"score": 0.004379977556546879, "phrase": "multi-threaded_applications"}, {"score": 0.004268293864953256, "phrase": "cache_space"}, {"score": 0.004195418010131832, "phrase": "cpu_time"}, {"score": 0.0038825121288253435, "phrase": "application_thread_count"}, {"score": 0.003501175642882274, "phrase": "thread_count"}, {"score": 0.003353521531649663, "phrase": "utility_model"}, {"score": 0.003296212583539166, "phrase": "application_performance"}, {"score": 0.0029722900280316216, "phrase": "linear_regression"}, {"score": 0.0027741761880779535, "phrase": "system_policy"}, {"score": 0.002703327151461985, "phrase": "configure_applications'_thread_counts"}, {"score": 0.0023752608301406343, "phrase": "qos."}, {"score": 0.0023145690608400425, "phrase": "system_throughput"}, {"score": 0.0021049977753042253, "phrase": "best_evaluated_traditional_policy"}], "paper_keywords": ["Multicore", " Multithreading", " Quality of service", " Performance model", " Interference"], "paper_abstract": "On today's multiprocessor systems, simultaneously executing multi-threaded applications contend for cache space and CPU time. This contention can be managed by changing application thread count. In this paper, we describe a technique to configure thread count using utility models. A utility model predicts application performance given its thread count and other workload thread counts. Built offline with linear regression, utility models are used online by a system policy to dynamically configure applications' thread counts. We present a policy which uses the models to maximize throughput while maintaining QoS. Our approach improves system throughput by 6 % and meets QoS 22 % more often than the best evaluated traditional policy.", "paper_title": "Building and using application utility models to dynamically choose thread counts", "paper_id": "WOS:000337800400009"}