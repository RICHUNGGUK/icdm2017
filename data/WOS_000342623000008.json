{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "rearrangeable_multicast_networks"}, {"score": 0.03252422696923042, "phrase": "known_method"}, {"score": 0.004665483918844599, "phrase": "set_s-n"}, {"score": 0.004592491583367684, "phrase": "situ_programs"}, {"score": 0.004506399797123487, "phrase": "extra_variables"}, {"score": 0.004271100220705305, "phrase": "extra_memory"}, {"score": 0.004112411350177274, "phrase": "previous_papers"}, {"score": 0.003934681262271618, "phrase": "new_results"}, {"score": 0.0038608730929994696, "phrase": "bijective_mapping"}, {"score": 0.0034899090274046014, "phrase": "general_arbitrary_mapping"}, {"score": 0.0033814348757887232, "phrase": "maximal_length"}, {"score": 0.003307508702661699, "phrase": "rearrangeable_multicast_routing_methods"}, {"score": 0.003224992202194877, "phrase": "alternating_reversions"}, {"score": 0.003194580334752371, "phrase": "first_method"}, {"score": 0.00305639530600272, "phrase": "network_theory"}, {"score": 0.003027568488234868, "phrase": "second_method"}, {"score": 0.002933422608537915, "phrase": "vertical_bar_s_vertical_bar"}, {"score": 0.0027712559151232843, "phrase": "linear_mapping"}, {"score": 0.0026597250663309385, "phrase": "euclidean_domain"}, {"score": 0.0023887436047824386, "phrase": "algorithmic_viewpoint"}, {"score": 0.0023512871357696022, "phrase": "directly_a_program"}, {"score": 0.0022637650216685906, "phrase": "new_result"}, {"score": 0.0022494973475924024, "phrase": "matrix_decompositions"}, {"score": 0.0021933182759089364, "phrase": "multicast_properties"}, {"score": 0.0021049977753042253, "phrase": "boolean_field"}], "paper_keywords": ["mapping computation", " memory optimization", " multistage interconnection network", " multicast rearrangeability", " butterfly", " bijective mapping", " boolean mapping", " combinatorial logic", " linear mapping", " modular arithmetic", " matrix decomposition"], "paper_abstract": "We investigate the computation of mappings from a set S-n to itself with in situ programs, that is using no extra variables than the input, and performing modifications of one component at a time, hence using no extra memory. In this paper, we survey this problem introduced in previous papers by the authors, we detail its close relation with rearrangeable multicast networks, and we provide new results for both viewpoints. A bijective mapping can be computed by 2n - 1 component modifications, that is by a program of length 2n - 1, a result equivalent to the rearrangeability of the concatenation of two reversed butterfly networks. For a general arbitrary mapping, we give two methods to build a program with maximal length 4n - 3. Equivalently, this yields rearrangeable multicast routing methods for the network formed by four successive butterflies with alternating reversions. The first method is available for any set S and practically equivalent to a known method in network theory. The second method, a refinement of the first, described when vertical bar S vertical bar is a power of 2, is new and allows more flexibility than the known method. For a linear mapping, when S is any field, or a quotient of an Euclidean domain (e. g. Z/sZ for any integer s), we build a program with maximal length 2n - 1. In this case the assignments are also linear, thereby particularly efficient from the algorithmic viewpoint, and giving moreover directly a program for the inverse when it exists. This yields also a new result on matrix decompositions, and a new result on the multicast properties of two successive reversed butterflies. Results of this flavour were known only for the boolean field Z/2Z.", "paper_title": "Computation with No Memory, and Rearrangeable Multicast Networks", "paper_id": "WOS:000342623000008"}