{"auto_keywords": [{"score": 0.0047395356621991935, "phrase": "important_aspect"}, {"score": 0.004379737380744606, "phrase": "scalability_characteristics"}, {"score": 0.004243552607799184, "phrase": "high_level_knowledge"}, {"score": 0.003941964605885606, "phrase": "temporal_application_characteristics"}, {"score": 0.00388016972840459, "phrase": "cache_reuse"}, {"score": 0.0036424917384748024, "phrase": "execution_control_flow"}, {"score": 0.0036043137580229873, "phrase": "openmp_applications"}, {"score": 0.0035477930970463432, "phrase": "compact_way"}, {"score": 0.0034193226278107346, "phrase": "full_trace"}, {"score": 0.003383475802364289, "phrase": "program_execution_events"}, {"score": 0.0032609360162842767, "phrase": "straightforward_extension"}, {"score": 0.003209782650616367, "phrase": "summary_data"}, {"score": 0.0031262984171100856, "phrase": "existing_profiling_tool"}, {"score": 0.0030772505522663612, "phrase": "multithreaded_applications"}, {"score": 0.002798662730881037, "phrase": "execution_dynamics"}, {"score": 0.002711506442590442, "phrase": "full_flexibility"}, {"score": 0.002654911400878851, "phrase": "independent_threads"}, {"score": 0.002558706570254187, "phrase": "openmp"}, {"score": 0.0024789887640568093, "phrase": "largely_uniform_way"}, {"score": 0.0024144659350277954, "phrase": "sequence_points"}, {"score": 0.002326938965568362, "phrase": "different_data_items"}, {"score": 0.0023025177990160487, "phrase": "worksharing_constructs"}, {"score": 0.0021957487795963666, "phrase": "simplified_representation"}, {"score": 0.0021612684684351974, "phrase": "execution_control"}, {"score": 0.0021049977753042253, "phrase": "similar_behavior"}], "paper_keywords": ["Performance analysis", " Control flow recording", " Control flow visualization", " Program phase detection"], "paper_abstract": "An important aspect of understanding the behavior of applications with respect to their performance, overhead, and scalability characteristics is knowledge of their execution control flow. High level knowledge of which functions or constructs were executed after which other constructs allows reasoning about temporal application characteristics such as cache reuse. This paper describes an approach to capture and visualize the execution control flow of OpenMP applications in a compact way. Our approach does not require a full trace of program execution events but is instead based on a straightforward extension to the summary data already collected by an existing profiling tool. In multithreaded applications each thread may define its own independent flow of control, complicating both the recording as well as the visualization of the execution dynamics. Our approach allows for the full flexibility with respect to independent threads. However, the most common usage models of OpenMP have threads operate in a largely uniform way, synchronizing frequently at sequence points and diverging only to operate on different data items in worksharing constructs. Our approach accounts for this by offering a simplified representation of the execution control flow for threads with similar behavior.", "paper_title": "Capturing and Analyzing the Execution Control Flow of OpenMP Applications", "paper_id": "WOS:000266089000003"}