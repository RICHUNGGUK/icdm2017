{"auto_keywords": [{"score": 0.04355159126538614, "phrase": "candidate_space"}, {"score": 0.00481495049065317, "phrase": "next_decade"}, {"score": 0.00478163886605204, "phrase": "program_synthesis"}, {"score": 0.004732100994830163, "phrase": "contemporary_answer"}, {"score": 0.0046993598473345395, "phrase": "automatic_programming"}, {"score": 0.004523272849033429, "phrase": "batch_automation"}, {"score": 0.004323620278409076, "phrase": "programming_problem"}, {"score": 0.003991646181215783, "phrase": "acceptable_program"}, {"score": 0.003909301559145041, "phrase": "incomplete_specifications"}, {"score": 0.0036468482216440233, "phrase": "construction_derivation_rules"}, {"score": 0.0035965032173588753, "phrase": "hardware_design"}, {"score": 0.0035468507553681034, "phrase": "end-user_programming"}, {"score": 0.0035100601949451028, "phrase": "systems_biology"}, {"score": 0.0033201720993656734, "phrase": "novel_abstractions"}, {"score": 0.003107935254560724, "phrase": "large_software"}, {"score": 0.0030331993611107328, "phrase": "stepwise_refinement"}, {"score": 0.002657677633954843, "phrase": "synthesis_problem"}, {"score": 0.002630085891013006, "phrase": "search_algorithm"}, {"score": 0.0023776656246300063, "phrase": "synthesis_advance"}, {"score": 0.002344800544183559, "phrase": "plain_programs"}, {"score": 0.002233301265743633, "phrase": "type_systems"}, {"score": 0.0022101055924375725, "phrase": "modeling_languages"}, {"score": 0.002119702106867801, "phrase": "crown_jewel"}, {"score": 0.0021049977753042253, "phrase": "programming_languages_research"}], "paper_keywords": ["Programming Languages", " Program Synthesis"], "paper_abstract": "Program synthesis is the contemporary answer to automatic programming. It innovates in two ways: First, it replaces batch automation with interactivity, assisting the programmer in refining the understanding of the programming problem. Second, it produces programs using search in a candidate space rather than by derivation from a specification. Searching for an acceptable program means that we can accommodate incomplete specifications, such as examples. Additionally, search makes synthesis applicable to domains that lack correct-by-construction derivation rules, such as hardware design, education, end-user programming, and systems biology. The future of synthesis rests on four challenges, each presenting an opportunity to develop novel abstractions for \"programming with search.\" Larger scope: today, we synthesize small, flat programs; synthesis of large software will need constructs for modularity and stepwise refinement. New interaction modes: to solicit the specification without simply asking for more examples, we need to impose a structure on the candidate space and explore it in a dialogue. Construction: how to compile a synthesis problem to a search algorithm without building a compiler? Everything is a program: whatever can be phrased as a program can be in principle synthesized. Indeed, we will see synthesis advance from synthesis of plain programs to synthesis of compilers and languages. The latter may include DSLs, type systems, and modeling languages for biology. As such, synthesis could help mechanize the crown jewel of programming languages research - the design of abstractions - which has so far been done manually and only by experts.", "paper_title": "Program Synthesis: Opportunities for the Next Decade", "paper_id": "WOS:000367255800001"}