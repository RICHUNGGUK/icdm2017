{"auto_keywords": [{"score": 0.014775725567914871, "phrase": "pei_et_al"}, {"score": 0.010435409021063343, "phrase": "empirical_study"}, {"score": 0.00481495049065317, "phrase": "shortest_unique_substring_queries"}, {"score": 0.004656871909510407, "phrase": "shortest_unique_substring"}, {"score": 0.004618209011847634, "phrase": "sus"}, {"score": 0.0035204268675160257, "phrase": "inverse_suffix_array"}, {"score": 0.00347657813672945, "phrase": "longest_common_prefix_array"}, {"score": 0.0033482708495261864, "phrase": "suffix_tree"}, {"score": 0.0031579997262619758, "phrase": "real-world_data"}, {"score": 0.0027974705482714884, "phrase": "string_size"}, {"score": 0.0026494723416072316, "phrase": "recent_tsuruta_et_al"}, {"score": 0.002436888552432559, "phrase": "sus_finding"}, {"score": 0.002346861891137455, "phrase": "nearly_the_same_processing_speed"}, {"score": 0.002158505888557744, "phrase": "string_location"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Unique substring", " Shortest unique substring", " Repetitiveness", " Regularity"], "paper_abstract": "We revisit the problem of finding shortest unique substring (SUS) proposed recently by Pei et al. (2013) [12]. We propose an optimal O(n) time and space algorithm that can find an SUS for every location of a string of size n and thus significantly improve their O(n(2)) time complexity. Our method also supports finding all the SUSes covering every location, whereas theirs can find only one SUS for every location. Further, our solution is simpler and easier to implement and is more space efficient in practice, since we only use the inverse suffix array and the longest common prefix array of the string, while their algorithm uses the suffix tree of the string and other auxiliary data structures. Our theoretical results are validated by an empirical study with real-world data that shows our method is at least 8 times faster and uses at least 20 times less memory. The speedup gained by our method against Pei et al's can become even more significant when the string size increases due to their quadratic time complexity. We also have compared our method with the recent Tsuruta et al.'s (2014) [14] proposal, another independent 0(n) time and space algorithm for SUS finding. The empirical study shows that both methods have nearly the same processing speed. However, ours uses at least 4 times less memory for finding one SUS and at least 2 times less memory for finding all SUSes, both covering every string location. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "A simple yet time-optimal and linear-space algorithm for shortest unique substring queries", "paper_id": "WOS:000347602000043"}