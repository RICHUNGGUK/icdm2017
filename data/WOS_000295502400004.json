{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "design_and_design_methods"}, {"score": 0.004593591780245872, "phrase": "hecc."}, {"score": 0.004428452434981208, "phrase": "unified_multiplier"}, {"score": 0.0041590143308280775, "phrase": "umi"}, {"score": 0.0036873373225096624, "phrase": "hyperelliptic_curve_cryptography"}, {"score": 0.003536210531933836, "phrase": "fpga"}, {"score": 0.0029284999172756103, "phrase": "smaller_data-path"}, {"score": 0.0028527866590859967, "phrase": "faster_scalar_multiplication"}, {"score": 0.0025025186963415, "phrase": "high_through-put_version"}, {"score": 0.002399893363309833, "phrase": "ram"}, {"score": 0.002362320344521919, "phrase": "xilinx_virtex-ii_fpga"}, {"score": 0.002253461585851626, "phrase": "lightweight_version"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Modular multiplication", " Inversion", " Hyperelliptic curve cryptography"], "paper_abstract": "This paper describes two novel architectures for a unified multiplier and inverter (UMI) in GF(2(m)): the UMI merges multiplier and inverter into one unified data-path. As such, the area of the data-path is reduced. We present two options for hyperelliptic curve cryptography (HECC) using UMIs: an FPGA-based high-performance implementation (Type-I) and an ASIC-based lightweight implementation (Type-II). The use of a UMI combined with affine coordinates brings a smaller data-path, smaller memory and faster scalar multiplication. Both implementations use curves defined by h(x)=x and f(x) = x(5) +f(3)x(3) + x(2) + f(0). The high through-put version uses 2316 slices and 2016 bits of block RAM on a Xilinx Virtex-II FPGA, and finishes one scalar multiplication in 311 mu s. The lightweight version uses only 14.5 kGates, and one scalar multiplication takes 450 ms. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Design and design methods for unified multiplier and inverter and its application for HECC", "paper_id": "WOS:000295502400004"}