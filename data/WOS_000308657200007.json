{"auto_keywords": [{"score": 0.034225892002261095, "phrase": "swift"}, {"score": 0.0122615391714314, "phrase": "code_quality"}, {"score": 0.007421784651180722, "phrase": "selective_compilation"}, {"score": 0.005547342105640741, "phrase": "virtual_registers"}, {"score": 0.005099428350078034, "phrase": "register-based_bytecode"}, {"score": 0.00481495049065317, "phrase": "jit_compiler"}, {"score": 0.004783852487938866, "phrase": "embedded_jvms"}, {"score": 0.004722254884093624, "phrase": "compilation_speed"}, {"score": 0.004661446705304497, "phrase": "jit_compilers"}, {"score": 0.004202223763361474, "phrase": "flat_execution_profile"}, {"score": 0.004198445147336639, "phrase": "android"}, {"score": 0.004175066536037121, "phrase": "short_live_time"}, {"score": 0.004134658048970194, "phrase": "lightweight_jit_technique"}, {"score": 0.003951175193382119, "phrase": "stack-based_java_bytecode"}, {"score": 0.003925633992809873, "phrase": "heterogeneous_register-based_machine_code"}, {"score": 0.003788069044402032, "phrase": "fast_and_effective_jit_technique"}, {"score": 0.003691048155818806, "phrase": "register-based_java_bytecode_format"}, {"score": 0.0036081880905161606, "phrase": "underlying_machine_architecture"}, {"score": 0.0035616743422949766, "phrase": "comprehensive_study"}, {"score": 0.0035043714971173252, "phrase": "java_applications"}, {"score": 0.0031281730014429666, "phrase": "native_code"}, {"score": 0.003107935254560724, "phrase": "risc_machines"}, {"score": 0.0030480018094535158, "phrase": "physical_registers"}, {"score": 0.002941100683384888, "phrase": "translation_table"}, {"score": 0.0028564228386290615, "phrase": "static_compiler"}, {"score": 0.002720661389788773, "phrase": "efficient_code_unloader"}, {"score": 0.002659527314613792, "phrase": "embedded_environment"}, {"score": 0.0025331002386232014, "phrase": "dex_bytecode"}, {"score": 0.00250041084632787, "phrase": "official_distribution_format"}, {"score": 0.0024842242921857705, "phrase": "android_applications"}, {"score": 0.0021886732310288128, "phrase": "best-performing_interpreter"}, {"score": 0.0021674482571326283, "phrase": "selected_benchmarks"}, {"score": 0.0021325287436338228, "phrase": "state-of-the-art_jit_compiler"}, {"score": 0.0021049977753042253, "phrase": "jitc-droid"}], "paper_keywords": ["Performance", " Language", " Design", " Register-based Bytecode", " Just-In-Time Compiler", " Embedded JVM", " Android"], "paper_abstract": "Code quality and compilation speed are two challenges to JIT compilers, while selective compilation is commonly used to trade-off these two issues. Meanwhile, with more and more Java applications running in mobile devices, selective compilation meets many problems. Since these applications always have flat execution profile and short live time, a lightweight JIT technique without losing code quality is extremely needed. However, the overhead of compiling stack-based Java bytecode to heterogeneous register-based machine code is significant in embedded devices. This paper presents a fast and effective JIT technique for mobile devices, building on a register-based Java bytecode format which is more similar to the underlying machine architecture. Through a comprehensive study on the characteristics of Java applications, we observe that virtual registers used by more than 90% Java methods can be directly fulfilled by 11 physical registers. Based on this observation, this paper proposes Swift, a novel JIT compiler on register-based bytecode, which generates native code for RISC machines. After mapping virtual registers to physical registers, the code is generated efficiently by looking up a translation table. And the code quality is guaranteed by the static compiler which is used to generate register-based bytecode. Besides, we design two lightweight optimizations and an efficient code unloader to make Swift more suitable for embedded environment. As the prevalence of Android, a prototype of Swift is implemented upon DEX bytecode which is the official distribution format of Android applications. Swift is evaluated with three benchmarks (SPECjvm98, EmbeddedCaffeineMark3 and JemBench2) on two different ARM SOCs: S3C6410 (armv6) and OMAP3530 (armv7). The results show that Swift achieves a speedup of 3.13 over the best-performing interpreter on the selected benchmarks. Compared with the state-of-the-art JIT compiler in Android, JITC-Droid, Swift achieves a speedup of 1.42.", "paper_title": "Swift: A Register-based JIT Compiler for Embedded JVMs", "paper_id": "WOS:000308657200007"}