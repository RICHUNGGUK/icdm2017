{"auto_keywords": [{"score": 0.03478167905660463, "phrase": "qvt-r"}, {"score": 0.015363471715370785, "phrase": "qvt_core"}, {"score": 0.009225058918082738, "phrase": "target_model"}, {"score": 0.008749079419553251, "phrase": "precise_understanding"}, {"score": 0.00481495049065317, "phrase": "qvt_relations"}, {"score": 0.004342430078306461, "phrase": "qvt-r_transformation"}, {"score": 0.004261617028111862, "phrase": "checkonly_mode"}, {"score": 0.004066076430818046, "phrase": "enforce_mode"}, {"score": 0.003940706575253453, "phrase": "checkonly_mode_transformations"}, {"score": 0.0038431888954930083, "phrase": "mode_transformations"}, {"score": 0.003643873052150612, "phrase": "checkonly_qvt-r_transformations"}, {"score": 0.0035648266669315943, "phrase": "overall_structure"}, {"score": 0.0033905067962602515, "phrase": "trace_classes"}, {"score": 0.0029722900280316216, "phrase": "irreconcilable_differences"}, {"score": 0.002944465517142163, "phrase": "intended_semantics"}, {"score": 0.0026467041118198977, "phrase": "qvt-r."}, {"score": 0.0025811251515543195, "phrase": "simple_game-theoretic_semantics"}, {"score": 0.002447101794397243, "phrase": "example_result"}, {"score": 0.0023939545398857518, "phrase": "consistent_models"}, {"score": 0.0023566987138026285, "phrase": "single_trace_model"}, {"score": 0.002305510336172047, "phrase": "traceability_links"}, {"score": 0.0021517438495635634, "phrase": "design_choices"}, {"score": 0.0021049977753042253, "phrase": "qvt-r_language"}], "paper_keywords": ["Bidirectional model transformation", " QVT Relations", " QVT Core", " Games", " Semantics", " Consistency checking"], "paper_abstract": "The QVT Relations (QVT-R) transformation language allows the definition of bidirectional model transformations, which are required in cases where two (or more) models must be kept consistent in the face of changes to either or both. A QVT-R transformation can be used either in checkonly mode, to determine whether a target model is consistent with a given source model, or in enforce mode, to change the target model. A precise understanding of checkonly mode transformations is prerequisite to a precise understanding of enforce mode transformations, and this is the focus of this paper. In order to give semantics to checkonly QVT-R transformations, we need to consider the overall structure of the transformation as given by when and where clauses, and the role of trace classes. In the standard, the semantics of QVT-R are given both directly, and by means of a translation to QVT Core, a language which is intended to be simpler. In this paper, we argue that there are irreconcilable differences between the intended semantics of QVT-R and those of QVT Core, so that no translation from QVT-R to QVT Core can be semantics-preserving, and hence no such translation can be helpful in defining the semantics of QVT-R. Treating QVT-R directly, we propose a simple game-theoretic semantics. We demonstrate its behaviour on examples and show how it can be used to prove an example result comparing two QVT-R transformations. We demonstrate that consistent models may not possess a single trace model whose objects can be read as traceability links in either direction. We briefly discuss the effect of variations in the rules of the game, to elucidate some design choices available to the designers of the QVT-R language.", "paper_title": "A simple game-theoretic approach to checkonly QVT Relations", "paper_id": "WOS:000314978800012"}