{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "deadlock_avoidance"}, {"score": 0.04825250923342016, "phrase": "multiple_instances"}, {"score": 0.004768378525561471, "phrase": "workflow-based_computations"}, {"score": 0.004722254884093624, "phrase": "workflow-based_workloads"}, {"score": 0.004263972370406983, "phrase": "well-defined_scientific_computation_task"}, {"score": 0.003964007795174772, "phrase": "high_degree"}, {"score": 0.003493021648360933, "phrase": "oversubscribed_storage_requests"}, {"score": 0.0034423989472667756, "phrase": "potential_problem"}, {"score": 0.0032471155306148156, "phrase": "traditional_problem"}, {"score": 0.003003809128328864, "phrase": "well-known_banker's_algorithm"}, {"score": 0.002903161412792026, "phrase": "important_distinction"}, {"score": 0.002875027551180213, "phrase": "active_and_inactive_resources"}, {"score": 0.0027651847105654363, "phrase": "previous_approaches"}, {"score": 0.002725081358527507, "phrase": "central_idea"}, {"score": 0.002659527314613792, "phrase": "data-flow_information"}, {"score": 0.002608218347502229, "phrase": "localized_maximum_claim"}, {"score": 0.0024963543716522087, "phrase": "remaining_jobs"}, {"score": 0.002389276641014013, "phrase": "intrainstance_concurrency"}, {"score": 0.0023091721866305426, "phrase": "simulation-based_studies"}, {"score": 0.002199363362666037, "phrase": "classic_banker's_algorithm"}, {"score": 0.0021049977753042253, "phrase": "active_storage_resource_utilization"}], "paper_keywords": ["Storage aware", " workflow scheduling", " deadlock", " data dependency", " data flow", " active storage resource", " storage constraints"], "paper_abstract": "Workflow-based workloads usually consist of multiple instances of the same workflow, which are jobs with control or data dependencies to carry out a well-defined scientific computation task, with each instance acting on its own input data. To maximize the performance, a high degree of concurrency is always achieved by running multiple instances simultaneously. However, since the amount of storage is limited on most systems, deadlock due to oversubscribed storage requests is a potential problem. To address this problem, we integrate two novel concepts with the traditional problem of deadlock avoidance by proposing two algorithms that can maximize active (not just allocated) resource utilization and minimize makespan. Our approach is based on the well-known banker's algorithm, but our algorithms make the important distinction between active and inactive resources, which is not a part of previous approaches. The central idea is to leverage the data-flow information to dynamically approximate localized maximum claim (i.e., the resource requirements of the remaining jobs of the instance) to improve either interinstance or intrainstance concurrency and still avoid deadlock. Through simulation-based studies, we show how our proposed algorithms are better than the classic banker's algorithm and the more recent Lang's algorithm in terms of makespan and active storage resource utilization.", "paper_title": "Maximizing Active Storage Resources with Deadlock Avoidance in Workflow-Based Computations", "paper_id": "WOS:000325171200008"}