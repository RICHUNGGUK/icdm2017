{"auto_keywords": [{"score": 0.041819278160957776, "phrase": "vliw_processors"}, {"score": 0.00481495049065317, "phrase": "tetris-xl"}, {"score": 0.004582528208024817, "phrase": "embedded_vliw_processors"}, {"score": 0.004404658750724105, "phrase": "application_space"}, {"score": 0.00419195822011581, "phrase": "embedded_platforms"}, {"score": 0.004069280130346136, "phrase": "power_consumption_constraints"}, {"score": 0.00395017798595193, "phrase": "limited_resources"}, {"score": 0.0037593414153801394, "phrase": "vliw_compiler"}, {"score": 0.0037039021744127783, "phrase": "instruction_level_parallelism"}, {"score": 0.0035954555250614197, "phrase": "register_constraints"}, {"score": 0.0035424245257172234, "phrase": "excessive_register_spills"}, {"score": 0.003472927015404464, "phrase": "reduced_overall_system_performance"}, {"score": 0.0032887360307856635, "phrase": "new_spill_reduction_technique"}, {"score": 0.0032402142645120958, "phrase": "vliw_runtime_performance"}, {"score": 0.0030988889679192965, "phrase": "instruction_scheduling"}, {"score": 0.003053159610975692, "phrase": "earlier_algorithms"}, {"score": 0.0029199689963238726, "phrase": "data_dependency"}, {"score": 0.0027787638791664663, "phrase": "unexpected_schedule_length_increases"}, {"score": 0.0027513507830537165, "phrase": "subsequent_instruction_scheduling"}, {"score": 0.002657511557782469, "phrase": "trimaran"}, {"score": 0.0026053296286950222, "phrase": "vliw"}, {"score": 0.0024916260764216752, "phrase": "embedded_systems_benchmarks"}, {"score": 0.002467038647952607, "phrase": "experimental_results"}, {"score": 0.0023476849595393872, "phrase": "vliw_performance"}, {"score": 0.002223039450439376, "phrase": "previous_spill_reduction_techniques"}, {"score": 0.002147180332779021, "phrase": "prior_approaches"}], "paper_keywords": ["Algorithms", " Performance", " Register pressure", " instruction level parallelism", " Very Long Instruction Word (VLIW) processor"], "paper_abstract": "As technology has advanced, the application space of Very Long Instruction Word (VLIW) processors has grown to include a variety of embedded platforms. Due to cost and power consumption constraints, many embedded VLIW processors contain limited resources, including registers. As a result, a VLIW compiler that maximizes instruction level parallelism (ILP) without considering register constraints may generate excessive register spills, leading to reduced overall system performance. To address this issue, this article presents a new spill reduction technique that improves VLIW runtime performance by reordering operations prior to register allocation and instruction scheduling. Unlike earlier algorithms, our approach explicitly considers both register reduction and data dependency in performing operation reordering. Data dependency control limits unexpected schedule length increases during subsequent instruction scheduling. Our technique has been evaluated using Trimaran, an academic VLIW compiler, and evaluated using a set of embedded systems benchmarks. Experimental results show that, on average, this technique improves VLIW performance by 10% for VLIW processors with 32 registers and 8 functional units compared with previous spill reduction techniques. Limited improvement is seen versus prior approaches for VLIW processors with 64 registers and 8 functional units.", "paper_title": "Tetris-XL: A Performance-Driven Spill Reduction Technique for Embedded VLIW Processors", "paper_id": "WOS:000271212500003"}