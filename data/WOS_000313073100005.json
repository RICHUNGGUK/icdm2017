{"auto_keywords": [{"score": 0.04673180922576999, "phrase": "healthiness_conditions"}, {"score": 0.00481495049065317, "phrase": "unifying_theories"}, {"score": 0.00463507149599759, "phrase": "new_techniques"}, {"score": 0.004582423717777699, "phrase": "systematic_manipulation"}, {"score": 0.004377719094086111, "phrase": "recursive_programs"}, {"score": 0.00434449804021954, "phrase": "necessary_restrictions"}, {"score": 0.004150377643719188, "phrase": "inheritance_relation"}, {"score": 0.0037446140218109895, "phrase": "closure_proof"}, {"score": 0.0037020429480068653, "phrase": "program_operators"}, {"score": 0.003456554957885269, "phrase": "recursive_program"}, {"score": 0.003404244237372396, "phrase": "different_recursive_functions"}, {"score": 0.0032519989404960073, "phrase": "abort_and_assignment_statements"}, {"score": 0.003190584226787897, "phrase": "different_predicates"}, {"score": 0.0031663432942179853, "phrase": "different_models"}, {"score": 0.003118410827789671, "phrase": "original_definition"}, {"score": 0.002922637921202474, "phrase": "fixpoint_theorem"}, {"score": 0.0028025415122856973, "phrase": "partially_correct_relational_model"}, {"score": 0.0027706507124407686, "phrase": "totally_correct_sequential_model"}, {"score": 0.0027495923042511047, "phrase": "utp."}, {"score": 0.0026771333996253783, "phrase": "assignment_statements"}, {"score": 0.0026265465397867093, "phrase": "new_healthiness_conditions"}, {"score": 0.002596653214530156, "phrase": "latter_model"}, {"score": 0.0024804367507031163, "phrase": "utp"}, {"score": 0.002360381056508368, "phrase": "first_argument"}, {"score": 0.0023335099338323974, "phrase": "sequential_composition"}, {"score": 0.0023069440108381364, "phrase": "command_tree"}, {"score": 0.0022719915771356354, "phrase": "terminating_computation"}, {"score": 0.002203663884543687, "phrase": "small_number"}, {"score": 0.0021049977753042253, "phrase": "totally_correct_model"}], "paper_keywords": ["Predicative semantics", " Unifying theories of programming", " Inheritance", " Healthiness conditions", " Fixpoint theory"], "paper_abstract": "This paper introduces a number of new techniques that support systematic manipulation of predicates, operators, healthiness conditions, laws and fixpoints of recursive programs. Necessary restrictions are imposed on the definition of each model so that the inheritance relation can be established by checking a few conditions on the healthiness conditions and the commands. In particular, we intend to identify the conditions that simplify the closure proof of the program operators and enable laws and fixpoints of a model to be inherited by its submodel without re-proof. A recursive program may correspond to different recursive functions in a model and its submodels, because the primitives such as abort and assignment statements are normally represented as different predicates in different models (although the original definition of each operator is unchanged). This paper studies meta-theory in this more general setting. A fixpoint theorem is discovered and applied to clarify the relationship between the partially correct relational model and the totally correct sequential model in UTP. It is shown that, although assignment statements are modified by the new healthiness conditions in the latter model, most laws (including many that are re-proved in UTP) and fixpoints can be inherited directly without re-proof, if the first argument of every sequential composition in each command tree corresponds to a terminating computation. This result also singles out a small number of laws and fixpoints that may no longer hold in the totally correct model.", "paper_title": "Semantic inheritance in unifying theories of programming", "paper_id": "WOS:000313073100005"}