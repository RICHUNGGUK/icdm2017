{"auto_keywords": [{"score": 0.03825875031822629, "phrase": "structuring_mechanism"}, {"score": 0.009973774389122168, "phrase": "constructive_negation"}, {"score": 0.0097948329559552, "phrase": "operational_semantics"}, {"score": 0.009549643621944322, "phrase": "static_visibility_rule"}, {"score": 0.00481495049065317, "phrase": "static_embedded_implications"}, {"score": 0.004780030485538593, "phrase": "normal_logic_programs"}, {"score": 0.004642852977065663, "phrase": "logic_programs"}, {"score": 0.004592427776766215, "phrase": "first_one"}, {"score": 0.004460609967916904, "phrase": "program_unit"}, {"score": 0.004316812490871324, "phrase": "composition_operators"}, {"score": 0.004269913167716059, "phrase": "second_approach"}, {"score": 0.004208169035079665, "phrase": "logic_programming"}, {"score": 0.004132237700479874, "phrase": "abstraction_and_scoping_rules"}, {"score": 0.003984444229875069, "phrase": "procedural_programming"}, {"score": 0.003828005972718727, "phrase": "miller"}, {"score": 0.00357192337454689, "phrase": "giordano"}, {"score": 0.0035459861927742654, "phrase": "martelli"}, {"score": 0.0035202521293134807, "phrase": "rossi"}, {"score": 0.00315561677959372, "phrase": "chosen_rule"}, {"score": 0.0030761074505030184, "phrase": "normal_constraint_logic_programs"}, {"score": 0.0029444248503861167, "phrase": "embedded_implications"}, {"score": 0.0028286597212365504, "phrase": "expressive_power"}, {"score": 0.002808104467715375, "phrase": "normal_programs"}, {"score": 0.0024004805502253427, "phrase": "alternative_semantics"}, {"score": 0.002306052064028865, "phrase": "flat_one"}, {"score": 0.002167355210897559, "phrase": "computed_answers"}, {"score": 0.0021049977753042253, "phrase": "transformation_semantics"}], "paper_keywords": [""], "paper_abstract": "There are mainly two approaches for structuring logic programs. The first one is based on defining some notion of program unit or module and on providing a number of composition operators. The second approach consists in enriching logic programming with a mechanism of abstraction and scoping rules that are frequently found, for instance, in procedural programming. More precisely, this approach has been advocated by Miller and others using implications embedded in the goals of the given program as a structuring mechanism. However, as Giordano, Martelli and Rossi pointed out, we can associate two different visibility rules (static and dynamic) to this kind of structuring mechanism where, obviously, the semantics of the given program depends on the chosen rule. In this paper we consider normal constraint logic programs (with constructive negation a la Drabent as operational semantics) extended with embedded implications with a static visibility rule. This class of programs combines the expressive power of normal programs with the capability to organize and to enhance dinamically their sets of clauses. In particular, first, we introduce an operational semantics based on constructive negation for this class of programs, taking into account the static visibility rule. Then, we present an alternative semantics in terms of a transformation of the given structured program into a flat one. Finally, we prove the adequacy of this transformation by showing that it preserves the computed answers of the given program. Obviously, this transformation semantics can be used as the basis for an implementation of this structuring mechanism.", "paper_title": "A transformational semantics of static embedded implications of normal logic programs", "paper_id": "WOS:000237004300009"}