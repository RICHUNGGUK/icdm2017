{"auto_keywords": [{"score": 0.029262716579216683, "phrase": "sci"}, {"score": 0.020276206314813805, "phrase": "reynolds"}, {"score": 0.00481495049065317, "phrase": "synthesis_iv_compiling_affine_recursion"}, {"score": 0.004762202897268383, "phrase": "static_hardware"}, {"score": 0.00471003041684707, "phrase": "abramsky's_geometry"}, {"score": 0.004658426838467567, "phrase": "interaction_interpretation"}, {"score": 0.004506968388996092, "phrase": "logical-directed_way"}, {"score": 0.004360412703519539, "phrase": "functional_views"}, {"score": 0.004149429072483132, "phrase": "dataflow-style_semantics"}, {"score": 0.00373682045166829, "phrase": "language_syntax"}, {"score": 0.0036553070575015344, "phrase": "key_idea"}, {"score": 0.003615217162972726, "phrase": "ghica's_geometry"}, {"score": 0.003309877074892399, "phrase": "syntactic_control_of"}, {"score": 0.003030247482854539, "phrase": "finitary_representation"}, {"score": 0.0029641011108505785, "phrase": "internal_state"}, {"score": 0.002883439044844259, "phrase": "physical_realisation"}, {"score": 0.002789528662623221, "phrase": "semantics-directed_compiler"}, {"score": 0.0025678829712650437, "phrase": "affine_recursive_programs"}, {"score": 0.002497976173193543, "phrase": "gos_method"}, {"score": 0.002363806685815014, "phrase": "recursive_computation"}, {"score": 0.002224510044064184, "phrase": "simple_benchmark-style_examples"}, {"score": 0.0021049977753042253, "phrase": "conventional_cpu-based_execution_models"}], "paper_keywords": ["Languages", " Theory", " Design"], "paper_abstract": "Abramsky's Geometry of Interaction interpretation (GoI) is a logical-directed way to reconcile the process and functional views of computation, and can lead to a dataflow-style semantics of programming languages that is both operational (i.e. effective) and denotational (i.e. inductive on the language syntax). The key idea of Ghica's Geometry of Synthesis (GoS) approach is that for certain programming languages (namely Reynolds's affine Syntactic Control of Interference-SCI) the GoI processes-like interpretation of the language can be given a finitary representation, for both internal state and tokens. A physical realisation of this representation becomes a semantics-directed compiler for SCI into hardware. In this paper we examine the issue of compiling affine recursive programs into hardware using the GoS method. We give syntax and compilation techniques for unfolding recursive computation in space or in time and we illustrate it with simple benchmark-style examples. We examine the performance of the benchmarks against conventional CPU-based execution models.", "paper_title": "Geometry of Synthesis IV Compiling Affine Recursion into Static Hardware", "paper_id": "WOS:000297632700022"}