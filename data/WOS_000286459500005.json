{"auto_keywords": [{"score": 0.040170396999330955, "phrase": "openmp"}, {"score": 0.00481495049065317, "phrase": "locality-aware_computations"}, {"score": 0.004772593750252861, "phrase": "openmp._locality"}, {"score": 0.004627244470096107, "phrase": "high_performance"}, {"score": 0.004566308708871429, "phrase": "broad_variety"}, {"score": 0.004526129302830441, "phrase": "parallel_architectures"}, {"score": 0.00436890075128947, "phrase": "essential_component"}, {"score": 0.004292337783332826, "phrase": "energy-efficient_computing"}, {"score": 0.004198510172614725, "phrase": "widely_available_industry_standard"}, {"score": 0.004161553532799662, "phrase": "shared_memory_programming"}, {"score": 0.0040886093072615, "phrase": "pervasive_deployment"}, {"score": 0.004052616113326177, "phrase": "multi-core_computers"}, {"score": 0.003999217176949845, "phrase": "steady_growth"}, {"score": 0.003964007795174772, "phrase": "core_count"}, {"score": 0.003709595902020469, "phrase": "important_role"}, {"score": 0.0036124465071873998, "phrase": "new_hardware"}, {"score": 0.00344087639309216, "phrase": "explicit_means"}, {"score": 0.0032485526269852606, "phrase": "\"flat\"_memory_model"}, {"score": 0.0030942116765996426, "phrase": "explicit_programmer_control"}, {"score": 0.0028195727965553367, "phrase": "potential_extensions"}, {"score": 0.002685558057339722, "phrase": "program's_data_layout"}, {"score": 0.0025241429061867633, "phrase": "data_accesses"}, {"score": 0.002447101794397243, "phrase": "intended_use"}, {"score": 0.0024148064819862337, "phrase": "proposed_features"}, {"score": 0.002341094670523097, "phrase": "experimental_results"}, {"score": 0.002161695357601592, "phrase": "major_player"}, {"score": 0.0021049977753042253, "phrase": "many-core_architectures"}], "paper_keywords": ["Locality of computation", " memory programming", " OpenMP", " programming models"], "paper_abstract": "Locality of computation is key to obtaining high performance on a broad variety of parallel architectures and applications. It is moreover an essential component of strategies for energy-efficient computing. OpenMP is a widely available industry standard for shared memory programming. With the pervasive deployment of multi-core computers and the steady growth in core count, a productive programming model such as OpenMP is increasingly expected to play an important role in adapting applications to this new hardware. However, OpenMP does not provide the programmer with explicit means to program for locality. Rather it presents the user with a \"flat\" memory model. In this paper, we discuss the need for explicit programmer control of locality within the context of OpenMP and present some ideas on how this might be accomplished. We describe potential extensions to OpenMP that would enable the user to manage a program's data layout and to align tasks and data in order to minimize the cost of data accesses. We give examples showing the intended use of the proposed features, describe our current implementation and present some experimental results. Our hope is that this work will lead to efforts that would help OpenMP to be a major player on emerging, multi- and many-core architectures.", "paper_title": "Enabling locality-aware computations in OpenMP", "paper_id": "WOS:000286459500005"}