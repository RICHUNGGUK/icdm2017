{"auto_keywords": [{"score": 0.040254524476117166, "phrase": "type_system"}, {"score": 0.012921861348321847, "phrase": "standard_ml."}, {"score": 0.010880874709642264, "phrase": "sql_queries"}, {"score": 0.00481495049065317, "phrase": "standard_ml"}, {"score": 0.004605258779434384, "phrase": "database_query_language"}, {"score": 0.004537401559396022, "phrase": "programming_language"}, {"score": 0.004089520289257753, "phrase": "sql"}, {"score": 0.0038919354605673104, "phrase": "integrated_language"}, {"score": 0.0037593414153801394, "phrase": "principal_type"}, {"score": 0.0037039021744127783, "phrase": "type_consistent_sql_expression"}, {"score": 0.0036312482387007815, "phrase": "sql_queries_first-class_citizens"}, {"score": 0.0031453010852936334, "phrase": "database_server"}, {"score": 0.0030531657435807673, "phrase": "mysql"}, {"score": 0.0030081030319492343, "phrase": "currently_implemented_version"}, {"score": 0.002862648127577722, "phrase": "machiavelli"}, {"score": 0.0027650234530228923, "phrase": "record_polymorphism"}, {"score": 0.002724207384182295, "phrase": "type_structure"}, {"score": 0.0026973372664496832, "phrase": "sql."}, {"score": 0.002618278365749875, "phrase": "practical_language"}, {"score": 0.0025289662786567896, "phrase": "technical_challenges"}, {"score": 0.002442693254693416, "phrase": "static_enforcement"}, {"score": 0.002418587525752333, "phrase": "server_connection_consistency"}, {"score": 0.0023947191132328233, "phrase": "proper_treatment"}, {"score": 0.0023710856920150574, "phrase": "overloaded_sql_primitives"}, {"score": 0.0023476849595393872, "phrase": "query_compilation"}, {"score": 0.0023130151703068444, "phrase": "runtime_connection_management"}, {"score": 0.0022452005651385095, "phrase": "necessary_extensions"}], "paper_keywords": ["Design", " Languages", " SQL", " Polymorphism", " Type System", " Interoperability", " SML#"], "paper_abstract": "Integrating a database query language into a programming language is becoming increasingly important in recently emerging high-level cloud computing and other applications, where efficient and sophisticated data manipulation is required during computation. This paper reports on seamless integration of SQL into SML# - an extension of Standard ML. In the integrated language, the type system always infers a principal type for any type consistent SQL expression. This makes SQL queries first-class citizens, which can be freely combined with any other language constructs definable in Standard ML. For a program involving SQL queries, the compiler separates SQL queries and delegates their evaluation to a database server, e. g. PostgreSQL or MySQL in the currently implemented version. The type system of our language is largely based on Machiavelli, which demonstrates that ML with record polymorphism can represent type structure of SQL. In order to develop a practical language, however, a number of technical challenges have to be overcome, including static enforcement of server connection consistency, proper treatment of overloaded SQL primitives, query compilation, and runtime connection management. This paper describes the necessary extensions to the type system and compilation, and reports on the details of its implementation.", "paper_title": "Making Standard ML a Practical Database Programming Language", "paper_id": "WOS:000297632700029"}