{"auto_keywords": [{"score": 0.04265314513641902, "phrase": "lp_decoding"}, {"score": 0.0364182571582389, "phrase": "koetter"}, {"score": 0.036156547548414006, "phrase": "vontobel"}, {"score": 0.00481495049065317, "phrase": "low-density_parity-check_codes"}, {"score": 0.004691136491297242, "phrase": "compressed_sensing"}, {"score": 0.004621813738791474, "phrase": "increased_attention"}, {"score": 0.004587535692463736, "phrase": "recent_years"}, {"score": 0.004387117409226736, "phrase": "iterative_decoding_algorithms"}, {"score": 0.004306205029641728, "phrase": "finite-blocklength_analysis"}, {"score": 0.0041642891310893, "phrase": "feldman_et_al"}, {"score": 0.004012061349250865, "phrase": "expander_graphs"}, {"score": 0.003724034990158436, "phrase": "empirically_observed_performance"}, {"score": 0.003561205990687285, "phrase": "random_noise"}, {"score": 0.0034954725617970294, "phrase": "daskalakis_et_al"}, {"score": 0.0032686865485199806, "phrase": "novel_understanding"}, {"score": 0.0031257046538823354, "phrase": "correctable_errors"}, {"score": 0.0029889584492584073, "phrase": "iterative_decoders"}, {"score": 0.002911961514073769, "phrase": "best_previously_noted_correctable_bit_error_rate"}, {"score": 0.002890535607018786, "phrase": "lp"}, {"score": 0.002815864555488112, "phrase": "explicit_connection"}, {"score": 0.0026330549554033876, "phrase": "primal_linear_program"}, {"score": 0.002603758927691463, "phrase": "interesting_byproduct"}, {"score": 0.0025272158996086378, "phrase": "\"locally_optimal\"_solution"}, {"score": 0.002389696110283506, "phrase": "nearest_codeword"}, {"score": 0.0023021895404322767, "phrase": "near-linear_time"}, {"score": 0.002276566401216226, "phrase": "\"reweighted\"_version"}, {"score": 0.002251227801482381, "phrase": "min-sum_algorithm"}, {"score": 0.0022013998682815323, "phrase": "lp."}, {"score": 0.002128694000627911, "phrase": "reweighted_version"}, {"score": 0.0021049977753042253, "phrase": "min-sum_decoder"}], "paper_keywords": ["Linear programming (LP) decoding", " low-density parity-check (LDPC) codes", " message-passing algorithms", " min-sum algorithm"], "paper_abstract": "Linear programming (LP) decoding for low-density parity-check codes (and related domains such as compressed sensing) has received increased attention over recent years because of its practical performance-coming close to that of iterative decoding algorithms-and its amenability to finite-blocklength analysis. Several works starting with the work of Feldman et al. showed how to analyze LP decoding using properties of expander graphs. This line of analysis works for only low error rates, about a couple of orders of magnitude lower than the empirically observed performance. It is possible to do better for the case of random noise, as shown by Daskalakis et al. and Koetter and Vontobel. Building on work of Koetter and Vontobel, we obtain a novel understanding of LP decoding, which allows us to establish a 0.05 fraction of correctable errors for rate-1/2 codes; this comes very close to the performance of iterative decoders and is significantly higher than the best previously noted correctable bit error rate for LP decoding. Our analysis exploits an explicit connection between LP decoding and message-passing algorithms and, unlike other techniques, directly works with the primal linear program. An interesting byproduct of our method is a notion of a \"locally optimal\" solution that we show to always be globally optimal (i.e., it is the nearest codeword). Such a solution can in fact be found in near-linear time by a \"reweighted\" version of the min-sum algorithm, obviating the need for LP. Our analysis implies, in particular, that this reweighted version of the min-sum decoder corrects up to a 0.05 fraction of errors.", "paper_title": "Message-Passing Algorithms and Improved LP Decoding", "paper_id": "WOS:000311359600019"}