{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "jtl"}, {"score": 0.007661363783985994, "phrase": "java"}, {"score": 0.004417848254181138, "phrase": "novel_language"}, {"score": 0.004209893377338457, "phrase": "source_code_software_tools"}, {"score": 0.004109600767747015, "phrase": "small_language"}, {"score": 0.004067349981835669, "phrase": "programming_language_extensions"}, {"score": 0.004039423410198574, "phrase": "java._applications"}, {"score": 0.003956784357357341, "phrase": "aspect-oriented_programming"}, {"score": 0.003916098498242888, "phrase": "type_constraints"}, {"score": 0.003889206369317587, "phrase": "generic_programming"}, {"score": 0.003835972725191194, "phrase": "encapsulation_policies"}, {"score": 0.003680587852807675, "phrase": "jtl_expression"}, {"score": 0.003459191419478298, "phrase": "simply-typed_relational_database"}, {"score": 0.0033651019362620866, "phrase": "abstract_syntax_tree"}, {"score": 0.0033304797419738182, "phrase": "underlying_semantics"}, {"score": 0.0032176163279340206, "phrase": "first_order_predicate_logic"}, {"score": 0.0031845067058084583, "phrase": "transitive_closure"}, {"score": 0.0031193028729331667, "phrase": "special_effort"}, {"score": 0.0030031998605136788, "phrase": "logical_conditions"}, {"score": 0.0029518598926717332, "phrase": "public_abstract_class"}, {"score": 0.002881450787481037, "phrase": "abstract_classes"}, {"score": 0.0026986685585382347, "phrase": "method_clone"}, {"score": 0.0025892330566358503, "phrase": "datalog-like_syntax"}, {"score": 0.002518746501941657, "phrase": "pattern_matching"}, {"score": 0.002441734529530325, "phrase": "recursive_calls"}, {"score": 0.002424942315592064, "phrase": "jtl's_query_analyzer"}, {"score": 0.0023507916951658455, "phrase": "\"closed_world_assumption"}, {"score": 0.002318566141177149, "phrase": "java_software"}, {"score": 0.0022015970225369975, "phrase": "jtl_interpreter"}], "paper_keywords": ["design", " languages", " declarative programming", " reverse engineering"], "paper_abstract": "We present an overview of JTL (the Java Tools Language, pronounced \"Gee-tel\"), a novel language for querying JAVA [ 8] programs. JTL was designed to serve the development of source code software tools for JAVA, and as a small language to aid programming language extensions to JAVA. Applications include definition of pointcuts for aspect-oriented programming, fixing type constraints for generic programming, specification of encapsulation policies, definition of micro-patterns, etc. We argue that the JTL expression of each of these is systematic, concise, intuitive and general. JTL relies on a simply-typed relational database for program representation, rather than an abstract syntax tree. The underlying semantics of the language is restricted to queries formulated in First Order Predicate Logic augmented with transitive closure (FOPL*). Special effort was taken to ensure terse, yet readable expression of logical conditions. The JTL pattern public abstract class, for example, matches all abstract classes which are publicly accessible, while class {public clone();} matches all classes in which method clone is public. To this end, JTL relies on a DATALOG-like syntax and semantics, enriched with quantifiers and pattern matching which all but entirely eliminate the need for recursive calls. JTL's query analyzer gives special attention to the fragility of the \"closed world assumption\" in examining JAVA software, and determines whether a query relies on such an assumption. The performance of the JTL interpreter is comparable to that of JQuery after it generated its database cache, and at least an order of magnitude faster when the cache has to be rebuilt.", "paper_title": "JTL - the Java tools language", "paper_id": "WOS:000202972500008"}