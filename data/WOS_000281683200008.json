{"auto_keywords": [{"score": 0.04565922187614429, "phrase": "wavelet_codes"}, {"score": 0.00481495049065317, "phrase": "wavelet_codes_for_algorithm-based_fault_tolerance_applications"}, {"score": 0.004662427600500598, "phrase": "real_number_parity_values"}, {"score": 0.004514714250357749, "phrase": "computer-induced_errors"}, {"score": 0.004466519142879166, "phrase": "numerical_processing_operations"}, {"score": 0.004278807087784626, "phrase": "necessary_redundancy"}, {"score": 0.004121015016128205, "phrase": "real_number_convolutional_codes"}, {"score": 0.0040334640350288, "phrase": "required_parity_values"}, {"score": 0.003969018740062018, "phrase": "continuous_fashion"}, {"score": 0.0038226070564362697, "phrase": "normal_data_processing"}, {"score": 0.0037213333316218522, "phrase": "transform_coefficients"}, {"score": 0.0036422425344358037, "phrase": "analysis_uniform_filter_bank"}, {"score": 0.003526735797659508, "phrase": "parity-checking_operations"}, {"score": 0.0034332736827447654, "phrase": "syndrome_synthesis_filter_bank"}, {"score": 0.0033243718810317254, "phrase": "data_processing_operations"}, {"score": 0.0032189132350239013, "phrase": "parity_generating_function"}, {"score": 0.0031335830806256777, "phrase": "parity_values"}, {"score": 0.003100085797251317, "phrase": "good_wavelet_codes"}, {"score": 0.0030017207229983385, "phrase": "standard_convolutional_codes"}, {"score": 0.002969628818856786, "phrase": "finite_fields"}, {"score": 0.0029064676523923886, "phrase": "field_elements"}, {"score": 0.0028142286985235977, "phrase": "real_number_space"}, {"score": 0.0027841357057119317, "phrase": "abft_techniques"}, {"score": 0.002681315076008658, "phrase": "systematic_form"}, {"score": 0.002610198789888055, "phrase": "systematic_codes"}, {"score": 0.0025137856138000014, "phrase": "abft_overhead_computations"}, {"score": 0.002447101794397243, "phrase": "protection_methods"}, {"score": 0.0023189818169615135, "phrase": "syndromes'_variances"}, {"score": 0.002233301265743633, "phrase": "syndrome_comparisons"}, {"score": 0.0021049977753042253, "phrase": "high-rate_wavelet_codes"}], "paper_keywords": ["Algorithm-based fault tolerance (ABFT)", " wavelet codes", " real number coding", " failure error detection", " systematic wavelet structures", " recursive processing"], "paper_abstract": "Algorithm-based fault tolerance (ABFT) methods, which use real number parity values computed in two separate comparable ways to detect computer-induced errors in numerical processing operations, can employ wavelet codes for establishing the necessary redundancy. Wavelet codes, one form of real number convolutional codes, determine the required parity values in a continuous fashion and can be intertwined naturally with normal data processing. Such codes are the transform coefficients associated with an analysis uniform filter bank which employs downsampling, while parity-checking operations are performed by a syndrome synthesis filter bank that includes upsampling. The data processing operations are merged effectively with the parity generating function to provide one set of parity values. Good wavelet codes can be designed starting from standard convolutional codes over finite fields by relating the field elements with the integers in the real number space. ABFT techniques are most efficient when employing a systematic form and methods for developing systematic codes are detailed. Bounds on the ABFT overhead computations are given and ABET protection methods for processing that contains feedback are outlined. Analyzing syndromes' variances guide the selection of thresholds for syndrome comparisons. Simulations demonstrate the detection and miss probabilities for some high-rate wavelet codes.", "paper_title": "Wavelet Codes for Algorithm-Based Fault Tolerance Applications", "paper_id": "WOS:000281683200008"}