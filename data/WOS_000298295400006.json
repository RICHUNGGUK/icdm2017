{"auto_keywords": [{"score": 0.032379727648413605, "phrase": "memory_manager"}, {"score": 0.00469545352928726, "phrase": "optimal_performance"}, {"score": 0.004666043394407466, "phrase": "garbage-collected_applications"}, {"score": 0.004354387464909719, "phrase": "garbage_collections"}, {"score": 0.004050708996795156, "phrase": "overall_throughput"}, {"score": 0.004012686357543403, "phrase": "today's_multicore"}, {"score": 0.003987535625069556, "phrase": "multiprocessor_machines"}, {"score": 0.003962541905291554, "phrase": "multiple_garbage-collected_applications"}, {"score": 0.003839894670436314, "phrase": "virtual_machine"}, {"score": 0.003571968614903263, "phrase": "peer_applications"}, {"score": 0.0034722729543863267, "phrase": "memory_management_system"}, {"score": 0.0033966530720227796, "phrase": "memory_demands"}, {"score": 0.003333143779627263, "phrase": "applications'_heaps"}, {"score": 0.0032503020402680385, "phrase": "negative_impacts"}, {"score": 0.003013890317967077, "phrase": "poor_richard's"}, {"score": 0.002957516535697149, "phrase": "overall_system_performance"}, {"score": 0.0028749210987951677, "phrase": "system-wide_decisions"}, {"score": 0.002733723435814484, "phrase": "existing_vms"}, {"score": 0.0026573612772397832, "phrase": "almost_no_impact"}, {"score": 0.002534789666280057, "phrase": "poor_richard's_memory_manager"}, {"score": 0.0025188786741217077, "phrase": "average_performance"}, {"score": 0.002335542599406245, "phrase": "garbage_collection_algorithm"}, {"score": 0.0022631392664577256, "phrase": "garbage_collector"}, {"score": 0.0021049977753042253, "phrase": "conservative_whole-heap_garbage_collector"}], "paper_keywords": ["Experimentation", " Measurement", " Performance", " poor richard's memory manager", " garbage collection", " multiprogramming", " throughput", " paging"], "paper_abstract": "To achieve optimal performance, garbage-collected applications must balance the sizes of their heaps dynamically. Sizing the heap too small can reduce throughput by increasing the number of garbage collections that must be performed. Too large a heap, however, can cause the system to page and drag down the overall throughput. In today's multicore, multiprocessor machines, multiple garbage-collected applications may run simultaneously. As a result, each virtual machine (VM) must adjust its memory demands to reflect not only the behavior of the application it is running, but also the behavior of the peer applications running on the system. We present a memory management system that enables VMs to react to memory demands dynamically. Our approach allows the applications' heaps to remain small enough to avoid the negative impacts of paging, while still taking advantage of any memory that is available within the system. This memory manager, which we call Poor Richard's Memory Manager, focuses on optimizing overall system performance by allowing applications to share data and make system-wide decisions. We describe the design of our memory management system, show how it can be added to existing VMs with little effort, and document that it has almost no impact on performance when memory is plentiful. Using both homogenous and heterogenous Java workloads, we then show that Poor Richard's memory manager improves average performance by up to a factor 5.5 when the system is paging. We further show that this result is not specific to any garbage collection algorithm, but that this improvement is observed for every garbage collector on which we test it. We finally demonstrate the versatility of our memory manager by using it to improve the performance of a conservative whole-heap garbage collector used in executing. Net applications.", "paper_title": "Waste Not, Want Not Resource-based Garbage Collection in a Shared Environment", "paper_id": "WOS:000298295400006"}