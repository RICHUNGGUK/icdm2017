{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "separation_logic"}, {"score": 0.0453665111651286, "phrase": "sequential_proof"}, {"score": 0.014900487383154404, "phrase": "sequential_program"}, {"score": 0.004428728205625129, "phrase": "potential_parallelization_opportunities"}, {"score": 0.004154332348800334, "phrase": "correctly_synchronized_parallelized_program"}, {"score": 0.003993958025223994, "phrase": "previous_work"}, {"score": 0.003877737556673229, "phrase": "simple_independence_analysis"}, {"score": 0.003378385493203297, "phrase": "naive_translation"}, {"score": 0.0032639039638211347, "phrase": "fine-grained_patterns"}, {"score": 0.0031532895341013297, "phrase": "straightforward_points"}, {"score": 0.0030017207229983385, "phrase": "shape_properties"}, {"score": 0.002914288956035066, "phrase": "complex_algorithms"}, {"score": 0.00266693888510356, "phrase": "different_parts"}, {"score": 0.0025638362414466278, "phrase": "discovered_dependencies"}, {"score": 0.0024891269874339553, "phrase": "synchronization_primitives"}, {"score": 0.0024525907271610104, "phrase": "parallelized_program"}, {"score": 0.0023694065215394593, "phrase": "resulting_parallelized_program"}, {"score": 0.0023003498123420237, "phrase": "original_sequential_program"}, {"score": 0.0021049977753042253, "phrase": "separation_logic_tools"}], "paper_keywords": ["Languages", " Theory", " Verification", " Separation logic", " abduction", " frame inference", " deterministic parallelism"], "paper_abstract": "We present an analysis which takes as its input a sequential program, augmented with annotations indicating potential parallelization opportunities, and a sequential proof, written in separation logic, and produces a correctly synchronized parallelized program and proof of that program. Unlike previous work, ours is not a simple independence analysis that admits parallelization only when threads do not interfere; rather, we insert synchronization to preserve dependencies in the sequential program that might be violated by a naive translation. Separation logic allows us to parallelize fine-grained patterns of resource usage, moving beyond straightforward points-to analysis. The sequential proof need only represent shape properties, meaning we can handle complex algorithms without verifying every aspect of their behavior. Our analysis works by using the sequential proof to discover dependencies between different parts of the program. It leverages these discovered dependencies to guide the insertion of synchronization primitives into the parallelized program, and to ensure that the resulting parallelized program satisfies the same specification as the original sequential program, and exhibits the same sequential behavior. Our analysis is built using frame inference and abduction, two techniques supported by an increasing number of separation logic tools.", "paper_title": "Proof-Directed Parallelization Synthesis by Separation Logic", "paper_id": "WOS:000322449200003"}