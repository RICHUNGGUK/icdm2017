{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "control_dependencies"}, {"score": 0.004716520738331953, "phrase": "space-aware_bytecode_verification"}, {"score": 0.0043875257506180865, "phrase": "virtual_machine"}, {"score": 0.004253618550301311, "phrase": "code_integrity"}, {"score": 0.0037965243835456214, "phrase": "java_card_technology"}, {"score": 0.0037188360359702182, "phrase": "java_applets"}, {"score": 0.0035681790580031998, "phrase": "smart_cards"}, {"score": 0.003459191419478298, "phrase": "large_memory_requirements"}, {"score": 0.003353521531649663, "phrase": "verification_process"}, {"score": 0.0030872017736888113, "phrase": "embedded_bytecode_verifier"}, {"score": 0.0027267406923803367, "phrase": "verification_algorithm"}, {"score": 0.0025625729433234623, "phrase": "system_memory"}, {"score": 0.0021490449563443025, "phrase": "control_flow_dependencies"}, {"score": 0.0021049977753042253, "phrase": "immediate_postdominators"}], "paper_keywords": ["Java Card", " bytecode verification", " data flow analysis"], "paper_abstract": "Java applets run on a Virtual Machine that checks code integrity and correctness before execution using a module called the Bytecode Verifier. Java Card technology allows Java applets to run on smart cards. The large memory requirements of the verification process do not allow the implementation of an embedded Bytecode Verifier in the Java Card Virtual Machine. To address this problem, we propose a verification algorithm that optimizes the use of system memory by imposing an ordering on the verification of the instructions. This algorithm is based on control flow dependencies and immediate postdominators in control flow graphs.", "paper_title": "Using control dependencies for space-aware bytecode verification", "paper_id": "WOS:000235771500009"}