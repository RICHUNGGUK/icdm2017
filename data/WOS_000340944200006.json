{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "bloom_filters"}, {"score": 0.004652016085325825, "phrase": "networking_device_algorithms"}, {"score": 0.004475266375001531, "phrase": "membership_queries"}, {"score": 0.0044369056710423065, "phrase": "limited_error"}, {"score": 0.004398872331144531, "phrase": "support_element"}, {"score": 0.004231699728933577, "phrase": "significant_amounts"}, {"score": 0.004035946043145475, "phrase": "new_general_method"}, {"score": 0.003984141889010296, "phrase": "variable_increments"}, {"score": 0.003799798511908168, "phrase": "cbfs"}, {"score": 0.0037348894128879082, "phrase": "element_insertion"}, {"score": 0.003686935223424015, "phrase": "hashed_counters"}, {"score": 0.003608370966473902, "phrase": "hashed_variable_increment"}, {"score": 0.003546722347907148, "phrase": "unit_increment"}, {"score": 0.0033971539563683174, "phrase": "exact_value"}, {"score": 0.0029980260560551982, "phrase": "lower_false_positive_rate"}, {"score": 0.00295950473406239, "phrase": "lower_overflow_probability"}, {"score": 0.0028963961037320805, "phrase": "practical_systems"}, {"score": 0.0027150087516999047, "phrase": "limited_added_complexity"}, {"score": 0.0026916956768363158, "phrase": "memory_overhead"}, {"score": 0.0025559595584080464, "phrase": "cbf"}, {"score": 0.002427035025924384, "phrase": "possible_improvements"}, {"score": 0.0023958326775913165, "phrase": "presented_schemes"}, {"score": 0.0023650305205893353, "phrase": "lower_bounds"}, {"score": 0.0022749744354271816, "phrase": "real-life_traces"}, {"score": 0.002150900082318562, "phrase": "false_positive_rate"}], "paper_keywords": ["Counting Bloom Filter", " false positive rate", " variable increments"], "paper_abstract": "Counting Bloom Filters (CBFs) are widely used in networking device algorithms. They implement fast set representations to support membership queries with limited error and support element deletions unlike Bloom Filters. However, they consume significant amounts of memory. In this paper, we introduce a new general method based on variable increments to improve the efficiency of CBFs and their variants. Unlike CBFs, at each element insertion, the hashed counters are incremented by a hashed variable increment instead of a unit increment. Then, to query an element, the exact value of a counter is considered and not just its positiveness. We present two simple schemes based on this method. We demonstrate that this method can always achieve a lower false positive rate and a lower overflow probability bound than CBF in practical systems. We also show how it can be easily implemented in hardware, with limited added complexity and memory overhead. We further explain how this method can extend many variants of CBF that have been published in the literature. We then suggest possible improvements of the presented schemes and provide lower bounds on their memory consumption. Lastly, using simulations with real-life traces and hash functions, we show how it can significantly improve the false positive rate of CBFs given the same amount of memory.", "paper_title": "The Variable-Increment Counting Bloom Filter", "paper_id": "WOS:000340944200006"}