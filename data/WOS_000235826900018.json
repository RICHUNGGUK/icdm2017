{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "compressed_suffix_arrays"}, {"score": 0.03347071801557563, "phrase": "data_structure"}, {"score": 0.00443308765153716, "phrase": "length_m"}, {"score": 0.0037188360359702182, "phrase": "well-studied_case"}, {"score": 0.003531474887552889, "phrase": "indexing_data_structure"}, {"score": 0.003459191419478298, "phrase": "pattern_query"}, {"score": 0.002726740692380339, "phrase": "best_previous_result"}, {"score": 0.0023225701080913388, "phrase": "indexing_space"}, {"score": 0.0022168460543913787, "phrase": "query_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "Let T be a text of length n and P be a pattern of length m, both strings over a fixed finite alphabet A. The k-difference (k-mismatch, respectively) problem is to find all occurrences of P in T that have edit distance (Hamming distance, respectively) at most k from P. In this paper we investigate a well-studied case in which T is fixed and preprocessed into an indexing data structure so that any pattern query can be answered faster. We give a solution using an O(n log n) bits indexing data structure with O(vertical bar A vertical bar(k) m(k) (.) max(k, log n)+occ) query time, where occ is the number of occurrences. The best previous result requires O(n log n) bits indexing data structure and gives O(vertical bar A vertical bar(k) m(k+2) + occ) query time. Our solution also allows us to exploit compressed suffix arrays to reduce the indexing space to O(n) bits, while increasing the query time by an O(log n) factor only. (c) 2005 Elsevier B.V. All rights reserved.", "paper_title": "Approximate string matching using compressed suffix arrays", "paper_id": "WOS:000235826900018"}