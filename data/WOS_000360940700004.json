{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "first-order_runtime_verification"}, {"score": 0.0045843245695654875, "phrase": "first-order_temporal_logic"}, {"score": 0.004382591802405206, "phrase": "new_type"}, {"score": 0.004021689117050817, "phrase": "undecidable_decision_problem"}, {"score": 0.003876226041373242, "phrase": "specific_ideas"}, {"score": 0.0034990853199511982, "phrase": "standard_ltl"}, {"score": 0.003372460634140967, "phrase": "first-order_logic"}, {"score": 0.003158522476399068, "phrase": "complete_monitor"}, {"score": 0.0028627183712016894, "phrase": "automata-based_construction"}, {"score": 0.002827740707723551, "phrase": "efficient_runtime_monitors"}, {"score": 0.0027365364488693656, "phrase": "trace_lengths"}, {"score": 0.002659142621852998, "phrase": "similar_approaches"}, {"score": 0.0024700078414481297, "phrase": "chosen_monitoring_approach"}, {"score": 0.0024001337476063094, "phrase": "general_categorisation"}, {"score": 0.0021049977753042253, "phrase": "well-known_safety-progress_hierarchy"}], "paper_keywords": ["Monitoring", " Spawning automata", " Temporal logic", " First-order logic", " Monitorability", " Trace-length independence"], "paper_abstract": "The main purpose of this paper is to introduce a first-order temporal logic, , and a corresponding monitor construction based on a new type of automaton, called spawning automaton. Specifically, we show that monitoring a specification in boils down to an undecidable decision problem. The proof of this result revolves around specific ideas on what we consider a \"proper\" monitor. As these ideas are general, we outline them first in the setting of standard LTL, before lifting them to the setting of first-order logic and . Although due to the above result one cannot hope to obtain a complete monitor for , we prove the soundness of our automata-based construction and give experimental results from an implementation. These seem to substantiate our hypothesis that the automata-based construction leads to efficient runtime monitors whose size does not grow with increasing trace lengths (as is often observed in similar approaches). However, we also discuss formulae for which growth is unavoidable, irrespective of the chosen monitoring approach. Specifically, we provide a general categorisation of so called monitorable languages, which is closely related to this notion of \"growth-inducing\" (that is, trace-length dependent) formulae. It relates to the well-known safety-progress hierarchy, yet is orthogonal to it.", "paper_title": "The ins and outs of first-order runtime verification", "paper_id": "WOS:000360940700004"}