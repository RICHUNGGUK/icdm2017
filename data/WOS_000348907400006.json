{"auto_keywords": [{"score": 0.02809562715313692, "phrase": "jvm."}, {"score": 0.00481495049065317, "phrase": "commodity_jvms"}, {"score": 0.004777214679969785, "phrase": "dynamic_taint_analysis"}, {"score": 0.004721162131188487, "phrase": "well-known_information_flow_analysis_problem"}, {"score": 0.004611013257082199, "phrase": "taint_tracking"}, {"score": 0.004521179256835894, "phrase": "application_data_flow"}, {"score": 0.004295681900150244, "phrase": "data_flow"}, {"score": 0.004261998281333649, "phrase": "taint_tracking_systems"}, {"score": 0.003817137134650275, "phrase": "production_environments"}, {"score": 0.003728000957725218, "phrase": "low_overhead"}, {"score": 0.003640938643675543, "phrase": "security-conscious_settings"}, {"score": 0.00348655247465418, "phrase": "dynamic_taint_tracking"}, {"score": 0.003312486229143855, "phrase": "real_world_purposes"}, {"score": 0.0032223742018434856, "phrase": "operating_system"}, {"score": 0.0031970796597571367, "phrase": "language_interpreter"}, {"score": 0.0031100973266506163, "phrase": "application_source_code"}, {"score": 0.003061463834024574, "phrase": "phosphor"}, {"score": 0.00294315185512045, "phrase": "jvm"}, {"score": 0.0026774738852854427, "phrase": "first_portable_general_purpose_taint_tracking_system"}, {"score": 0.0026148807877309417, "phrase": "phosphor's_performance"}, {"score": 0.002574107146915469, "phrase": "java"}, {"score": 0.0025537612895760275, "phrase": "scala"}, {"score": 0.0023787690061742566, "phrase": "android's_dalvik_virtual_machine"}, {"score": 0.0021724831184390192, "phrase": "dacapo_macro_benchmark_suite"}, {"score": 0.0021049977753042253, "phrase": "portable_taint_tracking"}], "paper_keywords": ["Taint Tracking", " Dataflow Analysis"], "paper_abstract": "Dynamic taint analysis is a well-known information flow analysis problem with many possible applications. Taint tracking allows for analysis of application data flow by assigning labels to data, and then propagating those labels through data flow. Taint tracking systems traditionally compromise among performance, precision, soundness, and portability. Performance can be critical, as these systems are often intended to be deployed to production environments, and hence must have low overhead. To be deployed in security-conscious settings, taint tracking must also be sound and precise. Dynamic taint tracking must be portable in order to be easily deployed and adopted for real world purposes, without requiring recompilation of the operating system or language interpreter, and without requiring access to application source code. We present PHOSPHOR, a dynamic taint tracking system for the Java Virtual Machine (JVM) that simultaneously achieves our goals of performance, soundness, precision, and portability. Moreover, to our knowledge, it is the first portable general purpose taint tracking system for the JVM. We evaluated PHOSPHOR's performance on two commonly used JVM languages (Java and Scala), on two successive revisions of two commonly used JVMs (Oracle's HotSpot and OpenJDK's IcedTea) and on Android's Dalvik Virtual Machine, finding its performance to be impressive: as low as 3% (53% on average; 220% at worst) using the DaCapo macro benchmark suite. This paper describes our approach toward achieving portable taint tracking in the JVM.", "paper_title": "Phosphor: Illuminating Dynamic Data Flow in Commodity JVMs", "paper_id": "WOS:000348907400006"}