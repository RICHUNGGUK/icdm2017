{"auto_keywords": [{"score": 0.043510309299986456, "phrase": "dsp"}, {"score": 0.00481495049065317, "phrase": "equivalence_verification"}, {"score": 0.0047747348769918, "phrase": "polynomial_datapaths"}, {"score": 0.004734853555630616, "phrase": "finite_ring_algebra"}, {"score": 0.004636594774238505, "phrase": "simulation-based_verification"}, {"score": 0.004335603324413586, "phrase": "finite_word-length_operands"}, {"score": 0.004192484908247302, "phrase": "digital_signal_processing"}, {"score": 0.004071121244999291, "phrase": "multimedia_applications"}, {"score": 0.003743310268453678, "phrase": "desired_precision"}, {"score": 0.003712011863784581, "phrase": "initial_descriptions"}, {"score": 0.003456287408801543, "phrase": "subsequent_hardware_synthesis"}, {"score": 0.0033141428467975795, "phrase": "bit-true_equivalent"}, {"score": 0.0032726467814278345, "phrase": "translated_rtl"}, {"score": 0.0031117775337824853, "phrase": "important_results"}, {"score": 0.0030599258491447946, "phrase": "exhaustive_simulation"}, {"score": 0.002860992017190221, "phrase": "datapath_computations"}, {"score": 0.0028370498057725796, "phrase": "polynomial_functions"}, {"score": 0.002813307389456184, "phrase": "finite_integer_rings"}, {"score": 0.00267495669519805, "phrase": "bit-vector_word-length"}, {"score": 0.00246964807581858, "phrase": "upper_bound"}, {"score": 0.0024182831453515782, "phrase": "simulation_vectors"}, {"score": 0.002204646157481869, "phrase": "exactly_those_vectors"}], "paper_keywords": ["bit-vector arithmetic", " equivalence checking", " finite integer rings", " polynomial functions", " simulation-based verification"], "paper_abstract": "This paper addresses simulation-based verification of high-level [algorithmic, behavioral, or register-transfer level (RTL)] descriptions of arithmetic datapaths that perform polynomial computations over finite word-length operands. Such designs are typically found in digital signal processing (DSP) for audio/video and multimedia applications; where the word-lengths of input and output Signals (bit-vectors) are predetermined and fixed according to the desired precision. Initial descriptions of such systems are usually specified as MATLAB/C code. These are then automatically translated into behavioral/RTL descriptions for subsequent hardware synthesis. In order to verify that the initial MATLAB/C model is bit-true equivalent to the translated RTL, how many simulation vectors need to be applied? This paper derives some important results that show that exhaustive simulation is not necessary to prove/disprove their equivalence. To derive these results, we model the datapath computations as polynomial functions over finite integer rings of the form Z(2)(rn), where m corresponds to the bit-vector word-length. Subsequently, by exploring some number theoretic and algebraic properties of these rings, we derive an upper bound on the number of simulation vectors required to prove equivalence or to identify bugs. Moreover, these vectors cannot be arbitrarily generated. We identify exactly those vectors that need to be simulated. Experiments are performed within practical computer-aided design (CAD) settings to demonstrate the validity and applicability of these results.", "paper_title": "Simulation bounds for equivalence verification of polynomial datapaths using finite ring algebra", "paper_id": "WOS:000254782900005"}