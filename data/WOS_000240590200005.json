{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "regular_tree_model_checking"}, {"score": 0.0047563776685277314, "phrase": "complex_dynamic_data_structures"}, {"score": 0.004556901872357751, "phrase": "non-recursive_c_programs"}, {"score": 0.004501453956464956, "phrase": "dynamic_linked_data_structures"}, {"score": 0.004446677711302801, "phrase": "possibly_several_next_pointer_selectors"}, {"score": 0.00436575511349828, "phrase": "finite_domain_non-pointer_data"}, {"score": 0.004208282550386197, "phrase": "basic_memory_consistency_properties"}, {"score": 0.0037459885494311217, "phrase": "existential_fragment"}, {"score": 0.0036777702949712457, "phrase": "first_order_logic"}, {"score": 0.003375429082739004, "phrase": "bad_memory_patterns"}, {"score": 0.002949598537993663, "phrase": "verification_problem"}, {"score": 0.002825681384008326, "phrase": "error_control_line"}, {"score": 0.002641360377825228, "phrase": "shape_graphs"}, {"score": 0.00257735013358606, "phrase": "original_way"}, {"score": 0.002453934333239467, "phrase": "program_statements"}, {"score": 0.002424012799998538, "phrase": "tree_transducers"}, {"score": 0.0023221248824337576, "phrase": "abstract_regular_tree_model_checking_framework"}], "paper_keywords": [""], "paper_abstract": "We consider the verification of non-recursive C programs manipulating dynamic linked data structures with possibly several next pointer selectors and with finite domain non-pointer data. We aim at checking basic memory consistency properties (no null pointer assignments, etc.) and shape invariants whose violation can be expressed in an existential fragment of a first order logic over graphs. We formalise this fragment as,a logic for specifying bad memory patterns whose formulae may be translated to testers written in C that can be attached to the program, thus reducing the verification problem considered to checking reachability of an error control line. We encode configurations of programs, which are essentially shape graphs, in an original way as extended tree automata and we represent program statements by tree transducers. Then, we use the abstract regular tree model checking framework for a fully automated verification. The method has been implemented and successfully applied on several case studies.", "paper_title": "Abstract regular tree model checking of complex dynamic data structures", "paper_id": "WOS:000240590200005"}