{"auto_keywords": [{"score": 0.03769021112631509, "phrase": "objects_lifetimes"}, {"score": 0.013052192686016489, "phrase": "upper_bounds"}, {"score": 0.00481495049065317, "phrase": "parametric_inference_of_memory_requirements_for_garbage_collected_languages"}, {"score": 0.004747620102130588, "phrase": "accurate_prediction"}, {"score": 0.00470325458481566, "phrase": "program's_memory_requirements"}, {"score": 0.004637478829869904, "phrase": "critical_component"}, {"score": 0.004594137808658537, "phrase": "software_development"}, {"score": 0.004551199992546761, "phrase": "existing_heap_space_analyses"}, {"score": 0.004342430078306461, "phrase": "specific_models"}, {"score": 0.004301834610818624, "phrase": "garbage_collectors"}, {"score": 0.004143196873246147, "phrase": "actual_memory_usage"}, {"score": 0.004047020753789236, "phrase": "novel_approach"}, {"score": 0.003953068310598579, "phrase": "memory_requirements"}, {"score": 0.003916098498242888, "phrase": "java-like_programs"}, {"score": 0.003771631577951067, "phrase": "object_lifetime"}, {"score": 0.0034984340449789745, "phrase": "reachability_analysis"}, {"score": 0.003369322866499541, "phrase": "memory_consumption"}, {"score": 0.003322140088192527, "phrase": "reachability-based_garbage_collector"}, {"score": 0.0031695693589575916, "phrase": "heap_liveness_analysis"}, {"score": 0.003081400693055518, "phrase": "program_minimal_memory_requirement"}, {"score": 0.0029260602766930065, "phrase": "optimal_garbage_collector"}, {"score": 0.002765490759189057, "phrase": "key_idea"}, {"score": 0.0026014425686078993, "phrase": "recurrence_equations"}, {"score": 0.002552946390854313, "phrase": "memory_usage"}, {"score": 0.0025171669791790438, "phrase": "different_program_states"}, {"score": 0.002470237978694949, "phrase": "heap_size_limit"}, {"score": 0.0024128022009415476, "phrase": "memory_requirement"}, {"score": 0.0022589720760078274, "phrase": "memory_limit"}, {"score": 0.0022064376000055764, "phrase": "garbage_collection"}, {"score": 0.0021049977753042253, "phrase": "java_bytecode_programs"}], "paper_keywords": ["Languages", " Theory", " Verification", " Reliability", " Live Heap Space Analysis", " Peak Memory Consumption", " Low-level Languages", " Java Bytecode", " Garbage Collection"], "paper_abstract": "The accurate prediction of program's memory requirements is a critical component in software development. Existing heap space analyses either do not take deallocation into account or adopt specific models of garbage collectors which do not necessarily correspond to the actual memory usage. We present a novel approach to inferring upper bounds on memory requirements of Java-like programs which is parametric on the notion of object lifetime, i.e., on when objects become collectible. If objects lifetimes are inferred by a reachability analysis, then our analysis infers accurate upper bounds on the memory consumption for a reachability-based garbage collector. Interestingly, if objects lifetimes are inferred by a heap liveness analysis, then we approximate the program minimal memory requirement, i.e., the peak memory usage when using an optimal garbage collector which frees objects as soon as they become dead. The key idea is to integrate information on objects lifetimes into the process of generating the recurrence equations which capture the memory usage at the different program states. If the heap size limit is set to the memory requirement inferred by our analysis, it is ensured that execution will not exceed the memory limit with the only assumption that garbage collection works when the limit is reached. Experiments on Java bytecode programs provide evidence of the feasibility and accuracy of our analysis.", "paper_title": "Parametric Inference of Memory Requirements for Garbage Collected Languages", "paper_id": "WOS:000280548600014"}