{"auto_keywords": [{"score": 0.04622747758713692, "phrase": "software_engineering_process"}, {"score": 0.023410409160679543, "phrase": "overall_plan"}, {"score": 0.00481495049065317, "phrase": "iterative_porting"}, {"score": 0.004690694501758065, "phrase": "general_framework"}, {"score": 0.004641890423057823, "phrase": "software_maintenance_activities"}, {"score": 0.004382364826200616, "phrase": "tool-based_planning_support"}, {"score": 0.004137288854115515, "phrase": "individual_iterations"}, {"score": 0.004051595625804513, "phrase": "distinct_porting_issues"}, {"score": 0.003610929883213109, "phrase": "path-planning_problem"}, {"score": 0.003554661425339528, "phrase": "abstract_cartesian_space"}, {"score": 0.0035176353680157367, "phrase": "program_versions"}, {"score": 0.0034628156490003775, "phrase": "dialect_variables"}, {"score": 0.0034088473318056537, "phrase": "optimal_solution"}, {"score": 0.0032180376288035296, "phrase": "restricted_integer_linear_program"}, {"score": 0.0031678720736808574, "phrase": "problem_constraints"}, {"score": 0.003085989256759819, "phrase": "simultaneous_linear_equations"}, {"score": 0.0030062165552187086, "phrase": "individual_dialect_vertices"}, {"score": 0.002750056254309311, "phrase": "looping_behaviour"}, {"score": 0.0024634797027967203, "phrase": "program_testability"}, {"score": 0.0024377918036784336, "phrase": "different_parts"}, {"score": 0.0023997601127552256, "phrase": "cartesian_space"}, {"score": 0.0023499703712897293, "phrase": "planned_migration"}, {"score": 0.0022299587520401747, "phrase": "iteration_planning"}, {"score": 0.002172266188075892, "phrase": "related_post-processor_support"}, {"score": 0.0021049977753042253, "phrase": "local_decisions"}], "paper_keywords": ["reliable software engineering process", " iterative software maintenance", " software porting", " planning", " testability", " analyze", " fix", " test", " debug", " quality assurance"], "paper_abstract": "We present a general framework for software maintenance activities such as porting. The framework comprises a software engineering process with tool-based planning support. The process is designed to be iterative, with individual iterations identifying and fixing distinct porting issues and building and testing of software taking place regularly through the iterations. Overall planning of the iterations is formalized as path-planning problem in an abstract Cartesian space of program versions characterized by dialect variables. An optimal solution to the problem is derived based on its translation to a restricted Integer Linear Program capturing the problem constraints as a set of simultaneous linear equations. The solution allows individual dialect vertices to be visited more than once, but not the same edge, thereby ruling out looping behaviour. Problems without solution are identified as infeasible. Reliability of the software engineering process is enhanced by the ability to characterize program testability in different parts of the Cartesian space and to guide planned migration through more testable spaces while identifying the corresponding (effort) tradeoffs. Iteration planning uses the overall plan and related post-processor support to allow user latitude in local decisions and in fine-tuning the overall plan.", "paper_title": "Process and planning support for iterative porting", "paper_id": "WOS:000236423900008"}