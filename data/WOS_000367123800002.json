{"auto_keywords": [{"score": 0.048112949023426686, "phrase": "programming_languages"}, {"score": 0.00481495049065317, "phrase": "rascal_-_experience_report"}, {"score": 0.004562362497952548, "phrase": "programming_language_tools"}, {"score": 0.004322967486451877, "phrase": "ordinary_software_construction"}, {"score": 0.004271490815763164, "phrase": "modular_implementations"}, {"score": 0.004047296286849109, "phrase": "language_implementation"}, {"score": 0.0038810583785936505, "phrase": "syntactic_and_semantic_dependencies"}, {"score": 0.0034016119212097826, "phrase": "modular_fashion"}, {"score": 0.0033409791799749434, "phrase": "rascal_meta-programming_language"}, {"score": 0.0032618078775887077, "phrase": "extensible_definition"}, {"score": 0.0032229262928681304, "phrase": "concrete_syntax"}, {"score": 0.0031845067058084583, "phrase": "abstract_syntax"}, {"score": 0.003109031770476385, "phrase": "concrete_and_abstract_syntax_trees"}, {"score": 0.002893140560765452, "phrase": "new_language_features"}, {"score": 0.0027575842698911173, "phrase": "existing_code"}, {"score": 0.002692200353719145, "phrase": "case_study"}, {"score": 0.0021821915946356168, "phrase": "domain-specific_languages"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["Language engineering", " Language workbench", " Meta-programming", " Modularity", " Compiler generators"], "paper_abstract": "All software evolves, and programming languages and programming language tools are no exception. And just like in ordinary software construction, modular implementations can help ease the process of changing a language implementation and its dependent tools. However, the syntactic and semantic dependencies between language features make this a challenging problem. In this paper we detail how programming languages can be implemented in a modular fashion using the RASCAL meta-programming language. RASCAL supports extensible definition of concrete syntax, abstract syntax and operations on concrete and abstract syntax trees like matching, traversal and transformation. As a result, new language features can be added without having to change existing code. As a case study, we detail our solution of the LDTA'11 Tool Challenge: a modular implementation of OBERON-0, a relatively simple imperative programming language. The approach we sketch can be applied equally well to the implementation of domain-specific languages. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Modular language implementation in Rascal - experience report", "paper_id": "WOS:000367123800002"}