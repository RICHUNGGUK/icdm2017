{"auto_keywords": [{"score": 0.004321118442104989, "phrase": "efficient_algorithm"}, {"score": 0.004154332348800334, "phrase": "faithful_rounding"}, {"score": 0.003916098498242888, "phrase": "floating-point_vector"}, {"score": 0.0034118234596993836, "phrase": "underlying_floating-point_type"}, {"score": 0.0028857130140890787, "phrase": "final_result"}, {"score": 0.002464709648714996, "phrase": "parallel_implementation"}, {"score": 0.002146926767291475, "phrase": "netlib_version"}, {"score": 0.0021049977753042253, "phrase": "current_processors"}], "paper_keywords": ["Floating-point arithmetic", " error-free transformations", " faithful rounding", " 2-norm", " underflow", " overflow"], "paper_abstract": "In this article, we present an efficient algorithm to compute the faithful rounding of the l(2)-norm of a floating-point vector. This means that the result is accurate to within 1 bit of the underlying floating-point type. This algorithm does not generate overflows or underflows spuriously, but does so when the final result calls for such a numerical exception to be raised. Moreover, the algorithm is well suited for parallel implementation and vectorization. The implementation runs up to 3 times faster than the netlib version on current processors.", "paper_title": "Efficient Calculations of Faithfully Rounded l(2)-Norms of n-Vectors", "paper_id": "WOS:000363733000002"}