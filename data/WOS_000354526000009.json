{"auto_keywords": [{"score": 0.043855814204982885, "phrase": "static_scheduling"}, {"score": 0.04052376779446135, "phrase": "load_imbalance"}, {"score": 0.011409558050688908, "phrase": "irregular_stream_programs"}, {"score": 0.00481495049065317, "phrase": "dynamic_scheduling_of_irregular_stream_programs"}, {"score": 0.004765788394931875, "phrase": "many-core_scalability"}, {"score": 0.004692980391580608, "phrase": "stream_programming_model"}, {"score": 0.004390060342250211, "phrase": "pipeline_parallelism"}, {"score": 0.0041490029730869345, "phrase": "regular_stream_programs"}, {"score": 0.004064653055162238, "phrase": "irregular_applications"}, {"score": 0.0037632749713937637, "phrase": "scalability_limitations"}, {"score": 0.003724810609448597, "phrase": "many-core_systems"}, {"score": 0.0035565113234273926, "phrase": "danbi_programming_model"}, {"score": 0.003413284742632989, "phrase": "dynamic_scheduling_techniques"}, {"score": 0.003192700856094016, "phrase": "major_hurdle"}, {"score": 0.002955782731675529, "phrase": "danbi_program"}, {"score": 0.002793260314529583, "phrase": "thundering-herd_problem"}, {"score": 0.00266693888510356, "phrase": "probabilistic_manner"}, {"score": 0.0026126405272417783, "phrase": "prior_static_stream_scheduling_approaches"}, {"score": 0.002494466951433885, "phrase": "prior_dynamic_stream_scheduling_approaches"}, {"score": 0.0024186620196958867, "phrase": "supported_program_types"}, {"score": 0.0023451553255837317, "phrase": "dynamic_scheduling"}, {"score": 0.0021709933368474223, "phrase": "danbi"}, {"score": 0.0021377414429251647, "phrase": "almost_linear_scalability"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_parallel_runtimes"}], "paper_keywords": ["Stream programming", " software pipelining", " scheduling", " load balancing", " irregular programs"], "paper_abstract": "The stream programming model has received much interest because it naturally exposes task, data, and pipeline parallelism. However, most prior work has focused on the static scheduling of regular stream programs. Therefore, irregular applications cannot be handled in static scheduling, and the load imbalance caused by static scheduling faces scalability limitations in many-core systems. In this paper, we introduce the DANBI programming model, which supports irregular stream programs, and propose dynamic scheduling techniques. Scheduling irregular stream programs is very challenging, and the load imbalance becomes a major hurdle to achieving scalability. Our dynamic load-balancing scheduler exploits producer-consumer relationships already expressed in the DANBI program to achieve scalability. Moreover, it effectively avoids the thundering-herd problem and dynamically adapts to load imbalance in a probabilistic manner. It surpasses prior static stream scheduling approaches which are vulnerable to load imbalance and also surpasses prior dynamic stream scheduling approaches which result in many restrictions on supported program types, on the scope of dynamic scheduling, and on data ordering preservation. Our experimental results on a 40-core server show that DANBI achieves an almost linear scalability and outperforms state-of-the-art parallel runtimes by up to 2.8 times.", "paper_title": "Dynamic Scheduling of Irregular Stream Programs toward Many-Core Scalability", "paper_id": "WOS:000354526000009"}