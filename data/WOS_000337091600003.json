{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "associative_classification"}, {"score": 0.004770461993586338, "phrase": "software_fault"}, {"score": 0.004617949594931096, "phrase": "recurrent_finding"}, {"score": 0.004575272950516775, "phrase": "software_development"}, {"score": 0.0044702911400353535, "phrase": "considerable_delays"}, {"score": 0.004388035083357706, "phrase": "budget_overruns"}, {"score": 0.004036141321779216, "phrase": "machine_learning_techniques"}, {"score": 0.00399881984083004, "phrase": "software_fault_prediction"}, {"score": 0.0039252049353279556, "phrase": "upfront_software_modules"}, {"score": 0.00372965096877929, "phrase": "testing_efforts"}, {"score": 0.003678023470672862, "phrase": "overall_software_quality"}, {"score": 0.003610292749660581, "phrase": "fault_prediction_models"}, {"score": 0.0035603115570447467, "phrase": "production_environment"}, {"score": 0.0035110198699787013, "phrase": "prediction_performance"}, {"score": 0.0034785371344994197, "phrase": "model_comprehensibility"}, {"score": 0.003244275497488318, "phrase": "academic_literature"}, {"score": 0.003125835572347772, "phrase": "fault_prediction"}, {"score": 0.0030825404960282713, "phrase": "associative_classification_methods"}, {"score": 0.002744234034162797, "phrase": "empirical_comparison"}, {"score": 0.0026811531172346676, "phrase": "ac-based_classifier"}, {"score": 0.002607362103727335, "phrase": "predictive_performance"}, {"score": 0.0023646866829474798, "phrase": "ac-based_models"}, {"score": 0.0023210846870653757, "phrase": "similar_prediction_performance"}, {"score": 0.0022467024793003812, "phrase": "cross_project_prediction"}, {"score": 0.002195033004022173, "phrase": "earlier_findings"}, {"score": 0.0021049977753042253, "phrase": "target_project"}], "paper_keywords": ["Software fault prediction", " associative classification", " prediction performance", " comprehensibility", " cross project validation"], "paper_abstract": "It is a recurrent finding that software development is often troubled by considerable delays as well as budget overruns and several solutions have been proposed in answer to this observation, software fault prediction being a prime example. Drawing upon machine learning techniques, software fault prediction tries to identify upfront software modules that are most likely to contain faults, thereby streamlining testing efforts and improving overall software quality. When deploying fault prediction models in a production environment, both prediction performance and model comprehensibility are typically taken into consideration, although the latter is commonly overlooked in the academic literature. Many classification methods have been suggested to conduct fault prediction; yet associative classification methods remain uninvestigated in this context. This paper proposes an associative classification (AC)-based fault prediction method, building upon the CBA2 algorithm. In an empirical comparison on 12 real-world datasets, the AC-based classifier is shown to achieve a predictive performance competitive to those of models induced by five other tree/rule-based classification techniques. In addition, our findings also highlight the comprehensibility of the AC-based models, while achieving similar prediction performance. Furthermore, the possibilities of cross project prediction are investigated, strengthening earlier findings on the feasibility of such approach when insufficient data on the target project is available.", "paper_title": "Investigating Associative Classification for Software Fault Prediction: An Experimental Perspective", "paper_id": "WOS:000337091600003"}