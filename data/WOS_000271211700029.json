{"auto_keywords": [{"score": 0.04890036336815042, "phrase": "synchronization_abstractions"}, {"score": 0.023065493239874866, "phrase": "concurrent_haskell"}, {"score": 0.010426173722079367, "phrase": "concurrent_ml"}, {"score": 0.006480686376190861, "phrase": "concurrent_ml's_concurrency_primitives"}, {"score": 0.005016199660548031, "phrase": "selective_communication"}, {"score": 0.00481495049065317, "phrase": "concurrent_ml_library"}, {"score": 0.004483912544530935, "phrase": "ml."}, {"score": 0.0037387746981660717, "phrase": "fairly_low-level"}, {"score": 0.0032418062548293745, "phrase": "concurrent_ml-style_programming"}, {"score": 0.003207315823694138, "phrase": "concurrent"}, {"score": 0.0031958979543042633, "phrase": "haskell"}, {"score": 0.0027708785175203556, "phrase": "possible_optimizations"}, {"score": 0.0026737455737636867, "phrase": "ocaml's_standard_library"}, {"score": 0.002654730366598922, "phrase": "concurrent_ml-style_primitives"}, {"score": 0.002570817338292482, "phrase": "new_distributed_synchronization_protocol"}, {"score": 0.0024718415971488627, "phrase": "concurrent_languages"}, {"score": 0.0024108455980729284, "phrase": "standard_semantics"}, {"score": 0.002173739308244513, "phrase": "distributed_machines"}, {"score": 0.002127667143545464, "phrase": "first-order_message"}], "paper_keywords": ["Algorithms", " Languages", " Concurrent ML", " synchronization abstractions", " distributed synchronization protocol", " pi-calculus", " Concurrent Haskell"], "paper_abstract": "In Concurrent ML, synchronization abstractions can be defined and passed as values, much like functions in ML. This mechanism admits a powerful, modular style of concurrent programming, called higher-order concurrent programming. Unfortunately, it is not clear whether this style of programming is possible in languages such as Concurrent Haskell, that support only first-order message passing. Indeed, the implementation of synchronization abstractions in Concurrent ML relies on fairly low-level, language-specific details. In this paper we show, constructively, that synchronization abstractions can be supported in a language that supports only first-order message passing. Specifically, we implement a library that makes Concurrent ML-style programming possible in Concurrent Haskell. We begin with a core, formal implementation of synchronization abstractions in the pi-calculus. Then, we extend this implementation to encode all of Concurrent ML's concurrency primitives (and more!) in Concurrent Haskell. Our implementation is surprisingly efficient, even without possible optimizations. In several small, informal experiments, our library seems to outperform OCaml's standard library of Concurrent ML-style primitives. At the heart of our implementation is a new distributed synchronization protocol that we prove correct. Unlike several previous translations of synchronization abstractions in concurrent languages, we remain faithful to the standard semantics for Concurrent ML's concurrency primitives. For example, we retain the symmetry of choose, which can express selective communication. As a corollary, we establish that implementing selective communication on distributed machines is no harder than implementing first-order message passing on such machines.", "paper_title": "A Concurrent ML Library in Concurrent Haskell", "paper_id": "WOS:000271211700029"}