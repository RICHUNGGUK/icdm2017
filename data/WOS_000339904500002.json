{"auto_keywords": [{"score": 0.041300200338926535, "phrase": "candidate_products"}, {"score": 0.015489956481070979, "phrase": "top-_queries"}, {"score": 0.01264690412599618, "phrase": "potential_customers"}, {"score": 0.004691136491297242, "phrase": "reverse_top-t_query"}, {"score": 0.004211069233133584, "phrase": "different_preferences"}, {"score": 0.0036689507925299885, "phrase": "competitive_existing_products"}, {"score": 0.0035744997458371335, "phrase": "np-hard_problem"}, {"score": 0.0034954725617970294, "phrase": "incremental_greedy_approach"}, {"score": 0.0034437574674180365, "phrase": "approximate_solution"}, {"score": 0.003280891942617853, "phrase": "basic_greedy_approach"}, {"score": 0.0031726587374218277, "phrase": "skyline_queries"}, {"score": 0.0031257046538823354, "phrase": "solution_space"}, {"score": 0.0030225753906647935, "phrase": "upper_bound"}, {"score": 0.002722930209707764, "phrase": "multiple_component_tables"}, {"score": 0.002603758927691463, "phrase": "accessed_tuples"}, {"score": 0.002574788013427524, "phrase": "component_tables"}, {"score": 0.002480520548392772, "phrase": "top-_favorites"}, {"score": 0.0023719332915829268, "phrase": "pruning_strategies"}, {"score": 0.0023281003994670714, "phrase": "faster_greedy_approach"}, {"score": 0.0023021895404322767, "phrase": "experiment_results"}, {"score": 0.002268088741853586, "phrase": "proposed_pruning_strategies"}, {"score": 0.0022096205841489786, "phrase": "faster_greedy_algorithms"}, {"score": 0.0021446391766277817, "phrase": "excellent_performance"}, {"score": 0.0021049977753042253, "phrase": "memory_utilization"}], "paper_keywords": ["Reverse top-t query", " Potential customers", " Query processing", " Maximum coverage problem"], "paper_abstract": "A reverse top-t query for a product returns a set of customers, named potential customers, who regard the product as one of their top-t favorites. Given a set of customers with different preferences on the features of the products, we want to select at most products from a pool of candidate products such that their total number of potential customers is maximized. Two versions of the problem are defined according to whether the competitive existing products are given. For solving this NP-hard problem, we first propose an incremental greedy approach to find an approximate solution of the problem with quality guaranteed. For further speeding up this basic greedy approach, we exploit several properties of the top- queries and skyline queries to reduce the solution space of the problem. In addition, an upper bound of the potential customers is estimated to reduce the cost of computing the reverse top- queries for the candidate products. Finally, when the candidate products are formed from multiple component tables, we propose a strategy to reduce the number of the accessed tuples in the component tables such that only the tuples that are possibly components of the top- favorites of the customers need to be accessed. By applying these pruning strategies, we propose another faster greedy approach. The experiment results demonstrate that the proposed pruning strategies work very well and make the faster greedy algorithms for both versions of the problem achieve excellent performance on both efficiency and memory utilization.", "paper_title": "Finding most favorite products based on reverse top- queries", "paper_id": "WOS:000339904500002"}