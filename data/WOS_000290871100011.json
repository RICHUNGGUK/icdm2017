{"auto_keywords": [{"score": 0.04315995617089535, "phrase": "job_co-scheduling"}, {"score": 0.00481495049065317, "phrase": "optimal_job_co-scheduling"}, {"score": 0.004706305193222972, "phrase": "heuristics-based_solutions"}, {"score": 0.004642292792558686, "phrase": "chip_multiprocessors"}, {"score": 0.004435112270935294, "phrase": "multiple_cores"}, {"score": 0.004354841111644036, "phrase": "-chip_cache"}, {"score": 0.004237138632255772, "phrase": "cache_thrashing"}, {"score": 0.004160435626849478, "phrase": "co-running_jobs"}, {"score": 0.003814563533445401, "phrase": "contention_and_consequent_performance_degradations"}, {"score": 0.003611034322786669, "phrase": "co-run_performance"}, {"score": 0.0035133644847622383, "phrase": "suitable_co-schedules"}, {"score": 0.003356396922662246, "phrase": "first_task"}, {"score": 0.0032955848190195343, "phrase": "simple_techniques"}, {"score": 0.0032064196784562017, "phrase": "different_schedules"}, {"score": 0.003063123420705719, "phrase": "systematic_exploration"}, {"score": 0.003021392767766593, "phrase": "second_task"}, {"score": 0.0029396242707327986, "phrase": "computational_complexity"}, {"score": 0.0028731719610706214, "phrase": "optimal_job_co-schedules"}, {"score": 0.0026949679939994226, "phrase": "graph_theory"}, {"score": 0.0026220103561723066, "phrase": "optimal_co-schedules"}, {"score": 0.002527788827701828, "phrase": "job_migrations"}, {"score": 0.002493333098814506, "phrase": "complex_cases"}, {"score": 0.002244277924422011, "phrase": "job_co-schedulers"}, {"score": 0.0022136780933978612, "phrase": "necessary_baselines"}, {"score": 0.0021049977753042253, "phrase": "co-scheduling_algorithms"}], "paper_keywords": ["Co-scheduling", " shared cache", " CMP scheduling", " cache contention", " perfect matching", " integer programming"], "paper_abstract": "In Chip Multiprocessors (CMPs) architecture, it is common that multiple cores share some on-chip cache. The sharing may cause cache thrashing and contention among co-running jobs. Job co-scheduling is an approach to tackling the problem by assigning jobs to cores appropriately so that the contention and consequent performance degradations are minimized. Job co-scheduling includes two tasks: the estimation of co-run performance, and the determination of suitable co-schedules. Most existing studies in job co-scheduling have concentrated on the first task but relies on simple techniques (e. g., trying different schedules) for the second. This paper presents a systematic exploration to the second task. The paper uncovers the computational complexity of the determination of optimal job co-schedules, proving its NP-completeness. It introduces a set of algorithms, based on graph theory and Integer/Linear Programming, for computing optimal co-schedules or their lower bounds in scenarios with or without job migrations. For complex cases, it empirically demonstrates the feasibility for approximating the optimal effectively by proposing several heuristics-based algorithms. These discoveries may facilitate the assessment of job co-schedulers by providing necessary baselines, as well as shed insights to the development of co-scheduling algorithms in practical systems.", "paper_title": "The Complexity of Optimal Job Co-Scheduling on Chip Multiprocessors and Heuristics-Based Solutions", "paper_id": "WOS:000290871100011"}