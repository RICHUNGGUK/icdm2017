{"auto_keywords": [{"score": 0.050076541926527426, "phrase": "trace_cache"}, {"score": 0.039717311925460824, "phrase": "smt"}, {"score": 0.004489810932879285, "phrase": "value_prediction"}, {"score": 0.004133627071344356, "phrase": "single-threaded_superscalar"}, {"score": 0.003287486794313661, "phrase": "smt."}, {"score": 0.0030457198309616694, "phrase": "future_smt_designs"}, {"score": 0.0028397103530211415, "phrase": "fundamental_interaction"}, {"score": 0.002750721367040336, "phrase": "smt's_sharing"}, {"score": 0.0026815368507715, "phrase": "multiple_threads"}, {"score": 0.0024527767211457046, "phrase": "smt_throughput"}, {"score": 0.0023458049872325214, "phrase": "instruction_storage"}, {"score": 0.0021049977753042253, "phrase": "queue_impacts"}], "paper_keywords": [""], "paper_abstract": "While trace cache, value prediction, and. prefetching have been shown to be effective in the single-threaded superscalar, there has been no analysis of these techniques in a Simultaneously Multithreaded (SMT) processor. SMT brings new factors both for and against these techniques, and it is not known how these techniques would fare in SMT. We evaluate these techniques in an SMT to provide recommendations for future SMT designs. Our key contributions are: (1) we identify a fundamental interaction between the techniques and SMT's sharing of resources among multiple threads, and (2) we quantify the impact of this interaction on SMT throughput. SMT's sharing of the instruction storage (i.e., trace cache or i-cache), physical registers, and issue queue impacts the effectiveness of trace cache, value prediction, and prefetching, respectively.", "paper_title": "Do trace cache, value prediction and prefetching improve SMT throughput?", "paper_id": "WOS:000236884200017"}