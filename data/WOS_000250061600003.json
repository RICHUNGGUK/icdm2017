{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "dynamic_trees"}, {"score": 0.044476153128415616, "phrase": "labeling_schemes"}, {"score": 0.0316727896939775, "phrase": "label_size"}, {"score": 0.015262565855172942, "phrase": "f-labeling_scheme"}, {"score": 0.010435409021063335, "phrase": "ancestry_relation"}, {"score": 0.009901713136794646, "phrase": "static_scheme"}, {"score": 0.004620093797504386, "phrase": "marker_algorithm"}, {"score": 0.004525629293824217, "phrase": "short_labels"}, {"score": 0.004473982381245469, "phrase": "decoder_algorithm"}, {"score": 0.004109600767747015, "phrase": "distributed_dynamic_labeling_schemes"}, {"score": 0.003757480190200645, "phrase": "leaf-increasing_tree_model"}, {"score": 0.003483120583663528, "phrase": "korman_et_al"}, {"score": 0.0033266548137541175, "phrase": "existing_static_tree_labeling_scheme"}, {"score": 0.0031991799574455555, "phrase": "separation_level"}, {"score": 0.0031193028729331667, "phrase": "designer_port_models"}, {"score": 0.0029654643666160883, "phrase": "communication_complexity"}, {"score": 0.0029114187110123105, "phrase": "multiplicative_overhead_factor"}, {"score": 0.00286493504971388, "phrase": "label_sizes"}, {"score": 0.002845240716618949, "phrase": "static_schemes"}, {"score": 0.002723607240517261, "phrase": "different_general_method"}, {"score": 0.002704881797334006, "phrase": "static_labeling_schemes"}, {"score": 0.002686284749214443, "phrase": "dynamic_tree_settings"}, {"score": 0.002643386043540555, "phrase": "tree_functions"}, {"score": 0.0023725232579531273, "phrase": "multiplicative_overhead_factors"}, {"score": 0.0022399174232611853, "phrase": "amortized_message_complexity"}, {"score": 0.002124461969404541, "phrase": "dynamic_labeling_schemes"}, {"score": 0.0021147075258839453, "phrase": "asymptotically_optimal_label_sizes"}, {"score": 0.0021049977753042253, "phrase": "sublinear_amortized_message_complexity"}], "paper_keywords": ["distributed algorithms", " dynamic networks", " labeling schemes", " routing schemes"], "paper_abstract": "Let F be a function on pairs of vertices. An F-labeling scheme is composed of a marker algorithm for labeling the vertices of a graph with short labels, coupled with a decoder algorithm allowing one to compute F(u, v) for any two vertices u and v directly from their labels. As applications for labeling schemes concern mainly large and dynamically changing networks, it is of interest to study distributed dynamic labeling schemes. This paper investigates labeling schemes for dynamic trees. We consider two dynamic tree models, namely, the leaf-dynamic tree model in which at each step a leaf can be added to or removed from the tree and the leaf-increasing tree model in which the only topological event that may occur is that a leaf joins the tree. A general method for constructing labeling schemes for dynamic trees (under the above mentioned dynamic tree models) was previously developed in Korman et al. (Theory Comput Syst 37:49-75, 2004). This method is based on extending an existing static tree labeling scheme to the dynamic setting. This approach fits many natural functions on trees, such as distance, separation level, ancestry relation, routing (in both the adversary and the designer port models), nearest common ancestor etc.. Their resulting dynamic schemes incur overheads (over the static scheme) on the label size and on the communication complexity. In particular, all their schemes yield a multiplicative overhead factor of Omega(log n) on the label sizes of the static schemes. Following (Korman et al., Theory Comput Syst 37:49-75, 2004), we develop a different general method for extending static labeling schemes to the dynamic tree settings. Our method fits the same class of tree functions. In contrast to the above paper, our trade-off is designed to minimize the label size, sometimes at the expense of communication. Informally, for any function k(n) and any static F-labeling scheme on trees, we present an F-labeling scheme on dynamic trees incurring multiplicative overhead factors (over the static scheme) of O(log(k(n)) n) on the label size and O(k(n) log(k(n)) n) on the amortized message complexity. In particular, by setting k( n) = n(epsilon) for any 0 < epsilon < 1, we obtain dynamic labeling schemes with asymptotically optimal label sizes and sublinear amortized message complexity for the ancestry relation, the id-based and label-based nearest common ancestor relation and the routing function.", "paper_title": "General compact labeling schemes for dynamic trees", "paper_id": "WOS:000250061600003"}