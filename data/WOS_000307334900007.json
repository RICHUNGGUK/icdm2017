{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "mechanized_metatheory"}, {"score": 0.004398094237005956, "phrase": "theorem-proving_systems"}, {"score": 0.0040171817997972335, "phrase": "compiler_correctness"}, {"score": 0.0037532257703888315, "phrase": "first_poplmark"}, {"score": 0.0033893426032054366, "phrase": "compiler_implementations"}, {"score": 0.002763709443278514, "phrase": "specific_criteria"}, {"score": 0.0025819015229390663, "phrase": "mechanized_metatheory_systems"}, {"score": 0.002305014991156598, "phrase": "twelf_metatheory"}], "paper_keywords": ["Theorem proving", " Proof assistants", " Program proof", " Compiler verification", " Typed machine language", " Metatheory", " Coq", " Twelf"], "paper_abstract": "We propose a benchmark to compare theorem-proving systems on their ability to express proofs of compiler correctness. In contrast to the first POPLmark, we emphasize the connection of proofs to compiler implementations, and we point out that much can be done without binders or alpha-conversion. We propose specific criteria for evaluating the utility of mechanized metatheory systems; we have constructed solutions in both Coq and Twelf metatheory, and we draw conclusions about those two systems in particular.", "paper_title": "A List-Machine Benchmark for Mechanized Metatheory", "paper_id": "WOS:000307334900007"}