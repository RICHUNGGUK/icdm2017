{"auto_keywords": [{"score": 0.04981327237913684, "phrase": "computational_kernels"}, {"score": 0.01243687655319017, "phrase": "xark"}, {"score": 0.008713768692145006, "phrase": "automatic_recognition"}, {"score": 0.006511973203714578, "phrase": "source_code"}, {"score": 0.005113476897290613, "phrase": "xark_compiler"}, {"score": 0.0047221003380992525, "phrase": "program_constructs"}, {"score": 0.004643934241650914, "phrase": "software_developers"}, {"score": 0.004605335502605577, "phrase": "powerful_mechanism"}, {"score": 0.004454107944369186, "phrase": "object_code"}, {"score": 0.004260134699483774, "phrase": "array_recurrences"}, {"score": 0.00421297029755273, "phrase": "intensive_research_area"}, {"score": 0.004154745345684458, "phrase": "compiler_technology"}, {"score": 0.004040688646993605, "phrase": "new_compiler_framework"}, {"score": 0.003995944005801644, "phrase": "previous_techniques"}, {"score": 0.003951692879298571, "phrase": "specific_and_isolated_kernels"}, {"score": 0.00390792986752692, "phrase": "comprehensive_collection"}, {"score": 0.0038325030882481797, "phrase": "full-scale_real_applications"}, {"score": 0.0037272595230222125, "phrase": "gated_single_assignment"}, {"score": 0.0037065619213039985, "phrase": "gsa"}, {"score": 0.0036553070575015344, "phrase": "high-level_intermediate_representation"}, {"score": 0.003575002283537593, "phrase": "recognition"}, {"score": 0.0035155276979913466, "phrase": "demand-driven_analysis"}, {"score": 0.003486275025030832, "phrase": "high-level_ir"}, {"score": 0.0033529377175106636, "phrase": "strongly_connected_components"}, {"score": 0.0032973606227939423, "phrase": "data-dependence_graph"}, {"score": 0.0032699173589777948, "phrase": "gsa_form"}, {"score": 0.003188946047322158, "phrase": "intra-scc_analysis"}, {"score": 0.0029826617970403566, "phrase": "different_sccs"}, {"score": 0.0028845643213678755, "phrase": "simpler_kernels"}, {"score": 0.0027974705482714884, "phrase": "hierarchical_representation"}, {"score": 0.00274341766440739, "phrase": "dependence_relationships"}, {"score": 0.0025587358189000193, "phrase": "recognition_algorithms"}, {"score": 0.00246765655376112, "phrase": "recognition_capabilities"}, {"score": 0.002426717832834137, "phrase": "new_kernels"}, {"score": 0.0023931202835437626, "phrase": "advanced_symbolic_analysis_framework"}, {"score": 0.002333809817752256, "phrase": "extensive_experiments"}, {"score": 0.00225700428055894, "phrase": "different_application_domains"}, {"score": 0.002207206921611084, "phrase": "sparskit-ii_library"}, {"score": 0.0021766418372878835, "phrase": "sparse_matrices"}, {"score": 0.002158505888557746, "phrase": "perfect_benchmarks"}, {"score": 0.00212268510072928, "phrase": "pltmg_package"}, {"score": 0.0021049977753042253, "phrase": "elliptic_partial_differential_equations"}], "paper_keywords": ["Algorithms", " Languages", " Experimentation", " Automatic kernel recognition", " demand-driven algorithms", " use-def chains", " symbolic analysis", " gated single assignment", " strongly connected component"], "paper_abstract": "The recognition of program constructs that are frequently used by software developers is a powerful mechanism for optimizing and parallelizing compilers to improve the performance of the object code. The development of techniques for automatic recognition of computational kernels such as inductions, reductions and array recurrences has been an intensive research area in the scope of compiler technology during the 90's. This article presents a new compiler framework that, unlike previous techniques that focus on specific and isolated kernels, recognizes a comprehensive collection of computational kernels that appear frequently in full-scale real applications. The XARK compiler operates on top of the Gated Single Assignment (GSA) form of a high-level intermediate representation (IR) of the source code. Recognition is carried out through a demand-driven analysis of this high-level IR at two different levels. First, the dependences between the statements that compose the strongly connected components (SCCs) of the data-dependence graph of the GSA form are analyzed. As a result of this intra-SCC analysis, the computational kernels corresponding to the execution of the statements of the SCCs are recognized. Second, the dependences between statements of different SCCs are examined in order to recognize more complex kernels that result from combining simpler kernels in the same code. Overall, the XARK compiler builds a hierarchical representation of the source code as kernels and dependence relationships between those kernels. This article describes in detail the collection of computational kernels recognized by the XARK compiler. Besides, the internals of the recognition algorithms are presented. The design of the algorithms enables to extend the recognition capabilities of XARK to cope with new kernels, and provides an advanced symbolic analysis framework to run other compiler techniques on demand. Finally, extensive experiments showing the effectiveness of XARK for a collection of benchmarks from different application domains are presented. In particular, the SparsKit-II library for the manipulation of sparse matrices, the Perfect benchmarks, the SPEC CPU2000 collection and the PLTMG package for solving elliptic partial differential equations are analyzed in detail.", "paper_title": "XARK: An EXtensible Framework for Automatic Recognition of Computational Kernels", "paper_id": "WOS:000260958900003"}