{"auto_keywords": [{"score": 0.0450678547644915, "phrase": "data_traces"}, {"score": 0.00481495049065317, "phrase": "time-aware_instrumentation"}, {"score": 0.0047709540557306284, "phrase": "embedded_software"}, {"score": 0.0047273577269638725, "phrase": "software_instrumentation"}, {"score": 0.004662705558154439, "phrase": "key_technique"}, {"score": 0.004556901872357751, "phrase": "development_process"}, {"score": 0.004392565073466714, "phrase": "embedded_systems"}, {"score": 0.004352411290383643, "phrase": "instrumented_programs"}, {"score": 0.0038981499110532273, "phrase": "runtime_overhead"}, {"score": 0.003809628721278519, "phrase": "additional_computation_resources"}, {"score": 0.003555902292752528, "phrase": "system's_timing"}, {"score": 0.0033651019362620866, "phrase": "instrumentation_technique"}, {"score": 0.0033037970113095577, "phrase": "temporal_constraints"}, {"score": 0.003213920601037463, "phrase": "cyclic_executive_systems"}, {"score": 0.0030135741897058844, "phrase": "software_instrumentations"}, {"score": 0.002878140062594849, "phrase": "trace_reliability"}, {"score": 0.002786964045867666, "phrase": "real-time_applications"}, {"score": 0.0026011706232569316, "phrase": "low_perturbation"}, {"score": 0.002530359917257626, "phrase": "insertion_points"}, {"score": 0.0025071862539276283, "phrase": "trace_buffer_size"}, {"score": 0.002461472107682778, "phrase": "code_size"}, {"score": 0.002276283303864666, "phrase": "openec_firmware"}, {"score": 0.0022450768409733807, "phrase": "keyboard_controller"}, {"score": 0.002194011800331242, "phrase": "child_project"}, {"score": 0.0021049977753042253, "phrase": "flash_file_system"}], "paper_keywords": ["Debugging", " instrumentation", " real-time systems", " tracing."], "paper_abstract": "Software instrumentation is a key technique in many stages of the development process. It is particularly important for debugging embedded systems. Instrumented programs produce data traces which enable the developer to locate the origins of misbehaviors in the system under test. However, producing data traces incurs runtime overhead in the form of additional computation resources for capturing and copying the data. The instrumentation may therefore interfere with the system's timing and perturb its behavior. In this work, we propose an instrumentation technique for applications with temporal constraints, specifically targeting background/foreground or cyclic executive systems. Our framework permits reasoning about space and time and enables the composition of software instrumentations. In particular, we propose a definition for trace reliability, which enables us to instrument real-time applications which aggressively push their time budgets. Using the framework, we present a method with low perturbation by optimizing the number of insertion points and trace buffer size with respect to code size and time budgets. Finally, we apply the theory to two concrete case studies: we instrument the OpenEC firmware for the keyboard controller of the One Laptop Per Child project, as well as an implementation of a flash file system.", "paper_title": "Time-Aware Instrumentation of Embedded Software", "paper_id": "WOS:000283984900016"}