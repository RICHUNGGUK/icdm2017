{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "weak_properties"}, {"score": 0.00918949955405056, "phrase": "proof_trees"}, {"score": 0.0046739596755881185, "phrase": "rule-based_programming"}, {"score": 0.004125314447335291, "phrase": "computation_branch"}, {"score": 0.003450966222451681, "phrase": "expected_result"}, {"score": 0.003009390313137981, "phrase": "constructor_form"}, {"score": 0.002938560664857691, "phrase": "unified_framework"}, {"score": 0.002371424085814217, "phrase": "evaluation_strategy"}, {"score": 0.0022881443200668886, "phrase": "right_computation_branch"}, {"score": 0.0022077827041801193, "phrase": "costly_breadth-first_strategy"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Abstraction", " Completeness", " Induction", " Rewriting", " Narrowing", " Weak termination"], "paper_abstract": "In rule-based programming, properties of programs, such as termination, are in general considered in their strong acceptance, i.e., on every computation branch. But in practice, they may hold in their weak acceptance only, i.e., on at least one computation branch. Moreover, weak properties are often enough to ensure that programs give the expected result. There are very few results to handle weak properties of rewriting. We address here two of them: termination and reducibility to a constructor form, in a unified framework allowing us to prove them inductively. Proof trees are developed, which simulate rewriting trees by narrowing and abstracting subterms. Our technique is constructive in the sense that proof trees can be used to infer an evaluation strategy for any given input: the right computation branch is developed without using a costly breadth-first strategy nor backtracking. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Proving weak properties of rewriting", "paper_id": "WOS:000293119400002"}