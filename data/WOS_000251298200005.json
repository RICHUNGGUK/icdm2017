{"auto_keywords": [{"score": 0.0388263744242103, "phrase": "vliw_schedules"}, {"score": 0.015719716506582538, "phrase": "vliw_processors"}, {"score": 0.004777569299319633, "phrase": "exact_methods"}, {"score": 0.004740476936977635, "phrase": "optimal_instruction_scheduling"}, {"score": 0.004506265705673849, "phrase": "assumed_processor_model"}, {"score": 0.004333973355873714, "phrase": "optimal_solution"}, {"score": 0.004233762728640565, "phrase": "different_classes"}, {"score": 0.003916098498242888, "phrase": "integer_linear_programming"}, {"score": 0.0035245918797629804, "phrase": "superscalar_processors"}, {"score": 0.003324203391715804, "phrase": "linearized_form"}, {"score": 0.003298357357267836, "phrase": "vliw_compaction_methods"}, {"score": 0.003234615195382533, "phrase": "dynamic_instruction_dispatch_algorithms"}, {"score": 0.0032094634756436595, "phrase": "in-order_and_out-of-order_issue_superscalar_processors"}, {"score": 0.002968424524565369, "phrase": "multiblock_reservation_tables"}, {"score": 0.0028996963188373144, "phrase": "time_optimization"}, {"score": 0.002865929543375884, "phrase": "greedy_schedules"}, {"score": 0.002671406231520296, "phrase": "incremental_scheduling_algorithms"}, {"score": 0.002619748321217153, "phrase": "topological_sorting"}, {"score": 0.0025892330566358503, "phrase": "data_dependence_graph"}, {"score": 0.002311933249234786, "phrase": "optimal_vliw_scheduling"}, {"score": 0.002163367190715979, "phrase": "optimal_schedule"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["instruction-level parallelism", " instruction scheduling", " code generation", " code compaction", " integer linear programming", " VLIW architecture", " superscalar processor"], "paper_abstract": "Exact methods for optimal instruction scheduling are gaining importance. They differ, however, considerably in the assumed processor model and in the space of schedules searched for an optimal solution. We identify and analyze different classes of schedules for VLIW processors. The classes are induced by various common techniques for generating or enumerating them, such as integer linear programming or list scheduling with backtracking. In particular, we study the relationship between VLIW schedules and their equivalent linearized forms (which may be used, e.g., with superscalar processors), and we identify classes of VLIW schedules that can be created from a linearized form using VLIW compaction methods that are just the static equivalents of dynamic instruction dispatch algorithms of in-order and out-of-order issue superscalar processors. For example, we study the class of greedy schedules and show that, if all instructions have multiblock reservation tables, it is safe for time optimization to consider greedy schedules only. We also show that, in certain situations, certain schedules generally cannot be constructed by incremental scheduling algorithms that are based on topological sorting of the data dependence graph. We summarize our findings as a hierarchy of classes of VLIW schedules. These results can sharpen the interpretation of the term 'optimality' used with various methods for optimal VLIW scheduling, and may help to identify classes that can be safely ignored when searching for an optimal schedule. Copyright (c) 2007 John Wiley & Sons, Ltd.", "paper_title": "Classification and generation of schedules for VLIW processors", "paper_id": "WOS:000251298200005"}