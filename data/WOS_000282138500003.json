{"auto_keywords": [{"score": 0.04807496386351964, "phrase": "dependently_typed_lambda_calculus"}, {"score": 0.00481495049065317, "phrase": "tutorial_implementation"}, {"score": 0.004296264970612285, "phrase": "type_rules"}, {"score": 0.004116440453049531, "phrase": "dependently_typed_core_calculus"}, {"score": 0.00388828234270598, "phrase": "straightforward_implementation"}, {"score": 0.003779017029526606, "phrase": "haskell"}, {"score": 0.0031845067058084583, "phrase": "simply-typed_lambda_calculus"}, {"score": 0.0026452734009203764, "phrase": "data_types"}, {"score": 0.0022608057001451414, "phrase": "executable_interpreter"}, {"score": 0.0021971473452127126, "phrase": "example_code"}, {"score": 0.0021049977753042253, "phrase": "immediate_experimentation"}], "paper_keywords": [""], "paper_abstract": "We present the type rules for a dependently typed core calculus together with a straightforward implementation in Haskell. We explicitly highlight the changes necessary to shift from a simply-typed lambda calculus to the dependently typed lambda calculus. We also describe how to extend our core language with data types and write several small example programs. The article is accompanied by an executable interpreter and example code that allows immediate experimentation with the system we describe.", "paper_title": "A Tutorial Implementation of a Dependently Typed Lambda Calculus", "paper_id": "WOS:000282138500003"}