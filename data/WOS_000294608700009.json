{"auto_keywords": [{"score": 0.049188612914091503, "phrase": "global_resource_control"}, {"score": 0.04516267803280923, "phrase": "power_consumption"}, {"score": 0.030424249019695215, "phrase": "control_layer"}, {"score": 0.00481495049065317, "phrase": "synchronous_programming"}, {"score": 0.004769958800452922, "phrase": "device_drivers"}, {"score": 0.004681226806682058, "phrase": "embedded_operating_systems"}, {"score": 0.00461575768501871, "phrase": "embedded_systems"}, {"score": 0.004529881123652277, "phrase": "shared_resource"}, {"score": 0.003897742942358768, "phrase": "centralized_view"}, {"score": 0.0038431888954930083, "phrase": "devices'_states"}, {"score": 0.003666776809252461, "phrase": "sensor_networks"}, {"score": 0.0035648266669315943, "phrase": "small_embedded_systems"}, {"score": 0.003322140088192527, "phrase": "significant_gains"}, {"score": 0.0032145922365231093, "phrase": "consumption_modes"}, {"score": 0.003038237581227068, "phrase": "simple_adaptation"}, {"score": 0.002995677265350124, "phrase": "application_level"}, {"score": 0.002726740692380339, "phrase": "simple_automata"}, {"score": 0.0025892330566358503, "phrase": "power_consumption_modes"}, {"score": 0.0025053520095236694, "phrase": "global_properties"}, {"score": 0.0024241817763927163, "phrase": "synchronous_language"}, {"score": 0.0023789822182914877, "phrase": "static_scheduling"}, {"score": 0.0023346234464901978, "phrase": "single_piece"}, {"score": 0.0023127544795063263, "phrase": "c_code"}, {"score": 0.0021551222226685648, "phrase": "traditional_multithreading_operating_system"}], "paper_keywords": ["Algorithms", " Synchronous Paradigm", " Automated Control", " Power-Aware Implementation", " Wireless Sensor Networks"], "paper_abstract": "In embedded systems, controlling a shared resource like the bus, or improving a property like power consumption, may be hard to achieve when programming device drivers individually. There is a need for global resource control, taking decisions based on a centralized view of the devices' states. In this paper, we study power consumption in sensor networks, where the nodes are small embedded systems powered by batteries. We concentrate on the hardware/software architecture of a node, where significant gains can be achieved by controlling the consumption modes of the various devices globally. The architecture we propose involves a simple adaptation of the application level, to communicate with the hardware via a control layer. The control layer itself is built from a set of simple automata: the drivers of the devices, whose states correspond to power consumption modes, and a controller that enforces global properties. All these automata are programmed using a synchronous language, whose compiler performs static scheduling and produces a single piece of C code. We explain the approach in details, demonstrate its use with either Contiki or a traditional multithreading operating system, and report on our experiments.", "paper_title": "Synchronous Programming of Device Drivers for Global Resource Control in Embedded Operating Systems", "paper_id": "WOS:000294608700009"}