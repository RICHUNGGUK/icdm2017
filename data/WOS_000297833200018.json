{"auto_keywords": [{"score": 0.047802242875604355, "phrase": "datar"}, {"score": 0.047678806414826455, "phrase": "motwani"}, {"score": 0.022261096583566366, "phrase": "babcock"}, {"score": 0.010569666866229406, "phrase": "sliding_windows_model"}, {"score": 0.0075895296032029835, "phrase": "over-sampling_method"}, {"score": 0.007152365716459563, "phrase": "sliding_windows"}, {"score": 0.006676757763254989, "phrase": "indyk"}, {"score": 0.005459833768306472, "phrase": "cormode"}, {"score": 0.005445099191970239, "phrase": "muthukrishnan"}, {"score": 0.005144635360028765, "phrase": "k_samples"}, {"score": 0.004776045956489136, "phrase": "important_case"}, {"score": 0.004756711164376025, "phrase": "streaming_model"}, {"score": 0.004561435826527103, "phrase": "widom"}, {"score": 0.0045062369566329944, "phrase": "gionis"}, {"score": 0.0043800392732323045, "phrase": "fixed_size"}, {"score": 0.004274674436298454, "phrase": "fixed_parameter"}, {"score": 0.0041549346214203135, "phrase": "single_step"}, {"score": 0.004121340894041519, "phrase": "last_t_steps"}, {"score": 0.004082489940894373, "phrase": "fixed_parameter_t"}, {"score": 0.004065951389941403, "phrase": "random_sampling"}, {"score": 0.004049479565790619, "phrase": "fundamental_tool"}, {"score": 0.00403853528823342, "phrase": "data_streams"}, {"score": 0.004022174082572901, "phrase": "numerous_algorithms"}, {"score": 0.004000461789254997, "phrase": "sampled_data"}, {"score": 0.003973485512321946, "phrase": "entire_stream"}, {"score": 0.003962745801989759, "phrase": "effective_sampling"}, {"score": 0.0039306998378317295, "phrase": "nontrivial_problem"}, {"score": 0.0038102303259679063, "phrase": "deleted_elements"}, {"score": 0.0037896577832672307, "phrase": "entire_window"}, {"score": 0.0037743010271713054, "phrase": "implicit_nature"}, {"score": 0.00372355818900207, "phrase": "existing_methods"}, {"score": 0.0036934393166178216, "phrase": "explicit_deletions"}, {"score": 0.0036536580604613414, "phrase": "rozenbaum"}, {"score": 0.003624102624715537, "phrase": "frahling"}, {"score": 0.00360453149273517, "phrase": "sohler"}, {"score": 0.0034987570025741834, "phrase": "implicit_deletions"}, {"score": 0.0033640389001960997, "phrase": "obvious_disadvantages"}, {"score": 0.0033098173146814676, "phrase": "additional_costs"}, {"score": 0.0032564668172126014, "phrase": "memory_bounds"}, {"score": 0.0031996373239639637, "phrase": "even_small_probability_events"}, {"score": 0.0028788333208613123, "phrase": "randomized_bounds"}, {"score": 0.0027529584542185384, "phrase": "randomized_complexity"}, {"score": 0.0027122493313123377, "phrase": "esa"}, {"score": 0.0026975735311976197, "phrase": "chakrabarti"}, {"score": 0.002682991567875978, "phrase": "mcgregor"}, {"score": 0.0023749184208371322, "phrase": "optimal_sampling_schemas"}, {"score": 0.0023239675473344214, "phrase": "fixed_or_timestamp-based_windows"}, {"score": 0.002308270158486372, "phrase": "fixed-size_windows"}, {"score": 0.0022957884470036186, "phrase": "optimal_solutions"}, {"score": 0.00226487798581053, "phrase": "timestamp-based_windows"}, {"score": 0.0021923765227391473, "phrase": "gemulla"}, {"score": 0.0021864411179849117, "phrase": "lehner"}, {"score": 0.0021279531349081868, "phrase": "deterministic_bounds"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Data streams", " Random sampling", " Sliding windows"], "paper_abstract": "A sliding windows model is an important case of the streaming model, where only the most \"recent\" elements remain active and the rest are discarded. The sliding windows model is important for many applications (see, e.g., Babcock, Babu, Datar, Motwani and Widom (PODS 02); and Datar, Gionis, Indyk and Motwani (SODA 02)). There are two equally important types of the sliding windows model - windows with fixed size (e.g., where items arrive one at a time, and only the most recent n items remain active for some fixed parameter n), and timestamp-based windows (e.g., where many items can arrive in \"bursts\" at a single step and where only items from the last t steps remain active, again for some fixed parameter t). Random sampling is a fundamental tool for data streams, as numerous algorithms operate on the sampled data instead of on the entire stream. Effective sampling from sliding windows is a nontrivial problem, as elements eventually expire. In fact, the deletions are implicit; i.e., it is not possible to identify deleted elements without storing the entire window. The implicit nature of deletions on sliding windows does not allow the existing methods (even those that support explicit deletions, e.g., Cormode, Muthukrishnan and Rozenbaum (VLDB 05); Frahling, Indyk and Sohler (SOCG 05)) to be directly \"translated\" to the sliding windows model. One trivial approach to overcoming the problem of implicit deletions is that of over-sampling. When k samples are required, the over-sampling method maintains k' > k samples in the hope that at least k samples are not expired. The obvious disadvantages of this method are twofold: (a) It introduces additional costs and thus decreases the performance; and (b) The memory bounds are not deterministic, which is atypical for streaming algorithms (where even small probability events may eventually happen for a stream that is long enough). Babcock, Datar and Motwani (SODA 02), were the first to stress the importance of improvements to over-sampling. They formally introduced the problem of sampling from sliding windows and improved the over-sampling method for sampling with replacement. Their elegant solutions for sampling with replacement are optimal in expectation, and thus resolve disadvantage (a) mentioned above. Unfortunately, the randomized bounds do not resolve disadvantage (b) above. Interestingly, all algorithms that employ the ideas of Babcock, Datar and Motwani have the same central problem of having to deal with a randomized complexity bound (see, e.g., Datar and Muthukrishnan (ESA 02); Chakrabarti, Cormode and McGregor (SODA 07)). Further, the proposed solutions of Babcock. Datar and Motwani for sampling without replacement are based on the over-sampling method and thus do not solve problem (a). Therefore, the question of whether we can solve sampling on sliding windows optimally (i.e., resolve both disadvantages) is implicit in the paper of Babcock. Datar and Motwani and has remained open for all variants of the problem. In this paper we answer these questions affirmatively and provide optimal sampling schemas for all variants of the problem, i.e., sampling with or without replacement from fixed or timestamp-based windows. Specifically, for fixed-size windows, we provide optimal solutions that require O (k) memory; for timestamp-based windows, we show algorithms that require O (k logn) space,(1) which is optimal since it matches the lower bound by Gemulla and Lehner (SIGMOD 08). In contrast to the work of Babcock, Datar and Motwani, our solutions have deterministic bounds. (C) 2011 Published by Elsevier Inc.", "paper_title": "Optimal sampling from sliding windows", "paper_id": "WOS:000297833200018"}