{"auto_keywords": [{"score": 0.043650576243490884, "phrase": "temporal_safety"}, {"score": 0.015279904083785283, "phrase": "pointer_dereferences"}, {"score": 0.012310922769076372, "phrase": "cets"}, {"score": 0.00481495049065317, "phrase": "c._temporal_memory_safety_errors"}, {"score": 0.0046253989970108985, "phrase": "double_frees"}, {"score": 0.004520438007604407, "phrase": "prevalent_source"}, {"score": 0.0044688500725247726, "phrase": "software_bugs"}, {"score": 0.004417848254181138, "phrase": "unmanaged_languages"}, {"score": 0.004342756449992773, "phrase": "c."}, {"score": 0.0040767015025213625, "phrase": "high_runtime_overheads"}, {"score": 0.0038713805573219297, "phrase": "debugging_aids"}, {"score": 0.003471135453226184, "phrase": "c_programs"}, {"score": 0.0033922781038328844, "phrase": "existing_approaches"}, {"score": 0.003296212583539166, "phrase": "unique_identifier"}, {"score": 0.003058944053868522, "phrase": "disjoint_metadata_space"}, {"score": 0.003006654007926993, "phrase": "memory_layout_compatibility"}, {"score": 0.0027741761880779535, "phrase": "formal_proof"}, {"score": 0.0025596276616952516, "phrase": "arbitrary_casts"}, {"score": 0.002472822097373027, "phrase": "spatial_safety_violations"}, {"score": 0.002402731767209114, "phrase": "temporal_check_removal_optimizations"}, {"score": 0.002375253757224999, "phrase": "traditional_compiler_optimizations"}, {"score": 0.002321234686549485, "phrase": "runtime_overhead"}, {"score": 0.002191489192077851, "phrase": "spatial-checking_system"}, {"score": 0.0021539955106204354, "phrase": "average_overall_overhead"}, {"score": 0.0021049977753042253, "phrase": "complete_memory_safety"}], "paper_keywords": ["Languages", " Performance", " Reliability", " Memory safety", " temporal errors", " dangling pointers", " C"], "paper_abstract": "Temporal memory safety errors, such as dangling pointer dereferences and double frees, are a prevalent source of software bugs in unmanaged languages such as C. Existing schemes that attempt to retrofit temporal safety for such languages have high runtime overheads and/or are incomplete, thereby limiting their effectiveness as debugging aids. This paper presents CETS, a compile-time transformation for detecting all violations of temporal safety in C programs. Inspired by existing approaches, CETS maintains a unique identifier with each object, associates this metadata with the pointers in a disjoint metadata space to retain memory layout compatibility, and checks that the object is still allocated on pointer dereferences. A formal proof shows that this is sufficient to provide temporal safety even in the presence of arbitrary casts if the program contains no spatial safety violations. Our CETS prototype employs both temporal check removal optimizations and traditional compiler optimizations to achieve a runtime overhead of just 48% on average. When combined with a spatial-checking system, the average overall overhead is 116% for complete memory safety.", "paper_title": "CETS: Compiler-Enforced Temporal Safety for C", "paper_id": "WOS:000280548600004"}