{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "diam-based_vliw_architectures"}, {"score": 0.004552360432689039, "phrase": "wide_datapath"}, {"score": 0.00430402915573404, "phrase": "dynamic_implied_addressing_mode"}, {"score": 0.004192803336288522, "phrase": "lower_power_consumption"}, {"score": 0.004161553532799662, "phrase": "smaller_code_size"}, {"score": 0.0041151131903594445, "phrase": "small_performance_overhead"}, {"score": 0.0038471128411102914, "phrase": "additionally_generated_special_instructions"}, {"score": 0.0037058116979705857, "phrase": "reduced_instruction_bit-width"}, {"score": 0.003543059748318891, "phrase": "performance_impact"}, {"score": 0.0034773669221269594, "phrase": "vliw_architecture"}, {"score": 0.003362163770566293, "phrase": "high_level"}, {"score": 0.0033370841436001597, "phrase": "instruction_level_parallelism"}, {"score": 0.0031312981393997355, "phrase": "aggressive_code_scheduling"}, {"score": 0.0030162086479223506, "phrase": "performance_degradation"}, {"score": 0.0029053368919259985, "phrase": "total_execution_time"}, {"score": 0.0028301536956600137, "phrase": "high_ilp."}, {"score": 0.0027776422068966867, "phrase": "original_diam_compilation_technique"}, {"score": 0.002675516297446243, "phrase": "proposed_loop_optimization_scheme"}, {"score": 0.0025868090345615197, "phrase": "performance_loss"}, {"score": 0.002548331088496964, "phrase": "excessive_number"}, {"score": 0.00252930673503721, "phrase": "additional_instructions"}, {"score": 0.002473079487488344, "phrase": "slightly_modified_hardware"}, {"score": 0.002427177130359851, "phrase": "well-known_loop_unrolling_scheme"}, {"score": 0.002382124723569496, "phrase": "denser_code"}, {"score": 0.002320449502337321, "phrase": "substantial_code_size"}, {"score": 0.0022434880661725493, "phrase": "experiment_result"}, {"score": 0.0022101055924375725, "phrase": "loop_unrolling_technique"}, {"score": 0.002152874480615438, "phrase": "far_better_code"}, {"score": 0.0021049977753042253, "phrase": "quite_an_acceptable_amount"}], "paper_keywords": ["VLIW architecture", " reduced bit-width ISA", " Dynamic Implied Addressing Mode", " code size", " performance", " loop", " loop unrolling"], "paper_abstract": "Recent studies show that very long instruction word (VLIW) architectures, which inherently have wide datapath (e. g. 128 or 256 bits for one VLIW instruction word), can benefit from dynamic implied addressing mode (DIAM) and can achieve lower power consumption and smaller code size with a small performance overhead. Such overhead, which is claimed to be small, is mainly caused by the execution of additionally generated special instructions for conveying information that cannot be encoded in reduced instruction bit-width. In this paper, however, we show that the performance impact of applying DIAM on VLIW architecture cannot be overlooked expecially when applications possess high level of instruction level parallelism (ILP), which is mostly the case for loops because of the result of aggressive code scheduling. We also propose a way to relieve the performance degradation especially focusing on loops since loops spend almost 90% of total execution time in programs and tend to have high ILP. We first implement the original DIAM compilation technique in a compiler, and augment it with the proposed loop optimization scheme to show that ours can clearly alleviate the performance loss caused by the excessive number of additional instructions, with the help of slightly modified hardware. Moreover, the well-known loop unrolling scheme, which would produce denser code in loops at the cost of substantial code size bloating, is integrated into our compiler. The experiment result shows that the loop unrolling technique, combined with our augmented DIAM scheme, produces far better code in terms of performance with quite an acceptable amount of code increase.", "paper_title": "Improving Performance of Loops on DIAM-based VLIW Architectures", "paper_id": "WOS:000341937800016"}