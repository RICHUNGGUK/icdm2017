{"auto_keywords": [{"score": 0.04965333175972822, "phrase": "lockless_synchronization"}, {"score": 0.030242772158219394, "phrase": "algorithm_designers"}, {"score": 0.00481495049065317, "phrase": "memory_reclamation"}, {"score": 0.00470862827326028, "phrase": "high_performance"}, {"score": 0.004666756595735701, "phrase": "concurrent_applications"}, {"score": 0.004625255533545965, "phrase": "modem_multiprocessors"}, {"score": 0.004306205029641728, "phrase": "non-blocking_synchronization"}, {"score": 0.00419229472352669, "phrase": "priority_inversion"}, {"score": 0.0038855864345030563, "phrase": "memory_reclamation_scheme"}, {"score": 0.0036335821512795026, "phrase": "existing_memory_reclamation_schemes"}, {"score": 0.003474694300991964, "phrase": "first_fair_and_comprehensive_comparison"}, {"score": 0.003065698491529525, "phrase": "flexible_microbenchmark"}, {"score": 0.002957919048133256, "phrase": "globally_optimal_scheme"}, {"score": 0.002778317177178732, "phrase": "data_structure"}, {"score": 0.00269263690712392, "phrase": "execution_environment"}, {"score": 0.0025863375961196005, "phrase": "memory_reclamation_performance"}, {"score": 0.0023437863565921053, "phrase": "quiescent-state-based_reclamation"}, {"score": 0.002271476019266231, "phrase": "os_kernel"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["lockless", " non-blocking", " memory reclamation", " hazard pointers", " read-copy update", " synchronization", " concurrency", " performance"], "paper_abstract": "Achieving high performance for concurrent applications on modem multiprocessors remains challenging. Many programmers avoid locking to improve performance, while others replace locks with non-blocking synchronization to protect against deadlock, priority inversion, and convoying. In both cases, dynamic data structures that avoid locking require a memory reclamation scheme that reclaims elements once they are no longer in use. The performance of existing memory reclamation schemes has not been thoroughly evaluated. We conduct the first fair and comprehensive comparison of three recent schemes-quiescent-state-based reclamation, epoch-based reclamation, and hazard-pointer-based reclamation-using a flexible microbenchmark. Our results show that there is no globally optimal scheme. When evaluating lockless synchronization, programmers and algorithm designers should thus carefully consider the data structure, the workload, and the execution environment, each of which can dramatically affect the memory reclamation performance. We discuss the consequences of our results for programmers and algorithm designers. Finally, we describe the use of one scheme, quiescent-state-based reclamation, in the context of an OS kernel-an execution environment which is well suited to this scheme. (c) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Performance of memory reclamation for lockless synchronization", "paper_id": "WOS:000252040200005"}