{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "online_local_moments"}, {"score": 0.004733625412289433, "phrase": "dynamic_external_memory_arrays"}, {"score": 0.004201381218977942, "phrase": "first_n_local_moments"}, {"score": 0.004060566667226606, "phrase": "constant_n."}, {"score": 0.0037928847801943404, "phrase": "consecutive_ranges"}, {"score": 0.003512702405367876, "phrase": "local-moment_queries"}, {"score": 0.0033660587983313536, "phrase": "algebraic_queries"}, {"score": 0.0032810180076973806, "phrase": "n_buffers"}, {"score": 0.003117307618682836, "phrase": "time_complexity"}, {"score": 0.002886885861509621, "phrase": "hierarchical_buffering"}, {"score": 0.002790004829699627, "phrase": "logarithmic_time_complexity"}, {"score": 0.002561752783323717, "phrase": "n_hierarchical_buffers"}, {"score": 0.002178144355363467, "phrase": "wavelet-based_algorithms"}], "paper_keywords": ["Very large arrays", " hierarchical buffers", " statistical queries", " polynomial fitting"], "paper_abstract": "For a massive I/O array of size n, we want to compute the first N local moments, for some constant N. Our simpler algorithms partition the array into consecutive ranges called bins, and apply not only to local-moment queries, but also to algebraic queries. With N buffers of size v n, time complexity drops to O(root n). A more sophisticated approach uses hierarchical buffering and has a logarithmic time complexity (O(blog(b) n)), when using N hierarchical buffers of size n/b. Using overlapped bin buffering, we show that only one buffer is needed, as with wavelet-based algorithms, but using much less storage.", "paper_title": "Hierarchical Bin Buffering: Online Local Moments for Dynamic External Memory Arrays", "paper_id": "WOS:000265816600014"}