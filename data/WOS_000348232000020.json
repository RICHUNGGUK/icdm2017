{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "simd_width"}, {"score": 0.00655526574835185, "phrase": "power_consumption"}, {"score": 0.004654174363567422, "phrase": "control-flow_divergence"}, {"score": 0.0046079260641779755, "phrase": "prevalent_issue"}, {"score": 0.004567596860086148, "phrase": "current_and_future_computing_systems"}, {"score": 0.004376394990708817, "phrase": "larger_simd_widths"}, {"score": 0.004371160978838441, "phrase": "instruction_stream"}, {"score": 0.004220086640742953, "phrase": "multiple_data"}, {"score": 0.0035082436540296406, "phrase": "data-parallel_programs"}, {"score": 0.0034168317227203206, "phrase": "increasing_simd_width"}, {"score": 0.003284145698220425, "phrase": "memory-access_divergence"}, {"score": 0.002658562959236011, "phrase": "regrouping_techniques"}, {"score": 0.002381365139274329, "phrase": "scalar_execution"}], "paper_keywords": ["Languages", " Measurement", " Performance", " Data parallelism", " divergent control flow", " GPGPU", " memory access patterns", " OpenCL", " performance analysis", " SIMD", " vectorization"], "paper_abstract": "Power consumption is a prevalent issue in current and future computing systems. SIMD processors amortize the power consumption of managing the instruction stream by executing the same instruction in parallel on multiple data. Therefore, in the past years, the SIMD width has steadily increased, and it is not unlikely that it will continue to do so. In this article, we experimentally study the influence of the SIMD width to the execution of data-parallel programs. We investigate how an increasing SIMD width (up to 1024) influences control-flow divergence and memory-access divergence, and how well techniques to mitigate them will work on larger SIMD widths. We perform our study on 76 OpenCL applications and show that a group of programs scales well up to SIMD width 1024, whereas another group of programs increasingly suffers from control-flow divergence. For those programs, thread regrouping techniques may become increasingly important for larger SIMD widths. We show what average speedups can be expected when increasing the SIMD width. For example, when switching from scalar execution to SIMD width 64, one can expect a speedup of 60.11, which increases to 62.46 when using thread regrouping. We also analyze the frequency of regular (uniform, consecutive) memory access patterns and observe a monotonic decrease of regular memory accesses from 82.6% at SIMD width 4 to 43.1% at SIMD width 1024.", "paper_title": "The Impact of the SIMD Width on Control-Flow and Memory Divergence", "paper_id": "WOS:000348232000020"}