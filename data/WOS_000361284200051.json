{"auto_keywords": [{"score": 0.03171025198538442, "phrase": "self-optimizing_interpreters"}, {"score": 0.00481495049065317, "phrase": "runtime_metaprogramming"}, {"score": 0.004614483128885678, "phrase": "convenient_solution"}, {"score": 0.004449280529563265, "phrase": "generic_way"}, {"score": 0.0041112665381266315, "phrase": "domain-specific_languages"}, {"score": 0.004012500850311087, "phrase": "powerful_metaobject_protocols"}, {"score": 0.0038923605771735838, "phrase": "even_common_concepts"}, {"score": 0.003822003373331997, "phrase": "reflective_method_invocation"}, {"score": 0.003775803846431323, "phrase": "dynamic_proxies"}, {"score": 0.0035100601949451028, "phrase": "metaprogramming_capabilities"}, {"score": 0.0033230588808076267, "phrase": "performance_improving_techniques"}, {"score": 0.0032629585038738856, "phrase": "overhead-free_runtime_metaprogramming"}, {"score": 0.00316518932828897, "phrase": "dispatch_chains"}, {"score": 0.003051713660488494, "phrase": "polymorphic_inline_caches"}, {"score": 0.0029244418026475832, "phrase": "simple_optimization"}, {"score": 0.0028715299874549245, "phrase": "language-implementation_level"}, {"score": 0.002735052488172277, "phrase": "unrestricted_metaobject_protocols"}, {"score": 0.002636956926079255, "phrase": "first_time"}, {"score": 0.0026050445177883005, "phrase": "runtime_overhead"}, {"score": 0.002466139325703204, "phrase": "just-in-time_compilation"}, {"score": 0.0023346234464901978, "phrase": "partial_evaluation"}, {"score": 0.002183347623351868, "phrase": "common_reflective_operations"}, {"score": 0.0021307975800397816, "phrase": "significant_performance_improvements"}, {"score": 0.0021049977753042253, "phrase": "existing_applications"}], "paper_keywords": ["Metaprogramming", " Reflection", " Proxies", " Metaobject Protocols", " Meta-tracing", " Partial Evaluation", " Virtual Machines", " Just-in-Time Compilation"], "paper_abstract": "Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.", "paper_title": "Zero-Overhead Metaprogramming Reflection and Metaobject Protocols Fast and without Compromises", "paper_id": "WOS:000361284200051"}