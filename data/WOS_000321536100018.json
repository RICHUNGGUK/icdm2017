{"auto_keywords": [{"score": 0.032031782697215905, "phrase": "arv"}, {"score": 0.03178164007123485, "phrase": "ala"}, {"score": 0.008308942243310373, "phrase": "time-based_stms"}, {"score": 0.00481495049065317, "phrase": "software_transactional_memory"}, {"score": 0.004776297980616768, "phrase": "adaptive_read"}, {"score": 0.0045324756541157574, "phrase": "promising_paradigm"}, {"score": 0.004477992162329249, "phrase": "concurrent_programming"}, {"score": 0.004442032546224076, "phrase": "chip_multiprocessors"}, {"score": 0.00419823857480455, "phrase": "inconsistent_performance"}, {"score": 0.004164516065972361, "phrase": "different_design_decisions"}, {"score": 0.0040485975929323, "phrase": "different_circumstances"}, {"score": 0.0039677715255034595, "phrase": "large_margin"}, {"score": 0.0038417798012011155, "phrase": "transactional_read"}, {"score": 0.003734810936407523, "phrase": "existing_transactional_read"}, {"score": 0.003704797078215222, "phrase": "write_policies"}, {"score": 0.0036602262729063775, "phrase": "static_approach"}, {"score": 0.003501322813520807, "phrase": "single_universal_policy"}, {"score": 0.003473178781851477, "phrase": "optimal_performance"}, {"score": 0.0033764382987428497, "phrase": "adaptive_read_validation"}, {"score": 0.003308986613384597, "phrase": "adaptive_lock_acquisition"}, {"score": 0.0030523478413779686, "phrase": "workloads'_behavior"}, {"score": 0.0029792984108210525, "phrase": "history-based_techniques"}, {"score": 0.0029434299787644445, "phrase": "transaction's_behavior"}, {"score": 0.0026932247685847246, "phrase": "validation_and_lock_acquisition_policies"}, {"score": 0.0025866199378466754, "phrase": "different_phases"}, {"score": 0.0024345529783611703, "phrase": "application-specific_information"}, {"score": 0.002165388556451298, "phrase": "crown_copyright"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Transactional memory", " Read validation", " Lock acquisition", " Time-based transactional memory"], "paper_abstract": "Software transactional memory (STM) is a promising paradigm which simplifies concurrent programming for chip multiprocessors. Although the implementations of STMs are simple and efficient, they display inconsistent performance: different design decisions lead to systems performing best under different circumstances, often by a large margin. In this paper, we investigate transactional read and write policies in time-based STMs. Existing transactional read and write policies follow a static approach and use one policy across all applications. However, no single universal policy offers optimal performance across all applications. We propose adaptive read validation (ARV) and adaptive lock acquisition (ALA) policies for time-based STMs. Our solutions adjust transactional read and write policies dynamically and according to workloads' behavior. ARV and ALA are history-based techniques and exploit transaction's behavior in the past to adjust transactional read and write policies in the future. ARV and ALA not only vary read validation and lock acquisition policies across applications, but also adjust the two policies across different phases of an application. ARV and ALA are simple to implement, require no application-specific information, and are transparent to programmers. We evaluate our adaptive techniques using Stamp v0.9.10 benchmark suite. The evaluation reveals that ARV and ALA are highly effective and improve performance significantly. Crown Copyright (C) 2012 Published by Elsevier B.V. All rights reserved.", "paper_title": "ARV-ALA: Improving performance of software transactional memory through adaptive read and write policies", "paper_id": "WOS:000321536100018"}