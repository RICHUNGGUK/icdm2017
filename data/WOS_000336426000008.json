{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "multikey_quickselect"}, {"score": 0.0038758293658651237, "phrase": "selection_problem"}, {"score": 0.003531474887552889, "phrase": "uniform_model"}, {"score": 0.0032848684681050745, "phrase": "character_comparisons"}, {"score": 0.0032176163279340206, "phrase": "pointer_swaps"}, {"score": 0.0030554300179552415, "phrase": "alphabet_cardinality"}, {"score": 0.0027837615811247963, "phrase": "binary_variant"}, {"score": 0.0021049977753042253, "phrase": "multikey_quicksort"}], "paper_keywords": ["Selection", " Strings", " Analysis of algorithms", " Average-case", " Partition", " Divide-and-conquer"], "paper_abstract": "We present multikey quickselect: an efficient, in-place, easy-to-implement algorithm for the selection problem for strings. We analyze its expected cost under a uniform model, measured as the number of character comparisons and pointer swaps, depending on the alphabet cardinality. From the analysis, we derive a binary variant of the algorithm, which is more efficient when the range of values for the alphabet is known. This variant can also be applied to multikey quicksort.", "paper_title": "Multikey Quickselect", "paper_id": "WOS:000336426000008"}