{"auto_keywords": [{"score": 0.049352273134126406, "phrase": "lustre"}, {"score": 0.00481495049065317, "phrase": "scheduling_policies"}, {"score": 0.004778258911940497, "phrase": "safe_shared_memory"}, {"score": 0.0045464538515249085, "phrase": "complex_control_systems"}, {"score": 0.004409404470207072, "phrase": "typical_applications"}, {"score": 0.004375789703278455, "phrase": "different_control_laws"}, {"score": 0.0043258453436258405, "phrase": "different_phases"}, {"score": 0.004084510791138056, "phrase": "fly-by-wire_control_system"}, {"score": 0.003991774582021095, "phrase": "existing_methods"}, {"score": 0.0038713805573219297, "phrase": "powerful_but_unsafe_mechanisms"}, {"score": 0.0038125469099459905, "phrase": "imperative_updates"}, {"score": 0.0037834649508375544, "phrase": "shared_variables"}, {"score": 0.003697538418750941, "phrase": "synchronous_languages"}, {"score": 0.0036274223080131583, "phrase": "esterel"}, {"score": 0.003372844338742438, "phrase": "particular_control_automaton"}, {"score": 0.0032585499655442404, "phrase": "conservative_extension"}, {"score": 0.003221316290858497, "phrase": "synchronous_data-flow_language"}, {"score": 0.002731971103291716, "phrase": "shared_memory"}, {"score": 0.0026494723416072316, "phrase": "scheduling_policy"}, {"score": 0.002530359917257626, "phrase": "valid_synchronous_reaction"}, {"score": 0.002444544487772349, "phrase": "proper_use"}, {"score": 0.0023798115577749225, "phrase": "type_inference_problem"}, {"score": 0.002361632539339945, "phrase": "row_types"}, {"score": 0.0023346300510830643, "phrase": "wand"}, {"score": 0.002316789156496971, "phrase": "remy"}, {"score": 0.0022990901047984197, "phrase": "vouillon"}, {"score": 0.0022296340517805125, "phrase": "extended_synchronous_language"}, {"score": 0.0022041312401435346, "phrase": "type_system"}, {"score": 0.0021789194955896102, "phrase": "proposed_extension"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Verification", " Real-time systems", " Synchronous languages", " Block-diagrams", " Compilation", " Semantics", " Type systems"], "paper_abstract": "This paper addresses the problem of designing and implementing complex control systems for real-time embedded software. Typical applications involve different control laws corresponding to different phases or modes, e. g., take-off, full flight and landing in a fly-by-wire control system. On one hand, existing methods such as the combination of Simulink/Stateflow provide powerful but unsafe mechanisms by means of imperative updates of shared variables. On the other hand, synchronous languages and tools such as Esterel or SCADE/Lustre are too restrictive and forbid to fully separate the specification of modes from their actual instantiation with a particular control automaton. In this paper, we introduce a conservative extension of a synchronous data-flow language close to Lustre, in order to be able to define systems with modes in a more modular way, while insuring the absence of data-races. We show that such a system can be viewed as an object where modes are methods acting on a shared memory. The object is associated to a scheduling policy which specifies the ways methods can be called to build a valid synchronous reaction. We show that the verification of the proper use of an object reduces to a type inference problem using row types introduced by Wand, Remy and Vouillon. We define the semantics of the extended synchronous language and the type system. The proposed extension has been implemented and we illustrate its use through several examples.", "paper_title": "Synchronous Objects with Scheduling Policies Introducing safe shared memory in Lustre", "paper_id": "WOS:000268471100003"}