{"auto_keywords": [{"score": 0.004714023408114857, "phrase": "synthesis_techniques"}, {"score": 0.0046544807197808095, "phrase": "existing_fault-intolerant_real-time_programs"}, {"score": 0.0044237033788643715, "phrase": "fault-tolerant_program"}, {"score": 0.004258128672571261, "phrase": "timing_constraints"}, {"score": 0.0038461532860146535, "phrase": "program's_normal_behavior"}, {"score": 0.0033295966773779174, "phrase": "simplest_case"}, {"score": 0.00327356326590461, "phrase": "first_phase"}, {"score": 0.0031912706211861324, "phrase": "acceptable_behavior"}, {"score": 0.003150900886669123, "phrase": "time_theta"}, {"score": 0.003071682293903262, "phrase": "second_phase"}, {"score": 0.002994449398035894, "phrase": "ideal_behavior"}, {"score": 0.0029691377785333872, "phrase": "time_delta"}, {"score": 0.0026363807171515255, "phrase": "real-time_fault-tolerant_program"}, {"score": 0.0024320326084093465, "phrase": "automated_synthesis"}, {"score": 0.002215081186105616, "phrase": "sound_and_complete_synthesis_algorithm"}, {"score": 0.0021049977753042253, "phrase": "highly_complex_decision_procedures"}], "paper_keywords": ["Fault-tolerance", " Real-time", " Bounded-time recovery", " Phased recovery", " Program synthesis", " Program transformation"], "paper_abstract": "We focus on synthesis techniques for transforming existing fault-intolerant real-time programs into fault-tolerant programs that provide phased recovery. A fault-tolerant program is one that satisfies its safety and liveness specifications as well as timing constraints in the presence of faults. We argue that in many commonly considered programs (especially in safety/mission-critical systems), when faults occur, simple recovery to the program's normal behavior is necessary, but not sufficient. For such programs, it is necessary that recovery is accomplished in a sequence of phases, each ensuring that the program satisfies certain properties. In the simplest case, in the first phase the program recovers to an acceptable behavior within some time theta, and, in the second phase, it recovers to the ideal behavior within time delta. In this article, we introduce four different types of bounded-time 2-phase recovery, namely ordered-strict, strict, relaxed, and graceful, based on how a real-time fault-tolerant program reaches the acceptable and ideal behaviors in the presence of faults. We rigorously analyze the complexity of automated synthesis of each type: we either show that the problem is hard in some class of complexity or we present a sound and complete synthesis algorithm. We argue that such complexity analysis is essential to deal with the highly complex decision procedures of program synthesis.", "paper_title": "Synthesizing bounded-time 2-phase fault recovery", "paper_id": "WOS:000347157300001"}