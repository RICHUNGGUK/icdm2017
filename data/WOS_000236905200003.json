{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "type_system"}, {"score": 0.004720419202969916, "phrase": "compile-time_analysis"}, {"score": 0.004658426838467567, "phrase": "heap-space_requirements"}, {"score": 0.004597244847332915, "phrase": "java_style_object-oriented_programs"}, {"score": 0.004303127794432684, "phrase": "amortised_complexity_analysis"}, {"score": 0.0034363735647539267, "phrase": "upper_bound"}, {"score": 0.003368816076401138, "phrase": "heap_space_usage"}, {"score": 0.0029706504420983896, "phrase": "example_applications"}, {"score": 0.0028739078688746374, "phrase": "destination-passing_style"}, {"score": 0.0028360962841331634, "phrase": "doubly-linked_lists"}, {"score": 0.0024192592458651204, "phrase": "abstract_elides"}, {"score": 0.0022196020509093694, "phrase": "space_limitations"}, {"score": 0.002175913488493802, "phrase": "full_version"}, {"score": 0.0021049977753042253, "phrase": "authors'_web_pages"}], "paper_keywords": [""], "paper_abstract": "We present a type system for a compile-time analysis of heap-space requirements of Java style object-oriented programs with explicit deallocation. Our system is based on an amortised complexity analysis: the data is arbitrarily assigned a potential related to its size and layout; allocations must be \"payed for\" from this potential. The potential of each input then furnishes an upper bound on the heap space usage for the computation on this input. We successfully treat inheritance, downcast, update and aliasing. Example applications for the analysis include destination-passing style and doubly-linked lists. Type inference is explicitly not included; the contribution lies in the system itself and the nontrivial soundness theorem. This extended abstract elides most technical lemmas and proofs, even nontrivial ones, due to space limitations. A full version is available at the authors' web pages.", "paper_title": "Type-based arnortised heap-space analysis", "paper_id": "WOS:000236905200003"}