{"auto_keywords": [{"score": 0.045171522171843934, "phrase": "redundant_mutants"}, {"score": 0.00481495049065317, "phrase": "non-redundant_mutation_operators"}, {"score": 0.004686963264680882, "phrase": "powerful_but_computationally_expensive_method"}, {"score": 0.004541918674719973, "phrase": "testing_or_debugging_technique"}, {"score": 0.004481132747216135, "phrase": "high_cost"}, {"score": 0.0042650992966174065, "phrase": "commonly_used_mutation_operators"}, {"score": 0.0035156341294017685, "phrase": "skewed_mutant_detection_rate"}, {"score": 0.0033914308417007316, "phrase": "assessed_testing"}, {"score": 0.003361069456060196, "phrase": "debugging_technique"}, {"score": 0.0032863459256972896, "phrase": "previous_work"}, {"score": 0.003113696267229798, "phrase": "non-redundant_versions"}, {"score": 0.003071965703296204, "phrase": "conditional_operator_replacement"}, {"score": 0.003044455555031339, "phrase": "unary_operator_insertion"}, {"score": 0.0030036501770192865, "phrase": "relational_operator_replacement_mutation_operators"}, {"score": 0.002897482096228207, "phrase": "conducted_empirical_study"}, {"score": 0.0027328817607818207, "phrase": "empirical_study"}, {"score": 0.0026481480455339055, "phrase": "test_suites"}, {"score": 0.0024421008630165046, "phrase": "mutation_analysis"}, {"score": 0.0023770362063833903, "phrase": "total_mutation_analysis_run_time"}, {"score": 0.0022019274077124795, "phrase": "overestimated_mutation_score"}, {"score": 0.0021723899772112423, "phrase": "analysed_test_suites"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["mutation analysis", " redundant mutants", " test adequacy", " code coverage"], "paper_abstract": "Mutation analysis is a powerful but computationally expensive method to measure the effectiveness of a testing or debugging technique. The high cost is due, in part, to redundant mutants generated by commonly used mutation operators. A mutant is said to be redundant if its outcome can be predicted based on the outcome of other mutants. The execution of those redundant mutants is unnecessary and wastes CPU resources. Moreover, the inclusion of redundant mutants may lead to a skewed mutant detection rate and therefore misrepresent the effectiveness of the assessed testing or debugging technique. This paper extends previous work and makes the following contributions. First, it defines and provides non-redundant versions of the conditional operator replacement, unary operator insertion, and relational operator replacement mutation operators. Second, it reports on a conducted empirical study using 10 real-world programmes that comprise a total of 410000 lines of code. The empirical study used developer-written and generated test suites. The results show how prevalent redundant mutants are and how their elimination improves the efficiency and accuracy of mutation analysis. In summary, the total mutation analysis run time decreased by more than 20% by removing redundant mutants, and the inclusion of redundant mutants led to an overestimated mutation score for all analysed test suites. Copyright (C) 2014 John Wiley & Sons, Ltd.", "paper_title": "Higher accuracy and lower run time: efficient mutation analysis using non-redundant mutation operators", "paper_id": "WOS:000359764600003"}