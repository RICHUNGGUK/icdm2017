{"auto_keywords": [{"score": 0.044610447192194966, "phrase": "systemc"}, {"score": 0.00481495049065317, "phrase": "platform_verification"}, {"score": 0.004700027722284931, "phrase": "modern_hardware_design"}, {"score": 0.00456571874088313, "phrase": "higher_levels"}, {"score": 0.004456717971917794, "phrase": "system_modeling"}, {"score": 0.0037811784409635023, "phrase": "early_design_space_exploration"}, {"score": 0.0035679633126097115, "phrase": "systemc_models"}, {"score": 0.0034826993555190765, "phrase": "introspection_technique"}, {"score": 0.0034325187732054093, "phrase": "computational_reflection"}, {"score": 0.0033021988455635403, "phrase": "white-box_introspection_mechanism"}, {"score": 0.0031922210879462513, "phrase": "reflexbox"}, {"score": 0.002954361295811154, "phrase": "systemc_module"}, {"score": 0.0028421434495262796, "phrase": "proprietary_systemc_implementation"}, {"score": 0.0027876387169652717, "phrase": "systemc_library"}, {"score": 0.00269475174341129, "phrase": "module_source_code"}, {"score": 0.002530359917257626, "phrase": "performance_evaluation"}, {"score": 0.0025059724686541263, "phrase": "communication_analysis"}, {"score": 0.0024578987081792405, "phrase": "reflexbox_effectiveness"}, {"score": 0.0023417010799384524, "phrase": "register_inspection"}, {"score": 0.002319127685733821, "phrase": "performance_analysis"}, {"score": 0.002263639474937039, "phrase": "testbench_reuse"}, {"score": 0.002177600561610171, "phrase": "source_code_availability"}, {"score": 0.0021049977753042253, "phrase": "overall_platform_performance"}], "paper_keywords": ["Platform-based design", " Debugging", " Computational reflection", " System architecture"], "paper_abstract": "The complexity of modern hardware design has created the need for higher levels of abstraction, where system modeling is used to integrate modules into complex System-on-Chip (SoCs) platforms. SystemC, and its TLM (Transaction Level Modeling) extensions, have been used for this purpose mainly because of their fast prototyping and simulation features, which allow for early design space exploration. This paper proposes an approach to explore and interact with SystemC models by means of an introspection technique known as Computational Reflection. We use reflection to implement a white-box introspection mechanism called ReflexBox. We show that ReflexBox is a fast, non-intrusive technique that can be used to dynamically gather and inject stimuli into any SystemC module, without the need to use a proprietary SystemC implementation, change the SystemC library, instrument or even inspect the module source code. Our approach can be used to support many different verification tasks like platform debugging, performance evaluation and communication analysis. To show ReflexBox effectiveness we used it in three platforms case studies to address tasks like register inspection, performance analysis and signal replaying for testbench reuse. In all cases we assumed no source code availability and measured the impact on the overall platform performance.", "paper_title": "Computational reflection and its application to platform verification", "paper_id": "WOS:000304107700001"}