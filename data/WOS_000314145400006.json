{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "pipelining"}, {"score": 0.0046432244185370605, "phrase": "system_performance"}, {"score": 0.00460125407969429, "phrase": "overlapping_executions"}, {"score": 0.004559661374976129, "phrase": "hardware_or_software_computing_stages"}, {"score": 0.004477595431209663, "phrase": "direct_pipelining"}, {"score": 0.004357245559948974, "phrase": "video_bitstreams"}, {"score": 0.0040334640350288, "phrase": "pure_software_pipelining"}, {"score": 0.003871869188502677, "phrase": "macroblock_level"}, {"score": 0.0038368442918503072, "phrase": "reasonable_performance_gain"}, {"score": 0.0037506567448470163, "phrase": "pipeline_stages"}, {"score": 0.0035515951985356374, "phrase": "extra_overhead"}, {"score": 0.003503497128638099, "phrase": "optimized_decoders"}, {"score": 0.0033630629374009576, "phrase": "software_pipelining"}, {"score": 0.00330246222643051, "phrase": "negative_performance_gain"}, {"score": 0.0032282396745967504, "phrase": "multiple_stages"}, {"score": 0.0031990183472675377, "phrase": "larger_batches"}, {"score": 0.00297454367746853, "phrase": "multicore_systems"}, {"score": 0.002947611960613497, "phrase": "experimental_results"}, {"score": 0.0023372808856170386, "phrase": "next-generation_video_coding"}, {"score": 0.002213065910356615, "phrase": "batch-pipelining_mechanism"}, {"score": 0.0021830553825770097, "phrase": "new_effective_direction"}, {"score": 0.0021632743048552554, "phrase": "software_codec_development"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Parallelization", " Pipelining", " Batch", " H.264", " HEVC", " Multicore", " Synchronization", " Optimization"], "paper_abstract": "Pipelining has been applied in many area to improve system performance by overlapping executions of hardware or software computing stages. However, direct pipelining for H.264 decoding is difficult because video bitstreams are encoded with lots of dependencies and little parallelism is left to be explored. Fortunately, pure software pipelining can still be applied to H.264 decoding at macroblock level with reasonable performance gain. However, the pipeline stages might need to synchronize with each other and incur lots of extra overhead. For optimized decoders, the overhead is relatively more significant and software pipelining might lead to negative performance gain. We first group multiple stages into larger batches and execute these batches concurrently, called batch-pipelining, to explore more parallelism on multicore systems. Experimental results show that it can speed the decoding up to 89% and achieve up to 259 and 69 frames per second for resolution 720P and 1080P, respectively, on a 4-core x86 machine over an optimized H.264 decoder. Because of its flexibility, batch-pipelining can be applied to not only H.264 but also many similar applications, such as the next-generation video coding: high efficiency video coding. Therefore, we believe the batch-pipelining mechanism creates a new effective direction for software codec development. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "Batch-pipelining for multicore H.264 decoding", "paper_id": "WOS:000314145400006"}