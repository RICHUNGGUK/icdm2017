{"auto_keywords": [{"score": 0.04915098975480121, "phrase": "resource_consumption"}, {"score": 0.011659181191653467, "phrase": "core_logic"}, {"score": 0.00481495049065317, "phrase": "reasoning_infrastructure"}, {"score": 0.004611959213131437, "phrase": "java_virtual_machine_language"}, {"score": 0.004417487764326481, "phrase": "small_hierarchy"}, {"score": 0.004383016741930174, "phrase": "program_logics"}, {"score": 0.004331811712726697, "phrase": "increasing_levels"}, {"score": 0.0041653916552844535, "phrase": "type_system"}, {"score": 0.0041167185402778425, "phrase": "high-level_language"}, {"score": 0.0038969619124903884, "phrase": "proof-carrying_code"}, {"score": 0.003866549297804648, "phrase": "pcc"}, {"score": 0.0037915057447460133, "phrase": "mobile_programs"}, {"score": 0.003717925116469845, "phrase": "formal_evidence"}, {"score": 0.0036600862989330106, "phrase": "predictable_resource_behaviour"}, {"score": 0.0034107088717109857, "phrase": "partial_correctness"}, {"score": 0.0032924448113309797, "phrase": "functional_behaviour"}, {"score": 0.003228517923065361, "phrase": "important_results"}, {"score": 0.0030680392468327147, "phrase": "resource-aware_operational_semantics"}, {"score": 0.0030321497870310077, "phrase": "jvml."}, {"score": 0.002973261772253616, "phrase": "second_logic"}, {"score": 0.0026535183547537655, "phrase": "high-level_language_type_systems"}, {"score": 0.0025614418906438744, "phrase": "entire_infrastructure"}, {"score": 0.0023773911659018825, "phrase": "prototype_implementation"}, {"score": 0.00235880210585049, "phrase": "pcc."}, {"score": 0.002223927963267319, "phrase": "resource_bounds"}, {"score": 0.0021721582450016, "phrase": "high-level_functional_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["program logic", " proof-carrying-code", " object-oriented languages", " Java virtual machine language", " cost modelling", " quantitative typesystems", " lightweight verification"], "paper_abstract": "We introduce a reasoning infrastructure for proving statements about resource consumption in a fragment of the Java Virtual Machine Language (JVML). The infrastructure is based on a small hierarchy of program logics, with increasing levels of abstraction: at the top there is a type system for a high-level language that encodes resource consumption. The infrastructure is designed to be used in a proof-carrying code (PCC) scenario, where mobile programs can be equipped with formal evidence that they have predictable resource behaviour. This article focuses on the core logic in our infrastructure, a VDM-style program logic for partial correctness, which can make statements about resource consumption alongside functional behaviour. We establish some important results for this logic, including soundness and completeness with respect to a resource-aware operational semantics for the JVML. We also present a second logic built on top of the core logic, which is used to express termination; it too is shown to be sound and complete. We then outline how high-level language type systems may be connected to these logics. The entire infrastructure has been formalized in Isabelle/HOL, both to enhance the confidence in our meta-theoretical results, and to provide a prototype implementation for PCC. We give examples to show the usefulness of this approach, including proofs of resource bounds on code resulting from compiling high-level functional programs. (c) 2007 Published by Elsevier B.V.", "paper_title": "A program logic for resources", "paper_id": "WOS:000251629200003"}