{"auto_keywords": [{"score": 0.03929351710815938, "phrase": "fable"}, {"score": 0.02664820811074127, "phrase": "johnson"}, {"score": 0.00481495049065317, "phrase": "large_assembly_lines"}, {"score": 0.004791400910568939, "phrase": "updating_johnson's"}, {"score": 0.00470987645199336, "phrase": "roger_johnson"}, {"score": 0.004641098123285973, "phrase": "optimally_balancing_large_assembly_lines_with_fable"}, {"score": 0.0044844784352041835, "phrase": "fable_algorithm"}, {"score": 0.004290817978172869, "phrase": "good_solutions"}, {"score": 0.004176592996088243, "phrase": "good_solution"}, {"score": 0.004085392297873218, "phrase": "verifiable_optimal_solution"}, {"score": 0.003996175079854025, "phrase": "small_and_predictable_amount"}, {"score": 0.003340682007472679, "phrase": "original_fable_algorithm"}, {"score": 0.0031962573658912796, "phrase": "resulting_algorithm"}, {"score": 0.003095837423068241, "phrase": "current_best_algorithms"}, {"score": 0.002645497508810706, "phrase": "c_programming_language"}, {"score": 0.002626070787915654, "phrase": "first_improvement"}, {"score": 0.0025812933071991825, "phrase": "solution_space"}, {"score": 0.00254977641182853, "phrase": "second_improvement"}, {"score": 0.0025372773909061717, "phrase": "large_parts"}, {"score": 0.002518643357539004, "phrase": "branch-and-bound_tree"}, {"score": 0.002469688222667711, "phrase": "fortran"}, {"score": 0.0023685748500162276, "phrase": "computer_memory"}, {"score": 0.00224391225822467, "phrase": "small_average_number"}, {"score": 0.0021573807590576336, "phrase": "research_area"}], "paper_keywords": ["line balancing", " Fable", " branch-and-bound"], "paper_abstract": "In 1988 Roger Johnson published a paper entitled \"Optimally Balancing Large Assembly Lines with Fable\" describing a depth-first, branch-and-bound algorithm for solving the type-1 line balancing problem. The Fable algorithm sought to achieve three goals. 1) The algorithm could be a heuristic that would quickly find good solutions to instances containing 1000 or more tasks. 2) After finding a good solution the algorithm could continue until it found a verifiable optimal solution. 3) The algorithm would require a small and predictable amount of computer memory. Fable did remarkably well at achieving goals. 1 and 3 and reasonably well at achieving goal 2. Though unstated, Fable achieved another goal. It was easy to understand and easy to program. Over the years researchers have proposed alternatives and improvements aimed at doing better at goal 2. The objective of this paper is to apply the best of these improvements to the original Fable algorithm to see what progress has been made in 15 years and where work is still needed. The resulting algorithm is called Fable 2003 and it seems to perform as well as the current best algorithms in the literature. The range of instances solved by Fable 2003 is significantly, larger than what Johnson's [ 1988] Fable was able to solve. This is due primarily to three groups of improvements: 1) Changing direction, task priorities, and running more than 1 trial per instance; 2) The Nourie-Venta list and other fathoming methods; and 3) The C programming language. The first improvement ensures that the most promising parts of the solution space are searched. The second improvement fathoms large parts of the branch-and-bound tree. Johnson's Fable was written in Fortran. Fable 2003 is written in C and so can use pointers to make more effective use of computer memory. One group of instances is difficult for Fable 2003 and the best algorithms in the literature. These are instances having a small average number of tasks per station, say three or fewer. Solving these instances is the research area where work is needed most. This is the same area that Johnson identified 15 years ago.", "paper_title": "Optimally balancing large assembly lines: Updating Johnson's 1988 Fable algorithm", "paper_id": "WOS:000239934600003"}