{"auto_keywords": [{"score": 0.04751922773044916, "phrase": "modal_mu-calculus"}, {"score": 0.032342749358323236, "phrase": "pushdown_models"}, {"score": 0.03092044901115448, "phrase": "vp-mu"}, {"score": 0.00481495049065317, "phrase": "new_fixpoint_modal_logic"}, {"score": 0.0044536312768349, "phrase": "execution_trees"}, {"score": 0.004427966503146096, "phrase": "structured_programs"}, {"score": 0.004277040831984646, "phrase": "new_logic"}, {"score": 0.004240116703465252, "phrase": "pushdown_specifications"}, {"score": 0.004083745587982289, "phrase": "recent_work"}, {"score": 0.004060203647513207, "phrase": "visibly_pushdown_languages"}, {"score": 0.0037880260900233064, "phrase": "program_specifications"}, {"score": 0.003755307753574745, "phrase": "computing_combinations"}, {"score": 0.0037336520904376687, "phrase": "local_and_global_program_flows"}, {"score": 0.0036588323994343045, "phrase": "security_properties"}, {"score": 0.0036272258853286433, "phrase": "context_stack"}, {"score": 0.0035958914160284985, "phrase": "interprocedural_dataflow_analysis_properties"}, {"score": 0.0035340293330075483, "phrase": "flow-sensitive_and_interprocedural_analysis"}, {"score": 0.003453193151234472, "phrase": "skipping_procedure"}, {"score": 0.0034134687245359376, "phrase": "local_flows"}, {"score": 0.0031845067058084613, "phrase": "first-class_objects"}, {"score": 0.003156984631072011, "phrase": "appropriate_constructs"}, {"score": 0.003138768436081888, "phrase": "concatenating_summaries"}, {"score": 0.0029967610945411593, "phrase": "main_result"}, {"score": 0.002936664639276662, "phrase": "model-checking_problem"}, {"score": 0.0028037753646260937, "phrase": "weaker_logics"}, {"score": 0.00277953789177136, "phrase": "ctl."}, {"score": 0.0027395968397212053, "phrase": "expressive_power"}, {"score": 0.0027159094186967247, "phrase": "logic_vp-mu"}, {"score": 0.002623184850933423, "phrase": "corresponding_pushdown_temporal_logic"}, {"score": 0.0025117070259621376, "phrase": "classical_mu-calculus"}, {"score": 0.0022630864103570913, "phrase": "ctl"}, {"score": 0.002249996040468422, "phrase": "caret"}, {"score": 0.0021731423856364003, "phrase": "monadic_second-order_logic"}, {"score": 0.0021049993427773527, "phrase": "vpa"}], "paper_keywords": ["algorithms", " theory", " verification", " logic", " specification", " verification", " mu-calculus", " infinite-state", " model-checking", " games", " pushdown systems"], "paper_abstract": "We define a new fixpoint modal logic, the visibly pushdown mu-calculus (VP-mu), as an extension of the modal mu-calculus. The models of this logic are execution trees of structured programs where the procedure calls and returns are made visible. This new logic can express pushdown specifications on the model that its classical counterpart cannot, and is motivated by recent work on visibly pushdown languages [4]. We show that our logic naturally captures several interesting program specifications in program verification and dataflow analysis. This includes a variety of program specifications such as computing combinations of local and global program flows, pre/post conditions of procedures, security properties involving the context stack, and interprocedural dataflow analysis properties. The logic can capture flow-sensitive and interprocedural analysis, and it has constructs that allow skipping procedure calls so that local flows in a procedure can also be tracked. The logic generalizes the semantics of the modal mu-calculus by considering summaries instead of nodes as first-class objects, with appropriate constructs for concatenating summaries, and naturally captures the way in which pushdown models are model-checked. The main result of the paper is that the model-checking problem for VP-mu, is effectively solvable against pushdown models with no more effort than that required for weaker logics such as CTL. We also investigate the expressive power of the logic VP-mu: we show that it encompasses all properties expressed by a corresponding pushdown temporal logic on linear structures (CARET [2]) as well as by the classical mu-calculus. This makes VP-mu the most expressive known program logic for which algorithmic software model checking is feasible. In fact, the decidability of most known program logics (mu-calculus, temporal logics LTL and CTL, CARET, etc.) can be understood by their interpretation in the monadic second-order logic over trees. This is not true for the logic VPA, making it a new powerful tractable program logic.", "paper_title": "A fixpoint calculus for local and global program flows", "paper_id": "WOS:000235615800015"}