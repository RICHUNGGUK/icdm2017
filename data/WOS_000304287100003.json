{"auto_keywords": [{"score": 0.035533772426587416, "phrase": "execution_time"}, {"score": 0.024756821463281675, "phrase": "parallel_applications"}, {"score": 0.00481495049065317, "phrase": "chip-multiprocessor_systems"}, {"score": 0.004714023408114857, "phrase": "chip_multiprocessor_systems"}, {"score": 0.004566567411073082, "phrase": "new_generation"}, {"score": 0.004255121395629569, "phrase": "good_cmp_utilization"}, {"score": 0.004007083686875716, "phrase": "cmp_system"}, {"score": 0.003578600071301459, "phrase": "different_applications"}, {"score": 0.0035408501923902477, "phrase": "first_model"}, {"score": 0.003346119094502001, "phrase": "network_latency"}, {"score": 0.003287482882222731, "phrase": "vcs_results"}, {"score": 0.003241312187060814, "phrase": "power_overhead"}, {"score": 0.003150900886669123, "phrase": "buffer_implementation"}, {"score": 0.0030847461428168614, "phrase": "second_model"}, {"score": 0.0029565620771207003, "phrase": "space_partitioning"}, {"score": 0.0029253546782349875, "phrase": "cmp_chip"}, {"score": 0.002863921785266393, "phrase": "last_model"}, {"score": 0.0028437313714204087, "phrase": "virtual-regions"}, {"score": 0.002764379205581817, "phrase": "reconfiguration_algorithm"}, {"score": 0.002658863179011018, "phrase": "network_partitions"}, {"score": 0.002603012037901889, "phrase": "application_requirements"}, {"score": 0.002357457094026928, "phrase": "average_improvements"}, {"score": 0.0022835460368487233, "phrase": "baseline_scenario"}, {"score": 0.002219790619936024, "phrase": "vcs_implementation"}, {"score": 0.002180848602315088, "phrase": "average_execution_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Chip Multiprocessor", " Network-on-Chip", " Virtualization"], "paper_abstract": "It is expected that Chip Multiprocessor Systems (CMPs) will contain more and more cores in every new generation. However, applications for these systems do not scale at the same pace. In order to obtain a good CMP utilization several applications will need to coexist in the system and in those cases virtualization of the CMP system will become mandatory. In this paper we analyze two virtualization strategies at NoC-level aiming to isolate the traffic generated by each application to reduce or even eliminate interferences among messages belonging to different applications. The first model handles most interferences among messages with a virtual-channels (VCs) implementation reducing both execution time and network latency. However, using VCs results in area and power overhead due to the cost of control and buffer implementation. In contrast, the second model is based on the resource partitioning strategies which results in a space partitioning of the CMP chip in several regions. For this last model, Virtual-Regions (VR), we use a reconfiguration algorithm of the network that is able to dynamically adapt the network partitions in order to satisfy the application requirements. The paper shows a comparison of both models and identifies their main advantages and disadvantages. From our experimental results, we show that our proposal obtains in terms of execution time average improvements of 30% for parallel applications when compared to a baseline scenario. Moreover, when compared to a VCs implementation, our proposal improves the average execution time by 9% for parallel applications. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Network-on-Chip virtualization in Chip-Multiprocessor Systems", "paper_id": "WOS:000304287100003"}