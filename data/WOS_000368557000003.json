{"auto_keywords": [{"score": 0.049710559403496724, "phrase": "circuit_parallelism"}, {"score": 0.04793423660529138, "phrase": "space_complexity"}, {"score": 0.042646818425399066, "phrase": "functional_arrays"}, {"score": 0.037094845215981595, "phrase": "ram"}, {"score": 0.00481495049065317, "phrase": "sparse_functional_arrays"}, {"score": 0.004724158990345732, "phrase": "longstanding_open_question"}, {"score": 0.004688321299229397, "phrase": "algorithms_and_data_structures"}, {"score": 0.004565007074039171, "phrase": "pure_functional_arrays"}, {"score": 0.004530371221172796, "phrase": "imperative_arrays"}, {"score": 0.004394424341776717, "phrase": "constant_time"}, {"score": 0.0041662189933067, "phrase": "ram_algorithm"}, {"score": 0.0039049226745413224, "phrase": "main_result"}, {"score": 0.0037589124802364384, "phrase": "optimal_unit_time"}, {"score": 0.0034303002275695446, "phrase": "massive_parallelism"}, {"score": 0.003391290302481397, "phrase": "digital_circuits"}, {"score": 0.003314591878914152, "phrase": "unit_time_operations"}, {"score": 0.003276893480994257, "phrase": "storage_management"}, {"score": 0.0032150101448578734, "phrase": "sparse_and_extensible_arrays"}, {"score": 0.0031784407245606704, "phrase": "main_idea"}, {"score": 0.0030829367866722825, "phrase": "ram_memory"}, {"score": 0.003047865053078826, "phrase": "tree_circuit"}, {"score": 0.002718301574682098, "phrase": "array_representation"}, {"score": 0.0024899186481178075, "phrase": "large_numbers"}, {"score": 0.0023966900120342364, "phrase": "key_algorithms"}, {"score": 0.0023784664152543718, "phrase": "extensible_sparse_functional_arrays"}, {"score": 0.0022981559278396845, "phrase": "functional_and_imperative_programming_languages"}, {"score": 0.002203663884543687, "phrase": "circuit_specification"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Functional array", " Sparse array", " Extensible array", " Functional programming", " Circuit parallelism"], "paper_abstract": "A longstanding open question in algorithms and data structures is the time and space complexity of pure functional arrays. Imperative arrays provide update and lookup operations that require constant time in the Random Access Machine (RAM) theoretical model, but it is conjectured that there does not exist a RAM algorithm that achieves the same complexity for functional arrays, unless restrictions are placed on the operations. The main result of this paper is an algorithm that does achieve optimal unit time and space complexity for update and lookup on functional arrays. This algorithm does not run on a RAM, but instead it exploits the massive parallelism inherent in digital circuits. The algorithm also provides unit time operations that support storage management, as well as sparse and extensible arrays. The main idea behind the algorithm is to replace a RAM memory by a tree circuit that is more powerful than the RAM yet has the same asymptotic complexity in time (gate delays) and size (number of components). The algorithm uses an array representation that allows elements to be shared between many arrays with only a small constant factor penalty in space and time. This system exemplifies circuit parallelism, which exploits large numbers of transistors per chip in order to speed up key algorithms. Extensible Sparse Functional Arrays (ESFA) can be used with both functional and imperative programming languages. The system comprises a set of algorithms and a circuit specification, and it has been implemented on a GPGPU. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Extensible sparse functional arrays with circuit parallelism", "paper_id": "WOS:000368557000003"}