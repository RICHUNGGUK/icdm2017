{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "efficient_execution_of_recursive_programs"}, {"score": 0.004753670676591174, "phrase": "commodity_vector_hardware"}, {"score": 0.0046038458731764926, "phrase": "computational_efficiency"}, {"score": 0.004401955895933783, "phrase": "throughput-oriented_hardware"}, {"score": 0.004263168852219819, "phrase": "increasingly_wide_vector_units"}, {"score": 0.0038973170902076707, "phrase": "data-parallel_computations"}, {"score": 0.0038230844545071303, "phrase": "vectorized_manner"}, {"score": 0.003194736764837261, "phrase": "throughput-oriented_architectures"}, {"score": 0.003034916887102753, "phrase": "novel_code_transformations"}, {"score": 0.002958021635132416, "phrase": "data_parallelism"}, {"score": 0.0027212777001495176, "phrase": "straightforward_vectorization"}, {"score": 0.0026865721000905235, "phrase": "task-parallel_programs"}, {"score": 0.0025521085778978042, "phrase": "scheduling_policies"}, {"score": 0.0025034338848015166, "phrase": "high_utilization"}, {"score": 0.0024714996534331668, "phrase": "vector_resources"}, {"score": 0.0024243586247372087, "phrase": "space_usage"}, {"score": 0.0023029886389559122, "phrase": "efficient_vector_resource_utilization"}], "paper_keywords": ["Algorithms", " Performance", " Recursive Programs", " Task Parallelism", " Vectorization"], "paper_abstract": "The pursuit of computational efficiency has led to the proliferation of throughput-oriented hardware, from GPUs to increasingly wide vector units on commodity processors and accelerators. This hardware is designed to efficiently execute data-parallel computations in a vectorized manner. However, many algorithms are more naturally expressed as divide-and-conquer, recursive, task-parallel computations. In the absence of data parallelism, it seems that such algorithms are not well suited to throughput-oriented architectures. This paper presents a set of novel code transformations that expose the data parallelism latent in recursive, task-parallel programs. These transformations facilitate straightforward vectorization of task-parallel programs on commodity hardware. We also present scheduling policies that maintain high utilization of vector resources while limiting space usage. Across several task-parallel benchmarks, we demonstrate both efficient vector resource utilization and substantial speedup on chips using Intel's SSE4.2 vector units, as well as accelerators using Intel's AVX512 units.", "paper_title": "Efficient Execution of Recursive Programs on Commodity Vector Hardware", "paper_id": "WOS:000361284200048"}