{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "parallel_prefix_networks"}, {"score": 0.00475254914916922, "phrase": "parallel_prefix_network"}, {"score": 0.004650330504968421, "phrase": "n_inputs"}, {"score": 0.003924629168434799, "phrase": "associative_operator_circle"}, {"score": 0.003806866174028117, "phrase": "fundamental_problems"}, {"score": 0.003773870856027139, "phrase": "computer_science"}, {"score": 0.003644714340300824, "phrase": "parallel_computation"}, {"score": 0.003535320700255283, "phrase": "apparently_sequential_problem"}, {"score": 0.0034894451015047875, "phrase": "parallel_programming"}, {"score": 0.0034441627435203804, "phrase": "dominant_programming_paradigm"}, {"score": 0.0034143003168921114, "phrase": "parallel_prefix"}, {"score": 0.002843519597398796, "phrase": "functional_programming"}, {"score": 0.0027461155463816772, "phrase": "deep_exploration"}, {"score": 0.002722288966917744, "phrase": "parallel_prefix_network_design"}, {"score": 0.002640507929183363, "phrase": "best_known_previous_results"}, {"score": 0.0025500402081330394, "phrase": "precise_modelling"}, {"score": 0.002516917671182532, "phrase": "functional_programming_language"}, {"score": 0.002473420909291381, "phrase": "simple_visualization"}, {"score": 0.0022967713922705, "phrase": "manual_techniques"}, {"score": 0.0022180544041790697, "phrase": "programming_idiom"}, {"score": 0.0021702292394814144, "phrase": "higher_order_functions"}, {"score": 0.002132711053003407, "phrase": "wider_application"}, {"score": 0.0021049977753042253, "phrase": "network_generation"}], "paper_keywords": [""], "paper_abstract": "A parallel prefix network of width n takes n inputs, a(1), a(2), ... , a(n), and computes each y(i) = a(1) circle a(2) circle ... a(i) for 1 <= i <= n, for an associative operator circle. This is one of the fundamental problems in computer science, because it gives insight into how parallel computation can be used to solve an apparently sequential problem. As parallel programming becomes the dominant programming paradigm, parallel prefix or scan is proving to be a very important building block of parallel algorithms and applications. There are many different parallel prefix networks, with different properties such as number of operators, depth and allowed fanout from the operators. In this paper, ideas from functional programming are combined with search to enable a deep exploration of parallel prefix network design. Networks that improve on the best known previous results are generated. It is argued that precise modelling in a functional programming language, together with simple visualization of the networks, gives a new, more experimental, approach to parallel prefix network design, improving on the manual techniques typically employed in the literature. The programming idiom that marries search with higher order functions may well have wider application than the network generation described here.", "paper_title": "Functional and dynamic programming in the design of parallel prefix networks", "paper_id": "WOS:000289376900003"}