{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "inherent_sequentiality"}, {"score": 0.004722254884093624, "phrase": "concurrent_objects."}, {"score": 0.004326624385772596, "phrase": "worst_case_time"}, {"score": 0.004161553532799662, "phrase": "single_instance"}, {"score": 0.003925633992809873, "phrase": "nonblocking_implementation"}, {"score": 0.0038127186374325582, "phrase": "large_class"}, {"score": 0.0037392451233558234, "phrase": "concurrent_data_structures"}, {"score": 0.003631671435460452, "phrase": "n_processes"}, {"score": 0.002931569771634119, "phrase": "standard_data_structures"}, {"score": 0.0023431692392929353, "phrase": "base_object"}, {"score": 0.0022756672722130424, "phrase": "upper_bounds"}, {"score": 0.0021464286727045623, "phrase": "base_objects"}], "paper_keywords": ["distributed data structures", " lower bounds", " covering", " memory contention"], "paper_abstract": "We present Omega(n) lower bounds on the worst case time to perform a single instance of an operation in any nonblocking implementation of a large class of concurrent data structures shared by n processes. Time is measured by the number of stalls a process incurs as a result of contention with other processes. For standard data structures such as counters, stacks, and queues, our bounds are tight. The implementations considered may apply any primitives to a base object. No upper bounds are assumed on either the number of base objects or their size.", "paper_title": "ON THE INHERENT SEQUENTIALITY OF CONCURRENT OBJECTS", "paper_id": "WOS:000306001700003"}