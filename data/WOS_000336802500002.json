{"auto_keywords": [{"score": 0.03620728805533268, "phrase": "instrumented_version"}, {"score": 0.00481495049065317, "phrase": "compiler-generated_skeletons"}, {"score": 0.004671012181488876, "phrase": "original_generation"}, {"score": 0.004608422081389008, "phrase": "algorithmic_skeletons"}, {"score": 0.004531357177195719, "phrase": "speculative_parallelization"}, {"score": 0.004500891637057374, "phrase": "scientific_nested_loop_kernels"}, {"score": 0.004336939968686303, "phrase": "target_code"}, {"score": 0.004235717186207754, "phrase": "data_locality"}, {"score": 0.004207230913063179, "phrase": "parallel_code_generation"}, {"score": 0.004081385289516914, "phrase": "binary_algorithmic_skeletons"}, {"score": 0.003932654396285872, "phrase": "original_code"}, {"score": 0.00384083110935486, "phrase": "polyhedral_parallelizing_transformation"}, {"score": 0.0036144035798673967, "phrase": "executable_code"}, {"score": 0.0035779805381654438, "phrase": "run-time_process"}, {"score": 0.003541923233726252, "phrase": "transformation_selection"}, {"score": 0.0035062280202127136, "phrase": "online_profiling_phases"}, {"score": 0.00348263058839775, "phrase": "short_samples"}, {"score": 0.0033218213825698417, "phrase": "accessed_memory_addresses"}, {"score": 0.0032223742018434856, "phrase": "dependence_distance_vectors"}, {"score": 0.0030943793545344495, "phrase": "forthcoming_accesses"}, {"score": 0.003042555825368091, "phrase": "distance_vectors"}, {"score": 0.0029915976131073825, "phrase": "dependence_analysis"}, {"score": 0.002951444412262927, "phrase": "parallelizing_transformation"}, {"score": 0.0027307746993761035, "phrase": "rollback_time"}, {"score": 0.002640038329840458, "phrase": "successive_slices"}, {"score": 0.0026134084008199933, "phrase": "outermost_original_loop"}, {"score": 0.0024758420717852113, "phrase": "sequential_original_version"}, {"score": 0.0022829193139224636, "phrase": "observed_execution_phases"}, {"score": 0.002222004614440872, "phrase": "pre-built_skeletons"}, {"score": 0.0021408862709571615, "phrase": "llvm_compiler"}, {"score": 0.0021049977753042253, "phrase": "significant_speed-ups"}], "paper_keywords": ["Algorithmic skeletons", " Polytope model", " Automatic parallelization", " Speculative parallelization", " Dynamic parallelization", " Loop nests", " Compilation"], "paper_abstract": "We propose a framework based on an original generation and use of algorithmic skeletons, and dedicated to speculative parallelization of scientific nested loop kernels, able to apply at run-time polyhedral transformations to the target code in order to exhibit parallelism and data locality. Parallel code generation is achieved almost at no cost by using binary algorithmic skeletons that are generated at compile-time, and that embed the original code and operations devoted to instantiate a polyhedral parallelizing transformation and to verify the speculations on dependences. The skeletons are patched at run-time to generate the executable code. The run-time process includes a transformation selection guided by online profiling phases on short samples, using an instrumented version of the code. During this phase, the accessed memory addresses are used to compute on-the-fly dependence distance vectors, and are also interpolated to build a predictor of the forthcoming accesses. Interpolating functions and distance vectors are then employed for dependence analysis to select a parallelizing transformation that, if the prediction is correct, does not induce any rollback during execution. In order to ensure that the rollback time overhead stays low, the code is executed in successive slices of the outermost original loop of the nest. Each slice can be either a parallel version which instantiates a skeleton, a sequential original version, or an instrumented version. Moreover, such slicing of the execution provides the opportunity of transforming differently the code to adapt to the observed execution phases, by patching differently one of the pre-built skeletons. The framework has been implemented with extensions of the LLVM compiler and an x86-64 runtime system. Significant speed-ups are shown on a set of benchmarks that could not have been handled efficiently by a compiler.", "paper_title": "Dynamic and Speculative Polyhedral Parallelization Using Compiler-Generated Skeletons", "paper_id": "WOS:000336802500002"}