{"auto_keywords": [{"score": 0.04937176974353987, "phrase": "predicate_abstraction"}, {"score": 0.012390582011515246, "phrase": "deductive_proof"}, {"score": 0.010113936416165101, "phrase": "safety_properties"}, {"score": 0.008529278866691555, "phrase": "progress_properties"}, {"score": 0.00818837927199126, "phrase": "complete_ranking_function"}, {"score": 0.00481502318726609, "phrase": "modular"}, {"score": 0.004387117409226736, "phrase": "liveness_properties"}, {"score": 0.004338390136272005, "phrase": "paper_studies"}, {"score": 0.0041488110506566825, "phrase": "non-constraining_progress_monitor"}, {"score": 0.0040571383470418085, "phrase": "ranking_functions"}, {"score": 0.00389427992231721, "phrase": "automatic_verification"}, {"score": 0.003601235776892337, "phrase": "helpful_step"}, {"score": 0.0035479614996805383, "phrase": "adequate_user-provided_inputs"}, {"score": 0.0029889584492584073, "phrase": "ranking_abstraction"}, {"score": 0.0028903278985330117, "phrase": "tne_ranking_abstraction"}, {"score": 0.0026626797255348287, "phrase": "apporpriate_refinements"}, {"score": 0.0024620842899061614, "phrase": "program_invariants"}, {"score": 0.0024075916292945715, "phrase": "boolean_combination"}, {"score": 0.0023281003994670714, "phrase": "well-founded_ranking_functions"}, {"score": 0.0021850254717637172, "phrase": "arbitrary_ltl_formula"}, {"score": 0.002128694000627911, "phrase": "successful_application"}, {"score": 0.0021049977753042253, "phrase": "ranking_abstraction_method"}], "paper_keywords": ["model checking", " predicate abstraction", " ranking abstraction", " deductive verification"], "paper_abstract": "Predicate abstraction has become one of the most successful methodologies for proving safety properties of programs. Recently, several abstraction methodologies have been proposed for proving liveness properties. This paper studies \"ranking abstraction\" where a program is augmented by a non-constraining progress monitor based on a set of ranking functions, and further abstracted by predicate-abstraction, to allow for automatic verification of progress properties. Unlike many liveness methodologies, the augmentation does not require a complete ranking function that is expected to decrease with each helpful step. Rather, adequate user-provided inputs are component rankings from which a complete ranking function may be automatically formed. The premise of the paper is an analogy between the methods of ranking abstraction and predicate abstraction, one ingredient of which is refinement: When predicate abstraction fails, one can refine it. When ranking abstraction fails, one must determine whether the predicate abstraction, or tne ranking abstraction, needs be refined. The paper presents strategies for determining which case is at hand, and methods for performing the apporpriate refinements. The other part of the analogy is that of automatically deriving deductive proof constructs: Predicate abstraction is often used to derive program invariants for proving safety properties as a boolean combination of the given predicates. Deductive proof of progress properties requires well-founded ranking functions in addition to invariants. We show how the constructs necessary for a deductive proof of an arbitrary LTL formula can be automatically extracted from a successful application of the ranking abstraction method.", "paper_title": "Modular ranking abstraction", "paper_id": "WOS:000250860600002"}