{"auto_keywords": [{"score": 0.031062668392302317, "phrase": "best_variant_function"}, {"score": 0.014375671493310661, "phrase": "program_structure"}, {"score": 0.009878036452485464, "phrase": "fixpoint_definition"}, {"score": 0.004355163162038354, "phrase": "abstract_interpretation_design_principle"}, {"score": 0.004240116703465252, "phrase": "new_forward_and_backward_proof"}, {"score": 0.0040324997782003455, "phrase": "strongest_safety_property"}, {"score": 0.0039259432210911925, "phrase": "constructive_fixpoint_form"}, {"score": 0.003899745240916238, "phrase": "safety_proof"}, {"score": 0.003809416146761322, "phrase": "fixpoint_induction"}, {"score": 0.0037839928025418896, "phrase": "static_analysis"}, {"score": 0.0037587384888691645, "phrase": "abstract_safety_properties"}, {"score": 0.003659389341948856, "phrase": "fixpoint_abstraction"}, {"score": 0.0035388743851813512, "phrase": "safety_properties"}, {"score": 0.003376769321692139, "phrase": "existing_approaches"}, {"score": 0.0031579462920888132, "phrase": "design_principle"}, {"score": 0.0031054861345720854, "phrase": "potential_and_definite_termination"}, {"score": 0.0030744279865523036, "phrase": "trace-based_termination"}, {"score": 0.002789715649746005, "phrase": "new_static_analysis_methods"}, {"score": 0.0026088355715432523, "phrase": "syntactic_notion"}, {"score": 0.002591403838835242, "phrase": "structural_induction"}, {"score": 0.002548331088496964, "phrase": "hoare_logic"}, {"score": 0.002514387630447547, "phrase": "semantic_structural_induction"}, {"score": 0.0024808951705681636, "phrase": "new_semantic_concept"}, {"score": 0.0024643161985886085, "phrase": "inductive_trace_cover"}, {"score": 0.0023990982005125763, "phrase": "new_basis"}, {"score": 0.002375087848055933, "phrase": "program_properties"}, {"score": 0.0023356021521252495, "phrase": "generalized_recursive_proof"}, {"score": 0.0023044856709624494, "phrase": "static_analysis_methods"}, {"score": 0.0021987994275190314, "phrase": "particular_instances"}, {"score": 0.002184101477091303, "phrase": "floyd's_handling"}, {"score": 0.00216950156199795, "phrase": "loop_cut-points"}, {"score": 0.002140593237903078, "phrase": "nested_loops"}, {"score": 0.0021262835396323623, "phrase": "burstall's_intermittent_assertion_total_correctness_proof_method"}, {"score": 0.0021049977753042253, "phrase": "podelski-rybalchenko"}], "paper_keywords": ["Languages", " Reliability", " Security", " Theory", " Verification", " Abstract Interpretation", " Induction", " Proof", " Safety", " Static analysis", " Variant function", " Verification", " Termination"], "paper_abstract": "Proof, verification and analysis methods for termination all rely on two induction principles: (1) a variant function or induction on data ensuring progress towards the end and (2) some form of induction on the program structure. The abstract interpretation design principle is first illustrated for the design of new forward and backward proof, verification and analysis methods for safety. The safety collecting semantics defining the strongest safety property of programs is first expressed in a constructive fixpoint form. Safety proof and checking/verification methods then immediately follow by fixpoint induction. Static analysis of abstract safety properties such as invariance are constructively designed by fixpoint abstraction (or approximation) to (automatically) infer safety properties. So far, no such clear design principle did exist for termination so that the existing approaches are scattered and largely not comparable with each other. For (1), we show that this design principle applies equally well to potential and definite termination. The trace-based termination collecting semantics is given a fixpoint definition. Its abstraction yields a fixpoint definition of the best variant function. By further abstraction of this best variant function, we derive the Floyd/Turing termination proof method as well as new static analysis methods to effectively compute approximations of this best variant function. For (2), we introduce a generalization of the syntactic notion of structural induction (as found in Hoare logic) into a semantic structural induction based on the new semantic concept of inductive trace cover covering execution traces by segments, a new basis for formulating program properties. Its abstractions allow for generalized recursive proof, verification and static analysis methods by induction on both program structure, control, and data. Examples of particular instances include Floyd's handling of loop cut-points as well as nested loops, Burstall's intermittent assertion total correctness proof method, and Podelski-Rybalchenko transition invariants.", "paper_title": "An Abstract Interpretation Framework for Termination", "paper_id": "WOS:000300548100019"}