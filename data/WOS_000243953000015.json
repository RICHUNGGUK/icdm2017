{"auto_keywords": [{"score": 0.0500782030438861, "phrase": "custom_instructions"}, {"score": 0.04599283119366169, "phrase": "dfg"}, {"score": 0.037969048916105315, "phrase": "selected_node"}, {"score": 0.034267075898275066, "phrase": "problem_size"}, {"score": 0.027196367561612412, "phrase": "new_algorithm"}, {"score": 0.026528696575256593, "phrase": "existing_algorithms"}, {"score": 0.004774324145784758, "phrase": "extensible_processors"}, {"score": 0.0046544807197808095, "phrase": "fast_algorithm"}, {"score": 0.004576253356889219, "phrase": "convex_subgraphs"}, {"score": 0.0044424917428102445, "phrase": "dataflow_graph"}, {"score": 0.004330941610682453, "phrase": "basic_block"}, {"score": 0.003995772867224968, "phrase": "better_instruction-set_extension"}, {"score": 0.003962042040350354, "phrase": "ise"}, {"score": 0.0039119492240482, "phrase": "faster_design_space_exploration"}, {"score": 0.003813669883040509, "phrase": "grading_method"}, {"score": 0.0037495207047193034, "phrase": "next_node"}, {"score": 0.003400984514637656, "phrase": "resultant_subgraph"}, {"score": 0.0029817668105720924, "phrase": "smaller_dfgs"}, {"score": 0.0027741761880779535, "phrase": "simple_but_efficient_method"}, {"score": 0.0027274643070540733, "phrase": "invalid_subgraphs"}, {"score": 0.0026140878612307536, "phrase": "relatively_small_dfgs"}, {"score": 0.0025919830205975215, "phrase": "small_exploration_space"}, {"score": 0.0025375331660958665, "phrase": "similar_runtimes"}, {"score": 0.0024423826953133844, "phrase": "larger_dfgs"}, {"score": 0.002391067964886602, "phrase": "multiple_input"}, {"score": 0.0023309080951251335, "phrase": "runtime_improvement"}, {"score": 0.0021049977753042253, "phrase": "embedded_processors"}], "paper_keywords": ["algorithm", " configurable processor", " instruction-set extension (ISE)"], "paper_abstract": "This paper proposes a fast algorithm to enumerate all convex subgraphs that satisfy the I/O constraints from the dataflow graph (DFG) of a basic block. The algorithm can be tuned to determine all subgraphs or only those connected subgraphs. This allows a choice between better instruction-set extension (ISE) and faster design space exploration. The algorithm uses a grading method to identify the next node for inclusion into a subgraph. If the selected node is included, other related nodes are included as well, thus ensuring that the resultant subgraph is always convex and at the same time, reducing the problem size by a block of nodes. If the selected node is not included, the DFG will be split into smaller DFGs, thus reducing also the problem size. With this as base, the algorithm employs a simple but efficient method to prune the invalid subgraphs that violate the I/O constraints. Results show that for relatively small DFGs with small exploration space, the new algorithm has similar runtimes to that of existing algorithms. However, for larger DFGs with much larger exploration space and with multiple input and output constraints, the runtime improvement can be orders of magnitude better than that of existing algorithms. The new algorithm can be used to quickly identify custom instructions for ISE of embedded processors.", "paper_title": "Fast identification of custom instructions for extensible processors", "paper_id": "WOS:000243953000015"}