{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrency_bugs"}, {"score": 0.0073510360070973115, "phrase": "potential_failure_sites"}, {"score": 0.00478218760286811, "phrase": "sequential_errors"}, {"score": 0.004685224205630963, "phrase": "non-deterministic_interleavings"}, {"score": 0.004653339900995785, "phrase": "shared_memory_accesses"}, {"score": 0.0043610084347896596, "phrase": "incorrect_output"}, {"score": 0.0039362209515303795, "phrase": "traditional_techniques"}, {"score": 0.003688773272422118, "phrase": "common_triggers"}, {"score": 0.003613899384402803, "phrase": "data_races"}, {"score": 0.003540539868937462, "phrase": "consequence-oriented_approach"}, {"score": 0.0034450303951025704, "phrase": "state-space_search"}, {"score": 0.003375087185182269, "phrase": "proposed_approach"}, {"score": 0.0032952735750239924, "phrase": "program_binary"}, {"score": 0.0030985717040741875, "phrase": "critical_read_instructions"}, {"score": 0.002984173420996039, "phrase": "data_dependences"}, {"score": 0.002786858120570499, "phrase": "suspicious_interleavings"}, {"score": 0.0027395968397212053, "phrase": "incorrect_state"}, {"score": 0.002693134880651768, "phrase": "critical_read"}, {"score": 0.0026384167183586015, "phrase": "software_failure"}, {"score": 0.002567180189640976, "phrase": "conseq's_backwards_approach"}, {"score": 0.0024893297856666808, "phrase": "bug-detection_coverage"}, {"score": 0.0023486473525617794, "phrase": "empirical_observation"}, {"score": 0.0021708548759021844, "phrase": "conseq"}, {"score": 0.0021340178074057245, "phrase": "traditional_approaches"}], "paper_keywords": ["Languages", " Reliability", " Software testing", " concurrency bugs"], "paper_abstract": "Concurrency bugs are caused by non-deterministic interleavings between shared memory accesses. Their effects propagate through data and control dependences until they cause software to crash, hang, produce incorrect output, etc. The lifecycle of a bug thus consists of three phases: (1) triggering, (2) propagation, and (3) failure. Traditional techniques for detecting concurrency bugs mostly focus on phase (1)-i.e., on finding certain structural patterns of interleavings that are common triggers of concurrency bugs, such as data races. This paper explores a consequence-oriented approach to improving the accuracy and coverage of state-space search and bug detection. The proposed approach first statically identifies potential failure sites in a program binary (i.e., it first considers a phase (3) issue). It then uses static slicing to identify critical read instructions that are highly likely to affect potential failure sites through control and data dependences (phase (2)). Finally, it monitors a single (correct) execution of a concurrent program and identifies suspicious interleavings that could cause an incorrect state to arise at a critical read and then lead to a software failure (phase (1)). ConSeq's backwards approach, (3)->(2)->(1), provides advantages in bug-detection coverage and accuracy but is challenging to carry out. ConSeq makes it feasible by exploiting the empirical observation that phases (2) and (3) usually are short and occur within one thread. Our evaluation on large, real-world C/C++ applications shows that ConSeq detects more bugs than traditional approaches and has a much lower false-positive rate.", "paper_title": "ConSeq: Detecting Concurrency Bugs through Sequential Errors", "paper_id": "WOS:000290854400021"}