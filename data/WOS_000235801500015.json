{"auto_keywords": [{"score": 0.04780597585803096, "phrase": "incremental_evaluation"}, {"score": 0.00481495049065317, "phrase": "tabled_prolog"}, {"score": 0.0047515546458205046, "phrase": "pure_logic_programs"}, {"score": 0.004546174820239776, "phrase": "logic_programs"}, {"score": 0.00436890075128947, "phrase": "program_change"}, {"score": 0.0040886093072615, "phrase": "current_algorithms"}, {"score": 0.004016938499717623, "phrase": "memo_tables"}, {"score": 0.003676926952533304, "phrase": "arbitrary_tabled_programs"}, {"score": 0.00359653851381984, "phrase": "prolog"}, {"score": 0.00342568771304873, "phrase": "non-stratified_negation"}, {"score": 0.0032919615578986816, "phrase": "simpler_incremental_evaluation_algorithm"}, {"score": 0.0032057142600527, "phrase": "dynamic_call_graph"}, {"score": 0.003107935254560724, "phrase": "entire_calls"}, {"score": 0.0025241429061867633, "phrase": "call-based_algorithm"}, {"score": 0.002436289099444074, "phrase": "call_dependencies"}, {"score": 0.0022496114364599328, "phrase": "independent_cyclic_components"}, {"score": 0.002200337772403981, "phrase": "analysis_problems"}, {"score": 0.0021426288417854987, "phrase": "first_practical_algorithm"}, {"score": 0.0021049977753042253, "phrase": "legal_tabled_logic_programs"}], "paper_keywords": [""], "paper_abstract": "Tabling, or memoization, enables incremental evaluation of logic programs. When the rules or facts of a program change, we need to recompute only those results that are affected by the changes. The current algorithms for incrementally maintaining memo tables treat insertion of facts/rules differently from their deletion. Hence these techniques cannot be directly applied for incremental evaluation of arbitrary tabled programs, especially those involving Prolog built-ins such as findall, other aggregation operations, or non-stratified negation. In this paper, we explore a simpler incremental evaluation algorithm that, based on the dynamic call graph, invalidates and re-evaluates entire calls. The algorithm is agnostic to whether a dependency adds or removes answers from tables, and hence can be applied uniformly to programs with negation, even when the negation is implicit (as is the case with certain aggregation operations). We find that the call-based algorithm is very effective in examples where the call dependencies are largely acyclic (e.g. dynamic programming examples) and is moderately effective when the dependencies contain independent cyclic components (e.g. data flow analysis problems). This is the first practical algorithm to handle all legal tabled logic programs for which incremental evaluation is meaningful.", "paper_title": "Incremental evaluation of tabled Prolog: Beyond pure logic programs", "paper_id": "WOS:000235801500015"}