{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "polar_codes"}, {"score": 0.004716520738331953, "phrase": "successive-cancellation_list_decoder"}, {"score": 0.004506968388996092, "phrase": "classic_successive-cancellation_decoder"}, {"score": 0.0044698906756151235, "phrase": "arikan"}, {"score": 0.004396600680348434, "phrase": "proposed_list_decoder"}, {"score": 0.004360412703519539, "phrase": "l_decoding_paths"}, {"score": 0.004253618550301311, "phrase": "decoding_stage"}, {"score": 0.004149429072483132, "phrase": "integer_parameter"}, {"score": 0.004031082737449308, "phrase": "decoding_process"}, {"score": 0.003916098498242888, "phrase": "l_paths"}, {"score": 0.003835972725191194, "phrase": "single_codeword"}, {"score": 0.0037886833451021723, "phrase": "decoder_output"}, {"score": 0.0036958398682001015, "phrase": "resulting_performance"}, {"score": 0.003590383760209319, "phrase": "maximum-likelihood_decoding"}, {"score": 0.003531474887552889, "phrase": "moderate_values"}, {"score": 0.0033465923623290034, "phrase": "transmitted_codeword"}, {"score": 0.003171358146412577, "phrase": "current_state-of-the-art_ldpc_codes"}, {"score": 0.0030052718739167696, "phrase": "simple_crc_precoding"}, {"score": 0.002968192753809507, "phrase": "specific_list-decoding_algorithm"}, {"score": 0.0028596699752849682, "phrase": "decoding_paths"}, {"score": 0.0028243822059448266, "phrase": "information_bit"}, {"score": 0.002755104031926742, "phrase": "pruning_procedure"}, {"score": 0.0026875205754965537, "phrase": "l_most_likely_paths"}, {"score": 0.002643386043540555, "phrase": "straightforward_implementation"}, {"score": 0.002504880563070155, "phrase": "stark_contrast"}, {"score": 0.002413256359147736, "phrase": "original_successive-cancellation_decoder"}], "paper_keywords": ["List decoding", " polar codes", " successive cancellation decoding"], "paper_abstract": "We describe a successive-cancellation list decoder for polar codes, which is a generalization of the classic successive-cancellation decoder of Arikan. In the proposed list decoder, L decoding paths are considered concurrently at each decoding stage, where L is an integer parameter. At the end of the decoding process, the most likely among the L paths is selected as the single codeword at the decoder output. Simulations show that the resulting performance is very close to that of maximum-likelihood decoding, even for moderate values of L. Alternatively, if a genie is allowed to pick the transmitted codeword from the list, the results are comparable with the performance of current state-of-the-art LDPC codes. We show that such a genie can be easily implemented using simple CRC precoding. The specific list-decoding algorithm that achieves this performance doubles the number of decoding paths for each information bit, and then uses a pruning procedure to discard all but the L most likely paths. However, straightforward implementation of this algorithm requires Omega(Ln(2)) time, which is in stark contrast with the O(n log n) complexity of the original successive-cancellation decoder. In this paper, we utilize the structure of polar codes along with certain algorithmic transformations in order to overcome this problem: we devise an efficient, numerically stable, implementation of the proposed list decoder that takes only O(Ln log n) time and O(Ln) space.", "paper_title": "List Decoding of Polar Codes", "paper_id": "WOS:000353515700001"}