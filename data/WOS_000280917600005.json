{"auto_keywords": [{"score": 0.03867712206987224, "phrase": "robustness_testing"}, {"score": 0.03459313900284793, "phrase": "different_states"}, {"score": 0.03379621455202772, "phrase": "state_machine"}, {"score": 0.02992988581002572, "phrase": "test_cases"}, {"score": 0.00481495049065317, "phrase": "software_components"}, {"score": 0.0047689174754929195, "phrase": "component-based_development"}, {"score": 0.004611224230543916, "phrase": "existing_components"}, {"score": 0.004501774379030109, "phrase": "software_reuse"}, {"score": 0.0043738432231020885, "phrase": "critical_applications"}, {"score": 0.003878625406105021, "phrase": "well-suited_means"}, {"score": 0.0038230844545071303, "phrase": "source_code"}, {"score": 0.0036261282565554507, "phrase": "testing_methodology"}, {"score": 0.0034725269588525534, "phrase": "unexpected_inputs"}, {"score": 0.0034063576796640603, "phrase": "stressful_environment"}, {"score": 0.0031845067058084583, "phrase": "based_approach"}, {"score": 0.002730023736069673, "phrase": "specific_control_state"}, {"score": 0.0026395715432958665, "phrase": "invalid_inputs"}, {"score": 0.002329009499335603, "phrase": "stateless_api_testing"}, {"score": 0.0022302306304023602, "phrase": "open_source_software"}, {"score": 0.002166711569953301, "phrase": "existing_approaches"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Robustness testing", " Component", " Contract", " State machine"], "paper_abstract": "Component-based development allows one to build software from existing components and promises to improve software reuse and reduce costs. For critical applications, the user of a component must ensure that it fits the requirements of the application. To achieve this, testing is a well-suited means when the source code of the components is not available. Robustness testing is a testing methodology to detect the vulnerabilities of a component under unexpected inputs or in a stressful environment. As components may fail differently in different states, we use a state machine based approach to robustness testing. First, a set of paths is generated to cover transitions of the state machine, and it is used by the test cases to bring the component into a specific control state. Second, method calls with invalid inputs are fed to the component in different states to test the robustness. By traversing the paths, the test cases cover more states and transitions compared to stateless API testing. We apply our approach to several components, including open source software, and compare our results with existing approaches. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Robustness testing for software components", "paper_id": "WOS:000280917600005"}