{"auto_keywords": [{"score": 0.042121604651343916, "phrase": "openmp"}, {"score": 0.00481495049065317, "phrase": "numa_architectures"}, {"score": 0.004683073921949839, "phrase": "full_computational_power"}, {"score": 0.0046184900568047565, "phrase": "current_hierarchical_multiprocessor_machines"}, {"score": 0.004308630865024719, "phrase": "underlying_non-uniform_architecture"}, {"score": 0.004161553532799662, "phrase": "remote_memory_access_penalties"}, {"score": 0.004104132253183181, "phrase": "directive-based_programming_languages"}, {"score": 0.0036722834182246933, "phrase": "easy_way"}, {"score": 0.0033317342432676385, "phrase": "runtime_system"}, {"score": 0.003129623571496151, "phrase": "multi-level_thread_scheduler"}, {"score": 0.0030437652050982617, "phrase": "numa-aware_memory_manager"}, {"score": 0.0029193609786176632, "phrase": "scheduling_hints"}, {"score": 0.0028590732866152118, "phrase": "thread-memory_affinity_issues"}, {"score": 0.002761340122199076, "phrase": "dynamic_load_distribution"}, {"score": 0.002704306866425829, "phrase": "application_structure"}, {"score": 0.00266693888510356, "phrase": "hardware_topology"}, {"score": 0.0025578967205807843, "phrase": "performance_portability"}, {"score": 0.0024704333220467393, "phrase": "mixed_solutions"}, {"score": 0.0022101055924375725, "phrase": "next-touch-based_data_distribution_policies"}, {"score": 0.0021049977753042253, "phrase": "additional_optimizations"}], "paper_keywords": ["OpenMP", " Memory", " NUMA", " Hierarchical Thread Scheduling", " Multi-Core"], "paper_abstract": "Exploiting the full computational power of current hierarchical multiprocessor machines requires a very careful distribution of threads and data among the underlying non-uniform architecture so as to avoid remote memory access penalties. Directive-based programming languages such as OpenMP, can greatly help to perform such a distribution by providing programmers with an easy way to structure the parallelism of their application and to transmit this information to the runtime system. Our runtime, which is based on a multi-level thread scheduler combined with a NUMA-aware memory manager, converts this information into scheduling hints related to thread-memory affinity issues. These hints enable dynamic load distribution guided by application structure and hardware topology, thus helping to achieve performance portability. Several experiments show that mixed solutions (migrating both threads and data) outperform work-stealing based balancing strategies and next-touch-based data distribution policies. These techniques provide insights about additional optimizations.", "paper_title": "ForestGOMP: An Efficient OpenMP Environment for NUMA Architectures", "paper_id": "WOS:000281163100006"}