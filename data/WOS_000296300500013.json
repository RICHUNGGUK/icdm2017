{"auto_keywords": [{"score": 0.04916387935172273, "phrase": "flash_memory"}, {"score": 0.0111816541902516, "phrase": "run_generation_phase"}, {"score": 0.008644611032791804, "phrase": "optimal_solution"}, {"score": 0.00481495049065317, "phrase": "flash_memory_via_natural_page_run_generation"}, {"score": 0.004759507166427077, "phrase": "increasing_popularity"}, {"score": 0.004422827355213055, "phrase": "external_sort"}, {"score": 0.004206236029936448, "phrase": "efficient_external_sorting"}, {"score": 0.00398478333092707, "phrase": "previously_sorted_data"}, {"score": 0.003878451139312637, "phrase": "data_updates"}, {"score": 0.0035212516951180946, "phrase": "partial_sorted_nature"}, {"score": 0.003374655868348244, "phrase": "traditional_external_merge_sort"}, {"score": 0.0031845067058084613, "phrase": "partially_sorted_data"}, {"score": 0.0030283946391741912, "phrase": "io"}, {"score": 0.0027706013216537042, "phrase": "shortest_distance_problem"}, {"score": 0.0027386335451725762, "phrase": "directed_acyclic_graph"}, {"score": 0.00257424957319189, "phrase": "well-known_dag-shortest-paths_algorithm"}, {"score": 0.0024479627964740748, "phrase": "even_moderate-sized_data_sets"}, {"score": 0.002401053532270901, "phrase": "fast_heuristic_solution"}, {"score": 0.0023188652648490874, "phrase": "high_percentage"}, {"score": 0.0022481685132781626, "phrase": "computational_overhead"}, {"score": 0.0021378442381693847, "phrase": "external_sorting_time"}], "paper_keywords": ["external sorting", " flash memory", " relational database", " merge sort"], "paper_abstract": "The increasing popularity of flash memory means more database systems will run on flash memory in the future. One of the most important database operations is the external sort. Hence, this paper is focused on studying the problem of efficient external sorting on flash memory. In contrast to most previous work, we target the situation where previously sorted data have become progressively unsorted due to data updates. Accordingly, we call this 'partially' sorted data. We focus on re-sorting partially sorted data by taking advantage of the partial sorted nature of the data to speed up the run generation phase of the traditional external merge sort. We do this by finding 'naturally occurring' page runs in the partially sorted data. Our algorithm can perform up to a factor of 1024 less write IO compared with a traditional external merge sort during the run generation phase. We map the problem of finding naturally occurring runs into the shortest distance problem in a directed acyclic graph (DAG). Accordingly, we propose an optimal solution to the problem using the well-known DAG-Shortest-Paths algorithm. However, we found that the optimal solution was too slow for even moderate-sized data sets and accordingly propose a fast heuristic solution that-we experimentally show-finds a high percentage of page runs using a minimum of computational overhead. Experiments using both real and synthetic data sets show that our heuristic algorithm can halve the external sorting time when compared with three likely competing external sorting algorithms.", "paper_title": "External Sorting on Flash Memory Via Natural Page Run Generation", "paper_id": "WOS:000296300500013"}