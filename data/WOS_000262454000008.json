{"auto_keywords": [{"score": 0.049593242225692294, "phrase": "stateless_components"}, {"score": 0.015719716506582538, "phrase": "automatic_composition"}, {"score": 0.0046937237797352515, "phrase": "available_software_components"}, {"score": 0.004622450915803531, "phrase": "new_systems"}, {"score": 0.00437021209960886, "phrase": "considerable_amount"}, {"score": 0.004216880725292, "phrase": "human_effort"}, {"score": 0.003966388754366831, "phrase": "single_component"}, {"score": 0.0038862297330905836, "phrase": "sought_functionality"}, {"score": 0.0038271712887391015, "phrase": "ideal_scenario"}, {"score": 0.003788296551609616, "phrase": "software_reuse"}, {"score": 0.0036740168936985314, "phrase": "new_software_system"}, {"score": 0.0036181717017041387, "phrase": "existing_components"}, {"score": 0.003403122817578447, "phrase": "logical_reasoning"}, {"score": 0.0031521392193570846, "phrase": "simple_two_step_behavior"}, {"score": 0.002934566917795928, "phrase": "corresponding_outputs"}, {"score": 0.0028170314398963704, "phrase": "concrete_algorithms"}, {"score": 0.0027741761880779535, "phrase": "possible_component_compositions"}, {"score": 0.002731971103291716, "phrase": "requested_behavior"}, {"score": 0.0026494723416072316, "phrase": "returned_compositions"}, {"score": 0.002622528664187849, "phrase": "composition_algebraic_rules"}, {"score": 0.0025958582759972315, "phrase": "composition_algebra"}, {"score": 0.002556359086441866, "phrase": "minimal_process_algebra"}, {"score": 0.0023435920614377306, "phrase": "proposed_approach"}, {"score": 0.0023197517832705297, "phrase": "realistic_situations"}, {"score": 0.0022267859286766553, "phrase": "experimental_results"}, {"score": 0.0021049977753042253, "phrase": "test_cases"}], "paper_keywords": [""], "paper_abstract": "Reusing available software components in developing new systems is always a priority, as it usually saves a considerable amount of time, money, and human effort. Since it might not always be possible to find a single component that provides the sought functionality, an ideal scenario for software reuse would be to build a new software system by composing existing components based on their behavioral properties. In this paper we take advantage of logical reasoning to find a solution for automatic composition of stateless components. Stateless components are components with a simple two step behavior: they receive all their inputs at the same time, and then return the corresponding outputs also at the same time. We provide concrete algorithms to find possible component compositions for a requested behavior. We then validate the returned compositions using composition algebraic rules. Composition algebra is a minimal process algebra that is specifically designed for this validation. In order to understand the functionality of the proposed approach in realistic situations, we also study some of the experimental results obtained by implementing the algorithm and running it on some test cases.", "paper_title": "A Logical Reasoning Approach to Automatic Composition of Stateless Components", "paper_id": "WOS:000262454000008"}