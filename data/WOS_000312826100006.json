{"auto_keywords": [{"score": 0.03659429864956845, "phrase": "hampi"}, {"score": 0.004817914645071553, "phrase": "context"}, {"score": 0.0044237033788643715, "phrase": "constraint-generation_phase"}, {"score": 0.004349337717774093, "phrase": "constraint-solving_phase"}, {"score": 0.004133627071344356, "phrase": "increasing_efficiency_of_off-the-shelf_constraint_solvers"}, {"score": 0.003797530813314321, "phrase": "string-manipulating_programs"}, {"score": 0.003400984514637656, "phrase": "string_constraints"}, {"score": 0.0033579708256295847, "phrase": "string_variables"}, {"score": 0.003245900020944865, "phrase": "regular_expressions"}, {"score": 0.0031777570808834213, "phrase": "string_terms"}, {"score": 0.0031375577552605533, "phrase": "typical_string_operations"}, {"score": 0.002809732883291955, "phrase": "hampi's_expressiveness"}, {"score": 0.0026929458952693465, "phrase": "automated_testing"}, {"score": 0.0026252106881752067, "phrase": "static_and_dynamic_analyses"}, {"score": 0.0025919830205975215, "phrase": "sql_injection_vulnerabilities"}, {"score": 0.002570064617803693, "phrase": "web_applications"}, {"score": 0.0024012441367538434, "phrase": "automated_bug_finding"}, {"score": 0.002380934815435267, "phrase": "c_programs"}, {"score": 0.002360796860462937, "phrase": "dynamic_systematic_testing"}, {"score": 0.002311192286067765, "phrase": "concolic_testing"}, {"score": 0.002224510044064184, "phrase": "string_solver"}, {"score": 0.002205692205167157, "phrase": "cfganalyzer"}, {"score": 0.0021049977753042253, "phrase": "hampi's_source_code"}], "paper_keywords": ["Verification", " Algorithms", " Reliability", " Security", " String constraints", " word equations", " regular languages", " context-free languages", " concolic testing", " program analysis"], "paper_abstract": "Many automatic testing, analysis, and verification techniques for programs can be effectively reduced to a constraint-generation phase followed by a constraint-solving phase. This separation of concerns often leads to more effective and maintainable software reliability tools. The increasing efficiency of off-the-shelf constraint solvers makes this approach even more compelling. However, there are few effective and sufficiently expressive off-the-shelf solvers for string constraints generated by analysis of string-manipulating programs, so researchers end up implementing their own ad-hoc solvers. To fulfill this need, we designed and implemented HAMPI, a solver for string constraints over bounded string variables. Users of HAMPI specify constraints using regular expressions, context-free grammars, equality between string terms, and typical string operations such as concatenation and substring extraction. HAMPI then finds a string that satisfies all the constraints or reports that the constraints are unsatisfiable. We demonstrate HAMPI's expressiveness and efficiency by applying it to program analysis and automated testing. We used HAMPI in static and dynamic analyses for finding SQL injection vulnerabilities in Web applications with hundreds of thousands of lines of code. We also used HAMPI in the context of automated bug finding in C programs using dynamic systematic testing (also known as concolic testing). We then compared HAMPI with another string solver, CFGAnalyzer, and show that HAMPI is several times faster. HAMPI'S source code, documentation, and experimental data are available at http://people.csail.mit.edu/akiezun/hampi(1).", "paper_title": "HAMPI: A Solver for Word Equations over Strings, Regular Expressions, and Context-Free Grammars", "paper_id": "WOS:000312826100006"}