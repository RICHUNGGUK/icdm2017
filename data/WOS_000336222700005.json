{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "group_replication"}, {"score": 0.0047323590206695305, "phrase": "exascale_systems"}, {"score": 0.00469159356595623, "phrase": "high_performance_computing_applications"}, {"score": 0.004531997388646422, "phrase": "traditional_fault-tolerance_solution"}, {"score": 0.0042656009036320585, "phrase": "secondary_storage"}, {"score": 0.004014800383343256, "phrase": "optimal_checkpointing_strategy"}, {"score": 0.003962998498942111, "phrase": "checkpointing_overhead"}, {"score": 0.003928834302530914, "phrase": "high_parallel_efficiency"}, {"score": 0.003894963476923956, "phrase": "large_scale"}, {"score": 0.0038613835226952117, "phrase": "additional_fault-tolerance_mechanisms"}, {"score": 0.003525744120930142, "phrase": "processor_failure"}, {"score": 0.0034353020860809404, "phrase": "application_failure"}, {"score": 0.003361702510958392, "phrase": "resource_waste"}, {"score": 0.003275454623236867, "phrase": "higher_parallel_efficiency"}, {"score": 0.0030560920414081645, "phrase": "multiple_application_instances"}, {"score": 0.002913837945508097, "phrase": "exponential_failures"}, {"score": 0.002863762666256937, "phrase": "upper_bound"}, {"score": 0.0028267701593809877, "phrase": "expected_application_execution_time"}, {"score": 0.0027422968723193057, "phrase": "particular_checkpointing_period"}, {"score": 0.0026718978608934077, "phrase": "general_failures"}, {"score": 0.0026146109167103655, "phrase": "dynamic_programming_algorithm"}, {"score": 0.0025808284847319528, "phrase": "non-periodic_checkpoint_dates"}, {"score": 0.002525489173110693, "phrase": "empirical_periodic_checkpointing_solution"}, {"score": 0.002449997042686432, "phrase": "numerical_search"}, {"score": 0.0023257824499250653, "phrase": "non-replication_case"}, {"score": 0.0022857899334246946, "phrase": "exponential_and_weibull_failure_distributions"}, {"score": 0.0021511430180912164, "phrase": "realistic_application"}, {"score": 0.0021233361369222344, "phrase": "overhead_scenarios"}, {"score": 0.0021049977753042253, "phrase": "future_exascale_platforms"}], "paper_keywords": ["Checkpointing", " replication", " exascale platforms", " resilience"], "paper_abstract": "High performance computing applications must be resilient to faults. The traditional fault-tolerance solution is checkpoint-recovery, by which application state is saved to and recovered from secondary storage throughout execution. It has been shown that, even when using an optimal checkpointing strategy, the checkpointing overhead precludes high parallel efficiency at large scale. Additional fault-tolerance mechanisms must thus be used. Such a mechanism is replication, that is, multiple processors performing the same computation so that a processor failure does not necessarily imply an application failure. In spite of resource waste, replication can lead to higher parallel efficiency when compared to using only checkpoint-recovery at large scale. We propose to execute and checkpoint multiple application instances concurrently, an approach we term group replication. For exponential failures we give an upper bound on the expected application execution time. This bound corresponds to a particular checkpointing period that we derive. For general failures, we propose a dynamic programming algorithm to determine non-periodic checkpoint dates as well as an empirical periodic checkpointing solution whose period is found via a numerical search. Using simulation we evaluate our proposed approaches, including comparison to the non-replication case, for both exponential and Weibull failure distributions. Our broad finding is that group replication is useful in a range of realistic application and checkpointing overhead scenarios for future exascale platforms.", "paper_title": "Using group replication for resilience on exascale systems", "paper_id": "WOS:000336222700005"}