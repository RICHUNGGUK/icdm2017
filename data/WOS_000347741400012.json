{"auto_keywords": [{"score": 0.049494570200460955, "phrase": "field_accesses"}, {"score": 0.04653328525522038, "phrase": "partial_order_reduction_technique"}, {"score": 0.03117265952854613, "phrase": "static_analyses"}, {"score": 0.00481495049065317, "phrase": "concurrent_programs"}, {"score": 0.004785466029391189, "phrase": "static_analysis"}, {"score": 0.0047270350800814286, "phrase": "systematic_exploration"}, {"score": 0.004683678340162048, "phrase": "possible_thread_interleavings"}, {"score": 0.0046407174174471644, "phrase": "popular_approach"}, {"score": 0.004569985765181602, "phrase": "multi-threaded_programs"}, {"score": 0.004528062940497773, "phrase": "common_strategy"}, {"score": 0.004404577716425371, "phrase": "non-deterministic_thread_scheduling_choice"}, {"score": 0.004206175629459691, "phrase": "global_state"}, {"score": 0.004041441391385147, "phrase": "java_pathfinder"}, {"score": 0.003955416337187053, "phrase": "program_state_space"}, {"score": 0.0037310040297385346, "phrase": "current_state"}, {"score": 0.0035301176972299627, "phrase": "reduction_technique"}, {"score": 0.0034762541706024755, "phrase": "thread_choice"}, {"score": 0.0034022184461070114, "phrase": "heap_object"}, {"score": 0.0033709718729037943, "phrase": "multiple_threads"}, {"score": 0.003218977531454772, "phrase": "single_thread"}, {"score": 0.0031992346303888397, "phrase": "program_execution"}, {"score": 0.0030268930660241563, "phrase": "particular_state"}, {"score": 0.002999083173896382, "phrase": "conservative_decisions"}, {"score": 0.0028287747612440912, "phrase": "program_state"}, {"score": 0.0026681117410294708, "phrase": "state_space_traversal_algorithm"}, {"score": 0.0025952171827648665, "phrase": "unnecessary_thread_choices"}, {"score": 0.002524309110841349, "phrase": "thread_interleavings"}, {"score": 0.002462903804873404, "phrase": "distinct_behaviors"}, {"score": 0.0024029886206651573, "phrase": "proposed_analyses"}, {"score": 0.0023882384197463987, "phrase": "wala"}, {"score": 0.0023517568875393345, "phrase": "jpf._results"}, {"score": 0.002238711127939149, "phrase": "jpf."}, {"score": 0.002144252482711611, "phrase": "reasonable_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software model checking", " Concurrency", " Field accesses", " Immutability", " Static analysis"], "paper_abstract": "Systematic exploration of all possible thread interleavings is a popular approach to detect errors in multi-threaded programs. A common strategy is to use a partial order reduction technique and perform a non-deterministic thread scheduling choice only when the next instruction to be executed may possibly read or modify the global state. However, some verification frameworks and software model checkers, including Java Pathfinder (JPF), construct the program state space on-the-fly during traversal. The partial order reduction technique built into such a tool can use only the information available in the current state to determine whether the execution of a given instruction is globally-relevant. For example, the reduction technique has to make a thread choice at every field access on a heap object reachable from multiple threads, even in the case of fields that are really accessed only by a single thread during program execution, because it does not have any information about what may happen in the future after a particular state. These conservative decisions cause many redundant thread choices. We propose static analyses that identify globally-relevant field accesses more precisely. For each program state, the analyses give information about field accesses that may occur in the future after the given state. The state space traversal algorithm can use this information to soundly avoid creating unnecessary thread choices, and thus to reduce the number of thread interleavings that must be explored to cover all distinct behaviors of the given program. We implemented the proposed analyses using WALA and integrated them with JPF. Results of experiments on several Java programs show that the static analyses greatly improve the performance and scalability of JPF. In particular, it is now possible to check more complex programs than before in reasonable time. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Model checking of concurrent programs with static analysis of field accesses", "paper_id": "WOS:000347741400012"}