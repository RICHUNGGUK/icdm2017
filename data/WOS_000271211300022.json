{"auto_keywords": [{"score": 0.02654057206622627, "phrase": "smalltalk"}, {"score": 0.00481495049065317, "phrase": "previous_states"}, {"score": 0.0041586840496756474, "phrase": "programming_language"}, {"score": 0.0040385352882334235, "phrase": "histoory"}, {"score": 0.0038309141193444015, "phrase": "efficient_data_structure"}, {"score": 0.0035705347414368726, "phrase": "existing_code"}, {"score": 0.0033083236588614174, "phrase": "fine-grained_control"}, {"score": 0.0026781477395106993, "phrase": "complete_system"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Languages", " Performance", " Object Versioning", " Object-oriented Programming", " Language Design"], "paper_abstract": "Object versioning refers to how an application can have access to previous states of its objects. Implementing this mechanism is hard because it needs to be efficient in space and time, and well integrated with the programming language. This paper presents HistOOry, an object versioning system that uses an efficient data structure to store and retrieve past states. It needs only three primitives, and existing code does not need to be modified to be versioned. It provides fine-grained control over what parts of objects are versioned and when. It stores all states, past and present, in memory. Code can be executed in the past of the system and will see the complete system at that point in time. We have implemented our model in Smalltalk and used it for three applications that need versioning: checked postconditions, stateful execution tracing and a planar point location implementation. Benchmarks are provided to asses the practical complexity of our implementation.", "paper_title": "Executing Code in the Past: Efficient In-Memory Object Graph Versioning", "paper_id": "WOS:000271211300022"}