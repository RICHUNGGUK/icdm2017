{"auto_keywords": [{"score": 0.03404610894568889, "phrase": "local_states"}, {"score": 0.00481495049065317, "phrase": "fault-tolerant_distributed_executions"}, {"score": 0.004736045157669388, "phrase": "set_v"}, {"score": 0.0046970764288494764, "phrase": "active_components"}, {"score": 0.004601045179623499, "phrase": "distributed_execution"}, {"score": 0.0045443671106012405, "phrase": "storage_scheme"}, {"score": 0.00418387341007444, "phrase": "successive_global_states"}, {"score": 0.0038518661517315533, "phrase": "fixed_and_cyclic_calendar"}, {"score": 0.0037419747525425586, "phrase": "ith_step"}, {"score": 0.00371115485111022, "phrase": "block_bi"}, {"score": 0.0034170242625515854, "phrase": "bi"}, {"score": 0.0031193028729331667, "phrase": "bi_crashes"}, {"score": 0.0028596699752849682, "phrase": "failed_components"}, {"score": 0.002789528662623221, "phrase": "recent_global_state"}, {"score": 0.002546708483171714, "phrase": "storage_schemes"}, {"score": 0.002286781334850213, "phrase": "large_blocks"}, {"score": 0.002184943946549964, "phrase": "small_number"}], "paper_keywords": ["load balancing and task assignment", " distributed applications", " checkpoint/restart", " fault-tolerance", " storage/repositories", " distributed systems", " network repositories/data mining/backup"], "paper_abstract": "Given a set V of active components in charge of a distributed execution, a storage scheme is a sequence B(0), B(1),..., B(b-1) of subsets of V, where successive global states are recorded. The subsets, also called blocks, have the same size and are scheduled according to some fixed and cyclic calendar of b steps. During the ith step, block Bi is selected. Each component takes a copy of its local state and sends it to one of the components in Bi, in such a way that each component stores ( approximately) the same number of local states. Afterward, if a component of Bi crashes, all of its stored data is lost and the computation cannot continue. If there exists a block with no failed components in it, then a recent global state can be retrieved and the computation does not need to start over from the very beginning. The goal is to design storage schemes that tolerate as many crashes as possible, while trying to have each component participating in as few blocks as possible and, at the same time, working with large blocks ( so that a component in a block stores a small number of local states). In this paper, several such schemes are described and compared in terms of these measures.", "paper_title": "Cyclic storage for fault-tolerant distributed executions", "paper_id": "WOS:000239249800012"}