{"auto_keywords": [{"score": 0.041188803823205146, "phrase": "multi-core_platforms"}, {"score": 0.015719716506582538, "phrase": "java_applications"}, {"score": 0.004709224641263802, "phrase": "platforms"}, {"score": 0.004674333455266527, "phrase": "multi-core_processors"}, {"score": 0.004588531238691602, "phrase": "computer_systems"}, {"score": 0.004356535752468849, "phrase": "memory_wall"}, {"score": 0.0043083624695326745, "phrase": "limiting_factor"}, {"score": 0.004167001961564886, "phrase": "large_disparity"}, {"score": 0.0036870776660851007, "phrase": "intel_clovertown"}, {"score": 0.003659859979893989, "phrase": "amd"}, {"score": 0.003566028957296066, "phrase": "\"partially_scalable\"_benchmark_programs"}, {"score": 0.0034875380341306468, "phrase": "cpu_cores"}, {"score": 0.003360527337581911, "phrase": "software_threads"}, {"score": 0.0032622464094096463, "phrase": "scalability_curve"}, {"score": 0.0031786037839399055, "phrase": "strong_correlation"}, {"score": 0.0031317713853981064, "phrase": "object_allocation_rate"}, {"score": 0.0031086137705026483, "phrase": "memory_bus_write_traffic"}, {"score": 0.0029621948240346092, "phrase": "large_amounts"}, {"score": 0.0029077288662492894, "phrase": "almost_all_the_memory"}, {"score": 0.002822652835367827, "phrase": "write_bandwidth"}, {"score": 0.0026401983633087267, "phrase": "object_allocation"}, {"score": 0.002582032847722892, "phrase": "objects-allocation_intensive_java_applications"}, {"score": 0.0024879169065840493, "phrase": "\"allocation_wall"}, {"score": 0.002344398099179438, "phrase": "key_architecture_level"}, {"score": 0.002284234786840546, "phrase": "micro-benchmark_program"}, {"score": 0.0021927897271015657, "phrase": "\"partially_scalable\"_programs"}, {"score": 0.0021049977753042253, "phrase": "allocation_wall"}], "paper_keywords": ["Experimentation", " Performance", " Allocation", " Scalability", " Java"], "paper_abstract": "Multi-core processors are widely used in computer systems. As the performance of microprocessors greatly exceeds that of memory, the memory wall becomes a limiting factor. It is important to understand how the large disparity of speed between processor and memory influences the performance and scalability of Java applications on emerging multi-core platforms. In this paper, we studied two popular Java benchmarks, SPECjbb2005 and SPECjvm2008, on multi-core platforms including Intel Clovertown and AMD Phenom. We focus on the \"partially scalable\" benchmark programs. With smaller number of CPU cores these programs scale perfectly, but when more cores and software threads are used, the slope of the scalability curve degrades dramatically. We identified a strong correlation between scalability, object allocation rate and memory bus write traffic in our experiments with our partially scalable programs. We find that these applications allocate large amounts of memory and consume almost all the memory write bandwidth in our hardware platforms. Because the write bandwidth is so limited, we propose the following hypothesis: the scalability and performance is limited by the object allocation on emerging multi-core platforms for those objects-allocation intensive Java applications, as if these applications are running into an \"allocation wall\". In order to verify this hypothesis, several experiments are performed, including measuring key architecture level met-rics, composing a micro-benchmark program, and studying the effect of modifying some of the \"partially scalable\" programs. All the experiments strongly suggest the existence of the allocation wall.", "paper_title": "Allocation Wall: a Limiting Factor of Java Applications on Emerging Multi-core Platforms", "paper_id": "WOS:000271211300020"}