{"auto_keywords": [{"score": 0.03142156249606681, "phrase": "clam"}, {"score": 0.00481495049065317, "phrase": "multithreaded_user-level_protocols"}, {"score": 0.0046429592670444945, "phrase": "appealing_features"}, {"score": 0.004547438494330851, "phrase": "unix_kernels"}, {"score": 0.004430784015995566, "phrase": "per-process_basis"}, {"score": 0.004294724955301414, "phrase": "asynchronous_events"}, {"score": 0.004206338218873218, "phrase": "per-process_signals"}, {"score": 0.004055998173160551, "phrase": "complex_multithreaded_applications"}, {"score": 0.0038304902197108643, "phrase": "finer_granularity"}, {"score": 0.0034519997658752598, "phrase": "user-level_threads"}, {"score": 0.003380897678672156, "phrase": "ariadne_system"}, {"score": 0.002619748321217153, "phrase": "efficient_mechanism"}, {"score": 0.002579140290642792, "phrase": "thread_context-switching"}, {"score": 0.0024868131939261716, "phrase": "multithreaded_protocols"}, {"score": 0.00239778324260337, "phrase": "signal-handling_mechanisms"}, {"score": 0.002311933249234786, "phrase": "race_conditions"}, {"score": 0.0022407927161620855, "phrase": "efficient_and_flexible_interface"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["timers", " continuations", " multithreading", " parallel protocols", " user-level protocols", " asynchronous"], "paper_abstract": "Precise timing and asynchronous I/O are appealing features for many applications. Unix kernels provide such features on a per-process basis, using signals to communicate asynchronous events to applications. Per-process signals and timers are grossly inadequate for complex multithreaded applications that require per-thread signals and timers that operate at finer granularity. To respond to this need, we present a scheme that integrates asynchronous (Unix) signals with user-level threads, using the ARIADNE system as a platform. This is done with a view towards support for portable, multithreaded, and multiprotocol distributed applications, namely the CLAM (connectionless, lightweight, and multiway) communications library. In the same context, we propose the use of continuations as an efficient mechanism for reducing thread context-switching and busy-wait overheads in multithreaded protocols. Our proposal for integrating timers and signal-handling mechanisms not only solves problems related to race conditions, but also offers an efficient and flexible interface for timing and signalling threads. Copyright (C) 2006 John Wiley & Sons, Ltd.", "paper_title": "Signals, timers, and continuations for multithreaded user-level protocols", "paper_id": "WOS:000237410500001"}