{"auto_keywords": [{"score": 0.0448268450297557, "phrase": "rta"}, {"score": 0.0065591609440361145, "phrase": "rewrite_closure"}, {"score": 0.006481229647127024, "phrase": "rta_language"}, {"score": 0.0057737603634154195, "phrase": "tree_automata"}, {"score": 0.00481495049065317, "phrase": "rigid_tree_automata"}, {"score": 0.004663636232080366, "phrase": "standard_bottom-up_automata"}, {"score": 0.004571478018964363, "phrase": "distinguished_states"}, {"score": 0.0044990584725586764, "phrase": "rigid_states"}, {"score": 0.004023120753104693, "phrase": "local_and_global_tests"}, {"score": 0.003927848423072668, "phrase": "non-linear_tree_pattern_matching"}, {"score": 0.003655389115856843, "phrase": "boolean"}, {"score": 0.0034289106230496816, "phrase": "emptiness_problem"}, {"score": 0.003361069456060196, "phrase": "linear_time"}, {"score": 0.0031532677506660475, "phrase": "np"}, {"score": 0.002898930717812433, "phrase": "restricted_family"}, {"score": 0.0025202582748972122, "phrase": "model_checking_procedures"}, {"score": 0.0024901940672239784, "phrase": "finite_tree_automata_techniques"}, {"score": 0.0024117603727471654, "phrase": "communicating_processes"}, {"score": 0.0022352169832099153, "phrase": "local_and_global_equality_tests"}, {"score": 0.0021821915946356168, "phrase": "horn_clause_formalisms"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Tree automata", " Symbol constraints", " Term rewriting", " Verification"], "paper_abstract": "We introduce the class of rigid tree automata (RTA), an extension of standard bottom-up automata on ranked trees with distinguished states called rigid. Rigid states define a restriction on the computation of RTA on trees: RTA can test for equality in subtrees reaching the same rigid state. RTA are able to perform local and global tests of equality between subtrees, non-linear tree pattern matching, and some inequality and disequality tests as well. Properties like determinism, pumping lemma, Boolean closure, and several decision problems are studied in detail. In particular, the emptiness problem is shown decidable in linear time for RTA whereas membership of a given tree to the language of a given RTA is NP-complete. Our main result is the decidability of whether a given tree belongs to the rewrite closure of an RTA language under a restricted family of term rewriting systems, whereas this closure is not an RTA language. This result, one of the first on rewrite closure of languages of tree automata with constraints, is enabling the extension of model checking procedures based on finite tree automata techniques, in particular for the verification of communicating processes with several local non-rewritable memories, like security protocols. Finally, a comparison of RTA with several classes of tree automata with local and global equality tests, with dag automata and Horn clause formalisms is also provided. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "Rigid tree automata and applications", "paper_id": "WOS:000287382300016"}