{"auto_keywords": [{"score": 0.046114804435266145, "phrase": "multithreaded_java_programs"}, {"score": 0.00481495049065317, "phrase": "java_programs"}, {"score": 0.00467855218490191, "phrase": "desktop_grid"}, {"score": 0.004481132747216135, "phrase": "introductory_optimization"}, {"score": 0.004230749292148046, "phrase": "java_virtual_machines"}, {"score": 0.004081385289516914, "phrase": "desktop_grids"}, {"score": 0.00374399358035391, "phrase": "first_stage"}, {"score": 0.0036640806940633373, "phrase": "clustering_algorithm"}, {"score": 0.0035346515636097533, "phrase": "macro_data_flow_graphs"}, {"score": 0.003105305189036267, "phrase": "control_dependencies"}, {"score": 0.0030171910207671205, "phrase": "conditional_branch_instructions"}, {"score": 0.002952745241052452, "phrase": "branch_statistics"}, {"score": 0.002889672003089062, "phrase": "execution_traces"}, {"score": 0.00284837132359445, "phrase": "representative_sets"}, {"score": 0.002727967804120323, "phrase": "second_stage"}, {"score": 0.002669683153809812, "phrase": "list_scheduling"}, {"score": 0.002396371892825691, "phrase": "mutually_exclusive_paths"}, {"score": 0.0023451553255837317, "phrase": "conditional_branch_nodes"}, {"score": 0.0022950308685133224, "phrase": "presented_object_placement_optimization_algorithm"}, {"score": 0.0021979660485319523, "phrase": "dg-adaj_environment"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "A method for an introductory optimization of multithreaded Java programs for execution on clusters of Java Virtual Machines (JVMs) inside desktop grids is presented. It is composed of two stages. In the first stage, a clustering algorithm is applied to extended macro data flow graphs generated on the basis of the byte-code compiled for multithreaded Java programs. These graphs account for data and control dependencies in programs including conditional branch instructions annotated by branch statistics driven from execution traces for representative sets of data. In the second stage, a list scheduling is performed based on the Earliest Task First (ETF) heuristics in which node mapping on JVMs accounts for mutually exclusive paths outgoing from conditional branch nodes. The presented object placement optimization algorithm is a part of the DG-ADAJ environment. (c) 2007 Elsevier B.V. All rights reserved.", "paper_title": "Byte-code scheduling of Java programs with branches for desktop grid", "paper_id": "WOS:000248934800007"}