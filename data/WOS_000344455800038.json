{"auto_keywords": [{"score": 0.04954397446159371, "phrase": "syntactic_sugar"}, {"score": 0.01414301060036108, "phrase": "core_language"}, {"score": 0.009515819788214934, "phrase": "surface_language"}, {"score": 0.00481495049065317, "phrase": "evaluation_sequences"}, {"score": 0.004603244077348199, "phrase": "language_technology"}, {"score": 0.004230956171850591, "phrase": "domain-specific_languages"}, {"score": 0.00378080526397273, "phrase": "resulting_programs"}, {"score": 0.003378385493203297, "phrase": "user's_source_program"}, {"score": 0.003087419032091453, "phrase": "reduction_steps"}, {"score": 0.0030017207229983385, "phrase": "surface_syntax"}, {"score": 0.0027741761880779535, "phrase": "computed_steps"}, {"score": 0.0022396199331882476, "phrase": "coq"}], "paper_keywords": ["Programming Languages", " Syntactic Sugar", " Macros", " Evaluation", " Debugging", " Resugaring"], "paper_abstract": "Syntactic sugar is pervasive in language technology. It is used to shrink the size of a core language; to define domain-specific languages; and even to let programmers extend their language. Unfortunately, syntactic sugar is eliminated by transformation, so the resulting programs become unfamiliar to authors. Thus, it comes at a price: it obscures the relationship between the user's source program and the program being evaluated. We address this problem by showing how to compute reduction steps in terms of the surface syntax. Each step in the surface language emulates one or more steps in the core language. The computed steps hide the transformation, thus maintaining the abstraction provided by the surface language. We make these statements about emulation and abstraction precise, prove that they hold in our formalism, and verify part of the system in Coq. We have implemented this work and applied it to three very different languages.", "paper_title": "Resugaring: Lifting Evaluation Sequences through Syntactic Sugar", "paper_id": "WOS:000344455800038"}