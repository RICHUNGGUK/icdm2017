{"auto_keywords": [{"score": 0.049791066928346464, "phrase": "induction_pointers"}, {"score": 0.03803007121708631, "phrase": "correct_aopj"}, {"score": 0.00481495049065317, "phrase": "correct_increment"}, {"score": 0.004574342831225094, "phrase": "induction_variables"}, {"score": 0.004425072111844721, "phrase": "fixed_amount"}, {"score": 0.004254988591788044, "phrase": "ips"}, {"score": 0.004191200981137508, "phrase": "previous_works"}, {"score": 0.00406663414150229, "phrase": "correct_amount"}, {"score": 0.003910193916677954, "phrase": "loop_unrolling"}, {"score": 0.0036589868713755185, "phrase": "main_difficulty"}, {"score": 0.0034864522257187242, "phrase": "data_structure"}, {"score": 0.0032920678776655783, "phrase": "simple_advancement"}, {"score": 0.0027298319171606498, "phrase": "next_element"}, {"score": 0.002478225374613311, "phrase": "proposed_method"}, {"score": 0.0024117251593529883, "phrase": "accompanying_loop_unrolling_technique"}, {"score": 0.0023755529073496394, "phrase": "suif_compiler"}, {"score": 0.002361236012575149, "phrase": "c_programs"}, {"score": 0.0023328599525181707, "phrase": "automatic_unrolling"}, {"score": 0.002143529653780496, "phrase": "embedded_systems"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Unrolling", " Pointers", " Optimizations"], "paper_abstract": "Induction pointers (IPs) are the analogue of induction variables (IVs), namely, pointers that are advanced by a fixed amount every iteration of a loop (e.g., p = p -> next -> next). Although IPs have been considered in previous works, there is no algorithm to properly compute the correct amount of pointer jumping (AOPJ) by which IPs should be advanced if loop unrolling is to be applied to loops of the form while(p){...p = p -> next -> next;}. The main difficulty in computing the correct AOPJ of IPs is that pointers can be used to modify the data structure that is traversed by the loop (e.g., adding/removing/by-passing elements). Consequently, a simple advancement p = p -> next in a loop does not necessarily mean that p is advanced by one element every iteration. This situation contrasts with the use of IVs, which cannot change the structure of arrays that are traversed by loops. Hence, if i is an IV, A[i + 1] will always mean the next element of An, while if p = p -> next; is preceded by p -> next = q; it may be advanced by k>1 elements at every iteration. The proposed method for computing the correct AOPJ of IPs and an accompanying loop unrolling technique were implemented in the SUIF compiler for C programs. Our experiments with automatic unrolling of loops with pointers yielded an improvement of 3-5% for a set of SPEC2000 programs. Experiments with a VLIW IA-64 machine also verified the usefulness of this approach for embedded systems. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Computing the correct Increment of Induction Pointers with application to loop unrolling", "paper_id": "WOS:000285814400002"}