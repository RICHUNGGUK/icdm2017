{"auto_keywords": [{"score": 0.03329116510010126, "phrase": "length_m"}, {"score": 0.00481495049065317, "phrase": "text_collections"}, {"score": 0.004753512932910936, "phrase": "compressed_format"}, {"score": 0.004672808182229058, "phrase": "arbitrary_portions"}, {"score": 0.004476963405985556, "phrase": "current_self-indexes"}, {"score": 0.004307700591183651, "phrase": "highly_repetitive_text_collections"}, {"score": 0.0041984140090404985, "phrase": "grammar-based_compression"}, {"score": 0.004005176784823524, "phrase": "first_grammar-based_self-index"}, {"score": 0.003920295222165263, "phrase": "straight-line_programs"}, {"score": 0.0038207994186834015, "phrase": "rather_general_kind"}, {"score": 0.003788196352457501, "phrase": "context-free_grammars"}, {"score": 0.003692040748097991, "phrase": "n_rules"}, {"score": 0.0036448787596988423, "phrase": "text_t"}, {"score": 0.003177687211289478, "phrase": "text_substring"}, {"score": 0.0029416448256236057, "phrase": "occ_occurrences"}, {"score": 0.002904040426340639, "phrase": "pattern_string"}, {"score": 0.002564360070426064, "phrase": "parse_tree"}, {"score": 0.002531569068012135, "phrase": "slp."}, {"score": 0.0022067604433257814, "phrase": "plain_array"}], "paper_keywords": ["Grammar-based Compression", " Straight-Line Programs", " Self-Indexes", " Compressed Text Databases", " Highly Repetitive Sequences", " Pattern Matching", " Data Structures"], "paper_abstract": "Self-indexes aim at representing text collections in a compressed format that allows extracting arbitrary portions and also offers indexed searching on the collection. Current self-indexes are unable of fully exploiting the redundancy of highly repetitive text collections that arise in several applications. Grammar-based compression is well suited to exploit such repetitiveness. We introduce the first grammar-based self-index. It builds on Straight-Line Programs (SLPs), a rather general kind of context-free grammars. If an SLP of n rules represents a text T [1, u], then an SLP-compressed representation of T requires 2n log(2) n bits. For that same SLP, our self-index takes O(n log n) + n log(2) u bits. It extracts any text substring of length m in time O ((m + h) log n), and finds occ occurrences of a pattern string of length m in time O ((m (m + h) + h occ) log n), where h is the height of the parse tree of the SLP. No previous grammar representation had achieved o(n) search time. As byproducts we introduce (i) a representation of SLPs that takes 2n log(2) n (1 + o(1)) bits and efficiently supports more operations than a plain array of rules; (ii) a representation for binary relations with labels supporting various extended queries; (iii) a generalization of our self-index to grammar compressors that reduce T to a sequence of terminals and nonterminals, such as Re-Pair and LZ78.", "paper_title": "Self-Indexed Grammar-Based Compression", "paper_id": "WOS:000298376700003"}