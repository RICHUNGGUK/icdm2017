{"auto_keywords": [{"score": 0.04958720442967608, "phrase": "approximate_string_matching"}, {"score": 0.00481495049065317, "phrase": "fpga-based_accelerators"}, {"score": 0.004716520738331953, "phrase": "dynamic_programming"}, {"score": 0.004596295252559861, "phrase": "large_family"}, {"score": 0.004549063619065006, "phrase": "different_algorithms"}, {"score": 0.004297795905522757, "phrase": "hardware_utilization"}, {"score": 0.004188198923320451, "phrase": "impressive_speed-ups"}, {"score": 0.004060350364088702, "phrase": "point_solutions"}, {"score": 0.003623949225126944, "phrase": "hardware_description"}, {"score": 0.0035497797026638033, "phrase": "broad_range"}, {"score": 0.003513264130359459, "phrase": "behavioral_options"}, {"score": 0.003405948098114941, "phrase": "feature_bloat"}, {"score": 0.003234299589505403, "phrase": "different_parts"}, {"score": 0.0031845067058084583, "phrase": "approximate_string_matching_problem"}, {"score": 0.0029467742734417255, "phrase": "maximum_use"}, {"score": 0.0029013950320185573, "phrase": "fpga_fabric"}, {"score": 0.002841971477743441, "phrase": "application's_specific_resource_requirements"}, {"score": 0.0027837615811247963, "phrase": "interchangeable_implementations"}, {"score": 0.0027126684113045756, "phrase": "component_type"}, {"score": 0.0025892330566358503, "phrase": "efficient_generation"}, {"score": 0.0023834640793589414, "phrase": "high_performance"}, {"score": 0.002286781334850213, "phrase": "serial_reference_codes"}, {"score": 0.0021601997088758957, "phrase": "high-end_pc."}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "Dynamic programming for approximate string matching is a large family of different algorithms, which vary significantly in purpose, complexity, and hardware utilization. Many implementations have reported impressive speed-ups, but have typically been point solutions - highly specialized and addressing only one or a few of the many possible options. The problem to be solved is creating a hardware description that implements a broad range of behavioral options without losing efficiency due to feature bloat. We report a set of three component types that address different parts of the approximate string matching problem. This allows each application to choose the feature set required, then make maximum use of the FPGA fabric according to that application's specific resource requirements. Multiple, interchangeable implementations are available for each component type. We show that these methods allow the efficient generation of a large, if not complete, family of accelerators for this application. This flexibility was obtained while retaining high performance: we have evaluated a sample against serial reference codes and found speed-ups of from 150x to 400x over a high-end PC. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "Families of FPGA-based accelerators for approximate string matching", "paper_id": "WOS:000245320700007"}