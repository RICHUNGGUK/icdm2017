{"auto_keywords": [{"score": 0.03228044674175594, "phrase": "bl-mcpa"}, {"score": 0.01376710148673043, "phrase": "pipeline_registers"}, {"score": 0.011429380042196473, "phrase": "false_positives"}, {"score": 0.008226573206203354, "phrase": "execution_latency"}, {"score": 0.00481495049065317, "phrase": "behavioral-level_multicycle_path_analysis"}, {"score": 0.004523103062368843, "phrase": "behavioral-level_specifications"}, {"score": 0.004306205029641728, "phrase": "hls_tools"}, {"score": 0.004267896572751978, "phrase": "datapath_pipelines"}, {"score": 0.004154995396099332, "phrase": "combinational_logic"}, {"score": 0.004118026552723285, "phrase": "single-cycle_segments"}, {"score": 0.003973398317120165, "phrase": "available_cycles"}, {"score": 0.0039380388343479384, "phrase": "signal_propagation"}, {"score": 0.003732368382223596, "phrase": "rt-level_timing_analyses"}, {"score": 0.003459191419478298, "phrase": "critical-path_analyses"}, {"score": 0.00341309513558946, "phrase": "rtl_synthesis_tools"}, {"score": 0.003367611042980526, "phrase": "real_critical_paths"}, {"score": 0.0032059442984238664, "phrase": "hardware_quality"}, {"score": 0.0030794433253250476, "phrase": "efficient_behavioral-level_multicycle_path_analysis"}, {"score": 0.002984504445973107, "phrase": "control-data_flow_information"}, {"score": 0.002905454531687249, "phrase": "multicycle_path_analysis"}, {"score": 0.0025518429503461736, "phrase": "unnecessary_pipeline_register_insertion"}, {"score": 0.0023021895404322767, "phrase": "large_multiplexers"}, {"score": 0.002251227801482381, "phrase": "pipelined_mux-trees"}, {"score": 0.0021049977753042253, "phrase": "large_muxs"}], "paper_keywords": ["Chaining", " high-level synthesis (HLS)", " performance optimization", " pipelining", " timing analysis"], "paper_abstract": "High-level synthesis (HLS) tools generate register-transfer level (RTL) hardware descriptions from behavioral-level specifications through resource allocation, scheduling and binding. Traditionally, HLS tools build datapath pipelines by inserting pipeline registers to break combinational logic into single-cycle segments; accurately analyzing that the number of available cycles for signal propagation is proven to be infeasible at the RT-level. Thus, RT-level timing analyses must pessimistically assume each path has at most one cycle for signal propagation. This leads to false positives in critical-path analyses, prevents RTL synthesis tools from optimizing real critical paths, and forces HLS flows to insert pipeline registers without improving hardware quality. In this paper, we present an efficient behavioral-level multicycle path analysis (BL-MCPA) algorithm that leverages control-data flow information to reduce time complexity of multicycle path analysis from exponential to polynomial. BL-MCPA helps eliminate false positives in timing analysis, and improves the reported f(max) by 15% on average. With BL-MCPA, we avoid unnecessary pipeline register insertion, and reduce execution latency by 25% and register usage by 29% under a user f(max) constraint of 300 MHz. Using BL-MCPA, we replace large multiplexers (MUXs) by pipelined MUX-trees and reduce execution latency of hardware by up to 67% on designs whose performance is limited by the large MUXs.", "paper_title": "High-Level Synthesis With Behavioral-Level Multicycle Path Analysis", "paper_id": "WOS:000345518500006"}