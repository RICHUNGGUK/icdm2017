{"auto_keywords": [{"score": 0.045965832953546316, "phrase": "term_equivalence"}, {"score": 0.03413008367759664, "phrase": "decidable_type_checking"}, {"score": 0.008132133364104187, "phrase": "abstract_relation"}, {"score": 0.00481495049065317, "phrase": "type_equivalence"}, {"score": 0.004688823162073856, "phrase": "typed_language"}, {"score": 0.004642377903273107, "phrase": "dependently-typed_languages"}, {"score": 0.004286931271697226, "phrase": "type_checking"}, {"score": 0.004216362268148017, "phrase": "term_equivalence_relation"}, {"score": 0.004188459638572375, "phrase": "almost_all_dependently-typed_languages"}, {"score": 0.004024895854039862, "phrase": "coq"}, {"score": 0.003998223112665124, "phrase": "epigram"}, {"score": 0.003971761552420796, "phrase": "agda"}, {"score": 0.0037165246288857925, "phrase": "dml"}, {"score": 0.0036919224527115716, "phrase": "ats"}, {"score": 0.003667468902144262, "phrase": "omega_mega"}, {"score": 0.0036311253824878056, "phrase": "haskell"}, {"score": 0.003595097948724078, "phrase": "nonterminating_computation"}, {"score": 0.003386412845243943, "phrase": "terminating_index_language"}, {"score": 0.003352825186671963, "phrase": "singleton_types"}, {"score": 0.002974760986688745, "phrase": "termination_analyses"}, {"score": 0.002955050521440921, "phrase": "dependently_typed_programs"}, {"score": 0.002925728709297618, "phrase": "total_correctness_properties"}, {"score": 0.002830068550982961, "phrase": "type_safety"}, {"score": 0.0027284410545226306, "phrase": "decidable_approximation"}, {"score": 0.002710358243468008, "phrase": "program_equivalence"}, {"score": 0.002595698433525986, "phrase": "different_approach"}, {"score": 0.0025528981558942372, "phrase": "fixed_notion"}, {"score": 0.0023886223145816376, "phrase": "novel_set"}, {"score": 0.0023727863021828547, "phrase": "typing_rules"}, {"score": 0.0022648286660146314, "phrase": "progress_lemmas"}, {"score": 0.0021980296285911915, "phrase": "valid_instantiations"}, {"score": 0.002133196554995389, "phrase": "contextual_equivalence"}, {"score": 0.0021049977753042253, "phrase": "exotic_equivalences"}], "paper_keywords": ["Design", " Languages", " Theory", " Dependent types", " Program equivalence"], "paper_abstract": "The definition of type equivalence is one of the most important design issues for any typed language. In dependently-typed languages, because terms appear in types, this definition must rely on a definition of term equivalence. In that case, decidability of type checking requires decidability for the term equivalence relation. Almost all dependently-typed languages require this relation to be decidable. Some, such as Coq, Epigram or Agda, do so by employing analyses to force all programs to terminate. Conversely, others, such as DML, ATS, Omega mega, or Haskell, allow nonterminating computation, but do not allow those terms to appear in types. Instead, they identify a terminating index language and use singleton types to connect indices to computation. In both cases, decidable type checking comes at a cost, in terms of complexity and expressiveness. Conversely, the benefits to be gained by decidable type checking are modest. Termination analyses allow dependently typed programs to verify total correctness properties. However, decidable type checking is not a prerequisite for type safety. Furthermore, decidability does not imply tractability. A decidable approximation of program equivalence may not be useful in practice. Therefore, we take a different approach: instead of a fixed notion for term equivalence, we parameterize our type system with an abstract relation that is not necessarily decidable. We then design a novel set of typing rules that require only weak properties of this abstract relation in the proof of the preservation and progress lemmas. This design provides flexibility: we compare valid instantiations of term equivalence which range from beta-equivalence, to contextual equivalence, to some exotic equivalences.", "paper_title": "Dependent Types and Program Equivalence", "paper_id": "WOS:000274028100025"}