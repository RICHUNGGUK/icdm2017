{"auto_keywords": [{"score": 0.03402661398595979, "phrase": "jit_compilation"}, {"score": 0.027140291257134692, "phrase": "specialized_instructions"}, {"score": 0.00481495049065317, "phrase": "hardware_acceleration_of_red-black_tree_management"}, {"score": 0.0045748683993128425, "phrase": "everlasting_consumer_demand"}, {"score": 0.004195418010131832, "phrase": "different_computing_resources"}, {"score": 0.003970439654470374, "phrase": "software_designers"}, {"score": 0.003923815926819606, "phrase": "significant_performance_and_portability_issues"}, {"score": 0.003833861798883707, "phrase": "software"}, {"score": 0.003742711659195878, "phrase": "virtualization_technologies"}, {"score": 0.0033518704336033874, "phrase": "runtime_optimized_code"}, {"score": 0.0031100973266506163, "phrase": "execution_speedups"}, {"score": 0.003085681391556093, "phrase": "generated_code"}, {"score": 0.0029781530607129653, "phrase": "jit_compilation_phases"}, {"score": 0.002763261749602258, "phrase": "performance_analysis"}, {"score": 0.0027415611720084006, "phrase": "different_jit_compilation_technologies"}, {"score": 0.002688050388891007, "phrase": "hardware_and_software_optimization_opportunities"}, {"score": 0.002573965014439041, "phrase": "dedicated_processor"}, {"score": 0.002533687835358909, "phrase": "critical_functions"}, {"score": 0.0025137856138000014, "phrase": "jit_compilers"}, {"score": 0.00241658945942583, "phrase": "associative_arrays"}, {"score": 0.0023976048394496446, "phrase": "dynamic_memory_allocation"}, {"score": 0.0023507916951658455, "phrase": "llvm_framework"}, {"score": 0.002286781334850213, "phrase": "code_generator's_execution_time"}, {"score": 0.002224510044064184, "phrase": "standard_libraries"}, {"score": 0.0021049977753042253, "phrase": "wider_range"}], "paper_keywords": ["Hardware acceleration", " Red-Black trees", " Associative arrays", " JIT compilation", " Virtualization", " Embedded systems"], "paper_abstract": "Due to the everlasting consumer demand for more complex applications, embedded systems have evolved both in terms of complexity and heterogeneity. The architecture of such systems often includes several kinds of different computing resources (DSPs, GPUs, etc.). As a consequence, software designers are facing significant performance and portability issues to target these devices. Software relies more and more on virtualization technologies to maximize portability of applications. In order to balance portability and performance, most virtualization technologies leverage Just-in-time (JIT) compilation to provide runtime optimized code from portable one. Nevertheless, the efficiency of JIT compilation depends on the ability to compensate its overhead with execution speedups of generated code. While most research efforts focus on limiting overhead of JIT compilation phases by reducing their occurrences, this paper investigates opportunities of speeding up JIT compilation itself. We first present a performance analysis of different JIT compilation technologies in order to identify hardware and software optimization opportunities. Second, we propose a solution based on a dedicated processor with specialized instructions for critical functions of JIT compilers. These specialized instructions provide an average 5x speedup on manipulations of associative arrays and dynamic memory allocation. Based on the LLVM framework, we show a 15% overall speedup on code generator's execution time. Because our specialized instructions are hidden behind standard libraries, we also argue that these instructions may be transparently reused for a wider range of applications.", "paper_title": "Hardware Acceleration of Red-Black Tree Management and Application to Just-In-Time Compilation", "paper_id": "WOS:000341693600006"}