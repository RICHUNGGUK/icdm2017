{"auto_keywords": [{"score": 0.028726859758345397, "phrase": "regionwiz"}, {"score": 0.007566522226969573, "phrase": "dangling_pointers"}, {"score": 0.006978711066182405, "phrase": "large_c_programs"}, {"score": 0.006216815076859503, "phrase": "consistency_rules"}, {"score": 0.005645476416903348, "phrase": "region_lifetime_consistency"}, {"score": 0.00481495049065317, "phrase": "safe_region-based_memory_management"}, {"score": 0.004777917315737992, "phrase": "region-based_memory_management"}, {"score": 0.004668510065740584, "phrase": "systems_software"}, {"score": 0.004632597963417253, "phrase": "better_organization"}, {"score": 0.004355026964936104, "phrase": "different_lifetimes"}, {"score": 0.003833749901796579, "phrase": "consistent_placement"}, {"score": 0.0032341432727280707, "phrase": "static_analysis_tool_regionwiz"}, {"score": 0.0030401074516310184, "phrase": "analysis_framework"}, {"score": 0.002902236818129282, "phrase": "conditional_correlations"}, {"score": 0.0028356575042385156, "phrase": "succinct_formalization"}, {"score": 0.002792119634261638, "phrase": "region_lifetimes"}, {"score": 0.0027599042621376624, "phrase": "memory_safety"}, {"score": 0.0026347074232350503, "phrase": "efficient_static_analysis"}, {"score": 0.0025942468561537682, "phrase": "conditional_correlation"}, {"score": 0.002382541887825168, "phrase": "six_real-world_software_packages"}, {"score": 0.0023459748101467793, "phrase": "rc"}, {"score": 0.0023188652648490874, "phrase": "apache_web_server"}, {"score": 0.002292097733181405, "phrase": "subversion_version_control_system"}], "paper_keywords": ["experimentation", " reliability", " verification", " region", " conditional correlation", " program analysis", " error detection", " memory management"], "paper_abstract": "Region-based memory management is a popular scheme in systems software for better organization and performance. In the scheme, a developer constructs a hierarchy of regions of different lifetimes and allocates objects in regions. When the developer deletes a region, the runtime will recursively delete all its subregions and simultaneously reclaim objects in the regions. The developer must construct a consistent placement of objects in regions; otherwise, if a region that contains pointers to other regions is not always deleted before pointees, an inconsistency will surface and cause dangling pointers, which may lead to either crashes or leaks. This paper presents a static analysis tool RegionWiz that can find such lifetime inconsistencies in large C programs using regions. The tool is based on an analysis framework that generalizes the relations and constraints over regions and objects as conditional correlations. This framework allows a succinct formalization of consistency rules for region lifetimes, preserving memory safety and avoiding dangling pointers. RegionWiz uses these consistency rules to implement an efficient static analysis to compute the conditional correlation and reason about region lifetime consistency; the analysis is based on a context-sensitive, field-sensitive pointer analysis with heap cloning. Experiments with applying RegionWiz to six real-world software packages ( including the RC compiler, Apache web server, and Subversion version control system) with two different region-based memory management interfaces show that RegionWiz can reason about region lifetime consistency in large C programs. The experiments also show that RegionWiz can find several previously unknown inconsistency bugs in these packages.", "paper_title": "Conditional correlation analysis for safe region-based memory management", "paper_id": "WOS:000257820400005"}