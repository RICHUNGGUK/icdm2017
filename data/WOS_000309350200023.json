{"auto_keywords": [{"score": 0.03862495247285584, "phrase": "deadlock_avoidance"}, {"score": 0.035142389611168834, "phrase": "dummy_messages"}, {"score": 0.00481495049065317, "phrase": "efficient_deadlock_avoidance_for_streaming_computation"}, {"score": 0.004743164872278112, "phrase": "parallel_streaming_computations"}, {"score": 0.00419016653753787, "phrase": "individual_nodes"}, {"score": 0.003975416846030462, "phrase": "data-dependent_manner"}, {"score": 0.003800093834008562, "phrase": "finite_buffers"}, {"score": 0.0036052633308076933, "phrase": "data_streams"}, {"score": 0.0035514484574435574, "phrase": "occasional_dummy_messages"}, {"score": 0.003485304124598714, "phrase": "general_dag_topologies"}, {"score": 0.003446208270665051, "phrase": "polynomial_time_algorithm"}, {"score": 0.0030097975788892896, "phrase": "large_class"}, {"score": 0.002987236799291296, "phrase": "dag_topologies"}, {"score": 0.002920561105784389, "phrase": "new_method"}, {"score": 0.0028877818105020434, "phrase": "dummy_message"}, {"score": 0.0026483647033436674, "phrase": "efficient_algorithms"}, {"score": 0.002628506002255396, "phrase": "dummy_interval_computation"}, {"score": 0.0026087958216676702, "phrase": "series-parallel_dags"}, {"score": 0.002531418327080538, "phrase": "larger_graph_family"}, {"score": 0.0024196235355517827, "phrase": "undirected_cycle"}, {"score": 0.0022696277881969896, "phrase": "large_set"}, {"score": 0.002252602622785975, "phrase": "application_topologies"}, {"score": 0.0021693692831601745, "phrase": "streaming_model"}, {"score": 0.0021049977753042253, "phrase": "reasonable_overhead"}], "paper_keywords": ["Algorithms", " Design", " Theory", " Deadlock Avoidance", " Graph Theory", " Streaming Computation"], "paper_abstract": "Parallel streaming computations have been studied extensively, and many languages, libraries, and systems have been designed to support this model of computation. In particular, we consider acyclic streaming computations in which individual nodes can choose to filter, or discard, some of their inputs in a data-dependent manner. In these applications, if the channels between nodes have finite buffers, the computation can deadlock. One method of deadlock avoidance is to augment the data streams between nodes with occasional dummy messages; however, for general DAG topologies, no polynomial time algorithm is known to compute the intervals at which dummy messages must be sent to avoid deadlock. In this paper, we show that deadlock avoidance for streaming computations with filtering can be performed efficiently for a large class of DAG topologies. We first present a new method where each dummy message is tagged with a destination, so as to reduce the number of dummy messages sent over the network. We then give efficient algorithms for dummy interval computation in series-parallel DAGs. We finally generalize our results to a larger graph family, which we call the CS4 DAGs, in which every undirected Cycle is Single-Source and Single-Sink (CS4). Our results show that, for a large set of application topologies that are both intuitively useful and formalizable, the streaming model with filtering can be implemented safely with reasonable overhead.", "paper_title": "Efficient Deadlock Avoidance for Streaming Computation with Filtering", "paper_id": "WOS:000309350200023"}