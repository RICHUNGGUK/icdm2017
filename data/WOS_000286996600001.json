{"auto_keywords": [{"score": 0.029690019141265074, "phrase": "practical_programs"}, {"score": 0.00481495049065317, "phrase": "ancestor_stacks"}, {"score": 0.004662913362513954, "phrase": "partial_evaluation"}, {"score": 0.0046256566852302256, "phrase": "logic_programs"}, {"score": 0.00455202992136173, "phrase": "well_quasi_orders"}, {"score": 0.00401961206251868, "phrase": "specialization_power"}, {"score": 0.003549245218355768, "phrase": "ancestor_relation"}, {"score": 0.0034926916198124484, "phrase": "significant_overhead"}, {"score": 0.0031590250068577867, "phrase": "stack-based_implementation"}, {"score": 0.0029504765287722465, "phrase": "local_unfolding"}, {"score": 0.002857143106182505, "phrase": "depth-first_strategies"}, {"score": 0.0027556576784848207, "phrase": "assertion-based_techniques"}, {"score": 0.0024922258873137093, "phrase": "leftmost_unfolding"}, {"score": 0.0023558375480288297, "phrase": "practical_partial_evaluator"}, {"score": 0.0021049977753042253, "phrase": "traditional_tree-based_implementations"}], "paper_keywords": ["partial evaluation", " partial deduction", " logic programming", " prolog", " SLD semantics", " local unfolding"], "paper_abstract": "The most successful unfolding rules used nowadays in the partial evaluation of logic programs are based on well quasi orders (wqo) applied over (covering) ancestors, i.e., a subsequence of the atoms selected during a derivation. Ancestor (sub)sequences are used to increase the specialization power of unfolding while still guaranteeing termination and also to reduce the number of atoms for which the wqo has to be checked. Unfortunately, maintaining the structure of the ancestor relation during unfolding introduces significant overhead. We propose an efficient, practical local unfolding rule based on the notion of covering ancestors which can be used in combination with a wqo and allows a stack-based implementation without losing any opportunities for specialization. Using our technique, certain nonleftmost unfoldings are allowed as long as local unfolding is performed, i.e., we cover depth-first strategies. To deal with practical programs, we propose assertion-based techniques which allow our approach to treat programs that include (Prolog) built-ins and external predicates in a very extensible manner, for the case of leftmost unfolding. Finally, we report on our implementation of these techniques embedded in a practical partial evaluator, which shows that our techniques, in addition to dealing with practical programs, are also significantly more efficient in time and somewhat more efficient in memory than traditional tree-based implementations.", "paper_title": "Efficient local unfolding with ancestor stacks", "paper_id": "WOS:000286996600001"}