{"auto_keywords": [{"score": 0.022841033938614086, "phrase": "python"}, {"score": 0.00481495049065317, "phrase": "simple_inductive"}, {"score": 0.004579005794486596, "phrase": "high-level_specification"}, {"score": 0.004502943680955863, "phrase": "low-level_programming_language"}, {"score": 0.00428222231579898, "phrase": "efficient_program"}, {"score": 0.0039822874870125095, "phrase": "new_algorithmic_methodology"}, {"score": 0.0039380388343479384, "phrase": "inductive_synthesis"}, {"score": 0.003724034990158436, "phrase": "second_order_logic"}, {"score": 0.003561205990687285, "phrase": "small_application-specific_logics"}, {"score": 0.003348838095597268, "phrase": "expected_linear_time"}, {"score": 0.003293142761521425, "phrase": "worst_case"}, {"score": 0.0030451958332949735, "phrase": "e._g"}, {"score": 0.0030113280682863234, "phrase": "linear-time_tests"}, {"score": 0.0029447150254434842, "phrase": "input_graph"}, {"score": 0.00272564002014117, "phrase": "paige"}, {"score": 0.002341164727388946, "phrase": "building_blocks"}, {"score": 0.0023021895404322767, "phrase": "efficient_code"}], "paper_keywords": ["Languages", " Performance", " Finite Differencing", " High Level Program", " Inductive Synthesis", " Transformational Programming"], "paper_abstract": "Given a high-level specification and a low-level programming language, our goal is to automatically synthesize an efficient program that meets the specification. In this paper, we present a new algorithmic methodology for inductive synthesis that allows us to do this. We use Second Order logic as our generic high level specification logic. For our low-level languages we choose small application-specific logics that can be immediately translated into code that runs in expected linear time in the worst case. We explain our methodology and provide examples of the synthesis of several graph classifiers, e. g, linear-time tests of whether the input graph is connected, acyclic, etc. In another set of applications we automatically derive many finite differencing expressions equivalent to ones that Paige built by hand in his thesis [Pai81]. Finally we describe directions for automatically combining such automatically generated building blocks to synthesize efficient code implementing more complicated specifications. The methods in this paper have been implemented in Python using the SMT solver Z3 [dMB].", "paper_title": "A Simple Inductive Synthesis Methodology and its Applications", "paper_id": "WOS:000286595800003"}