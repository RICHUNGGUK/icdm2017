{"auto_keywords": [{"score": 0.04917768661879915, "phrase": "self-optimizing_ast_interpreters"}, {"score": 0.03363896917055259, "phrase": "dsl"}, {"score": 0.01260196886695259, "phrase": "javascript"}, {"score": 0.00481495049065317, "phrase": "domain-specific_language"}, {"score": 0.004769444094319619, "phrase": "building_self-optimizing_ast_interpreters"}, {"score": 0.004613516457919661, "phrase": "provided_input"}, {"score": 0.004569905085027681, "phrase": "faster_execution"}, {"score": 0.004462663711734448, "phrase": "initial_tests"}, {"score": 0.004316722156877335, "phrase": "ast_nodes"}, {"score": 0.003906804492585634, "phrase": "dynamic_programming_languages"}, {"score": 0.0037969755088553326, "phrase": "traditional_procedural_and_object-oriented_programming_languages"}, {"score": 0.003355515315708125, "phrase": "declarative_domain-specific_language"}, {"score": 0.0027610089418453614, "phrase": "minimum_amount"}, {"score": 0.002176334183729241, "phrase": "ruby"}, {"score": 0.002155762370453017, "phrase": "python"}, {"score": 0.002104997932050659, "phrase": "smalltalk"}], "paper_keywords": ["Algorithms", " Languages", " Performance Java", " domain-specific languages", " dynamic languages", " language implementation", " self-optimizing programs"], "paper_abstract": "Self-optimizing AST interpreters dynamically adapt to the provided input for faster execution. This adaptation includes initial tests of the input, changes to AST nodes, and insertion of guards that ensure assumptions still hold. Such specialization and speculation is essential for the performance of dynamic programming languages such as JavaScript. In traditional procedural and object-oriented programming languages it can be tedious to write self-optimizing AST interpreters, as those languages fail to provide constructs that would specifically support that. This paper introduces a declarative domain-specific language (DSL) that greatly simplifies writing self-optimizing AST interpreters. The DSL supports specialization of operations based on types of the input and other properties. It can then use these specializations directly or chain them to represent the operation with the minimum amount of code possible. The DSL significantly reduces the complexity of expressing specializations for those interpreters. We use it in our high-performance implementation of JavaScript, where 274 language operations have an average of about 4 and a maximum of 190 specializations. In addition, the DSL is used in implementations of Ruby, Python, R, and Smalltalk.", "paper_title": "A Domain-Specific Language for Building Self-Optimizing AST Interpreters", "paper_id": "WOS:000357124200015"}