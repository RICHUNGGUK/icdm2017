{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "distributed"}, {"score": 0.00465634671242413, "phrase": "message_sequence_charts"}, {"score": 0.004258372598568333, "phrase": "program_synthesis"}, {"score": 0.004027031316965272, "phrase": "high-level_message_sequence_charts"}, {"score": 0.0036826452656927877, "phrase": "general_case"}, {"score": 0.0034824716857663114, "phrase": "simple_projection"}, {"score": 0.002251227801482381, "phrase": "communication_controllers"}, {"score": 0.0021049977753042253, "phrase": "stamping_information"}], "paper_keywords": ["Scenarios", " Implementation", " Distributed system synthesis"], "paper_abstract": "This work revisits the problem of program synthesis from specifications described by high-level message sequence charts. We first show that in the general case, synthesis by a simple projection on each component of the system allows more behaviors in the implementation than in the specification. We then show that differences arise from loss of ordering among messages and show that behaviors can be preserved by addition of communication controllers that intercept messages to add stamping information before resending them and deliver messages to processes in the order described by the specification.", "paper_title": "Distributed implementation of message sequence charts", "paper_id": "WOS:000354094400028"}