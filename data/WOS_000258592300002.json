{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "synchronous_models"}, {"score": 0.03760896637952158, "phrase": "semantic_equivalence"}, {"score": 0.03687705932093384, "phrase": "synchronous_model"}, {"score": 0.004750178261675602, "phrase": "loosely_time"}, {"score": 0.004623224002010226, "phrase": "synchronous_systems"}, {"score": 0.004561019117546361, "phrase": "clean_semantics"}, {"score": 0.0044692705329574, "phrase": "easy_verification_path"}, {"score": 0.004320421465896323, "phrase": "often_inefficient_implementations"}, {"score": 0.004233492114255375, "phrase": "design_specifications"}, {"score": 0.0037219886365287085, "phrase": "key_issue"}, {"score": 0.0031203609829058587, "phrase": "loosely_time-triggered_architecture"}, {"score": 0.0028764048059439205, "phrase": "global_synchronization"}, {"score": 0.0025630077791393125, "phrase": "intermediate_model"}, {"score": 0.0024774888010414206, "phrase": "kahn_process_network"}, {"score": 0.002427549902743566, "phrase": "finite_queues"}, {"score": 0.002237637525225501, "phrase": "semantic_preserving_implementation"}, {"score": 0.002162951519368368, "phrase": "general_case"}], "paper_keywords": ["synchronous models", " distributed systems", " loosely time-triggered architecture", " semantics-preserving implementation", " code generation", " embedded systems"], "paper_abstract": "Synchronous systems offer clean semantics and an easy verification path at the expense of often inefficient implementations. Capturing design specifications as synchronous models and then implementing the specifications in a less restrictive platform allows us to address a much larger design space. The key issue in this approach is maintaining semantic equivalence between the synchronous model and its implementation. We address this problem by showing how to map a synchronous model onto a loosely time-triggered architecture that is fairly straightforward to implement as it does not require global synchronization or blocking communication. We show how to maintain semantic equivalence between specification and implementation using an intermediate model ( similar to a Kahn process network but with finite queues) that helps in defining the transformation. Performance of the semantic preserving implementation is studied for the general case and for a few special cases.", "paper_title": "Implementing synchronous models on loosely time triggered architectures", "paper_id": "WOS:000258592300002"}