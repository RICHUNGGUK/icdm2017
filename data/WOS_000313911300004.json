{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "vectorisation_avoidance"}, {"score": 0.004684157900507474, "phrase": "nested_parallelism"}, {"score": 0.004556901872357751, "phrase": "vectorising_code"}, {"score": 0.004392565073466714, "phrase": "irregular_nested_parallelism"}, {"score": 0.004312622975366676, "phrase": "flat_data_parallelism"}, {"score": 0.004081385289516914, "phrase": "good_asymptotic_performance"}, {"score": 0.003334309053314909, "phrase": "subsequent_optimisation"}, {"score": 0.0031845067058084583, "phrase": "novel_program_analysis"}, {"score": 0.0027741761880779535, "phrase": "appropriate_gain"}, {"score": 0.002673957615079041, "phrase": "empirical_evidence"}, {"score": 0.002224510044064184, "phrase": "array_fusion"}, {"score": 0.0021049977753042253, "phrase": "resulting_code"}], "paper_keywords": ["Languages", " Performance", " Nested data parallelism", " Haskell", " Program transformation"], "paper_abstract": "Flattening nested parallelism is a vectorising code transform that converts irregular nested parallelism into flat data parallelism. Although the result has good asymptotic performance, flattening thoroughly restructures the code. Many intermediate data structures and traversals are introduced, which may or may not be eliminated by subsequent optimisation. We present a novel program analysis to identify parts of the program where flattening would only introduce overhead, without appropriate gain. We present empirical evidence that avoiding vectorisation in these cases leads to more efficient programs than if we had applied vectorisation and then relied on array fusion to eliminate intermediates from the resulting code.", "paper_title": "Vectorisation Avoidance", "paper_id": "WOS:000313911300004"}