{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "run-time_errors"}, {"score": 0.004764859786310636, "phrase": "embedded_real-time_parallel_c_programs."}, {"score": 0.004593591780245872, "phrase": "abstract_interpretation"}, {"score": 0.004405348628112645, "phrase": "multi-threaded_c_programs"}, {"score": 0.0042692243768616455, "phrase": "astree"}, {"score": 0.0041589926969138585, "phrase": "embedded_critical_programs"}, {"score": 0.004072851768196397, "phrase": "dynamic_memory_allocation"}, {"score": 0.003905864553426306, "phrase": "static_set"}, {"score": 0.0037653554368382814, "phrase": "shared_memory"}, {"score": 0.0036680857629458816, "phrase": "finite_set"}, {"score": 0.003629882559085245, "phrase": "mutual_exclusion_locks"}, {"score": 0.0035361001070845677, "phrase": "toareal-time_scheduling_policy"}, {"score": 0.0032861588691414667, "phrase": "slightly_modified_non-parallel_analysis"}, {"score": 0.003085989256759819, "phrase": "abstract_set"}, {"score": 0.0030538300202383106, "phrase": "thread_interferences"}, {"score": 0.0026649432435828842, "phrase": "sequential_consistency_semantics"}, {"score": 0.0025555322596460036, "phrase": "reasonable_weakly_consistent_memory_semantics"}, {"score": 0.0024250482323322606, "phrase": "mutual_exclusion_and_thread_priorities"}, {"score": 0.0023133055945761235, "phrase": "scheduler_state"}, {"score": 0.0022653055209664284, "phrase": "preliminary_experimental_results"}, {"score": 0.0022299587520401747, "phrase": "industrial_program"}, {"score": 0.002183684303511462, "phrase": "thesee"}], "paper_keywords": ["Abstract interpretation", " parallel programs", " run-time errors", " static analysis"], "paper_abstract": "We present a static analysis by Abstract Interpretation to check for run-time errors in parallel and multi-threaded C programs. Following our work on Astree, we focus on embedded critical programs without recursion nor dynamic memory allocation, but extend the analysis to a static set of threads communicating implicitly through a shared memory and explicitly using a finite set of mutual exclusion locks, and scheduled according toareal-time scheduling policy and fixed priorities. Our method is thread-modular. It is based on a slightly modified non-parallel analysis that, when analyzing a thread, applies and enriches an abstract set of thread interferences. An iterator then re-analyzes each thread in turn until interferences stabilize. We prove the soundness of our method with respect to the sequential consistency semantics, but also with respect to a reasonable weakly consistent memory semantics. We also show how to take into account mutual exclusion and thread priorities through a partitioning over an abstraction of the scheduler state. We present preliminary experimental results analyzing an industrial program with our prototype, Thesee, and demonstrate the scalability of our approach.", "paper_title": "STATIC ANALYSIS OF RUN-TIME ERRORS IN EMBEDDED REAL-TIME PARALLEL C PROGRAMS", "paper_id": "WOS:000302505000026"}