{"auto_keywords": [{"score": 0.0469718995485594, "phrase": "inductive_definitions"}, {"score": 0.043113908496203904, "phrase": "tree_tuple_languages"}, {"score": 0.038715940575402064, "phrase": "logic_programs"}, {"score": 0.02796174008115712, "phrase": "tuple_languages"}, {"score": 0.00481495049065317, "phrase": "logic_programming_point"}, {"score": 0.004403480614319231, "phrase": "language_expressions"}, {"score": 0.002911961514073769, "phrase": "definition_introduction"}, {"score": 0.0025461386232786356, "phrase": "uniform_way"}, {"score": 0.0024075916292945715, "phrase": "clause_classes"}, {"score": 0.0023021895404322767, "phrase": "closure_properties"}, {"score": 0.0021526564019119466, "phrase": "new_decidability"}, {"score": 0.0021049977753042253, "phrase": "computability_results"}], "paper_keywords": ["tree tuples", " logic programming", " inductive definitions"], "paper_abstract": "We introduce inductive definitions over language expressions as a framework for specifying tree tuple languages. Inductive definitions and their subclasses correspond naturally to classes of logic programs, and operations on tree tuple languages correspond to the transformation of logic programs. We present an algorithm based on unfolding and definition introduction that is able to deal with several classes of tuple languages in a uniform way. Termination proofs for clause classes translate directly to closure properties of tuple languages, leading to new decidability and computability results for the latter.", "paper_title": "Tree tuple languages from the logic programming point of view", "paper_id": "WOS:000244309400004"}