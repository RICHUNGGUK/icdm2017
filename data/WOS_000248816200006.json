{"auto_keywords": [{"score": 0.03961779893438284, "phrase": "source_code"}, {"score": 0.00481495049065317, "phrase": "bunch_search-based_software_modularization_algorithm"}, {"score": 0.004522796947899013, "phrase": "automatic_reverse_engineering_process"}, {"score": 0.004438642216475526, "phrase": "subsystem_abstractions"}, {"score": 0.00422177384286051, "phrase": "software_maintenance_activities"}, {"score": 0.0038673406001234535, "phrase": "module-level_dependencies"}, {"score": 0.0037246656582642272, "phrase": "abstract_structures"}, {"score": 0.0036097844103129073, "phrase": "called_subsystems"}, {"score": 0.003542557455905503, "phrase": "clustering_process"}, {"score": 0.0034984340449789745, "phrase": "evolutionary_algorithms"}, {"score": 0.0033905067962602515, "phrase": "enormous_set"}, {"score": 0.0033482708495261864, "phrase": "possible_graph_partitions"}, {"score": 0.00320453237792, "phrase": "fitness_function"}, {"score": 0.003066945490483524, "phrase": "individual_graph_partitions"}, {"score": 0.0030097975788892896, "phrase": "second_part"}, {"score": 0.002688532127821979, "phrase": "qualitative_and_quantitative_studies"}, {"score": 0.00262191949451482, "phrase": "good_results"}, {"score": 0.0024014759148123736, "phrase": "underlying_structure"}, {"score": 0.0023566987138026285, "phrase": "search_space"}, {"score": 0.0022273034991008326, "phrase": "interesting_findings"}, {"score": 0.002158505888557746, "phrase": "random_graphs"}, {"score": 0.0021049977753042253, "phrase": "real_software_systems"}], "paper_keywords": ["reverse engineering", " software clustering", " search algorithms"], "paper_abstract": "The first part of this paper describes an automatic reverse engineering process to infer subsystem abstractions that are useful for a variety of software maintenance activities. This process is based on clustering the graph representing the modules and module-level dependencies found in the source code into abstract structures not in the source code called subsystems. The clustering process uses evolutionary algorithms to search through the enormous set of possible graph partitions, and is guided by a fitness function designed to measure the quality of individual graph partitions. The second part of this paper focuses on evaluating the results produced by our clustering technique. Our previous research has shown through both qualitative and quantitative studies that our clustering technique produces good results quickly and consistently. In this part of the paper we study the underlying structure of the search space of several open source systems. We also report on some interesting findings our analysis uncovered by comparing random graphs to graphs representing real software systems.", "paper_title": "On the evaluation of the Bunch search-based software modularization algorithm", "paper_id": "WOS:000248816200006"}