{"auto_keywords": [{"score": 0.03953174774374673, "phrase": "cofinite_quantification"}, {"score": 0.00481495049065317, "phrase": "formal_metatheory"}, {"score": 0.004786107405332454, "phrase": "machine-checked_proofs"}, {"score": 0.0047289360793096044, "phrase": "programming_languages"}, {"score": 0.004672444473700524, "phrase": "critical_need"}, {"score": 0.004616624583337195, "phrase": "increased_confidence"}, {"score": 0.004588964055070299, "phrase": "large_and_complex_designs"}, {"score": 0.004466519142879166, "phrase": "proof-carrying_code"}, {"score": 0.004347327095048136, "phrase": "black_art"}, {"score": 0.004168181737829043, "phrase": "huge_cumulative_difference"}, {"score": 0.004081385289516914, "phrase": "large_formal_developments"}, {"score": 0.003972429785872538, "phrase": "variable_binding"}, {"score": 0.00393675895773741, "phrase": "key_issue"}, {"score": 0.0038780151896468194, "phrase": "novel_style"}, {"score": 0.0038086741610654715, "phrase": "locally_nameless_representation"}, {"score": 0.003740568332108757, "phrase": "free_variable_names"}, {"score": 0.0037181370924317834, "phrase": "inductive_definitions"}, {"score": 0.0035648266669315943, "phrase": "key_technical_insight"}, {"score": 0.003387108469185429, "phrase": "free_names"}, {"score": 0.003267003547703286, "phrase": "structural_induction_principles"}, {"score": 0.0031701655096648784, "phrase": "metatheoretic_reasoning"}, {"score": 0.003085460307255466, "phrase": "strong_inversion_principles"}, {"score": 0.002993987272124797, "phrase": "induction_principles"}, {"score": 0.002940406485632161, "phrase": "underlying_ingredients"}, {"score": 0.0028360962841331634, "phrase": "significant_improvement"}, {"score": 0.0028021527740710508, "phrase": "first-order_representations"}, {"score": 0.0027272537812174365, "phrase": "informal_practice"}, {"score": 0.002686509402739493, "phrase": "external_tool_support"}, {"score": 0.0026463721181523873, "phrase": "proof_assistant"}, {"score": 0.0025524660112107296, "phrase": "coq_proof_assistant"}, {"score": 0.002476755123108715, "phrase": "type_soundness"}, {"score": 0.0023249757987087055, "phrase": "subject_reduction"}, {"score": 0.0021049977753042253, "phrase": "future_extension"}], "paper_keywords": ["design", " documentation", " languages", " theory", " verification", " binding", " Coq", " locally nameless"], "paper_abstract": "Machine-checked proofs of properties of programming languages have become a critical need, both for increased confidence in large and complex designs and as a foundation for technologies such as proof-carrying code. However, constructing these proofs remains a black art, involving many choices in the formulation of definitions and theorems that make a huge cumulative difference in the difficulty of carrying out large formal developments. The representation and manipulation of terms with variable binding is a key issue. We propose a novel style for formalizing metatheory, combining locally nameless representation of terms and cofinite quantification of free variable names in inductive definitions of relations on terms (typing, reduction,...). The key technical insight is that our use of cofinite quantification obviates the need for reasoning about equivariance (the fact that free names can be renamed in derivations); in particular, the structural induction principles of relations defined using cofinite quantification are strong enough for metatheoretic reasoning, and need not be explicitly strengthened. Strong inversion principles follow (automatically, in Coq) from the induction principles. Although many of the underlying ingredients of our technique have been used before, their combination here yields a significant improvement over other methodologies using first-order representations, leading to developments that are faithful to informal practice, yet require no external tool support and little infrastructure within the proof assistant. We have carried out several large developments in this style using the Coq proof assistant and have made them publicly available. Our developments include type soundness for System F-< : and core ML (with references, exceptions, datatypes, recursion, and patterns) and subject reduction for the Calculus of Constructions. Not only do these developments demonstrate the comprehensiveness of our approach; they have also been optimized for clarity and robustness, making them good templates for future extension.", "paper_title": "Engineering formal metatheory", "paper_id": "WOS:000256500600003"}