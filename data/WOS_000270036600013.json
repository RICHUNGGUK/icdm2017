{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "automated_design_debugging_with_abstraction"}, {"score": 0.004726382602809228, "phrase": "design_debugging"}, {"score": 0.004617949594931096, "phrase": "major_remaining_manual_processes"}, {"score": 0.004554082077300675, "phrase": "semiconductor_design_cycle"}, {"score": 0.004491093879657087, "phrase": "recent_advances"}, {"score": 0.004388035083357706, "phrase": "automated_design_debugging"}, {"score": 0.00413096972023037, "phrase": "today's_designs"}, {"score": 0.00398028819691605, "phrase": "refinement_methodology"}, {"score": 0.0039252049353279556, "phrase": "current_debuggers"}, {"score": 0.0035273744062641636, "phrase": "debugger_performance"}, {"score": 0.0034947408949397127, "phrase": "different_circuit_structures"}, {"score": 0.0034624082435775676, "phrase": "state_abstraction"}, {"score": 0.003367188029221534, "phrase": "problem_size"}, {"score": 0.0032745778756077693, "phrase": "primitive_gates"}, {"score": 0.0032292292848296617, "phrase": "function_abstraction"}, {"score": 0.003125835572347772, "phrase": "modular_and_hierarchical_information"}, {"score": 0.0030117065110966414, "phrase": "initial_abstracted_model"}, {"score": 0.0028615323526689582, "phrase": "existing_automated_debugger"}, {"score": 0.0028087949095629955, "phrase": "error_site"}, {"score": 0.002656327554326748, "phrase": "abstracted_components"}, {"score": 0.002523828967909659, "phrase": "underlying_theory"}, {"score": 0.002431626477893495, "phrase": "debugging_tool"}, {"score": 0.002375714262344562, "phrase": "proposed_methodology"}, {"score": 0.0023537101705489957, "phrase": "empirical_results"}, {"score": 0.0023103100997344072, "phrase": "run_time"}, {"score": 0.0022889103976458437, "phrase": "memory_capacity"}, {"score": 0.0021246816854197732, "phrase": "wide_range"}, {"score": 0.0021049977753042253, "phrase": "benchmark_and_industrial_designs"}], "paper_keywords": ["Abstraction", " debugging", " diagnosis", " refinement", " verification", " very large scale integration"], "paper_abstract": "Design debugging is one of the major remaining manual processes in the semiconductor design cycle. Despite recent advances in the area of automated design debugging, more effort is required to cope with the size and complexity of today's designs. This paper introduces an abstraction and refinement methodology to enable current debuggers to operate on designs that are orders of magnitude larger than otherwise possible. Two abstraction techniques are developed with the goals of improving debugger performance for different circuit structures: State abstraction is aimed at reducing the problem size for circuits consisting purely of primitive gates, while function abstraction focuses on designs that also contain modular and hierarchical information. In both methods, after an initial abstracted model is created, the problem can be solved by an existing automated debugger. If an error site is abstracted, refinement is necessary to reintroduce some of the abstracted components back into the design. This paper also presents the underlying theory to guarantee correctness and completeness of a debugging tool that operates using the proposed methodology. Empirical results demonstrate improvements in run time and memory capacity of two orders of magnitude over a state-of-the-art debugger on a wide range of benchmark and industrial designs.", "paper_title": "Automated Design Debugging With Abstraction and Refinement", "paper_id": "WOS:000270036600013"}