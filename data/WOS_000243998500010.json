{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "multi-adjoint_logic_programs"}, {"score": 0.00477190623242136, "phrase": "multi-adjoint_logic_programming"}, {"score": 0.004582897918101983, "phrase": "logic_programming"}, {"score": 0.00415166680936294, "phrase": "operational_one"}, {"score": 0.004114527599108729, "phrase": "admissible_steps"}, {"score": 0.004005083535629333, "phrase": "similar_way"}, {"score": 0.003969250376327401, "phrase": "classical_resolution_steps"}, {"score": 0.003933736547198066, "phrase": "pure_logic_programming"}, {"score": 0.00384633057714983, "phrase": "computed_substitution"}, {"score": 0.003628024127607343, "phrase": "last_expression"}, {"score": 0.0033459905006404207, "phrase": "fuzzy_component"}, {"score": 0.0032423089921154503, "phrase": "computed_answer"}, {"score": 0.003113696267229798, "phrase": "well_known_transformation_rule"}, {"score": 0.003058179790439378, "phrase": "declarative_programming"}, {"score": 0.0027825094419000637, "phrase": "operational_steps"}, {"score": 0.0027206133859493725, "phrase": "program_rules"}, {"score": 0.0024864612830452254, "phrase": "interpretive_steps"}, {"score": 0.002292965705677312, "phrase": "strong_correctness_properties"}, {"score": 0.0022118619998034742, "phrase": "computed_substitutions"}, {"score": 0.0021920373388760314, "phrase": "truth_degrees"}], "paper_keywords": ["fuzzy logic programming", " program transformation", " unfolding"], "paper_abstract": "Multi-adjoint logic programming represents a very recent, extremely flexible attempt for introducing fuzzy logic into logic programming. In this setting, the execution of a goal w.r.t. a given program is done in two separate phases. During the operational one, admissible steps are systematically applied in a similar way to classical resolution steps in pure logic programming, thus returning a computed substitution together with an expression where all atoms have been exploited. This last expression is then interpreted under a given lattice during the so called interpretive phase, hence returning a value which represents the fuzzy component (truth degree) of the computed answer. On the other hand, unfolding is a well known transformation rule widely used in declarative programming for optimizing and specializing programs, among other applications. In essence, it is usually based on the application of operational steps on the body of program rules. The novelty of this paper consists in showing that this process can also be made in terms of interpretive steps. We present two strongly related kinds of unfolding (operational and interpretive), which, apart from exhibiting strong correctness properties (i.e. they preserve the semantics of computed substitutions and truth degrees) they are able to significantly simplify the two execution phases when solving goals.", "paper_title": "Operational/interpretive unfolding of multi-adjoint logic programs", "paper_id": "WOS:000243998500010"}