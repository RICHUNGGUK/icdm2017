{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "safe_convergence"}, {"score": 0.004565007074039171, "phrase": "non-negative_integers"}, {"score": 0.004444921827311577, "phrase": "silent_self-stabilizing_algorithm"}, {"score": 0.00421410521089045, "phrase": "unique_node_ids"}, {"score": 0.004103212598803194, "phrase": "node_p"}, {"score": 0.003010893527930816, "phrase": "minimal_one"}, {"score": 0.0026771333996253783, "phrase": "shared_memory_model"}, {"score": 0.0024978881934276387, "phrase": "theta"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Distributed systems", " Self-stabilization", " Safe convergence", " (f, g)-alliance", " Unfair daemon"], "paper_abstract": "Given two functions f and g mapping nodes to non-negative integers, we give a silent self-stabilizing algorithm that computes a minimal (f, g)-alliance in an asynchronous network with unique node IDs, assuming that every node p has a degree at least g(p) and satisfies f (p) >= g(p). Our algorithm is safely converging in the sense that starting from any configuration, it first converges to a (not necessarily minimal) (f, g)-alliance in at most four rounds, and then continues to converge to a minimal one in at most 5n+4 additional rounds, where n is the size of the network. Our algorithm is written in the shared memory model. It is proven assuming an unfair (distributed) daemon. Its memory requirement is Theta (log n) bits per process, and it takes O(n . Delta(3)) steps to stabilize, where A is the degree of the network. (C) 2015 Elsevier Inc. All rights reserved.", "paper_title": "Self-stabilizing (f, g)-alliances with safe convergence", "paper_id": "WOS:000355962100002"}