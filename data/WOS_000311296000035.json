{"auto_keywords": [{"score": 0.043891862951523704, "phrase": "program_slices"}, {"score": 0.009661622770654224, "phrase": "trace_slice"}, {"score": 0.00467207889925365, "phrase": "higher-order_functional_computations"}, {"score": 0.004231699728933577, "phrase": "traditional_notion"}, {"score": 0.0039841418890102925, "phrase": "new_notion"}, {"score": 0.003816197777388722, "phrase": "flexible_and_rich_slicing_criteria"}, {"score": 0.003501175642882274, "phrase": "algorithm-independent_fashion"}, {"score": 0.003426556090707852, "phrase": "least_slice"}, {"score": 0.0031845067058084613, "phrase": "least_program_slices"}, {"score": 0.002762240719058935, "phrase": "unevaluation_algorithm"}, {"score": 0.0026116610153271943, "phrase": "program_slice"}, {"score": 0.00253400005142168, "phrase": "close_correspondence"}, {"score": 0.0023046064114537503, "phrase": "programming_language"}, {"score": 0.0021049977753042253, "phrase": "important_practical_implementation_concerns"}], "paper_keywords": ["program slicing", " debugging", " provenance"], "paper_abstract": "We present techniques that enable higher-order functional computations to \"explain\" their work by answering questions about how parts of their output were calculated. As explanations, we consider the traditional notion of program slices, which we show can be inadequate, and propose a new notion: trace slices. We present techniques for specifying flexible and rich slicing criteria based on partial expressions, parts of which have been replaced by holes. We characterise program slices in an algorithm-independent fashion and show that a least slice for a given criterion exists. We then present an algorithm, called unevaluation, for computing least program slices from computations reified as traces. Observing a limitation of program slices, we develop a notion of trace slice as another form of explanation and present an algorithm for computing them. The unevaluation algorithm can be applied to any subtrace of a trace slice to compute a program slice whose evaluation generates that subtrace. This close correspondence between programs, traces, and their slices can enable the programmer to understand a computation interactively, in terms of the programming language in which the computation is expressed. We present an implementation in the form of a tool, discuss some important practical implementation concerns and present some techniques for addressing them.", "paper_title": "Functional Programs that Explain their Work", "paper_id": "WOS:000311296000035"}