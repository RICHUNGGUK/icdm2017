{"auto_keywords": [{"score": 0.026452279654774383, "phrase": "sql"}, {"score": 0.007076520274765503, "phrase": "olap"}, {"score": 0.004633429997452688, "phrase": "interesting_sample"}, {"score": 0.003872414709826833, "phrase": "current_systems"}, {"score": 0.003256808693019209, "phrase": "diamond_cube_operator"}, {"score": 0.003133844153806967, "phrase": "existing_data_warehouse_operations"}, {"score": 0.0029203055813347874, "phrase": "diamond_cubes"}, {"score": 0.002738797804069541, "phrase": "large_data_sets"}, {"score": 0.002259054486157494, "phrase": "popular_database_engines"}], "paper_keywords": ["OLAP", " Information retrieval", " Multidimensional queries"], "paper_abstract": "In OLAP, analysts often select an interesting sample of the data. For example, an analyst might focus on products bringing revenues of at least $100,000, or on shops having sales greater than $400,000. However, current systems do not allow the application of both of these thresholds simultaneously, selecting products and shops satisfying both thresholds. For such purposes, we introduce the diamond cube operator, filling a gap among existing data warehouse operations. Because of the interaction between dimensions the computation of diamond cubes is challenging. We compare and test various algorithms on large data sets of more than 100 million facts. We find that while it is possible to implement diamonds in SQL, it is inefficient. Indeed, our custom implementation can be a hundred times faster than popular database engines (including a row-store and a column-store). (c) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Diamond dicing", "paper_id": "WOS:000320353700001"}