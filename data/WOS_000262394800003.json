{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "bytecode_verification"}, {"score": 0.015413195163808452, "phrase": "abstract_interpretation"}, {"score": 0.004490842671590769, "phrase": "key_point"}, {"score": 0.004358676214574977, "phrase": "security_chain"}, {"score": 0.004230382915464492, "phrase": "java_platform"}, {"score": 0.0037913267098534887, "phrase": "memory_requirements"}, {"score": 0.00367967106192446, "phrase": "verification_process"}, {"score": 0.0028394925080958205, "phrase": "multiple_specialized_passes"}, {"score": 0.0026745503978347143, "phrase": "type_encoding_space"}, {"score": 0.00256993314099902, "phrase": "different_abstractions"}, {"score": 0.0021049977753042253, "phrase": "small_memory_systems"}], "paper_keywords": ["Verification", " Theory", " Abstract interpretation", " bytecode verification"], "paper_abstract": "Bytecode verification is a key point in the security chain of the Java platform. This feature is only optional in many embedded devices since the memory requirements of the verification process are too high. In this article we propose an approach that significantly reduces the use of memory by a serial/parallel decomposition of the verification into multiple specialized passes. The algorithm reduces the type encoding space by operating on different abstractions of the domain of types. The results of our evaluation show that this bytecode verification can be performed directly on small memory systems. The method is formalized in the framework of abstract interpretation.", "paper_title": "Decomposing Bytecode Verification by Abstract Interpretation", "paper_id": "WOS:000262394800003"}