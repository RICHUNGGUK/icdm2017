{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "loop_transformations"}, {"score": 0.004773904938276846, "phrase": "deep_parallelism"}, {"score": 0.004672808182229058, "phrase": "modern_compilers"}, {"score": 0.0045543011700929096, "phrase": "idealistic_operational_semantics"}, {"score": 0.004496174406337201, "phrase": "source_program"}, {"score": 0.004382127278148236, "phrase": "efficient_use"}, {"score": 0.004326188427877999, "phrase": "highly_complex_heterogeneous_machine"}, {"score": 0.004270960586542813, "phrase": "optimization_problems"}, {"score": 0.0041984140090404985, "phrase": "huge_and_unstructured_search_spaces"}, {"score": 0.003971006689166329, "phrase": "weak_scalability"}, {"score": 0.003937126962709418, "phrase": "disappointing_sustained_performance"}, {"score": 0.0037719988989298983, "phrase": "program_representation"}, {"score": 0.003692040748097991, "phrase": "semi-automatic_optimization_approach"}, {"score": 0.003629291866667764, "phrase": "current_compilers"}, {"score": 0.0035676056286816915, "phrase": "unnecessary_constraints"}, {"score": 0.003432604816716035, "phrase": "semantically_richer_transformation_framework"}, {"score": 0.003177687211289478, "phrase": "syntactic_code_representations"}, {"score": 0.0030705342386533083, "phrase": "rigid_phase_ordering"}, {"score": 0.003044313656896057, "phrase": "cumbersome_expression"}, {"score": 0.0030183163057929687, "phrase": "architecture-aware_loop_transformations"}, {"score": 0.0029165216647792924, "phrase": "complex_transformation_sequences"}, {"score": 0.002842428606954139, "phrase": "significant_performance_benefits"}, {"score": 0.0027465495490291746, "phrase": "automatic_search"}, {"score": 0.0027230880516264685, "phrase": "program_transformation_sequences"}, {"score": 0.0026767629720554397, "phrase": "classical_polyhedral_representations"}, {"score": 0.0026538960171433985, "phrase": "better_support_operation_research_strategies"}, {"score": 0.0025315664299815537, "phrase": "unified_polyhedral_representation"}, {"score": 0.0024566655761509276, "phrase": "normalization_rules"}, {"score": 0.0024252458095689847, "phrase": "flexible_and_expressive_transformation_sequencing"}, {"score": 0.0023333715029833007, "phrase": "polyhedral_dependence_analysis"}, {"score": 0.00218789980093445, "phrase": "algorithmic_advances"}, {"score": 0.0021692000054033956, "phrase": "polyhedral_code_generation"}, {"score": 0.0021049977753042253, "phrase": "modern_research_compiler"}], "paper_keywords": ["compiler optimization", " semi-automatic program transformation", " polyhedral model", " automatic parallelization"], "paper_abstract": "Modern compilers are responsible for translating the idealistic operational semantics of the source program into a form that makes efficient use of a highly complex heterogeneous machine. Since optimization problems are associated with huge and unstructured search spaces, this combinational task is poorly achieved in general, resulting in weak scalability and disappointing sustained performance. We address this challenge by working on the program representation itself, using a semi-automatic optimization approach to demonstrate that current compilers offen suffer from unnecessary constraints and intricacies that can be avoided in a semantically richer transformation framework. Technically, the purpose of this paper is threefold: (1) to show that syntactic code representations close to the operational semantics lead to rigid phase ordering and cumbersome expression of architecture-aware loop transformations, (2) to illustrate how complex transformation sequences may be needed to achieve significant performance benefits, (3) to facilitate the automatic search for program transformation sequences, improving on classical polyhedral representations to better support operation research strategies in a simpler, structured search space. The proposed framework relies on a unified polyhedral representation of loops and statements, using normalization rules to allow flexible and expressive transformation sequencing. Thisrepresentation allows to extend the scalability of polyhedral dependence analysis, and to delay the (automatic) legality checks until the end of a transformation sequence. Our work leverages on algorithmic advances in polyhedral code generation and has been implemented in a modern research compiler.", "paper_title": "Semi-automatic composition of loop transformations for deep parallelism and memory hierarchies", "paper_id": "WOS:000239355400005"}