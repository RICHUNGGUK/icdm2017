{"auto_keywords": [{"score": 0.03876606694020765, "phrase": "hardware_assists"}, {"score": 0.03779104206343624, "phrase": "npt"}, {"score": 0.014326736871829749, "phrase": "shadow_mechanism"}, {"score": 0.013597420145953623, "phrase": "virtual_addresses"}, {"score": 0.008684297942482041, "phrase": "hap"}, {"score": 0.00481495049065317, "phrase": "key_technique"}, {"score": 0.004772818068176176, "phrase": "cloud_computing"}, {"score": 0.004662250189344776, "phrase": "virtualization_overhead"}, {"score": 0.0046079260641779755, "phrase": "virtualized_system"}, {"score": 0.004461761855323898, "phrase": "page_table_virtualization"}, {"score": 0.0044356867986444426, "phrase": "conventional_virtual_machines"}, {"score": 0.004345613093011898, "phrase": "page_tables"}, {"score": 0.004294962474996283, "phrase": "shadow_page_table"}, {"score": 0.004134372859330047, "phrase": "machine_addresses"}, {"score": 0.004026712228523795, "phrase": "physical_page_table"}, {"score": 0.0039449104968131655, "phrase": "expensive_vm_exits"}, {"score": 0.003887496109332722, "phrase": "page_fault"}, {"score": 0.0037311485295990045, "phrase": "intel"}, {"score": 0.003709336452974522, "phrase": "amd"}, {"score": 0.0036660479882474717, "phrase": "ept"}, {"score": 0.0034979676031187015, "phrase": "address_translation"}, {"score": 0.0033473779327638322, "phrase": "ordinary_guest_page_table"}, {"score": 0.0032889671598112023, "phrase": "physical_addresses"}, {"score": 0.0032315723330399375, "phrase": "extended_page_table"}, {"score": 0.0031658723398585516, "phrase": "guest_physical_addresses"}, {"score": 0.003138124398958758, "phrase": "physical_or_machine_addresses"}, {"score": 0.0030833537429977797, "phrase": "similar_style"}, {"score": 0.0029075757820516634, "phrase": "vm_exits"}, {"score": 0.0028069426877159664, "phrase": "conventional_shadow_mechanism"}, {"score": 0.0026624684547385718, "phrase": "hardware-assisted_paging"}, {"score": 0.002623669616798891, "phrase": "shadow_paging"}, {"score": 0.0026083756004393116, "phrase": "sp"}, {"score": 0.002570296816631395, "phrase": "definite_winner"}, {"score": 0.002459545376635285, "phrase": "noticeable_gap"}, {"score": 0.002353554841514325, "phrase": "dynamic_switching_mechanism"}, {"score": 0.002332910483431198, "phrase": "tlb"}, {"score": 0.002193367454830741, "phrase": "new_mechanism"}, {"score": 0.002129877319760485, "phrase": "better_performance"}, {"score": 0.0021049985590385146, "phrase": "sp."}], "paper_keywords": ["Algorithms", " Management", " Measurement", " Performance", " Design", " Experimentation", " Verification", " virtual machine", " hardware-assisted virtualization", " shadow paging", " dynamic switching", " hardware assisted paging"], "paper_abstract": "As virtualization becomes a key technique for supporting cloud computing, much effort has been made to reduce virtualization overhead, so a virtualized system can match its native performance. One major overhead is due to memory or page table virtualization. Conventional virtual machines rely on a shadow mechanism to manage page tables, where a shadow page table maintained by the VMM (Virtual Machine Monitor) maps virtual addresses to machine addresses while a guest maintains its own virtual to physical page table. This shadow mechanism will result in expensive VM exits whenever there is a page fault that requires synchronization between the two page tables. To avoid this cost, both Intel and AMD provide hardware assists, EPT (extended page table) and NPT (nested page table), to facilitate address translation. With the hardware assists, the MMU (Memory Management Unit) maintains an ordinary guest page table that translates virtual addresses to guest physical addresses. In addition, the extended page table as provided by EPT translates from guest physical addresses to host physical or machine addresses. NPT works in a similar style. With EPT or NPT, a guest page fault can be handled by the guest itself without triggering VM exits. However, the hardware assists do have their disadvantage compared to the conventional shadow mechanism - the page walk yields more memory accesses and thus longer latency. Our experimental results show that neither hardware-assisted paging (HAP) nor shadow paging (SP) can be a definite winner. Despite the fact that in over half of the cases, there is no noticeable gap between the two mechanisms, an up to 34% performance gap exists for a few benchmarks. We propose a dynamic switching mechanism that monitors TLB misses and guest page faults on the fly, and dynamically switches between the two paging modes. Our experiments show that this new mechanism can match and, sometimes, even beat the better performance of HAP and SP.", "paper_title": "Selective Hardware/Software Memory Virtualization", "paper_id": "WOS:000294949300020"}