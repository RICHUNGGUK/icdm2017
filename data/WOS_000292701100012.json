{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "prolog"}, {"score": 0.00478701880312723, "phrase": "simple_compositional_semantics"}, {"score": 0.00475924837336259, "phrase": "prolog's_very_useful_expressive_power"}, {"score": 0.004690521763591147, "phrase": "traditional_logic_programming_semantics"}, {"score": 0.004556018017257075, "phrase": "clause_order"}, {"score": 0.004438250823243621, "phrase": "operational_details"}, {"score": 0.004399672486322409, "phrase": "computation_state"}, {"score": 0.004187284711626886, "phrase": "expressive_power"}, {"score": 0.004162978902905446, "phrase": "computation_model"}, {"score": 0.004114787982556699, "phrase": "compositional_denotational_semantics"}, {"score": 0.003859500298805362, "phrase": "partial_evaluator"}, {"score": 0.0038259332670788748, "phrase": "safe_unfolding"}, {"score": 0.003781629193080687, "phrase": "predicate_definitions"}, {"score": 0.0035885019925285394, "phrase": "cut's_full_power"}, {"score": 0.003385422532841961, "phrase": "primitive_goal_types"}, {"score": 0.0033559647822437298, "phrase": "compositional_semantics"}, {"score": 0.0033170847930578473, "phrase": "variable-binding_solutions"}, {"score": 0.0032406665327678616, "phrase": "usual_technique"}, {"score": 0.003212464294894526, "phrase": "least_fixpoint_construction"}, {"score": 0.003129317057177867, "phrase": "alternative_language"}, {"score": 0.003021781956684419, "phrase": "identical_expressive_power"}, {"score": 0.0029009722548088306, "phrase": "semantic_framework"}, {"score": 0.002859003260874958, "phrase": "alternative_ones"}, {"score": 0.00280126189041041, "phrase": "term_language"}, {"score": 0.00278497898719426, "phrase": "variable_abstraction"}, {"score": 0.0026814165903551353, "phrase": "call_arguments"}, {"score": 0.002536926192232391, "phrase": "local_case"}, {"score": 0.002414241727802253, "phrase": "open_definitions"}, {"score": 0.0023585737444452573, "phrase": "simple_functional_application"}, {"score": 0.0022708315711029423, "phrase": "simple_account"}, {"score": 0.0022576249214220187, "phrase": "flexible_module_composition_mechanisms"}, {"score": 0.0021991369769963545, "phrase": "exposed_principles"}, {"score": 0.002142161017595363, "phrase": "prolog_engine"}, {"score": 0.0021049977753042253, "phrase": "large_real-world_applications"}], "paper_keywords": ["Prolog", " Cut", " Compositional semantics", " Denotational semantics"], "paper_abstract": "Prolog's very useful expressive power is not captured by traditional logic programming semantics, due mainly to the cut and goal and clause order. Several alternative semantics have been put forward, exposing operational details of the computation state. We propose instead to redesign Prolog around structured alternatives to the cut and clauses, keeping the expressive power and computation model but with a compositional denotational semantics over much simpler states-just variable bindings. This considerably eases reasoning about programs, by programmers and tools such as a partial evaluator, with safe unfolding of calls through predicate definitions. An if-then-else across clauses replaces most uses of the cut, but the cut's full power is achieved by an until construct. Disjunction, conjunction and until, along with unification, are the primitive goal types with a compositional semantics yielding sequences of variable-binding solutions. This extends to programs via the usual technique of a least fixpoint construction. A simple interpreter for Prolog in the alternative language, and a definition of until in Prolog, establish the identical expressive power of the two languages. Many useful control constructs are derivable from the primitives, and the semantic framework illuminates the discussion of alternative ones. The formalisation rests on a term language with variable abstraction as in the lambda-calculus. A clause is an abstraction on the call arguments, a continuation, and the local variables. It can be inclusive or exclusive, expressing a local case bound to a continuation by either a disjunction or an if-then-else. Clauses are open definitions, composed (and closed) with simple functional application (beta-reduction). This paves the way for a simple account of flexible module composition mechanisms. Cube, a concrete language with the exposed principles, has been implemented on top of a Prolog engine and successfully used to build large real-world applications.", "paper_title": "A structured alternative to Prolog with simple compositional semantics", "paper_id": "WOS:000292701100012"}