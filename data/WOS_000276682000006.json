{"auto_keywords": [{"score": 0.028241480231683772, "phrase": "cppc_library"}, {"score": 0.00481495049065317, "phrase": "portable_checkpointing"}, {"score": 0.0047804843375940835, "phrase": "message-passing_applications"}, {"score": 0.00467855218490191, "phrase": "high-performance_computing"}, {"score": 0.004546000131069232, "phrase": "new_checkpoint"}, {"score": 0.0042004472903194616, "phrase": "different_machines"}, {"score": 0.0041703614123283165, "phrase": "checkpointing_tools"}, {"score": 0.004066740842661956, "phrase": "heterogeneous_environments"}, {"score": 0.003909065355459264, "phrase": "parallel_application"}, {"score": 0.0037710151976096985, "phrase": "opaque_state"}, {"score": 0.003690527690610707, "phrase": "communications_support"}, {"score": 0.0035858673522839407, "phrase": "single_feature"}, {"score": 0.0034467717443162015, "phrase": "underlying_ad_hoc_representations"}, {"score": 0.0033490008882413103, "phrase": "different_environments"}, {"score": 0.0033249931673591457, "phrase": "portable_checkpointers"}, {"score": 0.0032774911048411835, "phrase": "portability_issues"}, {"score": 0.002931569771634119, "phrase": "cppc"}, {"score": 0.002910545717767559, "phrase": "compiler_for_portable_checkpointing"}, {"score": 0.0028689475587958917, "phrase": "checkpointing_tool"}, {"score": 0.0026220625042810706, "phrase": "variable_level_checkpointing"}, {"score": 0.0025938977569302177, "phrase": "portable_code"}, {"score": 0.0025476254812544135, "phrase": "cppc_compiler"}, {"score": 0.00245753647863636, "phrase": "time-consuming_tasks"}, {"score": 0.0024223970976460173, "phrase": "data_flow"}, {"score": 0.002370625627299064, "phrase": "instrumentation_code"}, {"score": 0.0022703709180757576, "phrase": "experimental_results"}, {"score": 0.0022379017425216917, "phrase": "large-scale_real_applications"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["fault tolerance", " checkpointing", " parallel programming", " message-passing", " MPI", " compiler support"], "paper_abstract": "With the evolution of high-performance computing toward heterogeneous, massively parallel systems, parallel applications have developed new checkpoint and restart necessities. Whether due to a failure in the execution or to a migration of the application processes to different machines, checkpointing tools must be able to operate in heterogeneous environments. However, some of the data manipulated by a parallel application are not truly portable. Examples of these include opaque state (e.g. data structures for communications support) or diversity of interfaces for a single feature (e.g. communications, I/O). Directly manipulating the underlying ad hoc representations renders checkpointing tools unable to work on different environments. Portable checkpointers usually work around portability issues at the cost of transparency: the user must provide information such as what data need to be stored, where to store them, or where to checkpoint. CPPC (ComPiler for Portable Checkpointing) is a checkpointing tool designed to feature both portability and transparency. It is made up of a library and a compiler. The CPPC library contains routines for variable level checkpointing, using portable code and protocols. The CPPC compiler helps to achieve transparency by relieving the user from time-consuming tasks, such as data flow and communications analyses and adding instrumentation code. This paper covers both the operation of the CPPC library and its compiler support. Experimental results using benchmarks and large-scale real applications are included, demonstrating usability, efficiency, and portability. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "CPPC: a compiler-assisted tool for portable checkpointing of message-passing applications", "paper_id": "WOS:000276682000006"}