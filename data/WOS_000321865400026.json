{"auto_keywords": [{"score": 0.03945817458808679, "phrase": "composite_operations"}, {"score": 0.010368994511891941, "phrase": "static_analysis"}, {"score": 0.010193927100515431, "phrase": "foresight_information"}, {"score": 0.004814976234894088, "phrase": "concurrent"}, {"score": 0.004753515404103343, "phrase": "foresight"}, {"score": 0.004712988631183401, "phrase": "linearizable_libraries"}, {"score": 0.004056981775766067, "phrase": "linearizable_library"}, {"score": 0.004005176784823524, "phrase": "arbitrary_atomic_composite_operations"}, {"score": 0.0038868464660354626, "phrase": "novel_approach"}, {"score": 0.0038207994186834015, "phrase": "concurrent_library"}, {"score": 0.003537155405923517, "phrase": "correctness_condition"}, {"score": 0.003432604816716035, "phrase": "dynamic_right-movers"}, {"score": 0.002854645802851, "phrase": "client_programmer"}, {"score": 0.0027702126237754625, "phrase": "client_code"}, {"score": 0.0027114323601885666, "phrase": "generic_technique"}, {"score": 0.002665305036900055, "phrase": "library_implementation"}, {"score": 0.0026312238938540787, "phrase": "foresight-based_synchronization"}, {"score": 0.0025315664299815537, "phrase": "general-purpose_java_library"}, {"score": 0.0023839754995935184, "phrase": "multiple_instances"}, {"score": 0.0023636038312749245, "phrase": "map_data_structures"}, {"score": 0.0023134312557290043, "phrase": "maps_library"}, {"score": 0.0022257833099336858, "phrase": "wide_selection"}, {"score": 0.0022067604433257814, "phrase": "real-life_java_composite_operations"}, {"score": 0.0021231452870210965, "phrase": "efficient_and_scalable_synchronization"}, {"score": 0.0021049977753042253, "phrase": "real-life_composite_operations"}], "paper_keywords": ["Concurrency", " Composition", " Transactions", " Data Structures", " Automatic Synchronization"], "paper_abstract": "Linearizable libraries provide operations that appear to execute atomically. Clients, however, may need to execute a sequence of operations (a composite operation) atomically. We consider the problem of extending a linearizable library to support arbitrary atomic composite operations by clients. We introduce a novel approach in which the concurrent library ensures atomicity of composite operations by exploiting information (foresight) provided by its clients. We use a correctness condition, based on a notion of dynamic right-movers, that guarantees that composite operations execute atomically without deadlocks, and without using rollbacks. We present a static analysis to infer the foresight information required by our approach, allowing a compiler to automatically insert the foresight information into the client. This relieves the client programmer of this burden and simplifies writing client code. We present a generic technique for extending the library implementation to realize foresight-based synchronization. This technique is used to implement a general-purpose Java library for Map data structures - the library permits composite operations to simultaneously work with multiple instances of Map data structures. We use the Maps library and the static analysis to enforce atomicity of a wide selection of real-life Java composite operations. Our experiments indicate that our approach enables realizing efficient and scalable synchronization for real-life composite operations.", "paper_title": "Concurrent Libraries with Foresight", "paper_id": "WOS:000321865400026"}