{"auto_keywords": [{"score": 0.04752086310544823, "phrase": "database_systems"}, {"score": 0.00481495049065317, "phrase": "multisocket_hardware"}, {"score": 0.004589307360976108, "phrase": "new_challenges"}, {"score": 0.004495854882808791, "phrase": "software_parallelism"}, {"score": 0.004359216541892805, "phrase": "simultaneous_requests"}, {"score": 0.004285101149043392, "phrase": "synchronization_barriers"}, {"score": 0.004112303664150895, "phrase": "aries-style_concurrency"}, {"score": 0.003946453104980692, "phrase": "oltp"}, {"score": 0.003634458561248524, "phrase": "different_level"}, {"score": 0.0035972293900260414, "phrase": "software_architecture"}, {"score": 0.003335581163845351, "phrase": "log_flush"}, {"score": 0.0031035439594553635, "phrase": "in-memory_log_data_structures"}, {"score": 0.00281900316527787, "phrase": "modern_database_system"}, {"score": 0.002790103629701475, "phrase": "log-intensive_workloads"}, {"score": 0.002723815159181826, "phrase": "tatp"}, {"score": 0.0026774300859545826, "phrase": "single-socket_multiprocessor_server"}, {"score": 0.002622806755354039, "phrase": "log_insert_throughput"}, {"score": 0.0025959133277517824, "phrase": "small_log_records"}, {"score": 0.002569294946452846, "phrase": "single-socket_server"}, {"score": 0.002508239347479441, "phrase": "traditional_way"}, {"score": 0.002448631085132444, "phrase": "single_mutex"}, {"score": 0.002333620799300123, "phrase": "multi-socket_servers"}, {"score": 0.002239340134646663, "phrase": "latency_penalty"}, {"score": 0.002208765537836048, "phrase": "multi-socket_hardware"}, {"score": 0.002126816206925344, "phrase": "distributed_log_buffer_design"}, {"score": 0.0021049977753042253, "phrase": "socket_level"}], "paper_keywords": ["Log manager", " Early lock release", " Flush pipelining", " Log buffer contention", " Consolidation array", " Scaling to multisockets"], "paper_abstract": "The shift to multi-core and multi-socket hardware brings new challenges to database systems, as the software parallelism determines performance. Even though database systems traditionally accommodate simultaneous requests, a multitude of synchronization barriers serialize execution. Write-ahead logging is a fundamental, omnipresent component in ARIES-style concurrency and recovery, and one of the most important yet-to-be addressed potential bottlenecks, especially in OLTP workloads making frequent small changes to data. In this paper, we identify four logging-related impediments to database system scalability. Each issue challenges different level in the software architecture: (a) the high volume of small-sized I/O requests may saturate the disk, (b) transactions hold locks while waiting for the log flush, (c) extensive context switching overwhelms the OS scheduler with threads executing log I/Os, and (d) contention appears as transactions serialize accesses to in-memory log data structures. We demonstrate these problems and address them with techniques that, when combined, comprise a holistic, scalable approach to logging. Our solution achieves a 20-69% speedup over a modern database system when running log-intensive workloads, such as the TPC-B and TATP benchmarks, in a single-socket multiprocessor server. Moreover, it achieves log insert throughput over 2.2 GB/s for small log records on the single-socket server, roughly 20 times higher than the traditional way of accessing the log using a single mutex. Furthermore, we investigate techniques on scaling the performance of logging to multi-socket servers. We present a set of optimizations which partly ameliorate the latency penalty that comes with multi-socket hardware, and then we investigate the feasibility of applying a distributed log buffer design at the socket level.", "paper_title": "Scalability of write-ahead logging on multicore and multisocket hardware", "paper_id": "WOS:000301776400005"}