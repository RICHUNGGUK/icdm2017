{"auto_keywords": [{"score": 0.050078487022614894, "phrase": "labeled_trees"}, {"score": 0.044242962092394124, "phrase": "neville"}, {"score": 0.004490842671590769, "phrase": "node_labels"}, {"score": 0.004446349752828045, "phrase": "different_codes"}, {"score": 0.004272728456464736, "phrase": "prufer"}, {"score": 0.00416765588092386, "phrase": "deo"}, {"score": 0.004126349202545883, "phrase": "micikevicius"}, {"score": 0.0035891316580885665, "phrase": "unified_framework"}, {"score": 0.003380791705551809, "phrase": "parallel_setting"}, {"score": 0.0031686717525002935, "phrase": "n-node_trees"}, {"score": 0.0031061129850110994, "phrase": "first_linear_time"}, {"score": 0.0028536871476905847, "phrase": "erew_pram_model"}, {"score": 0.0026217213613095322, "phrase": "root_log"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["graph algorithms", " labeled trees", " prufer-like codes", " data structures"], "paper_abstract": "We consider the problem of coding labeled trees by means of strings of node labels. Different codes have been introduced in the literature by Prufer, Neville, and Deo and Micikevicius. For all of them, we show that both coding and decoding can be reduced to integer (radix) sorting, closing several open problems within a unified framework that can be applied both in a sequential and in a parallel setting. Our sequential coding and decoding schemes require optimal O(n) time when applied to n-node trees, yielding the first linear time decoding algorithm for a code presented by Neville. These schemes can be parallelized on the EREW PRAM model. so as to work in O(log n) time with cost O(n), O(n root log n), or O(n log n), depending on the code and on the operation: in all cases, they either match or improve the performances of the best ad hoc approaches known so far. (c) 2007 Elsevier B.V. All rights reserved.", "paper_title": "On coding labeled trees", "paper_id": "WOS:000249294100003"}