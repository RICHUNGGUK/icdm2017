{"auto_keywords": [{"score": 0.031539476490019626, "phrase": "lsa."}, {"score": 0.00481495049065317, "phrase": "runtime_elision_of_transactional_barriers"}, {"score": 0.004717723626157272, "phrase": "captured_memory"}, {"score": 0.004303830426772906, "phrase": "new_technique"}, {"score": 0.0041316803676012155, "phrase": "transaction-local_memory"}, {"score": 0.003926105480202798, "phrase": "managed_environments"}, {"score": 0.0037307208089736835, "phrase": "low_runtime_overhead"}, {"score": 0.0034733518170738517, "phrase": "well_known_stm_framework"}, {"score": 0.003403122817578447, "phrase": "deuce"}, {"score": 0.0023798115577749225, "phrase": "stamp_benchmarks"}, {"score": 0.0021705796895687864, "phrase": "best_case"}, {"score": 0.0021049977753042253, "phrase": "vacation_application"}], "paper_keywords": ["Performance", " Transactions", " Software Transactional Memory", " Runtime Optimizations"], "paper_abstract": "In this paper, we propose a new technique that can identify transaction-local memory (i.e. captured memory), in managed environments, while having a low runtime overhead. We implemented our proposal in a well known STM framework (Deuce) and we tested it in STMBench7 with two different STMs: TL2 and LSA. In both STMs the performance improved significantly (4 times and 2.6 times, respectively). Moreover, running the STAMP benchmarks with our approach shows improvements of 7 times in the best case for the Vacation application.", "paper_title": "Runtime Elision of Transactional Barriers for Captured Memory", "paper_id": "WOS:000324158900038"}