{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "multi-stage_open_shop_processing_systems"}, {"score": 0.027559932969777202, "phrase": "special_case"}, {"score": 0.0043215158337835706, "phrase": "deadlock_detection_questions"}, {"score": 0.004190019394361629, "phrase": "safe_and_unsafe_system_states"}, {"score": 0.003878451139312637, "phrase": "system_states"}, {"score": 0.003674192201248236, "phrase": "initial_state"}, {"score": 0.002846647336160784, "phrase": "reachable_deadlock_states"}, {"score": 0.0027386335451725762, "phrase": "open_shop_systems"}, {"score": 0.002401053532270901, "phrase": "linear_programming"}, {"score": 0.002364172626241202, "phrase": "matching_theory"}, {"score": 0.0021049977753042253, "phrase": "graph-theoretic_arguments"}], "paper_keywords": ["Scheduling", " Resource allocation", " Deadlock", " Computational complexity"], "paper_abstract": "We study algorithmic problems in multi-stage open shop processing systems that are centered around reachability and deadlock detection questions. We characterize safe and unsafe system states. We show that it is easy to recognize system states that can be reached from the initial state (where the system is empty), but that in general it is hard to decide whether one given system state is reachable from another given system state. We show that the problem of identifying reachable deadlock states is hard in general open shop systems, but is easy in the special case where no job needs processing on more than two machines (by linear programming and matching theory), and in the special case where all machines have capacity one (by graph-theoretic arguments).", "paper_title": "Analysis of multi-stage open shop processing systems", "paper_id": "WOS:000330038100011"}