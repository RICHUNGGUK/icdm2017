{"auto_keywords": [{"score": 0.004682288586254123, "phrase": "knowledge_representation_features"}, {"score": 0.004626553103375699, "phrase": "new_multi-paradigm_programming_language"}, {"score": 0.004445494322321316, "phrase": "oriented_and_imperative_programming_styles"}, {"score": 0.004120694410890683, "phrase": "labeled_theories"}, {"score": 0.004007083686875716, "phrase": "theory_label"}, {"score": 0.003684634192576662, "phrase": "theory_structure"}, {"score": 0.003583002730249742, "phrase": "knowledge_domain"}, {"score": 0.002981216610222911, "phrase": "ontology_class"}, {"score": 0.0029339151044984134, "phrase": "type_definition"}, {"score": 0.0027192536281209463, "phrase": "labeled_theory"}, {"score": 0.0026547761341670505, "phrase": "subclass_relationships"}, {"score": 0.0026022112631368223, "phrase": "type_and_theory_inheritance_rules"}, {"score": 0.0023545567809591804, "phrase": "ontology_oriented_programming"}, {"score": 0.0021909411820497707, "phrase": "ontology_specification"}, {"score": 0.0021049977753042253, "phrase": "oriented_programming"}], "paper_keywords": [""], "paper_abstract": "In this paper we introduce the knowledge representation features of a new multi-paradigm programming language called go! that cleanly integrates logic, functional, object oriented and imperative programming styles. Borrowing from L&O [1] go! allows knowledge to be represented as a set of labeled theories incrementally constructed using multiple-inheritance. The theory label is a constructor for instances of the class. The instances are Go!'s objects. A Go! theory structure can be used to characterize any knowledge domain. In particular, it can be used to describe classes of things, such as people, students, etc., their subclass relationships and characteristics of their key properties. That is, it can be used to represent an ontology. For each ontology class we give a type definition-we declare what properties, with what value type, instances of the class have-and we give a labeled theory that defines these properties. Subclass relationships are reflected using both type and theory inheritance rules. Following [2], we shall call this ontology oriented programming. This paper describes the Go! language and its use for ontology oriented programming, comparing its expressiveness with Owl, particularly Owl Lite[3]. The paper assumes some familiarity with ontology specification using Owl like languages and with logic and object oriented programming.", "paper_title": "Ontology oriented programming in Go!", "paper_id": "WOS:000236963200002"}