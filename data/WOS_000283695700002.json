{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "rule-based_programs"}, {"score": 0.0047459060595229224, "phrase": "generic_scheme"}, {"score": 0.0047049532961375, "phrase": "declarative_debugging"}, {"score": 0.00461075951152053, "phrase": "rewriting-based_languages"}, {"score": 0.0044536312768349, "phrase": "integrated_development_environment"}, {"score": 0.004143196873246147, "phrase": "single_framework"}, {"score": 0.004095567486538121, "phrase": "semantics-based_diagnoser"}, {"score": 0.003944506079554075, "phrase": "inductive_learner"}, {"score": 0.0034036089823450385, "phrase": "parametric_w.r.t"}, {"score": 0.003202987495080647, "phrase": "intended_specification"}, {"score": 0.0031753062090452864, "phrase": "program_r"}, {"score": 0.0030580836029381817, "phrase": "single_step"}, {"score": 0.002988101395789399, "phrase": "effective_debugging_method"}, {"score": 0.002945175711537758, "phrase": "computed_answers_semantics"}, {"score": 0.0028944757265206332, "phrase": "finitely_terminating_bottom-up_abstract_diagnosis_method"}, {"score": 0.0028037753646260937, "phrase": "bug-correction_program_synthesis_methodology"}, {"score": 0.0027634902834910184, "phrase": "erroneous_components"}, {"score": 0.0027395968397212053, "phrase": "wrong_code"}, {"score": 0.0024400265512135397, "phrase": "resulting_program"}, {"score": 0.0022828113789751694, "phrase": "error_symptoms"}, {"score": 0.0022434880661725493, "phrase": "difficult_questions"}, {"score": 0.0022305310659333864, "phrase": "program_correctness"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Debugging", " Narrowing", " Functional logic programming", " Program transformation"], "paper_abstract": "We present a generic scheme for the declarative debugging of programs that are written in rewriting-based languages that are equipped with narrowing. Our aim is to provide an integrated development environment in which it is possible to debug a program and then correct it automatically. Our methodology is based on the combination (in a single framework) of a semantics-based diagnoser that identifies those parts of the code that contain errors and an inductive learner that tries to repair them, once the bugs have been located in the program. We develop our methodology in several steps. First, we associate with our programs a semantics that is based on a (continuous) immediate consequence operator, T-R, which models the answers computed by narrowing and is parametric w.r.t. the evaluation strategy, which can be eager or lazy. Then, we show that, given the intended specification of a program R, it is possible to check the correctness of R by a single step of T-R. In order to develop an effective debugging method, we approximate the computed answers semantics of R and derive a finitely terminating bottom-up abstract diagnosis method, which can be used statically. Finally, a bug-correction program synthesis methodology attempts to correct the erroneous components of the wrong code. We propose a hybrid, top-down (unfolding-based) as well as bottom-up (induction-based), correction approach that is driven by a set of evidence examples which are automatically produced as an outcome by the diagnoser. The resulting program is proven to be correct and complete w.r.t. the considered example sets. Our debugging framework does not require the user to provide error symptoms in advance or to answer difficult questions concerning program correctness. An implementation of our debugging system has been undertaken which demonstrates the workability of our approach. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "An integrated framework for the diagnosis and correction of rule-based programs", "paper_id": "WOS:000283695700002"}