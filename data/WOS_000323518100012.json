{"auto_keywords": [{"score": 0.04659100592900169, "phrase": "custom_allocators"}, {"score": 0.00481495049065317, "phrase": "reconsidering_custom_memory_allocation"}, {"score": 0.004695303774351139, "phrase": "performance_improvements"}, {"score": 0.004636594774238505, "phrase": "custom_memory_allocators"}, {"score": 0.004578616481036476, "phrase": "in-depth_study"}, {"score": 0.003712011863784581, "phrase": "higher_performance"}, {"score": 0.003559387846675818, "phrase": "programmer_burden"}, {"score": 0.0034708317974593136, "phrase": "memory_leaks"}, {"score": 0.003286420941205958, "phrase": "individual_objects"}, {"score": 0.0031912018800904314, "phrase": "substantial_increase"}, {"score": 0.0031645050772280033, "phrase": "memory_consumption"}, {"score": 0.0030089355635315005, "phrase": "common_programming_idioms"}, {"score": 0.002885135695263876, "phrase": "general-purpose_and_region-based_allocators"}, {"score": 0.0026862220320327613, "phrase": "full_range"}, {"score": 0.0026637384761565605, "phrase": "region_semantics"}, {"score": 0.0026083473154448326, "phrase": "individual_object_deletion"}, {"score": 0.002511522462767081, "phrase": "high_performance"}, {"score": 0.002459288755782293, "phrase": "region-like_semantics"}, {"score": 0.0023980368333253147, "phrase": "case_study"}, {"score": 0.002358050109031317, "phrase": "space_advantages"}, {"score": 0.002338306897057454, "phrase": "software_engineering_benefits"}, {"score": 0.0022326306658609365, "phrase": "fast_regions"}, {"score": 0.0021049977753042253, "phrase": "lea_allocator"}], "paper_keywords": ["Algorithms", " Experimentation", " Performance", " Reliability"], "paper_abstract": "Programmers hoping to achieve performance improvements often use custom memory allocators. This in-depth study examines eight applications that use custom allocators. Surprisingly, for six of these applications, a state-of-the-art general-purpose allocator (the Lea allocator) performs as well as or better than the custom allocators. The two exceptions use regions, which deliver higher performance (improvements of up to 44%). Regions also reduce programmer burden and eliminate a source of memory leaks. However, we show that the inability of programmers to free individual objects within regions can lead to a substantial increase in memory consumption. Worse, this limitation precludes the use of regions for common programming idioms, reducing their usefulness. We present a generalization of general-purpose and region-based allocators that we call reaps. Reaps are a combination of regions and heaps, providing a full range of region semantics with the addition of individual object deletion. We show that our implementation of reaps provides high performance, outperforming other allocators with region-like semantics. We then use a case study to demonstrate the space advantages and software engineering benefits of reaps in practice. Our results indicate that programmers needing fast regions should use reaps, and that most programmers considering custom allocators should instead use the Lea allocator.", "paper_title": "Reconsidering Custom Memory Allocation", "paper_id": "WOS:000323518100012"}