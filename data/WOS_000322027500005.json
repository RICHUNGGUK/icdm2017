{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "asymmetric_rendezvous_system"}, {"score": 0.00450933377534525, "phrase": "unfair_synchronous_queue"}, {"score": 0.00433531459712787, "phrase": "elimination_array"}, {"score": 0.003423042581201533, "phrase": "unique_thread"}, {"score": 0.002962543869356265, "phrase": "prior_synchronous_queue_and_elimination_array_implementations"}, {"score": 0.0022777800735119405, "phrase": "rendezvous_system"}, {"score": 0.0021049977753042253, "phrase": "highly_scalable_and_competitive_stack_implementation"}], "paper_keywords": [""], "paper_abstract": "In an asymmetric rendezvous system, such as an unfair synchronous queue or an elimination array, threads of two types, consumers and producers, show up and are matched each with a unique thread of the other type. Here we present new highly scalable, high throughput asymmetric rendezvous systems that outperform prior synchronous queue and elimination array implementations under both symmetric and asymmetric workloads (more operations of one type than the other). Based on this rendezvous system, we also construct a highly scalable and competitive stack implementation.", "paper_title": "Fast and scalable rendezvousing", "paper_id": "WOS:000322027500005"}