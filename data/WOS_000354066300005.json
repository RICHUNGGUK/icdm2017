{"auto_keywords": [{"score": 0.03289282662064985, "phrase": "lcs"}, {"score": 0.00481495049065317, "phrase": "target_string"}, {"score": 0.004527371799277529, "phrase": "l_strings"}, {"score": 0.0043452175611323335, "phrase": "natural_number"}, {"score": 0.004235095881928715, "phrase": "string_m"}, {"score": 0.004085579055228594, "phrase": "k_strings"}, {"score": 0.002895620643297197, "phrase": "parameter_k"}, {"score": 0.002559444836360178, "phrase": "preprocessing_time"}, {"score": 0.0022856052476424344, "phrase": "maximal_length"}, {"score": 0.0021049977753042253, "phrase": "longest_common_subsequence"}], "paper_keywords": ["Dynamic programming", " Longest common subsequences", " Resequencing", " Inverted indexing", " Totally monotone matrices"], "paper_abstract": "Given a set S={S (1),S (2),aEuro broken vertical bar,S (l) } of l strings, a text T, and a natural number k, find a string M, which is a concatenation of k strings (not necessarily distinct, i.e., a string in S may occur more than once in M) from S, whose longest common subsequence with T is largest, where a string in S may occur more than once in M. Such a string is called a k-inlay. The resequencing longest common subsequence problem (resequencing LCS problem for short) is to find a k-inlay for each query with parameter k after T and S are given. In this paper, we propose an algorithm for solving this problem which takes O(nml) preprocessing time and O(I (k) k) query time for each query with parameter k, where n is the length of T, m is the maximal length of strings in S, and I (k) is the length of the longest common subsequence between a k-inlay and T.", "paper_title": "Resequencing a Set of Strings Based on a Target String", "paper_id": "WOS:000354066300005"}