{"auto_keywords": [{"score": 0.0451821857931196, "phrase": "stm_system"}, {"score": 0.028278818389359073, "phrase": "virtual_world_consistency"}, {"score": 0.014412738133806708, "phrase": "concurrent_objects"}, {"score": 0.00983658415321985, "phrase": "committed_transactions"}, {"score": 0.00481495049065317, "phrase": "stm_systems"}, {"score": 0.004760765880314089, "phrase": "versatile_protocol"}, {"score": 0.004733901576706854, "phrase": "invisible_read_operations"}, {"score": 0.004641059153109559, "phrase": "software_transactional_memory"}, {"score": 0.004448169552315403, "phrase": "multiprocess_programs"}, {"score": 0.0037852512654732223, "phrase": "explicit_synchronization_statement"}, {"score": 0.00370044870195814, "phrase": "underlying_stm_system"}, {"score": 0.0033511469200347907, "phrase": "underlying_stm_concurrency_management"}, {"score": 0.0032299490885442103, "phrase": "new_stm_consistency_condition"}, {"score": 0.003104310486173269, "phrase": "object_values"}, {"score": 0.003078028357912228, "phrase": "inconsistent_global_state"}, {"score": 0.002958281631770322, "phrase": "aborted_transactions"}, {"score": 0.0027403030304207886, "phrase": "aborted_transaction"}, {"score": 0.0024814079299143536, "phrase": "stm_protocol"}, {"score": 0.002405193760683982, "phrase": "read_operations"}, {"score": 0.0023713273141757326, "phrase": "operational_point"}, {"score": 0.002305014991156598, "phrase": "vector-clock_mechanism"}, {"score": 0.002234206434819338, "phrase": "shared_objects"}, {"score": 0.0021049977753042253, "phrase": "causal_consistency"}], "paper_keywords": ["Atomic object", " Causal past", " Commit/abort", " Concurrency control", " Consistency condition", " Consistent global state", " Lock", " Read-from relation", " Regular read/write object", " Serializability", " Shared memory", " Software transactional memory", " Vector clock", " Transaction"], "paper_abstract": "The aim of a Software Transactional Memory (STM) is to discharge the programmers from the management of synchronization in multiprocess programs that access concurrent objects. To that end, an STM system provides the programmer with the concept of a transaction. The job of the programmer is to design each process the application is made up of as a sequence of transactions. A transaction is a piece of code that accesses concurrent objects, but contains no explicit synchronization statement. It is the job of the underlying STM system to provide the illusion that each transaction appears as being executed atomically. Of course, for efficiency, an STM system has to allow transactions to execute concurrently. Consequently, clue to the underlying STM concurrency management, a transaction commits or aborts. This paper first presents a new STM consistency condition, called virtual world consistency. This condition states that no transaction reads object values from an inconsistent global state. It is similar to opacity for the committed transactions but weaker for the aborted transactions. More precisely, it states that (1) the committed transactions can be totally ordered, and (2) the values read by each aborted transaction are consistent with respect to its causal past. Hence, virtual world consistency is weaker than opacity while keeping its spirit. Then, assuming the objects shared by the processes are atomic read/write objects, the paper presents an STM protocol that ensures virtual world consistency (while guaranteeing the invisibility of the read operations). From an operational point of view, this protocol is based on a vector-clock mechanism. Finally, the paper considers the case where the shared objects are regular read/write objects. It also shows how the protocol can easily be weakened while still providing an STM system that satisfies causal consistency, a condition strictly weaker than virtual world consistency. (c) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Virtual world consistency: A condition for STM systems (with a versatile protocol with invisible read operations)", "paper_id": "WOS:000306041700011"}