{"auto_keywords": [{"score": 0.035067601146693536, "phrase": "tree_automata"}, {"score": 0.03338531779439961, "phrase": "tasc"}, {"score": 0.0313025820359723, "phrase": "red-black_trees"}, {"score": 0.004815658223740169, "phrase": "automata"}, {"score": 0.004685375117376838, "phrase": "tree_updates"}, {"score": 0.004577076689777069, "phrase": "effective_verification_procedure"}, {"score": 0.0045415338200109345, "phrase": "imperative_programs"}, {"score": 0.004250302819248558, "phrase": "classical_semi-algorithmic_approach"}, {"score": 0.004119762981892093, "phrase": "manually_the_loop_invariants"}, {"score": 0.003993216345115755, "phrase": "hoare_triples"}, {"score": 0.0034029588672379926, "phrase": "tree-like_memory_configurations"}, {"score": 0.0033502512757488433, "phrase": "special_class"}, {"score": 0.0032727116186194584, "phrase": "size_constraints"}, {"score": 0.003196960816092101, "phrase": "main_advantage"}, {"score": 0.0031351720217878917, "phrase": "program_specifications"}, {"score": 0.0030745737579268876, "phrase": "non-regular_sets"}, {"score": 0.0029916929549256297, "phrase": "avl_trees"}, {"score": 0.002865929543375884, "phrase": "arithmetic_reasoning"}, {"score": 0.002519402443228795, "phrase": "emptiness_problem"}, {"score": 0.0023391880766516285, "phrase": "insertion_procedure"}, {"score": 0.0022407927161620855, "phrase": "insertion_algorithm"}, {"score": 0.0022146817879683204, "phrase": "balanced_red-black_tree"}, {"score": 0.0021803388613879896, "phrase": "longest_path"}, {"score": 0.0021049977753042253, "phrase": "shortest_path"}], "paper_keywords": [""], "paper_abstract": "This paper describes an effective verification procedure for imperative programs that handle (balanced) tree-like data structures. Since the verification problem considered is undecidable, we appeal to a classical semi-algorithmic approach in which the user has to provide manually the loop invariants in order to check the validity of Hoare triples of the form {P}C{Q}, where P, Q are the sets of states corresponding to the pre- and post-conditions, and C is the program to be verified. We specify the sets of states (representing tree-like memory configurations) using a special class of tree automata named Tree Automata with Size Constraints (TASC). The main advantage of using TASC in program specifications is that they recognize non-regular sets of tree languages such as the AVL trees, the red-black trees, and in general, specifications involving arithmetic reasoning about the lengths (depths) of various (possibly all) paths in the tree. The class of TASC is closed under the operations of union, intersection and complement, and moreover, the emptiness problem is decidable, which makes it a practical verification tool. We validate our approach considering red-black trees and the insertion procedure, for which we verify that the output of the insertion algorithm is a balanced red-black tree, i.e. the longest path is at most twice as long as the shortest path.", "paper_title": "Automata-based verification of programs with tree updates", "paper_id": "WOS:000236941100023"}