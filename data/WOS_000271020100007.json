{"auto_keywords": [{"score": 0.04303241603089626, "phrase": "functional_units"}, {"score": 0.015524077210859924, "phrase": "power_gating"}, {"score": 0.006621372724282567, "phrase": "wakeup_instructions"}, {"score": 0.00481495049065317, "phrase": "power-gating_functional_units"}, {"score": 0.004784565134881178, "phrase": "embedded_microprocessors"}, {"score": 0.004650175539595746, "phrase": "leakage_reduction"}, {"score": 0.004620825188916713, "phrase": "integrated_circuits"}, {"score": 0.004476816511183382, "phrase": "sleep_transistors"}, {"score": 0.004420472010542188, "phrase": "circuit_modules"}, {"score": 0.004351033214640434, "phrase": "sustained_periods"}, {"score": 0.004296264970612285, "phrase": "program_execution"}, {"score": 0.004175533280178052, "phrase": "new_framework"}, {"score": 0.004083971741538933, "phrase": "embedded_system_microprocessors"}, {"score": 0.003994409920585572, "phrase": "proposed_framework"}, {"score": 0.003956627672153024, "phrase": "efficient_algorithm"}, {"score": 0.00393163747242631, "phrase": "idle_time_estimation"}, {"score": 0.003906804492585634, "phrase": "appropriate_insertion"}, {"score": 0.0038821277513157973, "phrase": "sleep_instructions"}, {"score": 0.003749155155531426, "phrase": "sleeping_units"}, {"score": 0.0035751121405295026, "phrase": "loop_hierarchy_trees"}, {"score": 0.003496670470065125, "phrase": "partial_ordering"}, {"score": 0.0034635798581019073, "phrase": "nested_loops"}, {"score": 0.0033875770020590796, "phrase": "control_flow_graph"}, {"score": 0.003344895435289136, "phrase": "source_program"}, {"score": 0.0031996871318754685, "phrase": "maximal_subgraphs"}, {"score": 0.0031693980719538317, "phrase": "long_idle_periods"}, {"score": 0.003051073364818384, "phrase": "sleep_instruction"}, {"score": 0.0029558409515535525, "phrase": "corresponding_functional_units"}, {"score": 0.0027566337241307286, "phrase": "control_unit"}, {"score": 0.0026536779296945138, "phrase": "execute_stage"}, {"score": 0.002546466113418944, "phrase": "object_code"}, {"score": 0.0024747842618794255, "phrase": "arm_processor_architecture"}, {"score": 0.0023899010501421186, "phrase": "cmos_cell_library"}, {"score": 0.002337403139264533, "phrase": "experimental_results"}, {"score": 0.0022572213326336374, "phrase": "mibench_suite"}, {"score": 0.0021728771392034462, "phrase": "leakage_energy"}, {"score": 0.0021318918306931474, "phrase": "integer_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "floating-point_benchmarks"}], "paper_keywords": ["Embedded system", " leakage power", " power gating"], "paper_abstract": "Power gating is a technique commonly used for leakage reduction in integrated circuits. In microprocessors, power gating is implemented by using sleep transistors to selectively deactivate circuit modules that remain idle for sustained periods of time during program execution. In this work, we develop a new framework for power gating the functional units in embedded system microprocessors without degradation in performance. The proposed framework includes an efficient algorithm for idle time estimation, appropriate insertion of sleep instructions within the code, and a method for reactivating the sleeping units only when needed without the use of wakeup instructions. We introduce the notion of loop hierarchy trees (LHTs) to represent the partial ordering of the nested loops within the program. From the control flow graph (CFG) representation of the source program, a forest of LHTs is constructed and is used to identify the maximal subgraphs representing the long idle periods for the functional units. For each subgraph thus identified, a sleep instruction is introduced in the program with a list of corresponding functional units to be deactivated. When an instruction is decoded, the functional units needed for that instruction are automatically activated by the control unit such that the units are ready before the instruction reaches the execute stage. This eliminates the need for wakeup instructions to be inserted into the object code reducing the overheads. In our implementation, the ARM processor architecture was modified and resynthesized to include power gating by developing a CMOS cell library of functional units with the above capabilities. Experimental results are reported for a set of 12 benchmarks chosen from the MiBench suite, which indicate that, on average, our technique reduces the leakage energy in functional units by 31.1% for integer benchmarks and 26.8% for floating-point benchmarks.", "paper_title": "A Framework for Power-Gating Functional Units in Embedded Microprocessors", "paper_id": "WOS:000271020100007"}