{"auto_keywords": [{"score": 0.03711031720937781, "phrase": "first-class_contracts"}, {"score": 0.00481495049065317, "phrase": "behavioral_software_contracts"}, {"score": 0.004740476936977635, "phrase": "widely_used_mechanism"}, {"score": 0.004453874101119545, "phrase": "runtime_monitoring"}, {"score": 0.004317109072311102, "phrase": "significant_overhead"}, {"score": 0.004206338218873218, "phrase": "faulty_components"}, {"score": 0.003931402465972151, "phrase": "soft_contract_verification"}, {"score": 0.003434085751246066, "phrase": "higher-order_symbolic_execution"}, {"score": 0.0032940691998512963, "phrase": "symbolic_values"}, {"score": 0.0032599633778910516, "phrase": "unknown_behavioral_values"}, {"score": 0.0031762308449055305, "phrase": "updatable_heap"}, {"score": 0.003143341238802547, "phrase": "contract_invariants"}, {"score": 0.003078577062864183, "phrase": "flow-sensitive_facts"}, {"score": 0.0029994894380575604, "phrase": "symbolic_execution"}, {"score": 0.0029376803941247084, "phrase": "dynamic_semantics"}, {"score": 0.002702887319160532, "phrase": "recursive_data_structures"}, {"score": 0.0026471739851621143, "phrase": "control-flow-sensitive_refinements"}, {"score": 0.0025259712348798323, "phrase": "dynamic_languages"}, {"score": 0.002473895542219933, "phrase": "effective_use"}, {"score": 0.002435542816459651, "phrase": "off-the-shelf_solver"}, {"score": 0.002372935208038141, "phrase": "heavy_encodings"}, {"score": 0.0022760856906838814, "phrase": "wide_range"}, {"score": 0.0022524959504997303, "phrase": "existing_tools"}, {"score": 0.0022175679453857473, "phrase": "type_systems"}], "paper_keywords": ["Higher-order contracts", " symbolic execution"], "paper_abstract": "Behavioral software contracts are a widely used mechanism for governing the flow of values between components. However, runtime monitoring and enforcement of contracts imposes significant overhead and delays discovery of faulty components to run-time. To overcome these issues, we present soft contract verification, which aims to statically prove either complete or partial contract correctness of components, written in an untyped, higher-order language with first-class contracts. Our approach uses higher-order symbolic execution, leveraging contracts as a source of symbolic values including unknown behavioral values, and employs an updatable heap of contract invariants to reason about flow-sensitive facts. We prove the symbolic execution soundly approximates the dynamic semantics and that verified programs can't be blamed. The approach is able to analyze first-class contracts, recursive data structures, unknown functions, and control-flow-sensitive refinements of values, which are all idiomatic in dynamic languages. It makes effective use of an off-the-shelf solver to decide problems without heavy encodings. The approach is competitive with a wide range of existing tools-including type systems, flow analyzers, and model checkers-on their own benchmarks.", "paper_title": "Soft Contract Verification", "paper_id": "WOS:000349143000013"}