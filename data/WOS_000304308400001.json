{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "adaptive_pre-execution"}, {"score": 0.004766388573192505, "phrase": "data_prefetching"}, {"score": 0.004718314112245913, "phrase": "data_prefetching_mechanisms"}, {"score": 0.00457696724030363, "phrase": "memory_latency"}, {"score": 0.004530794611704416, "phrase": "data_intensive_applications"}, {"score": 0.00441738161338662, "phrase": "speed_gap"}, {"score": 0.004198965651975536, "phrase": "cpu_caches"}, {"score": 0.0038913443732432468, "phrase": "combined_prefetching_method"}, {"score": 0.003736567662016446, "phrase": "original_code"}, {"score": 0.0030811340338342454, "phrase": "formal_definition"}, {"score": 0.0030500051941781034, "phrase": "speculative_and_non-speculative_pre-execution"}, {"score": 0.0029735479904284706, "phrase": "lightweight_software-based_strategy"}, {"score": 0.0029137604783116065, "phrase": "main_working_thread"}, {"score": 0.002686360550456695, "phrase": "memory_addresses"}, {"score": 0.0025275050635202878, "phrase": "adaptive_automatic_control"}, {"score": 0.00248927752933113, "phrase": "helper_thread"}, {"score": 0.0024023079401125492, "phrase": "best_performance"}, {"score": 0.002283298119790413, "phrase": "intensive_application"}, {"score": 0.002248755794042486, "phrase": "hardware_modifications"}, {"score": 0.0021591707887653865, "phrase": "average_speedup"}, {"score": 0.0021049977753042253, "phrase": "real-life_application"}], "paper_keywords": ["Pre-execution", " Data prefetch", " Self-configuration", " Data intensive application", " Performance"], "paper_abstract": "Data prefetching mechanisms are widely used for hiding memory latency in data intensive applications. They mask the speed gap between CPUs and their memory systems by preloading data into the CPU caches, where accessing them is by at least one order of magnitude faster. Pre-execution is a combined prefetching method, which executes a slice of the original code preloading the code and its data at the same time. Pre-execution is often mentioned in the literature, but according to our knowledge, it has not been formally defined yet. We fill this void by presenting the formal definition of speculative and non-speculative pre-execution, and derive a lightweight software-based strategy which accelerates the main working thread by introducing an adaptive, non-speculative pre-execution helper thread. This helper thread acts as a perfect predictor, calculates memory addresses, prefetches the data and consumes cache misses early. The adaptive automatic control allows the helper thread to configure itself in run-time for best performance. The method is directly applicable to any data intensive application without requiring hardware modifications. Our method was able to achieve an average speedup of 10-30% in a real-life application.", "paper_title": "Software Controlled Adaptive Pre-Execution for Data Prefetching", "paper_id": "WOS:000304308400001"}