{"auto_keywords": [{"score": 0.028007058398925127, "phrase": "mri"}, {"score": 0.00481495049065317, "phrase": "robust_solvers"}, {"score": 0.004775726266706856, "phrase": "inverse_imaging_problems_using_dense"}, {"score": 0.004756233569671719, "phrase": "single-precision_hardware"}, {"score": 0.004659951478263083, "phrase": "iterative_framework"}, {"score": 0.0045843245695654875, "phrase": "large_inverse_problems"}, {"score": 0.004021689117050817, "phrase": "large_problems"}, {"score": 0.003924121879214595, "phrase": "high_levels"}, {"score": 0.0036008372531664726, "phrase": "quadratic_and_general_non-linear_minimization_problems"}, {"score": 0.003386301445203071, "phrase": "efficient_parallelizable_matrix-vector_products"}, {"score": 0.003304097742490624, "phrase": "outer_iterations"}, {"score": 0.003210704011271791, "phrase": "quadratic_minimization_problem"}, {"score": 0.003158522476399068, "phrase": "single_newton_step"}, {"score": 0.0031327496009959464, "phrase": "inner_iterations"}, {"score": 0.0030193416820392554, "phrase": "truncated_neumann_series"}, {"score": 0.002994701080666466, "phrase": "minimax_polynomial_approximations"}, {"score": 0.0029581155916843663, "phrase": "operator_splittings"}, {"score": 0.0029100272315053253, "phrase": "convergence_analysis"}, {"score": 0.0028046593475268174, "phrase": "embedded_environments"}, {"score": 0.0027817658627604653, "phrase": "fixed_computation_budgets"}, {"score": 0.0027477745788313163, "phrase": "certification_requirements"}, {"score": 0.0027141975147496264, "phrase": "real-time_medical_imaging"}, {"score": 0.002659142621852998, "phrase": "benchmark_problem"}, {"score": 0.002573362191631126, "phrase": "penalty_functions"}, {"score": 0.002500571634075998, "phrase": "important_family"}, {"score": 0.0024298350266697905, "phrase": "bilateral_filtering"}, {"score": 0.0024099937116733227, "phrase": "total_variation"}, {"score": 0.002303720729387236, "phrase": "linear_programming"}, {"score": 0.002229380111189829, "phrase": "segment_images"}, {"score": 0.00219311232069446, "phrase": "different_types"}, {"score": 0.0021662983565317283, "phrase": "priori_knowledge"}, {"score": 0.0021049977753042253, "phrase": "different_penalties"}], "paper_keywords": ["Inverse problem", " Medical imaging", " Neumann series", " Operator splitting", " MRI", " SENSE"], "paper_abstract": "We present an iterative framework for robustly solving large inverse problems arising in imaging using only single-precision (or other reduced-precision) arithmetic, which allows the use of high-density processors (e.g. Cell BE and Graphics Processing Units). Robustness here means linear-convergence even for large problems (billions of variables), with high levels of noise (signal-to-noise levels less than unity). This framework handles problems formulated as quadratic and general non-linear minimization problems. Sparse and dense problems can be treated, as long as there are efficient parallelizable matrix-vector products for the transformations involved. Outer iterations correspond to approximate solutions of a quadratic minimization problem, using a single Newton step. Inner iterations correspond to the estimation of the step via truncated Neumann series or minimax polynomial approximations built from operator splittings. Given the convergence analysis, this approach can also be used in embedded environments with fixed computation budgets, or certification requirements, like real-time medical imaging. We describe a benchmark problem from MRI, and a series of penalty functions suited to this framework. An important family of such penalties is motivated by both bilateral filtering and total variation, and we show how they can be optimized using linear programming. We also discuss penalties designed to segment images, and use different types of a priori knowledge, and show numerically that the different penalties are effective when used in combination.", "paper_title": "Robust Solvers for Inverse Imaging Problems Using Dense Single-Precision Hardware", "paper_id": "WOS:000262315700007"}