{"auto_keywords": [{"score": 0.04863013157799098, "phrase": "runtime_verification"}, {"score": 0.006435976352573809, "phrase": "run_time"}, {"score": 0.004826228006643227, "phrase": "time"}, {"score": 0.0044209926093642235, "phrase": "desirable_logical_properties"}, {"score": 0.004287166497171827, "phrase": "event-triggered_solutions"}, {"score": 0.003663645143713398, "phrase": "constant_invocation"}, {"score": 0.00332924643541238, "phrase": "serious_obstacles"}, {"score": 0.0032728171827367068, "phrase": "safety-critical_systems"}, {"score": 0.003141246279336443, "phrase": "aforementioned_defects"}, {"score": 0.003025277245730244, "phrase": "novel_time-triggered_approach"}, {"score": 0.002903628734069691, "phrase": "constant_frequency"}, {"score": 0.0028349323966217386, "phrase": "system's_health"}, {"score": 0.002786858120570499, "phrase": "formal_semantics"}, {"score": 0.002767856819656175, "phrase": "time-triggered_monitoring"}, {"score": 0.002702363975375762, "phrase": "sampling_period"}, {"score": 0.0026839372202435065, "phrase": "minimum_auxiliary_memory"}, {"score": 0.0026206920330522176, "phrase": "np"}, {"score": 0.0025409639091476363, "phrase": "integer_linear_programming"}, {"score": 0.002497862210672172, "phrase": "real-time_benchmark_suite_show"}, {"score": 0.002340623433237658, "phrase": "negligible_auxiliary_memory"}, {"score": 0.002215897810312801, "phrase": "overall_overhead"}, {"score": 0.0021049977753042253, "phrase": "long_enough_sampling_period"}], "paper_keywords": ["Runtime verification", " Monitoring", " Time-triggered", " Predictability", " Overhead", " Real-time", " Embedded systems"], "paper_abstract": "The goal of runtime verification is to monitor the behavior of a system to check its conformance to a set of desirable logical properties. The literature of runtime verification mostly focuses on event-triggered solutions, where a monitor is invoked when an event of interest occurs (e.g., change in the value of some variable). At invocation, the monitor evaluates the set of properties of the system that are affected by the occurrence of the event. This constant invocation introduces two major defects to the system under scrutiny at run time: (1) significant overhead, and (2) unpredictability of behavior. These defects are serious obstacles when applying runtime verification on safety-critical systems that are time-sensitive by nature. To circumvent the aforementioned defects in runtime verification, in this article, we introduce a novel time-triggered approach, where the monitor takes samples from the system with a constant frequency, in order to analyze the system's health. We describe the formal semantics of time-triggered monitoring and discuss how to optimize the sampling period using minimum auxiliary memory. We show that such optimization is NP-complete and consequently introduce a mapping to Integer Linear Programming. Experiments on a real-time benchmark suite show that our approach introduces bounded overhead and effectively reduces the involvement of the monitor at run time by using negligible auxiliary memory. We also show that in some cases it is even possible to reduce the overall overhead of runtime verification by using our time-triggered approach when the structure of the system allows choosing a long enough sampling period.", "paper_title": "Time-triggered runtime verification", "paper_id": "WOS:000321223500002"}