{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "source_code_changes"}, {"score": 0.004776297980616768, "phrase": "revision_control_systems"}, {"score": 0.004699917295313231, "phrase": "svn"}, {"score": 0.004662211947545807, "phrase": "git"}, {"score": 0.004624751696958501, "phrase": "mercurial"}, {"score": 0.0043533862892678864, "phrase": "development_repositories"}, {"score": 0.004032302251481604, "phrase": "semantic_consequences"}, {"score": 0.003616189733352126, "phrase": "system_release"}, {"score": 0.003501322813520807, "phrase": "release_master"}, {"score": 0.0032038465090068646, "phrase": "related_unchanged_code"}, {"score": 0.0031271827534050493, "phrase": "potential_impact"}, {"score": 0.002884603537502399, "phrase": "visualization_tool"}, {"score": 0.002826949449085849, "phrase": "object-oriented_programs"}, {"score": 0.002748161380979131, "phrase": "torch"}, {"score": 0.0026932247685847246, "phrase": "structural_information"}, {"score": 0.0026500668745484957, "phrase": "symbolic_information"}, {"score": 0.002607598760956807, "phrase": "text-based_diff_information"}, {"score": 0.002494279207996077, "phrase": "current_implementation"}, {"score": 0.0024543014947630876, "phrase": "smalltalk_programs"}, {"score": 0.002357131866579133, "phrase": "pharo"}, {"score": 0.0021917966722180132, "phrase": "release_masters"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Source code", " Visualizations", " Change understanding"], "paper_abstract": "Revision Control Systems (e.g., SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Visually characterizing source code changes", "paper_id": "WOS:000347741200005"}