{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "maple"}, {"score": 0.004592016716046632, "phrase": "potential_benefits"}, {"score": 0.0045302298105691615, "phrase": "partial_evaluation"}, {"score": 0.0036968421974412522, "phrase": "non-standard_features"}, {"score": 0.0035016702571862165, "phrase": "partial_evaluator"}, {"score": 0.0028569549040495163, "phrase": "working_partial_evaluator"}, {"score": 0.002598034157587518, "phrase": "small_codes"}, {"score": 0.0025113494092413604, "phrase": "actual_routines"}, {"score": 0.0024607296642187846, "phrase": "maple's_own_library"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Maple", " Symbolic computation", " Partial evaluation", " Residual theorems"], "paper_abstract": "Having been convinced of the potential benefits of partial evaluation, we wanted to apply these techniques to code written in Maple, our Computer Algebra System of choice. Maple is a very large language, with a number of non-standard features. When we tried to implement a partial evaluator for it, we ran into a number of difficulties for which we could find no solution in the literature. Undaunted, we persevered and ultimately implemented a working partial evaluator with which we were able to very successfully conduct our experiments, first on small codes, and now on actual routines taken from Maple's own library. Here, we document the techniques we had to invent or adapt to achieve these results. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Partial evaluation of Maple", "paper_id": "WOS:000292722300002"}