{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "linked_data_structure_operations"}, {"score": 0.004512814529823301, "phrase": "recursive_linked_data_structures"}, {"score": 0.003932003833923186, "phrase": "current_sat-based_synthesis_techniques"}, {"score": 0.0037150687722055727, "phrase": "simple_approach"}, {"score": 0.003453584878128719, "phrase": "smaller_parts"}, {"score": 0.0033433365160336842, "phrase": "smaller_pieces"}, {"score": 0.0030086877092638945, "phrase": "large_and_complex_routines"}, {"score": 0.002707444334463544, "phrase": "code_synthesis"}, {"score": 0.0025167026017217926, "phrase": "code_generation_algorithm"}, {"score": 0.002416589459425828, "phrase": "linked_data_structures"}, {"score": 0.0022281257694320455, "phrase": "proposed_algorithm"}, {"score": 0.0021049977753042253, "phrase": "avl_tree"}], "paper_keywords": ["Languages", " code generation algorithm", " program synthesis", " SAT-solver", " linked data structures", " AVL trees"], "paper_abstract": "We argue that synthesizing operations on recursive linked data structures is not as hard as it appears and is, in fact, within reach of current SAT-based synthesis techniques-with the addition of a simple approach that we describe to decompose the problem into smaller parts. To generate smaller pieces of code, i.e., shorter routines, is obviously easier than large and complex routines, and, also, there is more potential for automating the code synthesis. In this paper, we present a code generation algorithm for synthesizing operations of linked data structures and, as an example, describe how the proposed algorithm works to synthesize operations of an AVL tree.", "paper_title": "On the Simplicity of Synthesizing Linked Data Structure Operations", "paper_id": "WOS:000338625500018"}