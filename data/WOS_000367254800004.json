{"auto_keywords": [{"score": 0.03657526290162966, "phrase": "synthesis_algorithm"}, {"score": 0.00481495049065317, "phrase": "semantic_locking"}, {"score": 0.004583205112737672, "phrase": "concurrent_programs"}, {"score": 0.004471530397729526, "phrase": "shared_state"}, {"score": 0.004335739075947899, "phrase": "linearizable_adts"}, {"score": 0.004076352180903171, "phrase": "automated_approach"}, {"score": 0.004026359831748917, "phrase": "concurrency_control"}, {"score": 0.0039281997063335735, "phrase": "common_need"}, {"score": 0.003738973626996355, "phrase": "code_fragment"}, {"score": 0.003625347557965931, "phrase": "multiple_adt_operations"}, {"score": 0.0035808664384880213, "phrase": "multiple_adt_instances"}, {"score": 0.0032641439000713306, "phrase": "client_program"}, {"score": 0.0031845067058084583, "phrase": "pessimistic_synchronization"}, {"score": 0.0029937855454238507, "phrase": "rollback_mechanism"}, {"score": 0.0028848643090508205, "phrase": "commutativity_specification"}, {"score": 0.002831894638104635, "phrase": "extra_input"}, {"score": 0.002678734566245688, "phrase": "adt_operations"}, {"score": 0.0025027144548626975, "phrase": "greater_parallelism"}, {"score": 0.002456744238900652, "phrase": "commuting_operations"}, {"score": 0.002281134611390528, "phrase": "java_compiler"}, {"score": 0.0021049977753042253, "phrase": "efficient_and_scalable_synchronization"}], "paper_keywords": ["Automatic synchronization", " Transactions", " Semantics"], "paper_abstract": "In this paper, we consider concurrent programs in which the shared state consists of instances of linearizable ADTs (abstract data types). We present an automated approach to concurrency control that addresses a common need: the need to atomically execute a code fragment, which may contain multiple ADT operations on multiple ADT instances. We present a synthesis algorithm that automatically enforces atomicity of given code fragments (in a client program) by inserting pessimistic synchronization that guarantees atomicity and deadlock-freedom (without using any rollback mechanism). Our algorithm takes a commutativity specification as an extra input. This specification indicates for every pair of ADT operations the conditions under which the operations commute. Our algorithm enables greater parallelism by permitting commuting operations to execute concurrently. We have implemented the synthesis algorithm in a Java compiler, and applied it to several Java programs. Our results show that our approach produces efficient and scalable synchronization.", "paper_title": "Automatic Scalable Atomicity via Semantic Locking", "paper_id": "WOS:000367254800004"}