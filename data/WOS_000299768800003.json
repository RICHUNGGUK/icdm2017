{"auto_keywords": [{"score": 0.04625710411123423, "phrase": "software_development"}, {"score": 0.03333227456953711, "phrase": "modeling_notations"}, {"score": 0.00481495049065317, "phrase": "component-based_software"}, {"score": 0.0047787596516662, "phrase": "model-driven_architecture"}, {"score": 0.004654210559456924, "phrase": "main_stream_technology"}, {"score": 0.0046192222897398685, "phrase": "software-intensive_system_design"}, {"score": 0.004567230180529598, "phrase": "main_engineering_principle"}, {"score": 0.004464987136420614, "phrase": "inherent_complexity"}, {"score": 0.004251210982670317, "phrase": "system_models"}, {"score": 0.0042192613869321575, "phrase": "mda"}, {"score": 0.004156012879026324, "phrase": "system_complexity"}, {"score": 0.004109212945115815, "phrase": "component-based_design_techniques"}, {"score": 0.004062937864702115, "phrase": "independent_component_design"}, {"score": 0.003853757393357659, "phrase": "component_interfaces"}, {"score": 0.003627800727103479, "phrase": "different_viewpoints"}, {"score": 0.003546513036085932, "phrase": "model-driven_method"}, {"score": 0.0033511469200347907, "phrase": "integrated_suite"}, {"score": 0.0033008858616145205, "phrase": "model_construction"}, {"score": 0.0030955250132409964, "phrase": "different_concerns"}, {"score": 0.002913895605074143, "phrase": "unified_theory"}, {"score": 0.002859345731792013, "phrase": "underlying_theory"}, {"score": 0.002722234804904997, "phrase": "correct_use"}, {"score": 0.0025335509856200433, "phrase": "mission-critical_applications"}, {"score": 0.002340147988348115, "phrase": "development_activities"}, {"score": 0.0022876463319883634, "phrase": "software_design_processes"}, {"score": 0.002129020447793464, "phrase": "different_stages"}, {"score": 0.0021049977753042253, "phrase": "software_development_process"}], "paper_keywords": ["component-based design", " models", " model transformations", " verification", " tool support"], "paper_abstract": "Model-driven architecture (MDA) has become a main stream technology for software-intensive system design. The main engineering principle behind it is that the inherent complexity of software development can only be mastered by building, analyzing and manipulating system models. MDA also deals with system complexity by providing component-based design techniques, allowing independent component design, implementation and deployment, and then system integration and reconfiguration based on component interfaces. The model of a system in any stage is an integration of models of different viewpoints. Therefore, for a model-driven method to be applied effectively, it must provide a body of techniques and an integrated suite of tools for model construction, validation, and transformation. This requires a number of modeling notations for the specification of different concerns and viewpoints of the system. These notations should have formally defined syntaxes and a unified theory of semantics. The underlying theory of the method is needed to underpin the development of tools and correct use of tools in software development, as well as to formally verify and reason about properties of systems in mission-critical applications. The modeling notations, techniques, and tools must be designed so that they can be used seamlessly in supporting development activities and documentation of artifacts in software design processes. This article presents such a method, called the rCOS, focusing on the models of a system at different stages in a software development process, their semantic integration, and how they are constructed, analyzed, transformed, validated, and verified.", "paper_title": "rCOS: a formal model-driven engineering method for component-based software", "paper_id": "WOS:000299768800003"}