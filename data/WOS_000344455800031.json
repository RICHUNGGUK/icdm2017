{"auto_keywords": [{"score": 0.034692465572853035, "phrase": "vericon"}, {"score": 0.007397917515013214, "phrase": "computer_networks"}, {"score": 0.00481495049065317, "phrase": "verifying_controller_programs"}, {"score": 0.004787240162944703, "phrase": "admissible_network_topologies"}, {"score": 0.004785896736401194, "phrase": "software-defined_networks"}, {"score": 0.004757017456572827, "phrase": "software-defined_networking"}, {"score": 0.004671416117092309, "phrase": "new_paradigm"}, {"score": 0.0045734970395410355, "phrase": "sdn"}, {"score": 0.004545880476042911, "phrase": "logically-centralized_control"}, {"score": 0.004464061452094005, "phrase": "\"controller\"_software"}, {"score": 0.00438370856272802, "phrase": "network_hardware"}, {"score": 0.004278807087784626, "phrase": "network_operating_system"}, {"score": 0.004252974635533396, "phrase": "network_operators"}, {"score": 0.004201774694043468, "phrase": "inhouse_and_third-party_sdn_programs"}, {"score": 0.003966833706820594, "phrase": "access_control_policies"}, {"score": 0.003860158978186175, "phrase": "formal_methods"}, {"score": 0.0036663981146086103, "phrase": "finite_state_model"}, {"score": 0.003611276113861415, "phrase": "sdn_programs"}, {"score": 0.0034717929086014636, "phrase": "large_networks"}, {"score": 0.0031990183472675377, "phrase": "sdn_program"}, {"score": 0.003150900886669123, "phrase": "admissible_topologies"}, {"score": 0.0030017207229983385, "phrase": "controller_program"}, {"score": 0.002938688858078236, "phrase": "concrete_counterexample"}, {"score": 0.0029032649701963014, "phrase": "first-order_logic"}, {"score": 0.0028595832692215766, "phrase": "desired_network-wide_invariants"}, {"score": 0.002816556934231128, "phrase": "classical_floyd-hoare-dijkstra_deductive_verification"}, {"score": 0.0026427848602443267, "phrase": "large_repertoire"}, {"score": 0.0026268035120419536, "phrase": "simple_core_sdn_programs"}, {"score": 0.002487240194265389, "phrase": "single_network_event"}, {"score": 0.002391067964886602, "phrase": "large_programs"}, {"score": 0.002333738303480471, "phrase": "inductive_invariants"}, {"score": 0.0022777800735119405, "phrase": "separate_procedure"}, {"score": 0.002196342933346204, "phrase": "simple_controller_programs"}, {"score": 0.0021501863832966966, "phrase": "first_step"}, {"score": 0.002124247104243502, "phrase": "practical_mechanisms"}, {"score": 0.0021049977753042253, "phrase": "network-wide_invariants"}], "paper_keywords": ["Languages", " Verification", " Software-defined networks", " Hoare-style verification"], "paper_abstract": "Software-defined networking (SDN) is a new paradigm for operating and managing computer networks. SDN enables logically-centralized control over network devices through a \"controller\" software that operates independently from the network hardware, and can be viewed as the network operating system. Network operators can run both inhouse and third-party SDN programs (often called applications) on top of the controller, e. g., to specify routing and access control policies. SDN opens up the possibility of applying formal methods to prove the correctness of computer networks. Indeed, recently much effort has been invested in applying finite state model checking to check that SDN programs behave correctly. However, in general, scaling these methods to large networks is challenging and, moreover, they cannot guarantee the absence of errors. We present VeriCon, the first system for verifying that an SDN program is correct on all admissible topologies and for all possible (infinite) sequences of network events. VeriCon either confirms the correctness of the controller program on all admissible network topologies or outputs a concrete counterexample. VeriCon uses first-order logic to specify admissible network topologies and desired network-wide invariants, and then implements classical Floyd-Hoare-Dijkstra deductive verification using Z3. Our preliminary experience indicates that VeriCon is able to rapidly verify correctness, or identify bugs, for a large repertoire of simple core SDN programs. VeriCon is compositional, in the sense that it verifies the correctness of execution of any single network event w.r.t. the specified invariant, and can thus scale to handle large programs. To relieve the burden of specifying inductive invariants from the programmer, VeriCon includes a separate procedure for inferring invariants, which is shown to be effective on simple controller programs. We view VeriCon as a first step en route to practical mechanisms for verifying network-wide invariants of SDN programs.", "paper_title": "VeriCon: Towards Verifying Controller Programs in Software-Defined Networks", "paper_id": "WOS:000344455800031"}