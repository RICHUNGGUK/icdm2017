{"auto_keywords": [{"score": 0.04979106692834644, "phrase": "graph_transformation"}, {"score": 0.0135399446760717, "phrase": "security_properties"}, {"score": 0.012640089467119042, "phrase": "security_weaknesses"}, {"score": 0.009090211598765585, "phrase": "security_requirements"}, {"score": 0.00481495049065317, "phrase": "software_models"}, {"score": 0.004757227624616643, "phrase": "security_certification"}, {"score": 0.004728624975677976, "phrase": "complex_systems"}, {"score": 0.004686041610317898, "phrase": "high_amount"}, {"score": 0.004602016568817581, "phrase": "particular_challenge"}, {"score": 0.004574342831225094, "phrase": "today's_systems"}, {"score": 0.004451846834142146, "phrase": "continuous_change"}, {"score": 0.004280651472525981, "phrase": "whole_system"}, {"score": 0.004091248980678087, "phrase": "general_modular"}, {"score": 0.004017846065981189, "phrase": "far_too_much_effort"}, {"score": 0.0037825134619339537, "phrase": "software_system"}, {"score": 0.0032821417644980674, "phrase": "tool-supported_way"}, {"score": 0.0032037993117317175, "phrase": "diverse_number"}, {"score": 0.0031845067058084583, "phrase": "changing_requirements"}, {"score": 0.0031084874662053426, "phrase": "non-security-related_lead"}, {"score": 0.0030251262102203385, "phrase": "design_time"}, {"score": 0.002952900365829518, "phrase": "meanwhile_updated_security_knowledge"}, {"score": 0.0028650312174624635, "phrase": "potential_flaws"}, {"score": 0.002754687859754749, "phrase": "potential_violations"}, {"score": 0.0026646374739979694, "phrase": "correction_alternatives"}, {"score": 0.002546554566866823, "phrase": "different_types"}, {"score": 0.0024932498388507084, "phrase": "flaw_detection"}, {"score": 0.0024336917123957387, "phrase": "left-hand_sides"}, {"score": 0.002419025278429845, "phrase": "graph_transformation_rules"}, {"score": 0.0021049977753042253, "phrase": "security_vulnerabilities"}], "paper_keywords": ["Evolution", " Graph transformation", " Model transformation", " Model-based software engineering security"], "paper_abstract": "Security certification of complex systems requires a high amount of effort. As a particular challenge, today's systems are increasingly long-living and subject to continuous change. After each change of some part of the system, the whole system needs to be re-certified from scratch ( since security properties are not in general modular), which is usually far too much effort. When models for software get changed, this can lead to security weaknesses that are also part of the software system that is derived from those models. Hence, it is important to check the models with respect to security properties and correct them respectively. To address this challenge, we present an approach which not only finds security weaknesses but can also correct them in a tool-supported way. As time goes by, a diverse number of changing requirements that may be security-related and non-security-related lead to an evolving system that met its security requirements at design time but can contain vulnerabilities with respect to meanwhile updated security knowledge. Supported by patterns we can describe and detect potential flaws that may arise in models, such as inconsistencies in security requirements. Potential violations can be formalized in the patterns as well as the correction alternatives to fix these. It is based on graph transformation and can be applied to different types of models and violations. For flaw detection, these patterns are used as the left-hand sides of graph transformation rules. Using graph transformation, we can further correct the models and establish that they no longer violate the security requirements under investigation. The approach is supported by a tool which can check whether these patterns arise in models and assist the user in correcting the security vulnerabilities.", "paper_title": "Restoring security of evolving software models using graph transformation", "paper_id": "WOS:000355682600003"}