{"auto_keywords": [{"score": 0.0360693023549226, "phrase": "data_races"}, {"score": 0.032646468497261105, "phrase": "sequential_consistency"}, {"score": 0.0047559432344272, "phrase": "multi-threaded_c"}, {"score": 0.004640079189342692, "phrase": "single-threaded_programming_language"}, {"score": 0.004583205112737672, "phrase": "separate_threads_library"}, {"score": 0.004018087343963485, "phrase": "next_revision"}, {"score": 0.003809055170833428, "phrase": "java"}, {"score": 0.003625347557965931, "phrase": "well-defined_and_interesting_subset"}, {"score": 0.0035224030823976186, "phrase": "sequentially_consistent_semantics"}, {"score": 0.0031910685060552485, "phrase": "java_effort"}, {"score": 0.0030623570435946977, "phrase": "race-free_programs"}, {"score": 0.002999955539996569, "phrase": "implementation_issues"}, {"score": 0.0029147175927233546, "phrase": "java_work"}, {"score": 0.0027064605585684696, "phrase": "weaker_semantics"}, {"score": 0.002684257009647205, "phrase": "try_lock"}, {"score": 0.0026622351303038885, "phrase": "existing_languages"}, {"score": 0.002544296663333569, "phrase": "intuitive_race_definition"}, {"score": 0.0024116163689723354, "phrase": "simple_model"}, {"score": 0.0021576973674470997, "phrase": "implementation_constraints"}], "paper_keywords": ["languages", " standardization", " reliability", " memory consistency", " memory model", " sequential consistency", " C plus", " trylock", " data race"], "paper_abstract": "Currently multi-threaded C or C++ programs combine a single-threaded programming language with a separate threads library. This is not entirely sound [ 7]. We describe an effort, currently nearing completion, to address these issues by explicitly providing semantics for threads in the next revision of the C++ standard. Our approach is similar to that recently followed by Java [ 25], in that, at least for a well-defined and interesting subset of the language, we give sequentially consistent semantics to programs that do not contain data races. Nonetheless, a number of our decisions are often surprising even to those familiar with the Java effort: We ( mostly) insist on sequential consistency for race-free programs, in spite of implementation issues that came to light after the Java work. We give no semantics to programs with data races. There are no benign C++ data races. We use weaker semantics for try lock than existing languages or libraries, allowing us to promise sequential consistency with an intuitive race definition, even for programs with try lock. This paper describes the simple model we would like to be able to provide for C++ threads programmers, and explain how this, together with some practical, but often under-appreciated implementation constraints, drives us towards the above decisions.", "paper_title": "Foundations of the C++ concurrency memory model", "paper_id": "WOS:000257820400007"}