{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "framebuffer_level"}, {"score": 0.0047559432344272, "phrase": "detail_algorithm"}, {"score": 0.004640079189342692, "phrase": "pixel_workload"}, {"score": 0.004555028829645471, "phrase": "interactive_rendering_application"}, {"score": 0.00428257928723, "phrase": "low_resolution_buffer"}, {"score": 0.004152502093643003, "phrase": "second_rendering_pass"}, {"score": 0.003976978140059542, "phrase": "desired_screen_resolution"}, {"score": 0.003832423454781517, "phrase": "lower_resolution_buffer"}, {"score": 0.0037159680715717056, "phrase": "rendering_time"}, {"score": 0.0035369291417564606, "phrase": "final_shading"}, {"score": 0.0034083145672246067, "phrase": "approximation_error"}, {"score": 0.0033251716926666437, "phrase": "feature-preserving_reconstruction_technique"}, {"score": 0.0031260524791486347, "phrase": "normal_discontinuities"}, {"score": 0.0030123335878664064, "phrase": "intermediate_components"}, {"score": 0.002831894638104635, "phrase": "finer-grained_control"}, {"score": 0.0026622351303038885, "phrase": "simple_control_mechanism"}, {"score": 0.002471973283582411, "phrase": "target_framerate"}, {"score": 0.0022531089868518235, "phrase": "modern_gpus"}], "paper_keywords": [""], "paper_abstract": "This paper introduces a framebuffer level of detail algorithm for controlling the pixel workload in an interactive rendering application. Our basic strategy is to evaluate the shading in a low resolution buffer and, in a second rendering pass, resample this buffer at the desired screen resolution. The size of the lower resolution buffer provides a trade-off between rendering time and the level of detail in the final shading. In order to reduce approximation error we use a feature-preserving reconstruction technique that more faithfully approximates the shading near depth and normal discontinuities. We also demonstrate how intermediate components of the shading can be selectively resized to provide finer-grained control over resource allocation. Finally, we introduce a simple control mechanism that continuously adjusts the amount of resizing necessary to maintain a target framerate. These techniques do not require any preprocessing, are straightforward to implement on modern GPUs, and are shown to provide significant performance gains for several pixel-bound scenes.", "paper_title": "Geometry-aware framebuffer level of detail", "paper_id": "WOS:000258223600015"}