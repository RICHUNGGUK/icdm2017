{"auto_keywords": [{"score": 0.02987089440189968, "phrase": "jellyfish"}, {"score": 0.00481495049065317, "phrase": "efficient_parallel_counting"}, {"score": 0.004250302819248558, "phrase": "long_string"}, {"score": 0.004184526032558792, "phrase": "central_subproblem"}, {"score": 0.0040771431404398855, "phrase": "genome_assembly"}, {"score": 0.003972504904621217, "phrase": "sequencing_reads"}, {"score": 0.003931402465972151, "phrase": "fast_multiple_sequence_alignment"}, {"score": 0.003771185758226876, "phrase": "deep_sequence_coverage"}, {"score": 0.003712796038920873, "phrase": "next-generation_sequencing_technologies"}, {"score": 0.0034881076466982226, "phrase": "genome_project"}, {"score": 0.003345895878114341, "phrase": "current_k-mer_counting_tools"}, {"score": 0.0031597433845085092, "phrase": "large_multicore_computers"}, {"score": 0.003078577062864183, "phrase": "research_facilities"}, {"score": 0.0030151432267065815, "phrase": "new_parallel_computational_paradigm"}, {"score": 0.0029072537537959374, "phrase": "new_k-mer_counting_algorithm"}, {"score": 0.002385326947545194, "phrase": "suffix_arrays"}, {"score": 0.0023361440016375972, "phrase": "data_structure"}, {"score": 0.002206045784326466, "phrase": "k-mer_counting"}], "paper_keywords": [""], "paper_abstract": "Motivation: Counting the number of occurrences of every k-mer (substring of length k) in a long string is a central subproblem in many applications, including genome assembly, error correction of sequencing reads, fast multiple sequence alignment and repeat detection. Recently, the deep sequence coverage generated by next-generation sequencing technologies has caused the amount of sequence to be processed during a genome project to grow rapidly, and has rendered current k-mer counting tools too slow and memory intensive. At the same time, large multicore computers have become commonplace in research facilities allowing for a new parallel computational paradigm. Results: We propose a new k-mer counting algorithm and associated implementation, called Jellyfish, which is fast and memory efficient. It is based on a multithreaded, lock-free hash table optimized for counting k-mers up to 31 bases in length. Due to their flexibility, suffix arrays have been the data structure of choice for solving many string problems. For the task of k-mer counting, important in many biological applications, Jellyfish offers a much faster and more memory-efficient solution.", "paper_title": "A fast, lock-free approach for efficient parallel counting of occurrences of k-mers", "paper_id": "WOS:000288277300004"}