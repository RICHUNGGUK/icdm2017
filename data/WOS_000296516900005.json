{"auto_keywords": [{"score": 0.0315457378628608, "phrase": "step_complexity"}, {"score": 0.00481495049065317, "phrase": "long-lived_renaming"}, {"score": 0.0045820747375409435, "phrase": "distinct_names"}, {"score": 0.00446987606516801, "phrase": "small_name_space"}, {"score": 0.0038518661517315533, "phrase": "name_a_process"}, {"score": 0.0032109670662222416, "phrase": "first_algorithm"}, {"score": 0.0021049977753042253, "phrase": "process_crashes"}], "paper_keywords": ["Renaming", " Shared memory", " Fault tolerant", " Asynchronous", " Synchronous", " Adaptivity"], "paper_abstract": "Long-lived renaming allows processes to repeatedly get distinct names from a small name space and release these names. This paper presents two long-lived renaming algorithms in which the name a process gets is bounded above by the number of processes currently occupying a name or performing one of these operations. The first algorithm is asynchronous, uses LL/SC objects, and has step complexity that is linear in the number of processes, c, currently getting or releasing a name. The second is synchronous, uses registers and counters, and has step complexity that is polylogarithmic in c. Both tolerate any number of process crashes.", "paper_title": "Fully-adaptive algorithms for long-lived renaming", "paper_id": "WOS:000296516900005"}