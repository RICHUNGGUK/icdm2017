{"auto_keywords": [{"score": 0.0497931443562307, "phrase": "flash_memory"}, {"score": 0.042646835916719104, "phrase": "flash_codes"}, {"score": 0.03877346340921445, "phrase": "block_erasure"}, {"score": 0.03734218400951657, "phrase": "coding_scheme"}, {"score": 0.00481495049065317, "phrase": "flash_memories"}, {"score": 0.004743423032820112, "phrase": "nonvolatile_computer_memory"}, {"score": 0.0045760425755563714, "phrase": "q_different_values"}, {"score": 0.004481132747216135, "phrase": "cell_level"}, {"score": 0.004258717300328513, "phrase": "entire_block"}, {"score": 0.004220624516321415, "phrase": "block_erasures"}, {"score": 0.004157889052612049, "phrase": "coding_schemes"}, {"score": 0.004108369978176129, "phrase": "floating_codes"}, {"score": 0.004035190488387378, "phrase": "buffer_codes"}, {"score": 0.0035794251590584563, "phrase": "flash_code_c"}, {"score": 0.0035051129798529, "phrase": "information_bits"}, {"score": 0.0034841647157189985, "phrase": "n_cells"}, {"score": 0.0032912755695190163, "phrase": "total_number"}, {"score": 0.0032716011062067286, "phrase": "available_level_transitions"}, {"score": 0.0025892330566358503, "phrase": "buffer_code"}, {"score": 0.0025202582748972122, "phrase": "r_l-ary_symbols"}, {"score": 0.00240213106042981, "phrase": "last_r_symbols"}, {"score": 0.0023381288193776778, "phrase": "previous_upper"}, {"score": 0.002310232205403468, "phrase": "maximum_number"}, {"score": 0.0022352169832099153, "phrase": "single_cell"}, {"score": 0.0021304214257321, "phrase": "jiang_et_al"}, {"score": 0.0021049977753042253, "phrase": "multiple_cells"}], "paper_keywords": ["Buffer codes", " coding theory", " flash codes", " flash memories"], "paper_abstract": "Flash memory is a nonvolatile computer memory comprising blocks of cells, wherein each cell can take on q different values or levels. While increasing the cell level is easy, reducing the level of a cell can be accomplished only by erasing an entire block. Since block erasures are highly undesirable, coding schemes-known as floating codes (or flash codes) and buffer codes-have been designed in order to maximize the number of times that information stored in a flash memory can be written (and rewritten) prior to incurring a block erasure. An (n, k, t)(q) flash code C is a coding scheme for storing k information bits in n cells in such a way that any sequence of up to t writes can be accommodated without a block erasure. The total number of available level transitions in n cells is n(q-1), and the write deficiency of C, defined as delta(C) = n(q-1) - t, is a measure of how close the code comes to perfectly utilizing all these transitions. In this paper, we show a construction of flash codes with write deficiency O(qk log k) if q >= log(2) k, and at most O(k log(2) k) otherwise. An (n, r, l, t) q buffer code is a coding scheme for storing a buffer of r l-ary symbols such that for any sequence of t symbols, it is possible to successfully decode the last r symbols that were written. We improve upon a previous upper bound on the maximum number of writes t in the case where there is a single cell to store the buffer. Then, we show how to improve a construction by Jiang et al. that uses multiple cells, where n >= 2r.", "paper_title": "Rewriting Codes for Flash Memories", "paper_id": "WOS:000330286100013"}