{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "abstract_garbage_collection"}, {"score": 0.005128696723443849, "phrase": "garbage_collection"}, {"score": 0.004740823885631586, "phrase": "static_analysis"}, {"score": 0.004704187604192605, "phrase": "functional_programs"}, {"score": 0.004252793268613575, "phrase": "theoretical_and_practical_challenges"}, {"score": 0.004027876348834879, "phrase": "pushdown_flow_analysis_grants"}, {"score": 0.003859500298805362, "phrase": "higher-order_programs"}, {"score": 0.003770633265791941, "phrase": "unbounded_polyvariance"}, {"score": 0.0037414662674652805, "phrase": "abstract_addresses"}, {"score": 0.003627028894710926, "phrase": "abstract_contexts"}, {"score": 0.0035297609635321203, "phrase": "pushdown_analysis"}, {"score": 0.003408512155673965, "phrase": "higherorder_languages"}, {"score": 0.003304224820203298, "phrase": "\"stickiness\"_problem"}, {"score": 0.0031660031870090434, "phrase": "analysis_times"}, {"score": 0.002861782260525497, "phrase": "reachable_control_states"}, {"score": 0.002828611294209297, "phrase": "pushdown_system"}, {"score": 0.002606906626639414, "phrase": "full_access"}, {"score": 0.0025766822940260963, "phrase": "entire_stack"}, {"score": 0.002536926192232391, "phrase": "root_set"}, {"score": 0.0024977819584875573, "phrase": "concrete_collection"}, {"score": 0.0024688196796198766, "phrase": "conditional_pushdown_systems"}, {"score": 0.0024025371556472557, "phrase": "existing_methods"}, {"score": 0.0023380300046435187, "phrase": "dynamic_nature"}, {"score": 0.0022841153001549193, "phrase": "fully_precise_and_approximate_solutions"}, {"score": 0.0022576249214220187, "phrase": "feasible_paths_problem"}, {"score": 0.00224013518726087, "phrase": "pushdown_garbage-collecting_control-flow_analysis"}, {"score": 0.002163089417146551, "phrase": "pushdown_techniques"}, {"score": 0.0021049977753042253, "phrase": "better-than-bothworlds\"_precision"}], "paper_keywords": [""], "paper_abstract": "In the static analysis of functional programs, pushdown flow analysis and abstract garbage collection push the boundaries of what we can learn about programs statically. This work illuminates and poses solutions to theoretical and practical challenges that stand in the way of combining the power of these techniques. Pushdown flow analysis grants unbounded yet computable polyvariance to the analysis of return-flow in higher-order programs. Abstract garbage collection grants unbounded polyvariance to abstract addresses which become unreachable between invocations of the abstract contexts in which they were created. Pushdown analysis solves the problem of precisely analyzing recursion in higherorder languages; abstract garbage collection is essential in solving the \"stickiness\" problem. Alone, our benchmarks demonstrate that each method can reduce analysis times and boost precision by orders of magnitude. We combine these methods. The challenge in marrying these techniques is not subtle: computing the reachable control states of a pushdown system relies on limiting access during transition to the top of the stack; abstract garbage collection, on the other hand, needs full access to the entire stack to compute a root set, just as concrete collection does. Conditional pushdown systems were developed for just such a conundrum, but existing methods are ill-suited for the dynamic nature of garbage collection. We show fully precise and approximate solutions to the feasible paths problem for pushdown garbage-collecting control-flow analysis. Experiments reveal synergistic interplay between garbage collection and pushdown techniques, and the fusion demonstrates \"better-than-bothworlds\" precision.", "paper_title": "Pushdown flow analysis with abstract garbage collection", "paper_id": "WOS:000339550500004"}