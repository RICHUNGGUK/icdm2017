{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "real-time_programs"}, {"score": 0.004539005582217309, "phrase": "real-time_control_programs"}, {"score": 0.002966438503447793, "phrase": "suitable_refinement_orderings"}, {"score": 0.002846175473457555, "phrase": "dijkstra's_weakest_precondition"}, {"score": 0.002763261749602258, "phrase": "first_alternative"}, {"score": 0.0027307746993761035, "phrase": "weakest_liberal_preconditions"}, {"score": 0.002498961351132696, "phrase": "third_alternative"}, {"score": 0.0021049977753042253, "phrase": "relational_semantics"}], "paper_keywords": [""], "paper_abstract": "Real-time control programs are often used in contexts where (conceptually) they run forever. Repetitions within such programs (or their specifications) may either (i) be guaranteed to terminate, (ii) be guaranteed to never terminate (loop forever), or (iii) may possibly terminate. In dealing with real-time programs and their specifications, we need to be able to represent these possibilities, and define suitable refinement orderings. A refinement ordering based on Dijkstra's weakest precondition only copes with the first alternative. Weakest liberal preconditions allow one to constrain behaviour provided the program terminates, which copes with the third alternative to some extent. However, neither of these handles the case when a program does not terminate. To handle this case a refinement ordering based on relational semantics can be used. In this paper we explore these issues and the definition of loops for real-time programs as well as corresponding refinement laws.", "paper_title": "Termination of real-time programs: Definitely, definitely not, or maybe", "paper_id": "WOS:000239422200009"}