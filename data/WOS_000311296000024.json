{"auto_keywords": [{"score": 0.03679411324829639, "phrase": "nesl"}, {"score": 0.029126933511886773, "phrase": "ndp"}, {"score": 0.00481495049065317, "phrase": "nested_data-parallelism"}, {"score": 0.0047267100475487595, "phrase": "processing_units"}, {"score": 0.004555028829645471, "phrase": "memory_bandwidth"}, {"score": 0.0044991925146184025, "phrase": "arithmetic_performance"}, {"score": 0.003738973626996355, "phrase": "traditional_data-level_parallelism"}, {"score": 0.0034294219963679857, "phrase": "first-order_functional_language"}, {"score": 0.003244050414264445, "phrase": "irregular-parallel_programs"}, {"score": 0.0031649018957020337, "phrase": "parallel_divide-and-conquer_algorithms"}, {"score": 0.0031068064097811844, "phrase": "wide-vector_parallel_computers"}, {"score": 0.0029570303644956128, "phrase": "nesl_implementation"}, {"score": 0.002831894638104635, "phrase": "empirical_evidence"}, {"score": 0.0026458370516131255, "phrase": "cpu-based_implementations"}, {"score": 0.002565345470805401, "phrase": "newer_gpu_languages"}, {"score": 0.0023819914954155905, "phrase": "hand-tuned_cuda_programs"}, {"score": 0.002295277579105177, "phrase": "notational_conciseness"}, {"score": 0.0021049977753042253, "phrase": "first_language_implementation"}], "paper_keywords": ["Languages", " Performance", " GPU", " GPGPU", " NESL", " nested data parallelism"], "paper_abstract": "Graphics processing units (GPUs) provide both memory bandwidth and arithmetic performance far greater than that available on CPUs but, because of their Single-Instruction-Multiple-Data (SIMD) architecture, they are hard to program. Most of the programs ported to GPUs thus far use traditional data-level parallelism, performing only operations that operate uniformly over vectors. NESL is a first-order functional language that was designed to allow programmers to write irregular-parallel programs - such as parallel divide-and-conquer algorithms - for wide-vector parallel computers. This paper presents our port of the NESL implementation to work on GPUs and provides empirical evidence that nested data-parallelism (NDP) on GPUs significantly outperforms CPU-based implementations and matches or beats newer GPU languages that support only flat parallelism. While our performance does not match that of hand-tuned CUDA programs, we argue that the notational conciseness of NESL is worth the loss in performance. This work provides the first language implementation that directly supports NDP on a GPU.", "paper_title": "Nested Data-Parallelism on the GPU", "paper_id": "WOS:000311296000024"}