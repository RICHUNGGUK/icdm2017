{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "memory_layouts"}, {"score": 0.004718897469501381, "phrase": "verification_methods"}, {"score": 0.004624751696958501, "phrase": "memory-manipulating_c_programs"}, {"score": 0.004139401327448803, "phrase": "split-heap_memory_model"}, {"score": 0.003780286517897356, "phrase": "arbitrary_memory_objects"}, {"score": 0.0036676174658755683, "phrase": "local_variables"}, {"score": 0.003594369823549604, "phrase": "single_struct_fields"}, {"score": 0.003487222504700868, "phrase": "array_slices"}, {"score": 0.0023523750536537102, "phrase": "data_structures"}, {"score": 0.0021049977753042253, "phrase": "schorr-waite_graph"}], "paper_keywords": ["C verification", " Low-level memory models", " Pointer programs", " Schorr-Waite graph traversal"], "paper_abstract": "Verification methods for memory-manipulating C programs need to address not only well-typed programs that respect invariants such as the split-heap memory model, but also programs that access through pointers arbitrary memory objects such as local variables, single struct fields, or array slices. We present a logic for memory layouts that covers these applications and show how proof obligations arising during the verification can be discharged automatically using the layouts. The framework developed in this way is also suitable for reasoning about data structures manipulated by algorithms, which we demonstrate by verifying the Schorr-Waite graph marking algorithm.", "paper_title": "Reasoning about memory layouts", "paper_id": "WOS:000286631700003"}