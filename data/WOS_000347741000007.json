{"auto_keywords": [{"score": 0.0481103253229687, "phrase": "bp"}, {"score": 0.006759581381771291, "phrase": "behavioral_programming"}, {"score": 0.005844711115121563, "phrase": "erlang"}, {"score": 0.005311989677729895, "phrase": "incremental_development"}, {"score": 0.004789760466836797, "phrase": "distributed_architectures"}, {"score": 0.004256409969563333, "phrase": "separate_machines"}, {"score": 0.004178935413340453, "phrase": "reactive_applications"}, {"score": 0.00409211122248989, "phrase": "desired_and_undesired_scenarios"}, {"score": 0.00397565401009627, "phrase": "requirements_document"}, {"score": 0.0039341294012600085, "phrase": "enhancement_request"}, {"score": 0.0038930368103015467, "phrase": "field_problem_report"}, {"score": 0.0038624981944755813, "phrase": "key_advantage"}, {"score": 0.003762415923844781, "phrase": "loosely_coupled_modules"}, {"score": 0.0036745528601286417, "phrase": "meaningful_prototype_execution"}, {"score": 0.0036171162332222836, "phrase": "early_stages"}, {"score": 0.003432044343307207, "phrase": "separate_facet"}, {"score": 0.0032223742018434856, "phrase": "behavior_threads"}, {"score": 0.0032054891061528896, "phrase": "efficient_implementation"}, {"score": 0.0031803266834374766, "phrase": "physically_distributed_environment"}, {"score": 0.0031553611552558986, "phrase": "significant_challenge"}, {"score": 0.0031141853323221414, "phrase": "broader_acceptance"}, {"score": 0.0030735451757603555, "phrase": "viable_new_way"}, {"score": 0.002931569771634119, "phrase": "coordination_protocol"}, {"score": 0.002833116698602608, "phrase": "distributed_systems"}, {"score": 0.0027887956749296995, "phrase": "bp_advantages"}, {"score": 0.002737960968372391, "phrase": "code_modules"}, {"score": 0.002673957615079041, "phrase": "general_bp_design_patterns"}, {"score": 0.0025977542995083624, "phrase": "distributed_applications"}, {"score": 0.0025237171554924128, "phrase": "full_synchronization"}, {"score": 0.0024134149741656557, "phrase": "different_time_scales"}, {"score": 0.0023818980286716826, "phrase": "external_input"}, {"score": 0.00235698036946969, "phrase": "entire_system"}, {"score": 0.0022958180852458215, "phrase": "execution_mechanism"}, {"score": 0.0021896891011033105, "phrase": "enhanced_execution_algorithm"}, {"score": 0.0021497514826678433, "phrase": "distributed_execution"}, {"score": 0.0021384748235753425, "phrase": "behavioral_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Behavioral programming", " Live sequence charts", " Logical execution time", " Time scales", " Synchronization"], "paper_abstract": "As part of expanding the implementation and use of the behavioral programming (BP) approach in a variety of languages and configurations, we tackle some of the challenges associated with applying the approach in a truly distributed, decentralized manner, where different modules run on separate machines. BP supports the development of reactive applications from modules that are aligned with the desired and undesired scenarios of system behaviors as described, say, in a requirements document, in an enhancement request, or a field problem report. A key advantage of this approach is that it facilitates incremental development where loosely coupled modules are added as requirements are introduced, and meaningful prototype execution can be carried out from early stages of development. In BP, each behavioral module (called a behavior thread) takes care of a separate facet of the requirements, thus control is conceptually decentralized. However, as the underlying principles of BP call for constant synchronization of, and \"consultation\" with, all behavior threads, efficient implementation in a physically distributed environment is a significant challenge on the road to broader acceptance of BP as a viable new way to develop systems. We begin by describing an implementation of BP in Erlang, where the coordination protocol is implemented via message passing. We demonstrate through examples how developing distributed systems in Erlang can benefit from BP advantages of incremental development and alignment of the code modules with the requirements. Next, we propose general BP design patterns (not limited to Erlang) for using BP in distributed applications, showing how to design applications using BP without forcing full synchronization among all threads at each step of the execution. This allows modules to run at different time scales and to wait for external input without stalling the entire system. Finally, we propose ways to alter the execution mechanism of BP so that execution can progress without necessarily waiting for the synchronization of all the threads. The enhanced execution algorithm has the potential of accelerating the distributed execution of behavioral programs. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Towards behavioral programming in distributed architectures", "paper_id": "WOS:000347741000007"}