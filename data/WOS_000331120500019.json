{"auto_keywords": [{"score": 0.0453665111651286, "phrase": "infinite-state_programs"}, {"score": 0.00481495049065317, "phrase": "solving_games"}, {"score": 0.004756805752518494, "phrase": "infinite_graphs"}, {"score": 0.004614483128885678, "phrase": "constraint-based_approach"}, {"score": 0.004558748120167778, "phrase": "computing_winning_strategies"}, {"score": 0.00450368324850566, "phrase": "two-player_graph_games"}, {"score": 0.004212453011596424, "phrase": "numerous_applications"}, {"score": 0.004161553532799662, "phrase": "program_verification"}, {"score": 0.003964007795174772, "phrase": "infinite-state_reactive_programs"}, {"score": 0.003916098498242888, "phrase": "branching-time_verification"}, {"score": 0.0037075456471849892, "phrase": "winning_conditions"}, {"score": 0.0033230588808076267, "phrase": "deductive_proof_rule"}, {"score": 0.003223494720348768, "phrase": "symbolic_representation"}, {"score": 0.00316518932828897, "phrase": "game_players"}, {"score": 0.003089080923888397, "phrase": "winning_strategy"}, {"score": 0.00303319936111073, "phrase": "particular_player"}, {"score": 0.002685558057339722, "phrase": "off-the-shelf_horn_constraint_solver"}, {"score": 0.002526938673434697, "phrase": "practical_promise"}, {"score": 0.0023632309822037637, "phrase": "challenging_\"cinderella-stepmother_game"}, {"score": 0.0023063614119692476, "phrase": "infinite_alternation"}, {"score": 0.002278440725193305, "phrase": "discrete_and_continuous_choices"}, {"score": 0.0021307975800397816, "phrase": "prior_work"}, {"score": 0.0021049977753042253, "phrase": "program_repair"}], "paper_keywords": ["program synthesis", " games", " reactive synthesis", " proof rules", " static analysis", " Horn clauses"], "paper_abstract": "We present a constraint-based approach to computing winning strategies in two-player graph games over the state space of infinite-state programs. Such games have numerous applications in program verification and synthesis, including the synthesis of infinite-state reactive programs and branching-time verification of infinite-state programs. Our method handles games with winning conditions given by safety, reachability, and general Linear Temporal Logic (LTL) properties. For each property class, we give a deductive proof rule that - provided a symbolic representation of the game players - describes a winning strategy for a particular player. Our rules are sound and relatively complete. We show that these rules can be automated by using an off-the-shelf Horn constraint solver that supports existential quantification in clause heads. The practical promise of the rules is demonstrated through several case studies, including a challenging \"Cinderella-Stepmother game\" that allows infinite alternation of discrete and continuous choices by two players, as well as examples derived from prior work on program repair and synthesis.", "paper_title": "A Constraint-Based Approach to Solving Games on Infinite Graphs", "paper_id": "WOS:000331120500019"}