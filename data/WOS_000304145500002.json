{"auto_keywords": [{"score": 0.04458003012492911, "phrase": "pta"}, {"score": 0.00481495049065317, "phrase": "temporal_aggregation"}, {"score": 0.0047650691627251825, "phrase": "important_operation"}, {"score": 0.004732100994830163, "phrase": "temporal_databases"}, {"score": 0.004683073921949839, "phrase": "different_variants"}, {"score": 0.004476399615305783, "phrase": "novel_temporal_aggregation_operator"}, {"score": 0.00443000995237127, "phrase": "parsimonious_temporal_aggregation"}, {"score": 0.004323620278409076, "phrase": "major_limitations"}, {"score": 0.004293693193836074, "phrase": "existing_approaches"}, {"score": 0.004190563478825626, "phrase": "instant_temporal_aggregation"}, {"score": 0.00395026016389782, "phrase": "argument_relation"}, {"score": 0.0038957429132649175, "phrase": "similar_tuples"}, {"score": 0.003697895355947004, "phrase": "new_operator"}, {"score": 0.0035100601949451028, "phrase": "result_size"}, {"score": 0.003390149669470349, "phrase": "precise_evaluation"}, {"score": 0.003366662001961897, "phrase": "pta_queries"}, {"score": 0.0032743220621043023, "phrase": "error-bounded_queries"}, {"score": 0.0032067276476968032, "phrase": "worst-case_complexity"}, {"score": 0.0030650070965891653, "phrase": "temporal_gaps"}, {"score": 0.002980916123365584, "phrase": "linear_runtime"}, {"score": 0.002939737235379635, "phrase": "real-world_data"}, {"score": 0.002899125545529459, "phrase": "quick_computation"}, {"score": 0.002869034325496957, "phrase": "approximate_pta_answer"}, {"score": 0.0028195727965553367, "phrase": "efficient_greedy_merging_strategy"}, {"score": 0.0025937408242280757, "phrase": "ita_tuples"}, {"score": 0.0023859534478427313, "phrase": "read-ahead_buffer"}, {"score": 0.002320449502337321, "phrase": "empirical_evaluation"}, {"score": 0.0023043558058824572, "phrase": "real-world_and_synthetic_data"}, {"score": 0.002225542510652775, "phrase": "aggregation_result"}, {"score": 0.002171979107594173, "phrase": "greedy_algorithms"}, {"score": 0.0021419510072373756, "phrase": "large_data_sets"}], "paper_keywords": ["Temporal aggregation", " Data approximation", " Algorithms", " Data mining"], "paper_abstract": "Temporal aggregation is an important operation in temporal databases, and different variants thereof have been proposed. In this paper, we introduce a novel temporal aggregation operator, termed parsimonious temporal aggregation (PTA), that overcomes major limitations of existing approaches. PTA takes the result of instant temporal aggregation (ITA) of size , which might be up to twice as large as the argument relation, and merges similar tuples until a given error () or size () bound is reached. The new operator is data-adaptive and allows the user to control the trade-off between the result size and the error introduced by merging. For the precise evaluation of PTA queries, we propose two dynamic programming-based algorithms for size- and error-bounded queries, respectively, with a worst-case complexity that is quadratic in . We present two optimizations that take advantage of temporal gaps and different aggregation groups and achieve a linear runtime in experiments with real-world data. For the quick computation of an approximate PTA answer, we propose an efficient greedy merging strategy with a precision that is upper bounded by (log ). We present two algorithms that implement this strategy and begin to merge as ITA tuples are produced. They require ( log ( + )) time and ( + ) space, where is the size of a read-ahead buffer and is typically very small. An empirical evaluation on real-world and synthetic data shows that PTA considerably reduces the size of the aggregation result, yet introducing only small errors. The greedy algorithms are scalable for large data sets and introduce less error than other approximation techniques.", "paper_title": "Parsimonious temporal aggregation", "paper_id": "WOS:000304145500002"}