{"auto_keywords": [{"score": 0.04738802715775448, "phrase": "syb"}, {"score": 0.014345399331013186, "phrase": "generic_programming"}, {"score": 0.011671551911215378, "phrase": "data_types"}, {"score": 0.004440780432053927, "phrase": "combinator_library"}, {"score": 0.004314285113050873, "phrase": "generic_traversals"}, {"score": 0.004215720671895337, "phrase": "classically"}, {"score": 0.003138768903050871, "phrase": "polyp"}, {"score": 0.00308476450051406, "phrase": "haskell"}, {"score": 0.002945175711537758, "phrase": "structural_view"}, {"score": 0.0027159094186967247, "phrase": "generic_functions"}, {"score": 0.0026691455928407022, "phrase": "classical_sense"}, {"score": 0.0025929837295811673, "phrase": "syb_approach"}, {"score": 0.0022305310659333864, "phrase": "syb_view"}, {"score": 0.0021049977753042253, "phrase": "generalized_algebraic_data_types"}], "paper_keywords": [""], "paper_abstract": "The paper \"Scrap your boilerplate\" (SYB) introduces a combinator library for generic programming that offers generic traversals and queries. Classically, support for generic programming consists of two essential ingredients: a way to write (type-) overloaded functions, and independently, a way to access the structure of data types. SYB seems to lack the second. As a consequence, it is difficult to compare with other approaches such as PolyP or Generic Haskell. In this paper we reveal the structural view that SYB builds upon. This allows us to define the combinators as generic functions in the classical sense. We explain the SYB approach in this changed setting from ground up, and use the understanding gained to relate it to other generic programming approaches. Furthermore, we show that the SYB view is applicable to a very large class of data types, including generalized algebraic data types.", "paper_title": "Scrap your boilerplate reloaded", "paper_id": "WOS:000238090800002"}