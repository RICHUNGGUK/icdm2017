{"auto_keywords": [{"score": 0.04881990207677595, "phrase": "transactional_data_sets"}, {"score": 0.041520457527160375, "phrase": "false_positives"}, {"score": 0.00481495049065317, "phrase": "hardware_signature_designs"}, {"score": 0.004484596684703308, "phrase": "memory_accesses"}, {"score": 0.004425215632459868, "phrase": "concurrent_transactions"}, {"score": 0.004048860957751714, "phrase": "fixed-size_bit_registers"}, {"score": 0.0038900709793274484, "phrase": "nonexisting_conflicts"}, {"score": 0.0034194194985380268, "phrase": "uneven_cardinality"}, {"score": 0.0033442114331500407, "phrase": "data_sets"}, {"score": 0.003314591878914152, "phrase": "filter_storage"}, {"score": 0.0030595112110658675, "phrase": "different_signature_designs"}, {"score": 0.002992195343569767, "phrase": "common_scheme"}, {"score": 0.002861961643289598, "phrase": "effective_way"}, {"score": 0.002761856557698856, "phrase": "new_signatures"}, {"score": 0.002641621667026613, "phrase": "first_class"}, {"score": 0.0024930878032164757, "phrase": "second_class"}, {"score": 0.002470987929071079, "phrase": "bloom_filters"}, {"score": 0.0024490834773668153, "phrase": "configurable_size"}, {"score": 0.0023739321566540682, "phrase": "main_focus"}, {"score": 0.0023113506171584157, "phrase": "thorough_study"}, {"score": 0.0022806798371116698, "phrase": "alternative_signature_designs"}, {"score": 0.0022404162042797262, "phrase": "statistical_analysis"}, {"score": 0.0021910825909008946, "phrase": "experimental_evaluation"}, {"score": 0.0021620042653528846, "phrase": "performance_results"}, {"score": 0.002142832962924139, "phrase": "hardware_area"}, {"score": 0.0021049977753042253, "phrase": "energy_requirements"}], "paper_keywords": ["Hardware transactional memory", " Bloom filter", " signatures", " conflict detection", " locality", " multiset", " asymmetric"], "paper_abstract": "Transactional Memory (TM) systems must track memory accesses made by concurrent transactions in order to detect conflicts. Many TM implementations use signatures for this purpose, which summarize reads and writes in fixed-size bit registers at the cost of false positives (detection of nonexisting conflicts). Signatures are commonly implemented as two separate same-sized Bloom filters, one for reads and other for writes. In contrast, transactions frequently exhibit read and write sets of uneven cardinality. This mismatch between data sets and filter storage introduces inefficiencies in the use of signatures that have some impact on performance. This paper presents different signature designs as alternatives to the common scheme to deal with the asymmetry in transactional data sets in an effective way. Basically, we analyze two classes of new signatures, called multiset and reconfigurable asymmetric signatures. The first class uses only one Bloom filter to track both read and write sets, while the second class uses Bloom filters of configurable size for reads and writes. The main focus of this paper is a thorough study of these alternative signature designs, including a statistical analysis of false positives and an experimental evaluation, providing performance results and hardware area, time and energy requirements.", "paper_title": "Hardware Signature Designs to Deal with Asymmetry in Transactional Data Sets", "paper_id": "WOS:000313816300008"}