{"auto_keywords": [{"score": 0.037703509080803325, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "monadic_abstract_interpreters"}, {"score": 0.004773904938276846, "phrase": "recent_developments"}, {"score": 0.004712988631183401, "phrase": "systematic_construction"}, {"score": 0.004672808182229058, "phrase": "abstract_interpreters"}, {"score": 0.0045348429403481464, "phrase": "broad_unification"}, {"score": 0.00445783412174435, "phrase": "static_analysis"}, {"score": 0.003988055287053139, "phrase": "particular_semantics"}, {"score": 0.0039035351575463103, "phrase": "unifying_agent"}, {"score": 0.0036137713873827374, "phrase": "monadically-parameterized_semantics"}, {"score": 0.003522027550662857, "phrase": "lambda_calculus"}, {"score": 0.003447349911141396, "phrase": "expected_context-insensitive_analysis"}, {"score": 0.0033026956021014204, "phrase": "systematic_method"}, {"score": 0.0032465423581390625, "phrase": "concrete_semantics"}, {"score": 0.0032050528424273994, "phrase": "monadically-parameterized_abstract_machine"}, {"score": 0.0028669153591624696, "phrase": "original_concrete_semantics"}, {"score": 0.0026998264237910884, "phrase": "singly-threaded_heap"}, {"score": 0.0026312238938540787, "phrase": "monadic_parameterization"}, {"score": 0.002553382046204689, "phrase": "ubiquitous_monotone_fixed-point_computation"}, {"score": 0.0023839754995935184, "phrase": "high-level_strategies"}, {"score": 0.0022936610196951962, "phrase": "abstract_garbage_collection"}, {"score": 0.002178529882942255, "phrase": "continuation-passing_style"}, {"score": 0.0021231452870210965, "phrase": "direct-style_lambda-calculus"}, {"score": 0.0021049977753042253, "phrase": "featherweight_java"}], "paper_keywords": ["Languages", " Theory", " abstract machines", " abstract interpretation", " monads", " operational semantics", " collecting semantics", " abstract garbage collection", " interpreters"], "paper_abstract": "Recent developments in the systematic construction of abstract interpreters hinted at the possibility of a broad unification of concepts in static analysis. We deliver that unification by showing context-sensitivity, polyvariance, flow-sensitivity, reachability-pruning, heap-cloning and cardinality-bounding to be independent of any particular semantics. Monads become the unifying agent between these concepts and between semantics. For instance, by plugging the same \"context-insensitivity monad\" into a monadically-parameterized semantics for Java or for the lambda calculus, it yields the expected context-insensitive analysis. To achieve this unification, we develop a systematic method for transforming a concrete semantics into a monadically-parameterized abstract machine. Changing the monad changes the behavior of the machine. By changing the monad, we recover a spectrum of machines-from the original concrete semantics to a monovariant, flow- and context-insensitive static analysis with a singly-threaded heap and weak updates. The monadic parameterization also suggests an abstraction over the ubiquitous monotone fixed-point computation found in static analysis. This abstraction makes it straightforward to instrument an analysis with high-level strategies for improving precision and performance, such as abstract garbage collection and widening. While the paper itself runs the development for continuation-passing style, our generic implementation replays it for direct-style lambda-calculus and Featherweight Java to support generality.", "paper_title": "Monadic Abstract Interpreters", "paper_id": "WOS:000321865400038"}