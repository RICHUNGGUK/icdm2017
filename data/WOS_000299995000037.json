{"auto_keywords": [{"score": 0.04763743657605743, "phrase": "tm"}, {"score": 0.00481495049065317, "phrase": "automatic_performance_tuning"}, {"score": 0.004740009255053372, "phrase": "significant_obstacle"}, {"score": 0.0046176782475198085, "phrase": "transactional_memory"}, {"score": 0.004498490110526062, "phrase": "real-world_parallel_programs"}, {"score": 0.004382364826200616, "phrase": "substantially_different_tm_algorithms"}, {"score": 0.004314127287770832, "phrase": "tm_algorithm"}, {"score": 0.0040942189695983185, "phrase": "best_choice"}, {"score": 0.00396767023935381, "phrase": "program_inputs"}, {"score": 0.0037261429556468217, "phrase": "hardware_characteristics"}, {"score": 0.0034628156490003775, "phrase": "single_isa."}, {"score": 0.0032012284065895537, "phrase": "static_and_dynamic_information"}, {"score": 0.0031348622158167195, "phrase": "intraprocedural_static_analysis"}, {"score": 0.003069867656852932, "phrase": "static_profile"}, {"score": 0.0029284999172756103, "phrase": "low-overhead_framework"}, {"score": 0.0028378798711397235, "phrase": "running_transactional_application"}, {"score": 0.0027645030021576926, "phrase": "complementary_descriptions"}, {"score": 0.002721388234661538, "phrase": "program's_behavior"}, {"score": 0.0026649432435828842, "phrase": "novel_expert_adaptivity_policies"}, {"score": 0.0026096659285441384, "phrase": "machine_learning_policies"}, {"score": 0.0025025186963415, "phrase": "simple_microbenchmarks"}, {"score": 0.002337684811187166, "phrase": "better_performance"}, {"score": 0.002301211274459965, "phrase": "single_tm_algorithm"}, {"score": 0.0022653055209664284, "phrase": "entire_stamp_benchmark_suite"}, {"score": 0.0021049977753042253, "phrase": "best_combination"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Atomicity", " serializability", " synchronization", " dynamic adaptivity", " machine", " learning"], "paper_abstract": "A significant obstacle to the acceptance of transactional memory (TM) in real-world parallel programs is the abundance of substantially different TM algorithms. Each TM algorithm appears well-suited to certain workload characteristics, but the best choice of algorithm is sensitive to program inputs, available cores, and program phases. Furthermore, operating system and hardware characteristics can affect which algorithm is best, with tradeoffs changing across iterations of a single ISA. This paper introduces methods for constructing policies to dynamically select the most appropriate TM algorithm based on static and dynamic information. We leverage intraprocedural static analysis to create a static profile of the application. We also introduce a low-overhead framework for dynamic profiling of a running transactional application. Armed with these complementary descriptions of a program's behavior, we present novel expert adaptivity policies as well as machine learning policies that are trained off-line using simple microbenchmarks. In our evaluation, we find that both the expert and learned policies provide better performance than any single TM algorithm across the entire STAMP benchmark suite. In addition, policies that combine expert and learned policies offer the best combination of performance, maintainability, and flexibility.", "paper_title": "A Transactional Memory with Automatic Performance Tuning", "paper_id": "WOS:000299995000037"}