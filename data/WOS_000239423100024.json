{"auto_keywords": [{"score": 0.026700629644145, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "access_control_policies"}, {"score": 0.004561019117546361, "phrase": "access_analysis"}, {"score": 0.003525493807130663, "phrase": "formal_basis"}, {"score": 0.00338493754743055, "phrase": "code_instrumentation_algorithm"}, {"score": 0.003249966782844541, "phrase": "access_control_checks"}, {"score": 0.002955533639862811, "phrase": "access_control_policy"}, {"score": 0.0028376361457661415, "phrase": "present_work"}, {"score": 0.0027616550517346066, "phrase": "field_access_analysis"}, {"score": 0.0025804616931593897, "phrase": "type-based_program_analysis"}, {"score": 0.0024111277643627154, "phrase": "type_preservation"}, {"score": 0.0023148964315569866, "phrase": "underlying_annotated_type_system"}, {"score": 0.0021049977753042253, "phrase": "example_specification"}], "paper_keywords": [""], "paper_abstract": "A field access analysis computes for each object the set of places where its fields are accessed and modified. Such an analysis is the formal basis for a code instrumentation algorithm that inserts access control checks in a program to enforce an access control policy. The present work formalizes field access analysis in terms of a type-based program analysis for Java, proves type preservation for the underlying annotated type system, and demonstrates its use with an example specification and instrumentation. A variant of the analysis has been implemented.", "paper_title": "Field access analysis for enforcing access control policies", "paper_id": "WOS:000239423100024"}