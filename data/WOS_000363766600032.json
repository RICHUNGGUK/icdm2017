{"auto_keywords": [{"score": 0.04867268826532293, "phrase": "synchronous_invocation"}, {"score": 0.010613647780619757, "phrase": "reply_capability"}, {"score": 0.00975159763606475, "phrase": "prototype_implementation"}, {"score": 0.004459605573798577, "phrase": "invocation's_servicer"}, {"score": 0.0041835168653521, "phrase": "asynchronous_invocations"}, {"score": 0.00402610372759447, "phrase": "parameter_values"}, {"score": 0.0038090874465452214, "phrase": "requested_computation"}, {"score": 0.003468053168607071, "phrase": "latter_invocation"}, {"score": 0.003394891095032025, "phrase": "reply_operation"}, {"score": 0.0030645676308053444, "phrase": "user_code"}, {"score": 0.002936577024096783, "phrase": "new_version"}, {"score": 0.002899229492461335, "phrase": "jr_concurrent_programming_language"}, {"score": 0.0027078974645805736, "phrase": "xjr_examples"}, {"score": 0.0026734504926268442, "phrase": "realistic_ones"}, {"score": 0.002617007341172262, "phrase": "additional_flexibility"}, {"score": 0.0025947642929906407, "phrase": "new_features"}, {"score": 0.0025291601927956765, "phrase": "non-lexical_reply"}, {"score": 0.0024863459251358217, "phrase": "additional_features"}, {"score": 0.002433843373780471, "phrase": "run-time_performance"}, {"score": 0.002413153346716919, "phrase": "existing_jr_features"}, {"score": 0.0023221983158528163, "phrase": "programming_scenarios"}, {"score": 0.0022346638243276717, "phrase": "actual_implementation"}, {"score": 0.002159623311924437, "phrase": "prototype's_performance_advantages"}], "paper_keywords": ["concurrent programming", " message passing", " early reply", " deferred reply", " forward", " reply capabilities", " transformations", " JR programming language"], "paper_abstract": "Many message passing languages and packages include some form of synchronous invocation. In a synchronous invocation, the invoker waits for the invocation's servicer to pass back results. A synchronous invocation can be viewed as a pair of asynchronous invocations: one-initiating the computation-with parameter values from the invoker to the servicer and the other-once the requested computation has completed-with the 'go-ahead' and return value from the servicer to the invoker. The target of the latter invocation is known as the reply operation, and a reference to it is known as a reply capability. This paper addresses the issues of making such reply capabilities directly accessible to user code. It presents the design and prototype implementation of a new version of the JR concurrent programming language, called xJR, in which the reply capability can be explicit. This paper gives xJR examples, including realistic ones, to highlight the additional flexibility the new features offer (such as a non-lexical reply). These additional features do not impact the run-time performance of existing JR features and can even lead to more efficient code in some programming scenarios. Our experience with the prototype implementation indicates that an actual implementation would be fruitful and would preserve the prototype's performance advantages. Copyright (c) 2015John Wiley & Sons, Ltd.", "paper_title": "User accessible reply capabilities in invoking and servicing operations", "paper_id": "WOS:000363766600032"}