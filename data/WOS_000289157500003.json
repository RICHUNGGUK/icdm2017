{"auto_keywords": [{"score": 0.04646138076595222, "phrase": "java_bytecode"}, {"score": 0.02455382238675431, "phrase": "java_programs"}, {"score": 0.004700193486903964, "phrase": "fertile_darwinian_bytecode_harvester"}, {"score": 0.0038516336597530614, "phrase": "compatible_crossover"}, {"score": 0.0037597491055035895, "phrase": "correct_programs"}, {"score": 0.0034342161742428635, "phrase": "flow-based_compatibility_checks"}, {"score": 0.0033929894721242367, "phrase": "source_and_destination_bytecode_sections"}, {"score": 0.003252542052430782, "phrase": "existing_work"}, {"score": 0.0031941384895530426, "phrase": "restricted_subsets"}, {"score": 0.0031367803372203498, "phrase": "java_bytecode_instruction"}, {"score": 0.00306189690236109, "phrase": "representation_language"}, {"score": 0.0029887957779347394, "phrase": "genetic_programming"}, {"score": 0.00291743479583421, "phrase": "finch's_unqualified_success"}, {"score": 0.0027630232270330402, "phrase": "simple_and_complex_regression"}, {"score": 0.002680789041160613, "phrase": "image_classification"}, {"score": 0.0026485829604700833, "phrase": "array_sum"}, {"score": 0.002569749839351952, "phrase": "finch"}, {"score": 0.002478225374613311, "phrase": "java_virtual_machine_architecture"}, {"score": 0.0023755529073496394, "phrase": "human-readable_solutions"}, {"score": 0.002143529653780496, "phrase": "valuable_new_tool"}, {"score": 0.0021049977753042253, "phrase": "software_engineer's_toolkit"}], "paper_keywords": ["Automatic programming", " genetic programming (GP)", " Java bytecode", " software evolution"], "paper_abstract": "We describe Fertile Darwinian Bytecode Harvester (FINCH), a methodology for evolving Java bytecode, enabling the evolution of extant, unrestricted Java programs, or programs in other languages that compile to Java bytecode. Our approach is based upon the notion of compatible crossover, which produces correct programs by performing operand stack-based, local variables-based, and control flow-based compatibility checks on source and destination bytecode sections. This is in contrast to existing work that uses restricted subsets of the Java bytecode instruction set as a representation language for individuals in genetic programming. We demonstrate FINCH's unqualified success at solving a host of problems, including simple and complex regression, trail navigation, image classification, array sum, and tic-tac-toe. FINCH exploits the richness of the Java virtual machine architecture and type system, ultimately evolving human-readable solutions in the form of Java programs. The ability to evolve Java programs will hopefully lead to a valuable new tool in the software engineer's toolkit.", "paper_title": "Flight of the FINCH Through the Java Wilderness", "paper_id": "WOS:000289157500003"}