{"auto_keywords": [{"score": 0.048839643896770986, "phrase": "concurrent_objects"}, {"score": 0.014077555675357597, "phrase": "herlihy"}, {"score": 0.00481495049065317, "phrase": "proof_obligations"}, {"score": 0.004752240896915183, "phrase": "linearizability"}, {"score": 0.00425087885585093, "phrase": "wing"}, {"score": 0.0041136473765874815, "phrase": "correctness_condition"}, {"score": 0.0035605741849764187, "phrase": "concurrent_object"}, {"score": 0.0030414140732789186, "phrase": "simulation-based_proof_conditions"}, {"score": 0.0028480459059007468, "phrase": "lock-free_stack"}, {"score": 0.0025977542995083624, "phrase": "theorem_prover"}, {"score": 0.0021049977753042253, "phrase": "original_ideas"}], "paper_keywords": ["Algorithms", " Verification", " Z", " refinement", " concurrent access", " linearizability", " nonatomic refinement", " theorem proving", " KIV"], "paper_abstract": "Concurrent objects are inherently complex to verify. In the late 80s and early 90s, Herlihy and Wing proposed linearizability as a correctness condition for concurrent objects, which, once proven, allows us to reason about concurrent objects using pre- and postconditions only. A concurrent object is linearizable if all of its operations appear to take effect instantaneously some time between their invocation and return. In this article we define simulation-based proof conditions for linearizability and apply them to two concurrent implementations, a lock-free stack and a set with lock-coupling. Similar to other approaches, we employ a theorem prover (here, KIV) to mechanize our proofs. Contrary to other approaches, we also use the prover to mechanically check that our proof obligations actually guarantee linearizability. This check employs the original ideas of Herlihy and Wing of verifying linearizability via possibilities.", "paper_title": "Mechanically Verified Proof Obligations for Linearizability", "paper_id": "WOS:000286463800003"}