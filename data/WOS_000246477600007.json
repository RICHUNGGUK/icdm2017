{"auto_keywords": [{"score": 0.013555607191602717, "phrase": "evenodd"}, {"score": 0.013239573751168294, "phrase": "rdp"}, {"score": 0.00481495049065317, "phrase": "two-disk_failure-tolerlant_disk_arrays"}, {"score": 0.004701710196317656, "phrase": "rebuild_process"}, {"score": 0.004591120854640081, "phrase": "failed_disk"}, {"score": 0.004544521651302002, "phrase": "spare_disk"}, {"score": 0.0044225461990535855, "phrase": "latent_sector_failures"}, {"score": 0.004347972379250724, "phrase": "second_disk_failure"}, {"score": 0.004289215825521407, "phrase": "high_cost"}, {"score": 0.004260134699483774, "phrase": "data_loss"}, {"score": 0.0038862297330905836, "phrase": "latter_three_use_parity_encoding"}, {"score": 0.003718045060236861, "phrase": "disk_accesses"}, {"score": 0.0036428866026996707, "phrase": "appropriate_choice"}, {"score": 0.0036181717017041387, "phrase": "symbol_sizes"}, {"score": 0.003426373820419672, "phrase": "computational_cost"}, {"score": 0.003380029058401904, "phrase": "xor_operations"}, {"score": 0.0031254169757175257, "phrase": "operating_modes"}, {"score": 0.0030831303297783877, "phrase": "cost_functions"}, {"score": 0.003051790083321992, "phrase": "discrete_disk_accesses"}, {"score": 0.0030207674474548403, "phrase": "mean_response_time"}, {"score": 0.0029596622424171264, "phrase": "poisson_arrivals"}, {"score": 0.0027366287564324966, "phrase": "approximate_fork-join_response_analysis"}, {"score": 0.002618064695883912, "phrase": "response_time"}, {"score": 0.0026002844796442818, "phrase": "read_requests"}, {"score": 0.0025131738347596586, "phrase": "raido"}, {"score": 0.002453934333239467, "phrase": "write_requests"}, {"score": 0.00240426758768164, "phrase": "single_disk_failure"}, {"score": 0.002331641523873951, "phrase": "smaller_parity_group_size"}, {"score": 0.0021705796895687864, "phrase": "degraded_mode"}, {"score": 0.0021049977753042253, "phrase": "pseudorandorn_permutations"}], "paper_keywords": [""], "paper_abstract": "RAID5 disk arrays use the rebuild process to reconstruct the contents of a failed disk on a spare disk, but this process is unsuccessful if latent sector failures are encountered or a second disk failure occurs. The high cost of data loss has led to two-disk failure-tolerant (2DFT) arrays: RAID6, EVENODD, row-diagonal parity (RDP), and RM2. RAID6 uses Reed-Solomon (RS) codes, whereas the latter three use parity encoding. This paper is concerned with the performance from the viewpoint of disk accesses, which, with an appropriate choice of symbol sizes, is the same for RAID6, EVENODD, and RDP, rather than the computational cost (number of XOR operations). We compare the performance of 2DFTs with each other, as well as RAID0 and RAID5 in normal and degraded operating modes. We derive cost functions for processing discrete disk accesses. The mean response time can be obtained analytically with Poisson arrivals and first-come, first-served (FCFS) scheduling. A simulation is used for validation, calibrating the approximate fork-join response analysis, and shortest-access-time-first (SATF) scheduling. The response time for read requests in RAID6 and RM2 is higher than RAID5 and RAIDO and increases with the fraction of write requests. When there is a single disk failure, RM2 outperforms RAID6 since it has a smaller parity group size than RAID6, but RAID6 outperforms RM2 with two disk failures because of its costlier recovery process. Disk loads in RM2 and RAID6 in degraded mode are unbalanced, and a solution based on pseudorandorn permutations is proposed for this purpose.", "paper_title": "Performance of two-disk failure-tolerlant disk arrays", "paper_id": "WOS:000246477600007"}