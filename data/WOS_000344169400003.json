{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "deterministic_execution"}, {"score": 0.04685104062438761, "phrase": "detlock"}, {"score": 0.038315532080181534, "phrase": "logical_clocks"}, {"score": 0.004720043307726269, "phrase": "multithreaded_programs"}, {"score": 0.004581162468419365, "phrase": "multicore_systems"}, {"score": 0.004230382915464492, "phrase": "hardware_support"}, {"score": 0.0041469500929423595, "phrase": "kernel_modification"}, {"score": 0.0034660938095219846, "phrase": "previous_approaches"}, {"score": 0.0032975819773787985, "phrase": "non-portable_hardware"}, {"score": 0.0025191653363555193, "phrase": "average_overhead"}, {"score": 0.0023965798153709377, "phrase": "tested_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "average_overall_overhead"}], "paper_keywords": ["Multicore", " Multithreading", " Determinism"], "paper_abstract": "In this paper, we present DetLock, a runtime system to ensure deterministic execution of multithreaded programs running on multicore systems. DetLock does not rely on any hardware support or kernel modification to ensure determinism. For tracking the progress of the threads, logical clocks are used. Unlike previous approaches, which rely on non-portable hardware to update the logical clocks, DetLock employs a compiler pass to insert code for updating these clocks, thus increasing portability. For 4 cores, the average overhead of these clocks on tested benchmarks is brought down from 16 to 2% by applying several optimizations. Moreover, the average overall overhead, including deterministic execution, is 14%.", "paper_title": "Efficent and highly portable deterministic multithreading (DetLock)", "paper_id": "WOS:000344169400003"}