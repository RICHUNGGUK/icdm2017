{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "kremlin"}, {"score": 0.004667833113864304, "phrase": "multicore_age"}, {"score": 0.004386887374401584, "phrase": "first_questions"}, {"score": 0.003889583851551197, "phrase": "serial_version"}, {"score": 0.0034484600692786097, "phrase": "novel_hierarchical_critical_path_analysis"}, {"score": 0.0033952989364738353, "phrase": "new_metric"}, {"score": 0.003129317057177867, "phrase": "parallelism_planner"}, {"score": 0.003069112841132911, "phrase": "ranked_order"}, {"score": 0.003045355729156972, "phrase": "specific_regions"}, {"score": 0.0029292922955739963, "phrase": "largest_performance_impact"}, {"score": 0.002861782260525497, "phrase": "multiple_planner_personalities"}, {"score": 0.002742017872865778, "phrase": "particular_programming_environment"}, {"score": 0.0024688196796198766, "phrase": "kremlin's_plan"}, {"score": 0.0024496978447849835, "phrase": "third-party_manually_parallelized_versions"}, {"score": 0.0023932142697579506, "phrase": "kremlin's_openmp_planner"}, {"score": 0.0022227806435520764, "phrase": "manual_parallelization"}, {"score": 0.0021049977753042253, "phrase": "significantly_fewer_regions"}], "paper_keywords": ["Measurement", " Performance", " Hierarchical Critical Path Analysis", " Self-Parallelism", " Parallelism Planner", " Parallel Software Engineering"], "paper_abstract": "Many recent parallelization tools lower the barrier for parallelizing a program, but overlook one of the first questions that a programmer needs to answer: which parts of the program should I spend time parallelizing ? This paper examines Kremlin, an automatic tool that, given a serial version of a program, will make recommendations to the user as to what regions (e. g. loops or functions) of the program to attack first. Kremlin introduces a novel hierarchical critical path analysis and develops a new metric for estimating the potential of parallelizing a region: self-parallelism. We further introduce the concept of a parallelism planner, which provides a ranked order of specific regions to the programmer that are likely to have the largest performance impact when parallelized. Kremlin supports multiple planner personalities, which allow the planner to more effectively target a particular programming environment or class of machine. We demonstrate the effectiveness of one such personality, an OpenMP planner, by comparing versions of programs that are parallelized according to Kremlin's plan against third-party manually parallelized versions. The results show that Kremlin's OpenMP planner is highly effective, producing plans whose performance is typically comparable to, and sometimes much better than, manual parallelization. At the same time, these plans would require that the user parallelize significantly fewer regions of the program.", "paper_title": "Kremlin: Rethinking and Rebooting gprof for the Multicore Age", "paper_id": "WOS:000294609500040"}