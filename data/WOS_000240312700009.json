{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "factor_oracle"}, {"score": 0.004713162564945179, "phrase": "relatively_new_data_structure"}, {"score": 0.004265760046406154, "phrase": "allauzen"}, {"score": 0.004205397270251907, "phrase": "crochemore"}, {"score": 0.004116440453049531, "phrase": "raffinot"}, {"score": 0.0035949949979695063, "phrase": "experimental_behaviour"}, {"score": 0.003493900927782043, "phrase": "factor_oracle_based_string_matching"}, {"score": 0.003072918736387408, "phrase": "important_steps"}, {"score": 0.0024984517279573906, "phrase": "known_properties"}, {"score": 0.0024108455980729284, "phrase": "simple_observations"}], "paper_keywords": [""], "paper_abstract": "The factor oracle is a relatively new data structure for the set of factors of a string which has been introduced by Allauzen, Crochemore, and Raffinot in 1999. It may recognize non-factors (hence the name \"oracle\") but its implementational simplicity and experimental behaviour are stunning; factor oracle based string matching has been conjectured optimal on average. However, its structure is not well understood. We take important steps in clarifying its structure by explaining how it can be obtained as a quotient of the trie for the set of factors. When seen this way, all known properties of the factor oracle become simple observations. Also, we introduce a framework where various oracles can be compared. The factor oracle is better than several natural ones.", "paper_title": "Factor oracles", "paper_id": "WOS:000240312700009"}