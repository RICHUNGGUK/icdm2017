{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "software_artifact_provenance"}, {"score": 0.004739056045644449, "phrase": "well_designed_software_system"}, {"score": 0.004664352260912174, "phrase": "related_functionality"}, {"score": 0.004412000844879264, "phrase": "inheritance_trees"}, {"score": 0.004377077848734575, "phrase": "package_hierarchies"}, {"score": 0.003885085477351673, "phrase": "key_functional_properties"}, {"score": 0.0037040785566765954, "phrase": "implementation_details"}, {"score": 0.0036023971109946946, "phrase": "design_integrity"}, {"score": 0.003559675269411366, "phrase": "well-engineered_system"}, {"score": 0.0034895911869254146, "phrase": "new_features"}, {"score": 0.0034208822062692127, "phrase": "new_quality_attributes"}, {"score": 0.0033402088717816416, "phrase": "old_architectural_knowledge"}, {"score": 0.0032744315183287024, "phrase": "development_personnel_shift"}, {"score": 0.003248483521309273, "phrase": "new_jobs"}, {"score": 0.002599560451267203, "phrase": "current_design"}, {"score": 0.00252812242767189, "phrase": "brief_paper"}, {"score": 0.002429451930463481, "phrase": "broad_problem"}, {"score": 0.0023439376937579204, "phrase": "software_development_artifacts"}, {"score": 0.0023069016803337365, "phrase": "motivating_example"}, {"score": 0.0022524395393089544, "phrase": "recent_related_work"}, {"score": 0.0021731423856364003, "phrase": "version_information"}, {"score": 0.0021559025985688255, "phrase": "embedded_java_libraries"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software artifact provenance", " Software analytics", " Code cloning"], "paper_abstract": "In a well designed software system, units of related functionality are organized into modules and classes, which are in turn arranged into inheritance trees, package hierarchies, components, libraries, frameworks, and services. The trade-offs between simplicity versus flexibility and power are carefully considered, and interfaces are designed that expose the key functional properties of a component while hiding much of the complexity of the implementation details. However, over time the design integrity of a well-engineered system tends to decay as new features are added, as new quality attributes are emphasized, and as old architectural knowledge is lost when experienced development personnel shift to new jobs. Consequently, as developers and as users we often find ourselves looking at a piece of functionality or other design artifact and wondering, \"Why is this here?\" That is, we would like to examine the provenance of an artifact to understand its history and why it is where it is within the current design of the system. In this brief paper, we sketch some of the dimensions of the broad problem of extracting and reasoning about the provenance of software development artifacts. As a motivating example, we also describe some recent related work that uses hashing to quickly and accurately identify version information of embedded Java libraries. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Understanding software artifact provenance", "paper_id": "WOS:000345725100016"}