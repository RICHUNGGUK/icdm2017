{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "linear_average_time"}, {"score": 0.004477270137801732, "phrase": "efficient_algorithm"}, {"score": 0.004360412703519539, "phrase": "approximate_occurrences"}, {"score": 0.004218602458288531, "phrase": "length_m"}, {"score": 0.0041357305373417455, "phrase": "text_t"}, {"score": 0.003922580121023413, "phrase": "equal_length_adjacent_factors"}, {"score": 0.003623199939953831, "phrase": "efficient_filtering_method"}, {"score": 0.0033911868693238894, "phrase": "worst_case"}, {"score": 0.0030706395717772436, "phrase": "maximum_length"}, {"score": 0.0027803070408286158, "phrase": "alphabet_size"}, {"score": 0.0025849489224175548, "phrase": "average_time_complexity"}, {"score": 0.0022492129111567824, "phrase": "proposed_algorithm"}, {"score": 0.0021903801614787423, "phrase": "practical_cases"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Approximate string matching", " Algorithms", " Bioinformatics"], "paper_abstract": "We present an efficient algorithm for finding all approximate occurrences of a given pattern p of length m in a text t of length n allowing for translocations of equal length adjacent factors and inversions of factors. The algorithm is based on an efficient filtering method and has an O(nm max(alpha, beta))-time complexity in the worst case and O(max(alpha, beta, sigma))-space complexity, where alpha and beta are respectively the maximum length of the factors involved in any translocation and inversion, and a is the alphabet size. Moreover we show that our algorithm has an O(n) average time complexity, whenever sigma = Omega(log m/log log(1-epsilon) m), for epsilon > 0. Experiments show that the proposed algorithm achieves very good results in practical cases. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "String matching with inversions and translocations in linear average time (most of the time)", "paper_id": "WOS:000290743500004"}