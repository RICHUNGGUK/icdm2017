{"auto_keywords": [{"score": 0.049507241979896484, "phrase": "class_hierarchy"}, {"score": 0.00481495049065317, "phrase": "object-oriented_concepts"}, {"score": 0.004686504090684836, "phrase": "object-oriented_languages"}, {"score": 0.004602773636967002, "phrase": "implementation_details"}, {"score": 0.004575195715264118, "phrase": "specific_programming_languages"}, {"score": 0.004520532341696593, "phrase": "program_verification_techniques"}, {"score": 0.004439753960631346, "phrase": "relatively_little_formalisation_work"}, {"score": 0.004360412703519539, "phrase": "fundamental_concepts"}, {"score": 0.004334280585565239, "phrase": "object-oriented_programming"}, {"score": 0.004282483226549419, "phrase": "specific_language_considerations"}, {"score": 0.004218602458288531, "phrase": "particular_verification_style"}, {"score": 0.004020492138367616, "phrase": "core_object-oriented_programming_language_concepts"}, {"score": 0.0037631343866066855, "phrase": "standard_sequential_programming_constructs"}, {"score": 0.003729335910488339, "phrase": "abstract_syntax"}, {"score": 0.0036406779213379154, "phrase": "typical_object-oriented_programming_languages"}, {"score": 0.003608174324275597, "phrase": "java"}, {"score": 0.0035755653799043, "phrase": "novel_aspect"}, {"score": 0.003438441702164516, "phrase": "single_syntactic_term"}, {"score": 0.0033465923623290034, "phrase": "class_terms"}, {"score": 0.0031797191359738356, "phrase": "method_instances"}, {"score": 0.003132236287543072, "phrase": "relevant_object"}, {"score": 0.0029670762930358394, "phrase": "underlying_mathematical_objects"}, {"score": 0.0027519956065269126, "phrase": "local_variables"}, {"score": 0.0025989960809479104, "phrase": "process-algebraic_style"}, {"score": 0.002476755123108715, "phrase": "label-based_approach"}, {"score": 0.0023390219342052623, "phrase": "different_constructs"}, {"score": 0.002255997431382505, "phrase": "basic_rules"}, {"score": 0.0022424487483398876, "phrase": "individual_commands"}, {"score": 0.0021049977753042253, "phrase": "operational_semantics"}], "paper_keywords": ["Operational semantics", " Object-oriented programming", " Process algebra", " Class hierarchy"], "paper_abstract": "The formalisation of object-oriented languages is essential for describing the implementation details of specific programming languages or for developing program verification techniques. However there has been relatively little formalisation work aimed at abstractly describing the fundamental concepts of object-oriented programming, separate from specific language considerations or suitability for a particular verification style. In this paper we address this issue by formalising a language that includes the core object-oriented programming language concepts of field tests and updates, methods, constructors, subclassing, multithreading, and synchronisation, built on top of standard sequential programming constructs. The abstract syntax is relatively close to the core of typical object-oriented programming languages such as Java. A novel aspect of the syntax is that objects and classes are encapsulated within a single syntactic term, including their fields and methods. Furthermore, class terms are structured according to the class hierarchy, and objects appear as subterms of their class (and method instances as subterms of the relevant object). This helps to narrow the gap between how a programmer thinks about their code and the underlying mathematical objects in the semantics. The semantics is defined operationally, so that all actions a program may take, such as testing or setting local variables and fields, or invoking methods on other objects, appear on the labels of the transitions. A process-algebraic style of interprocess communication is used for object and class interactions. A benefit of this label-based approach to the semantics is that a separation of concerns can be made when defining the rules of the different constructs, and the rules tend to be more concise. The basic rules for individual commands may be composed into more powerful rules that operate at the level of classes and objects. The traces generated by the operational semantics are used as the basis for establishing equivalence between classes.", "paper_title": "An operational semantics for object-oriented concepts based on the class hierarchy", "paper_id": "WOS:000335555500004"}