{"auto_keywords": [{"score": 0.0490670488207421, "phrase": "run-time_memory"}, {"score": 0.015719716506582538, "phrase": "brouwerian_model"}, {"score": 0.012631617325730513, "phrase": "closed_cluster"}, {"score": 0.009653067343196885, "phrase": "brouwerian_structure"}, {"score": 0.008258510951187424, "phrase": "two-counter_algorithm"}, {"score": 0.004326987090971404, "phrase": "directed_graph"}, {"score": 0.003493900927782043, "phrase": "largest_set"}, {"score": 0.003051073364818384, "phrase": "closed_clusters"}, {"score": 0.0022933216359142736, "phrase": "traditional_one-counter_algorithm"}, {"score": 0.0021049977753042253, "phrase": "garbage_collection"}], "paper_keywords": ["Brouwerian algebra", " closed cluster", " cyclic structure", " depth-first search", " graph theory", " garbage collection", " reference count", " run-time memory", " strongly connected component"], "paper_abstract": "The run-time memory of a program may be described with a directed graph in which nodes represent chunks of memory and edges represent references. We define a closed cluster induced by a node n, denoted as CC(n), as the largest set of nodes that are reachable from n but are unreachable from nodes outside the closed cluster. Based on closed clusters, there is a Brouwerian structure under the run-time memory. We present the Brouwerian model and discuss its properties, transformations, and applications. We also propose a two-counter algorithm for calculating CC(n). The two-counter algorithm is never slower than a traditional one-counter algorithm. Our study of the Brouwerian structure is motivated by work on garbage collection.", "paper_title": "A Brouwerian Model of the Run-Time Memory", "paper_id": "WOS:000365243700016"}