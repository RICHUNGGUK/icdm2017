{"auto_keywords": [{"score": 0.04253556916257135, "phrase": "suffix_tree"}, {"score": 0.03668569649960335, "phrase": "linear-time_algorithms"}, {"score": 0.03476970978935563, "phrase": "crochemore's_algorithm"}, {"score": 0.00481495049065317, "phrase": "crochemore's_repetitions"}, {"score": 0.004148014765950199, "phrase": "similar_strategy"}, {"score": 0.003841699919521703, "phrase": "lempel-ziv_factorization"}, {"score": 0.003542786326740931, "phrase": "crochemore's_repetitions_algorithm"}, {"score": 0.002924074850256874, "phrase": "original_crochemore's_repetitions_algorithm"}, {"score": 0.002790004829699627, "phrase": "repetitions_algorithm"}, {"score": 0.002696366237523415, "phrase": "worsen_complexity"}, {"score": 0.002539978170928796, "phrase": "original_algorithm"}, {"score": 0.002372298201966367, "phrase": "third_variant"}, {"score": 0.0022062235065459274, "phrase": "best_extension"}, {"score": 0.0021049977753042253, "phrase": "parallel_implementation"}], "paper_keywords": ["Repetition", " run", " string", " periodicity", " suffix tree", " suffix array"], "paper_abstract": "Crochemore's repetitions algorithm introduced in 1981 was the first O(n log n) algorithm for computing repetitions. Since then, several linear-time worst-case algorithms for computing runs have been introduced. They all follow a similar strategy: first compute the suffix tree or array, then use the suffix tree or array to compute the Lempel-Ziv factorization, then using the Lempel-Ziv factorization compute all the runs. It is conceivable that in practice an extension of Crochemore's repetitions algorithm may outperform the linear-time algorithms, or at least for certain classes of strings. The nature of Crochemore's algorithm lends itself naturally to parallelization, while the linear-time algorithms are not easily conducive to parallelization. For all these reasons it is interesting to explore ways to extend the original Crochemore's repetitions algorithm to compute runs. We present three variants of extending the repetitions algorithm to compute runs: two with a worsen complexity of O(n(log n)(2)), and one with the same complexity as the original algorithm. The three variants are tested for speed of performance and their memory requirements are analyzed. The third variant is tested and analyzed for various memory-saving alterations. The purpose of this research is to identify the best extension of Crochemore's algorithm for further study, comparison with other algorithms, and parallel implementation.", "paper_title": "CROCHEMORE'S REPETITIONS ALGORITHM REVISITED: COMPUTING RUNS", "paper_id": "WOS:000302061000011"}