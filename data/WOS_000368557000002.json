{"auto_keywords": [{"score": 0.04416061972771482, "phrase": "smt"}, {"score": 0.029903338459546687, "phrase": "prolog"}, {"score": 0.00481495049065317, "phrase": "sat_modulo_theories"}, {"score": 0.004312622975366676, "phrase": "logical_connectives"}, {"score": 0.0040298010803060495, "phrase": "quantifier-free_problems"}, {"score": 0.003978866233891427, "phrase": "key_idea"}, {"score": 0.0038624981944755813, "phrase": "unit_propagation"}, {"score": 0.003813669883040509, "phrase": "propositional_part"}, {"score": 0.0037336520904376687, "phrase": "theory_propagation"}, {"score": 0.0036864465771943933, "phrase": "constraint_component"}, {"score": 0.003503497128638102, "phrase": "natural_way"}, {"score": 0.0033865859510157238, "phrase": "logic_programming"}, {"score": 0.003315499339103866, "phrase": "elegant_implementation"}, {"score": 0.003097865379563127, "phrase": "reverse_engineering"}, {"score": 0.0030457198309616694, "phrase": "type_recovery"}, {"score": 0.002906788114295269, "phrase": "smt_solver"}, {"score": 0.0028216858159564808, "phrase": "rational-tree_constraints"}, {"score": 0.0027390682208834013, "phrase": "off-the-shelf_smt_solvers"}, {"score": 0.002658863179011018, "phrase": "prolog_systems"}, {"score": 0.002570064617803693, "phrase": "smt_solvers"}, {"score": 0.002548331088496964, "phrase": "linear_constraints"}, {"score": 0.002526780881314497, "phrase": "integer_difference_constraints"}, {"score": 0.0024947959375982614, "phrase": "rational-tree_solver"}, {"score": 0.002421726275597666, "phrase": "type_recovery_problems"}, {"score": 0.0023607968604629393, "phrase": "lazy-basic_smt_solver"}, {"score": 0.00229164285862567, "phrase": "integer_difference_logic_solver"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["SMT", " SAT", " Satisfiability Modulo Theories", " Reification", " DPLL", " Rational tree unification", " Type recovery", " Reverse engineering", " Difference logic"], "paper_abstract": "SAT Modulo Theories (SMT) is the problem of determining the satisfiability of a formula in which constraints, drawn from a given constraint theory T, are composed with logical connectives. The DPLL(T) approach to SMT has risen to prominence as a technique for solving these quantifier-free problems. The key idea in DPLL(T) is to couple unit propagation in the propositional part of the problem with theory propagation in the constraint component. In this paper it is demonstrated how reification provides a natural way for orchestrating this in the setting of logic programming. This allows an elegant implementation of DPLL(T) solvers in Prolog. The work is motivated by a problem in reverse engineering, that of type recovery from binaries. The solution to this problem requires an SMT solver where the theory is that of rational-tree constraints, a theory not supported in off-the-shelf SMT solvers, but realised as unification in Prolog systems. The approach is also illustrated with SMT solvers for linear constraints and integer difference constraints. The rational-tree solver is benchmarked against a number of type recovery problems, and compared against a lazy-basic SMT solver built on PicoSAT, while the integer difference logic solver is benchmarked against CVC3 and CVC4, both of which are implemented in C++. (C) 2014 Published by Elsevier B.V.", "paper_title": "Theory propagation and reification", "paper_id": "WOS:000368557000002"}