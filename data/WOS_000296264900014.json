{"auto_keywords": [{"score": 0.04841059819520941, "phrase": "accord"}, {"score": 0.03559395751354385, "phrase": "co-ordination_strategy"}, {"score": 0.00481495049065317, "phrase": "safe_parallelism"}, {"score": 0.004696909870731282, "phrase": "thread_contracts"}, {"score": 0.004061160863655662, "phrase": "concurrency_co-ordination"}, {"score": 0.003836993936866082, "phrase": "automatic_tools"}, {"score": 0.00376950244909, "phrase": "concurrency_co-ordination_strategy"}, {"score": 0.0035236476185949565, "phrase": "formally_state"}, {"score": 0.003412833120814178, "phrase": "programmer's_implementation"}, {"score": 0.0032358074601765555, "phrase": "formal_accord_contracts"}, {"score": 0.003167587258150065, "phrase": "runtime_assertions"}, {"score": 0.0029608739165086257, "phrase": "large_class"}, {"score": 0.002939912751271152, "phrase": "data-parallel_programs"}, {"score": 0.0028881548838751705, "phrase": "intricate_ways"}, {"score": 0.002837305633114947, "phrase": "natural_and_simple_contracts"}, {"score": 0.0025686131021181134, "phrase": "existing_smt_solver"}, {"score": 0.0025144238077014114, "phrase": "co-ordination_strategies"}, {"score": 0.0021734395455430167, "phrase": "hitherto_undiscovered_data-races"}], "paper_keywords": ["concurrent contracts", " constraint solvers", " data-races", " testing", " Reliability", " Verification"], "paper_abstract": "We build a framework of thread contracts, called ACCORD, that allows programmers to annotate their concurrency co-ordination strategies. ACCORD annotations allow programmers to declaratively specify the parts of memory that a thread may read or write into, and the locks that protect them, reflecting the concurrency co-ordination among threads and the reason why the program is free of data-races. We provide automatic tools to check if the concurrency co-ordination strategy ensures race-freedom, using constraint-solvers (SMT solvers). Hence programmers using ACCORD can both formally state and prove their co-ordination strategies ensure race freedom. The programmer's implementation of the co-ordination strategy may however be correct or incorrect. We show how the formal ACCORD contracts allow us to automatically insert runtime assertions that serve to check, during testing, whether the implementation conforms to the contract. Using a large class of data-parallel programs that share memory in intricate ways, we show that natural and simple contracts suffice to document the co-ordination strategy amongst threads, and that the task of showing that the strategy ensures race-freedom can be handled efficiently and automatically by an existing SMT solver (Z3). While co-ordination strategies can be proved race-free in our framework, failure to prove the co-ordination strategy race-free, accompanied by counter-examples produced by the solver, indicates the presence of races. Using such counterexamples, we report hitherto undiscovered data-races that we found in the long-tested applu_1 benchmark in the Spec OMP2001 suite.", "paper_title": "Thread Contracts for Safe Parallelism", "paper_id": "WOS:000296264900014"}