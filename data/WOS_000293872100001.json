{"auto_keywords": [{"score": 0.04858132305104682, "phrase": "fortran"}, {"score": 0.007992792203058091, "phrase": "right_compiler"}, {"score": 0.00481495049065317, "phrase": "performance_penalty"}, {"score": 0.004497973025639345, "phrase": "\"number_crunching"}, {"score": 0.004201774694043468, "phrase": "large_datasets"}, {"score": 0.004015182362035361, "phrase": "object_oriented_design"}, {"score": 0.003942877273973905, "phrase": "code_expansion"}, {"score": 0.0036497740708342093, "phrase": "different_object_oriented_design_elements"}, {"score": 0.0035677736570659813, "phrase": "overall_performance"}, {"score": 0.0035194572615570977, "phrase": "first_series"}, {"score": 0.0032725712584012953, "phrase": "computation_time"}, {"score": 0.003170060683860338, "phrase": "object_life_cycle"}, {"score": 0.003056819704624705, "phrase": "second_series"}, {"score": 0.002988101395789399, "phrase": "finite_element"}, {"score": 0.002934237411711622, "phrase": "diffusion_term"}, {"score": 0.0028682668647074397, "phrase": "different_classes"}, {"score": 0.0026913130726432645, "phrase": "useful_computations"}, {"score": 0.0026548344763838213, "phrase": "integral_object_life_cycle"}, {"score": 0.0025833500717948343, "phrase": "oriented_design"}, {"score": 0.0023802126605244438, "phrase": "optimization_techniques"}, {"score": 0.002193013499219711, "phrase": "oriented_design_techniques"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Fortran", " Object-oriented", " Performance", " Abstraction", " Software design", " Finite elements"], "paper_abstract": "Fortran 95 is used often for \"number crunching\": scientific and engineering applications where performance is important and which operate with large datasets. The language allows the implementation of certain elements of object oriented design, which facilitate code expansion, reuse and maintenance. In this paper we discuss two series of tests to measure how different object oriented design elements of Fortran 95 affect overall performance. The first series of tests consists of several implementations for multiplying two matrices. These tests are focused exclusively on computation time, not considering other parts of the object life cycle such as construction and destruction. The second series consists of computing a finite element matrix for a diffusion term. A more complex environment with different classes is studied. Here, we consider not only the time spent doing useful computations but the integral object life cycle. Results show that object oriented design comes at a cost in all cases. However, given the right compiler, using the right compiler optimization techniques and keeping the amount of objects and method calls low, Fortran 95 designs can benefit from object oriented design techniques with a less than 10% running time increase. (C) 2011 Elsevier Ltd. All rights reserved.", "paper_title": "An experimental approach to the performance penalty of the use of classes in Fortran 95", "paper_id": "WOS:000293872100001"}