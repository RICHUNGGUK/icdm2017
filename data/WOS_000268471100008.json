{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "call_stack"}, {"score": 0.0046457802872573025, "phrase": "programming_model"}, {"score": 0.004563427013973105, "phrase": "runtime_system"}, {"score": 0.004324985524216987, "phrase": "ram_usage"}, {"score": 0.0041580507929967645, "phrase": "runtime_callstack"}, {"score": 0.003926626018798576, "phrase": "function_invocations"}, {"score": 0.0036684182697540382, "phrase": "multiple_callsites"}, {"score": 0.0035648266669315943, "phrase": "stack_elimination"}, {"score": 0.0034394269654205094, "phrase": "lifting_transformation"}, {"score": 0.0034026714408341868, "phrase": "global_variables"}, {"score": 0.0033663073782936952, "phrase": "local_scope"}, {"score": 0.0032829663495339465, "phrase": "ram."}, {"score": 0.003247868216333148, "phrase": "even_more_benefit"}, {"score": 0.003100085797251317, "phrase": "flattened_code"}, {"score": 0.0030017207229983385, "phrase": "false_paths"}, {"score": 0.0029590077170443666, "phrase": "standard_live_variables_analysis"}, {"score": 0.002927371124061966, "phrase": "resulting_problems"}, {"score": 0.0028651061556017304, "phrase": "spurious_live-range_conflicts"}, {"score": 0.0027941308786390033, "phrase": "unflattened_callgraph"}, {"score": 0.002695768552609587, "phrase": "high_register_pressure"}, {"score": 0.002610198789888055, "phrase": "consequent_spills"}, {"score": 0.0025730425700096365, "phrase": "register_allocator"}, {"score": 0.0025003054002226965, "phrase": "compiler's_stack_layout_optimizations"}, {"score": 0.002412273140088606, "phrase": "gcc"}, {"score": 0.0023356699564158426, "phrase": "source-to-source_transformations"}, {"score": 0.0022615046141708987, "phrase": "avr_family"}, {"score": 0.0022054488653549175, "phrase": "total_ram_usage"}], "paper_keywords": ["Performance", " Languages", " sensor networks", " embedded software", " compiler optimization", " memory optimizations", " memory allocation", " stack liveness analysis"], "paper_abstract": "Most programming languages support a call stack in the programming model and also in the runtime system. We show that for applications targeting low-power embedded microcontrollers (MCUs), RAM usage can be significantly decreased by partially or completely eliminating the runtime callstack. We present flattening, a transformation that absorbs a function into its caller, replacing function invocations and returns with jumps. Unlike inlining, flattening does not duplicate the bodies of functions that have multiple callsites. Applied aggressively, flattening results in stack elimination. Flattening is most useful in conjunction with a lifting transformation that moves global variables into a local scope. Flattening and lifting can save RAM. However, even more benefit can be obtained by adapting the compiler to cope with properties of flattened code. First, we show that flattening adds false paths that confuse a standard live variables analysis. The resulting problems can be mitigated by breaking spurious live-range conflicts between variables using information from the unflattened callgraph. Second, we show that the impact of high register pressure due to flattened and lifted code, and consequent spills out of the register allocator, can be mitigated by improving a compiler's stack layout optimizations. We have implemented both of these improvements in GCC, and have implemented flattening and lifting as source-to-source transformations. On a collection of applications for the AVR family of 8-bit MCUs, we show that total RAM usage can be reduced by 20% by compiling flattened and lifted programs with our improved GCC.", "paper_title": "Eliminating the Call Stack to Save RAM", "paper_id": "WOS:000268471100008"}