{"auto_keywords": [{"score": 0.030570347867177793, "phrase": "vvm_vectors"}, {"score": 0.02635635702473387, "phrase": "vvm"}, {"score": 0.012367620093409972, "phrase": "vpu"}, {"score": 0.008621959744139167, "phrase": "vpu_vector"}, {"score": 0.008059088889941252, "phrase": "function_overloading"}, {"score": 0.007540684228181785, "phrase": "real_vpus"}, {"score": 0.006926008487713986, "phrase": "abstract_vpu"}, {"score": 0.00481495049065317, "phrase": "abstract_vector_processing_unit"}, {"score": 0.004752221133109136, "phrase": "virtual_vpu"}, {"score": 0.004639322321297174, "phrase": "idealised_instruction"}, {"score": 0.0044896599221451216, "phrase": "idealised_instruction_set"}, {"score": 0.004470071518923524, "phrase": "common_constraints"}, {"score": 0.0044458322827705295, "phrase": "hand-coded_programs"}, {"score": 0.004232278141066795, "phrase": "performance_advantages"}, {"score": 0.004122654053110448, "phrase": "particular_vpu."}, {"score": 0.004104660295662782, "phrase": "abstract_vpu_implementation"}, {"score": 0.004086744751579196, "phrase": "vector_virtual_machine"}, {"score": 0.003946195919158241, "phrase": "desktop_vpus"}, {"score": 0.003911817572798092, "phrase": "altivec"}, {"score": 0.003752550907120244, "phrase": "short_vectors"}, {"score": 0.0037361664435836845, "phrase": "fixed_vector_sizes"}, {"score": 0.003687439449869248, "phrase": "aligned_memory"}, {"score": 0.0035761913760242697, "phrase": "machine-vision_library"}, {"score": 0.00356457374661241, "phrase": "char_types"}, {"score": 0.003529543381704363, "phrase": "templated_vectors"}, {"score": 0.0035141291835319682, "phrase": "constant_scalar_count_vectors"}, {"score": 0.0034835017385881385, "phrase": "consistent_functions"}, {"score": 0.003400640983719424, "phrase": "constant_scalar_count"}, {"score": 0.003378385493203297, "phrase": "vvm_vector"}, {"score": 0.0032908057622663732, "phrase": "type_conversions"}, {"score": 0.0032621183241997777, "phrase": "vpu_programs"}, {"score": 0.0032266093099550955, "phrase": "explicit_type_conversions"}, {"score": 0.0030281251520610604, "phrase": "zero-cost_implementation"}, {"score": 0.002860546817196148, "phrase": "single_scalar"}, {"score": 0.0023694065215394593, "phrase": "scalar_mode"}, {"score": 0.0023079225317714815, "phrase": "apple_gcc"}, {"score": 0.0022480304016499605, "phrase": "minimal_overheads"}, {"score": 0.0021993066642488237, "phrase": "implementation's_performance"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "The abstract vector processing unit (VPU) is a virtual VPU that represents a set of real VPUs. It has an idealised instruction set and constraints common to the VPUs that it represents. Together, the idealised instruction set and common constraints allow programs to be portable and to perform efficiently on the real VPUs being represented. The abstract VPU is suitable for programmers who want the performance advantages of using the VPU directly, without being restricted to a particular VPU. An abstract VPU implementation, Vector Virtual Machine (VVM), is presented in this paper. VVM is designed to represent desktop VPUs, such as AltiVec, and to support the creation of a generic, vectorised, machine-vision library. Constraints common to desktop VPUs that VVM are short vectors, fixed vector sizes, and fast access to aligned memory addresses only. To support the creation of a generic, vectorised, machine-vision library, VVM has traits, templated vectors, constant scalar count vectors, and uses consistent functions for scalars and vectors where possible. Because VVM has constant scalar count, each VVM vector can consist of more than one scalar or VPU vector. Since the cost of type conversions is large for VPU programs, VVM only supports explicit type conversions. Ideally, an abstract VPU should have no overheads; that is be zero-cost. Function overloading and expression templates were tested to investigate the possibility of creating a zero-cost implementation of VVM using only Standard C++ and Apple's GCC 3.1 20021003 compiler. Results show that in this environment, zero-cost can be achieved only when processing VVM vectors that contain a single scalar or VPU vector. For expressions involving one to five additions, function overloading was at worst 3.6% slower than hand-coded programs when processing VVM vectors with one scalar or VPU vector. Unfortunately, for VVM vectors with four VPU vectors, function overloading was at worst 23.0% slower. For the same kind of expressions, the expression templates implementation was up to 888.3% slower. It was comparable to hand-coded programs only for expressions involving only one addition between VVM vectors that contain four VPU vectors. When a VPU is available, only char VVM vectors will consist of one VPU vector. In scalar mode, all VVM vectors will consist of one scalar. Thus, with Apple GCC 3.1 20031003, a VVM implementation based on function overloading has minimal overheads only for applications where most operations involve char types. This implementation's performance is adequate for creating a generic, vectorised, machine-vision library because most image processing operations operate on char types. (c) 2005 Elsevier B.V. All rights reserved.", "paper_title": "The abstract vector processor", "paper_id": "WOS:000235602000003"}