{"auto_keywords": [{"score": 0.042121604651343916, "phrase": "supply_area"}, {"score": 0.011613173647364437, "phrase": "garbage_collector"}, {"score": 0.00481495049065317, "phrase": "array_manipulation_habits"}, {"score": 0.0047650691627251825, "phrase": "garbage_collection"}, {"score": 0.004732100994830163, "phrase": "type_flow_analysis"}, {"score": 0.004683073921949839, "phrase": "widespread_practice"}, {"score": 0.0046184900568047565, "phrase": "flexible_array"}, {"score": 0.004539005582217309, "phrase": "storage_area"}, {"score": 0.004061584718427419, "phrase": "main_purpose"}, {"score": 0.003909301559145041, "phrase": "whole_storage_area"}, {"score": 0.003685067218455088, "phrase": "main_idea"}, {"score": 0.0033317342432676385, "phrase": "simple_method"}, {"score": 0.003129623571496151, "phrase": "possible_presence"}, {"score": 0.003107935254560724, "phrase": "null_values"}, {"score": 0.0029092257197427195, "phrase": "used_area"}, {"score": 0.0028097829999199596, "phrase": "overall_results"}, {"score": 0.0027903049766389433, "phrase": "type_analysis"}, {"score": 0.0027326751144684386, "phrase": "source_code"}, {"score": 0.002648448458159033, "phrase": "main_arrays"}, {"score": 0.0023694065215394593, "phrase": "abstract_data_types"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["content of arrays", " dynamic type", " garbage collector", " null pointer detection", " type analysis"], "paper_abstract": "A widespread practice to implement a flexible array is to consider the storage area into two parts: the used area, which is already available for read/write operations, and the supply area, which is used in case of enlargement of the array. The main purpose of the supply area is to avoid as much as possible the reallocation of the whole storage area in case of enlargement. As the supply area is not used by the application, the main idea of the paper is to convey the information to the garbage collector, making it possible to avoid completely the marking of the supply area. We also present a simple method to analyze the types of objects, which are stored in an array as well as the possible presence of NULL values within the array. This allows us to better specialize the work of the garbage collector when marking the used area, and also, by transitivity, to improve overall results for type analysis of all expressions of the source code. After introducing several abstract data types, which represent the main arrays concerned by our technique (i.e., zero or variable indexing, circular arrays and hash maps), we measure its impact during the bootstrap of two compilers whose libraries are equipped with these abstract data types. We then measure, on various software products we have not written, the frequency of certain habits of manipulation of arrays, to assess the validity of our approach. Copyright (c) 2014 John Wiley & Sons, Ltd.", "paper_title": "Exploiting array manipulation habits to optimize garbage collection and type flow analysis", "paper_id": "WOS:000363501100003"}