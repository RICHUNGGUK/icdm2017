{"auto_keywords": [{"score": 0.03966598886647028, "phrase": "rsge"}, {"score": 0.00481495049065317, "phrase": "dynamic_parallelization_of_r"}, {"score": 0.004745555660203672, "phrase": "parallel_computations"}, {"score": 0.004714342482386552, "phrase": "fixed_points"}, {"score": 0.004695712740958672, "phrase": "program_flow"}, {"score": 0.004646390881549501, "phrase": "nested_parallelism"}, {"score": 0.004609738184349981, "phrase": "complex_computations"}, {"score": 0.004454206939203365, "phrase": "user_intervention"}, {"score": 0.004389988342259922, "phrase": "minimal_code_changes"}, {"score": 0.004309587105660596, "phrase": "resulting_computation"}, {"score": 0.0042643035767353, "phrase": "r_package_parallelize"}, {"score": 0.004253056919550972, "phrase": "dynamic_and_practical_issues"}, {"score": 0.0041972651315217765, "phrase": "r_language"}, {"score": 0.004120378951389702, "phrase": "functional_paradigm"}, {"score": 0.004109510313842204, "phrase": "i.e._return_values"}, {"score": 0.004023582827041885, "phrase": "function_definition"}, {"score": 0.004002382035704641, "phrase": "functional_r_program"}, {"score": 0.00390318786261632, "phrase": "return_values"}, {"score": 0.003811474473315608, "phrase": "function_calls"}, {"score": 0.0037913870545392457, "phrase": "e._g._packages"}, {"score": 0.003766434986519423, "phrase": "bode"}, {"score": 0.00369252098625837, "phrase": "revolution_analytics"}, {"score": 0.0036827838875469364, "phrase": "weston"}, {"score": 0.0036536975645015293, "phrase": "natural_point"}, {"score": 0.0035396506895365035, "phrase": "single_function"}, {"score": 0.003366288118649204, "phrase": "calling_mechanism"}, {"score": 0.0031802999916222792, "phrase": "apply_functions"}, {"score": 0.0030566420737720367, "phrase": "similar_function"}, {"score": 0.003016497363395603, "phrase": "parallel_way"}, {"score": 0.002980816767741665, "phrase": "potential_problems"}, {"score": 0.0029572637877332683, "phrase": "bootstrap_package_boot"}, {"score": 0.0029494562956444577, "phrase": "davison"}, {"score": 0.0029416649780403944, "phrase": "hinkley"}, {"score": 0.002926148206600001, "phrase": "canty"}, {"score": 0.002918423491074453, "phrase": "ripley"}, {"score": 0.002899189972263455, "phrase": "implicit_use"}, {"score": 0.0028877123860165136, "phrase": "parallel_package"}, {"score": 0.0028762801072447232, "phrase": "bootstrap_computations"}, {"score": 0.002861107239943045, "phrase": "larger_computations"}, {"score": 0.00285355076155907, "phrase": "parallelization_option"}, {"score": 0.0028422533410830107, "phrase": "boot_function"}, {"score": 0.002801209717483437, "phrase": "higher_level"}, {"score": 0.00279011893927913, "phrase": "computation_scenario"}, {"score": 0.0027425627058001133, "phrase": "parameter_values"}, {"score": 0.0027029547648481983, "phrase": "optimal_code_point"}, {"score": 0.002670972967408955, "phrase": "existing_solutions"}, {"score": 0.002632396192446404, "phrase": "different_apply_calls"}, {"score": 0.00262544217300649, "phrase": "nested_computations"}, {"score": 0.0025569018200150796, "phrase": "parallelization_process"}, {"score": 0.002506670420499921, "phrase": "ideal_solution"}, {"score": 0.002428339701880082, "phrase": "potential_benefits"}, {"score": 0.0023618061198796884, "phrase": "better_control"}, {"score": 0.002318463893671642, "phrase": "different_resources"}, {"score": 0.0023062267960524013, "phrase": "local_machine"}, {"score": 0.0022940541386142345, "phrase": "computer_cluster"}, {"score": 0.0022047794303991165, "phrase": "technical_strategy"}, {"score": 0.002127400176088142, "phrase": "important_practical_issues"}, {"score": 0.00211337095486803, "phrase": "r_programs"}, {"score": 0.0021049977753042253, "phrase": "functional_programming_style"}], "paper_keywords": [""], "paper_abstract": "R offers several extension packages that allow it to perform parallel computations. These operate on fixed points in the program flow and make it difficult to deal with nested parallelism and to organize parallelism in complex computations in general. In this article we discuss, first, of how to detect parallelism in functions, and second, how to minimize user intervention in that process. We present a solution that requires minimal code changes and enables to flexibly and dynamically choose the degree of parallelization in the resulting computation. An implementation is provided by the R package parallelize. dynamic and practical issues are discussed with the help of examples. The R language (Ihaka and Gentleman, 1996) can be used to program in the functional paradigm, i.e. return values of functions only depend on their arguments and values of variables bound at the moment of function definition. Assuming a functional R program, it follows that calls to a given set of functions are independent as long as their arguments do not involve return values of each other. This property of function calls can be exploited and several R packages allow to compute function calls in parallel, e. g. packages parallel, Rsge (Bode, 2012) or for each (Michael et al., 2013; Revolution Analytics and Weston, 2013). A natural point in the program flow where to employ parallelization is where use of the apply-family of functions is made. These functions take a single function (here called the compute-function) as their first argument together with a set of values as their second argument (here called the compute-arguments) each member of which is passed to the compute-function. The calling mechanism guarantees that function calls cannot see each others return values and are thereby independent. This family includes the apply, sapply, lapply, and tapply functions called generically Apply in the following. Examples of packages helping to parallelize Apply functions include parallel and Rsge among others and we will focus on these functions in this article as well. In these packages, a given Apply function is replaced by a similar function from the package that performs the same computation in a parallel way. Fixing a point of parallelism introduces some potential problems. For example, the bootstrap package boot (Davison and Hinkley, 1997; Canty and Ripley, 2013) allows implicit use of the parallel package. If bootstrap computations become nested within larger computations the parallelization option of the boot function potentially has to be changed to allow parallelization at a higher level once the computation scenario changes. In principle, the degree of parallelism could depend on parameter values changing between computations thereby making it difficult to choose an optimal code point at which to parallelize. Another shortcoming of existing solutions is that only a single Apply function gets parallelized thereby ignoring parallelism that spans different Apply calls in nested computations. The aim of this paper is to outline solutions that overcome these limitations. This implies that the parallelization process should be as transparent as possible, i.e. requiring as little user intervention as necessary. An ideal solution would therefore allow the user to ask for parallelization of a certain piece of code and we will try to approximate this situation. Potential benefits for the user are that less technical knowledge is required to make use of parallelization, computations can become more efficient by better control over the scaling of parallelization, and finally programs can better scale to different resources, say the local machine compared to a computer cluster. This article is organized as follows. We first give further motivation by an example that highlights the problems this approach seeks to address. We then outline the technical strategy needed to determine the parallelism in a given function call. After that, trade-offs introduced by such a strategy are discussed. We conclude by benchmarking two examples and discussing important practical issues such as deviations of R programs from the functional programming style.", "paper_title": "Dynamic Parallelization of R Functions", "paper_id": "WOS:000330193300010"}