{"auto_keywords": [{"score": 0.02663449930898407, "phrase": "global_programs"}, {"score": 0.025292733885623763, "phrase": "local_programs"}, {"score": 0.00481495049065317, "phrase": "fast_compiler"}, {"score": 0.0047787596516662, "phrase": "netkat._high-level_programming_languages"}, {"score": 0.004724980378009193, "phrase": "key_role"}, {"score": 0.004671803485255806, "phrase": "growing_number"}, {"score": 0.00463668357590034, "phrase": "networking_platforms"}, {"score": 0.004584495834677719, "phrase": "application_development"}, {"score": 0.004532892812505505, "phrase": "precise_formal_reasoning"}, {"score": 0.004498812433096501, "phrase": "network_behavior"}, {"score": 0.00443141503046841, "phrase": "current_compilers"}, {"score": 0.004381527499253281, "phrase": "\"local\"_programs"}, {"score": 0.004267287100135339, "phrase": "hop-by-hop_forwarding_behavior"}, {"score": 0.004156012879026324, "phrase": "simple_paths"}, {"score": 0.00409372989087314, "phrase": "richer_\"global\"_behaviors"}, {"score": 0.0040171817997972335, "phrase": "extra_state-something"}, {"score": 0.0037249853525936428, "phrase": "existing_compilers"}, {"score": 0.003627800727103479, "phrase": "forwarding_state"}, {"score": 0.0035331426502479687, "phrase": "relatively_small_inputs"}, {"score": 0.00340217066797559, "phrase": "performance_issues"}, {"score": 0.003325921766364862, "phrase": "hardware-level_apis"}, {"score": 0.003251376167695528, "phrase": "new_compiler"}, {"score": 0.003214730261140886, "phrase": "netkat_language"}, {"score": 0.0031784960695034645, "phrase": "rich_features"}, {"score": 0.003154566400499823, "phrase": "regular_paths"}, {"score": 0.0031308163228919773, "phrase": "virtual_networks"}, {"score": 0.0030033417337933625, "phrase": "previous_compilers"}, {"score": 0.0029471223246724204, "phrase": "symbolic_automata"}, {"score": 0.002902903244616154, "phrase": "extra_state"}, {"score": 0.002859345731792013, "phrase": "\"global\"_programs"}, {"score": 0.0027741761880779535, "phrase": "binary_decision_diagrams"}, {"score": 0.0026113524778702602, "phrase": "virtual_programs"}, {"score": 0.0025335509856200433, "phrase": "virtual_topologies"}, {"score": 0.0024673738215365104, "phrase": "network-wide_behavior"}, {"score": 0.00243033541656411, "phrase": "physical_topologies"}, {"score": 0.002305014991156598, "phrase": "single-switch_behavior"}, {"score": 0.0022447938263410005, "phrase": "hardware-level_forwarding_tables"}, {"score": 0.0021778895748464024, "phrase": "real-world_benchmarks"}, {"score": 0.002120982646893519, "phrase": "compilation_time"}, {"score": 0.0021049977753042253, "phrase": "forwarding_table_size"}], "paper_keywords": ["Software-defined networking", " domain-specific languages", " NetKAT", " Frenetic", " Kleene Algebra with tests", " virtualization", " binary decision diagrams"], "paper_abstract": "High-level programming languages play a key role in a growing number of networking platforms, streamlining application development and enabling precise formal reasoning about network behavior. Unfortunately, current compilers only handle \"local\" programs that specify behavior in terms of hop-by-hop forwarding behavior, or modest extensions such as simple paths. To encode richer \"global\" behaviors, programmers must add extra state-something that is tricky to get right and makes programs harder to write and maintain. Making matters worse, existing compilers can take tens of minutes to generate the forwarding state for the network, even on relatively small inputs. This forces programmers to waste time working around performance issues or even revert to using hardware-level APIs. This paper presents a new compiler for the NetKAT language that handles rich features including regular paths and virtual networks, and yet is several orders of magnitude faster than previous compilers. The compiler uses symbolic automata to calculate the extra state needed to implement \"global\" programs, and an intermediate representation based on binary decision diagrams to dramatically improve performance. We describe the design and implementation of three essential compiler stages: from virtual programs (which specify behavior in terms of virtual topologies) to global programs (which specify network-wide behavior in terms of physical topologies), from global programs to local programs (which specify behavior in terms of single-switch behavior), and from local programs to hardware-level forwarding tables. We present results from experiments on real-world benchmarks that quantify performance in terms of compilation time and forwarding table size.", "paper_title": "A Fast Compiler for NetKAT", "paper_id": "WOS:000367255800029"}