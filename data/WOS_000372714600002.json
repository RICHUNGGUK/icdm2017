{"auto_keywords": [{"score": 0.048877326221094704, "phrase": "concurrent_modules"}, {"score": 0.00481495049065317, "phrase": "modular_specifications"}, {"score": 0.004349337717774093, "phrase": "concurrent_program_module"}, {"score": 0.004186534737631288, "phrase": "difficult_problem"}, {"score": 0.003548368289666932, "phrase": "intended_clients"}, {"score": 0.0033295966773779174, "phrase": "underlying_module_implementation"}, {"score": 0.0030457198309616694, "phrase": "verification_techniques"}, {"score": 0.0021049977753042253, "phrase": "powerful_approaches"}], "paper_keywords": ["Concurrency", " specification", " program verification"], "paper_abstract": "The specification of a concurrent program module is a difficult problem. The specifications must be strong enough to enable reasoning about the intended clients without reference to the underlying module implementation. We survey a range of verification techniques for specifying concurrent modules, in particular highlighting four key concepts: auxiliary state, interference abstraction, resource ownership and atomicity. We show how these concepts combine to provide powerful approaches to specifying concurrent modules.", "paper_title": "Steps in Modular Specifications for Concurrent Modules", "paper_id": "WOS:000372714600002"}