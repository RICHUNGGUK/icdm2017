{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "hash_tables"}, {"score": 0.04972395969484311, "phrase": "network_devices"}, {"score": 0.00465634671242413, "phrase": "core_component"}, {"score": 0.004387117409226736, "phrase": "combined_memory_model"}, {"score": 0.004195418010131832, "phrase": "fast_memory"}, {"score": 0.004087469540575263, "phrase": "on-chip_sram"}, {"score": 0.0037101871762082153, "phrase": "real-life_hash_tables"}, {"score": 0.0036281710561308377, "phrase": "suboptimal_choice"}, {"score": 0.003587842947046177, "phrase": "hashing_scheme_parameters"}, {"score": 0.0035216195857272403, "phrase": "higher_average_query_time"}, {"score": 0.0034437574674180365, "phrase": "lower_throughput"}, {"score": 0.0033301694494391643, "phrase": "multiple-choice_hash_tables"}, {"score": 0.0031257046538823354, "phrase": "hash_table"}, {"score": 0.0030001224724395354, "phrase": "equivalent_problem"}, {"score": 0.002901124599876666, "phrase": "random_bipartite_graph"}, {"score": 0.0028688545415450407, "phrase": "fixed_left-side_vertex_degree"}, {"score": 0.002784540221128404, "phrase": "exact_results"}, {"score": 0.0027535633837592597, "phrase": "finite_system"}, {"score": 0.0027026971435126553, "phrase": "asymptotic_results"}, {"score": 0.0026726283357752585, "phrase": "fast_memory_size_increases"}, {"score": 0.0024075916292945715, "phrase": "internet_backbone_traces"}, {"score": 0.0022013916728990564, "phrase": "common_intuition"}, {"score": 0.0021687806803474367, "phrase": "slow_memory_accesses"}, {"score": 0.0021446391766277817, "phrase": "highly_efficient_schemes"}], "paper_keywords": ["Maximum matching", " random bipartite graph", " combined SRAM/DRAM memory model"], "paper_abstract": "Hash tables form a core component of many algorithms as well as network devices. Because of their large size, they often require a combined memory model, in which some of the elements are stored in a fast memory (for example, cache or on-chip SRAM) while others are stored in much slower memory (namely, the main memory or off-chip DRAM). This makes the implementation of real-life hash tables particularly delicate, as a suboptimal choice of the hashing scheme parameters may result in a higher average query time, and therefore in a lower throughput. In this paper, we focus on multiple-choice hash tables. Given the number of choices, we study the tradeoff between the load of a hash table and its average lookup time. The problem is solved by analyzing an equivalent problem: the expected maximum matching size of a random bipartite graph with a fixed left-side vertex degree. Given two choices, we provide exact results for any finite system, and also deduce asymptotic results as the fast memory size increases. In addition, we further consider other variants of this problem and model the impact of several parameters. Finally, we evaluate the performance of our models on Internet backbone traces, and illustrate the impact of the memories speed difference on the choice of parameters. In particular, we show that the common intuition of entirely avoiding slow memory accesses by using highly efficient schemes (namely, with many fast-memory choices) is not always optimal.", "paper_title": "Maximizing the Throughput of Hash Tables in Network Devices with Combined SRAM/DRAM Memory", "paper_id": "WOS:000349769500016"}