{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "woeginger"}, {"score": 0.00481495049065317, "phrase": "partially_ordered_jobs_faster"}, {"score": 0.0045443671106012405, "phrase": "scheduling_problem"}, {"score": 0.00418387341007444, "phrase": "graham_notation"}, {"score": 0.0036958398682001015, "phrase": "precedence_constraints"}, {"score": 0.0031064226956732497, "phrase": "special_case"}, {"score": 0.002931569771634119, "phrase": "natural_dynamic_programming_algorithm"}, {"score": 0.0021940118003312397, "phrase": "open_problem"}], "paper_keywords": ["Moderately-exponential algorithms", " Dynamic programming", " 2(n)-Barrier", " Scheduling", " Partially ordered jobs"], "paper_abstract": "In a scheduling problem, denoted by 1|prec|aC (i) in the Graham notation, we are given a set of n jobs, together with their processing times and precedence constraints. The task is to order the jobs so that their total completion time is minimized. 1|prec|aC (i) is a special case of the Traveling Repairman Problem with precedences. A natural dynamic programming algorithm solves both these problems in 2 (n) n (O(1)) time, and whether there exists an algorithms solving 1|prec|aC (i) in O(c (n) ) time for some constant c < 2 was an open problem posted in 2004 by Woeginger. In this paper we answer this question positively.", "paper_title": "Scheduling Partially Ordered Jobs Faster than 2(n)", "paper_id": "WOS:000330969900007"}