{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "embedded_systems"}, {"score": 0.004712463245074863, "phrase": "strong_demands"}, {"score": 0.004652016085325825, "phrase": "fast_and_cycle-accurate_virtual_platforms"}, {"score": 0.004456044928556639, "phrase": "meaningful_software_development"}, {"score": 0.004417848254181138, "phrase": "performance_debugging"}, {"score": 0.004305203085016233, "phrase": "entire_platform"}, {"score": 0.004053362743156545, "phrase": "fast_and_cycle-accurate_architecture_simulator"}, {"score": 0.003623949225126944, "phrase": "whole-system_simulation"}, {"score": 0.003471135453226184, "phrase": "modular_manner"}, {"score": 0.0032538723984338615, "phrase": "new_classes"}, {"score": 0.0032259472087775138, "phrase": "facsim"}, {"score": 0.003157174936641705, "phrase": "interpretive_simulation_technique"}, {"score": 0.00306334226516593, "phrase": "high_speed"}, {"score": 0.0030109772626153797, "phrase": "fast_cycle-accurate_architecture_simulation"}, {"score": 0.0028715299874549245, "phrase": "elapsed_cycles"}, {"score": 0.0028346293790895024, "phrase": "pipeline_stage"}, {"score": 0.0026916956768363158, "phrase": "core_clock"}, {"score": 0.0026456667695073043, "phrase": "cycle-by-cycle_simulation"}, {"score": 0.002566997205079849, "phrase": "basic-block_cache"}, {"score": 0.00253400005142168, "phrase": "decoded_instructions"}, {"score": 0.0025014259919355453, "phrase": "basic-block_level"}, {"score": 0.0024061887405214186, "phrase": "multicore_systems"}, {"score": 0.002294686545883412, "phrase": "eembc_benchmark_suite"}, {"score": 0.0022749744354271816, "phrase": "facsim's_accuracy"}, {"score": 0.0021049977753042253, "phrase": "basic-block_level_caching"}], "paper_keywords": ["algorithms", " design", " measurement", " performance", " experimentation", " architecture simulator", " simulator parallelization", " cycle-accurate simulation", " full-system simulation", " virtual prototyping"], "paper_abstract": "There have been strong demands for a fast and cycle-accurate virtual platforms in the embedded systems area where developers can do meaningful software development including performance debugging in the context of the entire platform. In this paper, we describe the design and implementation of a fast and cycle-accurate architecture simulator called FaCSim as a first step towards such a virtual platform. FacSim accurately models the ARM9E-S processor core and ARM926EJ-S processor's memory subsystem. It accurately simulates exceptions and interrupts to enable whole-system simulation including the OS. Since it is implemented in a modular manner in C++, it can be easily extended with other system components by subclassing or adding new classes. FaCSim is based on an interpretive simulation technique to provide flexibility, yet achieving high speed. It enables fast cycle-accurate architecture simulation by means of three mechanisms. First, it computes elapsed cycles in each pipeline stage as a chunk and incrementally adds it up to advance the core clock instead of performing cycle-by-cycle simulation. Second, it uses a basic-block cache that caches decoded instructions at the basic-block level. Finally, it is parallelized to exploit multicore systems that are available everywhere these days. Using 21 applications from the EEMBC benchmark suite, FaCSim's accuracy is validated against the ARM926EJ-S development board from ARM, and is accurate in a +/- 7% error margin. Due to basic-block level caching and parallelization, FaCSim is, on average, more than three times faster than ARMulator and more than six times faster than SimpleScalar.", "paper_title": "FaCSim: A fast and cycle-accurate architecture simulator for embedded systems", "paper_id": "WOS:000257820500009"}