{"auto_keywords": [{"score": 0.037723097438157785, "phrase": "root_scanning"}, {"score": 0.015469842941326485, "phrase": "real-time_garbage_collector"}, {"score": 0.010285212052786421, "phrase": "application_threads"}, {"score": 0.009612105607093982, "phrase": "garbage_collector"}, {"score": 0.00481495049065317, "phrase": "nonblocking_real-time"}, {"score": 0.004586531354697466, "phrase": "bounded_allocation_rates"}, {"score": 0.004454691230204595, "phrase": "short_blocking_times"}, {"score": 0.004397313229350093, "phrase": "incremental_garbage_collectors"}, {"score": 0.004215868268050613, "phrase": "root_nodes"}, {"score": 0.004175066536037121, "phrase": "object_graph"}, {"score": 0.004134658048970194, "phrase": "integral_part"}, {"score": 0.004094639048362357, "phrase": "garbage_collectors"}, {"score": 0.0040027552011993005, "phrase": "heap_compaction"}, {"score": 0.003938383970047866, "phrase": "probably_unbounded_heap_fragmentation"}, {"score": 0.0038375280115736958, "phrase": "unacceptably_high_memory_consumption"}, {"score": 0.0036790959367543337, "phrase": "thread_stacks"}, {"score": 0.003107935254560724, "phrase": "latter_solution"}, {"score": 0.0029602552900111407, "phrase": "execution_time"}, {"score": 0.0025829353063908256, "phrase": "large_objects"}, {"score": 0.002566215899764421, "phrase": "especially_large_arrays"}, {"score": 0.002549604441640963, "phrase": "long_blocking_times"}, {"score": 0.0025085435314540837, "phrase": "real-time_systems"}, {"score": 0.0024521640882380477, "phrase": "interruptible_copy_unit"}, {"score": 0.0024126686412257407, "phrase": "nonblocking_object_copy"}, {"score": 0.0023431692392929353, "phrase": "single_word_move"}, {"score": 0.0022756672722130424, "phrase": "proposed_techniques"}, {"score": 0.0022536005664642294, "phrase": "java_processor"}, {"score": 0.0021745003291048356, "phrase": "high-priority_hard_real-time_tasks"}, {"score": 0.002125612498781805, "phrase": "garbage_collection_task"}], "paper_keywords": ["Performance", " Design", " Garbage collection", " real-time", " root scanning", " nonblocking copying"], "paper_abstract": "A real-time garbage collector has to fulfill two basic properties: ensure that programs with bounded allocation rates do not run out of memory and provide short blocking times. Even for incremental garbage collectors, two major sources of blocking exist, namely, root scanning and heap compaction. Finding root nodes of an object graph is an integral part of tracing garbage collectors and cannot be circumvented. Heap compaction is necessary to avoid probably unbounded heap fragmentation, which in turn would lead to unacceptably high memory consumption. In this article, we propose solutions to both issues. Thread stacks are local to a thread, and root scanning, therefore, only needs to be atomic with respect to the thread whose stack is scanned. This fact can be utilized by either blocking only the thread whose stack is scanned, or by delegating the responsibility for root scanning to the application threads. The latter solution eliminates blocking due to root scanning completely. The impact of this solution on the execution time of a garbage collector is shown for two different variants of such a root scanning algorithm. During heap compaction, objects are copied. Copying is usually performed atomically to avoid interference with application threads, which could render the state of an object inconsistent. Copying of large objects and especially large arrays introduces long blocking times that are unacceptable for real-time systems. In this article, an interruptible copy unit is presented that implements nonblocking object copy. The unit can be interrupted after a single word move. We evaluate a real-time garbage collector that uses the proposed techniques on a Java processor. With this garbage collector, it is possible to run high-priority hard real-time tasks at 10 kHz parallel to the garbage collection task on a 100 MHz system.", "paper_title": "Nonblocking Real-Time Garbage Collection", "paper_id": "WOS:000282763900006"}