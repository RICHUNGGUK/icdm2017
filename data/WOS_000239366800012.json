{"auto_keywords": [{"score": 0.038780937298415766, "phrase": "inner-most_loop"}, {"score": 0.00481495049065317, "phrase": "nested_loops"}, {"score": 0.0047273577269638725, "phrase": "low-power_design"}, {"score": 0.00443308765153716, "phrase": "power_consumption"}, {"score": 0.004352411290383643, "phrase": "embedded_processors"}, {"score": 0.0038271712887391015, "phrase": "unnested_loops"}, {"score": 0.0032436052954996097, "phrase": "stack-based_controller"}, {"score": 0.003126481516783286, "phrase": "sequential_loops"}, {"score": 0.0025071862539276283, "phrase": "power_estimator_wattch"}, {"score": 0.0023725232579531273, "phrase": "energy_consumption"}], "paper_keywords": ["loop buffering", " low-power design"], "paper_abstract": "Several loop-buffering techniques were proposed for reducing power consumption of embedded processors. Although the schemes are effective in reducing power, they work for unnested loops (or the inner-most loop in nested loops) only. In this paper, we propose a stack-based controller which can handle sequential loops being nested in a loop of all styles and the if-then-else construct inside of a loop. Our experiments by power estimator Wattch show that the reduction in energy consumption using our technique is up to 36% improvement of the design without buffering technique and has 25% more improvement when compared to the results which handle inner-most loop only at the fetch and decode stages.", "paper_title": "Instruction buffering for nested loops in low-power design", "paper_id": "WOS:000239366800012"}