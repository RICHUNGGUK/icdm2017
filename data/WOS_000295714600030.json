{"auto_keywords": [{"score": 0.0364826355522259, "phrase": "higher-order_functions"}, {"score": 0.00481495049065317, "phrase": "abstracting_abstract_machines"}, {"score": 0.004686688155058031, "phrase": "higher-order_program_analysis"}, {"score": 0.004512814529823301, "phrase": "engineering_reliable_software_systems"}, {"score": 0.004116823963855969, "phrase": "difficult_and_error-prone_process"}, {"score": 0.004072573194988867, "phrase": "modern_high-level_programming_languages"}, {"score": 0.003900257249255497, "phrase": "principled_method"}, {"score": 0.0037352048741373816, "phrase": "analytic_models"}, {"score": 0.003695040819303525, "phrase": "analysis_designers"}, {"score": 0.003519561814102764, "phrase": "complex_languages_features"}, {"score": 0.0032806521851034766, "phrase": "dynamic_allocation"}, {"score": 0.003193129886123359, "phrase": "systematic_approach_to_program_analysis"}, {"score": 0.0029763124376934813, "phrase": "existing_derivational_techniques"}, {"score": 0.002928399649340438, "phrase": "high-level_language_semantics"}, {"score": 0.0028968858148006823, "phrase": "low-level_deterministic_state-transition_systems"}, {"score": 0.0026710653215026685, "phrase": "simple_machine_refactorings"}, {"score": 0.0025031188149336257, "phrase": "non-deterministic_state-transition_systems"}, {"score": 0.002333044307949414, "phrase": "program_analysis"}, {"score": 0.0023079225317714815, "phrase": "realistic_language_features"}, {"score": 0.0021863046959469863, "phrase": "side_effects"}, {"score": 0.0021394674440767124, "phrase": "first-class_continuations"}, {"score": 0.0021049977753042253, "phrase": "even_garbage_collection"}], "paper_keywords": [""], "paper_abstract": "Predictive models are fundamental to engineering reliable software systems. However, designing conservative, computable approximations for the behavior of programs (static analyses) remains a difficult and error-prone process for modern high-level programming languages. What analysis designers need is a principled method for navigating the gap between semantics and analytic models: analysis designers need a method that tames the interaction of complex languages features such as higher-order functions, recursion, exceptions, continuations, objects and dynamic allocation. We contribute a systematic approach to program analysis that yields novel and transparently sound static analyses. Our approach relies on existing derivational techniques to transform high-level language semantics into low-level deterministic state-transition systems (with potentially infinite state spaces). We then perform a series of simple machine refactorings to obtain a sound, computable approximation, which takes the form of a non-deterministic state-transition systems with finite state spaces. The approach scales up uniformly to enable program analysis of realistic language features, including higher-order functions, tail calls, conditionals, side effects, exceptions, first-class continuations, and even garbage collection.", "paper_title": "Abstracting Abstract Machines A Systematic Approach to Higher-Order Program Analysis", "paper_id": "WOS:000295714600030"}