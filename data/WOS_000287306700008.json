{"auto_keywords": [{"score": 0.040068893161497504, "phrase": "panini"}, {"score": 0.024242814380743473, "phrase": "panini_programs"}, {"score": 0.00481495049065317, "phrase": "correct_and_efficient_concurrent_programs"}, {"score": 0.004692227830462433, "phrase": "explicit_concurrency"}, {"score": 0.004231699728933577, "phrase": "modular_program_design"}, {"score": 0.004159446063902181, "phrase": "separate_goals"}, {"score": 0.0038825121288253435, "phrase": "new_language"}, {"score": 0.0036710872046569532, "phrase": "panini's_asynchronous"}, {"score": 0.0035620354052144656, "phrase": "modularity_goal"}, {"score": 0.003501175642882274, "phrase": "implicit_invocation_design_style"}, {"score": 0.0034562118159899772, "phrase": "concurrency_goal"}, {"score": 0.0034118234596993836, "phrase": "potential_concurrency"}, {"score": 0.00295950473406239, "phrase": "static_analysis"}, {"score": 0.0029214769181390653, "phrase": "potential_conflicts"}, {"score": 0.0028591768694918, "phrase": "dynamic_analysis"}, {"score": 0.002810292047426252, "phrase": "conflict_information"}, {"score": 0.0027622407190589326, "phrase": "safe_order"}, {"score": 0.002738523189244011, "phrase": "handler_invocation"}, {"score": 0.0025780912201045555, "phrase": "guaranteed_deterministic_semantics"}, {"score": 0.0024061887405214186, "phrase": "empirical_study"}, {"score": 0.0023855210798264205, "phrase": "program_performance"}, {"score": 0.002226430168622392, "phrase": "standard_concurrent_object-oriented_programs"}, {"score": 0.0021049977753042253, "phrase": "java's_fork-join_framework"}], "paper_keywords": ["Languages", " Design", " Performance", " Safe Implicit Concurrency", " Modularity"], "paper_abstract": "Writing correct and efficient concurrent programs still remains a challenge. Explicit concurrency is difficult, error prone, and creates code which is hard to maintain and debug. This type of concurrency also treats modular program design and concurrency as separate goals, where modularity often suffers. To solve these problems, we are designing a new language that we call Panini. In this paper, we focus on Panini's asynchronous, typed events which reconcile the modularity goal promoted by the implicit invocation design style with the concurrency goal of exposing potential concurrency between the execution of subjects and observers. Since modularity is improved and concurrency is implicit in Panini, programs are easier to reason about and maintain. The language incorporates a static analysis to determine potential conflicts between handlers and a dynamic analysis which uses the conflict information to determine a safe order for handler invocation. This mechanism avoids races and deadlocks entirely, yielding programs with a guaranteed deterministic semantics. To evaluate our language design and implementation we show several examples of its usage as well as an empirical study of program performance. We found that not only is developing and understanding Panini programs significantly easier compared to standard concurrent object-oriented programs, but also performance of Panini programs is comparable to their equivalent hand-tuned versions written using Java's fork-join framework.", "paper_title": "Implicit Invocation Meets Safe, Implicit Concurrency", "paper_id": "WOS:000287306700008"}