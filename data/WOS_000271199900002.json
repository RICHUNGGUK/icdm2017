{"auto_keywords": [{"score": 0.043753829437962216, "phrase": "systemc"}, {"score": 0.00481495049065317, "phrase": "systemc_transaction-level_models"}, {"score": 0.004674952036988355, "phrase": "transaction-level_models"}, {"score": 0.004553914287137776, "phrase": "early_validation"}, {"score": 0.004524145463916772, "phrase": "embedded_software"}, {"score": 0.004479855062309818, "phrase": "tl_model"}, {"score": 0.004435996321956133, "phrase": "virtual_prototype"}, {"score": 0.004392565073466714, "phrase": "hardware_part"}, {"score": 0.004154332348800334, "phrase": "transaction_level_modeling"}, {"score": 0.0041136473765874815, "phrase": "main_parallel_entities"}, {"score": 0.004073359218158693, "phrase": "hardware_platform"}, {"score": 0.003877737556673229, "phrase": "asynchronous_processes"}, {"score": 0.003802135020791801, "phrase": "simulation_time"}, {"score": 0.003728000957725218, "phrase": "scheduling_mechanism"}, {"score": 0.003607630811220324, "phrase": "possible_schedulings"}, {"score": 0.0035722806911457545, "phrase": "parallel_activities"}, {"score": 0.003537275726870251, "phrase": "physical_parallelism"}, {"score": 0.003445591238183763, "phrase": "loose_timing_annotations"}, {"score": 0.003312486229143855, "phrase": "possible_values"}, {"score": 0.0031845067058084613, "phrase": "hardware_behaviors"}, {"score": 0.0031223774204093713, "phrase": "simulation_engine"}, {"score": 0.0030715271045670504, "phrase": "deterministic_scheduler"}, {"score": 0.0030017207229983385, "phrase": "specific_values"}, {"score": 0.0029722900280316216, "phrase": "time_intervals"}, {"score": 0.0025638362414466278, "phrase": "valid_schedulings"}, {"score": 0.0022777800735119405, "phrase": "dynamic_partial_order_reduction"}, {"score": 0.0022113879114507577, "phrase": "complete_scheduling"}, {"score": 0.0021968983291791784, "phrase": "timing_set"}, {"score": 0.0021398811716327273, "phrase": "local_errors"}, {"score": 0.0021049977753042253, "phrase": "fixed_test_scenario"}], "paper_keywords": ["System-on-a-Chip", " Translational modeling", " Simulation", " Scheduling", " Loose timing", " Runtime verification", " Dynamic partial order reduction", " Test coverage"], "paper_abstract": "Transaction-Level Models (TLM) are used for the early validation of embedded software. A TL model is a virtual prototype of the hardware part of a System-on-a-Chip (SoC). When using SystemC for transaction level modeling, the main parallel entities of the hardware platform (processors, DMAs, bus arbiters, etc.) are modeled by asynchronous processes, which are scheduled at simulation time. The specification of this scheduling mechanism is non-deterministic; the set of all possible schedulings of the parallel activities represents the physical parallelism faithfully. Moreover TL models may contain loose timing annotations (intervals for instance), and the set of all possible values of time in these intervals is also meant to represent the hardware behaviors faithfully. However, any simulation engine is built on a deterministic scheduler, and at runtime will use specific values in the time intervals. This means that only a very small subset of all the possible schedulings and timings are exhibited during simulation. Some bugs may be missed if they are due to some behaviors of the hardware that are represented by other schedulings or timings. For a given finite test scenario, the set of valid schedulings and timings of a model is finite, but far too large to be explored fully. We present a solution to cover the set of schedulings and timings efficiently. Our solution is based on dynamic partial order reduction and constraint solving techniques. It gives a complete scheduling and timing set, which guarantees the detection of all local errors and deadlocks for a fixed test scenario.", "paper_title": "Full simulation coverage for SystemC transaction-level models of systems-on-a-chip", "paper_id": "WOS:000271199900002"}