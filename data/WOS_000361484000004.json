{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "c_programs"}, {"score": 0.04265027099832193, "phrase": "auxiliary_paths"}, {"score": 0.004759635663291431, "phrase": "fast_counterexample_detection"}, {"score": 0.004492406361795448, "phrase": "deep_loops"}, {"score": 0.004415189385015778, "phrase": "numerous_spurious_and_increasingly_longer_counterexamples"}, {"score": 0.0038654774211631564, "phrase": "loop_iterations"}, {"score": 0.0036907133026806297, "phrase": "exact_effect"}, {"score": 0.0036482665232275583, "phrase": "arbitrarily_many_loop_iterations"}, {"score": 0.0031753062090452864, "phrase": "bit-vector_semantics"}, {"score": 0.003066945490483524, "phrase": "arbitrary_conditions"}, {"score": 0.002945175711537758, "phrase": "loop_body"}, {"score": 0.0028119023819663472, "phrase": "quantified_conditionals"}, {"score": 0.00273167822885383, "phrase": "resulting_performance_penalty"}, {"score": 0.0024756080101497086, "phrase": "broad_range"}, {"score": 0.002447101794397243, "phrase": "verification_techniques"}, {"score": 0.002363532907211947, "phrase": "lazy_abstraction"}, {"score": 0.0023228223366301226, "phrase": "model_checking"}, {"score": 0.0022565201625076876, "phrase": "resulting_tool"}, {"score": 0.0021921063460682293, "phrase": "buffer_overflow_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "deep_counterexamples"}], "paper_keywords": ["Model checking", " Loop acceleration", " Underapproximation", " Counterexamples"], "paper_abstract": "Many software model checkers only detect counterexamples with deep loops after exploring numerous spurious and increasingly longer counterexamples. We propose a technique that aims at eliminating this weakness by constructing auxiliary paths that represent the effect of a range of loop iterations. Unlike acceleration, which captures the exact effect of arbitrarily many loop iterations, these auxiliary paths may under-approximate the behaviour of the loops. In return, the approximation is sound with respect to the bit-vector semantics of programs. Our approach supports arbitrary conditions and assignments to arrays in the loop body, but may as a result introduce quantified conditionals. To reduce the resulting performance penalty, we present two quantifier elimination techniques specially geared towards our application. Loop under-approximation can be combined with a broad range of verification techniques. We paired our techniques with lazy abstraction and bounded model checking, and evaluated the resulting tool on a number of buffer overflow benchmarks, demonstrating its ability to efficiently detect deep counterexamples in C programs that manipulate arrays.", "paper_title": "Under-approximating loops in C programs for fast counterexample detection", "paper_id": "WOS:000361484000004"}