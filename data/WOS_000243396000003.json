{"auto_keywords": [{"score": 0.04476987451361031, "phrase": "rank-join_operators"}, {"score": 0.014909005450178002, "phrase": "top-k_queries"}, {"score": 0.012219592826017341, "phrase": "input_cardinality"}, {"score": 0.010806188022637308, "phrase": "ranking_plans"}, {"score": 0.009977137415081931, "phrase": "unexpected_changes"}, {"score": 0.00481495049065317, "phrase": "relational_databases"}, {"score": 0.004782848614014638, "phrase": "rank-aware_query_processing"}, {"score": 0.0047035227618053965, "phrase": "key_requirement"}, {"score": 0.004672160300006692, "phrase": "modern_applications"}, {"score": 0.004518442937844318, "phrase": "integral_part"}, {"score": 0.00447331713604276, "phrase": "application_semantics"}, {"score": 0.004340614094598847, "phrase": "rank-aware_query_optimization_framework"}, {"score": 0.0042543303585113965, "phrase": "relational_query_engines"}, {"score": 0.00412809672402551, "phrase": "system_r_dynamic_programming_algorithm"}, {"score": 0.0039655692352351625, "phrase": "interesting_physical_property"}, {"score": 0.0038867116254051363, "phrase": "rank-aware_query_plans"}, {"score": 0.0038478705530517296, "phrase": "traditional_join_operators"}, {"score": 0.0036349635956605675, "phrase": "probabilistic_model"}, {"score": 0.0034917831997090328, "phrase": "rank-join_operator"}, {"score": 0.003399466007862412, "phrase": "first_effort"}, {"score": 0.003354223660940168, "phrase": "needed_input_size"}, {"score": 0.003331828027460222, "phrase": "optimal_rank_aggregation_algorithms"}, {"score": 0.003243726030199957, "phrase": "full_integration"}, {"score": 0.0032005497177523025, "phrase": "real-world_query_processing_engines"}, {"score": 0.003115908199991072, "phrase": "static_query_optimizers"}, {"score": 0.00306414423737093, "phrase": "estimation_errors"}, {"score": 0.003013237619840709, "phrase": "computing_environment"}, {"score": 0.002827365415832384, "phrase": "execution_plan"}, {"score": 0.0026797398345997114, "phrase": "query_plans"}, {"score": 0.0026175952455594277, "phrase": "complex_ranking_state"}, {"score": 0.002582731586309754, "phrase": "execution_strategy"}, {"score": 0.0025568881277209725, "phrase": "running_ranking_query"}, {"score": 0.0025313026089662165, "phrase": "important_and_challenging_task"}, {"score": 0.0024892263318773704, "phrase": "extensive_experimental_study"}, {"score": 0.002431489080631481, "phrase": "proposed_framework"}, {"score": 0.002407155340052809, "phrase": "experimental_results"}, {"score": 0.0022661710658109916, "phrase": "dynamic_programming_cost-based_optimizers"}, {"score": 0.0021987994275190314, "phrase": "significant_speedup"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_mid-query_reoptimization_strategies"}], "paper_keywords": ["algorithms", " design", " experimentation", " performance", " advanced query processing", " ranking", " top-k", " adaptive processing", " rank-aware optimization"], "paper_abstract": "Rank-aware query processing has emerged as a key requirement in modern applications. In these applications, efficient and adaptive evaluation of top-k queries is an integral part of the application semantics. In this article, we introduce a rank-aware query optimization framework that fully integrates rank-join operators into relational query engines. The framework is based on extending the System R dynamic programming algorithm in both enumeration and pruning. We define ranking as an interesting physical property that triggers the generation of rank-aware query plans. Unlike traditional join operators, optimizing for rank-join operators depends on estimating the input cardinality of these operators. We introduce a probabilistic model for estimating the input cardinality, and hence the cost of a rank-join operator. To our knowledge, this is the first effort in estimating the needed input size for optimal rank aggregation algorithms. Costing ranking plans is key to the full integration of rank-join operators in real-world query processing engines. Since optimal execution strategies picked by static query optimizers lose their optimality due to estimation errors and unexpected changes in the computing environment, we introduce several adaptive execution strategies for top-k queries that respond to these unexpected changes and costing errors. Our reactive reoptimization techniques change the execution plan at runtime to significantly enhance the performance of running queries. Since top-k query plans are usually pipelined and maintain a complex ranking state, altering the execution strategy of a running ranking query is an important and challenging task. We conduct an extensive experimental study to evaluate the performance of the proposed framework. The experimental results are twofold: ( 1) we show the effectiveness of our cost-based approach of integrating ranking plans in dynamic programming cost-based optimizers; and ( 2) we show a significant speedup ( up to 300%) when using our adaptive execution of ranking plans over the state-of-the-art mid-query reoptimization strategies.", "paper_title": "Adaptive rank-aware query optimization in relational databases", "paper_id": "WOS:000243396000003"}