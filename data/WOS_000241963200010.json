{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "remote_reference_time_complexity"}, {"score": 0.046273829908275756, "phrase": "remote_memory_references"}, {"score": 0.036710449636736135, "phrase": "lower_bound"}, {"score": 0.035142389611168834, "phrase": "mutual_exclusion_algorithms"}, {"score": 0.004602773636967002, "phrase": "read-modify-write_model"}, {"score": 0.00450020161335541, "phrase": "distributed_shared_memory_multiprocessors"}, {"score": 0.004237666411136617, "phrase": "memory_traffic"}, {"score": 0.002392453087295391, "phrase": "atomic_primitives"}, {"score": 0.002286781334850213, "phrase": "multiprocessor_systems"}], "paper_keywords": ["mutual exclusion", " atomic instructions", " shared memory systems", " time complexity", " tight bounds"], "paper_abstract": "In distributed shared memory multiprocessors, remote memory references generate processor-to-memory traffic, which may result in a bottleneck. It is therefore important to design algorithms that minimize the number of remote memory references. We establish a lower bound of three on remote reference time complexity for mutual exclusion algorithms in a model where processes communicate by means of a general read-modify-write primitive that accesses at most one shared variable in one instruction. Since the general read-modify-write primitive is a generalization of a variety of atomic primitives that have been implemented in multiprocessor systems, our lower bound holds for all mutual exclusion algorithms that use such primitives. Furthermore, this lower bound is shown to be tight by presenting an algorithm with the matching upper bound. (C) 2006 Elsevier Inc. All rights reserved.", "paper_title": "A tight bound on remote reference time complexity of mutual exclusion in the read-modify-write model", "paper_id": "WOS:000241963200010"}