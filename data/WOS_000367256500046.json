{"auto_keywords": [{"score": 0.042788752691329104, "phrase": "data_representation"}, {"score": 0.03963620921346666, "phrase": "source_code"}, {"score": 0.00481495049065317, "phrase": "ad_hoc_data_representation_transformations"}, {"score": 0.004714023408114857, "phrase": "run-time_performance"}, {"score": 0.004470823343432748, "phrase": "library_collections"}, {"score": 0.004377077848734575, "phrase": "custom_objects"}, {"score": 0.004217708394188058, "phrase": "efficient_access"}, {"score": 0.004021267064832957, "phrase": "tedious_and_error-prone_process"}, {"score": 0.003674738405118697, "phrase": "automated_and_composable_mechanism"}, {"score": 0.0034849681064606543, "phrase": "delimited_scopes"}, {"score": 0.003375826910838081, "phrase": "entire_class_definitions"}, {"score": 0.0028487656293168795, "phrase": "type_system"}, {"score": 0.0027741761880779535, "phrase": "correctness_guarantees"}, {"score": 0.00267301171407926, "phrase": "object-oriented_language_features"}, {"score": 0.0026168641536413978, "phrase": "dynamic_dispatch"}, {"score": 0.0024423826953133844, "phrase": "scala_compiler_plugin"}, {"score": 0.0023038418282549274, "phrase": "data_layout"}, {"score": 0.002208035721125305, "phrase": "value_class_status"}], "paper_keywords": ["data representation", " jvm", " bytecode", " compatibility", " transformation", " optimization", " safety", " semantics"], "paper_abstract": "To maximize run-time performance, programmers often specialize their code by hand, replacing library collections and containers by custom objects in which data is restructured for efficient access. However, changing the data representation is a tedious and error-prone process that makes it hard to test, maintain and evolve the source code. We present an automated and composable mechanism that allows programmers to safely change the data representation in delimited scopes containing anything from expressions to entire class definitions. To achieve this, programmers define a transformation and our mechanism automatically and transparently applies it during compilation, eliminating the need to manually change the source code. Our technique leverages the type system in order to offer correctness guarantees on the transformation and its interaction with object-oriented language features, such as dynamic dispatch, inheritance and generics. We have embedded this technique in a Scala compiler plugin and used it in four very different transformations, ranging from improving the data layout and encoding, to retrofitting specialization and value class status, and all the way to collection deforestation. On our benchmarks, the technique obtained speedups between 1.8x and 24.5x.", "paper_title": "Automating Ad hoc Data Representation Transformations", "paper_id": "WOS:000367256500046"}