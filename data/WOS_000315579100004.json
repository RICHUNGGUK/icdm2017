{"auto_keywords": [{"score": 0.0472261268256367, "phrase": "data_structure"}, {"score": 0.0327813622966444, "phrase": "high_probability"}, {"score": 0.012477900569364727, "phrase": "optimal_length"}, {"score": 0.009124048634490109, "phrase": "relaxed_error-correcting_data_structure"}, {"score": 0.00481495049065317, "phrase": "data_structures"}, {"score": 0.004765970000342784, "phrase": "adversarial_noise"}, {"score": 0.004669491735725192, "phrase": "succinct_data_structure"}, {"score": 0.004603115982404017, "phrase": "specific_queries"}, {"score": 0.00447316895126645, "phrase": "constant_fraction"}, {"score": 0.004038183610525504, "phrase": "new_model"}, {"score": 0.004013467050883458, "phrase": "common_generalization"}, {"score": 0.003980745866905835, "phrase": "locally_decodable_error-correcting_codes"}, {"score": 0.003900100724749234, "phrase": "upper_and_lower_bounds"}, {"score": 0.003797690272118125, "phrase": "t-probe_error-correcting_data_structures"}, {"score": 0.003623021914690631, "phrase": "membership_queries"}, {"score": 0.0035423376631308567, "phrase": "t-probe_ldcs"}, {"score": 0.003506257323449023, "phrase": "length_s."}, {"score": 0.0034492889699651607, "phrase": "small_t"}, {"score": 0.003400198866111204, "phrase": "bad_probes-versus-length_trade-off"}, {"score": 0.003331462822102908, "phrase": "membership"}, {"score": 0.0032570672391962208, "phrase": "so-called_relaxed_error-correcting_data_structures"}, {"score": 0.003210704011271791, "phrase": "\"relaxed_locally_decodable_codes"}, {"score": 0.0031779907400793376, "phrase": "pcp_literature"}, {"score": 0.003069230909006614, "phrase": "remaining_queries"}, {"score": 0.0028510114763213596, "phrase": "positive_results"}, {"score": 0.0027477745788313163, "phrase": "nearly_linear"}, {"score": 0.0026428443772601343, "phrase": "asymptotically_optimal_parameters"}, {"score": 0.002626645763725465, "phrase": "noiseless_case"}, {"score": 0.002547126085029548, "phrase": "buhrman_et_al"}, {"score": 0.002464950229534813, "phrase": "univariate_polynomial_g"}, {"score": 0.0023952188670182542, "phrase": "evaluation_queries"}, {"score": 0.002233955460191053, "phrase": "n_that_answers"}, {"score": 0.002126689547205173, "phrase": "best_known_noiseless_construction"}, {"score": 0.0021136508536459056, "phrase": "kedlaya"}, {"score": 0.002104999969758322, "phrase": "umans"}], "paper_keywords": ["data structures", " fault-tolerance", " error-correcting codes", " locally decodable codes", " membership problem", " polynomial evaluation"], "paper_abstract": "We study data structures in the presence of adversarial noise. We want to encode a given object in a succinct data structure that enables us to efficiently answer specific queries about the object, even if the data structure has been corrupted by a constant fraction of errors. We measure the efficiency of a data structure in terms of its length (the number of bits in its representation) and query-answering time, measured by the number of bit-probes to the (possibly corrupted) representation. The main issue is the trade-off between these two. This new model is the common generalization of (static) data structures and locally decodable error-correcting codes (LDCs). We prove a number of upper and lower bounds on various natural error-correcting data structure problems. In particular, we show that the optimal length of t-probe error-correcting data structures for the MEMBERSHIP problem (where we want to store subsets of size s from a universe of size n such that membership queries can be answered efficiently) is approximately the optimal length of t-probe LDCs that encode strings of length s. It has been conjectured that LDCs with small t must be superpolynomially long. This bad probes-versus-length trade-off carries over to error-correcting data structures for MEMBERSHIP and many other data structure problems. We then circumvent this problem by defining so-called relaxed error-correcting data structures, inspired by the notion of \"relaxed locally decodable codes\" developed in the PCP literature. Here the decoder is required to answer most queries correctly with high probability, and for the remaining queries the decoder with high probability either answers correctly or declares \"don't know.\" Furthermore, if there is no noise on the data structure, it answers all queries correctly with high probability. We obtain positive results for the following two data structure problems: (1) MEMBERSHIP. We construct a relaxed error-correcting data structure for this problem with length nearly linear in s log n that answers membership queries with O(1) bit-probes. This nearly matches the asymptotically optimal parameters for the noiseless case: length O(s log n) and one bit-probe, due to Buhrman et al. (2) UNIVARIATE POLYNOMIAL EVALUATION (namely, we want to store a univariate polynomial g of degree deg(g) <= s over the integers modulo n such that evaluation queries can be answered efficiently; i.e., we can evaluate the output of g on a given integer modulo n). We construct a relaxed error-correcting data structure for this problem with length nearly linear in s log n that answers evaluation queries with polylog(s) . log(1+o(1)) (n) bit-probes. This nearly matches the parameters of the best known noiseless construction due to Kedlaya and Umans.", "paper_title": "ERROR-CORRECTING DATA STRUCTURES", "paper_id": "WOS:000315579100004"}