{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "dynamic_environment"}, {"score": 0.0046114557978424245, "phrase": "ai_literature"}, {"score": 0.004545544875014869, "phrase": "agent_behavior"}, {"score": 0.004403823349864079, "phrase": "earlier_characterizations"}, {"score": 0.0042542311446793725, "phrase": "maintenance_behavior"}, {"score": 0.004133443893051179, "phrase": "different_characterization"}, {"score": 0.004050930846552577, "phrase": "earlier_notions"}, {"score": 0.003902020354497715, "phrase": "good-natured_agent"}, {"score": 0.003846210117129662, "phrase": "\"adversary\"_environment"}, {"score": 0.003780286517897356, "phrase": "unforeseeable_events"}, {"score": 0.003487222504700868, "phrase": "exogenous_events"}, {"score": 0.0032354070943654487, "phrase": "important_but_non-trivial_issue"}, {"score": 0.0031891008393769515, "phrase": "maintainability_control_functions"}, {"score": 0.003116381104175926, "phrase": "polynomial_time"}, {"score": 0.0030895394261534776, "phrase": "k-maintainable_control_function"}, {"score": 0.0029332611651817528, "phrase": "sat_solving"}, {"score": 0.0028912667826416494, "phrase": "suitable_formulation"}, {"score": 0.0028498718992429825, "phrase": "k-maintainable_control"}, {"score": 0.0027608716347791266, "phrase": "small_k"}, {"score": 0.002682370021834353, "phrase": "linear_time"}, {"score": 0.0026363417150129962, "phrase": "logic_programming_implementation"}, {"score": 0.0025687721301935465, "phrase": "standard_procedural_algorithm"}, {"score": 0.002510161871523503, "phrase": "k-maintainable_controls"}, {"score": 0.002488528581414211, "phrase": "different_assumptions"}, {"score": 0.0023557715482776694, "phrase": "new_concepts"}, {"score": 0.0022365262201954643, "phrase": "computational_logic_tools"}, {"score": 0.0021981315377404245, "phrase": "earlier_works"}, {"score": 0.0021854800233595444, "phrase": "control_synthesis"}, {"score": 0.0021729011671662536, "phrase": "temporal_logic_specification"}, {"score": 0.0021417691855960715, "phrase": "dijkstra's_notion"}, {"score": 0.0021171843749653455, "phrase": "related_notions"}, {"score": 0.0021049977753042253, "phrase": "distributed_computing"}], "paper_keywords": ["maintenance goals", " k-maintainability", " agent control", " computational complexity of agent design", " answer set programming", " horn theories", " SAT solving", " discrete event dynamic systems", " self-stabilization"], "paper_abstract": "The notion of maintenance often appears in the AI literature in the context of agent behavior and planning. In this paper, we argue that earlier characterizations of the notion of maintenance are not intuitive to characterize the maintenance behavior of certain agents in a dynamic environment. We propose a different characterization of maintenance and distinguish it from earlier notions such as stabilizability. Our notion of maintenance is more sensitive to a good-natured agent which struggles with an \"adversary\" environment, which hinders her by unforeseeable events to reach her goals (not in principle, but in case). It has a parameter k, referring to the length of non-interference (from exogenous events) needed to maintain a goal; we refer to this notion as k-maintainability. We demonstrate the notion on examples, and address the important but non-trivial issue of efficient construction of maintainability control functions. We present an algorithm which in polynomial time constructs a k-maintainable control function, if one exists, or tells that no such control is possible. Our algorithm is based on SAT Solving, and employs a suitable formulation of the existence of k-maintainable control in a fragment of SAT which is tractable. For small k (bounded by a constant), our algorithm is linear time. We then give a logic programming implementation of our algorithm and use it to give a standard procedural algorithm, and analyze the complexity of constructing k-maintainable controls, under different assumptions such as k = 1, and states described by variables. On the one hand, our work provides new concepts and algorithms for maintenance in dynamic environment, and on the other hand, a very fruitful application of computational logic tools. We compare our work with earlier works on control synthesis from temporal logic specification and relate our work to Dijkstra's notion of self-stabilization and related notions in distributed computing. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Maintenance goals of agents in a dynamic environment: Formulation and policy construction", "paper_id": "WOS:000258161300001"}