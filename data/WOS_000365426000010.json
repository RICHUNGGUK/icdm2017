{"auto_keywords": [{"score": 0.04872396874382183, "phrase": "model_checker"}, {"score": 0.015719783472112437, "phrase": "cml"}, {"score": 0.012324516435769662, "phrase": "fdr"}, {"score": 0.004634117581810466, "phrase": "automatic_tool"}, {"score": 0.004575354958479747, "phrase": "specific_structure"}, {"score": 0.004546252387071551, "phrase": "normally_a_kripke_structure"}, {"score": 0.004238035283883863, "phrase": "formal_notations"}, {"score": 0.004144399274022276, "phrase": "specification_s"}, {"score": 0.004078780515171644, "phrase": "formal_language"}, {"score": 0.003975936061382971, "phrase": "labelled_transition_system"}, {"score": 0.003826492478418294, "phrase": "general_how_usual_tools"}, {"score": 0.0037979285204920716, "phrase": "spin"}, {"score": 0.0037419233550722163, "phrase": "pat"}, {"score": 0.0036592001010420667, "phrase": "lts_representation"}, {"score": 0.0035216195857272403, "phrase": "lts_generation"}, {"score": 0.0031895978980118127, "phrase": "development_approach"}, {"score": 0.0031091037560494806, "phrase": "systematic_semantics"}, {"score": 0.0030696193341147866, "phrase": "formal_modeling"}, {"score": 0.003050064985384108, "phrase": "logic_programming"}, {"score": 0.0028980357312095835, "phrase": "formal_language_compass_modelling_language"}, {"score": 0.0027979296553079557, "phrase": "vdm"}, {"score": 0.0027712221075336853, "phrase": "refinement_calculus"}, {"score": 0.0026686869024027927, "phrase": "formula"}, {"score": 0.0026330549554033876, "phrase": "satisfiability_modulo_theories"}, {"score": 0.0025339578578194143, "phrase": "infinite_domains"}, {"score": 0.002485813299166851, "phrase": "symbolic_lts."}, {"score": 0.0024307967304431806, "phrase": "traditional_csp_model_checkers"}, {"score": 0.0023922444655593046, "phrase": "pat."}, {"score": 0.0022948394240866555, "phrase": "simple_semantic_modifications"}, {"score": 0.002187356046251648, "phrase": "real_implementation"}, {"score": 0.0021526564019119466, "phrase": "integrated_development_platform"}, {"score": 0.0021049977753042253, "phrase": "industrial_case_study"}], "paper_keywords": ["CML", " Model checker", " Analysis", " FORMULA", " Operational semantics", " SMT"], "paper_abstract": "A model checker is an automatic tool that traverses a specific structure (normally a Kripke structure referred as the model M) to check the satisfaction of some (temporal) logical property f. This is formally stated as . For some formal notations, the model M of a specification S (written in a formal language L) can be described as a labelled transition system (LTS). Specifically, it is not clear in general how usual tools such as SPIN, FDR, PAT, etc., create the LTS representation from a given process. Although one expects the coherence of the LTS generation with the semantics of L, it is completely hidden inside the model checker itself. In this paper we show how to create a model checker for L, using a development approach based on its operational semantics. We use a systematic semantics embedding and the formal modeling using logic programming and analysis (FORMULA) framework to this end. We illustrate our strategy considering the formal language COMPASS modelling language (CML)-a new language that was based on CSP, VDM and the refinement calculus proposed for modelling and analysis of systems of systems. As FORMULA is based on satisfiability modulo theories solving, our model checker can handle communications and predicates involving data with infinite domains by building and manipulating a symbolic LTS. This goes beyond the capabilities of traditional CSP model checkers such as FDR and PAT. Moreover, we show how to reduce time and space complexities by simple semantic modifications in the embedding. This allows a more semantics-preserving tuning. Finally, we show a real implementation of our model checker in an integrated development platform for CML and its practical use on an industrial case study.", "paper_title": "Model checking CML: tool development and industrial applications", "paper_id": "WOS:000365426000010"}