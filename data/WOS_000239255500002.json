{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "efficient_genericity"}, {"score": 0.004563427013973105, "phrase": "gaussian_elimination_algorithm"}, {"score": 0.004278807087784626, "phrase": "family_-_common_implementations"}, {"score": 0.00323625520042892, "phrase": "metaocaml's_staging_facilities"}, {"score": 0.002937879003671346, "phrase": "natural_and_type-safe_implementation"}, {"score": 0.002875391177926809, "phrase": "gaussian_elimination"}, {"score": 0.002724909017963099, "phrase": "code-generation_time"}, {"score": 0.0023189818169615135, "phrase": "resulting_code"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["MetaOCaml", " linear algebra", " genericity", " generative", " staging"], "paper_abstract": "The Gaussian Elimination algorithm is in fact an algorithm family - common implementations contain at least six (mostly independent) \"design choices\". A generic implementation can easily be parametrized by all these design choices, but this usually leads to slow and bloated code. Using MetaOCaml's staging facilities, we show how we can produce a natural and type-safe implementation of Gaussian Elimination which exposes its design choices at code-generation time, so that these choices can effectively be specialized away, and where the resulting code is quite efficient. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "Gaussian Elimination: A case study in efficient genericity with MetaOCaml", "paper_id": "WOS:000239255500002"}