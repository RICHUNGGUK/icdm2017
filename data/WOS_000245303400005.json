{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "arbitrary_stable_properties"}, {"score": 0.015409493645635382, "phrase": "stable_property"}, {"score": 0.004776297980616768, "phrase": "efficient_snapshots"}, {"score": 0.004424160689087029, "phrase": "distributed_executions"}, {"score": 0.0043533862892678864, "phrase": "open_problem"}, {"score": 0.004301046274139699, "phrase": "known_algorithms"}, {"score": 0.00421520166010848, "phrase": "snapshot_algorithms"}, {"score": 0.0039042694651106884, "phrase": "large_number"}, {"score": 0.0038417798012011155, "phrase": "global_snapshot"}, {"score": 0.003780286517897356, "phrase": "application_message_headers"}, {"score": 0.0036454883790271843, "phrase": "execution_history"}, {"score": 0.0035726811019151984, "phrase": "strong_property"}, {"score": 0.0035296940954990964, "phrase": "causal_delivery"}, {"score": 0.003335804608791029, "phrase": "arbitrary_stable_property"}, {"score": 0.003216804708106142, "phrase": "application_messages"}, {"score": 0.003077092305006702, "phrase": "message_coloring"}, {"score": 0.002872979681637667, "phrase": "message_history"}, {"score": 0.002682370021834353, "phrase": "nonintrusive_algorithms"}, {"score": 0.002545165985686468, "phrase": "three-phase_strategy"}, {"score": 0.002494279207996077, "phrase": "local_states"}, {"score": 0.0024345529783611703, "phrase": "consistent_snapshot"}, {"score": 0.0023381630439887184, "phrase": "key_feature"}, {"score": 0.0021306709646058295, "phrase": "thin_slice"}, {"score": 0.0021049977753042253, "phrase": "algorithm_execution"}], "paper_keywords": ["distributed system", " global state", " stable predicate", " stable property", " distributed snapshot"], "paper_abstract": "A stable property continues to hold in an execution once it becomes true. Detecting arbitrary stable properties efficiently in distributed executions is still an open problem. The known algorithms for detecting arbitrary stable properties and snapshot algorithms used to detect such stable properties suffer from drawbacks such as the following: They incur the overhead of a large number of messages per global snapshot, or alter application message headers, or use inhibition, or use the execution history, or assume a strong property such as causal delivery of messages in the system. We solve the problem of detecting an arbitrary stable property efficiently under the following assumptions: P1) The application messages should not be modified, not even by timestamps or message coloring. P2) No inhibition is allowed. P3) The algorithm should not use the message history. P4) Any process can initiate the algorithm. This paper proposes a family of nonintrusive algorithms requiring 6(n-1) control messages, where n is the number of processes. A three-phase strategy of uncoordinated observation of local states is used to give a consistent snapshot from which any stable property can be detected. A key feature of our algorithms is that they do not rely on the processes continually and pessimistically reporting their activity. Only the relevant activity that occurs in the thin slice during the algorithm execution needs to be examined.", "paper_title": "Detecting arbitrary stable properties using efficient snapshots", "paper_id": "WOS:000245303400005"}