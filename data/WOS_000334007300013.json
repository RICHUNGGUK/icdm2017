{"auto_keywords": [{"score": 0.03793044352294926, "phrase": "wssm"}, {"score": 0.00481495049065317, "phrase": "optimal_packed_string_matching"}, {"score": 0.004749106104067268, "phrase": "packed_string_matching_problem"}, {"score": 0.004636027593561925, "phrase": "machine_word"}, {"score": 0.004479120557712926, "phrase": "n-character_string"}, {"score": 0.004109600767747015, "phrase": "factor_alpha_speedup"}, {"score": 0.004081385289516914, "phrase": "traditional_algorithms"}, {"score": 0.0038492126993451337, "phrase": "word-ram_model"}, {"score": 0.003555902292752528, "phrase": "contemporary_commodity_processors"}, {"score": 0.0035072146967082083, "phrase": "wslm"}, {"score": 0.003435426082776884, "phrase": "pattern_pre-processing"}, {"score": 0.0032848684681050745, "phrase": "prior_theoretical_packed_string"}, {"score": 0.003130077012135034, "phrase": "packed_string"}, {"score": 0.00307657476125683, "phrase": "classical_word-ram_model"}, {"score": 0.0029416973901327925, "phrase": "wslm."}, {"score": 0.0029114187110123105, "phrase": "micro-level_algorithms"}, {"score": 0.002881450787481037, "phrase": "theoretically_efficient_emulation"}, {"score": 0.0028616432465945097, "phrase": "parallel_algorithms_techniques"}, {"score": 0.002793380001054064, "phrase": "four-russians_technique"}, {"score": 0.002670884656785558, "phrase": "new_simplified_parallel_random_access_machine_string-matching_algorithm"}, {"score": 0.0025625729433234644, "phrase": "new_algorithm"}, {"score": 0.0025014259919355453, "phrase": "consecutive_non-overlapping_blocks"}, {"score": 0.002424942315592064, "phrase": "latter_problem"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["String matching", " Word-RAM", " Packed strings"], "paper_abstract": "In the packed string matching problem, it is assumed that each machine word can accommodate up to a characters, thus an n-character string occupies n/alpha memory words. (a) We extend the Crochemore-Perrin constant-space O(n)-time string-matching algorithm to run in optimal O(n/alpha) time and even in real-time, achieving a factor alpha speedup over traditional algorithms that examine each character individually. Our macro-level algorithm only uses the standard AC(0) instructions of the word-RAM model (i.e. no integer multiplication) plus two specialized micro-level AC(0) word-size packed-string instructions. The main word-size string-matching instruction WSSM is available in contemporary commodity processors. The other word-size maximum-suffix instruction WSLM is only required during the pattern pre-processing. Benchmarks show that our solution can be efficiently implemented, unlike some prior theoretical packed string matching work. (b) We also consider the complexity of the packed string matching problem in the classical word-RAM model in the absence of the specialized micro-level instructions WSSM and WSLM. We propose micro-level algorithms for the theoretically efficient emulation using parallel algorithms techniques to emulate WSSM and using the Four-Russians technique to emulate WSLM. Surprisingly, our bit-parallel emulation of WSSM also leads to a new simplified parallel random access machine string-matching algorithm. As a byproduct to facilitate our results we develop a new algorithm for finding the leftmost (most significant) 1 bits in consecutive non-overlapping blocks of uniform size inside a word. This latter problem is not known to be reducible to finding the rightmost 1, which can be easily solved, since we do not know how to reverse the bits of a word in O(1) time. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Towards optimal packed string matching", "paper_id": "WOS:000334007300013"}