{"auto_keywords": [{"score": 0.025500902621675058, "phrase": "otello"}, {"score": 0.00481495049065317, "phrase": "nested_task_parallelism"}, {"score": 0.004665381744060558, "phrase": "shared_data"}, {"score": 0.004507485711694584, "phrase": "parallel_programming"}, {"score": 0.0044305441225064345, "phrase": "large_body"}, {"score": 0.004379977556546879, "phrase": "isolated_task-parallelism"}, {"score": 0.004159446063902181, "phrase": "difficult_and_unresolved_challenge"}, {"score": 0.004053362743156545, "phrase": "programming_and_execution_model"}, {"score": 0.003961330917648707, "phrase": "arbitrarily_nested_parallel_tasks"}, {"score": 0.003904871008565975, "phrase": "heap_data"}, {"score": 0.0038271712887391015, "phrase": "additional_burden"}, {"score": 0.0036658196285881094, "phrase": "parallel_tasks"}, {"score": 0.0035620354052144656, "phrase": "underlying_compiler"}, {"score": 0.0035416325863738326, "phrase": "runtime_system"}, {"score": 0.003481120202034407, "phrase": "aida_execution_model"}, {"score": 0.0034512514926836667, "phrase": "delegated_isolation_mechanism"}, {"score": 0.003372844338742438, "phrase": "nested_parallelism"}, {"score": 0.0033439015405773093, "phrase": "basic_runtime_construct"}, {"score": 0.00332474745356724, "phrase": "aida"}, {"score": 0.0031845067058084583, "phrase": "shared_heap"}, {"score": 0.00307657476125683, "phrase": "assembly_b"}, {"score": 0.0029467742734417255, "phrase": "carefully_selected_assembly_c"}, {"score": 0.0027982016314450717, "phrase": "task_a"}, {"score": 0.0027189137945757866, "phrase": "nesting_relationship"}, {"score": 0.0026267205286767577, "phrase": "habanero_java"}, {"score": 0.002472822097373027, "phrase": "nested_task-parallel_benchmarks"}, {"score": 0.0024586427394152196, "phrase": "non-nested_transactional_benchmarks"}, {"score": 0.0024096506756019704, "phrase": "nested_task-parallel_bench-marks"}, {"score": 0.002361632539339945, "phrase": "hj_programs"}, {"score": 0.002301295044886946, "phrase": "relative_overhead"}, {"score": 0.002147809092768899, "phrase": "transactional_benchmarks"}, {"score": 0.0021232402128269906, "phrase": "lower_overhead"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_software_transactional_memory_system"}], "paper_keywords": ["Languages", " Design", " Isolation", " Programming abstractions", " Irregular parallelism", " Contention"], "paper_abstract": "Isolation-the property that a task can access shared data without interference from other tasks-is one of the most basic concerns in parallel programming. While there is a large body of past work on isolated task-parallelism, the integration of isolation, task-parallelism, and nesting of tasks has been a difficult and unresolved challenge. In this paper, we present a programming and execution model called Otello where isolation is extended to arbitrarily nested parallel tasks with irregular accesses to heap data. At the same time, no additional burden is imposed on the programmer, who only exposes parallelism by creating and synchronizing parallel tasks, leaving the job of ensuring isolation to the underlying compiler and runtime system. Otello extends our past work on Aida execution model and the delegated isolation mechanism [22] to the setting of nested parallelism. The basic runtime construct in Aida and Otello is an assembly: a task equipped with a region in the shared heap that it owns. When an assembly A conflicts with an assembly B, A transfers-or delegates-its code and owned region to a carefully selected assembly C in a way that will ensure isolation with B, leaving the responsibility of re-executing task A to C. The choice of C depends on the nesting relationship between A and B. We have implemented Otello on top of the Habanero Java (HJ) parallel programming language [8], and used this implementation to evaluate Otello on collections of nested task-parallel benchmarks and non-nested transactional benchmarks from past work. On the nested task-parallel bench-marks, Otello achieves scalability comparable to HJ programs without built-in isolation, and the relative overhead of Otello is lower than that of many published data-race detection algorithms that detect the isolation violations (but do not enforce isolation). For the transactional benchmarks, Otello incurs lower overhead than a state-of-the-art software transactional memory system (Deuce STM).", "paper_title": "Isolation for Nested Task Parallelism", "paper_id": "WOS:000327697300032"}