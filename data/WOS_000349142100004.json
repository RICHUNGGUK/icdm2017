{"auto_keywords": [{"score": 0.04379677900638105, "phrase": "existing_analyses"}, {"score": 0.0413925310461803, "phrase": "manual_effort"}, {"score": 0.00481495049065317, "phrase": "dynamic_analysis_techniques"}, {"score": 0.00468627326602559, "phrase": "potential_deadlocks"}, {"score": 0.004561019117546361, "phrase": "potential_deadlock"}, {"score": 0.004359625030298944, "phrase": "real_execution"}, {"score": 0.004320421465896323, "phrase": "significant_programmer_effort"}, {"score": 0.004243064277617193, "phrase": "empirical_evidence"}, {"score": 0.0038590090616766434, "phrase": "non-existent_defects"}, {"score": 0.0035898158129721003, "phrase": "subsequent_manual_effort"}, {"score": 0.0034311578789991363, "phrase": "novel_approach"}, {"score": 0.003400274964240732, "phrase": "deadlock_detection"}, {"score": 0.0033393377529146893, "phrase": "dynamic_analysis"}, {"score": 0.0032794890195334513, "phrase": "execution_traces"}, {"score": 0.0029689311901364797, "phrase": "observed_trace"}, {"score": 0.002915701586760994, "phrase": "real_deadlock"}, {"score": 0.002639595219785102, "phrase": "wolf"}, {"score": 0.002367875199095903, "phrase": "reported_defects"}, {"score": 0.0022427071130840647, "phrase": "manual_analysis"}, {"score": 0.0021049977753042253, "phrase": "practical_adoption"}], "paper_keywords": ["deadlock detection", " dynamic analysis", " concurrency"], "paper_abstract": "Dynamic analysis techniques have been proposed to detect potential deadlocks. Analyzing and comprehending each potential deadlock to determine whether the deadlock is feasible in a real execution requires significant programmer effort. Moreover, empirical evidence shows that existing analyses are quite imprecise. This imprecision of the analyses further void the manual effort invested in reasoning about non-existent defects. In this paper, we address the problems of imprecision of existing analyses and the subsequent manual effort necessary to reason about deadlocks. We propose a novel approach for deadlock detection by designing a dynamic analysis that intelligently leverages execution traces. To reduce the manual effort, we replay the program by making the execution follow a schedule derived based on the observed trace. For a real deadlock, its feasibility is automatically verified if the replay causes the execution to deadlock. We have implemented our approach as part of WOLF and have analyzed many large (upto 160KLoC) Java programs. Our experimental results show that we are able to identify 74% of the reported defects as true (or false) positives automatically leaving very few defects for manual analysis. The overhead of our approach is negligible making it a compelling tool for practical adoption.", "paper_title": "Trace Driven Dynamic Deadlock Detection and Reproduction", "paper_id": "WOS:000349142100004"}