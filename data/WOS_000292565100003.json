{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "dma_races"}, {"score": 0.004774937143916685, "phrase": "model_checking"}, {"score": 0.004695900553353526, "phrase": "modern_multicore_processors"}, {"score": 0.004598933498016774, "phrase": "cell_broadband_engine"}, {"score": 0.004541712637353326, "phrase": "high_performance"}, {"score": 0.004485200522202792, "phrase": "accelerator_cores"}, {"score": 0.004447915226010682, "phrase": "small_\"scratch-pad\"_memories"}, {"score": 0.004301834610818624, "phrase": "higher_programming_complexity"}, {"score": 0.00417793854311445, "phrase": "data_movement"}, {"score": 0.004143196873246147, "phrase": "direct_memory_access"}, {"score": 0.004057596233938867, "phrase": "asynchronous_dma_operations"}, {"score": 0.003875424718379985, "phrase": "nondeterministic_bugs"}, {"score": 0.0036553070575015344, "phrase": "dma_race_analysis"}, {"score": 0.0036248955128033084, "phrase": "c_programs"}, {"score": 0.0033905067962602515, "phrase": "memory_flow_controller"}, {"score": 0.0033482708495261864, "phrase": "instrumented_program"}, {"score": 0.003265365666305185, "phrase": "state-of-the-art_software_model_checkers"}, {"score": 0.0030797912111959137, "phrase": "buggy_programs"}, {"score": 0.003028727936200845, "phrase": "automatic_verification"}, {"score": 0.002966084234963723, "phrase": "instrumented_programs"}, {"score": 0.00290473242917264, "phrase": "new_formulation"}, {"score": 0.0027974705482714884, "phrase": "proof_rule"}, {"score": 0.0025838249689625775, "phrase": "large_set"}, {"score": 0.002519800066326798, "phrase": "ibm_cell_sdk"}, {"score": 0.002447101794397243, "phrase": "previously_unknown_bug"}, {"score": 0.002337066031028783, "phrase": "problem_class"}, {"score": 0.00223196703759329, "phrase": "software_verification"}, {"score": 0.0021049977753042253, "phrase": "heterogeneous_multicore_processors"}], "paper_keywords": ["Model checking", " k-induction", " DMA", " Multicore programming", " Cell BE"], "paper_abstract": "Modern multicore processors, such as the Cell Broadband Engine, achieve high performance by equipping accelerator cores with small \"scratch-pad\" memories. The price for increased performance is higher programming complexity - the programmer must manually orchestrate data movement using direct memory access (DMA) operations. Programming using asynchronous DMA operations is error-prone, and DMA races can lead to nondeterministic bugs which are hard to reproduce and fix. We present a method for DMA race analysis in C programs. Our method works by automatically instrumenting a program with assertions modeling the semantics of a memory flow controller. The instrumented program can then be analyzed using state-of-the-art software model checkers. We show that bounded model checking is effective for detecting DMA races in buggy programs. To enable automatic verification of the correctness of instrumented programs, we present a new formulation of k-induction geared towards software, as a proof rule operating on loops. Our techniques are implemented as a tool, Scratch, which we apply to a large set of programs supplied with the IBM Cell SDK, in which we discover a previously unknown bug. Our experimental results indicate that our k-induction method performs extremely well on this problem class. To our knowledge, this marks both the first application of k-induction to software verification, and the first example of software model checking in the context of heterogeneous multicore processors.", "paper_title": "Automatic analysis of DMA races using model checking and k-induction", "paper_id": "WOS:000292565100003"}