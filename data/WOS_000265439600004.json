{"auto_keywords": [{"score": 0.0391216418022585, "phrase": "linear_time"}, {"score": 0.00481495049065317, "phrase": "labelled_r-uniform_hypertrees"}, {"score": 0.004199247711875386, "phrase": "hypertree_share"}, {"score": 0.003975515793563278, "phrase": "r-uniform_hypertree"}, {"score": 0.0039322149318145845, "phrase": "exactly_r_vertices"}, {"score": 0.003826007045267751, "phrase": "r-uniform_hypertrees"}, {"score": 0.0034102660898135155, "phrase": "decoding_algorithm"}, {"score": 0.0032819448594643853, "phrase": "general_hypertrees"}, {"score": 0.002285527382381719, "phrase": "labelled_trees"}, {"score": 0.0021049977753042253, "phrase": "counting_scheme"}], "paper_keywords": ["Hypertree", " Prufer code", " Coding", " Counting", " r-uniform"], "paper_abstract": "We consider labelled r-uniform hypertrees, 2 <= r <= n, where n is the number of vertices in the hypertree. Any two hyperedges in a hypertree share at most one vertex and each hyperedge in an r-uniform hypertree contains exactly r vertices. We show that r-uniform hypertrees can be encoded in linear time using as little as n - 2 integers in the range [1, n]. The decoding algorithm also runs in linear time. For general hypertrees, we require codes of length n + p - 2 where p is the number of vertices belonging to more than one hyperedge in the given hypertree. Based on our coding technique, we show that there are at most n((n-2))- f (n, r)/(r-1)((r-2))*(n-1/r-1) distinct labelled r-uniform hypertrees, where f (n, r) is a lower bound on the number of labelled trees with maximum (vertex) degree exceeding (r - 1)+ n-1/r-1 - 2. We suggest a counting scheme for determining such a lower bound f (n, r).", "paper_title": "Efficient Prufer-Like Coding and Counting Labelled Hypertrees", "paper_id": "WOS:000265439600004"}