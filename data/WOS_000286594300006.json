{"auto_keywords": [{"score": 0.04180609886778986, "phrase": "felleisen"}, {"score": 0.00481495049065317, "phrase": "abstracting_abstract_machines"}, {"score": 0.004670896353428476, "phrase": "derivational_approach"}, {"score": 0.004614483128885678, "phrase": "abstract_interpretation"}, {"score": 0.004476399615305783, "phrase": "transparently_sound_static_analyses"}, {"score": 0.00436890075128947, "phrase": "well-established_abstract_machines"}, {"score": 0.004036968488559984, "phrase": "cek_machine"}, {"score": 0.003940064365063039, "phrase": "friedman"}, {"score": 0.0037988336463795963, "phrase": "krivine's_machine"}, {"score": 0.0037075456471849892, "phrase": "stack-inspecting_cm_machine"}, {"score": 0.0036627267513923934, "phrase": "clements"}, {"score": 0.003574695610710444, "phrase": "abstract_interpretations"}, {"score": 0.00342568771304873, "phrase": "bound_temporal_ordering"}, {"score": 0.003384262486955773, "phrase": "program_events"}, {"score": 0.0032828706086018133, "phrase": "stack-inspection_behavior"}, {"score": 0.003107935254560724, "phrase": "by-need_parameters"}, {"score": 0.0028541057064952876, "phrase": "well-known_concrete_machine_refactorings"}, {"score": 0.0025578967205807843, "phrase": "static_analyses"}, {"score": 0.002320449502337321, "phrase": "static_analysis"}, {"score": 0.0022923586577645143, "phrase": "realistic_language_features"}, {"score": 0.0022508572821818124, "phrase": "tail_calls"}, {"score": 0.0021966859554037174, "phrase": "side_effects"}, {"score": 0.0021438155673297377, "phrase": "first-class_continuations"}, {"score": 0.0021049977753042253, "phrase": "even_garbage_collection"}], "paper_keywords": ["Languages", " Theory", " abstract machines", " abstract interpretation"], "paper_abstract": "We describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well-established abstract machines. To demonstrate the technique and support our claim, we transform the CEK machine of Felleisen and Friedman, a lazy variant of Krivine's machine, and the stack-inspecting CM machine of Clements and Felleisen into abstract interpretations of themselves. The resulting analyses bound temporal ordering of program events; predict return-flow and stack-inspection behavior; and approximate the flow and evaluation of by-need parameters. For all of these machines, we find that a series of well-known concrete machine refactorings, plus a technique we call store-allocated continuations, leads to machines that abstract into static analyses simply by bounding their stores. We demonstrate that the technique scales up uniformly to allow static analysis of realistic language features, including tail calls, conditionals, side effects, exceptions, first-class continuations, and even garbage collection.", "paper_title": "Abstracting Abstract Machines", "paper_id": "WOS:000286594300006"}