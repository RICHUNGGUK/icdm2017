{"auto_keywords": [{"score": 0.040273620909837396, "phrase": "hood"}, {"score": 0.007651434783248021, "phrase": "abstract_machine"}, {"score": 0.00481495049065317, "phrase": "natural_semantics"}, {"score": 0.004654826737377134, "phrase": "side_effects"}, {"score": 0.00456571874088313, "phrase": "functional_programs"}, {"score": 0.004246428036409373, "phrase": "practical_debuggers"}, {"score": 0.0041450181887917135, "phrase": "lazy_functional_languages"}, {"score": 0.0038737214010638745, "phrase": "haskell_debuggers"}, {"score": 0.003637669525737665, "phrase": "intermediate_data_structures"}, {"score": 0.003131023880006021, "phrase": "complex_situations"}, {"score": 0.0026687841359431105, "phrase": "different_implementations"}, {"score": 0.00249386680748172, "phrase": "hood_debugger"}, {"score": 0.0024578987081792405, "phrase": "sestoft's_natural_semantics"}, {"score": 0.002177600561610171, "phrase": "formal_foundation"}, {"score": 0.0021049977753042253, "phrase": "alternative_method"}], "paper_keywords": ["Parallel functional programming", " debugging", " semantics", " abstract machines"], "paper_abstract": "Due to the absence of side effects, reasoning about functional programs is simpler than reasoning about their imperative counterparts. However, because of the absence of practical debuggers, finding bugs in lazy functional languages has been more complex until quite recently. One of the easiest to use Haskell debuggers is Hood. Its behavior is based on the concept of observation of intermediate data structures. However, although using Hood can be simple when observing some structures, it is known that it can be hard to understand how it works when dealing with complex situations. In fact, the author of Hood recognizes that it is necessary to formalize its behavior to explain better what should be expected, and also to allow to check whether the different implementations work properly. In this paper, we formalize the behavior of the Hood debugger by extending Sestoft's natural semantics. Moreover, we also show how to derive an abstract machine including such debugging information. By doing so, we do not only provide a formal foundation, but we also provide an alternative method to implement debuggers. In fact, we have already made a prototype of the abstract machine presented in this paper.", "paper_title": "A Debugging System Based on Natural Semantics", "paper_id": "WOS:000273177900005"}