{"auto_keywords": [{"score": 0.04719839762621183, "phrase": "scientific_workflow_systems"}, {"score": 0.043429710921929404, "phrase": "temporal_violations"}, {"score": 0.04291534293383106, "phrase": "temporal_violation_handling"}, {"score": 0.039317403151617226, "phrase": "temporal_violation"}, {"score": 0.00481495049065317, "phrase": "handle_every"}, {"score": 0.004620093797504386, "phrase": "overall_deadlines"}, {"score": 0.0045820747375409435, "phrase": "local_milestones"}, {"score": 0.00443308765153716, "phrase": "dynamic_nature"}, {"score": 0.004378469469879815, "phrase": "underlying_computing_infrastructures"}, {"score": 0.00418387341007444, "phrase": "large_number"}, {"score": 0.0039813976794342, "phrase": "monetary_costs"}, {"score": 0.003948613642680196, "phrase": "time_overheads"}, {"score": 0.00389994107619882, "phrase": "essential_question"}, {"score": 0.003531474887552889, "phrase": "existing_works"}, {"score": 0.003502382624110703, "phrase": "workflow_temporal_management"}, {"score": 0.003360464999544279, "phrase": "functional_exceptions"}, {"score": 0.0030177339185643226, "phrase": "execution_delays"}, {"score": 0.0029194625087935345, "phrase": "saved_execution_time"}, {"score": 0.0028953973490895746, "phrase": "subsequent_workflow_activities"}, {"score": 0.002778006389296707, "phrase": "nonfunctional_nature"}, {"score": 0.002373615081691254, "phrase": "unnecessary_temporal_violation_handling"}, {"score": 0.002305799666781492, "phrase": "real-world_scientific_workflows"}, {"score": 0.0022679195103377124, "phrase": "test_cases"}, {"score": 0.0022399174232611853, "phrase": "experimental_results"}, {"score": 0.0021049977753042253, "phrase": "extreme_low_violation_rate"}], "paper_keywords": ["Algorithms", " Performance", " Reliability", " Verification", " Scientific workflows", " temporal constraints", " temporal verification", " violation handling point selection", " quality of service"], "paper_abstract": "Scientific processes are usually time constrained with overall deadlines and local milestones. In scientific workflow systems, due to the dynamic nature of the underlying computing infrastructures such as grid and cloud, execution delays often take place and result in a large number of temporal violations. Since temporal violation handling is expensive in terms of both monetary costs and time overheads, an essential question aroused is \"do we need to handle every temporal violation in scientific workflow systems?\" The answer would be \"true\" according to existing works on workflow temporal management which adopt the philosophy similar to the handling of functional exceptions, that is, every temporal violation should be handled whenever it is detected. However, based on our observation, the phenomenon of self-recovery where execution delays can be automatically compensated for by the saved execution time of subsequent workflow activities has been entirely overlooked. Therefore, considering the nonfunctional nature of temporal violations, our answer is \"not necessarily true.\" To take advantage of self-recovery, this article proposes a novel adaptive temporal violation handling point selection strategy where this phenomenon is effectively utilised to avoid unnecessary temporal violation handling. Based on simulations of both real-world scientific workflows and randomly generated test cases, the experimental results demonstrate that our strategy can significantly reduce the cost on temporal violation handling by over 96% while maintaining extreme low violation rate under normal circumstances.", "paper_title": "Do We Need to Handle Every Temporal Violation in Scientific Workflow Systems?", "paper_id": "WOS:000331615400005"}