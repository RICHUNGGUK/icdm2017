{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "deadlock_potentials"}, {"score": 0.004774530554776604, "phrase": "multithreaded_programs"}, {"score": 0.004734448316824488, "phrase": "concurrent_programs"}, {"score": 0.004388464928134458, "phrase": "deadlock"}, {"score": 0.004333283735537634, "phrase": "common_concurrency_error"}, {"score": 0.003818210967854446, "phrase": "highly_scalable_static_and_dynamic_techniques"}, {"score": 0.003660452313567116, "phrase": "known_algorithm"}, {"score": 0.0035091888798162176, "phrase": "nested_fashion"}, {"score": 0.0034504423179340738, "phrase": "nesting_order"}, {"score": 0.003407026489727146, "phrase": "lock_graph"}, {"score": 0.0032800186243040663, "phrase": "deadlock_potential"}, {"score": 0.0031845067058084583, "phrase": "basic_algorithm"}, {"score": 0.0030657684627749364, "phrase": "possible_deadlocks"}, {"score": 0.0029764767329116875, "phrase": "false_positives"}, {"score": 0.0028174721236762317, "phrase": "gate_lock"}, {"score": 0.002471661547432869, "phrase": "multiple_runs"}, {"score": 0.0024097920845706795, "phrase": "single_lock_graph"}, {"score": 0.0021682027434117095, "phrase": "static_analysis"}, {"score": 0.0021049977753042253, "phrase": "dynamic_checking"}], "paper_keywords": [""], "paper_abstract": "Concurrent programs are well known for containing errors that are difficult to detect, reproduce, and diagnose. Deadlock is a common concurrency error, which occurs when a set of threads are blocked, due to each attempting to acquire a lock held by another. This paper presents a collection of highly scalable static and dynamic techniques for exposing potential deadlocks. The basis is a known algorithm, which, when locks are acquired in a nested fashion, captures the nesting order in a lock graph. A cycle in the graph indicates a deadlock potential. We propose three extensions to this basic algorithm to eliminate, or label as low severity, false warnings of possible deadlocks (false positives). These false positives may be due to cycles within one thread, cycles guarded by a gate lock (an enclosing lock that prevents deadlocks), and cycles involving several code fragments that cannot possibly execute in parallel. We also present a technique that combines information from multiple runs of the program into a single lock graph, to find deadlock potentials that would not be revealed by analyzing one run at a time. Finally, this paper describes the use of static analysis to automatically reduce the overhead of dynamic checking for deadlock potentials.", "paper_title": "Detection of deadlock potentials in multithreaded programs", "paper_id": "WOS:000208259400008"}