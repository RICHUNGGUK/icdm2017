{"auto_keywords": [{"score": 0.049040461120392176, "phrase": "central_node"}, {"score": 0.0468062661778198, "phrase": "time_reference"}, {"score": 0.044878538469718086, "phrase": "synchronisation_errors"}, {"score": 0.035644758920137035, "phrase": "dynamic_network"}, {"score": 0.03041522092743518, "phrase": "dynamic_networks"}, {"score": 0.025624802958192288, "phrase": "proposed_approach"}, {"score": 0.00481495049065317, "phrase": "dynamic_tree"}, {"score": 0.004779876533667754, "phrase": "reference_node"}, {"score": 0.004432007036873777, "phrase": "computer_nodes"}, {"score": 0.004367647793378872, "phrase": "main_goal"}, {"score": 0.004262443682087016, "phrase": "time_synchronisation_error"}, {"score": 0.00400057357306865, "phrase": "best_rn"}, {"score": 0.00394245456672012, "phrase": "minimal_sum"}, {"score": 0.003923269062268688, "phrase": "time_synchronisation_errors"}, {"score": 0.0038287275986210543, "phrase": "first_step"}, {"score": 0.003754731210715724, "phrase": "minimum_spanning_tree"}, {"score": 0.003664236168480626, "phrase": "minimum_synchronisation_error"}, {"score": 0.003637513820504055, "phrase": "synchronisation_path"}, {"score": 0.003610985645560791, "phrase": "second_step"}, {"score": 0.003356080141737706, "phrase": "communication_links"}, {"score": 0.003307293031735533, "phrase": "synchronisation_accuracy"}, {"score": 0.0032433414042726356, "phrase": "static_rn"}, {"score": 0.0032196786163178107, "phrase": "suboptimal_synchronisation_accuracy"}, {"score": 0.0031961879138783012, "phrase": "existing_models"}, {"score": 0.0031420385282097804, "phrase": "static_rns"}, {"score": 0.0031115076263594607, "phrase": "computing_cost"}, {"score": 0.003051330222508351, "phrase": "suboptimal_total_synchronisation_error"}, {"score": 0.002992313172550772, "phrase": "selected_node"}, {"score": 0.0028988281367834444, "phrase": "efficient_method"}, {"score": 0.0028847066125323893, "phrase": "dynamic_rn_selection"}, {"score": 0.002787758144742021, "phrase": "rn_computation"}, {"score": 0.00276066021951467, "phrase": "live_mode"}, {"score": 0.0027271569075160086, "phrase": "new_method"}, {"score": 0.0027006464509273806, "phrase": "altered_path"}, {"score": 0.002635537976182262, "phrase": "mst"}, {"score": 0.0025908145385980397, "phrase": "efficient_way"}, {"score": 0.002528300562452668, "phrase": "average_time_complexity"}, {"score": 0.002455266773537278, "phrase": "total_number"}, {"score": 0.0023785199683725353, "phrase": "huge_dynamic_network"}, {"score": 0.0023324855762635616, "phrase": "different_situations"}, {"score": 0.0023041665760356296, "phrase": "excellent_running_time"}, {"score": 0.002287340100992165, "phrase": "synchronisation_error"}, {"score": 0.0022321322970228308, "phrase": "synchronisation_purposes"}, {"score": 0.002194279858055054, "phrase": "efficient_incremental_algorithm"}, {"score": 0.0021782540930080137, "phrase": "hop_counts"}, {"score": 0.0021570679320000565, "phrase": "central_point"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": [""], "paper_abstract": "The reference node (RN) is a central node that has minimum distance/hop count to all other nodes in the network. This central node can play several critical roles such as being the time reference in order to synchronise computer nodes. For synchronisation, the main goal is to minimise the sum of synchronisation errors. The time synchronisation error, known for each link between two nodes, accumulates for each hop along the path used for synchronisation between two nodes. In such a context, the best RN is defined as having the minimal sum of time synchronisation errors between itself and every other node. Thus, the first step for error minimisation is to select a minimum spanning tree (MST), formed by the links with minimum synchronisation error, as synchronisation path. The second step is to select an RN, which minimises the sum of synchronisation errors to all nodes in the MST, as time reference for synchronisation. In a dynamic network, where communication links appear and disappear, and synchronisation accuracy improves as more packets are exchanged, a static RN would entail suboptimal synchronisation accuracy. All existing models in this area are limited to static RNs because of the computing cost of updating the RN, yielding a suboptimal total synchronisation error over time and causing problems if the selected node is removed from the dynamic network. This paper presents a novel and efficient method for dynamic RN selection in dynamic networks. The approach proposed in this paper improves the performance of RN computation and update in live mode for dynamic networks. This new method concentrates on the altered path with respect to the RN, each time the MST is updated. This provides an efficient way to find and maintain a RN incrementally in an average time complexity of O(log n) per update, which n is the total number of nodes in the network. The proposed approach was tested with a huge dynamic network containing 60000 simulated nodes, in a number of different situations. The proposed approach achieves excellent running time while minimising synchronisation error. Although this work is currently used for time synchronisation purposes, several dynamic network tools can benefit from an efficient incremental algorithm to calculate hop counts and select a central point for the network. Copyright (c) 2014 John Wiley & Sons, Ltd", "paper_title": "Reference node selection in dynamic tree", "paper_id": "WOS:000345204900003"}