{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "two-player_games"}, {"score": 0.004766683200410046, "phrase": "real_time"}, {"score": 0.00473477283457869, "phrase": "game_structures"}, {"score": 0.004563028873351776, "phrase": "parity_conditions"}, {"score": 0.004309725894724034, "phrase": "time_delay"}, {"score": 0.004167315942319306, "phrase": "shorter_delay"}, {"score": 0.0037297918570822876, "phrase": "zeno_run"}, {"score": 0.0036430378180975667, "phrase": "efficient_reduction"}, {"score": 0.00333804919565419, "phrase": "rich_class"}, {"score": 0.003293442130869165, "phrase": "classical_parity_games"}, {"score": 0.003227643104496149, "phrase": "timed_parity_games"}, {"score": 0.003163154491827937, "phrase": "resulting_game"}, {"score": 0.0031208772639433145, "phrase": "clock_regions"}, {"score": 0.0030895394261534776, "phrase": "original_game"}, {"score": 0.0030482430937467013, "phrase": "state_space"}, {"score": 0.0030176323936876317, "phrase": "finite_game"}, {"score": 0.002937493907103812, "phrase": "region_graph"}, {"score": 0.002764856305713066, "phrase": "real-time_synthesis_problem"}, {"score": 0.0026023381988430666, "phrase": "exact_real-valued_time_delay"}, {"score": 0.0025503112711036994, "phrase": "nonzero_jitter"}, {"score": 0.002297585503415527, "phrase": "bounded-robust_winning_strategies"}, {"score": 0.0022290085428279846, "phrase": "robust_strategies"}, {"score": 0.002199189123395672, "phrase": "efficient_reductions"}, {"score": 0.0021770860717929192, "phrase": "timed_automaton_games"}, {"score": 0.0021049977753042253, "phrase": "robust_real-time_controllers"}], "paper_keywords": ["Timed Automata", " Timed Parity Games", " Robust Timed Control"], "paper_abstract": "We consider two-player games played in real time on game structures with clocks where the objectives of players are described using parity conditions. The games are concurrent in that at each turn, both players independently propose a time delay and an action, and the action with the shorter delay is chosen. To prevent a player from winning by blocking time, we restrict each player to play strategies that ensure that the player cannot be responsible for causing a zeno run. First, we present an efficient reduction of these games to turn-based (i.e., not concurrent) finite-state (i.e., untimed) parity games. Our reduction improves the best known complexity for solving timed parity games. Moreover, the rich class of algorithms for classical parity games can now be applied to timed parity games. The states of the resulting game are based on clock regions of the original game, and the state space of the finite game is linear in the size of the region graph. Second, we consider two restricted classes of strategies for the player that represents the controller in a real-time synthesis problem, namely, limit-robust and bounded-robust winning strategies. Using a limit-robust winning strategy, the controller cannot choose an exact real-valued time delay but must allow for some nonzero jitter in each of its actions. If there is a given lower bound on the jitter, then the strategy is bounded-robust winning. We show that exact strategies are more powerful than limit-robust strategies, which are more powerful than bounded-robust winning strategies for any bound. For both kinds of robust strategies, we present efficient reductions to standard timed automaton games. These reductions provide algorithms for the synthesis of robust real-time controllers.", "paper_title": "TIMED PARITY GAMES: COMPLEXITY AND ROBUSTNESS", "paper_id": "WOS:000301228900001"}