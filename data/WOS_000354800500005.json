{"auto_keywords": [{"score": 0.04762443660575816, "phrase": "untrusted_program"}, {"score": 0.012668996127929514, "phrase": "enforcement_mechanism"}, {"score": 0.00481495049065317, "phrase": "runtime_enforcement_of_security_policies"}, {"score": 0.004778923541463994, "phrase": "black_box_reactive_programs"}, {"score": 0.004743164872278112, "phrase": "security_enforcement_mechanisms"}, {"score": 0.004707672504464783, "phrase": "execution_monitors"}, {"score": 0.004466519142879166, "phrase": "different_enforcement_mechanisms"}, {"score": 0.00443308765153716, "phrase": "different_strengths"}, {"score": 0.004174451361776433, "phrase": "paper_studies"}, {"score": 0.004143196873246147, "phrase": "enforcement_mechanisms"}, {"score": 0.004112175423546628, "phrase": "reactive_programs"}, {"score": 0.003785836059995376, "phrase": "finite_time"}, {"score": 0.0036052633308076933, "phrase": "ligatti's_edit_automata"}, {"score": 0.0034722233102219466, "phrase": "arbitrary_amount"}, {"score": 0.0032694619052789768, "phrase": "black_box"}, {"score": 0.003043957650600757, "phrase": "alternative_executions"}, {"score": 0.002976019715894587, "phrase": "additional_copies"}, {"score": 0.0028986672783671147, "phrase": "different_inputs"}, {"score": 0.0028021527740710508, "phrase": "machine_code"}, {"score": 0.002628506002255396, "phrase": "virtual_machine_monitors"}, {"score": 0.002569816610348772, "phrase": "shadow_executions"}, {"score": 0.002531418327080538, "phrase": "upper_and_lower_bounds"}, {"score": 0.0023834640793589435, "phrase": "generic_enforcement_mechanism"}, {"score": 0.0023390219342052623, "phrase": "wide_range"}, {"score": 0.002218933616777076, "phrase": "specific_classes"}], "paper_keywords": ["Security", " Runtime Enforcement", " Hypersafety Policy", " Black Box Mechanism", " Reactive Program"], "paper_abstract": "Security enforcement mechanisms like execution monitors are used to make sure that some untrusted program complies with a policy. Different enforcement mechanisms have different strengths and weaknesses and hence it is important to understand the qualities of various enforcement mechanisms. This paper studies runtime enforcement mechanisms for reactive programs. We study the impact of two important constraints that many practical enforcement mechanisms satisfy: (1) the enforcement mechanism must handle each input/output event in finite time and on occurrence of the event (as opposed to for instance Ligatti's edit automata that have the power to buffer events for an arbitrary amount of time), and (2) the enforcement mechanism treats the untrusted program as a black box: it can monitor and/or edit the input/output events that the program exhibits on execution and it can explore alternative executions of the program by running additional copies of the program and providing these different inputs. It can not inspect the source or machine code of the untrusted program. Such enforcement mechanisms are important in practice: they include for instance many execution monitors, virtual machine monitors, and secure multi-execution or shadow executions. We establish upper and lower bounds for the class of policies that are enforceable by such black box mechanisms, and we propose a generic enforcement mechanism that works for a wide range of policies. We also show how our generic enforcement mechanism can be instantiated to enforce specific classes of policies, at the same time showing that many existing enforcement mechanisms are optimized instances of our construction.", "paper_title": "Runtime Enforcement of Security Policies on Black Box Reactive Programs", "paper_id": "WOS:000354800500005"}