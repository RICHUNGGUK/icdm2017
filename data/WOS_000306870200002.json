{"auto_keywords": [{"score": 0.04204790475185292, "phrase": "v_-_s"}, {"score": 0.00481495049065317, "phrase": "optimally_efficient_sets"}, {"score": 0.004600389726895716, "phrase": "set_s_subset"}, {"score": 0.003267342521938321, "phrase": "exactly_one_vertex"}, {"score": 0.003193606324727067, "phrase": "set_s"}, {"score": 0.003051073364818384, "phrase": "vertex_v"}, {"score": 0.002690975370565776, "phrase": "vertex_u"}, {"score": 0.0024005409468262203, "phrase": "polynomial_time_self-stabilizing_algorithm"}, {"score": 0.0023463203637929466, "phrase": "optimally_efficient_set"}, {"score": 0.0023064582783867645, "phrase": "arbitrary_graph"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Self-stabilizing algorithms", " Graph algorithms", " Optimally efficient set"], "paper_abstract": "The efficiency of a set S subset of V in a graph G = (V, E), is defined as epsilon(S) = vertical bar{v is an element of V - S: vertical bar N(v) boolean AND S vertical bar = }vertical bar 1; in other words, the efficiency of a set S equals the number of vertices in V - S that are adjacent to exactly one vertex in S. A set S is called optimally efficient if for every vertex v is an element of V - S, epsilon(S boolean OR {v}) <= epsilon(S), and for every vertex u is an element of S, epsilon(S - {u}) < epsilon(S). We present a polynomial time self-stabilizing algorithm for finding an optimally efficient set in an arbitrary graph. This algorithm is designed using the distance-2 self-stabilizing model of computation. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "A self-stabilizing algorithm for optimally efficient sets in graphs", "paper_id": "WOS:000306870200002"}