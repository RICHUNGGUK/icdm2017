{"auto_keywords": [{"score": 0.04697928508658599, "phrase": "hartman"}, {"score": 0.01191731406574555, "phrase": "elias"}, {"score": 0.004814985173371182, "phrase": "transpositions"}, {"score": 0.004727995968069753, "phrase": "np-hard_problem"}, {"score": 0.004449292759128597, "phrase": "shamir"}, {"score": 0.003988205219327185, "phrase": "feng"}, {"score": 0.003822003373331997, "phrase": "data_structure"}, {"score": 0.0031079352545607267, "phrase": "running_time"}, {"score": 0.0028715299874549245, "phrase": "permutation_tree"}, {"score": 0.0027184540871935284, "phrase": "firoz_et_al"}, {"score": 0.002466139325703204, "phrase": "sufficient_extensions"}, {"score": 0.0021049977753042253, "phrase": "permutation_trees"}], "paper_keywords": ["approximation algorithms", " genome rearrangement", " sorting by transpositions"], "paper_abstract": "Sorting by Transpositions is an NP-hard problem for which several polynomial-time approximation algorithms have been developed. Hartman and Shamir (2006) developed a 1.5-approximation O(n(3/2)root log n) algorithm, whose running time was improved to O(nlogn) by Feng and Zhu (2007) with a data structure they defined, the permutation tree. Elias and Hartman (2006) developed a 1.375-approximation O(n(2)) algorithm, and Firoz et al. (2011) claimed an improvement to the running time, from O(n(2)) to O(nlogn), by using the permutation tree. We provide counter-examples to the correctness of Firoz et al.'s strategy, showing that it is not possible to reach a component by sufficient extensions using the method proposed by them. In addition, we propose a 1.375-approximation algorithm, modifying Elias and Hartman's approach with the use of permutation trees and achieving O(nlogn) time.", "paper_title": "A Faster 1.375-Approximation Algorithm for Sorting by Transpositions", "paper_id": "WOS:000364289700007"}