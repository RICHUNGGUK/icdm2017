{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "simd_instructions"}, {"score": 0.004732785510739708, "phrase": "maximum_efficiency"}, {"score": 0.004692227830462433, "phrase": "modern_embedded_processors"}, {"score": 0.004652016085325825, "phrase": "media_applications"}, {"score": 0.004612147352416241, "phrase": "single_instruction_multiple_data"}, {"score": 0.004572625016577781, "phrase": "simd"}, {"score": 0.004342430078306461, "phrase": "large_machine_word"}, {"score": 0.004001335931796133, "phrase": "systematic_usage"}, {"score": 0.003899269293218826, "phrase": "program_performance"}, {"score": 0.003799796252156605, "phrase": "dominant_language"}, {"score": 0.003767203575060969, "phrase": "programming_embedded_devices"}, {"score": 0.003686935223424015, "phrase": "clear_need"}, {"score": 0.0036553070575015344, "phrase": "c_compilers"}, {"score": 0.0034562118159899772, "phrase": "memory_access"}, {"score": 0.0033680032592969633, "phrase": "instruction's_data_access_size"}, {"score": 0.003310447652300423, "phrase": "important_problem"}, {"score": 0.003170811465728631, "phrase": "c_pointer"}, {"score": 0.0029980260560551982, "phrase": "machine_word"}, {"score": 0.0028468767420392945, "phrase": "analysis_method"}, {"score": 0.0027503564589458837, "phrase": "compile_time"}, {"score": 0.0027150087516999047, "phrase": "alignment_information"}, {"score": 0.002622947550220266, "phrase": "dynamic_alignment_checks"}, {"score": 0.0025014259919355453, "phrase": "interprocedural_analysis"}, {"score": 0.002469269628821745, "phrase": "pointer_alignment_information"}, {"score": 0.002448061472257196, "phrase": "function_bodies"}, {"score": 0.00241658945942583, "phrase": "function_calls"}, {"score": 0.0023245746777044766, "phrase": "experimental_results"}, {"score": 0.0022749744354271816, "phrase": "typical_programs"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["DSP", " SIMD", " vectorization", " alignment analysis", " static pointer analysis"], "paper_abstract": "To achieve maximum efficiency, modern embedded processors for media applications exploit single instruction multiple data (SIMD) instructions. SIMD instructions provide a form of vectorization where a large machine word is viewed as a vector of subwords and the same operation is performed on all subwords in parallel. Systematic usage of SIMD instructions can significantly improve program performance. With C becoming the dominant language for programming embedded devices, there is a clear need for C compilers that use SIMD instructions whenever appropriate. However, SIMD instructions typically require each memory access to be aligned with the instruction's data access size. Therefore an important problem in designing the compiler is to determine whether a C pointer is aligned, i.e. whether it refers to the beginning of a machine word. In this paper, we describe our SIMD generation algorithm and present an analysis method which determines the alignment of pointers at compile time. The alignment information is used to reduce the number of dynamic alignment checks and the overhead incurred by them. Our method uses an interprocedural analysis which propagates pointer alignment information in function bodies and through function calls. The effectiveness of our method is supported by experimental results which show that in typical programs the alignments of about 50% of the pointers can be statically determined. Copyright (c) 2006 John Wiley & Sons, Ltd.", "paper_title": "Compiler optimizations for processors with SIMD instructions", "paper_id": "WOS:000243511300004"}