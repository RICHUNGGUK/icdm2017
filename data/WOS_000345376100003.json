{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "runtime_enforcement"}, {"score": 0.010537510099484315, "phrase": "timed_properties"}, {"score": 0.007935257655222988, "phrase": "enforcement_mechanisms"}, {"score": 0.0046797114400479135, "phrase": "powerful_technique"}, {"score": 0.0045971138571344345, "phrase": "running_system"}, {"score": 0.004548253531664032, "phrase": "desired_properties"}, {"score": 0.004483909657713567, "phrase": "enforcement_monitor"}, {"score": 0.004330843494837881, "phrase": "output_sequences"}, {"score": 0.004205395707787349, "phrase": "output_sequence"}, {"score": 0.0039300808153474205, "phrase": "untimed_properties"}, {"score": 0.003685840071638243, "phrase": "events_matters"}, {"score": 0.0036207206487324506, "phrase": "new_enforcement_paradigm"}, {"score": 0.003493900927782043, "phrase": "correct_output_sequence"}, {"score": 0.0034690732089830045, "phrase": "additional_delays"}, {"score": 0.003371508176308189, "phrase": "input_sequence"}, {"score": 0.0032883848851259123, "phrase": "regular_timed_property"}, {"score": 0.0032418062548293745, "phrase": "timed_automaton"}, {"score": 0.002975826686621829, "phrase": "first_one"}, {"score": 0.0028511121935559072, "phrase": "required_property"}, {"score": 0.0028207566216121856, "phrase": "second_one"}, {"score": 0.0027610089418453614, "phrase": "input_sequences"}, {"score": 0.0027121844541913367, "phrase": "minimal_way"}, {"score": 0.002561658528837694, "phrase": "time_retardant"}, {"score": 0.002480680078868508, "phrase": "timed_events"}, {"score": 0.0021049977753042253, "phrase": "timed_context"}], "paper_keywords": ["Runtime verification", " Runtime enforcement", " Timed properties", " Timed automata", " Software engineering"], "paper_abstract": "Runtime enforcement is a powerful technique to ensure that a running system satisfies some desired properties. Using an enforcement monitor, an (untrustworthy) input execution (in the form of a sequence of events) is modified into an output sequence that complies with a property. Over the last decade, runtime enforcement has been mainly studied in the context of untimed properties. This paper deals with runtime enforcement of timed properties by revisiting the foundations of runtime enforcement when time between events matters. We propose a new enforcement paradigm where enforcement mechanisms are time retardants: to produce a correct output sequence, additional delays are introduced between the events of the input sequence. We consider runtime enforcement of any regular timed property defined by a timed automaton. We prove the correctness of enforcement mechanisms and prove that they enjoy two usually expected features, revisited here in the context of timed properties. The first one is soundness meaning that the output sequences (eventually) satisfy the required property. The second one is transparency, meaning that input sequences are modified in a minimal way. We also introduce two new features, (i) physical constraints that describe how a time retardant is physically constrained when delaying a sequence of timed events, and (ii) optimality, meaning that output sequences are produced as soon as possible. To facilitate the adoption and implementation of enforcement mechanisms, we describe them at several complementary abstraction levels. Our enforcement mechanisms have been implemented and our experimental results demonstrate the feasibility of runtime enforcement in a timed context and the effectiveness of the mechanisms.", "paper_title": "Runtime enforcement of timed properties revisited", "paper_id": "WOS:000345376100003"}