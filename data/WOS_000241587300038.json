{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "higher-order_store"}, {"score": 0.01480701900356661, "phrase": "local_reasoning"}, {"score": 0.012207066456518818, "phrase": "separation_logic"}, {"score": 0.004624751696958501, "phrase": "sub-structural_logic"}, {"score": 0.004471978831302331, "phrase": "imperative_programs"}, {"score": 0.0040978781692373005, "phrase": "heap_structures"}, {"score": 0.003510754567808717, "phrase": "basic_data_types"}, {"score": 0.0031738126998349775, "phrase": "code_pointers"}, {"score": 0.003110396267535254, "phrase": "corresponding_heap_model"}, {"score": 0.0027187231747900814, "phrase": "partial_functions"}, {"score": 0.0021049977753042253, "phrase": "frame_rule"}], "paper_keywords": [""], "paper_abstract": "Separation Logic is a sub-structural logic that supports local reasoning for imperative programs. It is designed to elegantly describe sharing and aliasing properties of heap structures, thus facilitating the verification of programs with pointers. In past work, separation logic has been developed for heaps containing records of basic data types. Languages like C or NIL, however, also permit the use of code pointers. The corresponding heap model is commonly referred to as \"higher-order store\" since heaps may contain commands which in turn are interpreted as partial functions between heaps. In this paper we make Separation Logic and the benefits of local reasoning available to languages with higher-order store. In particular, we introduce an extension of the logic and prove it sound, including the Frame Rule that enables specifications of code to be extended by invariants on parts of the heap that are not accessed.", "paper_title": "Separation logic for higher-order store", "paper_id": "WOS:000241587300038"}