{"auto_keywords": [{"score": 0.03017159981040381, "phrase": "vbi"}, {"score": 0.00481495049065317, "phrase": "vulnerability-based_parity_optimization"}, {"score": 0.004771210909302332, "phrase": "interleaving"}, {"score": 0.004663533386096864, "phrase": "technology-independent_vulnerability-driven_parity_selection_method"}, {"score": 0.004496280772084575, "phrase": "memory_arrays"}, {"score": 0.004455409162867219, "phrase": "multiple-bit_upsets"}, {"score": 0.00419861271409079, "phrase": "recent_technologies"}, {"score": 0.004085115444878828, "phrase": "physical_interleaving"}, {"score": 0.003956558420993431, "phrase": "out-of-core_memory_structures"}, {"score": 0.003711409222544974, "phrase": "high_performance"}, {"score": 0.003660879039645457, "phrase": "core_arrays"}, {"score": 0.0035945701438887282, "phrase": "computational_complexity"}, {"score": 0.003561865840737996, "phrase": "high_delay"}, {"score": 0.0034027387694902287, "phrase": "vulnerability-based_parity_forest_formation"}, {"score": 0.0032358709481309913, "phrase": "pipeline_flushing"}, {"score": 0.003091262582401731, "phrase": "optimal_parity_tree_construction"}, {"score": 0.003063123420705719, "phrase": "mbu"}, {"score": 0.0030076088903023034, "phrase": "computationally_complex_problem"}, {"score": 0.0029666322924554274, "phrase": "integer_linear_program_formulation"}, {"score": 0.0028731719610706214, "phrase": "vulnerability-based_interleaving"}, {"score": 0.0026949679939994226, "phrase": "core_array_resiliency"}, {"score": 0.0025162511343171, "phrase": "selective_parity"}, {"score": 0.0024593458703463474, "phrase": "experimental_results"}, {"score": 0.0024376194150391227, "phrase": "alpha"}, {"score": 0.0024037389168038515, "phrase": "intel"}, {"score": 0.002360132221690264, "phrase": "core_memory_arrays"}, {"score": 0.0023173287402646577, "phrase": "proposed_parity_tree_selection"}, {"score": 0.002254571365634257, "phrase": "vulnerability_reduction"}, {"score": 0.0021735249249471614, "phrase": "small_number"}, {"score": 0.0021049977753042253, "phrase": "parity_trees"}], "paper_keywords": ["Architectural vulnerability factor (AVF)", " interleaving", " memory array", " modern microprocessor", " optimization", " parity"], "paper_abstract": "We propose a technology-independent vulnerability-driven parity selection method for protecting modern microprocessor in-core memory arrays against multiple-bit upsets (MBUs). As MBUs constitute over 50% of the upsets in recent technologies, error correcting codes or physical interleaving are typically employed to effectively protect out-of-core memory structures, such as caches. Such methods, however, are not applicable to high performance in-core arrays, due to computational complexity, high delay, and area overhead. Therefore, we investigate vulnerability-based parity forest formation as an effective mechanism for detecting errors. Checkpointing and pipeline flushing can subsequently be used for correction. As the optimal parity tree construction for MBU detection is a computationally complex problem, an integer linear program formulation is introduced. In addition, vulnerability-based interleaving (VBI) is explored as a mechanism for further enhancing in-core array resiliency in constrained, single parity tree cases. VBI first physically disperses bitlines based on their vulnerability factor and then applies selective parity to these lines. Experimental results on Alpha 21264 and Intel P6 in-core memory arrays demonstrate that the proposed parity tree selection and VBI methods can achieve vulnerability reduction up to 86%, even when a small number of bits are added to the parity trees.", "paper_title": "Multiple-Bit Upset Protection in Microprocessor Memory Arrays Using Vulnerability-Based Parity Optimization and Interleaving", "paper_id": "WOS:000364209000009"}