{"auto_keywords": [{"score": 0.009162281761260624, "phrase": "clock_mesh_network"}, {"score": 0.00481495049065317, "phrase": "integrated_resource_allocation"}, {"score": 0.004723087356997716, "phrase": "clock_distribution_network"}, {"score": 0.0046928556063004214, "phrase": "synchronous_digital_circuit"}, {"score": 0.00466281645777963, "phrase": "clock_signal"}, {"score": 0.004632968695963776, "phrase": "storage_element"}, {"score": 0.0044865586700633744, "phrase": "continued_technology"}, {"score": 0.004326188427877999, "phrase": "performance_degradation_or_system_failure"}, {"score": 0.004243610490021034, "phrase": "clock-skew_variation"}, {"score": 0.00418046991987597, "phrase": "profound_interest"}, {"score": 0.004030996395461364, "phrase": "timing_variations"}, {"score": 0.0039966069041588205, "phrase": "significantly_high_power_consumption"}, {"score": 0.003945569806429253, "phrase": "excessive_mesh_wire_and_buffer_resources"}, {"score": 0.0038619465940310863, "phrase": "mesh_clock_synthesis"}, {"score": 0.0038289937665255294, "phrase": "variation_tolerance"}, {"score": 0.0037158492397920133, "phrase": "resulting_clock_mesh"}, {"score": 0.0036605323485683983, "phrase": "segment_allocation"}, {"score": 0.0036137713873827374, "phrase": "buffer_allocation"}, {"score": 0.003477029725200912, "phrase": "optimization_approaches"}, {"score": 0.003359816816853762, "phrase": "runtime_complexity"}, {"score": 0.0030837288356760973, "phrase": "economical_clock_mesh_network"}, {"score": 0.002960628694214367, "phrase": "integrated_fashion"}, {"score": 0.0029165216647792924, "phrase": "iterative_framework"}, {"score": 0.002904040426340639, "phrase": "incremental_updates"}, {"score": 0.002854645802851, "phrase": "globally_optimal_allocation"}, {"score": 0.002842428606954139, "phrase": "mesh_resources"}, {"score": 0.0028060889647071787, "phrase": "clock-skew_tolerance_constraints"}, {"score": 0.0027465495490291746, "phrase": "precise_analysis"}, {"score": 0.0027114323601885666, "phrase": "resource_optimization_tasks"}, {"score": 0.002665305036900055, "phrase": "effective_and_efficient_integration"}, {"score": 0.0026031552074693284, "phrase": "runtime_problem"}, {"score": 0.002564360070426064, "phrase": "speedup_techniques"}, {"score": 0.0025261416376566835, "phrase": "rc_circuit"}, {"score": 0.0025099367332615794, "phrase": "redundant_matrix_multiplications"}, {"score": 0.0024884913795612707, "phrase": "sliding-window_scheme"}, {"score": 0.0024566655761509276, "phrase": "buffer_sizing_effect"}, {"score": 0.002414861891567233, "phrase": "fast_clock-skew_estimation"}, {"score": 0.0023585381082363967, "phrase": "early_decision_policies"}, {"score": 0.0023434058350520763, "phrase": "extensive_experiments"}, {"score": 0.0023333715029833007, "phrase": "benchmark_circuits"}, {"score": 0.002274059352027924, "phrase": "worst-case_clock_skew"}, {"score": 0.0022305645366398914, "phrase": "mesh_driving_buffers"}, {"score": 0.00218789980093445, "phrase": "short-circuit_power"}, {"score": 0.0021049977753042253, "phrase": "best-known_clock_mesh_synthesis_method"}], "paper_keywords": ["Algorithms", " Performance", " Reliability", " Clock mesh", " variation tolerance", " synthesis", " resource allocation", " resource binding"], "paper_abstract": "The clock distribution network in a synchronous digital circuit delivers a clock signal to every storage element, that is, clock sink in the circuit. However, since the continued technology scaling increases PVT (process-voltage-temperature) variation, the increase of clock-skew variation is highly likely to cause performance degradation or system failure at runtime. Recently, to mitigate the clock-skew variation, many researchers have taken a profound interest in the clock mesh network. However, though the structure of the clock mesh network is excellent in tolerating timing variations, it demands significantly high power consumption due to the use of excessive mesh wire and buffer resources. Thus, optimizing the resources required in the mesh clock synthesis while maintaining the variation tolerance is crucially important. The three major tasks that greatly affect the cost of the resulting clock mesh are: (1) mesh segment allocation, (2) mesh buffer allocation and sizing, and (3) clock sink binding to mesh segments. Previous clock mesh optimization approaches solve the three tasks sequentially, one by one at a time, to manage the runtime complexity of the tasks at the expense of losing the quality of results. However, since the three tasks are tightly interrelated, simultaneously optimizing all three tasks is essential, if the runtime is ever permitted, to synthesize an economical clock mesh network. In this work, we propose an approach that is able to tackle the problem in an integrated fashion by combining the three tasks into an iterative framework of incremental updates and solving them simultaneously to find a globally optimal allocation of mesh resources while taking into account the clock-skew tolerance constraints. The core parts of this work are a precise analysis on the relation among the resource optimization tasks and an establishment of a mechanism for effective and efficient integration of the tasks. In particular, to handle the runtime problem, we propose a set of speedup techniques, that is, modeling the RC circuit for eliminating redundant matrix multiplications, exploiting a sliding-window scheme, and quickly estimating the buffer sizing effect, which are fitted into our context of fast clock-skew estimation in mesh resource optimization as well as an invention of early decision policies. Through extensive experiments with benchmark circuits, it is shown that our proposed clock mesh synthesizer is able to reduce the worst-case clock skew, total mesh wirelength, total size of mesh driving buffers, and total clock mesh power consumption including short-circuit power by 25.0%, 13.2%, 10.9%, and 11.0% on average compared to that produced by the best-known clock mesh synthesis method (MeshWorks), respectively.", "paper_title": "Integrated Resource Allocation and Binding in Clock Mesh Synthesis", "paper_id": "WOS:000337808000009"}