{"auto_keywords": [{"score": 0.03470635444778384, "phrase": "kanalyze"}, {"score": 0.00481495335120205, "phrase": "k-mer"}, {"score": 0.004662427600500598, "phrase": "nucleotide_sequences"}, {"score": 0.004612662942073808, "phrase": "short_overlapping_fragments"}, {"score": 0.004563427013973105, "phrase": "uniform_length"}, {"score": 0.00441883624011048, "phrase": "common_step"}, {"score": 0.004301834610818624, "phrase": "existing_software_packages"}, {"score": 0.0040334640350288, "phrase": "application_programming_interface"}, {"score": 0.00399045750657307, "phrase": "api"}, {"score": 0.0039055990919333082, "phrase": "graphical_interface"}, {"score": 0.0035457302646174148, "phrase": "fastest_k-mer_counters"}, {"score": 0.003470358620464986, "phrase": "reliable_output"}, {"score": 0.0033965836912510385, "phrase": "future_development_efforts"}, {"score": 0.00323625520042892, "phrase": "k-mer_counts"}, {"score": 0.0031845067058084583, "phrase": "sorted_tab-delimited_file"}, {"score": 0.002953711377604328, "phrase": "large_datasets"}, {"score": 0.002724909017963099, "phrase": "command_line_interface"}, {"score": 0.0026957697563293513, "phrase": "cli"}, {"score": 0.002460295872115956, "phrase": "k-mer_counter"}, {"score": 0.002407946228120838, "phrase": "jellyfish"}, {"score": 0.0023821830434655913, "phrase": "dsk"}, {"score": 0.002306554129273339, "phrase": "perl"}, {"score": 0.0022819188084383236, "phrase": "linux"}, {"score": 0.002233301265743633, "phrase": "extensive_unit"}, {"score": 0.002209406458446019, "phrase": "system_testing"}, {"score": 0.0021049977753042253, "phrase": "correct_k-mer_counts"}], "paper_keywords": [""], "paper_abstract": "Motivation: Converting nucleotide sequences into short overlapping fragments of uniform length, k-mers, is a common step in many bioinformatics applications. While existing software packages count k-mers, few are optimized for speed, offer an application programming interface (API), a graphical interface or contain features that make it extensible and maintainable. We designed KAnalyze to compete with the fastest k-mer counters, to produce reliable output and to support future development efforts through well-architected, documented and testable code. Currently, KAnalyze can output k-mer counts in a sorted tab-delimited file or stream k-mers as they are read. KAnalyze can process large datasets with 2 GB of memory. This project is implemented in Java 7, and the command line interface (CLI) is designed to integrate into pipelines written in any language. Results: As a k-mer counter, KAnalyze outperforms Jellyfish, DSK and a pipeline built on Perl and Linux utilities. Through extensive unit and system testing, we have verified that KAnalyze produces the correct k-mer counts over multiple datasets and k-mer sizes.", "paper_title": "KAnalyze: a fast versatile pipelined K-mer toolkit", "paper_id": "WOS:000339814300018"}