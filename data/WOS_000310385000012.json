{"auto_keywords": [{"score": 0.049118287236398724, "phrase": "utility-directed_transformations"}, {"score": 0.04224783721680549, "phrase": "multiple_utility-directed_transformations"}, {"score": 0.03756970211925783, "phrase": "compile_time"}, {"score": 0.00481495049065317, "phrase": "optimizing_hardware_design"}, {"score": 0.004766388573192505, "phrase": "composing_utility-directed_transformations"}, {"score": 0.004220314322073171, "phrase": "linear_programming"}, {"score": 0.004177724522109952, "phrase": "geometric_programming"}, {"score": 0.004073113268289532, "phrase": "systematic_approach"}, {"score": 0.003911135156992, "phrase": "sequential_design"}, {"score": 0.0038520615699124123, "phrase": "customizable_parallel_computing_platform"}, {"score": 0.0037746771370555546, "phrase": "field-programmable_gate_array"}, {"score": 0.003606178185661875, "phrase": "automatic_design_optimization"}, {"score": 0.0035337158050484474, "phrase": "design_goals"}, {"score": 0.0034277338119963886, "phrase": "design_transformations"}, {"score": 0.0033759367489122716, "phrase": "utility-directed_transformation"}, {"score": 0.003291336101694653, "phrase": "overall_goal"}, {"score": 0.00317643367669255, "phrase": "pattern-directed_transformations"}, {"score": 0.0030655302236416502, "phrase": "overall_design_requirements"}, {"score": 0.002943502888225748, "phrase": "performance-optimized_designs"}, {"score": 0.0028990018343924683, "phrase": "data_reuse"}, {"score": 0.0028697761128032282, "phrase": "mapreduce"}, {"score": 0.002769483748975581, "phrase": "parallel_computing_platform"}, {"score": 0.002618995204424126, "phrase": "different_orders"}, {"score": 0.00248927752933113, "phrase": "design_performance"}, {"score": 0.0023066199295447686, "phrase": "system_performance"}, {"score": 0.002148226022654619, "phrase": "original_design"}, {"score": 0.0021049977753042253, "phrase": "target_hardware_platform"}], "paper_keywords": ["Design optimization", " data reuse", " MapReduce", " pipelining", " geometric programming"], "paper_abstract": "Utility-directed transformations involve changing a design to optimize for given constraints while preserving behavior. These changes are often achieved by techniques such as linear programming or geometric programming. We present a systematic approach composing multiple utility-directed transformations for optimizing and mapping a sequential design onto a customizable parallel computing platform such as a Field-Programmable Gate Array (FPGA). Our aim is to enable automatic design optimization at compile time. Design goals specified by users drive the design transformations. Each utility-directed transformation achieves part of the overall goal, and multiple utility-directed transformations, connected by pattern-directed transformations, are composed to fulfill the overall design requirements. The utility-directed transformations in this work produce performance-optimized designs by exploiting data reuse, MapReduce, and pipelining for the target parallel computing platform. Moreover, it is shown that performing transformations in different orders allows users to trade speed for resources, and design performance for compile time. Several applications are used to evaluate this approach on FPGAs. The system performance of a 64-bit matrix multiplication is shown to improve up to 98 times compared to the original design, in the target hardware platform.", "paper_title": "Optimizing Hardware Design by Composing Utility-Directed Transformations", "paper_id": "WOS:000310385000012"}