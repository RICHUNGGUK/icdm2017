{"auto_keywords": [{"score": 0.04427688803338459, "phrase": "parikh_vector_q"}, {"score": 0.0431313759871099, "phrase": "substring_t"}, {"score": 0.00481495049065317, "phrase": "approximate_jumbled_pattern_matching"}, {"score": 0.004630939008669291, "phrase": "parikh"}, {"score": 0.004184526032558792, "phrase": "text_s"}, {"score": 0.0037079710789139305, "phrase": "jumbled_pattern_matching"}, {"score": 0.0036080776793146843, "phrase": "approximate_version"}, {"score": 0.0035108659422301985, "phrase": "string_s"}, {"score": 0.003324203391715804, "phrase": "maximal_occurrences"}, {"score": 0.0030745737579268876, "phrase": "approximate_parikh_vector_search"}, {"score": 0.0028996963188373144, "phrase": "wavelet_tree"}, {"score": 0.002745438358145758, "phrase": "preprocessing_phase"}, {"score": 0.002681859084438076, "phrase": "scrabble-like_variation"}, {"score": 0.002599365215003002, "phrase": "weight_function"}, {"score": 0.0023946630984825207, "phrase": "maximum_weight"}, {"score": 0.00228499525153, "phrase": "binary_alphabet"}, {"score": 0.002206045784326466, "phrase": "decision_version"}, {"score": 0.002163367190715979, "phrase": "constant_time"}, {"score": 0.0021049977753042253, "phrase": "subquadratic_time"}], "paper_keywords": ["String algorithms", " Pattern matching", " Parikh vectors", " Average case analysis", " Approximate search", " Permuted strings"], "paper_abstract": "Given a string s, the Parikh vector of s, denoted p(s), counts the multiplicity of each character in s. Searching for a match of a Parikh vector q in the text s requires finding a substring t of s with p(t) = q. This can be viewed as the task of finding a jumbled (permuted) version of a query pattern, hence the term Jumbled Pattern Matching. We present several algorithms for the approximate version of the problem: Given a string s and two Parikh vectors u, v (the query bounds), find all maximal occurrences in s of some Parikh vector q such that u <= q <= v. This definition encompasses several natural versions of approximate Parikh vector search. We present an algorithm solving this problem in sub-linear expected time using a wavelet tree of s, which can be computed in time O(n) in a preprocessing phase. We then discuss a Scrabble-like variation of the problem, in which a weight function on the letters of s is given and one has to find all occurrences in s of a substring t with maximum weight having Parikh vector p(t) <= v. For the case of a binary alphabet, we present an algorithm which solves the decision version of the Approximate Jumbled Pattern Matching problem in constant time, by indexing the string in subquadratic time.", "paper_title": "On Approximate Jumbled Pattern Matching in Strings", "paper_id": "WOS:000299091300004"}