{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "program_analyses"}, {"score": 0.048824896279579914, "phrase": "static_analysis"}, {"score": 0.03326171377608873, "phrase": "boolean_tests"}, {"score": 0.0313852091624045, "phrase": "proof_system"}, {"score": 0.02885449335457636, "phrase": "second_layer"}, {"score": 0.0044169318855693356, "phrase": "program_behavior"}, {"score": 0.003958591403140206, "phrase": "static_analyses"}, {"score": 0.003893406207928709, "phrase": "completeness_class"}, {"score": 0.00361906209437624, "phrase": "nontrivial_abstraction"}, {"score": 0.003477628306017313, "phrase": "stratified_deductive_system"}, {"score": 0.003352825186671963, "phrase": "abstract_domain_a."}, {"score": 0.0032757395605609923, "phrase": "deductive_system"}, {"score": 0.003106112985011102, "phrase": "common_belief"}, {"score": 0.002994602527726632, "phrase": "first_layer"}, {"score": 0.002848947756758754, "phrase": "program_composition"}, {"score": 0.002701361707441567, "phrase": "instead_abstraction-specific"}, {"score": 0.0026480044868438875, "phrase": "abstract_domain_a"}, {"score": 0.0024941578231560055, "phrase": "suitable_static_analysis"}, {"score": 0.002453027723284009, "phrase": "completeness_proof"}, {"score": 0.00234142781099973, "phrase": "generic_nonrelational_abstraction"}, {"score": 0.0022951636331743066, "phrase": "sound_rule"}, {"score": 0.002190729937598138, "phrase": "numerical_abstract_domains"}, {"score": 0.002161777099230501, "phrase": "octagons"}, {"score": 0.0021403049512708494, "phrase": "necessary_and_sufficient_conditions"}], "paper_keywords": ["Abstract interpretation", " abstract domain", " Languages"], "paper_abstract": "We want to prove that a static analysis of a given program is complete, namely, no imprecision arises when asking some query on the program behavior in the concrete (i.e., for its concrete semantics) or in the abstract (i.e., for its abstract interpretation). Completeness proofs are therefore useful to assign confidence to alarms raised by static analyses. We introduce the completeness class of an abstraction as the set of all programs for which the abstraction is complete. Our first result shows that for any nontrivial abstraction, its completeness class is not recursively enumerable. We then introduce a stratified deductive system (proves)A to prove the completeness of program analyses over an abstract domain A. We prove the soundness of the deductive system. We observe that the only sources of incompleteness are assignments and Boolean tests - unlikely a common belief in static analysis, joins do not induce incompleteness. The first layer of this proof system is generic, abstraction-agnostic, and it deals with the standard constructs for program composition, that is, sequential composition, branching and guarded iteration. The second layer is instead abstraction-specific: the designer of an abstract domain A provides conditions for completeness in A of assignments and Boolean tests which have to be checked by a suitable static analysis or assumed in the completeness proof as hypotheses. We instantiate the second layer of this proof system first with a generic nonrelational abstraction in order to provide a sound rule for the completeness of assignments. Orthogonally, we instantiate it to the numerical abstract domains of Intervals and Octagons, providing necessary and sufficient conditions for the completeness of their Boolean tests and of assignments for Octagons.", "paper_title": "Analyzing Program Analyses", "paper_id": "WOS:000354800500021"}