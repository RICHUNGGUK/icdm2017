{"auto_keywords": [{"score": 0.033215478942437204, "phrase": "template_constructors"}, {"score": 0.00481495049065317, "phrase": "template_constructors_for_reusable_object_initialization"}, {"score": 0.004530552828603269, "phrase": "object_initialization_logic"}, {"score": 0.004300133642951283, "phrase": "mainstream_object-oriented_languages"}, {"score": 0.004081385289516914, "phrase": "significant_amount"}, {"score": 0.004010960493946656, "phrase": "boilerplate_code"}, {"score": 0.0034291991359158827, "phrase": "initialization_interface"}, {"score": 0.00303553181618577, "phrase": "template_parameters"}, {"score": 0.0029830992938695007, "phrase": "pattern_matching"}, {"score": 0.002831158147480665, "phrase": "superclass_constructors"}, {"score": 0.0027341763737751467, "phrase": "one-to-many_binding"}, {"score": 0.002462664392109308, "phrase": "aforementioned_problems"}, {"score": 0.002237477619351199, "phrase": "java-based_implementation"}], "paper_keywords": ["Languages", " Theory", " constructors", " object initialization", " reusability", " mixins"], "paper_abstract": "Reuse of and abstraction over object initialization logic is not properly supported in mainstream object-oriented languages. This may result in significant amount of boilerplate code and proliferation of constructors in subclasses. It also makes it impossible for mixins to extend the initialization interface of classes they are applied to. We propose template constructors, which employ template parameters and pattern matching of them against signatures of superclass constructors to enable a one-to-many binding of super-calls. We demonstrate how template constructors solve the aforementioned problems. We present a formalization of the concept, a Java-based implementation, and use cases which exercise its strengths.", "paper_title": "Template Constructors for Reusable Object Initialization", "paper_id": "WOS:000338625500006"}