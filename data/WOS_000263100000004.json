{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "exe"}, {"score": 0.007388739222479912, "phrase": "real_code"}, {"score": 0.004699376587957438, "phrase": "current_path_constraints"}, {"score": 0.0045346863560033175, "phrase": "running_code_on_manually_or_randomly_constructed_input"}, {"score": 0.004313581307559327, "phrase": "checked_code_runs"}, {"score": 0.003981928669805484, "phrase": "symbolic_value"}, {"score": 0.0036269721030245507, "phrase": "symbolic_expression"}, {"score": 0.0036028592508983402, "phrase": "exe_forks_execution"}, {"score": 0.0034846700528752368, "phrase": "true_branch"}, {"score": 0.0033479323773364716, "phrase": "possible_values"}, {"score": 0.003238078694483823, "phrase": "traditional_runtime_tool"}, {"score": 0.00312138530097218, "phrase": "feasible_program_path"}, {"score": 0.0030595112110658675, "phrase": "dangerous_operations"}, {"score": 0.0027131212233443137, "phrase": "test_case"}, {"score": 0.0026504553106526016, "phrase": "concrete_values"}, {"score": 0.002520990102833368, "phrase": "concrete_input"}, {"score": 0.0024958641143547856, "phrase": "uninstrumented_version"}, {"score": 0.002470987929071079, "phrase": "checked_code"}, {"score": 0.00235813005446246, "phrase": "deterministic_code"}, {"score": 0.0022057677637040396, "phrase": "bsd_and_linux_packet_filter_implementations"}, {"score": 0.002176495491786737, "phrase": "dhcp"}], "paper_keywords": ["Reliability", " Languages", " bug finding", " test case generation", " constraint solving", " symbolic execution", " dynamic analysis", " attack generation"], "paper_abstract": "This article presents EXE, an effective bug-finding tool that automatically generates inputs that crash real code. Instead of running code on manually or randomly constructed input, EXE runs it on symbolic input initially allowed to be anything. As checked code runs, EXE tracks the constraints on each symbolic (i.e., input-derived) memory location. If a statement uses a symbolic value, EXE does not run it, but instead adds it as an input-constraint; all other statements run as usual. If code conditionally checks a symbolic expression, EXE forks execution, constraining the expression to be true on the true branch and false on the other. Because EXE reasons about all possible values on a path, it has much more power than a traditional runtime tool: (1) it can force execution down any feasible program path and (2) at dangerous operations ( e. g., a pointer dereference), it detects if the current path constraints allow any value that causes a bug. When a path terminates or hits a bug, EXE automatically generates a test case by solving the current path constraints to find concrete values using its own co-designed constraint solver, STP. Because EXE's constraints have no approximations, feeding this concrete input to an uninstrumented version of the checked code will cause it to follow the same path and hit the same bug (assuming deterministic code). EXE works well on real code, finding bugs along with inputs that trigger them in: the BSD and Linux packet filter implementations, the udhcpd DHCP server, the pcre regular expression library, and three Linux file systems.", "paper_title": "EXE: Automatically Generating Inputs of Death", "paper_id": "WOS:000263100000004"}