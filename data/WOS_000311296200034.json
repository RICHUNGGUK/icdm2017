{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "javascript"}, {"score": 0.0430504450726834, "phrase": "djs"}, {"score": 0.0046394362688524475, "phrase": "dependent_javascript"}, {"score": 0.003817306032290766, "phrase": "run-time_type-tests"}, {"score": 0.00357689487273538, "phrase": "extensible_objects"}, {"score": 0.0035110198699787013, "phrase": "prototype_inheritance"}, {"score": 0.0032593915869553714, "phrase": "nested_refinement_types"}, {"score": 0.0029152570900178956, "phrase": "precisely_track"}, {"score": 0.0028882701690741467, "phrase": "prototype_hierarchies"}, {"score": 0.002607362103727335, "phrase": "type_system"}, {"score": 0.002375714262344562, "phrase": "tricky_idioms"}, {"score": 0.0023103100997344072, "phrase": "small_examples"}, {"score": 0.002164602220179823, "phrase": "popular_book"}], "paper_keywords": ["Refinement Types", " JavaScript", " Strong Updates", " Prototype Inheritance", " Arrays"], "paper_abstract": "We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.", "paper_title": "Dependent Types for JavaScript", "paper_id": "WOS:000311296200034"}