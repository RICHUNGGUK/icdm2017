{"auto_keywords": [{"score": 0.04174666335988992, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "java_memory_model_safe"}, {"score": 0.004502943680955863, "phrase": "machine-checked_formalisation"}, {"score": 0.004354572391793908, "phrase": "java_memory_model"}, {"score": 0.004072275820209647, "phrase": "operational_semantics"}, {"score": 0.0036826452656927877, "phrase": "whole_model"}, {"score": 0.0034824716857663114, "phrase": "data_race_freedom_guarantee"}, {"score": 0.0031845067058084583, "phrase": "previous_formalisations"}, {"score": 0.0031140747752837826, "phrase": "dynamic_memory_allocation"}, {"score": 0.0028795712616923462, "phrase": "infinite_executions"}, {"score": 0.002784540221128404, "phrase": "wait-notify_mechanism"}, {"score": 0.00269263690712392, "phrase": "thread_interruption"}, {"score": 0.0024897902536499005, "phrase": "subtle_ways"}, {"score": 0.0024075916292945715, "phrase": "memory_model"}, {"score": 0.002251227801482381, "phrase": "numerous_clarifications"}, {"score": 0.0021049977753042253, "phrase": "existing_jmm_specification"}], "paper_keywords": ["Languages", " Theory", " Data race freedom", " Java memory model", " operational semantics", " type safety"], "paper_abstract": "This work presents a machine-checked formalisation of the Java memory model and connects it to an operational semantics for Java and Java bytecode. For the whole model, I prove the data race freedom guarantee and type safety. The model extends previous formalisations by dynamic memory allocation, thread spawns and joins, infinite executions, the wait-notify mechanism, and thread interruption, all of which interact in subtle ways with the memory model. The formalisation resulted in numerous clarifications of and fixes to the existing JMM specification.", "paper_title": "Making the Java Memory Model Safe", "paper_id": "WOS:000329182700001"}