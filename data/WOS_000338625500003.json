{"auto_keywords": [{"score": 0.004688321299229397, "phrase": "extensible_programming_language"}, {"score": 0.004327981760540394, "phrase": "different_times"}, {"score": 0.004103212598803194, "phrase": "compile_time"}, {"score": 0.003959863717046575, "phrase": "module_system"}, {"score": 0.0038556354709511818, "phrase": "racket_programming_language"}, {"score": 0.0032272929113113203, "phrase": "compile-time_phases"}, {"score": 0.0030868583963299698, "phrase": "language_model"}, {"score": 0.0029789104204803137, "phrase": "racket's_module_system"}, {"score": 0.002874726518572154, "phrase": "phase-separation_facet"}, {"score": 0.0027989800906333805, "phrase": "language_extensible"}, {"score": 0.002515384834484012, "phrase": "new_phases"}, {"score": 0.002405853977978678, "phrase": "test_time"}, {"score": 0.0021620042653528846, "phrase": "code-management_benefits"}, {"score": 0.0021049977753042253, "phrase": "built-in_distinction"}], "paper_keywords": ["Macros", " modules", " language tower"], "paper_abstract": "In an extensible programming language, programmers write code that must run at different times-in particular, at compile time versus run time. The module system of the Racket programming language enables a programmer to reason about programs in the face of such extensibility, because the distinction between runtime and compile-time phases is built into the language model. Submodules extend Racket's module system to make the phase-separation facet of the language extensible. That is, submodules give programmers the capability to define new phases, such as \"test time\" or \"documentation time,\" with the same reasoning and code-management benefits as the built-in distinction between run time and compile time.", "paper_title": "Submodules in Racket You Want it When, Again?", "paper_id": "WOS:000338625500003"}