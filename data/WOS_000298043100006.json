{"auto_keywords": [{"score": 0.045184180069738025, "phrase": "outgoing_radiance"}, {"score": 0.04304998969990581, "phrase": "local_illumination_equation"}, {"score": 0.00481495049065317, "phrase": "nonlinear_prefiltering_methods"}, {"score": 0.004655924035639928, "phrase": "complex_surface"}, {"score": 0.004280861452668641, "phrase": "pixel_footprint"}, {"score": 0.004029592719134717, "phrase": "incident_radiance"}, {"score": 0.003975781274672803, "phrase": "surface_properties"}, {"score": 0.0037423521744765075, "phrase": "real-time_rendering"}, {"score": 0.0036064757492752703, "phrase": "fine_scale_surface_geometry"}, {"score": 0.003452218803245602, "phrase": "coarse_mesh"}, {"score": 0.003406091279580424, "phrase": "color_maps"}, {"score": 0.0033832583769880576, "phrase": "normal_maps"}, {"score": 0.003360578019762703, "phrase": "horizon_maps"}, {"score": 0.0033268412940032103, "phrase": "shadow_maps"}, {"score": 0.003282383509542342, "phrase": "frequently_used_simple_idea"}, {"score": 0.002917793073455365, "phrase": "averaged_surface_parameters"}, {"score": 0.002637609579129844, "phrase": "nonlinear_effects"}, {"score": 0.002507748938616919, "phrase": "general_presentation"}, {"score": 0.0024576084154573396, "phrase": "complex_surfaces"}, {"score": 0.0023923066544220277, "phrase": "existing_methods"}, {"score": 0.0023131084326717755, "phrase": "difficult_problem"}, {"score": 0.002206606452557159, "phrase": "generic_tools"}, {"score": 0.0021917966722180132, "phrase": "prefilter_maps"}, {"score": 0.0021697677572213086, "phrase": "nonlinear_functions"}, {"score": 0.0021335427588412056, "phrase": "open_issues"}, {"score": 0.0021049977753042253, "phrase": "general_problem"}], "paper_keywords": ["Rendering", " antialiasing", " prefiltering", " reflectance", " surface"], "paper_abstract": "Rendering a complex surface accurately and without aliasing requires the evaluation of an integral for each pixel, namely, a weighted average of the outgoing radiance over the pixel footprint on the surface. The outgoing radiance is itself given by a local illumination equation as a function of the incident radiance and of the surface properties. Computing all this numerically during rendering can be extremely costly. For efficiency, especially for real-time rendering, it is necessary to use precomputations. When the fine scale surface geometry, reflectance, and illumination properties are specified with maps on a coarse mesh (such as color maps, normal maps, horizon maps, or shadow maps), a frequently used simple idea is to prefilter each map linearly and separately. The averaged outgoing radiance, i.e., the average of the values given by the local illumination equation is then estimated by applying this equation to the averaged surface parameters. But this is really not accurate because this equation is nonlinear, due to self-occlusions, self-shadowing, nonlinear reflectance functions, etc. Some methods use more complex prefiltering algorithms to cope with these nonlinear effects. This paper is a survey of these methods. We start with a general presentation of the problem of prefiltering complex surfaces. We then present and classify the existing methods according to the approximations they make to tackle this difficult problem. Finally, an analysis of these methods allows us to highlight some generic tools to prefilter maps used in nonlinear functions, and to identify open issues to address the general problem.", "paper_title": "A Survey of Nonlinear Prefiltering Methods for Efficient and Accurate Surface Shading", "paper_id": "WOS:000298043100006"}