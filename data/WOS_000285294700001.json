{"auto_keywords": [{"score": 0.04953289560992991, "phrase": "fine-grained_state_tracking"}, {"score": 0.014768183060754914, "phrase": "ruby"}, {"score": 0.00481495049065317, "phrase": "optimizing_dynamic_dispatch"}, {"score": 0.004123781267600542, "phrase": "programming_paradigms"}, {"score": 0.004030157055463817, "phrase": "dynamic_aspect-oriented_programming"}, {"score": 0.0039841418890102925, "phrase": "context-oriented_programming"}, {"score": 0.0038713805573219297, "phrase": "performance_characteristics"}, {"score": 0.0038271712887391015, "phrase": "current_implementation"}, {"score": 0.0037834649508375544, "phrase": "dynamic_mixin"}, {"score": 0.003531474887552889, "phrase": "frequent_dynamic_mixin_operations"}, {"score": 0.0034911335714333507, "phrase": "global_method_cache"}, {"score": 0.0034512514926836667, "phrase": "inline_cache"}, {"score": 0.0033922781038328844, "phrase": "significant_overhead"}, {"score": 0.0029722900280316216, "phrase": "extreme_case"}, {"score": 0.0028715299874549245, "phrase": "global_method_cache_clearing"}, {"score": 0.0026342827320931937, "phrase": "alternating_states"}, {"score": 0.0025596276616952516, "phrase": "small_application"}, {"score": 0.002530359917257626, "phrase": "dynamic_mixins"}, {"score": 0.0022424956516376073, "phrase": "thread-local_caching"}, {"score": 0.0021049977753042253, "phrase": "thread-local_delegation_changes"}], "paper_keywords": ["Performance", " Dynamic method dispatch", " inline caching", " polymorphic inline caching"], "paper_abstract": "Dynamic mixin is a construct available in Ruby and other dynamic languages. It can be used as a base to implement a range of programming paradigms, such as dynamic aspect-oriented programming and context-oriented programming. However, the performance characteristics of current implementation of dynamic mixin in Ruby leaves much to be desired: under condition of frequent dynamic mixin operations, global method cache and inline cache misses incur significant overhead. In this work we implemented fine-grained state tracking for CRuby 1.9 and were able to improve performance by more than six times on the microbenchmark exercising extreme case, owing 4 times to global method cache clearing, 28% to fine-grained state tracking and further 12% to inline cache miss elimination by caching alternating states. We demonstrated a small application using dynamic mixins that gets 48% improvement in performance from our techniques. We also implemented in C a more general delegation object model and proposed an algorithm of thread-local caching, which allows to reduce inline cache misses while permitting thread-local delegation changes.", "paper_title": "Optimizing Dynamic Dispatch with Fine-grained State Tracking", "paper_id": "WOS:000285294700001"}