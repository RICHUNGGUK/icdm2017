{"auto_keywords": [{"score": 0.03714965378696057, "phrase": "exact_repair"}, {"score": 0.015404416953417363, "phrase": "storage-bandwidth_tradeoff"}, {"score": 0.013501538896953087, "phrase": "failed_node"}, {"score": 0.007032139146736554, "phrase": "functional_repair"}, {"score": 0.00481495049065317, "phrase": "distributed_storage_codes_with_repair"}, {"score": 0.004765889452740394, "phrase": "nonachievability_of_interior_points"}, {"score": 0.004590217765551337, "phrase": "recently_developed_codes"}, {"score": 0.004558977045730675, "phrase": "distributed_storage"}, {"score": 0.004497129150551236, "phrase": "reed-solomon_codes"}, {"score": 0.0044512920090463105, "phrase": "data_recovery"}, {"score": 0.004375928080972614, "phrase": "k_nodes"}, {"score": 0.004331320910631647, "phrase": "n-node_network"}, {"score": 0.0042725481832853315, "phrase": "regenerating_codes"}, {"score": 0.0040591367766929344, "phrase": "arbitrary_subset"}, {"score": 0.003577032245103867, "phrase": "special_case"}, {"score": 0.0034924598001567944, "phrase": "replacement_node"}, {"score": 0.00325051332556486, "phrase": "system_implementation"}, {"score": 0.0032173412933955117, "phrase": "first_result"}, {"score": 0.0030460403366412126, "phrase": "minimum_possible_repair_bandwidth"}, {"score": 0.002903628734069691, "phrase": "particularly_simple_graphical_description"}, {"score": 0.0027395968397212053, "phrase": "arithmetic_operations"}, {"score": 0.002620424858132324, "phrase": "mere_transfer"}, {"score": 0.0025409639091476363, "phrase": "second_result"}, {"score": 0.002480826434008026, "phrase": "interior_points"}, {"score": 0.002332626862738603, "phrase": "separate_tradeoff"}, {"score": 0.0022007808283071133, "phrase": "helper_node"}], "paper_keywords": ["Distributed storage", " minimum bandwidth", " node repair", " regenerating codes", " storage versus repair-bandwidth tradeoff"], "paper_abstract": "Regenerating codes are a class of recently developed codes for distributed storage that, like Reed-Solomon codes, permit data recovery from any subset of k nodes within the n-node network. However, regenerating codes possess in addition, the ability to repair a failed node by connecting to an arbitrary subset of d nodes. It has been shown that for the case of functional repair, there is a tradeoff between the amount of data stored per node and the bandwidth required to repair a failed node. A special case of functional repair is exact repair where the replacement node is required to store data identical to that in the failed node. Exact repair is of interest as it greatly simplifies system implementation. The first result of this paper is an explicit, exact-repair code for the point on the storage-bandwidth tradeoff corresponding to the minimum possible repair bandwidth, for the case when d = n-1. This code has a particularly simple graphical description, and most interestingly has the ability to carry out exact repair without any need to perform arithmetic operations. We term this ability of the code to perform repair through mere transfer of data as repair by transfer. The second result of this paper shows that the interior points on the storage-bandwidth tradeoff cannot be achieved under exact repair, thus pointing to the existence of a separate tradeoff under exact repair. Specifically, we identify a set of scenarios which we term as \"helper node pooling,\" and show that it is the necessity to satisfy such scenarios that overconstrains the system.", "paper_title": "Distributed Storage Codes With Repair-by-Transfer and Nonachievability of Interior Points on the Storage-Bandwidth Tradeoff", "paper_id": "WOS:000300845900035"}