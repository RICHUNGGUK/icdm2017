{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_data_representation_synthesis"}, {"score": 0.004487989502479992, "phrase": "data_representations"}, {"score": 0.00440976345264104, "phrase": "concurrent_programs"}, {"score": 0.0040385352882334235, "phrase": "concurrent_relations"}, {"score": 0.0036660436272785476, "phrase": "cooperating_data_structures"}, {"score": 0.003298631258267805, "phrase": "concurrent_access"}, {"score": 0.003212663446866794, "phrase": "data_structures"}, {"score": 0.0031289290660162145, "phrase": "resulting_code"}, {"score": 0.002967931416941965, "phrase": "individual_relational_operations"}, {"score": 0.0028151944356239952, "phrase": "aggregate_set"}, {"score": 0.0025778546800417808, "phrase": "relational_specification"}, {"score": 0.002488604965680912, "phrase": "high-level_optimizer"}, {"score": 0.0024024377855956136, "phrase": "best_performing"}, {"score": 0.0021049977753042253, "phrase": "graph_benchmark"}], "paper_keywords": ["Synthesis", " Lock Placement"], "paper_abstract": "We describe an approach for synthesizing data representations for concurrent programs. Our compiler takes as input a program written using concurrent relations and synthesizes a representation of the relations as sets of cooperating data structures as well as the placement and acquisition of locks to synchronize concurrent access to those data structures. The resulting code is correct by construction: individual relational operations are implemented correctly and the aggregate set of operations is serializable and deadlock free. The relational specification also permits a high-level optimizer to choose the best performing of many possible legal data representations and locking strategies, which we demonstrate with an experiment autotuning a graph benchmark.", "paper_title": "Concurrent Data Representation Synthesis", "paper_id": "WOS:000307582100037"}