{"auto_keywords": [{"score": 0.04657381885996478, "phrase": "error_trace"}, {"score": 0.007649603754757753, "phrase": "first_technique"}, {"score": 0.00700316703819308, "phrase": "second_technique"}, {"score": 0.00577060179568381, "phrase": "proposed_methodology"}, {"score": 0.005674212985638016, "phrase": "actual_error"}, {"score": 0.00481495049065317, "phrase": "model_debugging"}, {"score": 0.004774530554776604, "phrase": "design_debugging"}, {"score": 0.0047145329604366395, "phrase": "major_bottleneck"}, {"score": 0.004674952036988355, "phrase": "modern_very_large_scale_integration_design_flows"}, {"score": 0.004351595642056769, "phrase": "typical_design_blocks"}, {"score": 0.0043150485532080065, "phrase": "half_a_million_synthesized_logic_gates"}, {"score": 0.004171891198117439, "phrase": "clock_cycles"}, {"score": 0.004067635935640407, "phrase": "debugging_problem"}, {"score": 0.004016485454498076, "phrase": "great_challenge"}, {"score": 0.003982741546775355, "phrase": "automated_debugging_techniques"}, {"score": 0.003850566273995209, "phrase": "daunting_challenge"}, {"score": 0.0037861265016041813, "phrase": "bounded_model_debugging_methodology"}, {"score": 0.003722761107761564, "phrase": "bounded_sequences"}, {"score": 0.0035091888798162176, "phrase": "growing_problem"}, {"score": 0.003421437601439154, "phrase": "bounded_subsequences"}, {"score": 0.003349984456443527, "phrase": "increasing_size"}, {"score": 0.0032387402145603412, "phrase": "entire_trace"}, {"score": 0.003104849179057156, "phrase": "non-overlapping_bounded_sequences"}, {"score": 0.0028654728453890426, "phrase": "unified_methodology"}, {"score": 0.002735392281320413, "phrase": "empirical_results"}, {"score": 0.0027123819773059127, "phrase": "real_industrial_designs"}, {"score": 0.00266693888510356, "phrase": "large_designs"}, {"score": 0.0026445028886931837, "phrase": "long_error"}, {"score": 0.002131857309586904, "phrase": "conventional_automated_debuggers"}], "paper_keywords": ["Debugging", " interpolation", " RTL", " verification", " very large scale integration (VLSI)"], "paper_abstract": "Design debugging is a major bottleneck in modern very large scale integration design flows as both the design size and the length of the error trace contribute to its inherent complexity. With typical design blocks exceeding half a million synthesized logic gates and error traces in the thousands of clock cycles, the complexity of the debugging problem poses a great challenge to automated debugging techniques. This paper aims to address this daunting challenge by introducing the bounded model debugging methodology that iteratively analyzes bounded sequences of the error trace. Two techniques are introduced in this methodology to solve this growing problem. The first technique iteratively analyzes bounded subsequences of the error trace of increasing size until the error is found or the entire trace is analyzed. The second technique partitions the error trace into non-overlapping bounded sequences of clock cycles which are each separately analyzed. A discussion of these two techniques is presented and a unified methodology that leverages the strengths of both techniques is developed. Empirical results on real industrial designs show that for large designs and long error traces the proposed methodology can find the actual error in 79% of cases with the first technique and 100% of cases with the second technique. In cases where the methodology is not used only 21% of cases are able to find the actual error. These numbers confirm the benefits of the proposed methodology to allow conventional automated debuggers to handle much larger real-life circuits.", "paper_title": "Bounded Model Debugging", "paper_id": "WOS:000283453200011"}