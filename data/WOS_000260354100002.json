{"auto_keywords": [{"score": 0.037605849031919644, "phrase": "metisp"}, {"score": 0.008713768692145006, "phrase": "sequential_patterns"}, {"score": 0.008623469415472663, "phrase": "large_databases"}, {"score": 0.0047152877145889656, "phrase": "effective_time-indexing"}, {"score": 0.004666228956744244, "phrase": "sequential_pattern_mining_algorithms"}, {"score": 0.004451676867747938, "phrase": "specific_constraints"}, {"score": 0.0043367547691560175, "phrase": "support_threshold"}, {"score": 0.004246947739596565, "phrase": "time-independent_constraints"}, {"score": 0.004180809918117248, "phrase": "qualified_patterns"}, {"score": 0.004030449969901066, "phrase": "time-dependent_constraints"}, {"score": 0.003946960862020283, "phrase": "support_computation_process"}, {"score": 0.00386519448487341, "phrase": "time_attributes"}, {"score": 0.0038049789989278463, "phrase": "data_sequence"}, {"score": 0.003629882559085245, "phrase": "memory_time-indexing_approach"}, {"score": 0.0034628156490003775, "phrase": "time_constraints"}, {"score": 0.003069867656852932, "phrase": "time-index_sets"}, {"score": 0.0029593432468318745, "phrase": "index_sets"}, {"score": 0.0029131986574478046, "phrase": "pattern-growth_strategy"}, {"score": 0.0026649432435828842, "phrase": "search_space"}, {"score": 0.0025960262223338293, "phrase": "designated_in-memory_data_sequences"}, {"score": 0.0024894376091589244, "phrase": "potential_items"}, {"score": 0.002450602177683066, "phrase": "indicated_ranges"}, {"score": 0.002362320344521919, "phrase": "better_efficiency"}, {"score": 0.0023133055945761235, "phrase": "low_support"}, {"score": 0.002241679436497569, "phrase": "well-known_gsp"}, {"score": 0.002218299213266519, "phrase": "delisp"}, {"score": 0.0021049977753042253, "phrase": "database_size"}], "paper_keywords": ["Sequential patterns", " Time constraint", " Time-index", " Sequence mining", " Pattern-growth"], "paper_abstract": "Sequential pattern mining algorithms can often produce more accurate results if they work with specific constraints in addition to the support threshold. Many systems implement time-independent constraints by selecting qualified patterns. This selection cannot implement time-dependent constraints, because the support computation process must validate the time attributes of every data sequence during mining. Therefore, we propose a memory time-indexing approach, called METISP, to discover sequential patterns with time constraints including minimum-gap, maximum-gap, exact-gap, sliding window, and duration constraints. METISP scans the database into memory and constructs time-index sets for effective processing. METISP uses index sets and a pattern-growth strategy to mine patterns without generating any candidates or sub-databases. The index sets narrow down the search space to the sets of designated in-memory data sequences, and speed up the counting of potential items within the indicated ranges. Our comprehensive experiments show that METISP has better efficiency, even with low support and large databases, than the well-known GSP and DELISP algorithms. METISP scales up linearly with respect to database size. (c) 2008 Elsevier Inc. All rights reserved.", "paper_title": "Fast discovery of sequential patterns in large databases using effective time-indexing", "paper_id": "WOS:000260354100002"}