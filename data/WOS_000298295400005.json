{"auto_keywords": [{"score": 0.024510675242343478, "phrase": "tm"}, {"score": 0.014583120294385537, "phrase": "cache"}, {"score": 0.004681012408089219, "phrase": "poor_placement"}, {"score": 0.00464343008299973, "phrase": "data_blocks"}, {"score": 0.0045324756541157574, "phrase": "application_performance"}, {"score": 0.004406360418456518, "phrase": "cache_conflict"}, {"score": 0.004266501496765747, "phrase": "dynamically_allocated_structures"}, {"score": 0.004131063310728304, "phrase": "memory_allocator"}, {"score": 0.0040978781692373005, "phrase": "cache_index-oblivious_allocators"}, {"score": 0.00398380712846857, "phrase": "restricted_fraction"}, {"score": 0.003935892934907777, "phrase": "available_cache_indexes"}, {"score": 0.003601628511550962, "phrase": "general-purpose_malloc_allocator"}, {"score": 0.0033835707840639477, "phrase": "intel"}, {"score": 0.0032038465090068646, "phrase": "performance_pathologies"}, {"score": 0.0031020367403802773, "phrase": "simple_adjustment"}, {"score": 0.0029553380263320195, "phrase": "better_index_coverage"}, {"score": 0.002872979681637667, "phrase": "superfluous_conflict"}, {"score": 0.002759279370360986, "phrase": "observed_negative_consequences"}, {"score": 0.0026932247685847246, "phrase": "index-aware_allocator"}, {"score": 0.0024444073418288703, "phrase": "inter-process_conflict"}, {"score": 0.002276942212841243, "phrase": "nehalem"}, {"score": 0.0021479597698614373, "phrase": "different_threads"}, {"score": 0.0021049977753042253, "phrase": "different_cache_indexes"}], "paper_keywords": ["Performance", " experiments", " algorithms", " Dynamic storage allocators", " memory allocation", " malloc", " caches", " shared caches", " conflict misses", " placement policies"], "paper_abstract": "Poor placement of data blocks in memory may negatively impact application performance because of an increase in the cache conflict miss rate [18]. For dynamically allocated structures this placement is typically determined by the memory allocator. Cache index-oblivious allocators may inadvertently place blocks on a restricted fraction of the available cache indexes, artificially and needlessly increasing the conflict miss rate. While some allocators are less vulnerable to this phenomena, no general-purpose malloc allocator is index-aware and methodologically addresses this concern. We demonstrate that many existing state-of-the-art allocators are index-oblivious, admitting performance pathologies for certain block sizes. We show that a simple adjustment within the allocator to control the spacing of blocks can provide better index coverage, which in turn reduces the superfluous conflict miss rate in various applications, improving performance with no observed negative consequences. The result is an index-aware allocator. Our technique is general and can easily be applied to most memory allocators and to various processor architectures. Furthermore, we can reduce inter-thread and inter-process conflict misses for processors where threads concurrently share the level-1 cache such as the Sun UltraSPARC-T2 (TM) and Intel \"Nehalem\" by coloring the placement of blocks so that allocations for different threads and processes start on different cache indexes.", "paper_title": "Cache Index-Aware Memory Allocation", "paper_id": "WOS:000298295400005"}