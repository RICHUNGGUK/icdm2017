{"auto_keywords": [{"score": 0.03814741522567492, "phrase": "smalltalk"}, {"score": 0.00481495049065317, "phrase": "smalltalk_source_code_analysis_tools"}, {"score": 0.004766487181100495, "phrase": "code_management_systems"}, {"score": 0.004655285779819366, "phrase": "tool_support"}, {"score": 0.004500891637057374, "phrase": "version_history_analysis"}, {"score": 0.004455575231721042, "phrase": "adequate_models"}, {"score": 0.004410713064804144, "phrase": "source_code_entities"}, {"score": 0.004013098289856805, "phrase": "reflective_system"}, {"score": 0.003738502710504415, "phrase": "powerful_code"}, {"score": 0.0035181497207938746, "phrase": "api"}, {"score": 0.0034359094594153304, "phrase": "refactoring_engine"}, {"score": 0.003412783661090541, "phrase": "distributed_versioning_system"}, {"score": 0.003378385493203297, "phrase": "monticello"}, {"score": 0.0033106223384515546, "phrase": "specific_meta-models"}, {"score": 0.0032772504899699416, "phrase": "adequate_engineered_solution"}, {"score": 0.0030118779844670353, "phrase": "navigation_tool_reuse"}, {"score": 0.002951444412262927, "phrase": "polymorphic_apis"}, {"score": 0.0029118285733827406, "phrase": "first_step"}, {"score": 0.002843772431469196, "phrase": "history_analysis"}, {"score": 0.0026222551419772867, "phrase": "unified_and_layered_approach"}, {"score": 0.002501073751997206, "phrase": "change_analyses"}, {"score": 0.0023455000216532802, "phrase": "underlying_meta-model"}, {"score": 0.0023296961971785357, "phrase": "remote_and_off-image_browsing"}, {"score": 0.002229529362571334, "phrase": "future_work"}, {"score": 0.002162711766975021, "phrase": "new_generation"}, {"score": 0.002148136905808445, "phrase": "history_analysis_tools"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Source code meta-model", " Versioning", " Refactoring", " Monticello", " Smalltalk"], "paper_abstract": "Source code management systems record different versions of code. Tool support can then compute deltas between versions. To ease version history analysis we need adequate models to represent source code entities. Now naturally the questions of their definition, the abstractions they use, and the APIs of such models are raised, especially in the context of a reflective system which already offers a model of its own structure. We believe that this problem is due to the lack of a powerful code meta-model as well as an infrastructure. In Smalltalk, often several source code meta-models coexist: the Smalltalk reflective API coexists with the one of the Refactoring engine or distributed versioning system such as Monticello or Store. While having specific meta-models is an adequate engineered solution, it multiplies meta-models and it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly hinders navigation tool reuse when meta-models do not offer polymorphic APIs. As a first step to provide an infrastructure to support history analysis, this article presents Ring, a unifying source code meta-model that can be used to support several activities and proposes a unified and layered approach to be the foundation for building an infrastructure for version and stream of change analyses. We re-implemented three tools based on Ring to show that it can be used as the underlying meta-model for remote and off-image browsing, scoping refactoring, and visualizing and analyzing changes. As a future work and based on Ring we will build a new generation of history analysis tools. (C) 2011 Elsevier Ltd. All rights reserved.", "paper_title": "Ring: A unifying meta-model and infrastructure for Smalltalk source code analysis tools", "paper_id": "WOS:000299067600004"}