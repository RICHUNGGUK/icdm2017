{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "angelic_nondeterminism"}, {"score": 0.009337105248914847, "phrase": "floyd"}, {"score": 0.006540815816736836, "phrase": "safe_execution"}, {"score": 0.005704432865257119, "phrase": "angelic_operators"}, {"score": 0.004696491408936132, "phrase": "important_role"}, {"score": 0.004657653216262924, "phrase": "program_development"}, {"score": 0.004412881870378388, "phrase": "refinement_calculus"}, {"score": 0.004322186889256224, "phrase": "formal_basis"}, {"score": 0.0042864307215634756, "phrase": "regular_expressions"}, {"score": 0.004112020122418323, "phrase": "backtracking_algorithms"}, {"score": 0.003847546889061499, "phrase": "deterministic_programs"}, {"score": 0.003540661500026125, "phrase": "yet-to-be-written_deterministic_code"}, {"score": 0.0033964919992320024, "phrase": "angelic_operator"}, {"score": 0.003048449231088915, "phrase": "incomplete_programs"}, {"score": 0.0027246145918972025, "phrase": "implementation_strategy"}, {"score": 0.002646412155387084, "phrase": "refinement-based_angelic_programming"}, {"score": 0.002559780284750354, "phrase": "scala"}, {"score": 0.002496659907186784, "phrase": "bounded_model_checking"}, {"score": 0.002297274552621268, "phrase": "deutsch-schorr-waite"}, {"score": 0.002158233639156017, "phrase": "parasitic_stack"}, {"score": 0.0021049986112886576, "phrase": "dsw"}], "paper_keywords": ["Design", " Languages", " Verification", " Angelic non-determinism", " constraints", " bounded model-checking", " traces", " refinement"], "paper_abstract": "Angelic nondeterminism can play an important role in program development. It simplifies specifications, for example in deriving programs with a refinement calculus; it is the formal basis of regular expressions; and Floyd relied on it to concisely express backtracking algorithms such as N-queens. We show that angelic nondeterminism is also useful during the development of deterministic programs. The semantics of our angelic operator are the same as Floyd's but we use it as a substitute for yet-to-be-written deterministic code; the final program is fully deterministic. The angelic operator divines a value that makes the program meet its specification, if possible. Because the operator is executable, it allows the programmer to test incomplete programs: if a program has no safe execution, it is already incorrect; if a program does have a safe execution, the execution may reveal an implementation strategy to the programmer. We introduce refinement-based angelic programming, describe our embedding of angelic operators into Scala, report on our implementation with bounded model checking, and describe our experience with two case studies. In one of the studies, we use angelic operators to modularize the Deutsch-Schorr-Waite (DSW) algorithm. The modularization is performed with the notion of a parasitic stack, whose incomplete specification was instantiated for DSW with angelic nondeterminism.", "paper_title": "Programming with Angelic Nondeterminism", "paper_id": "WOS:000274028100030"}