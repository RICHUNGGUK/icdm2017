{"auto_keywords": [{"score": 0.048949445942657245, "phrase": "vliw_dsp_processors"}, {"score": 0.04850460722985758, "phrase": "distributed_register_files"}, {"score": 0.029880515873070942, "phrase": "palf_scheme"}, {"score": 0.00481495049065317, "phrase": "scheduling_methods"}, {"score": 0.0047464608267006395, "phrase": "ordering_framework"}, {"score": 0.004612376827433774, "phrase": "digital_signal_processors"}, {"score": 0.004172094622123562, "phrase": "power_consumption"}, {"score": 0.004132411680987228, "phrase": "design_cost"}, {"score": 0.003977403701783668, "phrase": "multi-bank_register_architectures"}, {"score": 0.0037556843869894566, "phrase": "register_files"}, {"score": 0.003580355398511932, "phrase": "efficient_codes"}, {"score": 0.0034459835582278746, "phrase": "instruction_scheduling_method"}, {"score": 0.0032850648549389025, "phrase": "well-known_palf_scheme"}, {"score": 0.00311669276800628, "phrase": "register_allocation"}, {"score": 0.0029711052657054463, "phrase": "pseudo_instruction_scheduler"}, {"score": 0.002928765962664163, "phrase": "bank_assignment_analysis"}, {"score": 0.00290087451159631, "phrase": "palf_assignment"}, {"score": 0.00276534038425712, "phrase": "program_graph"}, {"score": 0.002739001004969201, "phrase": "cycle_information"}, {"score": 0.0026361219160332626, "phrase": "ping-pong-aware_scheduling_policy"}, {"score": 0.002488985155689794, "phrase": "limited_temporal_connectivities"}, {"score": 0.0024301229420875155, "phrase": "dsp_processors"}, {"score": 0.002350041573006264, "phrase": "instruction_set_simulator"}, {"score": 0.002327648608736437, "phrase": "parallel_architecture_core_dsp_processors"}, {"score": 0.0022617389804167943, "phrase": "preliminary_experiments"}, {"score": 0.0022294857939412073, "phrase": "eembc_and_mibench_benchmarks"}, {"score": 0.0021252533072727707, "phrase": "hardware_constraints"}, {"score": 0.0021049977753042253, "phrase": "vliw_scheduling"}], "paper_keywords": ["VLIW DSP", " Compiler", " Instruction scheduling"], "paper_abstract": "Digital signal processors (DSPs) with very long instruction word (VLIW) data-path architectures are increasingly being deployed on embedded devices in video and other multimedia processing applications. To reduce the power consumption and design cost of VLIW DSP processors, distributed register files and multi-bank register architectures are being adopted to eliminate the amount of read/write ports associated with register files. This presents challenges for compilers attempting to generate efficient codes. In this paper we present an instruction scheduling method and phase ordering framework for such an architecture based on the well-known PALF scheme. The PALF scheme first performs bank partitioning followed by register allocation and then instruction scheduling. Our contribution includes the insertion of a pseudo instruction scheduler that performs bank assignment analysis before PALF assignment. We also enhance the PALF scheme by utilizing the program graph with cycle information generated by our pseudo scheduler. Finally, a ping-pong-aware scheduling policy is used in the scheduling phases to address the issue of limited temporal connectivities among register banks for DSP processors. Experiments were performed on an instruction set simulator for Parallel Architecture Core DSP processors based on the Open64 compiler infrastructure. Preliminary experiments with the EEMBC and MiBench benchmarks show that a compiler based on our proposed scheme for handling hardware constraints of VLIW scheduling on distributed register files exhibits performance superior to that of the PALF scheme.", "paper_title": "Instruction scheduling methods and phase ordering framework for VLIW DSP processors with distributed register files", "paper_id": "WOS:000308110100029"}