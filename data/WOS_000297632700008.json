{"auto_keywords": [{"score": 0.04942444706912143, "phrase": "first-class_control"}, {"score": 0.048778468893892986, "phrase": "pushdown_models"}, {"score": 0.02769366483683973, "phrase": "abstract_semantics"}, {"score": 0.00481495049065317, "phrase": "pushdown_flow_analysis"}, {"score": 0.004556901872357751, "phrase": "control-flow_graphs"}, {"score": 0.004494570360108983, "phrase": "higher-order_flow_analysis"}, {"score": 0.003680587852807675, "phrase": "analyzed_program_nest"}, {"score": 0.0027741761880779535, "phrase": "first_pushdown_flow_analysis"}, {"score": 0.0022399174232611853, "phrase": "summarization_algorithm"}, {"score": 0.0021342613107011624, "phrase": "new_kind"}, {"score": 0.0021049977753042253, "phrase": "summary_edge"}], "paper_keywords": ["Languages", " pushdown flow analysis", " first-class continuations", " restricted continuation-passing style", " summarization", " higher-order functional language"], "paper_abstract": "Pushdown models are better than control-flow graphs for higher-order flow analysis. They faithfully model the call/return structure of a program, which results in fewer spurious flows and increased precision. However, pushdown models require that calls and returns in the analyzed program nest properly. As a result, they cannot be used to analyze language constructs that break call/return nesting such as generators, coroutines, call/cc, etc. In this paper, we extend the CFA2 flow analysis to create the first pushdown flow analysis for languages with first-class control. We modify the abstract semantics of CFA2 to allow continuations to escape to, and be restored from, the heap. We then present a summarization algorithm that handles escaping continuations via a new kind of summary edge. We prove that the algorithm is sound with respect to the abstract semantics.", "paper_title": "Pushdown Flow Analysis of First-Class Control", "paper_id": "WOS:000297632700008"}