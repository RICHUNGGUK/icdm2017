{"auto_keywords": [{"score": 0.024397970571861702, "phrase": "jacobians"}, {"score": 0.00481495049065317, "phrase": "implementation-independent_simulation_models"}, {"score": 0.004687305496643216, "phrase": "complex_physical_systems"}, {"score": 0.004640311812502743, "phrase": "central_activity"}, {"score": 0.0044870272550540415, "phrase": "large_investments"}, {"score": 0.004427134352966977, "phrase": "measurement_equipment"}, {"score": 0.0038573081851680656, "phrase": "user_background"}, {"score": 0.0038186039088445524, "phrase": "engineering_domain"}, {"score": 0.0037297918570822876, "phrase": "modern_equation-based_modeling_languages"}, {"score": 0.0035823043879169153, "phrase": "executable_code"}, {"score": 0.003558294449586273, "phrase": "separate_model_compilers"}, {"score": 0.0034638476252104706, "phrase": "standalone_simulation"}, {"score": 0.0034290777464571895, "phrase": "fixed_interface"}, {"score": 0.0033718991936259038, "phrase": "numerical_solvers"}, {"score": 0.0032494292163722065, "phrase": "customized_code"}, {"score": 0.003079163348079199, "phrase": "conventional_solution"}, {"score": 0.0029973957125353306, "phrase": "input_and_output_variables"}, {"score": 0.002917793073455365, "phrase": "compiler_architecture"}, {"score": 0.002764856305713066, "phrase": "modelica_language"}, {"score": 0.0026111116934081284, "phrase": "simulation_environment"}, {"score": 0.0024909230668523825, "phrase": "input-output_causality"}, {"score": 0.0023523750536537102, "phrase": "equation_system"}, {"score": 0.002214048743052355, "phrase": "xml_format"}, {"score": 0.0021049977753042253, "phrase": "final_executable_code"}], "paper_keywords": ["simulation", " DAE", " compiler", " Modelica", " XML", " causality", " code generation"], "paper_abstract": "Mathematical modeling and the simulation of complex physical systems is a central activity in engineering. The models are the result of large investments in time and measurement equipment and therefore need to be used as efficiently as possible. If one and the same model can be run in several simulation environments and in other applications, then the model can be simulated today and tomorrow in the most appropriate environment with respect to user background, the engineering domain at hand, and more. Modern equation-based modeling languages provide this functionality in principle since the models are translated into executable code by separate model compilers. These compilers today generate code for standalone simulation using a fixed interface toward a number of numerical solvers. What is missing is a compiler that can generate customized code for various simulation environments, where the generated code interfaces with other models in the environment through the conventional solution of powerports. Each port holds both input and output variables such as force and velocity. A compiler architecture is proposed in this article. Also, an implementation for a subset of the Modelica language is demonstrated in the case of two widely different simulation environment targets. The model ports are adapted initially to the simulation environment characteristics in terms of the variables part of the ports, and an input-output causality is found for which the model can be solved and that suits the environment. The equation system is optimized, and information such as Jacobians, assignments, and more is generated in the XML format. Finally, code generators specific for each environment are employed that create the final executable code.", "paper_title": "A framework for implementation-independent simulation models", "paper_id": "WOS:000242895100001"}