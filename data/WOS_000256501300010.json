{"auto_keywords": [{"score": 0.048949445942657245, "phrase": "indirect_jumps"}, {"score": 0.00481495049065317, "phrase": "object-oriented_languages"}, {"score": 0.004656647251517823, "phrase": "indirect_jump_instructions"}, {"score": 0.004546755482549647, "phrase": "increasingly-common_programming_constructs"}, {"score": 0.004482063543727601, "phrase": "virtual_function_calls"}, {"score": 0.004439445472040688, "phrase": "switch-case_statements"}, {"score": 0.004313996835376177, "phrase": "interface_calls"}, {"score": 0.004252602474733162, "phrase": "performance_impact"}, {"score": 0.004054169947971483, "phrase": "multiple_targets"}, {"score": 0.003920780681351006, "phrase": "specialized_hardware"}, {"score": 0.003809932244103758, "phrase": "new_way"}, {"score": 0.003269393260288574, "phrase": "cfm"}, {"score": 0.00311669276800628, "phrase": "different_targets"}, {"score": 0.002845883666777154, "phrase": "run_time"}, {"score": 0.0024417832296664698, "phrase": "object-oriented_applications"}, {"score": 0.002406968743305622, "phrase": "java_dacapo_benchmark_suite"}, {"score": 0.0023388183537341213, "phrase": "commonly-used_branch_target_buffer"}, {"score": 0.0022617389804167943, "phrase": "energy_consumption"}, {"score": 0.0021049977753042253, "phrase": "best_performance"}], "paper_keywords": ["design", " performance", " dynamic predication", " indirect jumps", " virtual functions", " object-oriented languages", " predicated execution"], "paper_abstract": "Indirect jump instructions are used to implement increasingly-common programming constructs such as virtual function calls, switch-case statements, jump tables, and interface calls. The performance impact of indirect jumps is likely to increase because indirect jumps with multiple targets are difficult to predict even with specialized hardware. This paper proposes a new way of handling hard-to-predict indirect jumps: dynamically predicating them. The compiler (static or dynamic) identifies indirect jumps that are suitable for predication along with their control-flow merge (CFM) points. The hardware predicates the instructions between different targets of the jump and its CFM point if the jump turns out to be hard-to-predict at run time. If the jump would actually have been mispredicted, its dynamic predication eliminates a pipeline flush, thereby improving performance. Our evaluations show that Dynamic Indirect jump Predication (DIP) improves the performance of a set of object-oriented applications including the Java DaCapo benchmark suite by 37.8% compared to a commonly-used branch target buffer based predictor, while also reducing energy consumption by 24.8%. We compare DIP to three previously proposed indirect jump predictors and find that it provides the best performance and energy-efficiency.", "paper_title": "Improving the performance of object-oriented languages with dynamic predication of indirect jumps", "paper_id": "WOS:000256501300010"}