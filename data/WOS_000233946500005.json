{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java_programs"}, {"score": 0.007000549460174836, "phrase": "phase_behavior"}, {"score": 0.0047709540557306284, "phrase": "extant_java_virtual_machines"}, {"score": 0.004662705558154439, "phrase": "dynamic_compiler_optimizations"}, {"score": 0.004536029676655286, "phrase": "partial_execution"}, {"score": 0.004352411290383643, "phrase": "improving_performance"}, {"score": 0.004253618550301311, "phrase": "program_behavior"}, {"score": 0.004195418010131832, "phrase": "vital_importance"}, {"score": 0.004119049028319832, "phrase": "recent_research"}, {"score": 0.003988719758707836, "phrase": "computer_architecture"}, {"score": 0.003916098498242888, "phrase": "potential_optimization_opportunities"}, {"score": 0.0038624981944755813, "phrase": "repeating_patterns"}, {"score": 0.003809628721278519, "phrase": "time-varying_behavior"}, {"score": 0.00338060449446278, "phrase": "adaptive_jvms"}, {"score": 0.0032886455096627324, "phrase": "current_levels"}, {"score": 0.003083655376444887, "phrase": "optimization_development"}, {"score": 0.0029450811551641996, "phrase": "jikesrvm"}, {"score": 0.0029047858762049307, "phrase": "java"}, {"score": 0.00283870598459543, "phrase": "existing_techniques"}, {"score": 0.002799810685137358, "phrase": "unifying_set"}, {"score": 0.002748775748298028, "phrase": "data_collection"}, {"score": 0.0026616868981501006, "phrase": "dynamic_phase_behavior"}, {"score": 0.00257735013358606, "phrase": "optimization_developers"}, {"score": 0.002530359917257626, "phrase": "analysis_time"}, {"score": 0.0024842242921857705, "phrase": "adaptive_optimization"}, {"score": 0.0023725232579531273, "phrase": "sufficient_regularity"}, {"score": 0.002255431275670053, "phrase": "specjvm_benchmark_suite"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["program phases", " program behaviour visualization", " program analysis", " Java"], "paper_abstract": "Extant Java Virtual Machines (JVMs) apply dynamic compiler optimizations adaptively, based on the partial execution of the program, with the goal of improving performance. Understanding and characterizing program behavior is of vital importance to such systems. Recent research, primarily in the area of computer architecture, has identified potential optimization opportunities in the repeating patterns in the time-varying behavior of programs. In view of this, we believe that by considering time-varying, i.e., phase, behavior in Java programs, adaptive JVMs can enable performance that exceeds current levels. To enable analysis and visualization of phase behavior in Java programs and to facilitate optimization development, we have implemented a freely available, offline, phase analysis framework within the IBM Jikes Research Virtual Machine (JikesRVM) for Java. The framework couples existing techniques into a unifying set of tools for data collection, processing, and analysis of dynamic phase behavior in Java programs. The framework enables optimization developers to significantly reduce analysis time and to target adaptive optimization to parts of the code that will recur with sufficient regularity. We use the framework to evaluate phase behavior in the SpecJVM benchmark suite and discuss optimizations that are enabled by the framework. (c) 2005 Elsevier B.V. All rights reserved.", "paper_title": "Phase-based visualization and analysis of Java programs", "paper_id": "WOS:000233946500005"}