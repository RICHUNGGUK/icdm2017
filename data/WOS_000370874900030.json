{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "image_processing_pipelines"}, {"score": 0.004640590144749795, "phrase": "polymage"}, {"score": 0.004423284899590467, "phrase": "image_processing_pipeline"}, {"score": 0.004294625285753825, "phrase": "interconnected_stages"}, {"score": 0.0040783736687590635, "phrase": "data-dependent_operations"}, {"score": 0.004003798249233137, "phrase": "individual_stages"}, {"score": 0.003916098498242888, "phrase": "abundant_data_parallelism"}, {"score": 0.003830312347175889, "phrase": "relative_ease"}, {"score": 0.0037188360359702182, "phrase": "high_memory_bandwidth"}, {"score": 0.0036914757355166966, "phrase": "effective_utilization"}, {"score": 0.003623949225126944, "phrase": "modern_architectures"}, {"score": 0.0035445401296650535, "phrase": "high_performance"}, {"score": 0.0035054881943660096, "phrase": "traditional_options"}, {"score": 0.0034540850937966306, "phrase": "optimized_libraries"}, {"score": 0.0032800186243040663, "phrase": "library_routines"}, {"score": 0.0032558762499901727, "phrase": "manual_optimization_accounting"}, {"score": 0.003012831982759529, "phrase": "high-performance_implementations"}, {"score": 0.0029467742734417255, "phrase": "high-level_declarative_language"}, {"score": 0.0028293966058473476, "phrase": "code_generation_capabilities"}, {"score": 0.0027982016314450717, "phrase": "polyhedral_compiler_framework"}, {"score": 0.0026867260506696455, "phrase": "first_model-driven_compiler"}, {"score": 0.002618104519194264, "phrase": "complex_fusion"}, {"score": 0.0025324393547676623, "phrase": "experimental_results"}, {"score": 0.0025045102029373854, "phrase": "modern_multicore_system"}, {"score": 0.0023519508354777215, "phrase": "manual_tuning"}, {"score": 0.0023346271543145235, "phrase": "halide"}, {"score": 0.0021842976754894846, "phrase": "camera_raw_image_processing_pipeline"}, {"score": 0.0021049977753042253, "phrase": "hand-tuned_implementation"}], "paper_keywords": ["Domain-specific language", " image processing", " polyhedral optimization", " locality", " parallelism", " tiling", " multicores", " vectorization"], "paper_abstract": "This paper presents the design and implementation of PolyMage, a domain-specific language and compiler for image processing pipelines. An image processing pipeline can be viewed as a graph of interconnected stages which process images successively. Each stage typically performs one of point-wise, stencil, reduction or data-dependent operations on image pixels. Individual stages in a pipeline typically exhibit abundant data parallelism that can be exploited with relative ease. However, the stages also require high memory bandwidth preventing effective utilization of parallelism available on modern architectures. For applications that demand high performance, the traditional options are to use optimized libraries like OpenCV or to optimize manually. While using libraries precludes optimization across library routines, manual optimization accounting for both parallelism and locality is very tedious. The focus of our system, PolyMage, is on automatically generating high-performance implementations of image processing pipelines expressed in a high-level declarative language. Our optimization approach primarily relies on the transformation and code generation capabilities of the polyhedral compiler framework. To the best of our knowledge, this is the first model-driven compiler for image processing pipelines that performs complex fusion, tiling, and storage optimization automatically. Experimental results on a modern multicore system show that the performance achieved by our automatic approach is up to 1.81x better than that achieved through manual tuning in Halide, a state-of-the-art language and compiler for image processing pipelines. For a camera raw image processing pipeline, our performance is comparable to that of a hand-tuned implementation.", "paper_title": "PolyMage: Automatic Optimization for Image Processing Pipelines", "paper_id": "WOS:000370874900030"}