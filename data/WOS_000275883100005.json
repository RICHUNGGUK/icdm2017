{"auto_keywords": [{"score": 0.03326095884454224, "phrase": "ecc"}, {"score": 0.00481495049065317, "phrase": "microarchitectural_online_testing_for_failure_detection"}, {"score": 0.00475924837336259, "phrase": "memory_order_buffers"}, {"score": 0.004043541331944951, "phrase": "latent_defects"}, {"score": 0.003996727479807572, "phrase": "actual_errors"}, {"score": 0.0038148090091532933, "phrase": "current_reliability_qualification_methods"}, {"score": 0.0036838048761094933, "phrase": "microarchitecture_knowledge"}, {"score": 0.0036411406244705557, "phrase": "application_runtime_behavior"}, {"score": 0.003516079377293321, "phrase": "low-cost_continuous_online_testing_techniques"}, {"score": 0.0029694040368299624, "phrase": "control_logic"}, {"score": 0.002867348342846275, "phrase": "microarchitectural_approach"}, {"score": 0.00278497898719426, "phrase": "memory_order_buffer_logic"}, {"score": 0.002658068304632523, "phrase": "small_cache-like_structure"}, {"score": 0.002566685388128598, "phrase": "last_store"}, {"score": 0.0025221759076833124, "phrase": "cached_address"}, {"score": 0.0023380300046435187, "phrase": "youngest_older_producing_store"}, {"score": 0.002205560249972527, "phrase": "different_trade-offs"}, {"score": 0.002142161017595363, "phrase": "performance_overhead"}, {"score": 0.0021049977753042253, "phrase": "design_complexity"}], "paper_keywords": ["Online testing", " memory order buffer", " control logic", " microarchitecture", " error detection", " soft errors", " defects"], "paper_abstract": "Technology scaling leads to burn-in phase out and higher postsilicon test complexity, which increases in-the-field failure rate due to both latent defects and actual errors, respectively. As a consequence, current reliability qualification methods will likely be infeasible. Microarchitecture knowledge of application runtime behavior offers a possibility to have low-cost continuous online testing techniques detect hard errors in the field. Whereas data can be protected with redundancy (like parity or ECC), there is a lack of mechanism for control logic. This paper proposes a microarchitectural approach for validating that the memory order buffer logic works correctly. Our design relies on a small cache-like structure that keeps track of the last store to each cached address. Each load is checked to have obtained the data from the youngest older producing store. We present three different implementations of this idea, offering different trade-offs for error coverage, performance overhead, and design complexity.", "paper_title": "Microarchitectural Online Testing for Failure Detection in Memory Order Buffers", "paper_id": "WOS:000275883100005"}