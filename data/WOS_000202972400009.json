{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "component_programming_techniques"}, {"score": 0.0045357787854931894, "phrase": "external_linking"}, {"score": 0.003945467978172845, "phrase": "internally_specified_references"}, {"score": 0.0037913267098534887, "phrase": "pure_component_system"}, {"score": 0.003643185395780667, "phrase": "sufficient_mechanism"}, {"score": 0.00286795254228461, "phrase": "typed_units"}, {"score": 0.0023727863021828547, "phrase": "sml-style_system"}, {"score": 0.0021049977753042253, "phrase": "recursive_structures"}], "paper_keywords": ["module", " component", " structure", " functor", " unit"], "paper_abstract": "Component programming techniques encourage abstraction and reuse through external linking. Some parts of a program, however, must use concrete, internally specified references, so a pure component system is not a sufficient mechanism for structuring programs. We present the combination of a static, internally-linked module system and a purely abstractive component system. The latter extends our previous model of typed units to properly account for translucency and sharing. We also show how units and modules can express an SML-style system of structures and functors, and we explore the consequences for recursive structures and functors.", "paper_title": "From structures and functors to modules and units", "paper_id": "WOS:000202972400009"}