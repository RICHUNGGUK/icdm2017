{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "object_composition"}, {"score": 0.03992659287798476, "phrase": "run_time"}, {"score": 0.004767826806287385, "phrase": "class_inheritance"}, {"score": 0.004583878086896926, "phrase": "standard_class-based_languages"}, {"score": 0.004321118442104989, "phrase": "dynamic_behavior"}, {"score": 0.004133940019630129, "phrase": "different_forms"}, {"score": 0.004093453936415085, "phrase": "method_body_lookup"}, {"score": 0.003462599815177726, "phrase": "incomplete_featherweight_java"}, {"score": 0.0033288399506044763, "phrase": "featherweight_java"}, {"score": 0.0032800186243040663, "phrase": "novel_linguistic_construct"}, {"score": 0.0031845067058084613, "phrase": "incomplete_objects"}, {"score": 0.0031377955308198634, "phrase": "missing_methods"}, {"score": 0.002843372121209168, "phrase": "method_body"}, {"score": 0.0024768883044869023, "phrase": "consultation-based_lookup"}, {"score": 0.0024405312482831646, "phrase": "simple_extension"}, {"score": 0.002404706573379854, "phrase": "delegation-based_one"}, {"score": 0.002323142666222693, "phrase": "static_typing"}, {"score": 0.002255431275670053, "phrase": "type_safety"}, {"score": 0.0022005118194652704, "phrase": "\"message-not-understood\"_run-time_errors"}, {"score": 0.0021049977753042253, "phrase": "method_name_clashes"}], "paper_keywords": ["Language extensions", " Featherweight Java", " Object composition", " Delegation", " Consultation"], "paper_abstract": "Class inheritance and method overriding, as provided by standard class-based languages, are often not flexible enough to represent objects with some dynamic behavior. In this respect, object composition equipped with different forms of method body lookup is often advocated as a more flexible alternative to class inheritance since it takes place at run time, thus permitting the behavior of objects to be specialized dynamically. In this paper, we illustrate Incomplete Featherweight Java (IFJ), an extension of Featherweight Java with a novel linguistic construct, the incomplete object. Incomplete objects require some missing methods which can be provided at run time by composition with another (complete) object. Furthermore, we present two mechanisms for the method body lookup on (composed) objects, one based on delegation and the other based on consultation. Thanks to the design of the language, the consultation-based lookup is a simple extension of the delegation-based one. Both mechanisms are disciplined by static typing, therefore the language enjoys type safety (which implies no \"message-not-understood\" run-time errors) and avoids possible accidental overrides due to method name clashes. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Delegation by object composition", "paper_id": "WOS:000292671000003"}