{"auto_keywords": [{"score": 0.042616146611615016, "phrase": "ts"}, {"score": 0.030555654005410778, "phrase": "compression_factor"}, {"score": 0.00481495049065317, "phrase": "type_slicing"}, {"score": 0.004782631260642744, "phrase": "fundamental_problem"}, {"score": 0.0047292449487169345, "phrase": "object-oriented_languages"}, {"score": 0.004411238707599326, "phrase": "previous_theoretical_algorithms"}, {"score": 0.004293936328828505, "phrase": "large_hidden_constants"}, {"score": 0.0042459818200777846, "phrase": "successful_practical_heuristics"}, {"score": 0.004226949670141375, "phrase": "theoretical_support"}, {"score": 0.004133055661437163, "phrase": "novel_type_slicing_technique"}, {"score": 0.003916098498242888, "phrase": "empirical_findings"}, {"score": 0.0038290829316346654, "phrase": "eight_different_languages"}, {"score": 0.003786300145776278, "phrase": "previous_results"}, {"score": 0.003619878882843305, "phrase": "theoretical_analysis"}, {"score": 0.003555369476160024, "phrase": "best_possible_compression_factor"}, {"score": 0.003531474887552889, "phrase": "dispatching_matrix"}, {"score": 0.0034452224126541513, "phrase": "parameter_kappa"}, {"score": 0.003308587435077573, "phrase": "multiple_inheritance_hierarchy"}, {"score": 0.0032863459256972896, "phrase": "single_inheritance_hierarchies"}, {"score": 0.0030927608206968776, "phrase": "actual_use"}, {"score": 0.0030376164806204843, "phrase": "median_value"}, {"score": 0.0029567325862455054, "phrase": "ts_scheme"}, {"score": 0.002936849401568391, "phrase": "famous_interval_containment_technique"}, {"score": 0.0027950561494657633, "phrase": "space_requirement"}, {"score": 0.0027762571654110137, "phrase": "small_factor"}, {"score": 0.0027206133859493725, "phrase": "dispatching_time"}, {"score": 0.0026600905156986317, "phrase": "naive_matrix_implementation"}, {"score": 0.0026126405272417783, "phrase": "different_method_implementations"}, {"score": 0.0025089420019955232, "phrase": "ct_schemes"}, {"score": 0.0023504390264682757, "phrase": "single_inheritance_setting"}, {"score": 0.0023033100935570755, "phrase": "multiple_inheritance_setting"}, {"score": 0.0022218413146898887, "phrase": "first_bounds"}, {"score": 0.0022068891259005787, "phrase": "compression_ratio"}, {"score": 0.0021480776984218078, "phrase": "incremental_variant"}, {"score": 0.002105114063193976, "phrase": "java"}], "paper_keywords": ["algorithms", " design", " measurement", " performance", " theory", " CT (compact dispatch tables)", " dispatch", " dynamic-typing", " hierarchy", " incremental", " message", " subtyping", " type slicing"], "paper_abstract": "A fundamental problem in the implementation of object-oriented languages is that of a frugal implementation of dynamic dispatching, that is, a small footprint data structure that supports quick response to runtime dispatching queries of the following format: which method should be executed in response to a certain message sent to a given object. Previous theoretical algorithms for this problem tend to be impractical due to their conceptual complexity and large hidden constants. In contrast, successful practical heuristics lack theoretical support. The contribution of this article is in a novel type slicing technique, which results in two dispatching schemes: TS and CTd. We make the case for these schemes both practically and theoretically. The empirical findings on a corpus of 35 hierarchies totaling some 64 thousand types from eight different languages, demonstrate improvement over previous results in terms of the space required for the representation, and the time required for computing it. The theoretical analysis is with respect to iota, the best possible compression factor of the dispatching matrix. The results are expressed as a function of a parameter kappa, which can be thought of as a metric of the complexity of the topology of a multiple inheritance hierarchy. In single inheritance hierarchies kappa = 1, but although kappa can be in the order of the size of the hierarchy, it is typically a small constant in actual use of inheritance; in our corpus, the median value of kappa is 5, while its average is 6.4. The TS scheme generalizes the famous interval containment technique to multiple inheritance. TS achieves a compression factor of iota/kappa, that is, our generalization comes with an increase to the space requirement by a small factor of kappa. The pay is in the dispatching time, which is no longer constant as in a naive matrix implementation, but logarithmic in the number of different method implementations. In practice, dispatching uses one indirect branch and, on average, only 2.5 binary branches. The CT schemes are a sequence of algorithms CT1, CT2, CT3,..., where CTd uses d memory dereferencing operations during dispatch, and achieves a compression factor of 1/d iota(1-1/d) in a single inheritance setting. A generalization of these algorithms to a multiple inheritance setting, increases the space by a factor of (2 kappa)(1-1/d). This trade-off represents the first bounds on the compression ratio of constant-time dispatching algorithms. We also present an incremental variant of the CTd suited for languages such as Java.", "paper_title": "Efficient dynamic dispatching, with type slicing", "paper_id": "WOS:000252153400005"}