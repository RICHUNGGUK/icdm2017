{"auto_keywords": [{"score": 0.04767496358428856, "phrase": "web_services"}, {"score": 0.010612387000973441, "phrase": "rollback_recovery"}, {"score": 0.009841343075791341, "phrase": "atomic_web_services"}, {"score": 0.008859018040929471, "phrase": "web_service"}, {"score": 0.004788936788674301, "phrase": "composite_web_services"}, {"score": 0.004673595320100892, "phrase": "service-oriented_reliability_model"}, {"score": 0.004499647408293102, "phrase": "real-time_reliabilities"}, {"score": 0.004367508141547766, "phrase": "hybrid_reliability_model"}, {"score": 0.004355688788648902, "phrase": "based_on_both_path-based_and_state-based_models"}, {"score": 0.0042738402587223084, "phrase": "failure_or_error_arrival_times"}, {"score": 0.00414830454375092, "phrase": "error_arrival_times"}, {"score": 0.004092463367307375, "phrase": "operating_state"}, {"score": 0.0038450838990545886, "phrase": "doubly_stochastic_model"}, {"score": 0.003487453200471476, "phrase": "real-world_applications"}, {"score": 0.0034311578789991363, "phrase": "quite_a_large_number"}, {"score": 0.0033302915283097367, "phrase": "computing_complexity"}, {"score": 0.0032148895624688188, "phrase": "bounded_set_techniques"}, {"score": 0.0031629800646754505, "phrase": "previously_developed_stochastic_model"}, {"score": 0.003128838753643307, "phrase": "first_type"}, {"score": 0.0031119061114737267, "phrase": "system_combination"}, {"score": 0.0030040488740349664, "phrase": "parallel_and_serial_configurations"}, {"score": 0.002899919044381904, "phrase": "acceptance_testing_mechanism"}, {"score": 0.0028376361457661415, "phrase": "particular_web_service"}, {"score": 0.0027392588585718894, "phrase": "next_web_service"}, {"score": 0.0026299659007534516, "phrase": "checkpoint_algorithm"}, {"score": 0.002594510142298757, "phrase": "acceptance_test"}, {"score": 0.002497750121448195, "phrase": "single_point"}, {"score": 0.0023657330062474996, "phrase": "broker_level"}, {"score": 0.0023338311552207457, "phrase": "modified_general_scheme"}, {"score": 0.0023148964315569866, "phrase": "triple_modular_redundancy"}, {"score": 0.0023023585070519803, "phrase": "n-version_programming"}, {"score": 0.0022713093139061277, "phrase": "real_scenario"}, {"score": 0.0021806461242374685, "phrase": "service_qos"}, {"score": 0.002162951519368368, "phrase": "proposed_model"}, {"score": 0.002139581380750111, "phrase": "fault-tolerance_techniques"}, {"score": 0.0021049977753042253, "phrase": "recovery_block_technique"}], "paper_keywords": ["Bounded set", " broker", " checkpoint", " dependability", " doubly stochastic model", " rollback", " semi-Markov process", " series-parallel systems"], "paper_abstract": "In this paper, we propose a service-oriented reliability model that dynamically calculates the reliability of composite web services with rollback recovery based on the real-time reliabilities of the atomic web services of the composition. Our model is a hybrid reliability model based on both path-based and state-based models. Many reliability models assume that failure or error arrival times are exponentially distributed. This is inappropriate for web services as error arrival times are dependent on the operating state including workload of servers where the web service resides. In this manuscript, we modify our previous model (for software based on the Doubly Stochastic Model and Renewal Processes) to evaluate the reliability of atomic web services. In order to fix our idea, we developed the case of one simple web service which contains two states, i.e., idle and active states. In real-world applications, where web services could contain quite a large number of atomic services, the calculus as well as the computing complexity increases greatly. To limit our computing efforts and calculus, we chose the bounded set techniques that we apply using the previously developed stochastic model. As a first type of system combination, we proposed to study a scheme based on combining web services into parallel and serial configurations with centralized coordination. In this case, the broker has an acceptance testing mechanism that examines the results returned from a particular web service. If it was acceptable, then the computation continues to the next web service. Otherwise, it involves rollback and invokes another web service already specified by a checkpoint algorithm. Finally, the acceptance test is conducted using the broker. The broker can be considered as a single point of failure. To increase the reliability of the broker introduced in our systems and mask out errors at the broker level, we suggest a modified general scheme based on Triple modular redundancy and N-version programming. To imitate a real scenario where errors could happen at any stage of our application and improve the quality of Service QoS of the proposed model, we introduce fault-tolerance techniques using an adaption of the recovery block technique.", "paper_title": "Dependability and Rollback Recovery for Composite Web Services", "paper_id": "WOS:000300880700007"}