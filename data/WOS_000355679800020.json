{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "waiting_queues"}, {"score": 0.004735254735115024, "phrase": "new_libraries"}, {"score": 0.004656871909510407, "phrase": "grand_central_dispatch"}, {"score": 0.004392565073466714, "phrase": "multicore_platforms"}, {"score": 0.004266067096140677, "phrase": "concurrent_software"}, {"score": 0.004195418010131832, "phrase": "software_engineers"}, {"score": 0.004040688646993605, "phrase": "so-called_blocks"}, {"score": 0.0038431888954930083, "phrase": "synchronous_or_asynchronous_calls"}, {"score": 0.0035648266669315943, "phrase": "available_cores"}, {"score": 0.003536094661786819, "phrase": "blocks"}, {"score": 0.0034620831765465425, "phrase": "global_memory"}, {"score": 0.0033482708495261864, "phrase": "queue-dispatch_asynchronous_systems"}, {"score": 0.003306559295382181, "phrase": "mathematical_model"}, {"score": 0.0032381878248821383, "phrase": "synchronization_mechanisms"}, {"score": 0.003028727936200845, "phrase": "classical_formalisms"}, {"score": 0.0029909851863915283, "phrase": "pushdown_systems"}, {"score": 0.0029661107156742144, "phrase": "petri"}, {"score": 0.0028209599545587745, "phrase": "precise_worst-case_complexity_results"}, {"score": 0.0027858160868609936, "phrase": "parikh"}, {"score": 0.002728166176898539, "phrase": "termination_problem"}, {"score": 0.0025946532067459603, "phrase": "qdas"}, {"score": 0.0025623050508233078, "phrase": "fork-join_mechanism"}, {"score": 0.002376495929405298, "phrase": "coverability_problem"}, {"score": 0.0022507188208913394, "phrase": "handmade_abstractions"}, {"score": 0.0022226496830385304, "phrase": "practical_way"}, {"score": 0.00212268510072928, "phrase": "decidable_subclasses"}, {"score": 0.0021049977753042253, "phrase": "qdas."}], "paper_keywords": ["Algorithms", " Theory", " Verification", " Asynchronous programming", " waiting queues"], "paper_abstract": "Recently, new libraries, such as Grand Central Dispatch (GCD), have been proposed to directly harness the power of multicore platforms and to make the development of concurrent software more accessible to software engineers. When using such a library, the programmer writes so-called blocks, which are chunks of code, and dispatches them using synchronous or asynchronous calls to several types of waiting queues. A scheduler is then responsible for dispatching those blocks among the available cores. Blocks can synchronize via a global memory. In this article, we propose Queue-Dispatch Asynchronous Systems as a mathematical model that faithfully formalizes the synchronization mechanisms and behavior of the scheduler in those systems. We study in detail their relationships to classical formalisms such as pushdown systems, Petri nets, FIFO systems, and counter systems. Our main technical contributions are precise worst-case complexity results for the Parikh coverability problem and the termination problem for several subclasses of our model. We also consider an extension of QDAS with a fork-join mechanism. Adding fork-join to any of the subclasses that we have identified leads to undecidability of the coverability problem. This motivates the study of over-approximations. Finally, we consider handmade abstractions as a practical way of verifying programs that cannot be faithfully modeled by decidable subclasses of QDAS.", "paper_title": "On the Verification of Concurrent, Asynchronous Programs with Waiting Queues", "paper_id": "WOS:000355679800020"}