{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "custom_hardware_instruction_processor_synthesis"}, {"score": 0.014455254376273548, "phrase": "custom_instructions"}, {"score": 0.004377077848734575, "phrase": "critical_code_segments"}, {"score": 0.004285289574869884, "phrase": "available_data_bandwidth"}, {"score": 0.004173244935967375, "phrase": "custom_logic"}, {"score": 0.0041074234667687875, "phrase": "baseline_processor"}, {"score": 0.004064117897000019, "phrase": "architecturally_visible_state_registers"}, {"score": 0.003773449694108617, "phrase": "output_operands"}, {"score": 0.0036359780843400625, "phrase": "design_flow"}, {"score": 0.003578600071301459, "phrase": "promising_area"}, {"score": 0.0029253546782349875, "phrase": "highest_performance"}, {"score": 0.0027159094186967247, "phrase": "frequently_used_code_segments"}, {"score": 0.002658863179011018, "phrase": "overall_area_overhead"}, {"score": 0.002231607958228148, "phrase": "maximum_speed-up"}, {"score": 0.0021387992835532367, "phrase": "basic_blocks"}], "paper_keywords": ["application-specific instruction-set processors (ASIPs)", " custom instructions", " customizable processors", " extensible processors", " integer linear programming (ILP)", " optimization algorithms"], "paper_abstract": "his paper describes an integer-linear-programming (ILP)-based system called Custom Hardware Instruction Processor Synthesis (CHIPS) that identifies custom instructions for critical code segments, given the available data bandwidth and transfer latencies between custom logic and a baseline processor with architecturally visible state registers. Our approach enables designers to optionally constrain the number of input and output operands for custom instructions. We describe a design flow to identify promising area, performance, and code-size tradeoffs. We study the effect of input/output constraints, register-file ports, and compiler transformations such as if-conversion. Our experiments show that, in most cases, the solutions with the highest performance are identified when the input/output constraints are removed. However, input/output constraints help our algorithms identify frequently used code segments, reducing the overall area overhead. Results for 11 benchmarks covering cryptography and multimedia are shown, with speed-ups between 1.7 and 6.6 times, code-size reductions between 6% and 72%, and area costs ranging between 12 and 256 adders for maximum speed-up. Our ILP-based approach scales well: benchmarks with basic blocks consisting of more than 1000 instructions can be optimally solved, most of the time within a few seconds.", "paper_title": "CHIPS: Custom Hardware Instruction Processor Synthesis", "paper_id": "WOS:000253840500011"}