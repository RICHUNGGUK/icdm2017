{"auto_keywords": [{"score": 0.04964156968469261, "phrase": "gpu_kernels"}, {"score": 0.00481495049065317, "phrase": "verification_technique"}, {"score": 0.004598933498016774, "phrase": "formal_verification"}, {"score": 0.004453488286477661, "phrase": "correctness_properties"}, {"score": 0.004195418010131832, "phrase": "novel_formal_operational_semantics"}, {"score": 0.00415737515605372, "phrase": "gpu"}, {"score": 0.0038802832668554457, "phrase": "gpu_kernel"}, {"score": 0.0038447943243941685, "phrase": "multiple_groups"}, {"score": 0.003757480190200645, "phrase": "sdv_semantics"}, {"score": 0.0037231102027070724, "phrase": "operational_definitions"}, {"score": 0.003689053436223376, "phrase": "barrier_divergence"}, {"score": 0.0035887342563437935, "phrase": "intra-group_data_races"}, {"score": 0.0033037970113095577, "phrase": "massively_parallel_gpu_kernel"}, {"score": 0.003213920601037463, "phrase": "sequential_program"}, {"score": 0.0030695103543472908, "phrase": "thread_interleavings"}, {"score": 0.0030135741897058844, "phrase": "existing_techniques"}, {"score": 0.002985988377995789, "phrase": "sequential_program_verification"}, {"score": 0.002878140062594849, "phrase": "efficient_encoding"}, {"score": 0.002851790448644913, "phrase": "data_race_detection"}, {"score": 0.0027361626349903744, "phrase": "loop_invariants"}, {"score": 0.0025655216052760093, "phrase": "practical_verification_tool"}, {"score": 0.0025420267431501367, "phrase": "gpuverify"}, {"score": 0.0024501923237325676, "phrase": "opencl"}, {"score": 0.0024277785360429867, "phrase": "cuda"}, {"score": 0.002255431275670053, "phrase": "public_and_commercial_sources"}, {"score": 0.002124461969404541, "phrase": "large_number"}, {"score": 0.0021049977753042253, "phrase": "real-world_kernels"}], "paper_keywords": ["Theory", " Verification", " Verification", " GPUs", " concurrency", " data races", " barrier synchronization"], "paper_abstract": "We present a technique for the formal verification of GPU kernels, addressing two classes of correctness properties: data races and barrier divergence. Our approach is founded on a novel formal operational semantics for GPU kernels termed synchronous, delayed visibility (SDV) semantics, which captures the execution of a GPU kernel by multiple groups of threads. The SDV semantics provides operational definitions for barrier divergence and for both inter- and intra-group data races. We build on the semantics to develop a method for reducing the task of verifying a massively parallel GPU kernel to that of verifying a sequential program. This completely avoids the need to reason about thread interleavings, and allows existing techniques for sequential program verification to be leveraged. We describe an efficient encoding of data race detection and propose a method for automatically inferring the loop invariants that are required for verification. We have implemented these techniques as a practical verification tool, GPUVerify, that can be applied directly to OpenCL and CUDA source code. We evaluate GPUVerify with respect to a set of 162 kernels drawn from public and commercial sources. Our evaluation demonstrates that GPUVerify is capable of efficient, automatic verification of a large number of real-world kernels.", "paper_title": "The Design and Implementation of a Verification Technique for GPU Kernels", "paper_id": "WOS:000356699500003"}