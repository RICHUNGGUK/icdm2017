{"auto_keywords": [{"score": 0.03696631279974888, "phrase": "apma"}, {"score": 0.007684042288905163, "phrase": "pma"}, {"score": 0.0073536890636413, "phrase": "sorted_order"}, {"score": 0.005404588140217749, "phrase": "traditional_pma"}, {"score": 0.00505908235488984, "phrase": "amortized_memory_transfers"}, {"score": 0.00481495049065317, "phrase": "packed-memory_array"}, {"score": 0.00471003041684707, "phrase": "data_structure"}, {"score": 0.004641351004344458, "phrase": "dynamic_set"}, {"score": 0.0046073860169839305, "phrase": "n_elements"}, {"score": 0.004408729661992651, "phrase": "empty_spaces"}, {"score": 0.0040734753169135865, "phrase": "random_elements"}, {"score": 0.0037643920253363776, "phrase": "extremely_efficient_range_queries"}, {"score": 0.0036418947847496365, "phrase": "consecutive_elements"}, {"score": 0.003536346954940087, "phrase": "first_adaptive_packed-memory_array"}, {"score": 0.003408688677676014, "phrase": "input_pattern"}, {"score": 0.00322576184471691, "phrase": "element_moves"}, {"score": 0.0029641011108505785, "phrase": "amortized_element_moves"}, {"score": 0.002846549461929597, "phrase": "sequential_inserts"}, {"score": 0.0024299678474208023, "phrase": "constant_alpha"}, {"score": 0.0023335495163073544, "phrase": "n-alpha_elements"}, {"score": 0.0022741894748181243, "phrase": "apma."}, {"score": 0.0022327141073440436, "phrase": "simulation_results"}, {"score": 0.002183938718432764, "phrase": "asymptotic_bounds"}, {"score": 0.002159951198924152, "phrase": "sequential_insertions"}], "paper_keywords": ["algorithms", " experimentation", " performance", " theory", " adaptive packed-memory array", " cache oblivious", " locality preserving", " packed-memory array", " range query", " rebalance", " sequential file maintenance", " sequential scan", " sparse array"], "paper_abstract": "The packed-memory array (PMA) is a data structure that maintains a dynamic set of N elements in sorted order in a Theta(N)-sized array. The idea is to intersperse Theta(N) empty spaces or gaps among the elements so that only a small number of elements need to be shifted around on an insert or delete. Because the elements are stored physically in sorted order in memory or on disk, the PMA can be used to support extremely efficient range queries. Specifically, the cost to scan L consecutive elements is O(1 + L/B) memory transfers. This article gives the first adaptive packed-memory array (APMA), which automatically adjusts to the input pattern. Like the traditional PMA, any pattern of updates costs only O(log(2)N) amortized element moves and O(1 + (log(2)N)/B) amortized memory transfers per update. However, the APMA performs even better on many common input distributions achieving only O(log N) amortized element moves and O(1 +(log N)/B) amortized memory transfers. The article analyzes sequential inserts, where the insertions are to the front of the APMA, hammer inserts, where the insertions \"hammer\" on one part of the APMA, random inserts, where the insertions are after random elements in the APMA, and bulk inserts, where for constant alpha is an element of [0, 1], N-alpha elements are inserted after random elements in the APMA. The article then gives simulation results that are consistent with the asymptotic bounds. For sequential insertions of roughly 1.4 million elements, the APMA has four times fewer element moves per insertion than the traditional PMA and running times that are more than seven times faster.", "paper_title": "An adaptive packed-memory array", "paper_id": "WOS:000251588500007"}