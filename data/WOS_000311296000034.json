{"auto_keywords": [{"score": 0.04687389678833664, "phrase": "higher-order_recursion_schemes"}, {"score": 0.025253211372681248, "phrase": "functional_programs"}, {"score": 0.0048150134208227975, "phrase": "traversal"}, {"score": 0.0047597635659244655, "phrase": "algorithm_for_higher-order_model_checking"}, {"score": 0.00442457549952546, "phrase": "natural_generalisation"}, {"score": 0.004390689303780405, "phrase": "finite-state_and_pushdown_model_checking"}, {"score": 0.004160612392068268, "phrase": "software_model"}, {"score": 0.004112894218792621, "phrase": "functional_languages"}, {"score": 0.004066015341180544, "phrase": "ml"}, {"score": 0.004034620067450535, "phrase": "haskell"}, {"score": 0.003779223830897226, "phrase": "hors"}, {"score": 0.003622642432563435, "phrase": "program_branching"}, {"score": 0.003328611206488653, "phrase": "universal_horsc_model"}, {"score": 0.0032777653153451265, "phrase": "deterministic_trivial_automata"}, {"score": 0.003154012038613403, "phrase": "tree_language"}, {"score": 0.0030938932434437178, "phrase": "horsc"}, {"score": 0.0029656229252935417, "phrase": "intersection_type_system"}, {"score": 0.0029203055813347874, "phrase": "carefully_restricted_form"}, {"score": 0.0028979065012624044, "phrase": "union_types"}, {"score": 0.002788454815865172, "phrase": "model_checking_problem"}, {"score": 0.0026523079380037706, "phrase": "fully_abstract_game_semantics"}, {"score": 0.0025619562094446884, "phrase": "goal-directed_construction"}, {"score": 0.002493810638588771, "phrase": "union_type_system"}, {"score": 0.0024556852466581527, "phrase": "horsc_model_checking"}, {"score": 0.002427473263013356, "phrase": "suitable_backend_engine"}, {"score": 0.002273605493468005, "phrase": "travmc"}, {"score": 0.002213112756450354, "phrase": "test_suite"}, {"score": 0.0021708894366462153, "phrase": "abstract_models"}, {"score": 0.002121281184742656, "phrase": "abstraction-refinement_procedure"}, {"score": 0.0021049977753042253, "phrase": "pattern-matching_recursion_schemes"}], "paper_keywords": ["Algorithms", " Verification", " Model-checking", " Higher-order Programs"], "paper_abstract": "Higher-order model checking-the model checking of trees generated by higher-order recursion schemes (HORS)-is a natural generalisation of finite-state and pushdown model checking. Recent work has shown that it can serve as a basis for software model checking for functional languages such as ML and Haskell. In this paper, we introduce higher-order recursion schemes with cases (HORSC), which extend HORS with a definition-by-cases construct (to express program branching based on data) and non-determinism (to express abstractions of behaviours). This paper is a study of the universal HORSC model checking problem for deterministic trivial automata: does the automaton accept every tree in the tree language generated by the given HORSC? We first characterise the model checking problem by an intersection type system extended with a carefully restricted form of union types. We then present an algorithm for deciding the model checking problem, which is based on the notion of traversals induced by the fully abstract game semantics of these schemes, but presented as a goal-directed construction of derivations in the intersection and union type system. We view HORSC model checking as a suitable backend engine for an approach to verifying functional programs. We have implemented the algorithm in a tool called TRAVMC, and demonstrated its effectiveness on a test suite of programs, including abstract models of functional programs obtained via an abstraction-refinement procedure from pattern-matching recursion schemes.", "paper_title": "A Traversal-based Algorithm for Higher-Order Model Checking", "paper_id": "WOS:000311296000034"}