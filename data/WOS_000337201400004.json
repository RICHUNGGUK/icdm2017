{"auto_keywords": [{"score": 0.04730925038469872, "phrase": "distributed_computing"}, {"score": 0.028464780788350665, "phrase": "sorting_network"}, {"score": 0.00481495049065317, "phrase": "asynchronous_renaming"}, {"score": 0.004714869813251479, "phrase": "first_tight_bounds"}, {"score": 0.004665608609734034, "phrase": "time_complexity"}, {"score": 0.004633052743252902, "phrase": "shared-memory_renaming"}, {"score": 0.004380616732302083, "phrase": "distinct_identifiers"}, {"score": 0.004334832612029898, "phrase": "small_namespace"}, {"score": 0.0041129612315045, "phrase": "deterministic_renaming"}, {"score": 0.003754847652236926, "phrase": "exponential_separation"}, {"score": 0.0037286231222250065, "phrase": "deterministic_and_randomized_solutions"}, {"score": 0.0036767202303156854, "phrase": "new_tight_bounds"}, {"score": 0.003651039356522665, "phrase": "deterministic_concurrent_fetch-and-increment_counters"}, {"score": 0.0034884152484429207, "phrase": "new_reduction"}, {"score": 0.0034278075289561213, "phrase": "fundamental_problem"}, {"score": 0.003263631515158206, "phrase": "global_lower_bound"}, {"score": 0.0031845067058084613, "phrase": "total_step_complexity"}, {"score": 0.0029688173975648173, "phrase": "randomized_algorithms"}, {"score": 0.002937745193225725, "phrase": "strong_adversary"}, {"score": 0.0028866770996648057, "phrase": "new_global_lower_bounds"}, {"score": 0.0028664985822266344, "phrase": "randomized_approximate_counter_implementations"}, {"score": 0.0028068030356445894, "phrase": "logarithmic_factors"}, {"score": 0.002767696345005216, "phrase": "algorithmic_side"}, {"score": 0.002653606593103781, "phrase": "randomized_strong_adaptive_renaming_algorithm"}, {"score": 0.0025087506382067536, "phrase": "tight_adaptive_renaming_algorithm"}, {"score": 0.002371783323468861, "phrase": "current_execution"}, {"score": 0.002298044430178591, "phrase": "sublinear_time"}, {"score": 0.0021649437083408425, "phrase": "renaming_protocol"}, {"score": 0.0021422669204408263, "phrase": "monotone-consistent_counters"}, {"score": 0.002127280894809367, "phrase": "logarithmic_step_complexity"}, {"score": 0.0021049977753042253, "phrase": "fetch-and-increment_registers"}], "paper_keywords": ["Theory", " Algorithms", " Performance", " Distributed computing", " shared memory", " concurrent data structures", " renaming", " lower bounds"], "paper_abstract": "This article presents the first tight bounds on the time complexity of shared-memory renaming, a fundamental problem in distributed computing in which a set of processes need to pick distinct identifiers from a small namespace. We first prove an individual lower bound of P(h) process steps for deterministic renaming into any namespace of size subexponential in k, where k is the number of participants. The bound is tight: it draws an exponential separation between deterministic and randomized solutions, and implies new tight bounds for deterministic concurrent fetch-and-increment counters, queues, and stacks. The proof is based on a new reduction from renaming to another fundamental problem in distributed computing: mutual exclusion. We complement this individual bound with a global lower bound of Omega(k log(k/c)) on the total step complexity of renaming into a namespace of size ck, for any c >= 1. This result applies to randomized algorithms against a strong adversary, and helps derive new global lower bounds for randomized approximate counter implementations, that are tight within logarithmic factors. On the algorithmic side, we give a protocol that transforms any sorting network into a randomized strong adaptive renaming algorithm, with expected cost equal to the depth of the sorting network. This gives a tight adaptive renaming algorithm with expected step complexity O(log k), where k is the contention in the current execution. This algorithm is the first to achieve sublinear time, and it is time-optimal as per our randomized lower bound. Finally, we use this renaming protocol to build monotone-consistent counters with logarithmic step complexity and linearizable fetch-and-increment registers with polylogarithmic cost.", "paper_title": "Tight Bounds for Asynchronous Renaming", "paper_id": "WOS:000337201400004"}