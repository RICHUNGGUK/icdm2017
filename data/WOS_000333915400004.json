{"auto_keywords": [{"score": 0.04957891638694611, "phrase": "closed-world_assumption"}, {"score": 0.009632217786704608, "phrase": "type_flow_analysis"}, {"score": 0.00481495049065317, "phrase": "object-oriented_languages"}, {"score": 0.004698392162272106, "phrase": "best_level"}, {"score": 0.004665608609734034, "phrase": "runtime_performance"}, {"score": 0.0045846424310611745, "phrase": "object-oriented_language"}, {"score": 0.004334832612029898, "phrase": "source_code"}, {"score": 0.0042446888127531945, "phrase": "compile_time"}, {"score": 0.004098578483988551, "phrase": "efficient_code"}, {"score": 0.004027412633636142, "phrase": "multiple_inheritance"}, {"score": 0.003929843413153981, "phrase": "single_inheritance"}, {"score": 0.003821215658570578, "phrase": "prolonged_project"}, {"score": 0.003525291235622844, "phrase": "dynamic_dispatch"}, {"score": 0.003240826566478551, "phrase": "global_strategy"}, {"score": 0.003021334228842501, "phrase": "compiler_writers"}, {"score": 0.0029069972482610403, "phrase": "fundamental_aspect"}, {"score": 0.0028564621282167685, "phrase": "method_calls"}, {"score": 0.00268168157806506, "phrase": "additional_expressions"}, {"score": 0.002598333022293788, "phrase": "true_global_analysis"}, {"score": 0.002544207840990836, "phrase": "method_call_sites"}, {"score": 0.0024307637980373552, "phrase": "numerous_applications"}, {"score": 0.002396883802324751, "phrase": "even_library-defined_control_statements"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["object-oriented", " code customization", " type flow analysis", " compiler", " dynamic dispatch", " inlining"], "paper_abstract": "Reaching the best level of runtime performance from a high-level, object-oriented language is often considered challenging if not unattainable. The closed-world assumption involves considering all of the source code of an application together at compile time. That assumption makes it possible to produce an efficient code. For instance, multiple inheritance can be implemented as efficiently as single inheritance. Our compilation strategy is the result of a prolonged project, tying together several compilation techniques: call graph analysis, dead code elimination, type flow analysis, code customization, implementation of dynamic dispatch, inlining, pointer optimization, switch optimization, objects layout, and so on. Merging all of these techniques into a global strategy appears to be quite problematic. Throughout the paper, two real-world compilers are used as benchmarks to provide measurements for compiler writers to evaluate the applicability of our approach. Type flow analysis is a fundamental aspect of our strategy to resolve method calls. We have extended type flow analysis to deal with the content of arrays, enabling us to process additional expressions and thus making it possible to obtain a true global analysis. Typically, more than 90% of method call sites are statically resolved. Our experience indicates that the closed-world assumption is suitable for numerous applications. Surprisingly, even library-defined control statements from dynamic languages are perfectly processed with our strategy. The Smalltalk ifTrue:ifFalse:, whileTrue:, to:do:, and so on are, for the very first time, perfectly translated. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "Efficient compilation strategy for object-oriented languages under the closed-world assumption", "paper_id": "WOS:000333915400004"}