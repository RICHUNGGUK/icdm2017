{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "recursive_programs"}, {"score": 0.01428415192522294, "phrase": "reference_fields"}, {"score": 0.013869013552687534, "phrase": "local_variables"}, {"score": 0.01302594455035356, "phrase": "unbounded_number"}, {"score": 0.0077009168669945885, "phrase": "model_checking"}, {"score": 0.00470862827326028, "phrase": "almost_all_modern_imperative_programming_languages"}, {"score": 0.004274257668843717, "phrase": "recursive_procedures"}, {"score": 0.0038510053729959074, "phrase": "call_stack"}, {"score": 0.003601235776892337, "phrase": "static_analysis"}, {"score": 0.0035479614996805383, "phrase": "dynamic_manipulation"}, {"score": 0.003280891942617853, "phrase": "unbounded_allocation"}, {"score": 0.0032083351151314405, "phrase": "simple_imperative_language"}, {"score": 0.0031845067058084583, "phrase": "heap_manipulation"}, {"score": 0.0027741761880779535, "phrase": "bounded_visible_heap"}, {"score": 0.0025461386232786356, "phrase": "finitary_representation"}, {"score": 0.002268088741853586, "phrase": "specification_language"}, {"score": 0.0021850254717637172, "phrase": "invariant_properties"}, {"score": 0.0021687806803474367, "phrase": "heap-manipulating_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Heap manipulation", " Pushdown system", " Object-oriented program semantics", " Model checking"], "paper_abstract": "Almost all modern imperative programming languages include operations for dynamically manipulating the heap, for example by allocating and deallocating objects, and by updating reference fields. In the presence of recursive procedures and local variables, the interactions of a program with the heap can become rather complex, as an unbounded number of objects can be allocated either on the call stack using local variables, or, anonymously, on the heap using reference fields. As such, a static analysis for recursive programs with dynamic manipulation of the heap is, in general, undecidable. In this paper we study the verification of recursive programs with unbounded allocation of objects, in a simple imperative language with heap manipulation. We present a semantics for this language which is improved w.r.t. heap allocation, using an abstraction that is precise (i.e., bisimilar with the standard/concrete semantics). For any program with a bounded visible heap, meaning that the number of objects reachable from variables at any point of execution is bounded, this abstraction is a finitary representation of its behaviour, even though an unbounded number of objects can appear in the state. As a consequence, for such programs model checking is decidable. Finally, we introduce a specification language for heap-properties, and we discuss model checking of heap invariant properties against heap-manipulating programs. (C) 2014 Published by Elsevier B.V.", "paper_title": "Model checking recursive programs interacting via the heap", "paper_id": "WOS:000349731300004"}