{"auto_keywords": [{"score": 0.040480529068256305, "phrase": "nominal_unification"}, {"score": 0.015719716506582538, "phrase": "nominal_logic"}, {"score": 0.0047113960612140335, "phrase": "first-order_logic"}, {"score": 0.0044524122425287005, "phrase": "underlying_concepts"}, {"score": 0.004225950334493496, "phrase": "logic_programming"}, {"score": 0.0041170581247889654, "phrase": "automated_theorem"}, {"score": 0.003806866174028117, "phrase": "equational_reasoning"}, {"score": 0.0036926316547984763, "phrase": "urban"}, {"score": 0.0036606200838357906, "phrase": "pitts"}, {"score": 0.003628884472034002, "phrase": "gabbay"}, {"score": 0.003535320700255283, "phrase": "broadly_applicable_class"}, {"score": 0.003504670673093149, "phrase": "nominal_unification_problems"}, {"score": 0.0034143003168921114, "phrase": "nominal_logic's_equivariance_property"}, {"score": 0.003311799410921826, "phrase": "different_form"}, {"score": 0.0030223381739019894, "phrase": "decision_problem"}, {"score": 0.002996122158460243, "phrase": "equivariant_unification"}, {"score": 0.0029701328654852246, "phrase": "equivariant_matching"}, {"score": 0.0028689889861342544, "phrase": "np"}, {"score": 0.0027341763737751467, "phrase": "ground-name_restrictions"}, {"score": 0.0026986685585382347, "phrase": "previous_work"}, {"score": 0.002594880866651459, "phrase": "exponential-time_algorithm"}, {"score": 0.0024306740161601625, "phrase": "complete_finite_set"}, {"score": 0.002357632753637638, "phrase": "special_cases"}, {"score": 0.0022277448907881306, "phrase": "polynomial_time_algorithm"}, {"score": 0.0022084059770026416, "phrase": "swapping-free_equivariant_matching"}, {"score": 0.0021049977753042253, "phrase": "swapping_operation"}], "paper_keywords": ["Nominal logic", " Nominal unification", " Equivariance"], "paper_abstract": "Nominal logic is a variant of first-order logic with special facilities for reasoning about names and binding based on the underlying concepts of swapping and freshness. It serves as the basis of logic programming, term rewriting, and automated theorem proving techniques that support reasoning about languages with name-binding. These applications often require nominal unification, or equational reasoning and constraint solving in nominal logic. Urban, Pitts and Gabbay developed an algorithm for a broadly applicable class of nominal unification problems. However, because of nominal logic's equivariance property, these applications also require a different form of unification, which we call equivariant unification. In this article, we first study the complexity of the decision problem for equivariant unification and equivariant matching. We show that these problems are NP-hard in general, as is nominal unification without the ground-name restrictions employed in previous work on nominal unification. Moreover, we present an exponential-time algorithm for equivariant unification that can be used to decide satisfiability, or produce a complete finite set of solutions. We also study special cases that can be solved efficiently. In particular, we present a polynomial time algorithm for swapping-free equivariant matching, that is, for matching problems in which the swapping operation does not appear.", "paper_title": "Equivariant Unification", "paper_id": "WOS:000281694000003"}