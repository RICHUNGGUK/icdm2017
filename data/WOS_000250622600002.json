{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "switch_on_event"}, {"score": 0.03868050804560161, "phrase": "event_multithreading"}, {"score": 0.004612896435506914, "phrase": "low-power_and_low-complexity_mechanism"}, {"score": 0.004453874101119545, "phrase": "execution_stalls"}, {"score": 0.004250302819248558, "phrase": "multithreaded_processor"}, {"score": 0.00396218934254591, "phrase": "processor_cycles"}, {"score": 0.003781005930058317, "phrase": "simultaneous_multithreading"}, {"score": 0.0035940277928341265, "phrase": "fairness_metric"}, {"score": 0.0035108659422301985, "phrase": "individual_threads'_speedups"}, {"score": 0.0033504196896501333, "phrase": "fairness"}, {"score": 0.0032855095476183372, "phrase": "additional_thread_switch_points"}, {"score": 0.0032472646337850073, "phrase": "switch_points"}, {"score": 0.0031845067058084583, "phrase": "runtime_estimation"}, {"score": 0.0031474338010045386, "phrase": "single_threaded_performance"}, {"score": 0.0030865992688177005, "phrase": "individual_threads"}, {"score": 0.0029916929549256297, "phrase": "fairness_enforcement_mechanism"}, {"score": 0.002968424524565369, "phrase": "aggregate_ipc"}, {"score": 0.002888396879326153, "phrase": "simulation_results"}, {"score": 0.0027240799841720957, "phrase": "average_aggregate_ipc_increase"}, {"score": 0.002681859084438076, "phrase": "single_thread"}, {"score": 0.002490053106007765, "phrase": "poor_fairness"}, {"score": 0.0022583704173318123, "phrase": "proposed_mechanism"}, {"score": 0.002197443382039439, "phrase": "different_levels"}, {"score": 0.0021049977753042253, "phrase": "weighted_speedup"}], "paper_keywords": ["design", " performance", " switch on event multithreading", " SOE", " coarse-grained multi-threading", " multithreading", " fairness", " performance", " throughput", " weighted speedup"], "paper_abstract": "The need to reduce power and complexity will increase the interest in Switch On Event multithreading (coarse-grained multithreading). Switch On Event multithreading is a low-power and low-complexity mechanism to improve processor throughput by switching threads on execution stalls. Fairness may, however, become a problem in a multithreaded processor. Unless fairness is properly handled, some threads may starve while others consume all of the processor cycles. Heuristics that were devised in order to improve fairness in simultaneous multithreading are not applicable to Switch On Event multithreading. This paper defines the fairness metric using the ratio of the individual threads' speedups and shows how it can be enforced in Switch On Event multithreading. Fairness is controlled by forcing additional thread switch points. These switch points are determined dynamically by runtime estimation of the single threaded performance of each of the individual threads. We analyze the impact of the fairness enforcement mechanism on aggregate IPC and weighted speedup. We present simulation results of the performance of Switch On Event multithreading. Switch On Event multithreading achieves an average aggregate IPC increase of 26% over single thread and 12% weighted speedup when no fairness is enforced. In this case, a sixth of our runs resulted in poor fairness in which one thread ran extremely slowly (10 to 100 times slower than its single-thread performance), while the other thread's performance was hardly affected.. By using the proposed mechanism, we can guarantee fairness at different levels of strictness and, in most cases, even improve the weighted speedup.", "paper_title": "Fairness enforcement in switch on event multithreading", "paper_id": "WOS:000250622600002"}