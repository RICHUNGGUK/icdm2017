{"auto_keywords": [{"score": 0.04179897773189256, "phrase": "separation_logic"}, {"score": 0.03824046507309785, "phrase": "heap-dependent_expressions"}, {"score": 0.03235333437738429, "phrase": "predicate_definitions"}, {"score": 0.0305135299280402, "phrase": "standard_first-order_provers"}, {"score": 0.004719359108879602, "phrase": "imperative_programs"}, {"score": 0.004644247838681628, "phrase": "mutable_state"}, {"score": 0.00458869631642791, "phrase": "frame_problem"}, {"score": 0.004497576466646301, "phrase": "data_abstraction"}, {"score": 0.00426900754050533, "phrase": "upper_bounds"}, {"score": 0.0041842092128678105, "phrase": "memory_locations"}, {"score": 0.00401961206251868, "phrase": "method's_implementation"}, {"score": 0.003739421738326676, "phrase": "conventional_verification"}, {"score": 0.003694652993546994, "phrase": "separation_logic_assertions"}, {"score": 0.003592258384936271, "phrase": "host_programming_language"}, {"score": 0.0035350218469335573, "phrase": "method_calls"}, {"score": 0.0034232607917050392, "phrase": "logic-based_verifiers"}, {"score": 0.0033552055241931346, "phrase": "symbolic_execution"}, {"score": 0.0033150213498435617, "phrase": "symbolic_execution-based_verifiers"}, {"score": 0.0032491108935498794, "phrase": "non-separating_conjunction"}, {"score": 0.0029034358982402346, "phrase": "verification_condition_generation"}, {"score": 0.0027556576784848207, "phrase": "separation_logic_specification"}, {"score": 0.002615381301695394, "phrase": "implicit_dynamic_frames"}, {"score": 0.002512342528545883, "phrase": "implicit_dynamic_frames_specification"}, {"score": 0.0023940274498526213, "phrase": "first-order_verification_conditions"}, {"score": 0.0023369711258107244, "phrase": "verification_conditions"}, {"score": 0.002209060366991921, "phrase": "verifier_prototype"}, {"score": 0.0021219954544970878, "phrase": "related_work"}], "paper_keywords": ["Program verification", " frame problem", " separation logic"], "paper_abstract": "An important, challenging problem in the verification of imperative programs with shared, mutable state is the frame problem in the presence of data abstraction. That is, one must be able to specify and verify upper bounds on the set of memory locations a method can read and write without exposing that method's implementation. Separation logic is now widely considered the most promising solution to this problem. However, unlike conventional verification approaches, separation logic assertions cannot mention heap-dependent expressions from the host programming language, such as method calls familiar to many developers. Moreover, separation logic-based verifiers are often based on symbolic execution. These symbolic execution-based verifiers typically do not support non-separating conjunction, and some of them rely on the developer to explicitly fold and unfold predicate definitions. Furthermore, several researchers have wondered whether it is possible to use verification condition generation and standard first-order provers instead of symbolic execution to automatically verify conformance with a separation logic specification. In this article, we propose a variant of separation logic called implicit dynamic frames that supports heap-dependent expressions inside assertions. Conformance with an implicit dynamic frames specification can be checked by proving the validity of a number of first-order verification conditions. To show that these verification conditions can be discharged automatically by standard first-order provers, we have implemented our approach in a verifier prototype and have used this prototype to verify several challenging examples from related work. Our prototype automatically folds and unfolds predicate definitions, as required, during the proof and can reason about non-separating conjunction which is used in the specifications of some of these examples. Finally, we prove the soundness of the approach.", "paper_title": "Implicit Dynamic Frames", "paper_id": "WOS:000303333300002"}