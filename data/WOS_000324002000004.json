{"auto_keywords": [{"score": 0.03510429867928044, "phrase": "software_visualization_tool"}, {"score": 0.03316377535189864, "phrase": "task_performance_data"}, {"score": 0.025496330934838024, "phrase": "process_models"}, {"score": 0.00481495049065317, "phrase": "software_visualization_contribute"}, {"score": 0.0044356867986444426, "phrase": "vast_amounts"}, {"score": 0.004332894955218135, "phrase": "software_visualization_tools"}, {"score": 0.0041586840496756474, "phrase": "software_engineering_industry"}, {"score": 0.003968112038249246, "phrase": "underlying_reasons"}, {"score": 0.0038534477978822133, "phrase": "usability_study"}, {"score": 0.0037201996003549246, "phrase": "software_visualization_techniques"}, {"score": 0.0036126731589251906, "phrase": "complex_software_systems"}, {"score": 0.0035705347414368726, "phrase": "expert_programmers"}, {"score": 0.003447035529485425, "phrase": "programming_tasks"}, {"score": 0.0032505921489759224, "phrase": "eye_gaze_patterns"}, {"score": 0.003175175896313016, "phrase": "statistical_analysis"}, {"score": 0.0029592333031063156, "phrase": "control_group"}, {"score": 0.002890557197908352, "phrase": "task_completion_time"}, {"score": 0.002790511479398411, "phrase": "quantitative_analysis"}, {"score": 0.0027579362569638945, "phrase": "performance_measures"}, {"score": 0.0026624684547385718, "phrase": "ways_software_visualizations"}, {"score": 0.0024813081174066653, "phrase": "cognitive_strategies"}, {"score": 0.0024236964502593254, "phrase": "quantitative_performance_difference"}, {"score": 0.002353554841514325, "phrase": "qualitative_analysis"}, {"score": 0.002326068563512387, "phrase": "eye-tracking_data"}, {"score": 0.0022192891418394535, "phrase": "software_visualizations"}, {"score": 0.002142426911242168, "phrase": "experiment_group"}, {"score": 0.0021049977753042253, "phrase": "specific_software_comprehension_strategies"}], "paper_keywords": [""], "paper_abstract": "Despite their ability to synthesize vast amounts of information, software visualization tools are not widely adopted in the software engineering industry. In an effort to investigate the underlying reasons, we conducted a usability study to investigate the affordances of software visualization techniques for the maintenance of complex software systems. Expert programmers were asked to carry out programming tasks with or without using a software visualization tool while their screens and eye gaze patterns were recorded. Statistical analysis of task performance data showed that participants who used the software visualization tool outperformed the control group in terms of task completion time and accuracy. However, quantitative analysis of performance measures did not reveal in what ways software visualizations contributed to this improvement. In an effort to identify the cognitive strategies that underlie this quantitative performance difference, process models grounded in qualitative analysis of eye-tracking data were constructed. The process models indicated that software visualizations guided the subjects in the experiment group toward following specific software comprehension strategies, which account for the difference observed in task performance data.", "paper_title": "How Does Software Visualization Contribute to Software Comprehension? A Grounded Theory Approach", "paper_id": "WOS:000324002000004"}