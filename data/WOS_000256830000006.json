{"auto_keywords": [{"score": 0.044623380435940996, "phrase": "reconfigurable_hardware"}, {"score": 0.032970825241389536, "phrase": "instruction-scheduling_algorithm"}, {"score": 0.00481495049065317, "phrase": "reconfigurable_processors"}, {"score": 0.004588389551682397, "phrase": "molen_reconfigurable_processor"}, {"score": 0.004556901872357751, "phrase": "programming_paradigm"}, {"score": 0.004463723624910583, "phrase": "optimized_binary_code"}, {"score": 0.00443308765153716, "phrase": "c_applications"}, {"score": 0.004372442291178139, "phrase": "pragma_annotation"}, {"score": 0.003929613937944779, "phrase": "powerpc_backend"}, {"score": 0.003835972725191194, "phrase": "appropriate_instructions"}, {"score": 0.0037704502704526996, "phrase": "data_transfer"}, {"score": 0.0036553070575015344, "phrase": "specific_hardware_implementations"}, {"score": 0.0035681790580031998, "phrase": "annotated_c_application"}, {"score": 0.003531474887552889, "phrase": "complete_design_flow"}, {"score": 0.0034472883424839346, "phrase": "executable_bitstream"}, {"score": 0.0034118234596993836, "phrase": "reconfigurable_processor"}, {"score": 0.0033767221949228834, "phrase": "flexible_design"}, {"score": 0.0033419808453225516, "phrase": "proposed_infrastructure"}, {"score": 0.0032848684681050745, "phrase": "special_features"}, {"score": 0.0032510690712452147, "phrase": "reconfigurable_architectures"}, {"score": 0.003173545808843704, "phrase": "reconfiguration_latencies"}, {"score": 0.0030872017736888113, "phrase": "dynamic_hardware_configuration_instructions"}, {"score": 0.0028715299874549245, "phrase": "reconfigurable_hardware_resources"}, {"score": 0.002803031561019101, "phrase": "hardware_operations"}, {"score": 0.0027551040319267446, "phrase": "molen_compiler"}, {"score": 0.002707993764473537, "phrase": "multimedia_video_frame_m-jpeg_encoder"}, {"score": 0.002670884656785558, "phrase": "extended_discrete_cosine_transform"}, {"score": 0.0025803315030392014, "phrase": "fpga."}, {"score": 0.0025449518236394103, "phrase": "overall_speedup"}, {"score": 0.0024756677425317474, "phrase": "maximal_theoretical_speedup"}, {"score": 0.002424942315592064, "phrase": "performance_efficiency"}, {"score": 0.0023917027133236813, "phrase": "automatically_generated_nonoptimized_dct"}, {"score": 0.002302648849276114, "phrase": "dct"}, {"score": 0.002263238468116224, "phrase": "vlc"}, {"score": 0.002224510044064184, "phrase": "simulation_results"}, {"score": 0.0021639307835832136, "phrase": "simple_scheduling"}, {"score": 0.0021416404045850224, "phrase": "significant_performance_decrease"}], "paper_keywords": ["algorithms", " languages", " performance", " instruction scheduling", " reconfigurable computing", " FPGA"], "paper_abstract": "In this paper, we describe the compiler developed to target the Molen reconfigurable processor and programming paradigm. The compiler automatically generates optimized binary code for C applications, based on pragma annotation of the code executed on the reconfigurable hardware. For the IBM PowerPC 405 processor included in the Virtex II Pro platform FPGA, we implemented code generation, register, and stack frame allocation following the PowerPC EABI (embedded application binary interface). The PowerPC backend has been extended to generate the appropriate instructions for the reconfigurable hardware and data transfer, taking into account the information of the specific hardware implementations and system. Starting with an annotated C application, a complete design flow has been integrated to generate the executable bitstream for the reconfigurable processor. The flexible design of the proposed infrastructure allows to consider the special features of the reconfigurable architectures. In order to hide the reconfiguration latencies, we implemented an instruction-scheduling algorithm for the dynamic hardware configuration instructions. The algorithm schedules, in advance, the hardware configuration instructions, taking into account the conflicts for the reconfigurable hardware resources (FPGA area) between the hardware operations. To verify the Molen compiler, we used the multimedia video frame M-JPEG encoder of which the extended discrete cosine transform (DCT*) function was mapped on the FPGA. We obtained an overall speedup of 2.5 (about 84% efficiency over the maximal theoretical speedup of 2.96). The performance efficiency is achieved using automatically generated nonoptimized DCT* hardware implementation. The instruction-scheduling algorithm has been tested for DCT, quantization, and VLC operations. Based on simulation results, we determine that, while a simple scheduling produces a significant performance decrease, our proposed scheduling contributes for up to 16x M-JPEG encoder speedup.", "paper_title": "The molen compiler for reconfigurable processors", "paper_id": "WOS:000256830000006"}