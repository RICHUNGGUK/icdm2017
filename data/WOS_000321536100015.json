{"auto_keywords": [{"score": 0.03940660329523237, "phrase": "dynamic_proxies"}, {"score": 0.012421792188292879, "phrase": "java"}, {"score": 0.011675202259034513, "phrase": "behavioral_reflection"}, {"score": 0.006793938527319311, "phrase": "dynamic_proxy"}, {"score": 0.0047722145315845016, "phrase": "proxy_abstraction"}, {"score": 0.004729856080441582, "phrase": "long-lasting_tradition"}, {"score": 0.004701825207431857, "phrase": "object-oriented_programming"}, {"score": 0.004660088610495924, "phrase": "design_patterns"}, {"score": 0.004632469280786256, "phrase": "inherent_programming_language_support"}, {"score": 0.004577718478319983, "phrase": "remote_method_invocations"}, {"score": 0.004563723400894942, "phrase": "current_support"}, {"score": 0.004550585106483935, "phrase": "simple_forms"}, {"score": 0.003630019267740951, "phrase": "structural_conformance"}, {"score": 0.003128136484949595, "phrase": "application-defined_class_type"}, {"score": 0.0030183628643645436, "phrase": "inherent_limitations"}, {"score": 0.0029561107046138136, "phrase": "deeper_programming_language_support"}, {"score": 0.0027115578750853673, "phrase": "generic_criteria"}, {"score": 0.0026954557881801546, "phrase": "proxy_implementations"}, {"score": 0.0025020469669826497, "phrase": "generic_scheme"}, {"score": 0.002465059277476973, "phrase": "field_accesses"}, {"score": 0.002357337046408753, "phrase": "programmer's_perspective"}, {"score": 0.0022677843776709125, "phrase": "precise_benefits"}, {"score": 0.002168664249034287, "phrase": "future_method_invocations"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Proxy", " Object", " Java", " Byte-code", " Transformation", " Safety"], "paper_abstract": "The proxy abstraction has a long-lasting tradition in object-oriented programming. From design patterns to inherent programming language support, and from remote method invocations to simple forms of behavioral reflection, incarnations as well as applications of proxies are innumerable. Since version 1.3, Java has supported the concept of a dynamic proxy. Such an object conforms to a set of types specified by the program and can be used wherever an expression of any of these types is expected, yet it reifies invocations performed on it. This ability has allowed dynamic proxies to be used to implement paradigms such as behavioral reflection, structural conformance, or multi-methods. Alas, these proxies are only available \"for interfaces\". The case of creating dynamic proxies for a set of types including a class has not been addressed, meaning that it is currently not possible to create a dynamic proxy that conforms to an application-defined class type. This weakness strongly limits any application of dynamic proxies beyond the inherent limitations of proxies, which have motivated deeper programming language support for features such as behavioral reflection. In this paper, we unfold the current support for dynamic proxies in Java, assessing it in the light of a set of generic criteria for proxy implementations. We present an approach to supporting dynamic proxies \"for classes\", consisting in transformations performed on classes at load-time, including a generic scheme for enforcing encapsulation upon field accesses. These transformations seamlessly extend the scope of the current support for dynamic proxies from the programmer's perspective. We argue for the safety of our transformations, and discuss the precise benefits and costs of our extension in terms of the criteria introduced through an implementation of future method invocations balancing safety and transparency. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Safe uniform proxies for Java", "paper_id": "WOS:000321536100015"}