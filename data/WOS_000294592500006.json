{"auto_keywords": [{"score": 0.03167773775787858, "phrase": "query_times"}, {"score": 0.03147784922609138, "phrase": "update_time"}, {"score": 0.03108178984361603, "phrase": "patrascu"}, {"score": 0.00481495049065317, "phrase": "optimal_worst-case_performance"}, {"score": 0.004763029094510862, "phrase": "succinct_indexes"}, {"score": 0.004670970835711395, "phrase": "jacobson's_thesis"}, {"score": 0.004511663118269957, "phrase": "traditional_indexing"}, {"score": 0.004414854522390932, "phrase": "online_queries"}, {"score": 0.004100915566711555, "phrase": "succinct_indexing_schemes"}, {"score": 0.0040743063601078, "phrase": "well-studied_problem"}, {"score": 0.004056662487640994, "phrase": "searchable_partial"}, {"score": 0.003995912800907815, "phrase": "sps"}, {"score": 0.003969578094724766, "phrase": "array_a"}, {"score": 0.003943817709882109, "phrase": "non-negative_k-bit_integers"}, {"score": 0.0038843558517333327, "phrase": "online_sum"}, {"score": 0.003800956249538064, "phrase": "individual_entry"}, {"score": 0.0037762859792754193, "phrase": "succinct_indexing_scheme"}, {"score": 0.0035458802311188497, "phrase": "dynamic_bit_array_problem"}, {"score": 0.0031535341431377837, "phrase": "query_and_update_operations"}, {"score": 0.0030458216152112584, "phrase": "worst-case_time"}, {"score": 0.00292266718076393, "phrase": "demaine's_lower_bound_result"}, {"score": 0.0027983916291218626, "phrase": "lower_bound"}, {"score": 0.0027323009127771525, "phrase": "search_query"}, {"score": 0.002621797028791881, "phrase": "demaine"}, {"score": 0.0025102759256260703, "phrase": "succinct_index"}, {"score": 0.00214659338413584, "phrase": "succinct_data_structure"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "The notion of succinct indexes can be dated back from the debut of Jacobson's thesis (1988) [14], and has triggered many results in the last decade. In traditional indexing, some given data are preprocessed so as to support online queries (and updates) on the data as efficiently as possible. When succinctness is involved, we are restricted to index the data using only an information-theoretically minimum number of bits. This paper concerns the succinct indexing schemes for a well-studied problem called Searchable Partial Sums (SPS). In SPS, an array A of n non-negative k-bit integers is preprocessed so as to support online sum and search queries, and possibly update operation of individual entry. A succinct indexing scheme would allow only kn + o(kn) bits to represent the array A. The only known result is that when k = 1 (in this case, it is known as the Dynamic Bit Array Problem), we can support both queries in O(log(b) n) time and update in O(b) amortized time for any b with lg n/lg lg n <= b <= n. This paper shows that even for k = O(lg lg n), we can index A succinctly such that both query and update operations can be supported using the same time complexities. Moreover, the time for update becomes the worst-case time. Furthermore, the tradeoff between the query times and the update time is optimal as implied by Patrascu and Demaine's lower bound result (2006) [24]. In general when k = O(lg U), we show a lower bound of Omega(root lg n/lg lg n) time for the search query irrespective of the update time. This gives a tighter lower bound as compared to that of Patrascu and Demaine's, which is a consequence of the requirement of succinctness. On the other hand, we give a succinct index that can support sum in O(log(b) n) time, search in O(tau log(b) n) time, and update in O(b) time, where tau = min {lg lg n lg lg U/lg lg lg U, root lg n/lg lg n}. The query times are optimal when b = n(epsilon), This paper also extends the Searchable Partial Sums with insert and delete operations, and provides a succinct data structure for some cases. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Succinct data structures for Searchable Partial Sums with optimal worst-case performance", "paper_id": "WOS:000294592500006"}