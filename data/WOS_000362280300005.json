{"auto_keywords": [{"score": 0.0356726488083496, "phrase": "rewind"}, {"score": 0.008081912199561076, "phrase": "transactional_updates"}, {"score": 0.00481495049065317, "phrase": "in-memory_non-volatile_data-structures"}, {"score": 0.004472950892839414, "phrase": "pcm"}, {"score": 0.00442609371248893, "phrase": "stt-mram"}, {"score": 0.004243552607799184, "phrase": "main_memory"}, {"score": 0.004025885154716127, "phrase": "nvm_programming_models"}, {"score": 0.003962779958955344, "phrase": "persistent_data_structures"}, {"score": 0.0037793152987497286, "phrase": "cpu_loads"}, {"score": 0.0037005154613244363, "phrase": "existing_mechanisms"}, {"score": 0.0034555479218891638, "phrase": "block-based_storage"}, {"score": 0.0031594291695784286, "phrase": "user_code"}, {"score": 0.0030935140058168885, "phrase": "imperative_general-purpose_language"}, {"score": 0.0029972030224205506, "phrase": "custom_persistent"}, {"score": 0.0029501745152877706, "phrase": "memory_data_structure"}, {"score": 0.002858313353461727, "phrase": "recoverable_operations"}, {"score": 0.002697245874076643, "phrase": "non-temporal_updates"}, {"score": 0.0026689487424251907, "phrase": "persistent_memory_fences"}, {"score": 0.0026270572353632297, "phrase": "lightweight_logging"}, {"score": 0.0025994945418484935, "phrase": "experimental_results"}, {"score": 0.0025722202862084186, "phrase": "synthetic_transactional_workloads"}, {"score": 0.002545231718163258, "phrase": "tpc-c"}, {"score": 0.002172701452347454, "phrase": "data_structure_recoverability"}, {"score": 0.0021273284545701896, "phrase": "general_purpose"}, {"score": 0.0021049977753042253, "phrase": "nvm-aware_dbms-based_recovery_schemes"}], "paper_keywords": [""], "paper_abstract": "Recent non-volatile memory (NVM) technologies, such as PCM, STT-MRAM and ReRAM, can act as both main memory and storage. This has led to research into NVM programming models, where persistent data structures remain in memory and are accessed directly through CPU loads and stores. Existing mechanisms for transactional updates are not appropriate in such a setting as they are optimized for block-based storage. We present REWIND, a user-mode library approach to managing transactional updates directly from user code written in an imperative general-purpose language. REWIND relies on a custom persistent in-memory data structure for the log that supports recoverable operations on itself. The scheme also employs a combination of non-temporal updates, persistent memory fences, and lightweight logging. Experimental results on synthetic transactional workloads and TPC-C show the overhead of REWIND compared to its non-recoverable equivalent to be within a factor of only 1.5 and 1.39 respectively. Moreover, REWIND outperforms state-of-the-art approaches for data structure recoverability as well as general purpose and NVM-aware DBMS-based recovery schemes by up to two orders of magnitude.", "paper_title": "REWIND: Recovery Write-Ahead System for In-Memory Non-Volatile Data-Structures", "paper_id": "WOS:000362280300005"}