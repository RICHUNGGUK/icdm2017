{"auto_keywords": [{"score": 0.0439219563307645, "phrase": "simple_clones"}, {"score": 0.037703509080803346, "phrase": "structural_clones"}, {"score": 0.00481495049065317, "phrase": "data_mining_approach"}, {"score": 0.004773904938276846, "phrase": "detecting_higher-level_clones"}, {"score": 0.0046928556063004214, "phrase": "code_clones"}, {"score": 0.004652845998457721, "phrase": "similar_program_structures"}, {"score": 0.004593467306126913, "phrase": "variant_forms"}, {"score": 0.004382127278148236, "phrase": "similar_code_fragments"}, {"score": 0.004307700591183651, "phrase": "so-called_simple_clones"}, {"score": 0.004234532601573088, "phrase": "subsequent_unification"}, {"score": 0.004127094600862448, "phrase": "software_maintenance"}, {"score": 0.0039035351575463103, "phrase": "code_clone_analysis"}, {"score": 0.0038207994186834015, "phrase": "recurring_patterns"}, {"score": 0.003692040748097991, "phrase": "interesting_higher-level_similarities"}, {"score": 0.003537155405923517, "phrase": "bigger_picture"}, {"score": 0.00350696416714684, "phrase": "similarity_situation"}, {"score": 0.0034179225740833055, "phrase": "logical_groups"}, {"score": 0.003288567185099276, "phrase": "huge_number"}, {"score": 0.003205052842427402, "phrase": "simple_clone_detection_tools"}, {"score": 0.0030837288356760973, "phrase": "postdetection_visualization_techniques"}, {"score": 0.0028916124463906983, "phrase": "better_maintenance"}, {"score": 0.0026425357050743003, "phrase": "useful_types"}, {"score": 0.00249919111154604, "phrase": "structural_clone_concept"}, {"score": 0.0024461474613359994, "phrase": "data_mining_techniques"}, {"score": 0.002404522326122611, "phrase": "higher-level_similarities"}, {"score": 0.0023233815940300064, "phrase": "miner"}, {"score": 0.0021973099304606076, "phrase": "proposed_techniques"}], "paper_keywords": ["Design concepts", " maintainability", " restructuring", " reverse engineering", " reengineering", " reusable software"], "paper_abstract": "Code clones are similar program structures recurring in variant forms in software system(s). Several techniques have been proposed to detect similar code fragments in software, so-called simple clones. Identification and subsequent unification of simple clones is beneficial in software maintenance. Even further gains can be obtained by elevating the level of code clone analysis. We observed that recurring patterns of simple clones often indicate the presence of interesting higher-level similarities that we call structural clones. Structural clones show a bigger picture of similarity situation than simple clones alone. Being logical groups of simple clones, structural clones alleviate the problem of huge number of clones typically reported by simple clone detection tools, a problem that is often dealt with postdetection visualization techniques. Detection of structural clones can help in understanding the design of the system for better maintenance and in reengineering for reuse, among other uses. In this paper, we propose a technique to detect some useful types of structural clones. The novelty of our approach includes the formulation of the structural clone concept and the application of data mining techniques to detect these higher-level similarities. We describe a tool called Clone Miner that implements our proposed technique. We assess the usefulness and scalability of the proposed techniques via several case studies. We discuss various usage scenarios to demonstrate in what ways the knowledge of structural clones adds value to the analysis based on simple clones alone.", "paper_title": "A Data Mining Approach for Detecting Higher-Level Clones in Software", "paper_id": "WOS:000268305800006"}