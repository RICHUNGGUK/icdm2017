{"auto_keywords": [{"score": 0.04770073889647974, "phrase": "code_compression"}, {"score": 0.04577290335074107, "phrase": "code-compression_scheme"}, {"score": 0.00481495049065317, "phrase": "performance_enhancement"}, {"score": 0.004777392826700429, "phrase": "variable-length_embedded_processors"}, {"score": 0.004487241576747549, "phrase": "fixed-length_instruction_encoding"}, {"score": 0.004348813532606792, "phrase": "variable-length_instruction_encodings"}, {"score": 0.004052701031142039, "phrase": "variable-length_instruction-set_processors"}, {"score": 0.003688892770976908, "phrase": "challenging_task"}, {"score": 0.0035332058983966424, "phrase": "decompression_hardware"}, {"score": 0.0034646205853140558, "phrase": "code_postcache"}, {"score": 0.003203294948113915, "phrase": "second_one"}, {"score": 0.0031782684007251403, "phrase": "reserved_instructions"}, {"score": 0.003141093559655865, "phrase": "code_words"}, {"score": 0.003092200512475624, "phrase": "additional_logic"}, {"score": 0.002847691227421257, "phrase": "variable-length_risc_processor"}, {"score": 0.002792375587031108, "phrase": "detailed_experimental_analysis"}, {"score": 0.0027597018725736165, "phrase": "empirical_results"}, {"score": 0.002727409429089543, "phrase": "extensive_simulation-based_design_space_exploration"}, {"score": 0.0026639507068734907, "phrase": "optimized_decompressor"}, {"score": 0.002622465142275264, "phrase": "compressed_program"}, {"score": 0.0025816239578784067, "phrase": "native_program"}, {"score": 0.002511672561475743, "phrase": "code_size"}, {"score": 0.002197891020396052, "phrase": "hardware_description_language"}, {"score": 0.0021383149182448544, "phrase": "small_overheads"}, {"score": 0.0021049977753042253, "phrase": "proposed_approach"}], "paper_keywords": ["design", " performance", " experimentation", " code compression", " code decompression", " variable-length ISAs", " RISC processor", " instruction memory", " bus switching", " embedded systems"], "paper_abstract": "Most of the work done in the field of code compression pertains to processors with fixed-length instruction encoding. The design of a code-compression scheme for variable-length instruction encodings poses newer design challenges. In this work, we first investigate the scope for code compression on variable-length instruction-set processors whose encodings are already optimized to a certain extent with respect to their usage. For such ISAs instruction boundaries are not known prior to decoding. Another challenging task of designing a code-compression scheme for such ISAs is designing the decompression hardware, which must decompress code postcache so that we gain in performance. We present two dictionary-based code compression schemes. The first algorithm uses a bit-vector; the second one uses reserved instructions to identify code words. We design additional logic for each of the schemes to decompress the code on-the-fly. We test the two algorithms with a variable-length RISC processor. We provide a detailed experimental analysis of the empirical results obtained by extensive simulation-based design space exploration for this system. The optimized decompressor can now execute compressed program faster than the native program. The experiments demonstrate reduction in code size ( up to 30%), speed-up ( up to 15%), and bus-switching activity ( up to 20%). We also implement one decompressor in a hardware description language and synthesize it to illustrate the small overheads associated with the proposed approach.", "paper_title": "Code compression for performance enhancement of variable-length embedded processors", "paper_id": "WOS:000256880900013"}