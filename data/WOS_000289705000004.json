{"auto_keywords": [{"score": 0.047510470298773616, "phrase": "software_system"}, {"score": 0.04155362490823712, "phrase": "fault-inserted_files"}, {"score": 0.03093166086339985, "phrase": "bfafi"}, {"score": 0.015605952122804403, "phrase": "binary_file_format"}, {"score": 0.013395748495613214, "phrase": "binary_files"}, {"score": 0.011287176051570272, "phrase": "maximum_test_case_coverage"}, {"score": 0.00481495049065317, "phrase": "automated_analysis"}, {"score": 0.004744748477093856, "phrase": "fuzz_testing"}, {"score": 0.0046073860169839305, "phrase": "serious_security_holes"}, {"score": 0.0044904452331803, "phrase": "unexpected_data"}, {"score": 0.004328494656899359, "phrase": "system's_bugs"}, {"score": 0.003992385826251404, "phrase": "large_number"}, {"score": 0.0039053194919285725, "phrase": "test_case"}, {"score": 0.003615217162972726, "phrase": "novel_algorithm"}, {"score": 0.003408688677676014, "phrase": "proposed_approach"}, {"score": 0.0033712944392793195, "phrase": "automatic_analysis"}, {"score": 0.003261547125192671, "phrase": "stack_frames"}, {"score": 0.0032376465741070274, "phrase": "assembly_codes"}, {"score": 0.0030414140732789186, "phrase": "new_method"}, {"score": 0.002996992362027833, "phrase": "practical_tool"}, {"score": 0.002857041057269513, "phrase": "program_execution"}, {"score": 0.0027036380093304747, "phrase": "total_number"}, {"score": 0.00257735013358606, "phrase": "general_fuzzer"}, {"score": 0.00241214634516517, "phrase": "bfafi."}, {"score": 0.0022909940601580675, "phrase": "graphic_rendering_engine"}, {"score": 0.002200077887697072, "phrase": "system_library"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software testing", " Fuzzing", " Security testing"], "paper_abstract": "Fuzz testing is regarded as the most useful technique in finding serious security holes in a software system. It inserts unexpected data into the input of the software system and finds the system's bugs or errors. However, one of the disadvantages that fuzz testing executed using binary files has is that it requires a large number of fault-inserted files to cover every test case, which could be up to 2(8xFILESIZE) files. In order to overcome this drawback, we propose a novel algorithm that efficiently reduces the number of fault-inserted files, yet still maintain the maximum test case coverage. The proposed approach enables the automatic analysis of fields of binary files by tracking and analyzing stack frames, assembly codes, and registers as the software system parses the files. We evaluate the efficacy of the new method by implementing a practical tool, the Binary File Analyzer and Fault Injector (BFAFI), which traces the program execution and analyzes the fields in binary file format Our experiments demonstrate that the BFAFI reduced the total number of fault-inserted files with maximum test case coverage as well as detected approximately 14 times more exceptions than did the general fuzzer. Also, the BFAFI found 11 causes of exceptions; five of them were found only by BFAFI. Ten of the 11 causes of exceptions that we found were generated by a graphic rendering engine (GDI32.d11): the other was generated by the system library (kerne132.d11.) in Windows XP SP2. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Efficient file fuzz testing using automated analysis of binary file format", "paper_id": "WOS:000289705000004"}