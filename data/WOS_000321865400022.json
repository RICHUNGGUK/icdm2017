{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "temporal_logics"}, {"score": 0.004772593750252861, "phrase": "e._g._ctl"}, {"score": 0.0047306078475683865, "phrase": "ctl_star"}, {"score": 0.004506171772318298, "phrase": "sophisticated_questions"}, {"score": 0.004124920849728372, "phrase": "security_analysis"}, {"score": 0.004052616113326177, "phrase": "precondition_synthesis"}, {"score": 0.004016938499717623, "phrase": "environment_synthesis"}, {"score": 0.003911771812701971, "phrase": "existing_automatic_branching-time_verification_tools"}, {"score": 0.003410565849262162, "phrase": "automation_strategy"}, {"score": 0.0033212215487678854, "phrase": "previous_restrictions"}, {"score": 0.0032057142600527, "phrase": "non-trivial_mixtures"}, {"score": 0.0031774686451753477, "phrase": "universal_and_existential_modal_operators"}, {"score": 0.002908306074124806, "phrase": "existential_reasoning"}, {"score": 0.0028446460307503343, "phrase": "universal_reasoning"}, {"score": 0.002807118943000936, "phrase": "system's_state-space"}, {"score": 0.002615156460073562, "phrase": "recent_work"}, {"score": 0.0025018875576502606, "phrase": "new_route"}, {"score": 0.002447101794397243, "phrase": "existing_tools"}, {"score": 0.0023935128386292966, "phrase": "practical_viability"}, {"score": 0.002200337772403981, "phrase": "windows_operating_system"}, {"score": 0.0021712920081029194, "phrase": "postgresql_database_server"}, {"score": 0.0021521410307795657, "phrase": "soft-updates_patching_system"}], "paper_keywords": ["Verification", " Theory", " Reliability", " CTL", " temporal logic", " formal verification", " termination", " program analysis", " model checking"], "paper_abstract": "Branching-time temporal logics (e. g. CTL, CTL star, modal mu-calculus) allow us to ask sophisticated questions about the nondeterminism that appears in systems. Applications of this type of reasoning include planning, games, security analysis, disproving, precondition synthesis, environment synthesis, etc. Unfortunately, existing automatic branching-time verification tools have limitations that have traditionally restricted their applicability (e. g. push-down systems only, universal path quantifiers only, etc). In this paper we introduce an automation strategy that lifts many of these previous restrictions. Our method works reliably for properties with non-trivial mixtures of universal and existential modal operators. Furthermore, our approach is designed to support (possibly infinite-state) programs. The basis of our approach is the observation that existential reasoning can be reduced to universal reasoning if the system's state-space is appropriately restricted. This restriction on the state-space must meet a constraint derived from recent work on proving non-termination. The observation leads to a new route for implementation based on existing tools. To demonstrate the practical viability of our approach, we report on the results applying our preliminary implementation to a set of benchmarks drawn from the Windows operating system, the PostgreSQL database server, Soft-Updates patching system, as well as other hand-crafted examples.", "paper_title": "Reasoning about Nondeterminism in Programs", "paper_id": "WOS:000321865400022"}