{"auto_keywords": [{"score": 0.029677960066507737, "phrase": "low-level_heap_mutations"}, {"score": 0.00481495049065317, "phrase": "reachable_patterns"}, {"score": 0.004763565662615503, "phrase": "linked_data-structures"}, {"score": 0.004637478829869904, "phrase": "new_decidable_logic"}, {"score": 0.004395185177346749, "phrase": "dynamically-allocated_objects"}, {"score": 0.004301834610818624, "phrase": "destructive_pointer_updates"}, {"score": 0.004233119608341877, "phrase": "main_feature"}, {"score": 0.0038226070564362697, "phrase": "regular_expression"}, {"score": 0.0037615180375561805, "phrase": "designated_node"}, {"score": 0.0036227329311981195, "phrase": "boolean_operations"}, {"score": 0.003451766520526601, "phrase": "finite_model_property"}, {"score": 0.0033965836912510385, "phrase": "key_technical_result"}, {"score": 0.003100085797251317, "phrase": "loop_invariants"}, {"score": 0.003050508020268648, "phrase": "interesting_programs"}, {"score": 0.00266693888510356, "phrase": "arbitrary_data-structures"}, {"score": 0.002610198789888055, "phrase": "arbitrary_number"}, {"score": 0.0025822818714499795, "phrase": "pointer_fields"}, {"score": 0.0021049977753042253, "phrase": "partial_correctness"}], "paper_keywords": [""], "paper_abstract": "We define a new decidable logic for expressing and checking invariants of programs that manipulate dynamically-allocated objects via pointers and destructive pointer updates. The main feature of this logic is the ability to limit the neighborhood of a node that is reachable via a regular expression from a designated node. The logic is closed under boolean operations (entailment, negation) and has a finite model property. The key technical result is the proof of decidability. We show how to express precondition, postconditions, and loop invariants for some interesting programs. It is also possible to express properties such as disjointness of data-structures, and low-level heap mutations. Moreover, our logic can express properties of arbitrary data-structures and of an arbitrary number of pointer fields. The latter provides a way to naturally specify postconditions that relate the fields on entry to a procedure to the fields on exit. Therefore, it is possible to use the logic to automatically prove partial correctness of programs performing low-level heap mutations.", "paper_title": "A logic of reachable patterns in linked data-structures", "paper_id": "WOS:000237082000007"}