{"auto_keywords": [{"score": 0.03898048818064751, "phrase": "design_scheduling"}, {"score": 0.014737227852203452, "phrase": "dataflow_algorithms"}, {"score": 0.012510992302545643, "phrase": "algorithmic_transformations"}, {"score": 0.010480623314356665, "phrase": "synthesis_results"}, {"score": 0.009864896835174003, "phrase": "petri_net_theory"}, {"score": 0.00977991011657114, "phrase": "smv_model_checker"}, {"score": 0.00481495049065317, "phrase": "dataflow_scheduling."}, {"score": 0.0047113960612140335, "phrase": "formal_verification_method"}, {"score": 0.004670597652149685, "phrase": "high-level_synthesis"}, {"score": 0.004550300345169981, "phrase": "design_errors"}, {"score": 0.0044524122425287005, "phrase": "petri_net"}, {"score": 0.004244375827831527, "phrase": "formal_verification"}, {"score": 0.0041170581247889654, "phrase": "architecture_verification"}, {"score": 0.004010960493946656, "phrase": "functional_verification"}, {"score": 0.003976203286249396, "phrase": "register_transfer_level"}, {"score": 0.0037738708560271354, "phrase": "optimal_goals"}, {"score": 0.003311799410921826, "phrase": "high-level_faults"}, {"score": 0.0032830808525570903, "phrase": "high-level_verification"}, {"score": 0.003115908199991072, "phrase": "boolean_algebra"}, {"score": 0.0030888830649190282, "phrase": "traditional_verification"}, {"score": 0.002855934865505357, "phrase": "high-level_dataflow_designs"}, {"score": 0.002806595775343074, "phrase": "proposed_hybrid_verification_method"}, {"score": 0.002770150086489194, "phrase": "high-level_designor_duv"}, {"score": 0.002629026692001082, "phrase": "petri_net_model"}, {"score": 0.0024734363743525827, "phrase": "hls"}, {"score": 0.002257070536352418, "phrase": "proposed_verification_method"}, {"score": 0.0021049977753042253, "phrase": "resource_usage"}], "paper_keywords": ["Formal verification", " high-level synthesis", " dataflow", " Petri net", " model checking"], "paper_abstract": "This paper presents the formal verification method for high-level synthesis (HLS) to detect design errors of dataflow algorithms by using Petri Net (PN) and symbolic-model-verifier (SMV) techniques. Formal verification in high-level design means architecture verification, which is different from functional verification in register transfer level (RTL). Generally, dataflow algorithms need algorithmic transformations to achieve optimal goals and also need design scheduling to allocate process or resources before mapping on a silicon. However, algorithmic transformations and design scheduling are error-prone. In order to detect high-level faults, high-level verification is applied to verify the synthesis results in HLS. Instead of applying Boolean algebra in traditional verification, this paper adopts both Petri Net theory and SMV model checker to verify the correctness of the synthesis results of the high-level dataflow designs. In the proposed hybrid verification method, a high-level designor DUV (design-under-verification) is first transformed into a Petri Net model. Then, Petri Net theory is applied to check the correctness of its algorithmic transformations of HLS, and the SMV model checker is used to verify the correctness of the design scheduling. We presented two approaches to realize the proposed verification method and concluded the best one who outperforms the other in terms of processing speed and resource usage.", "paper_title": "VERIFICATION OF DATAFLOW SCHEDULING", "paper_id": "WOS:000262084900002"}