{"auto_keywords": [{"score": 0.02496380602277297, "phrase": "unlabeled_version"}, {"score": 0.00481495049065317, "phrase": "connected_graph"}, {"score": 0.004725886853744007, "phrase": "v_and_v'_two_n-element_subsets"}, {"score": 0.003957477564354679, "phrase": "common_elements"}, {"score": 0.0032827577713351336, "phrase": "intermediate_vertices"}, {"score": 0.0029618842673339173, "phrase": "computational_complexity"}, {"score": 0.002839812512030847, "phrase": "unlabeled_chips"}, {"score": 0.002445021071485221, "phrase": "linear-time_algorithm"}, {"score": 0.0021347607855562102, "phrase": "graph_algorithm"}, {"score": 0.0021049977753042253, "phrase": "tree_algorithm"}], "paper_keywords": [""], "paper_abstract": "Let C be a connected graph, and let V and V' two n-element subsets of its vertex set V(G). Imagine that we place a chip at each element of V and we want to move them into the positions of V' (V and V' may have common elements). A move is defined as shifting a chip from nu(1) to nu(2) (nu(1), nu(2) is an element of V(G)) on a path formed by edges of G so that no intermediate vertices are occupied. We give upper and lower bounds on the number of moves that are necessary, and analyze the computational complexity of this problem under various assumptions: labeled versus unlabeled chips, arbitrary graphs versus the case when the graph is the rectangular (infinite) planar grid, etc. We provide hardness and inapproximability results for several variants of the problem. We also give a linear-time algorithm which performs an optimal (minimum) number of moves for the unlabeled version in a tree, and a constant-ratio approximation algorithm for the unlabeled version in a graph. The graph algorithm uses the tree algorithm as a subroutine.", "paper_title": "Reconfigurations in graphs and grids", "paper_id": "WOS:000236886100027"}