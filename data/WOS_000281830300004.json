{"auto_keywords": [{"score": 0.024802822772455616, "phrase": "miller"}, {"score": 0.00481495049065317, "phrase": "communicating_tasks"}, {"score": 0.004766683200410046, "phrase": "good_scheduling_policies"}, {"score": 0.004718897469501381, "phrase": "distributed_embedded_applications"}, {"score": 0.004601508848655033, "phrase": "hard_real_time_constraints"}, {"score": 0.004442032546224076, "phrase": "computational_resources"}, {"score": 0.004331501320993783, "phrase": "quasi-static_scheduling_problem"}, {"score": 0.0041825638143434055, "phrase": "karp"}, {"score": 0.00418134346679498, "phrase": "flow_branchings"}, {"score": 0.004118587636081584, "phrase": "scheduling_decisions"}, {"score": 0.004077272409331917, "phrase": "run_time"}, {"score": 0.003916098498242888, "phrase": "sequential_processes"}, {"score": 0.0038379074449947067, "phrase": "point-to-point_buffers"}, {"score": 0.0034003686971964707, "phrase": "required_responses"}, {"score": 0.0033156708990372047, "phrase": "pre-determined_configuration"}, {"score": 0.0032006150973842846, "phrase": "new_request"}, {"score": 0.002952356518921907, "phrase": "scheduling_policy"}, {"score": 0.002907992115184249, "phrase": "upper_bounds"}, {"score": 0.002878785759716458, "phrase": "buffer_capacities"}, {"score": 0.0026688629249775925, "phrase": "important_subclass"}, {"score": 0.0026420518944303716, "phrase": "\"data-branching\"_systems"}, {"score": 0.0025119730908615104, "phrase": "data-dependent_internal_choices"}, {"score": 0.0024617483174454113, "phrase": "sequential_components"}, {"score": 0.0024247382451294255, "phrase": "decidability_result"}, {"score": 0.0023170054862555896, "phrase": "coverability_tree"}, {"score": 0.0022937210378944457, "phrase": "petri_nets"}, {"score": 0.0021697677572213086, "phrase": "message_sequence_charts"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Communicating machines", " Quasi-static scheduling", " Channel bound"], "paper_abstract": "Good scheduling policies for distributed embedded applications are required for meeting hard real time constraints and for optimizing the use of computational resources. We study the quasi-static scheduling problem in which (uncontrollable) control flow branchings can influence scheduling decisions at run time. Our abstracted distributed task model consists of a network of sequential processes that communicate via point-to-point buffers. In each round, the task gets activated by a request from the environment. When the task has finished computing the required responses, it reaches a pre-determined configuration and is ready to receive a new request from the environment. For such systems, we prove that determining the existence of a scheduling policy that guarantees upper bounds on buffer capacities is undecidable. However, we show that the problem is decidable for the important subclass of \"data-branching\" systems in which control flow branchings are exclusively due to data-dependent internal choices made by the sequential components. This decidability result exploits ideas derived from the Karp and Miller coverability tree for Petri nets as well as the existential boundedness notion of languages of message sequence charts. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "Quasi-static scheduling of communicating tasks", "paper_id": "WOS:000281830300004"}