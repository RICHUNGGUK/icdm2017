{"auto_keywords": [{"score": 0.028891126864103063, "phrase": "optimal_precision"}, {"score": 0.00481495049065317, "phrase": "real-time_distributed_computing_model"}, {"score": 0.00465634671242413, "phrase": "simple_real-time_distributed_computing_model"}, {"score": 0.004403480614319231, "phrase": "distributed_computing"}, {"score": 0.004330321475256457, "phrase": "real-time_systems_perspective"}, {"score": 0.004211069233133584, "phrase": "instantaneous_computing_steps"}, {"score": 0.0041642891310893, "phrase": "computing_steps"}, {"score": 0.004118026552723285, "phrase": "non-zero_duration"}, {"score": 0.003916098498242888, "phrase": "real-time_scheduling_analysis"}, {"score": 0.0037869901077566526, "phrase": "classic_distributed_computing_analysis_techniques"}, {"score": 0.0036621225944272256, "phrase": "general_simulations"}, {"score": 0.0036214184763804034, "phrase": "validity_conditions"}, {"score": 0.003501991125315889, "phrase": "classic_synchronous_model"}, {"score": 0.003293142761521422, "phrase": "real_systems"}, {"score": 0.0031140747752837826, "phrase": "zero_step-time_models"}, {"score": 0.0030282147475402736, "phrase": "well-studied_problem"}, {"score": 0.0029447150254434842, "phrase": "failure-free_internal_clock_synchronization"}, {"score": 0.002800158709933889, "phrase": "clock_synchronization_algorithm"}, {"score": 0.0027690086059100495, "phrase": "constant_running_time"}, {"score": 0.002574788013427524, "phrase": "classic_model"}, {"score": 0.0021049977753042253, "phrase": "lower_bounds"}], "paper_keywords": ["Distributed computing models", " Real-time scheduling analysis", " Optimal clock synchronization", " Lower bounds"], "paper_abstract": "This paper introduces a simple real-time distributed computing model for message-passing systems, which reconciles the distributed computing and the real-time systems perspective: By just replacing instantaneous computing steps with computing steps of non-zero duration, we obtain a model that both facilitates real-time scheduling analysis, and retains compatibility with classic distributed computing analysis techniques and results. We provide general simulations and validity conditions for transforming algorithms from the classic synchronous model to our real-time model and vice versa, and investigate whether/which properties of real systems are inaccurately or even wrongly captured when resorting to zero step-time models. We revisit the well-studied problem of deterministic drift- and failure-free internal clock synchronization for this purpose, and show that no clock synchronization algorithm with constant running time can achieve optimal precision in our real-time model. Since such an algorithm is known for the classic model, this is an instance of a problem where the standard distributed computing analysis gives too optimistic results. We prove that optimal precision is only achievable with algorithms that take Omega(n) time in our model, and establish several additional algorithms and lower bounds. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Towards a real-time distributed computing model", "paper_id": "WOS:000263635200013"}