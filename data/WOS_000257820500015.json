{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "periodic_register_allocation"}, {"score": 0.006022607198573055, "phrase": "remaining_registers"}, {"score": 0.004767451673469903, "phrase": "loop_unrolling_degree"}, {"score": 0.0046738485441681485, "phrase": "open_problem"}, {"score": 0.004551883842967241, "phrase": "software_pipelining"}, {"score": 0.004506968388996092, "phrase": "powerful_technique"}, {"score": 0.004462494148878735, "phrase": "fine-grain_parallelism"}, {"score": 0.004403874076980828, "phrase": "reuse_circuits"}, {"score": 0.004374852170791322, "phrase": "multiple_loop_iterations"}, {"score": 0.004204676524824095, "phrase": "code_generation_challenge"}, {"score": 0.003948613642680196, "phrase": "embedded_processors"}, {"score": 0.003807529003314843, "phrase": "high_risk"}, {"score": 0.003757480190200645, "phrase": "computation_throughput-initiation_interval"}, {"score": 0.003482160257566501, "phrase": "unpractical_code_growth"}, {"score": 0.0034477636809450312, "phrase": "latter_approach"}, {"score": 0.003379983027734299, "phrase": "maxlive_registers"}, {"score": 0.003153041030690117, "phrase": "post-pass_loop_unrolling"}, {"score": 0.003060491505805715, "phrase": "undesired_register_spills"}, {"score": 0.0029608318458226755, "phrase": "periodic_register_allocation_technique"}, {"score": 0.002931569771634119, "phrase": "software-only_code_generation"}, {"score": 0.002798780784517325, "phrase": "generated_code"}, {"score": 0.0026543514413663893, "phrase": "architectural_registers"}, {"score": 0.0026281103468378856, "phrase": "target_processor"}, {"score": 0.0025090323307618632, "phrase": "unrolling_degree"}, {"score": 0.0024434201175883674, "phrase": "complete_formalisation"}, {"score": 0.0023716501597131024, "phrase": "extensive_experiments"}, {"score": 0.00234043119560776, "phrase": "practical_loop_unrolling_degrees"}, {"score": 0.0021049977753042253, "phrase": "unacceptable_code_growth"}], "paper_keywords": ["algorithms", " performance", " periodic register allocation", " software pipelining", " loop unrolling", " embedded code optimisation"], "paper_abstract": "This paper solves an open problem regarding loop unrolling after periodic register allocation. Although software pipelining is a powerful technique to extract fine-grain parallelism, it generates reuse circuits spanning multiple loop iterations. These circuits require periodic register allocation, which in turn yield a code generation challenge, generally addressed through: (1) hardware support -rotating register files-deemed too expensive for embedded processors, (2) insertion of register moves with a high risk of reducing the computation throughput-initiation interval (II)-of software pipelining, and (3) post-pass loop unrolling that does not compromise throughput but often leads to unpractical code growth. The latter approach relies on the proof that MAXLIVE registers are sufficient for periodic register allocation (2; 3; 5); yet the only heuristic to control the amount of post-pass loop unrolling does not achieve this bound and leads to undesired register spills (4; 7). We propose a periodic register allocation technique allowing a software-only code generation that does not trade the optimality of the II for compactness of the generated code. Our idea is based on using the remaining registers: calling R(arch) the number of architectural registers of the target processor, then the number of remaining registers that can be used for minimising the unrolling degree is equal to R(arch)-MAXLIVE. We provide a complete formalisation of the problem and algorithm, followed by extensive experiments. We achieve practical loop unrolling degrees in most cases-with no increase of the II-while state-of-the-art techniques would either induce register spilling, degrade the II or lead to unacceptable code growth.", "paper_title": "Post-pass periodic register allocation to minimise loop unrolling degree", "paper_id": "WOS:000257820500015"}