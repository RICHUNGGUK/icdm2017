{"auto_keywords": [{"score": 0.049027569260597086, "phrase": "framework-specific_models"}, {"score": 0.015043882960475326, "phrase": "application_code"}, {"score": 0.011449022384980244, "phrase": "static_analyses"}, {"score": 0.00481495049065317, "phrase": "high-quality_framework-specific_models"}, {"score": 0.004544770921520536, "phrase": "framework_viewpoint"}, {"score": 0.004195418010131832, "phrase": "practical_model-supported_software_engineering"}, {"score": 0.00408501512749186, "phrase": "design_models"}, {"score": 0.004048860957751714, "phrase": "development_tasks"}, {"score": 0.003995226376780718, "phrase": "code_understanding"}, {"score": 0.003942299471749811, "phrase": "framework_usage_rules"}, {"score": 0.0037043953071235155, "phrase": "different_times"}, {"score": 0.0036553070575015344, "phrase": "software_lifecycle"}, {"score": 0.0036229421570951807, "phrase": "software_evolution_tasks"}, {"score": 0.003543273649210823, "phrase": "experimental_study"}, {"score": 0.003114449258490062, "phrase": "retrieved_models"}, {"score": 0.0030189426536422577, "phrase": "framework-specific_modeling_languages"}, {"score": 0.002900426826591769, "phrase": "open-source_framework"}, {"score": 0.002861961643289598, "phrase": "reverse_engineering"}, {"score": 0.002811464848641341, "phrase": "prototype_implementations"}, {"score": 0.002689076130099546, "phrase": "considered_frameworks"}, {"score": 0.0026534064006291853, "phrase": "large_body"}, {"score": 0.0026182085765020548, "phrase": "rather_simple_code_analyses"}, {"score": 0.002438203996977464, "phrase": "initial_results"}, {"score": 0.0023113506171584157, "phrase": "larger_set"}, {"score": 0.0021910825909008946, "phrase": "refined_static_analyses"}, {"score": 0.0021049977753042253, "phrase": "analyzed_applications"}], "paper_keywords": ["Reverse engineering", " Framework-specific models", " Framework-specific modeling languages", " Static analysis", " Object-oriented frameworks", " Application programming interface", " API"], "paper_abstract": "Framework-specific models represent the design of application code from the framework viewpoint by showing how framework-provided concepts are instantiated in the code. Retrieving such models quickly and precisely is necessary for practical model-supported software engineering, in which developers use design models for development tasks such as code understanding, verifying framework usage rules, and round-trip engineering. Also, comparing models extracted at different times of the software lifecycle supports software evolution tasks. We describe an experimental study of the static analyses necessary to automatically retrieve framework-specific models from application code. We reverse engineer a number of applications based on three open-source frameworks and evaluate the quality of the retrieved models. The models are expressed using framework-specific modeling languages (FSMLs), each designed for an open-source framework. For reverse engineering, we use prototype implementations of the three FSMLs. Our results show that for the considered frameworks and a large body of application code rather simple code analyses are sufficient for automatically retrieving framework-specific models with high precision and recall. Based on the initial results, we refine the static analyses and repeat the study on a larger set of applications to provide more evidence and confirm the results. The refined static analyses provide precision and recall of close to 100% for the analyzed applications.", "paper_title": "Fast extraction of high-quality framework-specific models from application code", "paper_id": "WOS:000263418600005"}