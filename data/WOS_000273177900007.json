{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "automatic_insertion"}, {"score": 0.0047268728636719725, "phrase": "message-passing_codes"}, {"score": 0.004451546786101008, "phrase": "system_level"}, {"score": 0.004370087541308677, "phrase": "application_level"}, {"score": 0.004040123129261597, "phrase": "different_environments"}, {"score": 0.003966162568548304, "phrase": "application-level_checkpointing_tools"}, {"score": 0.0035010071030752883, "phrase": "user_code"}, {"score": 0.0034368818187904744, "phrase": "kernel_routines"}, {"score": 0.0031918782879822773, "phrase": "spmd"}, {"score": 0.002950608985750058, "phrase": "application_code"}, {"score": 0.0028566300478906916, "phrase": "global_consistency"}, {"score": 0.0027784560880013886, "phrase": "new_runtime_communications"}, {"score": 0.0027528751037412128, "phrase": "piggybacked_data"}, {"score": 0.002652878591019016, "phrase": "specific_fault-tolerant_message-passing_implementations"}, {"score": 0.0025447065763362984, "phrase": "compilation_technique"}, {"score": 0.0024522530645471065, "phrase": "spatial_coordination_protocol"}, {"score": 0.002396179086883187, "phrase": "static_analysis"}, {"score": 0.002341384304635523, "phrase": "heuristic_analysis"}, {"score": 0.0023198180380964305, "phrase": "computational_load"}, {"score": 0.0022149235007885826, "phrase": "automatic_checkpoint_insertion"}, {"score": 0.002164264600379492, "phrase": "classical_protocols"}, {"score": 0.0021245712108461227, "phrase": "uncoordinated_checkpointing"}, {"score": 0.0021049977753042253, "phrase": "distributed_snapshots"}], "paper_keywords": ["Fault tolerance", " checkpointing", " parallel programming", " message-passing", " compiler-support"], "paper_abstract": "Checkpointing tools may be typically implemented at two different abstraction levels: at the system level or at the application level. The latter has become a more popular alternative due to its flexibility and the possibility of operating in different environments. However, application-level checkpointing tools often require the user to manually insert checkpoints in order to ensure that certain requirements are met ( e. g. forcing checkpoints to be taken at the user code and not inside kernel routines). The approach presented in this work is twofold. First, a spatial coordination protocol for checkpointing parallel SPMD applications is proposed, based on forcing checkpoints to be taken at the same places in the application code by all processes. Thus, global consistency is achieved without adding any new runtime communications or piggybacked data, and without the need to use specific fault-tolerant message-passing implementations. Second, the paper also introduces a compilation technique for the automatic insertion of checkpoints using the spatial coordination protocol, based on a static analysis of communications and a heuristic analysis of computational load. These analyses can also be used to achieve automatic checkpoint insertion in approaches based on classical protocols, such as uncoordinated checkpointing or distributed snapshots.", "paper_title": "A Heuristic Approach for the Automatic Insertion of Checkpoints in Message-Passing Codes", "paper_id": "WOS:000273177900007"}