{"auto_keywords": [{"score": 0.04287116553907799, "phrase": "coinductive_prolog"}, {"score": 0.015720021303785386, "phrase": "prolog"}, {"score": 0.010660013081256659, "phrase": "standard_semantics"}, {"score": 0.009182855873533608, "phrase": "coinductive_definitions"}, {"score": 0.00798145223887783, "phrase": "cyclic_values"}, {"score": 0.004627168743964783, "phrase": "infinite_data"}, {"score": 0.00443308765153716, "phrase": "lazy_evaluation"}, {"score": 0.004325871055204964, "phrase": "haskell"}, {"score": 0.004221186370364584, "phrase": "infinite_regular_data"}, {"score": 0.0038389110156920926, "phrase": "formal_verification"}, {"score": 0.0036553070575015344, "phrase": "meta-programming_facilities"}, {"score": 0.003512591457930393, "phrase": "regular_corecursion"}, {"score": 0.0033651019362620866, "phrase": "new_interpreter"}, {"score": 0.0033037970113095577, "phrase": "non-terminating_failure"}, {"score": 0.0031457068207998143, "phrase": "swi-prolog"}, {"score": 0.0030043508031729277, "phrase": "existential_quantification"}, {"score": 0.002976849168883199, "phrase": "regular_term"}, {"score": 0.002851790448644913, "phrase": "finally_clauses"}, {"score": 0.002731971103291716, "phrase": "annotating_arguments"}, {"score": 0.002715268913787316, "phrase": "coinductive_predicates"}, {"score": 0.0025537472239953807, "phrase": "expressive_power"}, {"score": 0.002461472107682778, "phrase": "different_example_programs"}, {"score": 0.0023871221933990192, "phrase": "context_free_grammars"}, {"score": 0.002258893331333988, "phrase": "concise_and_relatively_simple_programs"}, {"score": 0.002210903392596343, "phrase": "vanilla_meta-interpreters"}, {"score": 0.002190648965946838, "phrase": "interesting_starting_point"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Logic programming", " Coinduction and corecursion"], "paper_abstract": "Corecursion is the ability of defining a function that produces some infinite data in terms of the function and the data itself, as supported by lazy evaluation. However, in languages such as Haskell strict operations fail to terminate even on infinite regular data, that is, cyclic data. Regular corecursion is naturally supported by coinductive Prolog, an extension where predicates can be interpreted either inductively or coinductively, that has proved to be useful for formal verification, static analysis and symbolic evaluation of programs. In this paper we use the meta-programming facilities offered by Prolog to propose extensions to coinductive Prolog aiming to make regular corecursion more expressive and easier to program with. First, we propose a new interpreter to solve the problem of non-terminating failure as experienced with the standard semantics of coinduction (as supported, for instance, in SWI-Prolog). Another problem with the standard semantics is that predicates expressed in terms of existential quantification over a regular term cannot directly defined by coinduction; to this aim, we introduce finally clauses, to allow more flexibility in coinductive definitions. Then we investigate the possibility of annotating arguments of coinductive predicates, to restrict coinductive definitions to a subset of the arguments; this allows more efficient definitions, and further enhance the expressive power of coinductive Prolog. We investigate the effectiveness of such features by showing different example programs manipulating several kinds of cyclic values, ranging from automata and context free grammars to graphs and repeating decimals; the examples show how computations on cyclic values can be expressed with concise and relatively simple programs. The semantics defined by these vanilla meta-interpreters are an interesting starting point for a more mature design and implementation of coinductive Prolog. (C) 2013 Elsevier Ltd. All rights reserved.", "paper_title": "Regular corecursion in Prolog", "paper_id": "WOS:000328715400003"}