{"auto_keywords": [{"score": 0.03338845738741894, "phrase": "architectural_models"}, {"score": 0.02903024767561201, "phrase": "abstract_interpretation"}, {"score": 0.00481495049065317, "phrase": "execution_time"}, {"score": 0.004621279527317074, "phrase": "semantics-based_program_verification_framework"}, {"score": 0.004574085781766281, "phrase": "critical_embedded_real-time_systems"}, {"score": 0.004504193207111593, "phrase": "worst-case_execution_time"}, {"score": 0.004367581653370531, "phrase": "safety_parameter"}, {"score": 0.004300830853119242, "phrase": "verification_algorithm"}, {"score": 0.004127753467337283, "phrase": "limited_computational_resources"}, {"score": 0.004085579055228594, "phrase": "efficient_resource_usage"}, {"score": 0.003861175855298779, "phrase": "abstract-carrying_code"}, {"score": 0.0038217550289936287, "phrase": "acc"}, {"score": 0.0037057255600764475, "phrase": "additional_verification_mechanism"}, {"score": 0.0036678472439508484, "phrase": "linear_programming"}, {"score": 0.0035382855372646164, "phrase": "certifying_properties"}, {"score": 0.0035021127041237887, "phrase": "duality_theory"}, {"score": 0.0033957904376127187, "phrase": "wcet_estimates"}, {"score": 0.0033096502887394233, "phrase": "wcet_verification_approach"}, {"score": 0.0031116963435584982, "phrase": "certifying_wcet_algorithm"}, {"score": 0.002986329509791943, "phrase": "arm_instruction_set"}, {"score": 0.002895620643297197, "phrase": "particular_instantiation"}, {"score": 0.002851301751761804, "phrase": "compositional_data-flow_framework"}, {"score": 0.002793260314529583, "phrase": "theoretic_foundations"}, {"score": 0.0027646829399573434, "phrase": "denotational_semantics"}, {"score": 0.0026945086500597304, "phrase": "data-flow_framework"}, {"score": 0.0026126405272417783, "phrase": "algorithmic_transformations"}, {"score": 0.0025726416100664853, "phrase": "verification_efficiency"}, {"score": 0.002494466951433885, "phrase": "verification_time"}, {"score": 0.0024311346712789553, "phrase": "multicore_architectures"}, {"score": 0.0021821915946356168, "phrase": "wcet_estimation"}], "paper_keywords": ["Abstract interpretation", " Abstraction-carrying code", " WCET", " LP", " LR-servers"], "paper_abstract": "This article presents a semantics-based program verification framework for critical embedded real-time systems using the worst-case execution time (WCET) as the safety parameter. The verification algorithm is designed to run on devices with limited computational resources where efficient resource usage is a requirement For this purpose, the framework of abstract-carrying code (ACC) is extended with an additional verification mechanism for linear programming (LP) by applying the certifying properties of duality theory to check the optimality of WCET estimates. Further, the WCET verification approach preserves feasibility and scalability when applied to multicore architectural models. The certifying WCET algorithm is targeted to architectural models based on the ARM instruction set and is presented as a particular instantiation of a compositional data-flow framework supported on the theoretic foundations of denotational semantics and abstract interpretation. The data-flow framework has algebraic properties that provide algorithmic transformations to increase verification efficiency, mainly in terms of verification time. The WCET analysis/verification on multicore architectures applies the formalism of latency-rate (LR.) servers, and proves its correctness in the context of abstract interpretation, in order to ease WCET estimation of programs sharing resources. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Certifying execution time in multicores", "paper_id": "WOS:000368556800007"}