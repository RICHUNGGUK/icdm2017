{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "terrain_analysis"}, {"score": 0.04682254053814278, "phrase": "union-find_problem"}, {"score": 0.029286139458111295, "phrase": "union-find_data_structure"}, {"score": 0.004394281902031765, "phrase": "n_union"}, {"score": 0.004287415750101536, "phrase": "union_operation"}, {"score": 0.003996133359116611, "phrase": "memory_size"}, {"score": 0.0039264465913491356, "phrase": "disk_block_size"}, {"score": 0.003804046908915231, "phrase": "worst_case"}, {"score": 0.003737697279708501, "phrase": "union_operations"}, {"score": 0.0033631279928072314, "phrase": "minimum_spanning_tree"}, {"score": 0.0033044432971036652, "phrase": "n_edges"}, {"score": 0.002890557197908352, "phrase": "height_function"}, {"score": 0.0027034263575471352, "phrase": "modern_mapping_technologies"}, {"score": 0.0026844452074327265, "phrase": "huge_amount"}, {"score": 0.0026655969705316708, "phrase": "elevation_data"}, {"score": 0.0023151639346874883, "phrase": "topological_persistence"}, {"score": 0.002258745901862197, "phrase": "contour_tree"}, {"score": 0.002157583854640276, "phrase": "input_terrain"}, {"score": 0.0021198904828154657, "phrase": "triangular_mesh"}, {"score": 0.0021049977753042253, "phrase": "n_vertices"}], "paper_keywords": ["I/O-efficient algorithms", " union-find"], "paper_abstract": "In this article we present an I/O-efficient algorithm for the batched (off-line) version of the union-find problem. Given any sequence of N union and find operations, where each union operation joins two distinct sets, our algorithm uses O(SORT(N)) = O(N/B logM/B N/B) I/Os, where M is the memory size and B is the disk block size. This bound is asymptotically optimal in the worst case. If there are union operations that join a set with itself, our algorithm uses O(SORT(N) + MST(N)) I/Os, where MST(N) is the number of I/Os needed to compute the minimum spanning tree of a graph with N edges. We also describe a simple and practical O(SORT(N) log(N/M))-I/O algorithm for this problem, which we have implemented. We are interested in the union-find problem because of its applications in terrain analysis. A terrain can be abstracted as a height function defined over R-2, and many problems that deal with such functions require a union-find data structure. With the emergence of modern mapping technologies, huge amount of elevation data is being generated that is too large to fit in memory, thus I/O-efficient algorithms are needed to process this data efficiently. In this article, we study two terrain-analysis problems that benefit from a union-find data structure: (i) computing topological persistence and (ii) constructing the contour tree. We give the first O(SORT(N))-I/O algorithms for these two problems, assuming that the input terrain is represented as a triangular mesh with N vertices.", "paper_title": "I/O-Efficient Batched Union-Find and Its Applications to Terrain Analysis", "paper_id": "WOS:000288825000011"}