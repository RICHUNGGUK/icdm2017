{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "parallel_programs"}, {"score": 0.004774530554776604, "phrase": "schedule_specialization"}, {"score": 0.004539005582217309, "phrase": "key_reason"}, {"score": 0.004406994912939125, "phrase": "enormous_number"}, {"score": 0.0043699845927285905, "phrase": "execution_inter-leavings"}, {"score": 0.004278807087784626, "phrase": "static_analysis"}, {"score": 0.0041194351307673556, "phrase": "poor_precision"}, {"score": 0.004084829853870028, "phrase": "dynamic_analysis"}, {"score": 0.003982741546775355, "phrase": "tiny_fraction"}, {"score": 0.003738502710504415, "phrase": "parallel_program"}, {"score": 0.0034504423179340738, "phrase": "static_analysis_results"}, {"score": 0.003378385493203297, "phrase": "schedule_specialization_framework"}, {"score": 0.003027178161479457, "phrase": "simpler_program"}, {"score": 0.002914288956035066, "phrase": "resultant_program"}, {"score": 0.002853396755102163, "phrase": "stock_analyses"}, {"score": 0.0028293966058473476, "phrase": "improved_precision"}, {"score": 0.0027469703311742647, "phrase": "precise_schedule-aware_def-use_analysis"}, {"score": 0.0021049977753042253, "phrase": "well-checked_programs"}], "paper_keywords": ["Algorithms", " Design", " Reliability", " Verification", " Specialization", " parallel programs", " multithreading", " control-flow analysis", " data-flow analysis", " constraint solving"], "paper_abstract": "Parallel programs are known to be difficult to analyze. A key reason is that they typically have an enormous number of execution inter-leavings, or schedules. Static analysis over all schedules requires over-approximations, resulting in poor precision; dynamic analysis rarely covers more than a tiny fraction of all schedules. We propose an approach called schedule specialization to analyze a parallel program over only a small set of schedules for precision, and then enforce these schedules at runtime for soundness of the static analysis results. We build a schedule specialization framework for C/C++ multithreaded programs that use Pthreads. Our framework avoids the need to modify every analysis to be schedule-aware by specializing a program into a simpler program based on a schedule, so that the resultant program can be analyzed with stock analyses for improved precision. Moreover, our framework provides a precise schedule-aware def-use analysis on memory locations, enabling us to build three highly precise analyses: an alias analyzer, a data-race detector, and a path slicer. Evaluation on 17 programs, including 2 real-world programs and 15 popular benchmarks, shows that analyses using our framework reduced may-aliases by 61.9%, false race reports by 69%, and path slices by 48.7%; and detected 7 unknown bugs in well-checked programs.", "paper_title": "Sound and Precise Analysis of Parallel Programs through Schedule Specialization", "paper_id": "WOS:000307582100019"}