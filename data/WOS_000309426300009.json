{"auto_keywords": [{"score": 0.04896125332848592, "phrase": "parallel_pipelined_filter"}, {"score": 0.03145208061134155, "phrase": "precedence_constraints"}, {"score": 0.022843588953236495, "phrase": "np-hard"}, {"score": 0.00481495049065317, "phrase": "parallel_pipelined_filter_ordering"}, {"score": 0.004546666837896004, "phrase": "n_filters"}, {"score": 0.003972673543700013, "phrase": "unit_time"}, {"score": 0.003789322824699646, "phrase": "random_element"}, {"score": 0.0034944094552943, "phrase": "parallel_query_optimization"}, {"score": 0.0034475308539463323, "phrase": "query_processing"}, {"score": 0.0034243271052114234, "phrase": "web_services"}, {"score": 0.003266201217790818, "phrase": "tree-structured_precedence_constraints"}, {"score": 0.003168413874902081, "phrase": "condon_et_al"}, {"score": 0.0031048496409917478, "phrase": "kodialam"}, {"score": 0.002892219926795975, "phrase": "sparse_solution"}, {"score": 0.002853396755102163, "phrase": "join_operators"}, {"score": 0.0028341804777934224, "phrase": "database_queries"}, {"score": 0.0027123819773059127, "phrase": "\"filter\"_selectivities"}, {"score": 0.0025958041241829254, "phrase": "strong_connection"}, {"score": 0.0025436978068459565, "phrase": "total_work"}, {"score": 0.00252656192077797, "phrase": "sequential_filter"}, {"score": 0.002321834168782981, "phrase": "polynomial_time"}, {"score": 0.0021049977753042253, "phrase": "arbitrary_precedence_constraints"}], "paper_keywords": ["Pipelined filter ordering", " parallel databases", " query optimization", " flow algorithms", " sequential testing"], "paper_abstract": "In the parallel pipelined filter ordering problem, we are given a set of n filters that run in parallel. The filters need to be applied to a stream of elements, to determine which elements pass all filters. Each filter has a rate limit r(i) on the number of elements it can process per unit time, and a selectivity p(i), which is the probability that a random element will pass the filter. The goal is to maximize throughput. This problem appears naturally in a variety of settings, including parallel query optimization in databases and query processing over Web services. We present an O(n(3)) algorithm for this problem, given tree-structured precedence constraints on the filters. This extends work of Condon et al. [2009] and Kodialam [2001], who presented algorithms for solving the problem without precedence constraints. Our algorithm is combinatorial and produces a sparse solution. Motivated by join operators in database queries, we also give algorithms for versions of the problem in which \"filter\" selectivities may be greater than or equal to 1. We prove a strong connection between the more classical problem of minimizing total work in sequential filter ordering (A), and the parallel pipelined filter ordering problem (B). More precisely, we prove that A is solvable in polynomial time for a given class of precedence constraints if and only if B is as well. This equivalence allows us to show that B is NP-Hard in the presence of arbitrary precedence constraints (since A is known to be NP-Hard in that setting).", "paper_title": "Parallel Pipelined Filter Ordering with Precedence Constraints", "paper_id": "WOS:000309426300009"}