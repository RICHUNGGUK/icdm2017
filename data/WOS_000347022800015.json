{"auto_keywords": [{"score": 0.04006150269648473, "phrase": "different_toolsets"}, {"score": 0.012987541481580255, "phrase": "binary_codes"}, {"score": 0.011678002041562672, "phrase": "new_metrics"}, {"score": 0.009909251464088957, "phrase": "busybox_tool"}, {"score": 0.00481495049065317, "phrase": "differently_compiled_binaries"}, {"score": 0.004712913906047687, "phrase": "unauthorized_use"}, {"score": 0.004669845451682529, "phrase": "software_library"}, {"score": 0.004627168743964783, "phrase": "clone_detection_problem"}, {"score": 0.004556901872357751, "phrase": "commercial_products"}, {"score": 0.004529093447865156, "phrase": "additional_complexity"}, {"score": 0.004093901605219401, "phrase": "different_binary_codes"}, {"score": 0.0038862297330905836, "phrase": "common_software_library"}, {"score": 0.003700371064796848, "phrase": "software_metrics"}, {"score": 0.0036553070575015344, "phrase": "high_level_languages"}, {"score": 0.003512591457930393, "phrase": "syntactical_changes"}, {"score": 0.003334309053314909, "phrase": "metric_values"}, {"score": 0.0032436052954996097, "phrase": "training_data"}, {"score": 0.0030414140732789186, "phrase": "stamp_benchmark"}, {"score": 0.0029677378488677983, "phrase": "different_modes"}, {"score": 0.002886981828647614, "phrase": "stamp"}, {"score": 0.0027069560455629917, "phrase": "used_compiling_toolset"}, {"score": 0.0024766170166319735, "phrase": "arithmetic_instructions"}, {"score": 0.0023507916951658455, "phrase": "target_addresses"}, {"score": 0.002315012841166354, "phrase": "best_way"}, {"score": 0.0022313446699940534, "phrase": "geometric_mean"}, {"score": 0.002210903392596343, "phrase": "previous_knowledge"}, {"score": 0.0021441057555396013, "phrase": "appropriate_transformer"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software clone", " Clone detection", " Semantic clone", " Software metric", " Binary code analysis"], "paper_abstract": "Context: Detection of an unauthorized use of a software library is a clone detection problem that in case of commercial products has additional complexity due to the fact that only binary code is available. Objective: The goal of this paper is to propose an approach for estimating the level of similarity between the procedures originating from different binary codes. The assumption is that the clones in the binary codes come from the use of a common software library that may be compiled with different toolsets. Method: The approach uses a set of software metrics adapted from the high level languages and it also extends the set with new metrics that take into account syntactical changes that are introduced by the usage of different toolsets and optimizations. Moreover, the approach compares metric values and introduces transformers and formulas that can use training data for production of measure of similarities between the two procedures in binary codes. The approach has been evaluated on programs from STAMP benchmark and BusyBox tool, compiled with different toolsets in different modes. Results: The experiments with programs from STAMP benchmark show that detecting the same procedures recall can be up to 1.44 times higher using new metrics. Knowledge about the used compiling toolset can bring up to 2.28 times improvement in recall. The experiment with BusyBox tool shows 43% recall for 43% precision. Conclusion: The most useful newly proposed metrics are those that consider the frequency of arithmetic instructions, the number and frequency of occurrences for instructions, and the number of occurrences for target addresses in calls. The best way to combine the results of comparing metrics is to use a geometric mean or when previous knowledge is available, to use an arithmetic mean with appropriate transformer. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Approach for estimating similarity between procedures in differently compiled binaries", "paper_id": "WOS:000347022800015"}