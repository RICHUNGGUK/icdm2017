{"auto_keywords": [{"score": 0.03504330295761371, "phrase": "conceptual_model"}, {"score": 0.03447491429759028, "phrase": "base_program"}, {"score": 0.01414301060036108, "phrase": "fragile_pointcut_problem"}, {"score": 0.00481495049065317, "phrase": "aspect-oriented_software"}, {"score": 0.004761132425263795, "phrase": "model-based_pointcuts"}, {"score": 0.004551781491498328, "phrase": "aspect-oriented_programs"}, {"score": 0.004450568197899267, "phrase": "evolution_problems"}, {"score": 0.004278807087784626, "phrase": "seemingly_safe_modifications"}, {"score": 0.004207230913063179, "phrase": "base_code"}, {"score": 0.00413684709497912, "phrase": "aspect-oriented_program"}, {"score": 0.004044822781630218, "phrase": "unexpected_impact"}, {"score": 0.0036966717141736355, "phrase": "broken_aspect_functionality"}, {"score": 0.0036347979916389467, "phrase": "accidental_join_point_misses"}, {"score": 0.0035941231858949035, "phrase": "unintended_join_point"}, {"score": 0.0028857130140890787, "phrase": "effective_decoupling"}, {"score": 0.0027898428590137515, "phrase": "base_program's_structure"}, {"score": 0.0025638362414466278, "phrase": "potential_fragile_pointcut_conflicts"}, {"score": 0.0024926348205500715, "phrase": "structural_and_semantic_constraints"}, {"score": 0.0022270182923887012, "phrase": "model-based_pointcut_mechanism"}, {"score": 0.0021049977753042253, "phrase": "smallwiki"}], "paper_keywords": [""], "paper_abstract": "In spite of the more advanced modularisation mechanisms, aspect-oriented programs still suffer from evolution problems. Due to the fragile pointcut problem, seemingly safe modifications to the base code of an aspect-oriented program can have an unexpected impact on the semantics of the pointcuts defined in that program. This can lead to broken aspect functionality due to accidental join point misses and unintended join point captures. We tackle this problem by declaring pointcuts in terms of a conceptual model of the base program, rather than defining them directly in terms of how the base program is structured. As such, we achieve an effective decoupling of the pointcuts from the base program's structure. In addition, the conceptual model provides a means to verify where and why potential fragile pointcut conflicts occur, by imposing structural and semantic constraints on the conceptual model, that can be verified when the base program evolves. To validate our approach we implemented a model-based pointcut mechanism, which we used to define some aspects on SmallWiki, a medium-sized application, and subsequently detected and resolved occurrences of the fragile pointcut problem when this application evolved.", "paper_title": "Managing the evolution of aspect-oriented software with model-based pointcuts", "paper_id": "WOS:000239558900027"}