{"auto_keywords": [{"score": 0.04842456838190479, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "data_flow_fusion"}, {"score": 0.0047310525657970615, "phrase": "series_expressions"}, {"score": 0.004567596860086148, "phrase": "existing_approaches"}, {"score": 0.004294962474996283, "phrase": "straight-line_producer_consumer_pipelines"}, {"score": 0.0038989120088094185, "phrase": "generated_array"}, {"score": 0.003698442219929622, "phrase": "branching_data_flows"}, {"score": 0.0031289290660162145, "phrase": "intermediate_array"}, {"score": 0.00304737045343781, "phrase": "branch_point"}, {"score": 0.0029161225023394363, "phrase": "new_array_fusion_system"}, {"score": 0.0027417911324611917, "phrase": "waters's_series_expression_framework"}, {"score": 0.002555247330102505, "phrase": "functional_setting"}, {"score": 0.0024236964502593254, "phrase": "related_problem"}, {"score": 0.002381365139274329, "phrase": "stream_fusion"}, {"score": 0.002258745901862197, "phrase": "duplicate_loop_counters"}, {"score": 0.002142426911242168, "phrase": "existing_fusion_systems"}], "paper_keywords": ["Arrays", " Fusion", " Haskell"], "paper_abstract": "Existing approaches to array fusion can deal with straight-line producer consumer pipelines, but cannot fuse branching data flows where a generated array is consumed by several different consumers. Branching data flows are common and natural to write, but a lack of fusion leads to the creation of an intermediate array at every branch point. We present a new array fusion system that handles branches, based on Waters's series expression framework, but extended to work in a functional setting. Our system also solves a related problem in stream fusion, namely the introduction of duplicate loop counters. We demonstrate speedup over existing fusion systems for several key examples.", "paper_title": "Data Flow Fusion with Series Expressions in Haskell", "paper_id": "WOS:000331119900009"}