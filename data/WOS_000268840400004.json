{"auto_keywords": [{"score": 0.0486868426803837, "phrase": "jbc"}, {"score": 0.03880548739810384, "phrase": "interpretive_decompilation"}, {"score": 0.01572001783989537, "phrase": "prolog"}, {"score": 0.015605442628185794, "phrase": "partial_evaluation"}, {"score": 0.004709567162738894, "phrase": "java_bytecode"}, {"score": 0.004489046493029801, "phrase": "three-address_code"}, {"score": 0.004374593906165761, "phrase": "operand_stack"}, {"score": 0.00424734451992536, "phrase": "model_checkers"}, {"score": 0.004108589735101849, "phrase": "higher-level_representation"}, {"score": 0.0040334640350288, "phrase": "traditional_decompilation"}, {"score": 0.003945117054416623, "phrase": "java_source"}, {"score": 0.003802135020791801, "phrase": "good_input"}, {"score": 0.0037602557461171478, "phrase": "subsequent_phases"}, {"score": 0.0035708152831417104, "phrase": "compiled_language"}, {"score": 0.003441352119167824, "phrase": "high-level_language"}, {"score": 0.003126224853287381, "phrase": "important_open_issues"}, {"score": 0.0030464123943266673, "phrase": "real_language"}, {"score": 0.003012831982759529, "phrase": "jbc."}, {"score": 0.002882160722418316, "phrase": "first_modular_scheme"}, {"score": 0.0028189599390180536, "phrase": "realistic_programming_language"}, {"score": 0.0027878797103973313, "phrase": "high-level_representation"}, {"score": 0.0025137856138000036, "phrase": "program_point"}, {"score": 0.0023781827711414107, "phrase": "realistic_benchmarks"}, {"score": 0.0023346234464901978, "phrase": "decompiled_program_sizes"}, {"score": 0.002258212866482022, "phrase": "input_bytecode_program"}, {"score": 0.0021842976754894846, "phrase": "modular_decompilation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Program transformation", " Partial evaluation", " Decompilation", " Interpreters", " Java bytecode", " Logic programming"], "paper_abstract": "Reasoning about Java bytecode (JBC) is complicated due to its unstructured control-flow, the use of three-address code combined with the use of an operand stack, etc. Therefore, many static analyzers and model checkers for JBC first convert the code into a higher-level representation. In contrast to traditional decompilation, such representation is often not Java source, but rather some intermediate language which is a good input for the subsequent phases of the tool. Interpretive decompilation consists in partially evaluating an interpreter for the compiled language (in this case JBC) written in a high-level language with respect to the code to be decompiled. There have been proofs-of-concept that interpretive decompilation is feasible, but there remain important open issues when it comes to decompile a real language such as JBC. This paper presents, to the best of our knowledge, the first modular scheme to enable interpretive decompilation of a realistic programming language to a high-level representation, namely of JBC to Prolog. We introduce two notions of optimality, which together require that decompilation does not generate code more than once for each program point. We demonstrate the impact of our modular approach and optimality issues on a series of realistic benchmarks. Decompilation times and decompiled program sizes are! linear with the size of the input bytecode program. This demonstrates empirically the scalability, of modular decompilation of JBC by partial evaluation. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Decompilation of Java bytecode to Prolog by partial evaluation", "paper_id": "WOS:000268840400004"}