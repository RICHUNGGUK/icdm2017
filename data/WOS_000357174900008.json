{"auto_keywords": [{"score": 0.04625336728938103, "phrase": "root_cause"}, {"score": 0.03401790463741915, "phrase": "potential_causes"}, {"score": 0.00481495049065317, "phrase": "software_failures"}, {"score": 0.0047707093928203, "phrase": "cascade_fault_localization"}, {"score": 0.0047051051659828275, "phrase": "software_debugging"}, {"score": 0.004640398886726948, "phrase": "significant_amount"}, {"score": 0.004370087541308677, "phrase": "manifested_failure"}, {"score": 0.004192190072470619, "phrase": "cascade_fault_localization_method"}, {"score": 0.004077616905584829, "phrase": "labor-intensive_process"}, {"score": 0.00398452530840582, "phrase": "weakest_precondition_computation"}, {"score": 0.003839962121679795, "phrase": "cause_tree"}, {"score": 0.0037177622939493084, "phrase": "potential_cause"}, {"score": 0.0035663245542174224, "phrase": "casual_relationship"}, {"score": 0.0033428820402140683, "phrase": "existing_methods"}, {"score": 0.0030759821501544224, "phrase": "proper_context"}, {"score": 0.002843450389745497, "phrase": "tree_structure"}, {"score": 0.002714943351733626, "phrase": "domain_knowledge"}, {"score": 0.0025565050791036973, "phrase": "software_tool"}, {"score": 0.0024636239664210433, "phrase": "llvm_compiler"}, {"score": 0.0024409345168575833, "phrase": "klee_symbolic_virtual_machine"}, {"score": 0.0023522423291484212, "phrase": "large_set"}, {"score": 0.0023305762840188145, "phrase": "public_benchmarks"}, {"score": 0.00229844995872581, "phrase": "real_applications"}, {"score": 0.0022772782536385717, "phrase": "gnu_coreutils"}, {"score": 0.002256301798333696, "phrase": "busybox"}, {"score": 0.0021049977753042253, "phrase": "execution_trace"}], "paper_keywords": ["Verification", " Reliability", " Algorithms", " fault localization", " weakest precondition", " constraint", " satisfiability modulo theory (SMT)"], "paper_abstract": "During software debugging, a significant amount of effort is required for programmers to identify the root cause of a manifested failure. In this article, we propose a cascade fault localization method to help speed up this labor-intensive process via a combination of weakest precondition computation and constraint solving. Our approach produces a cause tree, where each node is a potential cause of the failure and each edge represents a casual relationship between two causes. There are two main contributions of this article that differentiate our approach from existing methods. First, our method systematically computes all potential causes of a failure and augments each cause with a proper context for ease of comprehension by the user. Second, our method organizes the potential causes in a tree structure to enable on-the-fly pruning based on domain knowledge and feedback from the user. We have implemented our new method in a software tool called CaFL, which builds upon the LLVM compiler and KLEE symbolic virtual machine. We have conducted experiments on a large set of public benchmarks, including real applications from GNU Coreutils and Busybox. Our results show that in most cases the user has to examine only a small fraction of the execution trace before identifying the root cause of the failure.", "paper_title": "Explaining Software Failures by Cascade Fault Localization", "paper_id": "WOS:000357174900008"}