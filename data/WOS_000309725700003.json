{"auto_keywords": [{"score": 0.04571345706034806, "phrase": "ip_mechanisms"}, {"score": 0.015719716506582538, "phrase": "incremental_programming"}, {"score": 0.011524201791584355, "phrase": "modular_reasoning"}, {"score": 0.00915431114340114, "phrase": "side_effects"}, {"score": 0.0046432244185370605, "phrase": "programming_style"}, {"score": 0.0045804107341714, "phrase": "new_program_components"}, {"score": 0.004337502738649814, "phrase": "object-oriented_programming_inheritance"}, {"score": 0.00429828390000229, "phrase": "aspect-oriented_programming_advice"}, {"score": 0.004240116703465252, "phrase": "feature-oriented_programming"}, {"score": 0.004051828608343507, "phrase": "individual_components"}, {"score": 0.0035515951985356374, "phrase": "notoriously_hard_problem"}, {"score": 0.0032135959043774085, "phrase": "other's_control"}, {"score": 0.002894492955183223, "phrase": "haskell"}, {"score": 0.00266693888510356, "phrase": "powerful_reasoning_techniques"}, {"score": 0.002548331088496964, "phrase": "algebraic_laws"}, {"score": 0.002525248554951453, "phrase": "effectful_operations"}, {"score": 0.0022434880661725493, "phrase": "interference_literature"}, {"score": 0.002133937537670312, "phrase": "non-trivial_combination"}], "paper_keywords": [""], "paper_abstract": "Incremental Programming (IP) is a programming style in which new program components are defined as increments of other components. Examples of IP mechanisms include Object-oriented programming inheritance, aspect-oriented programming advice, and feature-oriented programming. A characteristic of IP mechanisms is that, while individual components can be independently defined, the composition of components makes those components become tightly coupled, sharing both control and data flows. This makes reasoning about IP mechanisms a notoriously hard problem: modular reasoning about a component becomes very difficult; and it is very hard to tell if two tightly coupled components interfere with each other's control and data flows. This paper presents modular reasoning about interference (MRI), a purely functional model of IP embedded in Haskell. MRI models inheritance with mixins and side effects with monads. It comes with a range of powerful reasoning techniques: equational reasoning, parametricity, and reasoning with algebraic laws about effectful operations. These techniques enable MRI in the presence of side effects. MRI formally captures harmlessness, a hard-to-formalize notion in the interference literature, in two theorems. We prove these theorems with a non-trivial combination of all three reasoning techniques.", "paper_title": "MRI: Modular reasoning about interference in incremental programming", "paper_id": "WOS:000309725700003"}