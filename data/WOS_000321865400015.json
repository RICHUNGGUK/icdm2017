{"auto_keywords": [{"score": 0.04894388481876893, "phrase": "clap"}, {"score": 0.007378763352468781, "phrase": "concurrency_bugs"}, {"score": 0.00481495049065317, "phrase": "recording_local_executions"}, {"score": 0.004765686919942249, "phrase": "concurrency_failures"}, {"score": 0.004679539581057561, "phrase": "relaxed_memory_models"}, {"score": 0.004419426676931621, "phrase": "local_execution_paths"}, {"score": 0.004270429323002124, "phrase": "memory_dependencies"}, {"score": 0.004197817125707719, "phrase": "logged_execution"}, {"score": 0.004098221047046135, "phrase": "observed_bug"}, {"score": 0.0040562607160379936, "phrase": "second_step"}, {"score": 0.00396000980403964, "phrase": "thread_paths"}, {"score": 0.0038793218280304825, "phrase": "memory_model"}, {"score": 0.0037742798298349145, "phrase": "constraint_solver"}, {"score": 0.00365949103351756, "phrase": "purely_local_execution"}, {"score": 0.0035481809241908044, "phrase": "memory_interactions"}, {"score": 0.0034284557556382815, "phrase": "previous_approaches"}, {"score": 0.0032675746199502614, "phrase": "added_memory_barriers"}, {"score": 0.0028678347187083165, "phrase": "tso"}, {"score": 0.0028482111015026494, "phrase": "pso"}, {"score": 0.002799703831407504, "phrase": "sequential_consistency"}, {"score": 0.0026958888229781618, "phrase": "original_one"}, {"score": 0.002631832840403278, "phrase": "minimal_thread_context_switches"}, {"score": 0.002587010112064415, "phrase": "scalability_issues"}, {"score": 0.0025168721570288295, "phrase": "parallelize_constraint_solving"}, {"score": 0.002440231768165477, "phrase": "arbitrary_execution_length"}, {"score": 0.002423519259896573, "phrase": "experimental_results"}, {"score": 0.002382235844852208, "phrase": "multithreaded_benchmarks"}, {"score": 0.00236591959343317, "phrase": "real_world_concurrent_applications"}, {"score": 0.002163682878218085, "phrase": "state-of-the-art_technique"}, {"score": 0.0021049977753042253, "phrase": "execution_time_overhead"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Theory", " Concurrency", " Bug Reproduction", " Local Execution", " Constraint Solving"], "paper_abstract": "We present CLAP, a new technique to reproduce concurrency bugs. CLAP has two key steps. First, it logs thread local execution paths at runtime. Second, offline, it computes memory dependencies that accord with the logged execution and are able to reproduce the observed bug. The second step works by combining constraints from the thread paths and constraints based on a memory model, and computing an execution with a constraint solver. CLAP has four major advantages. First, logging purely local execution of each thread is substantially cheaper than logging memory interactions, which enables CLAP to be efficient compared to previous approaches. Second, our logging does not require any synchronization and hence with no added memory barriers or fences; this minimizes perturbation and missed bugs due to extra synchronizations foreclosing certain racy behaviors. Third, since it uses no synchronization, we extend CLAP to work on a range of relaxed memory models, such as TSO and PSO, in addition to sequential consistency. Fourth, CLAP can compute a much simpler execution than the original one, that reveals the bug with minimal thread context switches. To mitigate the scalability issues, we also present an approach to parallelize constraint solving, which theoretically scales our technique to programs with arbitrary execution length. Experimental results on a variety of multithreaded benchmarks and real world concurrent applications validate these advantages by showing that our technique is effective in reproducing concurrency bugs even under relaxed memory models; furthermore, it is significantly more efficient than a state-of-the-art technique that records shared memory dependencies, reducing execution time overhead by 45% and log size by 88% on average.", "paper_title": "CLAP: Recording Local Executions to Reproduce Concurrency Failures", "paper_id": "WOS:000321865400015"}