{"auto_keywords": [{"score": 0.05007631478617985, "phrase": "index_coding"}, {"score": 0.049816308116704816, "phrase": "side_information"}, {"score": 0.046672402720507176, "phrase": "index_coding_scheme"}, {"score": 0.037537504759411304, "phrase": "singleton"}, {"score": 0.02345060718839371, "phrase": "static_ecics"}, {"score": 0.004634608287151734, "phrase": "birk"}, {"score": 0.004609405025862562, "phrase": "kol"}, {"score": 0.004436716583179764, "phrase": "transmitted_symbols"}, {"score": 0.004329124434198367, "phrase": "error-correcting_methods"}, {"score": 0.0040992419283370435, "phrase": "side_information_hypergraph"}, {"score": 0.004043696733749226, "phrase": "maximal_number"}, {"score": 0.004021689117050817, "phrase": "erroneous_symbols"}, {"score": 0.003967190585801111, "phrase": "shortest_length"}, {"score": 0.0039348451962364, "phrase": "linear_index_code"}, {"score": 0.0038184768146120773, "phrase": "required_information"}, {"score": 0.0036553070575015344, "phrase": "shortest_length_error-correcting_code"}, {"score": 0.003625495268063948, "phrase": "prescribed_error-correcting_capability"}, {"score": 0.0035959257387697097, "phrase": "classical_coding_theory"}, {"score": 0.0033770679620017366, "phrase": "optimal_length"}, {"score": 0.003349517793727593, "phrase": "linear_error-correcting_index_code"}, {"score": 0.003277140908834426, "phrase": "large_alphabets"}, {"score": 0.0031975786158658158, "phrase": "optimal_index_code"}, {"score": 0.0031714880645482496, "phrase": "maximum_distance_separable_classical_code"}, {"score": 0.0030860426028530646, "phrase": "smaller_alphabets"}, {"score": 0.002986532180741284, "phrase": "random_construction"}, {"score": 0.0028666313115584853, "phrase": "optimal_linear"}, {"score": 0.0028123321837622943, "phrase": "error-correcting_decoding"}, {"score": 0.0027817666907529546, "phrase": "ecic"}, {"score": 0.0026920404458807444, "phrase": "correctly_the_desired_symbol"}, {"score": 0.0025768806441902295, "phrase": "affine_space"}, {"score": 0.002555841674475421, "phrase": "actual_error_vector"}, {"score": 0.002534974041090166, "phrase": "syndrome_decoding"}, {"score": 0.0024937472415523395, "phrase": "correct_output"}, {"score": 0.0024531892728646004, "phrase": "error_pattern"}, {"score": 0.0024067025753962013, "phrase": "error-correcting_capability"}, {"score": 0.0023870497011682676, "phrase": "corresponding_ecic."}, {"score": 0.002348222961789711, "phrase": "static_ecic"}, {"score": 0.002260059968281536, "phrase": "index_coding_problem"}, {"score": 0.0021049977753042253, "phrase": "weakly_resilient_boolean_functions"}], "paper_keywords": ["Broadcast", " error correction", " index coding", " minimum distance", " network coding", " side information"], "paper_abstract": "A problem of index coding with side information was first considered by Birk and Kol in 1998. In this study, a generalization of index coding scheme, where transmitted symbols are subject to errors, is studied. Error-correcting methods for such a scheme, and their parameters, are investigated. In particular, the following question is discussed: given the side information hypergraph of index coding scheme and the maximal number of erroneous symbols, what is the shortest length of a linear index code, such that every receiver is able to recover the required information? This question turns out to be a generalization of the problem of finding a shortest length error-correcting code with a prescribed error-correcting capability in the classical coding theory. The Singleton bound and two other bounds, referred to as the alpha-bound and the kappa-bound, for the optimal length of a linear error-correcting index code (ECIC) are established. For large alphabets, a construction based on concatenation of an optimal index code with a maximum distance separable classical code is shown to attain the Singleton bound. For smaller alphabets, however, this construction may not be optimal. A random construction is also analyzed. It yields another inexplicit bound on the length of an optimal linear ECIC. Further, the problem of error-correcting decoding by a linear ECIC is studied. It is shown that in order to decode correctly the desired symbol, the decoder is required to find one of the vectors, belonging to an affine space containing the actual error vector. The syndrome decoding is shown to produce the correct output if the weight of the error pattern is less or equal to the error-correcting capability of the corresponding ECIC. Finally, the notion of static ECIC, which is suitable for use with a family of instances of an index coding problem, is introduced. Several bounds on the length of static ECICs are derived, and constructions for static ECICs are discussed. Connections of these codes to weakly resilient Boolean functions are established.", "paper_title": "Error Correction for Index Coding With Side Information", "paper_id": "WOS:000315120400019"}