{"auto_keywords": [{"score": 0.04666794416407739, "phrase": "concurrency_bugs"}, {"score": 0.03880550409822826, "phrase": "new_bugs"}, {"score": 0.03253253627295769, "phrase": "afix"}, {"score": 0.00481495049065317, "phrase": "automated_atomicity-violation"}, {"score": 0.004721162131188487, "phrase": "software_bugs"}, {"score": 0.004606479650820579, "phrase": "important_and_time-consuming_process"}, {"score": 0.004321118442104989, "phrase": "multicore_era"}, {"score": 0.004053362743156545, "phrase": "non-deterministic_failures"}, {"score": 0.004013662619667083, "phrase": "tricky_parallel_reasoning"}, {"score": 0.003896871009090446, "phrase": "original_problem"}, {"score": 0.0037834649508375544, "phrase": "good_patch"}, {"score": 0.0036553070575015344, "phrase": "degrading_performance"}, {"score": 0.003566422652043389, "phrase": "software_readability"}, {"score": 0.003531474887552889, "phrase": "existing_tools"}, {"score": 0.003445591238183763, "phrase": "whole_fixing_process"}, {"score": 0.0033950634506367235, "phrase": "good-quality_patches"}, {"score": 0.0032160319265621285, "phrase": "whole_process"}, {"score": 0.0031377955308198634, "phrase": "concurrency_bug"}, {"score": 0.0031070348334684356, "phrase": "single-variable_atomicity_violations"}, {"score": 0.003016544840824688, "phrase": "bug_reports"}, {"score": 0.002986969236641105, "phrase": "existing_bug-detection_tools"}, {"score": 0.002899965889623787, "phrase": "static_analysis"}, {"score": 0.002843372121209168, "phrase": "suitable_patch"}, {"score": 0.0028016507334576216, "phrase": "bug_report"}, {"score": 0.00266693888510356, "phrase": "multiple_bugs"}, {"score": 0.002640781900605126, "phrase": "better_performance"}, {"score": 0.0026148807877309417, "phrase": "code_readability"}, {"score": 0.0025638362414466278, "phrase": "afix's_run-time_component"}, {"score": 0.0023117182131967523, "phrase": "eight_real-world_bugs"}, {"score": 0.002255431275670053, "phrase": "failure_probability"}, {"score": 0.0022005118194652704, "phrase": "afix_patches"}, {"score": 0.002125859121671525, "phrase": "similar_performance"}, {"score": 0.0021049977753042253, "phrase": "manually-designed_patches"}], "paper_keywords": ["Algorithms", " Experimentation", " Languages", " Measurement", " Performance", " Reliability", " Verification", " atomicity violations", " automated debugging", " concurrency", " critical regions", " deadlock", " mutex locks", " mutual exclusion", " patching", " static analysis"], "paper_abstract": "Fixing software bugs has always been an important and time-consuming process in software development. Fixing concurrency bugs has become especially critical in the multicore era. However, fixing concurrency bugs is challenging, in part due to non-deterministic failures and tricky parallel reasoning. Beyond correctly fixing the original problem in the software, a good patch should also avoid introducing new bugs, degrading performance unnecessarily, or damaging software readability. Existing tools cannot automate the whole fixing process and provide good-quality patches. We present AFix, a tool that automates the whole process of fixing one common type of concurrency bug: single-variable atomicity violations. AFix starts from the bug reports of existing bug-detection tools. It augments these with static analysis to construct a suitable patch for each bug report. It further tries to combine the patches of multiple bugs for better performance and code readability. Finally, AFix's run-time component provides testing customized for each patch. Our evaluation shows that patches automatically generated by AFix correctly eliminate six out of eight real-world bugs and significantly decrease the failure probability in the other two cases. AFix patches never introduce new bugs and usually have similar performance to manually-designed patches.", "paper_title": "Automated Atomicity-Violation Fixing", "paper_id": "WOS:000294609500034"}