{"auto_keywords": [{"score": 0.004694700982410345, "phrase": "fastest_known_method"}, {"score": 0.0046161999598320486, "phrase": "integer_multiplication"}, {"score": 0.004463096299091981, "phrase": "schonhage-strassen_algorithm"}, {"score": 0.0035240305920962766, "phrase": "prevailing_conjecture"}, {"score": 0.0032938942910948096, "phrase": "optimal_integer_multiplication_algorithm"}, {"score": 0.003027178161479457, "phrase": "major_step"}, {"score": 0.002853396755102163, "phrase": "upper_bound"}, {"score": 0.002389514188569084, "phrase": "running_time"}, {"score": 0.0023100907305651872, "phrase": "multitape_turing_machines"}, {"score": 0.0021049977753042253, "phrase": "boolean_circuits"}], "paper_keywords": ["integer multiplication", " discrete Fourier transform", " FFT", " complexity", " computer arithmetic"], "paper_abstract": "For more than 35 years, the fastest known method for integer multiplication has been the Schonhage-Strassen algorithm running in time O(n log n log log n). Under certain restrictive conditions, there is a corresponding Omega(n log n) lower bound. All this time, the prevailing conjecture has been that the complexity of an optimal integer multiplication algorithm is Theta(n log n). We take a major step towards closing the gap between the upper bound and the conjectured lower bound by presenting an algorithm running in time n log n2(O)(log* n). The running time bound holds for multitape Turing machines. The same bound is valid for the size of Boolean circuits.", "paper_title": "FASTER INTEGER MULTIPLICATION", "paper_id": "WOS:000270193400009"}