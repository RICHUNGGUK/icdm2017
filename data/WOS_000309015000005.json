{"auto_keywords": [{"score": 0.0461214201006367, "phrase": "balance_scale"}, {"score": 0.014936795889006864, "phrase": "false_coins"}, {"score": 0.010985018032136324, "phrase": "quantum_query_complexity"}, {"score": 0.0048219275162952905, "phrase": "quantum"}, {"score": 0.004692227830462433, "phrase": "counterfeit_coin_problem"}, {"score": 0.004001335931796133, "phrase": "number_k"}, {"score": 0.003130077012135034, "phrase": "k_false_coins"}, {"score": 0.002738523189244011, "phrase": "classical_query_complexity"}, {"score": 0.0025449518236394103, "phrase": "quartic_speed-up"}, {"score": 0.0023245746777044766, "phrase": "upper_bound"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Counterfeit coin problems", " Quantum computing", " Query complexity"], "paper_abstract": "The counterfeit coin problem requires us to find all false coins from a given bunch of coins using a balance scale. We assume that the balance scale gives us only \"balanced\" or \"tilted\" information and that we know the number k of false coins in advance. The balance scale can be modeled by a certain type of oracle and its query complexity is a measure for the cost of weighing algorithms (the number of weighings). In this paper, we study the quantum query complexity for this problem. Let Q(k, N) be the quantum query complexity of finding all k false coins from the N given coins. We show that for any k and N such that k < N/2, Q(k, N) = O(k(1/4)), contrasting with the classical query complexity, Omega (k log(N/k)), that depends on N. So our quantum algorithm achieves a quartic speed-up for this problem. We do not have a matching lower bound, but we show some evidence that the upper bound is tight: any algorithm, including our algorithm, that satisfies certain properties needs Omega(k(1/4)) queries. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Quantum counterfeit coin problems", "paper_id": "WOS:000309015000005"}