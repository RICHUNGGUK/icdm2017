{"auto_keywords": [{"score": 0.040028642553390774, "phrase": "software_architect"}, {"score": 0.00481495049065317, "phrase": "architectural_variability_models"}, {"score": 0.004779406424192843, "phrase": "plugin-based_systems"}, {"score": 0.004674333455266527, "phrase": "key_issue"}, {"score": 0.004588531238691602, "phrase": "software-intensive_systems"}, {"score": 0.0043404186974790706, "phrase": "customers'_needs"}, {"score": 0.0043083624695326745, "phrase": "specific_deployment_contexts"}, {"score": 0.004260719592945006, "phrase": "wide_form"}, {"score": 0.0041515831652973794, "phrase": "extensible_software_systems"}, {"score": 0.004045230861702083, "phrase": "plugin-based_architectures"}, {"score": 0.0038548668648948044, "phrase": "ideal_world"}, {"score": 0.0037145284903339327, "phrase": "system_variant"}, {"score": 0.0036059320136308808, "phrase": "particular_assembly"}, {"score": 0.0034875380341306468, "phrase": "variation_points"}, {"score": 0.003436169600453596, "phrase": "architectural_elements"}, {"score": 0.002929394386754424, "phrase": "unsafe_architectural_variants"}, {"score": 0.0028862231180242053, "phrase": "highest_possible_level"}, {"score": 0.002770745509774383, "phrase": "reverse_engineering_process"}, {"score": 0.0027299058905736456, "phrase": "variability_model"}, {"score": 0.002630414143385786, "phrase": "plugin-based_architecture"}, {"score": 0.0025916375737852506, "phrase": "automated_techniques"}, {"score": 0.002543967677678384, "phrase": "different_variability_descriptions"}, {"score": 0.0025064622665903645, "phrase": "hierarchical_software_architecture_model"}, {"score": 0.0024786956187352327, "phrase": "plugin_dependency_model"}, {"score": 0.0024512358145634358, "phrase": "software_architect_knowledge"}, {"score": 0.002353120949568249, "phrase": "architectural_feature_models"}, {"score": 0.0022091400304857043, "phrase": "large-scale_plugin-based_system"}, {"score": 0.0021604504765314497, "phrase": "different_versions"}], "paper_keywords": ["Variability", " Product lines", " Reverse engineering", " Software evolution", " Architecture recovery", " Configuration management"], "paper_abstract": "Variability management is a key issue when building and evolving software-intensive systems, making it possible to extend, configure, customize and adapt such systems to customers' needs and specific deployment contexts. A wide form of variability can be found in extensible software systems, typically built on top of plugin-based architectures that offer a (large) number of configuration options through plugins. In an ideal world, a software architect should be able to generate a system variant on-demand, corresponding to a particular assembly of plugins. To this end, the variation points and constraints between architectural elements should be properly modeled and maintained over time (i.e., for each version of an architecture). A crucial, yet error-prone and time-consuming, task for a software architect is to build an accurate representation of the variability of an architecture, in order to prevent unsafe architectural variants and reach the highest possible level of flexibility. In this article, we propose a reverse engineering process for producing a variability model (i.e., a feature model) of a plugin-based architecture. We develop automated techniques to extract and combine different variability descriptions, including a hierarchical software architecture model, a plugin dependency model and the software architect knowledge. By computing and reasoning about differences between versions of architectural feature models, software architect can control both the variability extraction and evolution processes. The proposed approach has been applied to a representative, large-scale plugin-based system (FraSCAti), considering different versions of its architecture. We report on our experience in this context.", "paper_title": "Extraction and evolution of architectural variability models in plugin-based systems", "paper_id": "WOS:000342493300009"}