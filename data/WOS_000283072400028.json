{"auto_keywords": [{"score": 0.030171599810403824, "phrase": "regenerating_codes"}, {"score": 0.015719716506582538, "phrase": "distributed_storage_systems"}, {"score": 0.010411755050352679, "phrase": "new_node"}, {"score": 0.004727837281331949, "phrase": "reliable_access"}, {"score": 0.004579147045265106, "phrase": "individually_unreliable_nodes"}, {"score": 0.004537525607322823, "phrase": "application_scenarios"}, {"score": 0.004496280772084575, "phrase": "data_centers"}, {"score": 0.004455409162867219, "phrase": "peer-to-peer_storage_systems"}, {"score": 0.0042178318724732005, "phrase": "erasure_code"}, {"score": 0.0040111533608228195, "phrase": "simple_replication"}, {"score": 0.003660879039645457, "phrase": "key_question"}, {"score": 0.0035781807623238905, "phrase": "encoded_fragments"}, {"score": 0.0035294580355761506, "phrase": "distributed_way"}, {"score": 0.003325852346387272, "phrase": "erasure_coded_system"}, {"score": 0.0032358709481309913, "phrase": "single_node_failure"}, {"score": 0.003119659433566212, "phrase": "whole_encoded_data_object"}, {"score": 0.0027073229284666294, "phrase": "stored_data"}, {"score": 0.0026704265616705023, "phrase": "surviving_nodes"}, {"score": 0.002551022760887132, "phrase": "repair_bandwidth"}, {"score": 0.00243694486220507, "phrase": "fundamental_tradeoff"}, {"score": 0.0023173287402646577, "phrase": "flow_arguments"}, {"score": 0.0022857351723674004, "phrase": "appropriately_constructed_graph"}, {"score": 0.002244277924422011, "phrase": "constructive_results"}, {"score": 0.0022238315004700607, "phrase": "network_coding"}, {"score": 0.0021049977753042253, "phrase": "optimal_tradeoff"}], "paper_keywords": ["Distributed storage", " network coding", " peer-to-peer storage", " regenerating codes"], "paper_abstract": "Distributed storage systems provide reliable access to data through redundancy spread over individually unreliable nodes. Application scenarios include data centers, peer-to-peer storage systems, and storage in wireless networks. Storing data using an erasure code, in fragments spread across nodes, requires less redundancy than simple replication for the same level of reliability. However, since fragments must be periodically replaced as nodes fail, a key question is how to generate encoded fragments in a distributed way while transferring as little data as possible across the network. For an erasure coded system, a common practice to repair from a single node failure is for a new node to reconstruct the whole encoded data object to generate just one encoded block. We show that this procedure is sub-optimal. We introduce the notion of regenerating codes, which allow a new node to communicate functions of the stored data from the surviving nodes. We show that regenerating codes can significantly reduce the repair bandwidth. Further, we show that there is a fundamental tradeoff between storage and repair bandwidth which we theoretically characterize using flow arguments on an appropriately constructed graph. By invoking constructive results in network coding, we introduce regenerating codes that can achieve any point in this optimal tradeoff.", "paper_title": "Network Coding for Distributed Storage Systems", "paper_id": "WOS:000283072400028"}