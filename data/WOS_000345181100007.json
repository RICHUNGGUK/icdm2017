{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "synchronous_paradigm"}, {"score": 0.004738078275822989, "phrase": "logical_abstraction"}, {"score": 0.004637478829869904, "phrase": "reactive_system_design"}, {"score": 0.004563427013973105, "phrase": "automatic_synthesis"}, {"score": 0.004514714250357749, "phrase": "embedded_systems"}, {"score": 0.004187917910692495, "phrase": "synchronous_model"}, {"score": 0.003701401653850141, "phrase": "complex_systems"}, {"score": 0.003526735797659508, "phrase": "causal_cycles"}, {"score": 0.0033602844686125375, "phrase": "key_property"}, {"score": 0.0030834712590249863, "phrase": "polychrony"}, {"score": 0.003034158379493625, "phrase": "perfect_synchrony"}, {"score": 0.002652639568848117, "phrase": "gals_systems"}, {"score": 0.0026242699269026204, "phrase": "kahn_process_networks"}, {"score": 0.002460295872115956, "phrase": "unified_constructive_semantic_framework"}, {"score": 0.0024339783012484032, "phrase": "structured_operational_semantics"}, {"score": 0.002306543826130521, "phrase": "multi-clocked_behavior"}], "paper_keywords": ["Synchronous programming", " Operational semantics", " Constructive systems", " Fixpoint theory", " Program verification"], "paper_abstract": "The synchronous paradigm provides a logical abstraction of time for reactive system design which allows automatic synthesis of embedded systems that behave in a predictable, timely, and reactive manner. According to the synchrony hypothesis, a synchronous model reacts to inputs by generating outputs that are immediately made available to the environment. While synchrony greatly simplifies the design of complex systems in general, it can sometimes lead to causal cycles. In these cases, constructiveness is a key property to guarantee that the output of each reaction can still be always algorithmically determined. Polychrony deviates from perfect synchrony by using a partially ordered, i.e., a relational model of time. It encompasses the behaviors of (implicitly) multi-clocked data-flow networks of synchronous modules and can analyze and synthesize them as GALS systems or Kahn process networks (KPNs). In this paper, we present a unified constructive semantic framework using structured operational semantics, which encompasses both the constructive behavior of synchronous modules and the multi-clocked behavior of polychronous networks. Along the way, we define the very first executable operational semantics of the polychronous language SIGNAL. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Constructive polychronous systems", "paper_id": "WOS:000345181100007"}