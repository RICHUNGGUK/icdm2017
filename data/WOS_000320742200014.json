{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "canonical_loops"}, {"score": 0.004620093797504386, "phrase": "compilation_technique"}, {"score": 0.004494570360108983, "phrase": "automatic_parallelization"}, {"score": 0.004283019592801715, "phrase": "recurring_pattern"}, {"score": 0.003997891221012094, "phrase": "frequent_itemset"}, {"score": 0.003943206903226289, "phrase": "k-means"}, {"score": 0.0038926348338472784, "phrase": "k"}, {"score": 0.003731673223879279, "phrase": "c_code"}, {"score": 0.0036301992752948956, "phrase": "stream_filters"}, {"score": 0.003459191419478298, "phrase": "channel_types"}, {"score": 0.0030554300179552415, "phrase": "suitable_communication_strategies"}, {"score": 0.0024501740852758505, "phrase": "available_processors"}, {"score": 0.0021940118003312397, "phrase": "hand_tuned_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Automatic parallelization", " Map-reduce", " Compiler", " Stream-programming"], "paper_abstract": "This paper presents a compilation technique that performs the automatic parallelization of canonical loops. Canonical loops are a recurring pattern that we have observed in many well known algorithms, such as frequent itemset, K-means and K nearest neighbors. Our compiler translates C code to sequences of stream filters that communicate through a variety of channel types. We analyze code containing canonical loops, separate the data over a cluster of processors and determine suitable communication strategies between these processors. Experiments performed on a cluster of 36 computers show that, for the three algorithms described above, our method produces speed-ups that are almost linear on the number of available processors. These experiments also show that the code automatically generated is competitive when compared to hand tuned programs. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Automatic parallelization of canonical loops", "paper_id": "WOS:000320742200014"}