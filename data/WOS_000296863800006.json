{"auto_keywords": [{"score": 0.042032386074769244, "phrase": "remote_caches"}, {"score": 0.03878424349807091, "phrase": "remote_cache"}, {"score": 0.00481495049065317, "phrase": "managing_capacity"}, {"score": 0.004757917303420435, "phrase": "cmp_architectures"}, {"score": 0.004720269202737973, "phrase": "private_caches"}, {"score": 0.004682917599491709, "phrase": "chip_multiprocessors"}, {"score": 0.004518442937844318, "phrase": "cache_fragmentation_problem"}, {"score": 0.004173244935967375, "phrase": "capacity_sharing_mechanisms"}, {"score": 0.004091130285858113, "phrase": "additional_cache_space"}, {"score": 0.0038696708318671446, "phrase": "victim_blocks"}, {"score": 0.0037188360359702182, "phrase": "high_number"}, {"score": 0.0034345152879289025, "phrase": "remote_cache_hits"}, {"score": 0.003287482882222731, "phrase": "newly_fetched_blocks"}, {"score": 0.003109390330476147, "phrase": "local_cache"}, {"score": 0.0030119758165837625, "phrase": "future_trace_information"}, {"score": 0.002964415652865295, "phrase": "near-upperbound_performance"}, {"score": 0.0028944757265206332, "phrase": "combined_placement"}, {"score": 0.0028715299874549245, "phrase": "replacement_decisions"}, {"score": 0.0028487656293168795, "phrase": "capacity_sharing"}, {"score": 0.002792638947473095, "phrase": "experimental_results"}, {"score": 0.0027159094186967247, "phrase": "adaptive_placement_policy"}, {"score": 0.002599560451267203, "phrase": "better_decision"}, {"score": 0.0025382066972107777, "phrase": "newly_fetched_block"}, {"score": 0.002508073621696602, "phrase": "local_or_remote_cache"}, {"score": 0.0023626775529531486, "phrase": "app's_capacity_sharing_mechanism"}, {"score": 0.002243521806418396, "phrase": "app"}, {"score": 0.0022168460543913787, "phrase": "state-of-the-art_capacity_sharing_mechanism"}, {"score": 0.0021049977753042253, "phrase": "maximum_degradation"}], "paper_keywords": ["Design", " Performance", " Measrument", " Memory systems", " chip multiprocessor", " private caches", " capacity sharing", " placement policies", " stack distance profiling", " limit studies", " QoS"], "paper_abstract": "Chip Multiprocessors (CMP) with distributed L2 caches suffer from a cache fragmentation problem; some caches may be overutilized while others may be underutilized. To avoid such fragmentation, researchers have proposed capacity sharing mechanisms where applications that need additional cache space can place their victim blocks in remote caches. However, we found that only allowing victim blocks to be placed on remote caches tends to cause a high number of remote cache hits relative to local cache hits. In this article, we show that many of the remote cache hits can be converted into local cache hits if we allow newly fetched blocks to be selectively placed directly in a remote cache, rather than in the local cache. To demonstrate this, we use future trace information to estimate the near-upperbound performance that can be gained from combined placement and replacement decisions in capacity sharing. Motivated by encouraging experimental results, we design a simple, predictor-based, scheme called Adaptive Placement Policy (APP) that learns from past cache behavior to make a better decision on whether to place a newly fetched block in the local or remote cache. We found that across 50 multiprogrammed workload mixes running on a 4-core CMP, APP's capacity sharing mechanism increases aggregate performance by 29% on average. At the same time, APP outperforms the state-of-the-art capacity sharing mechanism that uses only replacement-based decisions by up to 18.2%, with a maximum degradation of only 0.5%, and an average improvement of 3%.", "paper_title": "Evaluating Placement Policies for Managing Capacity Sharing in CMP Architectures with Private Caches", "paper_id": "WOS:000296863800006"}