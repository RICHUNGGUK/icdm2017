{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "counting_arguments"}, {"score": 0.00437302709192313, "phrase": "formal_verification"}, {"score": 0.004035777314816881, "phrase": "infinite_control"}, {"score": 0.0038152404172111815, "phrase": "unbounded_number"}, {"score": 0.0035208552733545463, "phrase": "recursive_procedures"}, {"score": 0.003121183062764093, "phrase": "fully_automated_techniques"}, {"score": 0.002974281028713475, "phrase": "key_questions"}, {"score": 0.0024922258873137093, "phrase": "counting_argument"}, {"score": 0.0021049977753042253, "phrase": "novel_solutions"}], "paper_keywords": ["Concurrency", " Verification", " Static Analysis"], "paper_abstract": "Counting arguments are among the most basic proof methods in mathematics. Within the field of formal verification, they are useful for reasoning about programs with infinite control, such as programs with an unbounded number of threads, or (concurrent) programs with recursive procedures. While counting arguments are common in informal, hand-written proofs of such programs, there are no fully automated techniques to construct counting arguments. The key questions involved in automating counting arguments are: how to decide what should be counted?, and how to decide when a counting argument is valid? In this paper, we present a technique for automatically constructing and checking counting arguments, which includes novel solutions to these questions.", "paper_title": "Proofs That Count", "paper_id": "WOS:000331120500014"}