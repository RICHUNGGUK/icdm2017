{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "jumbled_pattern_matching"}, {"score": 0.004611554879923759, "phrase": "finite_ordered_alphabet"}, {"score": 0.00459942401441004, "phrase": "sigma"}, {"score": 0.003952513974962462, "phrase": "parikh_vector_q"}, {"score": 0.0038561471948364723, "phrase": "substring_t"}, {"score": 0.0037971101834761017, "phrase": "q._the_problem"}, {"score": 0.003738973626996355, "phrase": "query_q"}, {"score": 0.0035260290145240464, "phrase": "sliding_window_approach"}, {"score": 0.0032742371135183195, "phrase": "first_algorithm"}, {"score": 0.0031845067058084583, "phrase": "binary_text"}, {"score": 0.0031357200369281344, "phrase": "linear_size_data_structure"}, {"score": 0.0029207251108325006, "phrase": "second_algorithm"}, {"score": 0.002814454488050123, "phrase": "arbitrary_alphabet"}, {"score": 0.002797121441432477, "phrase": "size_sigma"}, {"score": 0.002754253119972439, "phrase": "sub-linear_expected_time_complexity"}, {"score": 0.0026133424923929227, "phrase": "size_data_structure"}, {"score": 0.0025027144548626975, "phrase": "first_solution"}, {"score": 0.0024116163689723354, "phrase": "expected_query_time"}, {"score": 0.00224615642504509, "phrase": "parikh_vector_q."}, {"score": 0.0022185595808679, "phrase": "wavelet_trees"}, {"score": 0.0021913010538173825, "phrase": "expected_runtime"}, {"score": 0.0021049977753042253, "phrase": "log_m."}], "paper_keywords": ["Parikh vectors", " permuted strings", " pattern matching", " string algorithms", " average case analysis"], "paper_abstract": "The Parikh vector p(s) of a string s over a finite ordered alphabet Sigma = {a(1), . . . , a(sigma)} is defined as the vector of multiplicities of the characters, p(s) = (p(1), . . . , p(sigma)), where p(i) = vertical bar{j vertical bar s(j) = a(i)}vertical bar. Parikh vector q occurs in s if s has a substring t with p(t) = q. The problem of searching for a query q in a text s of length n can be solved simply and worst-case optimally with a sliding window approach in O(n) time. We present two novel algorithms for the case where the text is fixed and many queries arrive over time. The first algorithm only decides whether a given Parikh vector appears in a binary text. It uses a linear size data structure and decides each query in O(1) time. The preprocessing can be done trivially in Theta(n(2)) time. The second algorithm finds all occurrences of a given Parikh vector in a text over an arbitrary alphabet of size sigma >= 2 and has sub-linear expected time complexity. More precisely, we present two variants of the algorithm, both using an O(n) size data structure, each of which can be constructed in O(n) time. The first solution is very simple and easy to implement and leads to an expected query time of O(n(sigma/log sigma)(1/2) log m/root m), where m = Sigma(i) q(i) is the length of a string with Parikh vector q. The second uses wavelet trees and improves the expected runtime to O(n(sigma/log sigma)(1/2) 1 root m), i.e., by a factor of log m.", "paper_title": "ALGORITHMS FOR JUMBLED PATTERN MATCHING IN STRINGS", "paper_id": "WOS:000302061000009"}