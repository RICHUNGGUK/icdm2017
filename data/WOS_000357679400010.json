{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "loser_tree"}, {"score": 0.048231156244864744, "phrase": "k-hop_reachability"}, {"score": 0.032723156143854966, "phrase": "common_contacts"}, {"score": 0.004773040022691547, "phrase": "common_contacts_searching"}, {"score": 0.004731492618963217, "phrase": "large_graphs"}, {"score": 0.004450568197899267, "phrase": "considerable_attention"}, {"score": 0.004354315061804687, "phrase": "substantial_number"}, {"score": 0.0041316803676012155, "phrase": "searching_efficiency"}, {"score": 0.003752550907120244, "phrase": "large-scale_graphs"}, {"score": 0.003671338229632309, "phrase": "existing_algorithms"}, {"score": 0.003623453648863547, "phrase": "different_scholars"}, {"score": 0.003423042581201533, "phrase": "different_kinds"}, {"score": 0.0032621183241997777, "phrase": "new_algorithm"}, {"score": 0.0030148941188459987, "phrase": "large-scale_graph"}, {"score": 0.0029238768315330305, "phrase": "novel_algorithm"}, {"score": 0.0028731024405707277, "phrase": "graph_index"}, {"score": 0.0028480459059007468, "phrase": "binary_searching"}, {"score": 0.0027985846558073457, "phrase": "adjacent_list"}, {"score": 0.0026091594819333654, "phrase": "sequential_k-hop_contact"}, {"score": 0.0024218895273910943, "phrase": "efficient_algorithm"}, {"score": 0.002359046870732839, "phrase": "optimized_strategy"}, {"score": 0.0023384629381463054, "phrase": "k-hop_contact_set_serialization"}, {"score": 0.002287783663138828, "phrase": "synthetic_and_real_datasets"}, {"score": 0.0022480304016499605, "phrase": "proposed_zip_algorithm"}, {"score": 0.002123531043641047, "phrase": "breadth-first_searching"}, {"score": 0.0021050031046897367, "phrase": "grail"}], "paper_keywords": ["common contact", " k-hop query", " reachability", " social network"], "paper_abstract": "The problem of k-hop reachability between two vertices in a graph has received considerable attention in recent years. A substantial number of algorithms have been proposed with the goal of improving the searching efficiency of the k-hop reachability between two vertices in a graph. However, searching and traversing are challenging tasks, especially in large-scale graphs. Furthermore, the existing algorithms propounded by different scholars are not satisfactory in terms of feasibility and scalability when applied to different kinds of graphs. In this work, we propose a new algorithm, called Zip, in an attempt to efficiently determine the common contacts between any two random vertices in a large-scale graph. First, we describe a novel algorithm for constructing the graph index via binary searching which maintains the adjacent list of each vertex in order. Second, we present the ways to achieve a sequential k-hop contact set by using the loser tree, a merge sorting algorithm. Finally, we develop an efficient algorithm for querying common contacts and an optimized strategy for k-hop contact set serialization. Experimental results on synthetic and real datasets show that the proposed Zip algorithm outperforms existing state-of-the-art algorithms (e.g., breadth-first searching, GRAIL, the graph stratification algorithm).", "paper_title": "Zip: An Algorithm Based on Loser Tree for Common Contacts Searching in Large Graphs", "paper_id": "WOS:000357679400010"}