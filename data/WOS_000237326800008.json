{"auto_keywords": [{"score": 0.04796103779926308, "phrase": "wrong_choices"}, {"score": 0.00481495049065317, "phrase": "embedded_multimedia_applications"}, {"score": 0.004775531918452571, "phrase": "design_trotter"}, {"score": 0.00471700544744796, "phrase": "embedded_systems"}, {"score": 0.004659192888931046, "phrase": "challenging_task"}, {"score": 0.004527024978801684, "phrase": "extremely_costly_re-design_loops"}, {"score": 0.004344662696228875, "phrase": "algorithm_specification"}, {"score": 0.004238775572746022, "phrase": "selected_architecture"}, {"score": 0.004101579688745222, "phrase": "high-level_approach"}, {"score": 0.004067977399245212, "phrase": "design_space_exploration"}, {"score": 0.004001593118269276, "phrase": "usual_standard_language"}, {"score": 0.0035956327252723483, "phrase": "hcdfg"}, {"score": 0.0035369291417564606, "phrase": "control_data_flow_graph"}, {"score": 0.0033115124244647736, "phrase": "design_flow"}, {"score": 0.0030497740719977835, "phrase": "algorithmic_level"}, {"score": 0.0028202559386070873, "phrase": "design_process"}, {"score": 0.002762774046280398, "phrase": "algorithmic_choices"}, {"score": 0.002740109776120878, "phrase": "resource_requirements"}, {"score": 0.0025865679621853667, "phrase": "different_levels"}, {"score": 0.0025338369486914364, "phrase": "overall_aim"}, {"score": 0.0024116163689723333, "phrase": "implementation_efficiency"}, {"score": 0.0023721974375323267, "phrase": "silicon_area"}, {"score": 0.002333421318779658, "phrase": "energy_consumption"}, {"score": 0.0021224200236681498, "phrase": "suitable_architectures"}, {"score": 0.0021049977753042253, "phrase": "specific_applications"}], "paper_keywords": ["specification", " characterization", " algorithm/architecture matching", " design-space exploration", " SoCs"], "paper_abstract": "Designing embedded systems is a challenging task during which wrong choices can lead to extremely costly re-design loops, especially when these wrong choices are made during the algorithm specification and the mapping over the selected architecture. In this paper we propose a high-level approach for design space exploration, using a usual standard language as input. More precisely we present the two first steps of the Design Trotter framework: (i) the specification step and its underlying internal model (HCDFG: Hierarchical and Control Data Flow Graph) and (ii) the characterization step which takes place very early in the design flow. Indeed, once transformed into our internal representation, the specification is rapidly and automatically characterized and explored at the algorithmic level. The framework provides the designer with metrics so that he can evaluate, very early in the design process, the impact of algorithmic choices on resource requirements in terms of processing, control, memory bandwidth and potential parallelism at different levels of granularity. The overall aim of our approach is to improve the algorithm/architecture matching that sorely influences the implementation efficiency in terms of silicon area, performances and energy consumption. We give examples which illustrate how designers can refer to the outcomes of the Design Trotter framework in order to select or build suitable architectures for specific applications.", "paper_title": "Algorithmic-level specification and characterization of embedded multimedia applications with Design Trotter", "paper_id": "WOS:000237326800008"}