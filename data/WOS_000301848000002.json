{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "multi-task_real-time_embedded_systems"}, {"score": 0.004437910956996051, "phrase": "different_tasks"}, {"score": 0.004272164161788242, "phrase": "cache_management"}, {"score": 0.004157561334726201, "phrase": "cache_behavior"}, {"score": 0.003937459891461576, "phrase": "application's_worst-case_execution_time"}, {"score": 0.003831801113154043, "phrase": "worst-case_cpu_utilization"}, {"score": 0.0036091892088392775, "phrase": "real-time_embedded_systems"}, {"score": 0.00349324530379071, "phrase": "cache_locking_capability"}, {"score": 0.003236941658990869, "phrase": "predictable_manner"}, {"score": 0.0030487828775502563, "phrase": "instruction_cache"}, {"score": 0.002934764205541183, "phrase": "dramatic_influence"}, {"score": 0.002887210021573995, "phrase": "system_performance"}, {"score": 0.002779217021776702, "phrase": "cache_locking_techniques"}, {"score": 0.002646267286675984, "phrase": "multi-task_embedded_systems"}, {"score": 0.00251966141432339, "phrase": "i-cache_locking"}, {"score": 0.0023346234464901978, "phrase": "different_algorithms"}, {"score": 0.0022718774783143203, "phrase": "foreknown_information"}, {"score": 0.0022472527731744974, "phrase": "embedded_applications"}, {"score": 0.0022228943786652914, "phrase": "experimental_results"}, {"score": 0.00217496508306238, "phrase": "proposed_algorithms"}, {"score": 0.0021049977753042253, "phrase": "previous_techniques"}], "paper_keywords": ["Real-time and embedded systems", " Worst-case analysis", " Cache memories"], "paper_abstract": "In a multi-task embedded system, a cache is shared by different tasks, which increases the complexity of cache management and the unpredictability of cache behavior. This unpredictability in turn brings an overestimation of application's worst-case execution time (WCET) and worst-case CPU utilization (WCU) which are two of the most important criteria for real-time embedded systems. Modern processors often provide cache locking capability, which can be applied statically and dynamically to manage cache in a predictable manner. The selection of instructions to be locked in the instruction cache (I-Cache) has dramatic influence on the system performance. This paper focuses on applying cache locking techniques to the shared I-Cache to minimize WCU for multi-task embedded systems. We analyze and compare three different strategies to perform I-Cache locking: static locking, semi-dynamic locking, and dynamic locking. Different algorithms are proposed utilizing the foreknown information of embedded applications. Experimental results show that the proposed algorithms can reduce WCU compared to previous techniques.", "paper_title": "Instruction cache locking for multi-task real-time embedded systems", "paper_id": "WOS:000301848000002"}