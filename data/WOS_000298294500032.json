{"auto_keywords": [{"score": 0.04183650826006184, "phrase": "kismet"}, {"score": 0.008713768692145006, "phrase": "serial_programs"}, {"score": 0.007037190427082887, "phrase": "parallel_speedup_estimates"}, {"score": 0.004772137871562584, "phrase": "software_engineers"}, {"score": 0.004687645903373103, "phrase": "difficult_task"}, {"score": 0.00458412183693466, "phrase": "parallel_execution"}, {"score": 0.004543352284098364, "phrase": "multicore_processors"}, {"score": 0.004081385289516914, "phrase": "best_possible_parallelization"}, {"score": 0.0038510053729959074, "phrase": "unparallelized_serial_programs"}, {"score": 0.0037658881407605445, "phrase": "previous_approaches"}, {"score": 0.0036335821512795026, "phrase": "manual_analysis"}, {"score": 0.003474694300991964, "phrase": "quick_analysis"}, {"score": 0.003397866151093552, "phrase": "wasted_engineering_effort"}, {"score": 0.0031490944606172152, "phrase": "hierarchical_critical_path_analysis"}, {"score": 0.0031210475158175406, "phrase": "hcpa"}, {"score": 0.002905454531687249, "phrase": "potentially_nested_regions"}, {"score": 0.0028667159745494933, "phrase": "target_program"}, {"score": 0.0027907771648224273, "phrase": "parallel_execution_time_model"}, {"score": 0.00259793885118959, "phrase": "hardware_parameters"}, {"score": 0.002574788013427524, "phrase": "internal_program_structure"}, {"score": 0.002506562885555113, "phrase": "eight_high-parallelism_nas_parallel_benchmarks"}, {"score": 0.0024401411219526774, "phrase": "five_low-parallelism_specint_benchmarks"}, {"score": 0.002322895056238477, "phrase": "fine-grained_mit_raw_processor"}, {"score": 0.0021334650920198715, "phrase": "prior_work"}, {"score": 0.0021049977753042253, "phrase": "critical_path_analysis"}], "paper_keywords": ["Measurement", " Performance", " Hierarchical Critical Path Analysis", " Expressible Self-Parallelism", " Performance Estimation", " Parallel Software Engineering"], "paper_abstract": "Software engineers now face the difficult task of refactoring serial programs for parallel execution on multicore processors. Currently, they are offered little guidance as to how much benefit may come from this task, or how close they are to the best possible parallelization. This paper presents Kismet, a tool that creates parallel speedup estimates for unparallelized serial programs. Kismet differs from previous approaches in that it does not require any manual analysis or modification of the program. This difference allows quick analysis of many programs, avoiding wasted engineering effort on those that are fundamentally limited. To accomplish this task, Kismet builds upon the hierarchical critical path analysis (HCPA) technique, a recently developed dynamic analysis that localizes parallelism to each of the potentially nested regions in the target program. It then uses a parallel execution time model to compute an approximate upper bound for performance, modeling constraints that stem from both hardware parameters and internal program structure. Our evaluation applies Kismet to eight high-parallelism NAS Parallel Benchmarks running on a 32-core AMD multicore system, five low-parallelism SpecInt benchmarks, and six medium-parallelism benchmarks running on the fine-grained MIT Raw processor. The results are compelling. Kismet is able to significantly improve the accuracy of parallel speedup estimates relative to prior work based on critical path analysis.", "paper_title": "Kismet: Parallel Speedup Estimates for Serial Programs", "paper_id": "WOS:000298294500032"}