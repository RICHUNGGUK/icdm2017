{"auto_keywords": [{"score": 0.04719839762621183, "phrase": "code_size"}, {"score": 0.041904013256512336, "phrase": "embedded_systems"}, {"score": 0.00481495049065317, "phrase": "efficient_embedded_operating_systems"}, {"score": 0.004677711903652145, "phrase": "embedded_system"}, {"score": 0.0046392209103157936, "phrase": "operating_systems"}, {"score": 0.00446987606516801, "phrase": "runtime_performance"}, {"score": 0.00443308765153716, "phrase": "program_specialization"}, {"score": 0.004378469469879815, "phrase": "promising_match"}, {"score": 0.004081385289516914, "phrase": "previously_implemented_specializations"}, {"score": 0.004031082737449308, "phrase": "specialization_engine"}, {"score": 0.0038518661517315533, "phrase": "existing_compilers"}, {"score": 0.003680587852807675, "phrase": "resource-limited_system"}, {"score": 0.0035755653799043, "phrase": "dynamic_applications"}, {"score": 0.0033743949483348626, "phrase": "runtime_specialization_infrastructure"}, {"score": 0.0031064226956732497, "phrase": "specialized_c_templates"}, {"score": 0.003030247482854539, "phrase": "dedicated_compiler"}, {"score": 0.0029928611380840757, "phrase": "efficient_native_code"}, {"score": 0.0028127163745564777, "phrase": "remote_location"}, {"score": 0.002743772969061776, "phrase": "api"}, {"score": 0.002709862658377861, "phrase": "os_extensions"}, {"score": 0.0025892330566358503, "phrase": "specialized_code"}, {"score": 0.002433379035194, "phrase": "linux"}, {"score": 0.0023540387251475615, "phrase": "web_server"}, {"score": 0.002315367926547472, "phrase": "appreciable_improvements"}, {"score": 0.0021579641460002523, "phrase": "specialization_server"}, {"score": 0.0021049977753042253, "phrase": "sizable_workload"}], "paper_keywords": ["performance", " design", " experimentation", " remote specialization", " specialization server", " compilers", " performance analysis"], "paper_abstract": "Prior to their deployment on an embedded system, operating systems are commonly tailored to reduce code size and improve runtime performance. Program specialization is a promising match for this process: it is predictable and modules, and it allows the reuse of previously implemented specializations. A specialization engine for embedded systems must overcome three main obstacles: (i) Reusing existing compilers for embedded systems, (ii) supporting specialization on a resource-limited system and (iii) coping with dynamic applications by supporting specialization on demand. In this article, we describe a runtime specialization infrastructure that addresses these problems. Our solution proposes: ( i) Specialization in two phases of which the former generates specialized C templates and the latter uses a dedicated compiler to generate efficient native code. ( ii) A virtualization mechanism that facilitates specialization of code at a remote location. ( iii) An API and supporting OS extensions that allow applications to produce, manage and dispose of specialized code. We evaluate our work through two case studies: ( i) The TCP/IP implementation of Linux and ( ii) The TUX embedded web server. We report appreciable improvements in code size and performance. We also quantify the overhead of specialization and argue that a specialization server can scale to support a sizable workload.", "paper_title": "Remote specialization for efficient embedded operating systems", "paper_id": "WOS:000259035300005"}