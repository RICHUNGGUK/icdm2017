{"auto_keywords": [{"score": 0.042836668928844926, "phrase": "instruction_set"}, {"score": 0.04104204227824521, "phrase": "processor_models"}, {"score": 0.00481495049065317, "phrase": "compiler_backends"}, {"score": 0.004779406424192843, "phrase": "application-specific_instruction_set_processors"}, {"score": 0.004622662375029505, "phrase": "modern_embedded_systems"}, {"score": 0.004438019162720755, "phrase": "computing_power"}, {"score": 0.0043404186974790706, "phrase": "power_consumption"}, {"score": 0.004292422863834094, "phrase": "promising_approach"}, {"score": 0.004198010835867604, "phrase": "processor_design_alternatives"}, {"score": 0.004167001961564886, "phrase": "processor_description_languages"}, {"score": 0.004060256280654948, "phrase": "hardware_organization"}, {"score": 0.0037700424606538856, "phrase": "software_development_tools"}, {"score": 0.00370077772049505, "phrase": "hardware_models"}, {"score": 0.0035265659032655845, "phrase": "effective_shortening"}, {"score": 0.0035004992651905585, "phrase": "development_turnaround_times"}, {"score": 0.003410768840300913, "phrase": "novel_xadl_language"}, {"score": 0.0032381271420557052, "phrase": "structural_modeling"}, {"score": 0.0032022811145186974, "phrase": "processor's_hardware_organization"}, {"score": 0.0031434146012468307, "phrase": "behavioral_model"}, {"score": 0.0030514638431036714, "phrase": "instruction_set_extraction"}, {"score": 0.002995361424576051, "phrase": "tight_coupling"}, {"score": 0.002962194824034612, "phrase": "structural_hardware_view"}, {"score": 0.002929394386754424, "phrase": "instruction_set_view"}, {"score": 0.002791393223133408, "phrase": "existing_languages"}, {"score": 0.002689666606553487, "phrase": "compiler_backend_generator"}, {"score": 0.00265987582861194, "phrase": "tree_pattern"}, {"score": 0.002620666087191234, "phrase": "important_property"}, {"score": 0.0025251455169484557, "phrase": "resulting_compiler"}, {"score": 0.0024240794798626674, "phrase": "possible_input_programs"}, {"score": 0.0023972232771581753, "phrase": "generated_compilers"}, {"score": 0.002361876178411006, "phrase": "handcrafted_production_compilers"}, {"score": 0.0022009497295481678, "phrase": "considerable_reductions"}, {"score": 0.0021846599115561832, "phrase": "code_size"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["processor description languages", " compiler", " instruction selection", " completeness"], "paper_abstract": "Application-specific instruction set processors have proven successful in meeting the various design constraints of modern embedded systems and often provide the only viable trade-off between computing power and opposing metrics such as power consumption. A promising approach to facilitate the exploration of processor design alternatives are processor description languages, which capture the instruction set and hardware organization of a processor. With the use of those processor models, various design tasks, for example, the adaption of software development tools, the generation of hardware models, and various verification tasks, can be automatized. These languages thus allow effective shortening of development turnaround times. In this work, the novel xADL language is presented, which, in contrast to most contemporary processor description languages, focuses on a structural modeling of the processor's hardware organization. However, a behavioral model of the instruction set is automatically derived using instruction set extraction. This provides a tight coupling between the structural hardware view and the instruction set view of the processor and reduces the complexity of processor models in comparison with existing languages. The feasibility of our approach is demonstrated by a compiler backend generator based on tree pattern matching. An important property of our generator is its ability to automatically verify whether the resulting compiler is complete, that is, it can process all possible input programs. The generated compilers are competitive to handcrafted production compilers, showing speedups of up to 20% for certain benchmarks. On average, moderate slowdowns between 3% and 15% have been observed for several processor models while considerable reductions in code size have been measured. Copyright (C) 2012 John Wiley & Sons, Ltd.", "paper_title": "Automatic generation of compiler backends", "paper_id": "WOS:000313614800004"}