{"auto_keywords": [{"score": 0.04853750751694913, "phrase": "affine_transformations"}, {"score": 0.015720120587465348, "phrase": "pluto"}, {"score": 0.0041725881174377345, "phrase": "single_multi-dimensional_affine_function"}, {"score": 0.004104838067758352, "phrase": "long_and_complex_sequence"}, {"score": 0.004021689117050817, "phrase": "existing_affine_transformation_frameworks"}, {"score": 0.003972607172518598, "phrase": "pluto_algorithm"}, {"score": 0.003892126266260425, "phrase": "cost_function"}, {"score": 0.0038603905208013482, "phrase": "modern_multicore_architectures"}, {"score": 0.003828912548622257, "phrase": "coarse-grained_parallelism"}, {"score": 0.0036304470230058413, "phrase": "combinatorial_explosion"}, {"score": 0.0035278613436978933, "phrase": "ensuing_practical_tradeoffs"}, {"score": 0.003372460634140967, "phrase": "transformation_compositions"}, {"score": 0.0033449479263613848, "phrase": "loop_reversals"}, {"score": 0.003277140908834426, "phrase": "negative_factors"}, {"score": 0.002970260970134645, "phrase": "pluto_algorithm's_cost_function"}, {"score": 0.0029100272315053253, "phrase": "experimental_evaluation"}, {"score": 0.002827740707723551, "phrase": "compilation_time"}, {"score": 0.002770389097966904, "phrase": "generated_codes"}, {"score": 0.0025628355581338563, "phrase": "polybench_benchmarks"}, {"score": 0.0025315126622525424, "phrase": "lattice_boltzmann_method"}, {"score": 0.0024700078414481297, "phrase": "periodic_boundary_conditions"}, {"score": 0.00241989408309933, "phrase": "mean_speedup"}, {"score": 0.0022849068677290836, "phrase": "compile_times"}, {"score": 0.002256973121326987, "phrase": "experimental_results"}, {"score": 0.002238540344767611, "phrase": "polybench"}, {"score": 0.00219311232069446, "phrase": "overall_polyhedral_source-to-source_optimization_time"}, {"score": 0.0021049977753042253, "phrase": "execution_time"}], "paper_keywords": ["Affine transformations", " polyhedral model", " automatic parallelization", " tiling", " affine scheduling", " stencil computations"], "paper_abstract": "Affine transformations have proven to be very powerful for loop restructuring due to their ability to model a very wide range of transformations. A single multi-dimensional affine function can represent a long and complex sequence of simpler transformations. Existing affine transformation frameworks like the Pluto algorithm, that include a cost function for modern multicore architectures where coarse-grained parallelism and locality are crucial, consider only a sub-space of transformations to avoid a combinatorial explosion in finding the transformations. The ensuing practical tradeoffs lead to the exclusion of certain useful transformations, in particular, transformation compositions involving loop reversals and loop skewing by negative factors. In this paper, we propose an approach to address this limitation by modeling a much larger space of affine transformations in conjunction with the Pluto algorithm's cost function. We perform an experimental evaluation of both, the effect on compilation time, and performance of generated codes. The evaluation shows that our new framework, Pluto+, provides no degradation in performance in any of the Polybench benchmarks. For Lattice Boltzmann Method (LBM) codes with periodic boundary conditions, it provides a mean speedup of 1.33x over Pluto. We also show that Pluto+ does not increase compile times significantly. Experimental results on Polybench show that Pluto+ increases overall polyhedral source-to-source optimization time only by 15%. In cases where it improves execution time significantly, it increased polyhedral optimization time only by 2.04x.", "paper_title": "PLUTO plus : Near-Complete Modeling of Affine Transformations for Parallelism and Locality", "paper_id": "WOS:000367254800006"}