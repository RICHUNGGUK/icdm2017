{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "equal_elements"}, {"score": 0.010332646891009906, "phrase": "random_binary_search_trees"}, {"score": 0.007296697607840158, "phrase": "search_tree"}, {"score": 0.004295269532032448, "phrase": "multiple_occurrences"}, {"score": 0.00407042677958844, "phrase": "randomized_insertion"}, {"score": 0.003909527837211073, "phrase": "martinez"}, {"score": 0.003857308567471912, "phrase": "roura"}, {"score": 0.0036553070575015344, "phrase": "random_search_trees"}, {"score": 0.0033718991936259038, "phrase": "tree_updates"}, {"score": 0.0030482430937467013, "phrase": "random_search_tree"}, {"score": 0.0028498718992429825, "phrase": "special_way"}, {"score": 0.0024909230668523825, "phrase": "stable_trees"}, {"score": 0.0024084679931209514, "phrase": "implicit_indexing"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Data structures", " Multiset", " Equal elements", " Monoset"], "paper_abstract": "We consider random binary search trees when the input consists of a multiset, i.e. a set with multiple occurrences of equal elements, and prove that the randomized insertion and deletion algorithms given by Martinez and Roura (1998) [4] produce random search trees regardless of multiplicities; even if all the elements are equal during the tree updates, a search tree will maintain its randomness. Thus, equal elements do not degenerate a random search tree and they need not to be handled in any special way. We consider also stability of a search tree with respect to its inorder traversal and prove that the algorithms used produce stable trees. This implies an implicit indexing of equal elements giving another proof that multiplicities do not pose problems when maintaining random binary search trees. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Random binary search tree with equal elements", "paper_id": "WOS:000283702600007"}