{"auto_keywords": [{"score": 0.03014720888291599, "phrase": "overall_execution_time"}, {"score": 0.029134366556600278, "phrase": "jikes's_adaptive_system"}, {"score": 0.02734026317158217, "phrase": "greedy_algorithm"}, {"score": 0.00481495049065317, "phrase": "java_programs"}, {"score": 0.0035648266669315943, "phrase": "offline_feedback"}, {"score": 0.003441891354624516, "phrase": "trace_collection_system"}, {"score": 0.0032085525502105836, "phrase": "java_grande_benchmarks"}, {"score": 0.002509284173541882, "phrase": "previous_work"}, {"score": 0.0021262403223013242, "phrase": "trace_collection_overhead"}], "paper_keywords": [""], "paper_abstract": "Traces offer an opportunity to improve the performance of inlining because they contain information regarding which call sites are frequently executed, and thus can be beneficially inlined. We therefore evaluate the effectiveness of using traces to perform inlining. We propose a number of ways in which traces can be used to inline methods in an offline feedback directed system. We build a trace collection system for the Jikes Research Virtual Machine and create traces based on the execution of the SPECjvm98 and Java Grande benchmarks. We evaluate the use of these traces for miming, and find that the use of traces leads to a decrease in overall execution time of 5.4%, when compared to Jikes's adaptive system. This performance is slightly better than that achieved when using a greedy algorithm that is representative of previous work. Using the greedy algorithm leads to a decrease in overall execution time of 4.8%, when compared to Jikes's adaptive system. We conclude that traces may be used effectively to perform inlining, although the trace collection overhead of our system needs to be addressed.", "paper_title": "Inlining with traces in java programs", "paper_id": "WOS:000310413200002"}