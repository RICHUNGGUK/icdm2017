{"auto_keywords": [{"score": 0.04504330710057516, "phrase": "counter_examples"}, {"score": 0.00481495049065317, "phrase": "quickcheck_properties"}, {"score": 0.003858110309630846, "phrase": "infinite_objects"}, {"score": 0.0036037265181631324, "phrase": "sensible_show_function"}, {"score": 0.003394891095032025, "phrase": "infinite_object"}, {"score": 0.003309124298009635, "phrase": "finite_number"}, {"score": 0.003038532168038562, "phrase": "general_technique"}, {"score": 0.002790004829699627, "phrase": "finite_objects"}, {"score": 0.0021049977753042253, "phrase": "higher-order_functions"}], "paper_keywords": ["Algorithms", " Verification", " testing", " QuickCheck", " counter example"], "paper_abstract": "Although quantification over functions in QuickCheck properties has been supported from the beginning, displaying and shrinking them as counter examples has not. The reason is that in general, functions are infinite objects, which means that there is no sensible show function for them, and shrinking an infinite object within a finite number of steps seems impossible. This paper presents a general technique with which functions as counter examples can be shrunk to finite objects, which can then be displayed to the user. The approach turns out to be practically usable, which is shown by a number of examples. The two main limitations are that higher-order functions cannot be dealt with, and it is hard to deal with terms that contain functions as subterms.", "paper_title": "Shrinking and Showing Functions (Functional Pearl)", "paper_id": "WOS:000313911300007"}