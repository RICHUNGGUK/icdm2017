{"auto_keywords": [{"score": 0.025158343193522895, "phrase": "bottleneck_instances"}, {"score": 0.00481495049065317, "phrase": "bottleneck_cases"}, {"score": 0.00429057323623293, "phrase": "maximum_independent_set"}, {"score": 0.004208881856146758, "phrase": "n-vertex_graph"}, {"score": 0.003947601392882997, "phrase": "previous_running_time_bounds"}, {"score": 0.003494866798828308, "phrase": "improved_time"}, {"score": 0.003256808693019209, "phrase": "previously_known_reduction_rules"}, {"score": 0.0030349168871027558, "phrase": "simple_algorithms"}, {"score": 0.0026523079380037706, "phrase": "new_reducible_subgraphs"}, {"score": 0.0024874156497091994, "phrase": "worst_recurrence"}, {"score": 0.0021876814398268775, "phrase": "branching_operation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Exact algorithm", " Independent set", " Measure and conquer"], "paper_abstract": "We present an 0*(1.0836(n))-time algorithm for finding a maximum independent set in an n-vertex graph with degree bounded by 3, which improves all previous running time bounds for this problem. Our approach has the following two features. Without increasing the number of reduction/branching rules to get an improved time bound, we first successfully extract the essence from the previously known reduction rules such as domination, which can be used to get simple algorithms. More formally, we introduce a procedure for computing \"confining sets\", which unifies several known reducible subgraphs and covers new reducible subgraphs. Second we identify those instances that generate the worst recurrence among all recurrences of our branching rules as \"bottleneck instances\" and prove that bottleneck instances cannot appear consecutively after each branching operation. (c) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Confining sets and avoiding bottleneck cases: A simple maximum independent set algorithm in degree-3 graphs", "paper_id": "WOS:000314137900007"}