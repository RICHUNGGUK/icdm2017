{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "stm_haskell_implementation"}, {"score": 0.004640079189342692, "phrase": "concurrent_implementation"}, {"score": 0.004527024978801684, "phrase": "software_transactional_memory"}, {"score": 0.004416713079266374, "phrase": "concurrent_haskell"}, {"score": 0.004256243266481051, "phrase": "call-by-need_functional_language"}, {"score": 0.0036703791815812328, "phrase": "small-step_operational_semantics"}, {"score": 0.003284361433827464, "phrase": "early_abort"}, {"score": 0.003204232566468624, "phrase": "conflicting_transactions"}, {"score": 0.002728847267539957, "phrase": "contextual_semantics"}, {"score": 0.002295277579105179, "phrase": "correct_evaluator"}, {"score": 0.0022117133940361025, "phrase": "abstract_specification"}, {"score": 0.0021049977753042253, "phrase": "bigstep_semantics"}], "paper_keywords": ["Languages", " Theory", " Verification", " Functional Programming", " Concurrent Programming", " Semantics", " Software Transactional Memory", " Haskell"], "paper_abstract": "A concurrent implementation of software transactional memory in Concurrent Haskell using a call-by-need functional language with processes and futures is given. The description of the small-step operational semantics is precise and explicit, and employs an early abort of conflicting transactions. A proof of correctness of the implementation is given for a contextual semantics with may- and should-convergence. This implies that our implementation is a correct evaluator for an abstract specification equipped with a bigstep semantics.", "paper_title": "Correctness of an STM Haskell Implementation", "paper_id": "WOS:000327696700016"}