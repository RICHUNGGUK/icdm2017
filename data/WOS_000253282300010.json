{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "self-scheduling_algorithms"}, {"score": 0.03737634241271663, "phrase": "weighting_mechanism"}, {"score": 0.03602492811107984, "phrase": "dynamic_self-scheduling_algorithms"}, {"score": 0.004660453113061494, "phrase": "existing_dynamic_self-scheduling_algorithms"}, {"score": 0.004535481695403089, "phrase": "independent_tasks"}, {"score": 0.004486432283770142, "phrase": "heterogeneous_clusters"}, {"score": 0.004157561334726201, "phrase": "internode_communication"}, {"score": 0.003937459891461576, "phrase": "synchronization_mechanism"}, {"score": 0.0038737214010638745, "phrase": "inter-processor_communication"}, {"score": 0.0037087324991876727, "phrase": "efficiently_nested_loops"}, {"score": 0.003308195943172624, "phrase": "total_number"}, {"score": 0.0030487828775502563, "phrase": "chunk_sizes"}, {"score": 0.002999386721353559, "phrase": "computing_power"}, {"score": 0.002966900048034132, "phrase": "current_run-queue_state"}, {"score": 0.0028715299874549245, "phrase": "synchronization_and_weighting_mechanisms"}, {"score": 0.0025334249463305875, "phrase": "application_spectrum"}, {"score": 0.0024253827365474734, "phrase": "extensive_testing"}, {"score": 0.0023219374444738723, "phrase": "weighting_mechanisms"}, {"score": 0.002284290601837099, "phrase": "significant_improvement"}, {"score": 0.0022472527731744974, "phrase": "synchronized-weighted_versions"}, {"score": 0.00217496508306238, "phrase": "synchronized-only_versions"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["dynamic load balancing algorithms", " loops with dependencies", " synchronization", " weighting", " non-dedicated heterogeneous systems"], "paper_abstract": "Existing dynamic self-scheduling algorithms, used to schedule independent tasks on heterogeneous clusters, cannot handle tasks with dependencies because they lack the support for internode communication. To compensate for this deficiency we introduce a synchronization mechanism that provides inter-processor communication, thus, enabling self-scheduling algorithms to handle efficiently nested loops with dependencies. We also present a weighting mechanism that significantly improves the performance of dynamic self-scheduling algorithms. These algorithms divide the total number of tasks into chunks and assign them to processors. The weighting mechanism adapts the chunk sizes to the computing power and current run-queue state of the processors. The synchronization and weighting mechanisms are orthogonal, in the sense that they can simultaneously be applied to loops with dependencies. Thus, they broaden the application spectrum of dynamic self-scheduling algorithms and improve their performance. Extensive testing confirms the efficiency of the synchronization and weighting mechanisms and the significant improvement of the synchronized-weighted versions of the algorithms over the synchronized-only versions. (c) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Enhancing self-scheduling algorithms via synchronization and weighting", "paper_id": "WOS:000253282300010"}