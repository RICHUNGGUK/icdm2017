{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "indirect_data"}, {"score": 0.03983926434466607, "phrase": "shared_data_repository"}, {"score": 0.004701556483912018, "phrase": "loosely-coupled_component_systems"}, {"score": 0.004554488671294504, "phrase": "loose_coupling"}, {"score": 0.004447201233380302, "phrase": "dynamic_composition"}, {"score": 0.004173244935967375, "phrase": "-filter_architecture"}, {"score": 0.003531474887552889, "phrase": "time_compatibility"}, {"score": 0.0034482025128821548, "phrase": "even_static_type_checking"}, {"score": 0.0030119758165837625, "phrase": "pipe-and-filter_and_a_shared_data_repository"}, {"score": 0.0026099289298770023, "phrase": "struts_framework"}, {"score": 0.0024101837218440834, "phrase": "behavioural_contracts"}, {"score": 0.0022614266476954467, "phrase": "automated_formal_verification"}], "paper_keywords": [""], "paper_abstract": "To maintain loose coupling and facilitate dynamic composition, components in a pipe-and-filter architecture have a very limited syntactic interface and often communicate indirectly by means of a shared data repository. This severely limits the possibilities for compile time compatibility checking. Even static type checking is made largely irrelevant due to the very general types given in the interfaces. The combination of pipe-and-filter and a shared data repository is widely used, and in this paper we study this problem in the context of the Struts framework. We propose simple, but formally specified, behavioural contracts for components in such frameworks and show that automated formal verification of certain semantical compatibility properties is feasible. In particular, our verification guarantees that indirect data sharing through the shared data repository is performed consistently.", "paper_title": "Static verification of indirect data sharing in loosely-coupled component systems", "paper_id": "WOS:000241358100003"}