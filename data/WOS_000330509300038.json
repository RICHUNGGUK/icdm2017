{"auto_keywords": [{"score": 0.027899071058977324, "phrase": "blg"}, {"score": 0.00481495049065317, "phrase": "bipartite_liveness_graphs"}, {"score": 0.0047823219739028325, "phrase": "register_allocation"}, {"score": 0.004733791336312872, "phrase": "essential_optimization"}, {"score": 0.004606759374526927, "phrase": "sophisticated_register_allocation_algorithms"}, {"score": 0.004452731043379068, "phrase": "register_allocation_algorithms"}, {"score": 0.004407530256797396, "phrase": "modern_compilers"}, {"score": 0.004347972379250724, "phrase": "graph_coloring"}, {"score": 0.004274650638302117, "phrase": "linear_scan"}, {"score": 0.0041316803676012155, "phrase": "fundamental_limitations"}, {"score": 0.003993472712847928, "phrase": "key_data_structure"}, {"score": 0.00395291546135423, "phrase": "gc-based_algorithms"}, {"score": 0.003912768486550741, "phrase": "interference_graph"}, {"score": 0.0038336889370744662, "phrase": "program_points"}, {"score": 0.0037307208089736835, "phrase": "ls-based_algorithms"}, {"score": 0.003593623872399777, "phrase": "global_optimization"}, {"score": 0.00356924199356768, "phrase": "reduced_compile-time_and_space_overheads"}, {"score": 0.003485196263406553, "phrase": "static_single_assignment"}, {"score": 0.003426373820419672, "phrase": "allocation_algorithms"}, {"score": 0.003380029058401904, "phrase": "live-range_split_points"}, {"score": 0.003278024877215369, "phrase": "spilling_problem"}, {"score": 0.0032336801561165113, "phrase": "ssa-based_register_allocation"}, {"score": 0.003157510936118389, "phrase": "register_assignments"}, {"score": 0.0031360786664165093, "phrase": "ssa_elimination"}, {"score": 0.0030936482163040823, "phrase": "architectural_constraints"}, {"score": 0.0030414140732789186, "phrase": "abi_encoding"}, {"score": 0.003010496595090984, "phrase": "extra_overhead"}, {"score": 0.002949598537993663, "phrase": "dynamic_compilation_contexts"}, {"score": 0.002889928791032578, "phrase": "decoupled_non-ssa-based_global_register_allocation_algorithm"}, {"score": 0.0027931421106359875, "phrase": "current_algorithms"}, {"score": 0.002755338691613447, "phrase": "bipartite_liveness_graph"}, {"score": 0.002718045523483502, "phrase": "allocation_algorithm"}, {"score": 0.002681255756642227, "phrase": "spilling_phase"}, {"score": 0.002653989719462843, "phrase": "optimization_problem"}, {"score": 0.0025914395870574787, "phrase": "assignment_phase"}, {"score": 0.002565084553019013, "phrase": "separate_optimization_problem"}, {"score": 0.002547663224855668, "phrase": "advanced_register"}, {"score": 0.002538996868327341, "phrase": "allocation_optimizations"}, {"score": 0.002487612781045517, "phrase": "live-range_splitting"}, {"score": 0.002453934333239467, "phrase": "class_handling"}, {"score": 0.0023798115577749225, "phrase": "assignment_phases"}, {"score": 0.002331641523873951, "phrase": "register_classes"}, {"score": 0.002292243761395491, "phrase": "bucket-based_greedy_heuristic"}, {"score": 0.0022309895699993113, "phrase": "llvm."}, {"score": 0.0022154296909169826, "phrase": "register_class_constraints"}, {"score": 0.002185428109917791, "phrase": "experimental_evaluation"}, {"score": 0.0021338975690903014, "phrase": "production-quality_register_allocators"}, {"score": 0.002119398518241986, "phrase": "jikes_rvm"}], "paper_keywords": ["Decoupled register allocation", " bipartite graph", " coalesce graph", " basic and compound intervals"], "paper_abstract": "Register allocation is an essential optimization for all compilers. A number of sophisticated register allocation algorithms have been developed over the years. The two fundamental classes of register allocation algorithms used in modern compilers are based on Graph Coloring (GC) and Linear Scan (LS). However, these two algorithms have fundamental limitations in terms of precision. For example, the key data structure used in GC-based algorithms, the interference graph, lacks information on the program points at which two variables may interfere. The LS-based algorithms make local decisions regarding spilling, and thereby trade off global optimization for reduced compile-time and space overheads. Recently, researchers have proposed Static Single Assignment (SSA)-based decoupled register allocation algorithms that exploit the live-range split points of the SSA representation to optimally solve the spilling problem. However, SSA-based register allocation often requires extra complexity in repairing register assignments during SSA elimination and in addressing architectural constraints such as aliasing and ABI encoding; this extra overhead can be prohibitively expensive in dynamic compilation contexts. This article proposes a decoupled non-SSA-based global register allocation algorithm for dynamic compilation. It addresses the limitations in current algorithms by introducing a Bipartite Liveness Graph (BLG)-based register allocation algorithm that models the spilling phase as an optimization problem on the BLG itself and the assignment phase as a separate optimization problem. Advanced register allocation optimizations such as move coalescing, live-range splitting, and register class handling are also performed along with the spilling and assignment phases. In the presence of register classes, we propose a bucket-based greedy heuristic for assignment that strikes a balance between spill-cost and register class constraints. We present experimental evaluation of our BLG-based register allocation algorithm and compare it with production-quality register allocators in Jikes RVM and LLVM.", "paper_title": "A Decoupled Non-SSA Global Register Allocation Using Bipartite Liveness Graphs", "paper_id": "WOS:000330509300038"}