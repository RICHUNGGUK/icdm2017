{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "cooperating_embedded_devices"}, {"score": 0.004641770842098217, "phrase": "arbitrary_software_defects"}, {"score": 0.004604136423327813, "phrase": "embedded_systems"}, {"score": 0.004331393784852601, "phrase": "great_numbers"}, {"score": 0.004261419841494814, "phrase": "evolutionary_computation"}, {"score": 0.004227017549128813, "phrase": "ec"}, {"score": 0.004124831019063503, "phrase": "valid_repairs"}, {"score": 0.00407474190126995, "phrase": "source_code_level"}, {"score": 0.004008908217545878, "phrase": "elf"}, {"score": 0.003912112659326054, "phrase": "limited_system_resources"}, {"score": 0.003740679163860117, "phrase": "source_code"}, {"score": 0.0035477010181860376, "phrase": "program_instrumentation"}, {"score": 0.0035189057079817285, "phrase": "specialized_execution_environments"}, {"score": 0.0034761488481944657, "phrase": "virtual_machines"}, {"score": 0.003433909720151841, "phrase": "prior_knowledge"}, {"score": 0.003392182098020722, "phrase": "bug_type"}, {"score": 0.0032302647179383915, "phrase": "elf_binaries"}, {"score": 0.003088617973198433, "phrase": "disk_requirements"}, {"score": 0.0030262967460085366, "phrase": "repair_time"}, {"score": 0.0029773436815290215, "phrase": "similar_source-level_techniques"}, {"score": 0.0028583875909257766, "phrase": "c_source_code"}, {"score": 0.00278954520351591, "phrase": "arm"}, {"score": 0.0027108021939930014, "phrase": "efficiency_gains"}, {"score": 0.0026560841114619147, "phrase": "stochastic_fault_localization"}, {"score": 0.00260246764210499, "phrase": "comparable_deterministic_methods"}, {"score": 0.0024781515864648242, "phrase": "multiple_devices"}, {"score": 0.002388817995161952, "phrase": "naive_parallelism"}, {"score": 0.002274684393868218, "phrase": "single_device"}, {"score": 0.0021571717917276724, "phrase": "inter-phone_communication"}], "paper_keywords": ["Experimentation", " Languages", " Automated program repair", " evolutionary computation", " fault localization", " assembly code", " bytecode", " legacy software"], "paper_abstract": "We present a method for automatically repairing arbitrary software defects in embedded systems, which have limited memory, disk and CPU capacities, but exist in great numbers. We extend evolutionary computation (EC) algorithms that search for valid repairs at the source code level to assembly and ELF format binaries, compensating for limited system resources with several algorithmic innovations. Our method does not require access to the source code or build toolchain of the software under repair, does not require program instrumentation, specialized execution environments, or virtual machines, or prior knowledge of the bug type. We repair defects in ARM and x86 assembly as well as ELF binaries, observing decreases of 86% in memory and 95% in disk requirements, with 62% decrease in repair time, compared to similar source-level techniques. These advances allow repairs previously possible only with C source code to be applied to any ARM or x86 assembly or ELF executable. Efficiency gains are achieved by introducing stochastic fault localization, with much lower overhead than comparable deterministic methods, and low-level program representations. When distributed over multiple devices, our algorithm finds repairs faster than predicted by naive parallelism. Four devices using our approach are five times more efficient than a single device because of our collaboration model. The algorithm is implemented on Nokia N900 smartphones, with inter-phone communication fitting in 900 bytes sent in 7 SMS text messages per device per repair on average.", "paper_title": "Automated Repair of Binary and Assembly Programs for Cooperating Embedded Devices", "paper_id": "WOS:000321213100026"}