{"auto_keywords": [{"score": 0.028564362307969614, "phrase": "g."}, {"score": 0.00481495049065317, "phrase": "computing_tree_lcs."}, {"score": 0.0045804107341714, "phrase": "trees_f"}, {"score": 0.004477595431209663, "phrase": "largest_forest"}, {"score": 0.0041637779492720295, "phrase": "computing_tree_lcs"}, {"score": 0.004015182362035361, "phrase": "tree_lcs_problem"}, {"score": 0.0026069623057065664, "phrase": "novel_three-dimensional_alignment_graph"}, {"score": 0.002502374576203785, "phrase": "constrained_variant"}, {"score": 0.002401972657236928, "phrase": "zero_or_one_children"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Tree LCS", " Tree edit distance", " Ordered trees", " Largest common subforest", " Sparse dynamic programming"], "paper_abstract": "The LCS of two rooted, ordered, and labeled trees F and G is the largest forest that can be obtained from both trees by deleting nodes. We present algorithms for computing tree LCS which exploit the sparsity inherent to the tree LCS problem. Assuming G is smaller than F, our first algorithm runs in time O(r . height(F) . height(G) . lg lg vertical bar G vertical bar), where r is the number of pairs (upsilon is an element of F, omega is an element of G) such that upsilon and omega) have the same label. Our second algorithm runs in time O(Lr lg r . lg lg vertical bar G vertical bar), where L is the size of the LCS of F and G. For this algorithm we present a novel three-dimensional alignment graph. Our third algorithm is intended for the constrained variant of the problem in which only nodes with zero or one children can be deleted. For this case we obtain an O(rh lg lg vertical bar G vertical bar) time algorithm, where h = height(F) + height(G). (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Fast algorithms for computing tree LCS", "paper_id": "WOS:000270627100003"}