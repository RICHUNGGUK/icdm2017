{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "future_multi-core_systems"}, {"score": 0.004613825044585923, "phrase": "fine-grained_synchronization_methods"}, {"score": 0.004386887374401584, "phrase": "future_systems"}, {"score": 0.004187284711626886, "phrase": "portable_atomic_hardware_primitives"}, {"score": 0.004027876348834879, "phrase": "single_address"}, {"score": 0.003935147683802319, "phrase": "concurrent_algorithms"}, {"score": 0.003844545552246988, "phrase": "multiple_addresses"}, {"score": 0.003726967166630926, "phrase": "practical_wait-free_multi-word"}, {"score": 0.0035989687070420977, "phrase": "wait-free_property"}, {"score": 0.0034753508746887957, "phrase": "finite_number"}, {"score": 0.0032914145394036657, "phrase": "progress_assurance_scheme"}, {"score": 0.0032406665327678616, "phrase": "blocked_thread"}, {"score": 0.003069112841132911, "phrase": "traditional_lock-free_helping_techniques"}, {"score": 0.0025172781808293827, "phrase": "explicit_memory_barriers"}, {"score": 0.0023746766301040974, "phrase": "wait-free_progress_guarantee"}, {"score": 0.002319918823705175, "phrase": "high_contention_scenario"}, {"score": 0.0022576249214220187, "phrase": "single_multi-word_object"}, {"score": 0.002154693685426657, "phrase": "tested_scenarios"}], "paper_keywords": ["Wait-free", " Lock-free", " Non-blocking", " Concurrent", " Multi-word compare-and-swap", " MCAS", " CAS"], "paper_abstract": "The number of cores in future multi-core systems are expected to increase by 100 fold over the next decade. The fine-grained synchronization methods found in wait-free algorithm designs makes them desirable for these future systems. Unfortunately, such designs are often inhibited by the limitations of portable atomic hardware primitives. Typically these primitives can only operate on a single address at a time, while concurrent algorithms often need to operate on multiple addresses. To support such algorithms we present a practical wait-free Multi-word-compare-and-swap. The wait-free property ensures that each thread completes its operation in a finite number of steps, even if it is continuously interrupted. Our approach uses a progress assurance scheme that allows a blocked thread to announce that it is unable to make progress. This differs from traditional lock-free helping techniques where a thread will only help complete an operation that is in conflict with its own. Our design is practical in that it is built from only portable atomic operations, it is efficient in its utilization of memory (i.e. requiring only a single bit to be reserved from each word, not requiring use of explicit memory barriers, and requiring only four words per address in the operation), and has a wait-free progress guarantee. When tested in a high contention scenario with 64 threads executing updates on a single multi-word object, our wait-free design performs on average 77.1 % more operations than other practical approaches. Over all tested scenarios, our design performs on average 8.3 % more operations.", "paper_title": "A Wait-Free Multi-Word Compare-and-Swap Operation", "paper_id": "WOS:000352287300002"}