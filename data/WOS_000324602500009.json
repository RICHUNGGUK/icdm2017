{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "pattern_matching"}, {"score": 0.0038624981944755813, "phrase": "significant_effort"}, {"score": 0.003459191419478298, "phrase": "concrete_representations"}, {"score": 0.0030494153169181334, "phrase": "invertible_programming"}, {"score": 0.0028857130140890787, "phrase": "program_refactoring"}, {"score": 0.0027961342030212353, "phrase": "right-invertible_language_rinv-every_function"}, {"score": 0.0026045914281028473, "phrase": "new_design"}, {"score": 0.0024842242921857705, "phrase": "smooth_incremental_transition"}, {"score": 0.002407078478216306, "phrase": "algebraic_datatypes"}, {"score": 0.0022777800735119405, "phrase": "proper_encapsulation"}, {"score": 0.0022070310530794097, "phrase": "simple_and_sound_reasoning"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Functional programming", " Refactoring", " Pattern matching", " Invertible programming", " Abstract datatypes", " Fusion"], "paper_abstract": "Defining functions by pattern matching over the arguments is advantageous for understanding and reasoning, but it tends to expose the implementation of a datatype. Significant effort has been invested in tackling this loss of modularity; however, decoupling patterns from concrete representations while maintaining soundness of reasoning has been a challenge. Inspired by the development of invertible programming, we propose an approach to program refactoring based on a right-invertible language RINV-every function has a right (or pre-) inverse. We show how this new design is able to permit a smooth incremental transition from programs with algebraic datatypes and pattern matching, to ones with proper encapsulation, while maintaining simple and sound reasoning. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Refactoring pattern matching", "paper_id": "WOS:000324602500009"}