{"auto_keywords": [{"score": 0.04970018005584554, "phrase": "tm"}, {"score": 0.011027870582192349, "phrase": "existing_systems"}, {"score": 0.010642929742137482, "phrase": "htm_support"}, {"score": 0.00481495049065317, "phrase": "transactional_memory"}, {"score": 0.00435971969507033, "phrase": "tm_proposals"}, {"score": 0.004325208730208653, "phrase": "unreasonable_constraints"}, {"score": 0.004091130285858113, "phrase": "\"unbounded\"_transactions"}, {"score": 0.004026598712747509, "phrase": "significantly_higher_complexity_and_risk_than_best-effort_designs"}, {"score": 0.003674738405118697, "phrase": "best-effort_hardware"}, {"score": 0.0036311704130828114, "phrase": "htm"}, {"score": 0.0033937776228549557, "phrase": "transactional_programs"}, {"score": 0.0032744315183287024, "phrase": "performance_benefits"}, {"score": 0.0029292375702719494, "phrase": "best-effort_htm"}, {"score": 0.0028601252251285025, "phrase": "software_library"}, {"score": 0.0026836723685046407, "phrase": "berkeley_db_system"}, {"score": 0.002578946584040053, "phrase": "optional_use"}, {"score": 0.002391067964886602, "phrase": "simulated_multiprocessor"}, {"score": 0.0022977342663599042, "phrase": "hytm_approach"}, {"score": 0.002190519728921395, "phrase": "unbounded_htm_implementation"}, {"score": 0.0021049977753042253, "phrase": "complicated_htm_support"}], "paper_keywords": ["algorithms", " design", " transactional memory"], "paper_abstract": "Transactional memory (TM) promises to substantially reduce the difficulty of writing correct, efficient, and scalable concurrent programs. But \"bounded\" and \"best-effort\" hardware TM proposals impose unreasonable constraints on programmers, while more flexible software TM implementations are considered too slow. Proposals for supporting \"unbounded\" transactions in hardware entail significantly higher complexity and risk than best-effort designs. We introduce Hybrid Transactional Memory (HyTM), an approach to implementing TM in software so that it can use best-effort hardware TM (HTM) to boost performance but does not depend on HTM. Thus programmers can develop and test transactional programs in existing systems today, and can enjoy the performance benefits of HTM support when it becomes available. We describe our prototype HyTM system, comprising a compiler and a library. The compiler allows a transaction to be attempted using best-effort HTM, and retried using the software library if it fails. We have used our prototype to \"transactify\" part of the Berkeley DB system, as well as several benchmarks. By disabling the optional use of HTM, we can run all of these tests on existing systems. Furthermore, by using a simulated multiprocessor with HTM support, we demonstrate the viability of the HyTM approach: it can provide performance and scalability approaching that of an unbounded HTM implementation, without the need to support all transactions with complicated HTM support.", "paper_title": "Hybrid transactional memory", "paper_id": "WOS:000202972600032"}