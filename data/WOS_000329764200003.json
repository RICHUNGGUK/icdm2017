{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_van"}, {"score": 0.0047906082951008665, "phrase": "emde_boas"}, {"score": 0.00469445816161498, "phrase": "fast_and_simple_concurrent_dynamic_set_alternative"}, {"score": 0.00457696724030363, "phrase": "computationally_efficient_algorithms"}, {"score": 0.004306795240631196, "phrase": "concurrent_solutions"}, {"score": 0.004177724522109952, "phrase": "contemporary_processors"}, {"score": 0.003871653343842317, "phrase": "parallel_processing_and_parallel_computation"}, {"score": 0.003736567662016446, "phrase": "parallel_solution"}, {"score": 0.0036988415150699945, "phrase": "concurrent_data_structures"}, {"score": 0.0036245239349157236, "phrase": "multithread_programming_environments"}, {"score": 0.003410380718649286, "phrase": "new_concurrent_dynamic_set_structure"}, {"score": 0.0032415934630668484, "phrase": "emde_boas_trees"}, {"score": 0.0030038988468808845, "phrase": "node's_children"}, {"score": 0.0028551716387011637, "phrase": "simple_but_effective_locking_algorithm"}, {"score": 0.002632332114727894, "phrase": "presented_algorithm_idea"}, {"score": 0.0025663181430010686, "phrase": "experimental_implementation"}, {"score": 0.002501955525421155, "phrase": "preliminary_tests"}, {"score": 0.0024268423699752113, "phrase": "moderately_larger_data_sets"}, {"score": 0.0023659694724243764, "phrase": "read_operations"}, {"score": 0.0023301793939902015, "phrase": "concurrent_van_emde_boas_array"}, {"score": 0.002237357942660354, "phrase": "viable_alternative"}, {"score": 0.002181227522730908, "phrase": "similar_functionality"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["concurrent objects", " concurrent programming"], "paper_abstract": "Increasing demand for computationally efficient algorithms and processors has turned the attention of researchers toward parallel and concurrent solutions. Because the frequency of contemporary processors cannot be tweaked infinitely, the only hopes for squeezing more performance from computers are parallel processing and parallel computation. The important part of every parallel solution is concurrent data structures, which allow multithread programming environments to be taken advantage of. In this article, a new concurrent dynamic set structure is proposed. It is based on the van Emde Boas trees concept, where on every node of a tree, an array of the node's children is stored. The structure is equipped with a simple but effective locking algorithm, which allows it to be used concurrently by any number of threads. The presented algorithm idea is accompanied by an experimental implementation written in JAVA 6. Preliminary tests prove that, especially for moderately larger data sets with a predominance of read operations, the concurrent van Emde Boas array proposed in this article may be a viable alternative for other structures providing a similar functionality. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "A concurrent van Emde Boas array as a fast and simple concurrent dynamic set alternative", "paper_id": "WOS:000329764200003"}