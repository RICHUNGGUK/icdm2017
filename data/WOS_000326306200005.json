{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "automata-based_termination_proofs."}, {"score": 0.003999578057088828, "phrase": "infinite_and_complex_data_domains"}, {"score": 0.003738502710504415, "phrase": "pointer_structures"}, {"score": 0.003266201217790818, "phrase": "counterexample-driven_abstraction_refinement_loop"}, {"score": 0.002758597251689795, "phrase": "tree-like_data_structures"}, {"score": 0.002450864311898833, "phrase": "automatically_termination"}, {"score": 0.0022145052062614514, "phrase": "depth-first_tree_traversal"}, {"score": 0.0021049977753042253, "phrase": "deutsch-schorr-waite_tree_traversal"}], "paper_keywords": ["Formal verification", " termination analysis", " Buchi automata", " tree automata", " programs with pointers"], "paper_abstract": "This paper describes our generic framework for detecting termination of programs handling infinite and complex data domains, such as pointer structures. The framework is based on a counterexample-driven abstraction refinement loop. We have instantiated the framework for programs handling tree-like data structures, which allowed us to prove automatically termination of programs such as the depth-first tree traversal, the Deutsch-Schorr-Waite tree traversal, or the linking leaves algorithm.", "paper_title": "AUTOMATA-BASED TERMINATION PROOFS", "paper_id": "WOS:000326306200005"}