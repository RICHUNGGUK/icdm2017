{"auto_keywords": [{"score": 0.04014571756494075, "phrase": "modular_redundancy"}, {"score": 0.00481495049065317, "phrase": "efficient_fault-tolerance"}, {"score": 0.004776853267973129, "phrase": "cgras"}, {"score": 0.004627441072541506, "phrase": "multiple_applications"}, {"score": 0.004590820632326585, "phrase": "variable_reliability_needs"}, {"score": 0.004554488671294504, "phrase": "worst-case_platform-wide_fault-tolerance_decisions"}, {"score": 0.004257000695796238, "phrase": "adaptive_fault-tolerance_strategies"}, {"score": 0.004140203942496321, "phrase": "reliability_level"}, {"score": 0.004010624853427534, "phrase": "cgra_domain"}, {"score": 0.00396308097989371, "phrase": "existing_schemes"}, {"score": 0.00385431710959668, "phrase": "different_levels"}, {"score": 0.0033803056981691866, "phrase": "private_fault-tolerance_environments"}, {"score": 0.003248483521309273, "phrase": "low_cost"}, {"score": 0.0030602966787192745, "phrase": "permanent_and_temporary_faults"}, {"score": 0.0029409171055888804, "phrase": "data_memory"}, {"score": 0.0027815466400771768, "phrase": "fault_accumulation"}, {"score": 0.0027485326424697095, "phrase": "configuration_memory"}, {"score": 0.002726740692380339, "phrase": "simulation_results"}, {"score": 0.002610085471513591, "phrase": "fir"}, {"score": 0.002488183412451029, "phrase": "flexible_protection"}, {"score": 0.002468450551616404, "phrase": "energy_overhead"}, {"score": 0.0024006068621542642, "phrase": "different_reliability_levels"}, {"score": 0.002381566880282456, "phrase": "synthesis_results"}, {"score": 0.0023346234464901978, "phrase": "proposed_architecture"}, {"score": 0.0023069016803337365, "phrase": "area_overhead"}, {"score": 0.0021049977753042253, "phrase": "art_adaptive_reliability_techniques"}], "paper_keywords": ["Fault-tolerance", " Reliability", " Adaptive systems", " Energy-aware systems", " Scrubbing", " Reconfiguration", " Coarse grained reconfigurable arrays"], "paper_abstract": "In the era of platforms hosting multiple applications with variable reliability needs, worst-case platform-wide fault-tolerance decisions are neither optimal nor desirable. As a solution to this problem, designs commonly employ adaptive fault-tolerance strategies that provide each application with the reliability level actually needed. However, in the CGRA domain, the existing schemes either only allow to shift between different levels of modular redundancy (duplication, triplication, etc.) or protect only a particular region of a device (e.g. configuration memory, computation, or data memory). To complement these strategies, we propose private fault-tolerance environments which, in addition to modular redundancy, also provide low cost sub-modular (e.g. residue mod 3) redundancy capable of handling both permanent and temporary faults in configuration memory, computation, communication, and data memory. In addition, we also present adaptive configuration scrubbing techniques which prevent fault accumulation in the configuration memory. Simulation results using a few selected algorithms (FFT, matrix multiplication, and FIR filter) show that the approach proposed is capable of providing flexible protection with energy overhead ranging from 3.125 % to 107 % for different reliability levels. Synthesis results have confirmed that the proposed architecture reduces the area overhead for self-checking (58 %) and fault-tolerant (7.1 %) versions, compared to the state of the art adaptive reliability techniques.", "paper_title": "Private reliability environments for efficient fault-tolerance in CGRAs", "paper_id": "WOS:000356451900011"}