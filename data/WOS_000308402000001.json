{"auto_keywords": [{"score": 0.03758114799167708, "phrase": "tinyvm"}, {"score": 0.036083907902476696, "phrase": "compressed_bytecode"}, {"score": 0.00481495049065317, "phrase": "sensor_networks"}, {"score": 0.004770211811866158, "phrase": "energy-efficient_implementation_techniques"}, {"score": 0.00436530211426514, "phrase": "diametrical_effect"}, {"score": 0.004324723240308028, "phrase": "energy_consumption"}, {"score": 0.004264558080356621, "phrase": "vm-based_applications"}, {"score": 0.003994624397219346, "phrase": "bytecode_interpretation"}, {"score": 0.0038301525703886585, "phrase": "energy_efficiency"}, {"score": 0.0033761303704612734, "phrase": "primary_program_representation"}, {"score": 0.003313592421224647, "phrase": "rapid_application_deployment"}, {"score": 0.0032827577713351336, "phrase": "low_communication_overhead"}, {"score": 0.0030747771905143273, "phrase": "decompression_stage"}, {"score": 0.0030178044717552605, "phrase": "memory_consumption"}, {"score": 0.002989714021608139, "phrase": "sensor_nodes"}, {"score": 0.002893434697072309, "phrase": "energy-efficient_application-specific_vms"}, {"score": 0.0028133741785871867, "phrase": "machine_code"}, {"score": 0.0027483472371835865, "phrase": "vm_instruction"}, {"score": 0.0025862068041567934, "phrase": "discrete_optimization_problem"}, {"score": 0.002514625755809045, "phrase": "lowest_energy_consumption"}, {"score": 0.0024336086025284836, "phrase": "experimental_results"}, {"score": 0.002410942838102255, "phrase": "sensor_network_benchmarks"}, {"score": 0.00237733844863506, "phrase": "selected_applications"}, {"score": 0.0022686761827915647, "phrase": "intel"}, {"score": 0.0021750990136123367, "phrase": "gnu_general_public_license"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["virtual machines", " bytecode compression", " mixed-mode execution", " binary", " bytecode partitioning"], "paper_abstract": "Energy-efficient implementation techniques for virtual machines (VMs) have received little attention yet: conventional wisdom claims that VMs have a diametrical effect on energy consumption, and VM-based applications are therefore short-lived. In this paper, we argue that bytecode interpretation is affordable if we synthesize VMs specifically for energy efficiency. We present TinyVM, an execution infrastructure that seamlessly integrates with C and nesC/TinyOS-based programming environments. TinyVM achieves high code density through the use of compressed bytecode as the primary program representation. Compressed bytecode allows rapid application deployment with low communication overhead. TinyVM executes compressed bytecode in place, which eliminates the need for a decompression stage and thereby reduces memory consumption on sensor nodes. Our infrastructure automates the creation of energy-efficient application-specific VMs. Applications are partitioned in machine code, bytecode, and VM instruction set extensions. Partitioning is manually controlled and/or fully guided by a discrete optimization problem that produces a partitioning with lowest energy consumption for a given program size limit. We provide experimental results for sensor network benchmarks and for selected applications on various CPU architectures including Atmega128-based motes and the ARM-based Intel iMote2. TinyVM has been released under the GNU General Public License. Copyright (c) 2011 John Wiley & Sons, Ltd.", "paper_title": "TinyVM: an energy-efficient execution infrastructure for sensor networks", "paper_id": "WOS:000308402000001"}