{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "dynamic_casting"}, {"score": 0.004543708337879809, "phrase": "dynamic_casts"}, {"score": 0.004075469816959996, "phrase": "dynamic_cast"}, {"score": 0.003987755561492638, "phrase": "base_class"}, {"score": 0.0039019217388438134, "phrase": "derived_class"}, {"score": 0.0038179283509963695, "phrase": "object-oriented_language"}, {"score": 0.003525074461418428, "phrase": "integer_type_id"}, {"score": 0.003115908199991072, "phrase": "run_time"}, {"score": 0.003048782877550259, "phrase": "type_id_scheme"}, {"score": 0.0029615198132465236, "phrase": "modulo_function"}, {"score": 0.002655894070657161, "phrase": "class_hierarchies"}, {"score": 0.0026175952455594277, "phrase": "large_size"}, {"score": 0.0024342079318127423, "phrase": "pointer_adjustments"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["dynamic casting", " C plus", " modulo", " embedded systems", " hard real-time"], "paper_abstract": "We describe a scheme for implementing dynamic casts suitable for systems where the performance and predictability of performance is essential. A dynamic cast from a base class to a derived class in an object-oriented language can be performed quickly by having the linker assign an integer type ID to each class. A simple integer arithmetic operation verifies whether the cast is legal at run time. The type ID scheme presented uses the modulo function to check that one class derives from another. A 64-bit type ID is sufficient to handle class hierarchies of large size at least nine levels of derivation deep. We also discuss the pointer adjustments required for a C++ dynamic-cast. All examples will be drawn from the C++ language. Copyright (c) 2005 John Wiley & Sons, Ltd.", "paper_title": "Fast dynamic casting", "paper_id": "WOS:000235376600002"}