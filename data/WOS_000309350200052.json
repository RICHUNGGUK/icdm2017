{"auto_keywords": [{"score": 0.04590884875550199, "phrase": "mpi_datatypes"}, {"score": 0.00481495049065317, "phrase": "automatic_datatype_generation_and_optimization"}, {"score": 0.0045443671106012405, "phrase": "noncontiguous_data"}, {"score": 0.00446987606516801, "phrase": "contiguous_communication_buffers"}, {"score": 0.00418387341007444, "phrase": "noncontiguous_data_layouts"}, {"score": 0.004047781270412204, "phrase": "sophisticated_hardware"}, {"score": 0.0038518661517315533, "phrase": "application_data_structures"}, {"score": 0.0036352070472201086, "phrase": "real-world_applications"}, {"score": 0.003459191419478298, "phrase": "equivalent_datatypes"}, {"score": 0.002676418520290942, "phrase": "packing_code"}, {"score": 0.0024232694434408093, "phrase": "nas_parallel_benchmarks"}, {"score": 0.0023249757987087055, "phrase": "easy_porting"}, {"score": 0.0022492129111567824, "phrase": "new_machines"}, {"score": 0.0021049977753042253, "phrase": "programmer_productivity"}], "paper_keywords": ["Performance", " Design", " MPI", " Datatypes", " Compiler Technique", " Refactoring"], "paper_abstract": "Many high performance applications spend considerable time packing noncontiguous data into contiguous communication buffers. MPI Datatypes provide an alternative by describing noncontiguous data layouts. This allows sophisticated hardware to retrieve data directly from application data structures. However, packing codes in real-world applications are often complex and specifying equivalent datatypes is difficult, time-consuming, and error prone. We present an algorithm that automates the transformation. We have implemented the algorithm in a tool that transforms packing code to MPI Datatypes, and evaluated it by transforming 90 packing codes from the NAS Parallel Benchmarks. The transformation allows easy porting of applications to new machines that benefit from datatypes, thus improving programmer productivity.", "paper_title": "Automatic Datatype Generation and Optimization", "paper_id": "WOS:000309350200052"}