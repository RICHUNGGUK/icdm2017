{"auto_keywords": [{"score": 0.025058379676494633, "phrase": "fpga"}, {"score": 0.00481495049065317, "phrase": "runtime_reconfigurations"}, {"score": 0.004554488671294504, "phrase": "portable_devices"}, {"score": 0.004412000844879264, "phrase": "complex_dynamic_applications"}, {"score": 0.004206548500039536, "phrase": "flexible_platforms"}, {"score": 0.004140203942496321, "phrase": "embedded_systems"}, {"score": 0.004074901471704325, "phrase": "runtime_reconfigurable_hardware"}, {"score": 0.00385431710959668, "phrase": "reconfiguration_latency"}, {"score": 0.0032099453192629976, "phrase": "complex_scheduling_heuristics"}, {"score": 0.0030602966787192745, "phrase": "excessive_penalty"}, {"score": 0.0021559025985688255, "phrase": "good_schedules"}, {"score": 0.0021049977753042253, "phrase": "full_runtime_approach"}], "paper_keywords": [""], "paper_abstract": "Due to the emergence of portable devices that must run complex dynamic applications there is a need for flexible platforms for embedded systems. Runtime reconfigurable hardware can provide this flexibility but the reconfiguration latency can significantly decrease the performance. When dealing with task graphs, runtime support that schedules the reconfigurations in advance can drastically reduce this overhead. However, executing complex scheduling heuristics at runtime may generate an excessive penalty. Hence, we have developed a hybrid design-time/runtime reconfiguration scheduling heuristic that generates its final schedule at runtime but carries out most computations at design-time. We have tested our approach in a PowerPC 405 processor embedded on a FPGA demonstrating that it generates a very small runtime penalty while providing almost as good schedules as a full runtime approach.", "paper_title": "Efficiently Scheduling Runtime Reconfigurations", "paper_id": "WOS:000259971400004"}