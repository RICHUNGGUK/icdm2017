{"auto_keywords": [{"score": 0.042112809942214995, "phrase": "primitive_values"}, {"score": 0.01462202850457287, "phrase": "genetic_algorithms"}, {"score": 0.00481495049065317, "phrase": "whole_test_suite_generation"}, {"score": 0.004712463245074863, "phrase": "unit-level_test_cases"}, {"score": 0.0044369056710423065, "phrase": "method_call_sequences"}, {"score": 0.004213519983188574, "phrase": "right_state"}, {"score": 0.004141575435071002, "phrase": "uncovered_code"}, {"score": 0.003592859432554987, "phrase": "small_local_changes"}, {"score": 0.003382547312072468, "phrase": "target_structure"}, {"score": 0.003324743991757282, "phrase": "global_searches"}, {"score": 0.0032398798149196432, "phrase": "larger_changes"}, {"score": 0.0031435968684569112, "phrase": "particular_aspect"}, {"score": 0.0031032109441552287, "phrase": "test_case"}, {"score": 0.00295950473406239, "phrase": "evosuite_test_generation_tool"}, {"score": 0.0029214769181390653, "phrase": "memetic_algorithm"}, {"score": 0.002680114113899346, "phrase": "test_suite"}, {"score": 0.0026116610153271943, "phrase": "test_cases"}, {"score": 0.0024906610581090223, "phrase": "rigorous_experimental_methodology"}, {"score": 0.002437525632451029, "phrase": "open_source_classes"}, {"score": 0.0023855210798264205, "phrase": "numerical_applications"}, {"score": 0.0023650305205893353, "phrase": "text_processors"}, {"score": 0.002294686545883412, "phrase": "branch_coverage"}, {"score": 0.002226430168622392, "phrase": "individual_class"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Search-based software engineering", " Object-oriented", " Evolutionary testing"], "paper_abstract": "The generation of unit-level test cases for structural code coverage is a task well-suited to Genetic Algorithms. Method call sequences must be created that construct objects, put them into the right state and then execute uncovered code. However, the generation of primitive values, such as integers and doubles, characters that appear in strings, and arrays of primitive values, are not so straightforward. Often, small local changes are required to drive the value toward the one needed to execute some target structure. However, global searches like Genetic Algorithms tend to make larger changes that are not concentrated on any particular aspect of a test case. In this paper, we extend the Genetic Algorithm behind the EVOSUITE test generation tool into a Memetic Algorithm, by equipping it with several local search operators. These operators are designed to efficiently optimize primitive values and other aspects of a test suite that allow the search for test cases to function more effectively. We evaluate our operators using a rigorous experimental methodology on over 12,000 Java classes, comprising open source classes of various different kinds, including numerical applications and text processors. Our study shows that increases in branch coverage of up to 53% are possible for an individual class in practice. (C) 2014 The Authors. Published by Elsevier Inc.", "paper_title": "A Memetic Algorithm for whole test suite generation", "paper_id": "WOS:000351971500021"}