{"auto_keywords": [{"score": 0.03213307404449559, "phrase": "disl"}, {"score": 0.00481495049065317, "phrase": "dynamic_program_analysis_tools"}, {"score": 0.004530023871441992, "phrase": "program_comprehension"}, {"score": 0.004455272634364756, "phrase": "reverse_engineering"}, {"score": 0.004333406378146173, "phrase": "program_instrumentation"}, {"score": 0.0042148594491580324, "phrase": "low-level_instrumentation_libraries"}, {"score": 0.004122351497440992, "phrase": "tedious_and_error-prone_tool_development"}, {"score": 0.0038998328617557013, "phrase": "domain-specific_language"}, {"score": 0.00370981613076245, "phrase": "high-level_programming_abstractions"}, {"score": 0.003628352506247126, "phrase": "instrumentation-based_dynamic_analysis"}, {"score": 0.0033757067564871494, "phrase": "tool_developers"}, {"score": 0.003319939715683536, "phrase": "java_virtual_machine"}, {"score": 0.003175676186323053, "phrase": "resulting_tools"}, {"score": 0.002873524721802591, "phrase": "controlled_experiment"}, {"score": 0.0028260302580927856, "phrase": "tool_development_time"}, {"score": 0.0027486060614330043, "phrase": "developed_tools"}, {"score": 0.0025008468316682036, "phrase": "source_code_metrics"}, {"score": 0.0024323098907299027, "phrase": "original_implementations"}, {"score": 0.0023265270905455334, "phrase": "developer_productivity"}, {"score": 0.0022880528191813105, "phrase": "concise_tool_implementations"}, {"score": 0.0022007302738063566, "phrase": "negative_impact"}, {"score": 0.0021763973978248005, "phrase": "tool_performance"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Dynamic program analysis", " Bytecode instrumentation", " Development productivity", " Controlled experiment"], "paper_abstract": "Dynamic program analysis tools serve many important software engineering tasks such as profiling, debugging, testing, program comprehension, and reverse engineering. Many dynamic analysis tools rely on program instrumentation and are implemented using low-level instrumentation libraries, resulting in tedious and error-prone tool development. Targeting this issue, we have created the Domain-Specific Language for Instrumentation (DiSL), which offers high-level programming abstractions especially designed for instrumentation-based dynamic analysis. When designing DiSL, our goal was to boost the productivity of tool developers targeting the Java Virtual Machine, without impairing the performance of the resulting tools. In this paper we assess whether DiSL meets this goal. First, we perform a controlled experiment to measure tool development time and correctness of the developed tools, comparing DiSL with a prevailing, state-of-the-art instrumentation library. Second, we recast 10 open-source software engineering tools in DiSL and compare source code metrics and performance with the original implementations. Our studies show that DiSL significantly improves developer productivity, enables concise tool implementations, and does not have any negative impact on tool performance. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Dynamic program analysis-Reconciling developer productivity and tool performance", "paper_id": "WOS:000344578800006"}