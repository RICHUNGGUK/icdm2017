{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "lexical_macros"}, {"score": 0.0452139006539908, "phrase": "conditional_compilation"}, {"score": 0.004603244077348199, "phrase": "lexical_preprocessors"}, {"score": 0.004475659507646842, "phrase": "different_variants"}, {"score": 0.004207230913063179, "phrase": "compile-time_code_transformations"}, {"score": 0.003954837422946628, "phrase": "simple_way"}, {"score": 0.0037595947142663997, "phrase": "automatic_analysis"}, {"score": 0.0035539019235553897, "phrase": "variability-induced_complexity"}, {"score": 0.00319348234663792, "phrase": "current_parsing_solutions"}, {"score": 0.0031577303835881964, "phrase": "unsound_heuristics"}, {"score": 0.0029681091946289757, "phrase": "exponential_explosion"}, {"score": 0.0028695095228791724, "phrase": "typechef_project"}, {"score": 0.0027898428590137515, "phrase": "novel_variability-aware_parser"}, {"score": 0.002727700630869639, "phrase": "almost_all_unpreprocessed_code"}, {"score": 0.00266693888510356, "phrase": "practicable_time"}, {"score": 0.002607527117561699, "phrase": "obvious_task"}, {"score": 0.0025638362414466278, "phrase": "syntax_errors"}, {"score": 0.0024097920845706795, "phrase": "variability-aware_type_checking"}, {"score": 0.0023560952790080943, "phrase": "variability-aware_parsers"}, {"score": 0.0023298248728311583, "phrase": "java"}, {"score": 0.0023035922232490106, "phrase": "gnu_c"}, {"score": 0.0022145052062614514, "phrase": "product_line"}, {"score": 0.0021288561076024844, "phrase": "linux_kernel"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " parsing", " C", " preprocessor", " #ifdef", " variability", " conditional compilation", " Linux", " software product lines"], "paper_abstract": "In many projects, lexical preprocessors are used to manage different variants of the project (using conditional compilation) and to define compile-time code transformations (using macros). Unfortunately, while being a simple way to implement variability, conditional compilation and lexical macros hinder automatic analysis, even though such analysis is urgently needed to combat variability-induced complexity. To analyze code with its variability, we need to parse it without preprocessing it. However, current parsing solutions use unsound heuristics, support only a subset of the language, or suffer from exponential explosion. As part of the TypeChef project, we contribute a novel variability-aware parser that can parse almost all unpreprocessed code without heuristics in practicable time. Beyond the obvious task of detecting syntax errors, our parser paves the road for further analysis, such as variability-aware type checking. We implement variability-aware parsers for Java and GNU C and demonstrate practicability by parsing the product line MobileMedia and the entire X86 architecture of the Linux kernel with 6065 variable features.", "paper_title": "Variability-Aware Parsing in the Presence of Lexical Macros and Conditional Compilation", "paper_id": "WOS:000298294500048"}