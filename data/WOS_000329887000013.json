{"auto_keywords": [{"score": 0.049084030038618824, "phrase": "software_bus"}, {"score": 0.034507186965256564, "phrase": "model_checking"}, {"score": 0.03352481171599959, "phrase": "test_process"}, {"score": 0.015719716506582538, "phrase": "formal_engineering"}, {"score": 0.015132125742744085, "phrase": "formal_methods"}, {"score": 0.014440485375977852, "phrase": "xbus"}, {"score": 0.010291111212067359, "phrase": "second_phase"}, {"score": 0.004698392162272106, "phrase": "neopost"}, {"score": 0.004649302313891199, "phrase": "actual_industrial_use"}, {"score": 0.004536735647938243, "phrase": "neopost_inc."}, {"score": 0.0044736342427651185, "phrase": "server_component"}, {"score": 0.004342430078306461, "phrase": "testing_phase"}, {"score": 0.004149138381307042, "phrase": "model-based_test_tool"}, {"score": 0.004105763585757431, "phrase": "well-tested_software_bus"}, {"score": 0.0039505509342840665, "phrase": "jtorx"}, {"score": 0.003909244008208322, "phrase": "total_development_time"}, {"score": 0.0038548365797312443, "phrase": "model-based_testing"}, {"score": 0.0038011834843079554, "phrase": "conventional_test_methods"}, {"score": 0.003525291235622844, "phrase": "industrially_oriented_conferences"}, {"score": 0.0035129628117557023, "phrase": "ferreira"}, {"score": 0.003500664595501441, "phrase": "romanenko"}, {"score": 0.003374158368755018, "phrase": "case_study"}, {"score": 0.0032808401291334246, "phrase": "added_benefits"}, {"score": 0.0030855783418239366, "phrase": "xbus_protocol"}, {"score": 0.003021334228842501, "phrase": "neopost_business_process"}, {"score": 0.003005482666967669, "phrase": "working_implementation"}, {"score": 0.002948066398723126, "phrase": "behavioral_requirements"}, {"score": 0.002787181295054319, "phrase": "so-called_bad_weather_behavior"}, {"score": 0.0025264171945423254, "phrase": "entire_model-based_testing_approach"}, {"score": 0.002388487669097511, "phrase": "high_code_coverage"}, {"score": 0.0022383457200545634, "phrase": "formal_engineering_approach"}, {"score": 0.0022071417144862862, "phrase": "high_quality_software_products"}, {"score": 0.0021840238893568206, "phrase": "significantly_better_models"}, {"score": 0.002149799391146313, "phrase": "system_developers"}, {"score": 0.0021347607855562102, "phrase": "higher_model_quality"}, {"score": 0.002127280894809367, "phrase": "higher_costs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Formal methods", " Formal engineering", " Model-based testing", " IOCO", " JTorX", " mCRL2", " LTSmin", " CADP", " evaluator4", " MCL", " LPS", " Ips2torx"], "paper_abstract": "We report on the actual industrial use of formal methods during the development of a software bus. During an internship at Neopost Inc., of 14 weeks, we developed the server component of a software bus, called the XBus, using formal methods during the design, validation and testing phase: we modeled our design of the XBus in the process algebra mCRL2, validated the design using the mCRL2-simulator, and fully automatically tested our implementation with the model-based test tool JTorX. This resulted in a well-tested software bus with a maintainable architecture. Writing the model (m(dev)), simulating it, and testing the implementation with JTorX only took 17% of the total development time. Moreover, the errors found with model-based testing would have been hard to find with conventional test methods. Thus, we show that formal engineering can be feasible, beneficial and cost-effective. The findings above, reported earlier by us in (Sijtema et al., 2011) [1], were well-received, also in industrially oriented conferences (Ferreira and Romanenko, 2010) [2] and [3]. In this paper, we look back on the case study, and carefully analyze its merits and shortcomings. We reflect on (1) the added benefits of model checking, (2) model completeness and (3) the quality and performance of the test process. Thus, in a second phase, after the internship, we model checked the XBus protocol-this was not done in [1] since the Neopost business process required a working implementation after 14 weeks. We used the CADP tool evaluator4 to check the behavioral requirements obtained during the development. Model checking did not uncover errors in model m(dev), but revealed that model m(dev) was neither complete nor optimized: in particular, requirements to the so-called bad weather behavior (exceptions, unexpected inputs, etc.) were missing. Therefore, we created several improved models, checked that we could validate them, and used them to analyze quality and performance of the test process. Model checking was expensive: it took us approx. 4 weeks in total, compared to 3 weeks for the entire model-based testing approach during the internship. In the second phase, we analyzed the quality and performance of the test process, where we looked at both code and model coverage. We found that high code coverage (almost 100%) is in most cases obtained within 1000 test steps and 2 minutes, which matches the fact that the faults in the XBus were discovered within a few minutes. Summarizing, we firmly believe that the formal engineering approach is cost-effective, and produces high quality software products. Model checking does yield significantly better models, but is also costly. Thus, system developers should trade off higher model quality against higher costs. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Experiences with formal engineering: Model-based specification, implementation and testing of a software bus at Neopost", "paper_id": "WOS:000329887000013"}