{"auto_keywords": [{"score": 0.0417572237624928, "phrase": "shared_data"}, {"score": 0.00481495049065317, "phrase": "building_applications"}, {"score": 0.004653900688892822, "phrase": "parallel_hardware"}, {"score": 0.0043477114072437316, "phrase": "important_challenge"}, {"score": 0.003906586074865932, "phrase": "complicated_locking_schemes"}, {"score": 0.003614044704141927, "phrase": "parallel_execution"}, {"score": 0.003579046565851265, "phrase": "different_application_tasks"}, {"score": 0.003359647377874098, "phrase": "isolation_types"}, {"score": 0.002685558057339722, "phrase": "chosen_isolation_type"}, {"score": 0.0026209522797963447, "phrase": "practical_viability"}, {"score": 0.0025331002386232014, "phrase": "efficient_algorithm"}, {"score": 0.002331781764406665, "phrase": "interactive_game_application"}, {"score": 0.002264607102799332, "phrase": "parallelized_game"}, {"score": 0.0021674482571326283, "phrase": "original_sequential_game"}, {"score": 0.002135995282374723, "phrase": "satisfactory_speedups"}, {"score": 0.0021049977753042253, "phrase": "multicore_processor"}], "paper_keywords": ["Languages", " Concurrency", " Parallelism", " Transactions", " Isolation", " Revisions"], "paper_abstract": "Building applications that are responsive and can exploit parallel hardware while remaining simple to write, understand, test, and maintain, poses an important challenge for developers. In particular, it is often desirable to enable various tasks to read or modify shared data concurrently without requiring complicated locking schemes that may throttle concurrency and introduce bugs. We introduce a mechanism that simplifies the parallel execution of different application tasks. Programmers declare what data they wish to share between tasks by using isolation types, and execute tasks concurrently by forking and joining revisions. These revisions are isolated: they read and modify their own private copy of the shared data only. A runtime creates and merges copies automatically, and resolves conflicts deterministically, in a manner declared by the chosen isolation type. To demonstrate the practical viability of our approach, we developed an efficient algorithm and an implementation in the form of a C# library, and used it to parallelize an interactive game application. Our results show that the parallelized game, while simple and very similar to the original sequential game, achieves satisfactory speedups on a multicore processor.", "paper_title": "Concurrent Programming with Revisions and Isolation Types", "paper_id": "WOS:000286595800042"}