{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "algebraic_specifications"}, {"score": 0.03206132521725483, "phrase": "formal_specifications"}, {"score": 0.0047810714349158165, "phrase": "java_classes"}, {"score": 0.004747429622531595, "phrase": "modern_programs"}, {"score": 0.004714023408114857, "phrase": "extensive_use"}, {"score": 0.004680851157467745, "phrase": "reusable_software_libraries"}, {"score": 0.004502513902377422, "phrase": "large_java_applications"}, {"score": 0.004330941610682453, "phrase": "container_classes"}, {"score": 0.004165879874212301, "phrase": "extensive_code_reuse"}, {"score": 0.004136548839735555, "phrase": "java_programs"}, {"score": 0.004007083686875716, "phrase": "reusable_classes"}, {"score": 0.0031732652552570644, "phrase": "natural_language"}, {"score": 0.00290473242917264, "phrase": "significant_effort"}, {"score": 0.0028037753646260937, "phrase": "practical_difficulties"}, {"score": 0.002612238631882345, "phrase": "algebraic_specification"}, {"score": 0.0024510413243251906, "phrase": "regular_java_class"}, {"score": 0.0023325586335885104, "phrase": "error_messages"}, {"score": 0.0022041312401435346, "phrase": "hand-coded_implementation"}, {"score": 0.0021501863832966966, "phrase": "case_studies"}], "paper_keywords": ["documentation", " algebraic interpretation", " algebraic specifications", " specification discovery"], "paper_abstract": "Modern programs make extensive use of reusable software libraries. For example, a study of a number of large Java applications shows that between 17% and 30% of the classes in those applications use container classes defined in the java. util package. Given this extensive code reuse in Java programs, it is important for the interfaces of reusable classes to be well documented. An interface is well documented if it satisfies the following requirements: ( 1) the documentation completely describes how to use the interface; ( 2) the documentation is clear; ( 3) the documentation is unambiguous; and ( 4) any deviation between the documentation and the code is machine detectable. Unfortunately, documentation in natural language, which is the norm, does not satisfy the above requirements. Formal specifications can satisfy them but they are difficult to develop, requiring significant effort on the part of programmers. To address the practical difficulties with formal specifications, we describe and evaluate a tool to help programmers write and debug algebraic specifications. Given an algebraic specification of a class, our interpreter generates a prototype that can be used within an application like a regular Java class. When running an application that uses the prototype, the interpreter prints error messages that tell the developer in which way the specification is incomplete or inconsistent with a hand-coded implementation of the class. We use case studies to demonstrate the usefulness of our system.", "paper_title": "Developing and debugging algebraic specifications for Java classes", "paper_id": "WOS:000257820200003"}