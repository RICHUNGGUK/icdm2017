{"auto_keywords": [{"score": 0.024408336925290132, "phrase": "iv"}, {"score": 0.00481495049065317, "phrase": "finite_memory_universal_data_compression"}, {"score": 0.004730158389701481, "phrase": "individual_sequences"}, {"score": 0.004605748839642513, "phrase": "consecutive_blocks"}, {"score": 0.004565007074039171, "phrase": "n_letters"}, {"score": 0.00450456611645112, "phrase": "semi-infinite_individual_sequence_x"}, {"score": 0.004308791766002289, "phrase": "binary_sequences"}, {"score": 0.004251728624599691, "phrase": "one-to-one_mapping"}, {"score": 0.003907403442285109, "phrase": "universal_data-compression_algorithm"}, {"score": 0.003606866938661143, "phrase": "best_error-free_compression"}, {"score": 0.003543273649210823, "phrase": "particular_individual_sequence_x"}, {"score": 0.003389136094439662, "phrase": "best_possible_compression"}, {"score": 0.0032852337992126564, "phrase": "universal_data_compression_algorithm"}, {"score": 0.0032706520949775065, "phrase": "forfinite_n-blocks"}, {"score": 0.0031562971707460802, "phrase": "context_tree_coding"}, {"score": 0.002900426826591769, "phrase": "individual_training_sequence"}, {"score": 0.002861961643289598, "phrase": "classifier's_task"}, {"score": 0.002811464848641341, "phrase": "individual_test_sequences"}, {"score": 0.0027865506182608263, "phrase": "length_n"}, {"score": 0.0025950024597986366, "phrase": "training_sequence_x"}, {"score": 0.002482013330276732, "phrase": "appropriate_criterion"}, {"score": 0.0023739321566540682, "phrase": "particular_universal_context_classifier"}, {"score": 0.0023424328921363585, "phrase": "storagespace_complexity"}, {"score": 0.0021910825909008946, "phrase": "theoretical_\"individual_sequence\"_justification"}, {"score": 0.0021049977753042253, "phrase": "computational_biology"}], "paper_keywords": ["context-tree coding", " data compression", " universal", " classification", " universal compression"], "paper_abstract": "Consider the case where consecutive blocks of N letters of a semi-infinite individual sequence X over a finite-alphabet are being compressed into binary sequences by some one-to-one mapping. No a priori information about X is available at the encoder, which must therefore adopt a universal data-compression algorithm. It is known that if the universal Lempel-Ziv (LZ) data compression algorithm is successively applied to N-blocks then the best error-free compression, for the particular individual sequence X is achieved as N tends to infinity. The best possible compression that may be achieved by any universal data compression algorithm forfinite N-blocks is discussed. It is demonstrated that context tree coding essentially achieves it. Next, consider a device called classifier (or discriminator) that observes an individual training sequence X. The classifier's task is to examine individual test sequences of length N and decide whether the test A7-sequence has the same features as those that are captured by the training sequence X, or is sufficiently different, according to some appropriate criterion. Here again, it is demonstrated that a particular universal context classifier with a storagespace complexity that is linear in IV, is essentially optimal. This may contribute a theoretical \"individual sequence\" justification for the Probabilistic Suffix Tree (PST) approach in learning theory and in computational biology.", "paper_title": "On finite memory universal data compression and classification of individual sequences", "paper_id": "WOS:000254475300016"}