{"auto_keywords": [{"score": 0.03743399683518872, "phrase": "guiding_principles"}, {"score": 0.015452978649360787, "phrase": "signal_processing_applications"}, {"score": 0.013943647192694239, "phrase": "loop_nests"}, {"score": 0.010593669586665022, "phrase": "optimal_ordering"}, {"score": 0.007769286363982175, "phrase": "memory_requirement"}, {"score": 0.007702562692909252, "phrase": "in-place_mapping"}, {"score": 0.00481495049065317, "phrase": "loop_ordering"}, {"score": 0.004773476989344654, "phrase": "reduced_memory_usage"}, {"score": 0.004551647527068771, "phrase": "large_and_multi-dimensional_arrays"}, {"score": 0.0043213410601860985, "phrase": "array_elements"}, {"score": 0.004228839109569368, "phrase": "huge_impact"}, {"score": 0.0038781372962808894, "phrase": "memory_hierarchy"}, {"score": 0.003828091961373454, "phrase": "dominating_factor"}, {"score": 0.0037299231609021783, "phrase": "chip_size"}, {"score": 0.0033039560332995136, "phrase": "design_tools"}, {"score": 0.003205268682789165, "phrase": "loop_nest_dimensions"}, {"score": 0.003177615880037735, "phrase": "individual_data_dependencies"}, {"score": 0.002990592465417758, "phrase": "prior_restrictions"}, {"score": 0.0026835045963349647, "phrase": "remaining_dimensions"}, {"score": 0.002449997042686432, "phrase": "early_design_phases"}, {"score": 0.0023056996845692355, "phrase": "real_life_examples"}, {"score": 0.0021982976170703884, "phrase": "cost_optimized_end_product"}, {"score": 0.0021325650133686516, "phrase": "magnitude_improvement"}], "paper_keywords": ["Memory optimization", " Memory architecture exploration", " High level synthesis", " Code transformation", " Multi-media"], "paper_abstract": "Data dominated signal processing applications are typically described using large and multi-dimensional arrays and loop nests. The order of production and consumption of array elements in these loop nests has huge impact on the amount of memory required during execution. This is essential since the size and complexity of the memory hierarchy is the dominating factor for power, performance and chip size in these applications. This paper presents a number of guiding principles for the ordering of the dimensions in the loop nests. They enable the designer, or design tools, to find the optimal ordering of loop nest dimensions for individual data dependencies in the code. We prove the validity of the guiding principles when no prior restrictions are given regarding fixation of dimensions. If some dimensions are already fixed at given nest levels, this is taken into account when fixing the remaining dimensions. In most cases an optimal ordering is found for this situation as well. The guiding principles can be used in the early design phases in order to enable minimization of the memory requirement through in-place mapping. We use real life examples to show how they can be applied to reach a cost optimized end product. The results show orders of magnitude improvement in memory requirement compared to using the declared array sizes, and similar penalties for choosing the suboptimal ordering of loops when in-place mapping is exploited.", "paper_title": "Guidance of Loop Ordering for Reduced Memory Usage in Signal Processing Applications", "paper_id": "WOS:000259920500006"}