{"auto_keywords": [{"score": 0.04950097558699651, "phrase": "timing_model"}, {"score": 0.03769356560998694, "phrase": "secure_protocol"}, {"score": 0.02918882749290789, "phrase": "multiparty_functionality"}, {"score": 0.02696890954448819, "phrase": "concurrent_general_composition"}, {"score": 0.00481495049065317, "phrase": "secure_protocols"}, {"score": 0.004642604455537883, "phrase": "secure_multiparty_computation"}, {"score": 0.004549524321051407, "phrase": "mutually_distrustful_parties"}, {"score": 0.004440277230269978, "phrase": "joint_function"}, {"score": 0.004333642054036135, "phrase": "stand-alone_case"}, {"score": 0.004212453011596424, "phrase": "efficient_function"}, {"score": 0.004012500850311087, "phrase": "concurrent_composition"}, {"score": 0.003980106938194548, "phrase": "broad_impossibility_results"}, {"score": 0.0038375280115736958, "phrase": "honest_majority"}, {"score": 0.003791141540467091, "phrase": "trusted_setup_phase"}, {"score": 0.003640516896245813, "phrase": "general_composition"}, {"score": 0.0034817084307034955, "phrase": "arbitrary_other_protocols"}, {"score": 0.003384262486955773, "phrase": "single_secure_protocol"}, {"score": 0.003120568497402472, "phrase": "concurrent_setting"}, {"score": 0.003020918749760067, "phrase": "local_clock"}, {"score": 0.002936331371903168, "phrase": "approximately_the_same_rate"}, {"score": 0.0028541057064952876, "phrase": "mild_timing_assumption"}, {"score": 0.0027295084882654917, "phrase": "concurrent_self-composition"}, {"score": 0.0023680327896318915, "phrase": "specified_amount"}, {"score": 0.002311047934798247, "phrase": "negative_side"}, {"score": 0.0021049977753042253, "phrase": "aforementioned_delays"}], "paper_keywords": ["theory of cryptography", " secure multiparty computation", " concurrent composition", " timing assumptions"], "paper_abstract": "In the setting of secure multiparty computation, a set of mutually distrustful parties wish to securely compute some joint function of their inputs. In the stand-alone case it has been shown that every efficient function can be securely computed. However, in the setting of concurrent composition, broad impossibility results have been proven for the case of no honest majority and no trusted setup phase. These results hold both for the case of general composition (where a secure protocol is run many times concurrently with arbitrary other protocols) and self-composition (where a single secure protocol is run many times concurrently). In this paper we investigate the feasibility of obtaining security in the concurrent setting, assuming that each party has a local clock and that these clocks proceed at approximately the same rate. We show that under this mild timing assumption, it is possible to securely compute any multiparty functionality under concurrent self-composition. Loosely speaking, we also show that it is possible to securely compute any multiparty functionality under concurrent general composition, as long as the secure protocol is run only with protocols whose messages are delayed by a specified amount of time. On the negative side, we show that it is impossible to achieve security under concurrent general composition with no restrictions whatsoever on the network (like the aforementioned delays), even in the timing model.", "paper_title": "Concurrent composition of secure protocols in the timing model", "paper_id": "WOS:000248577800002"}