{"auto_keywords": [{"score": 0.04191813762702451, "phrase": "aotc"}, {"score": 0.04066501652970597, "phrase": "jitc"}, {"score": 0.03826559283990352, "phrase": "hybrid_environment"}, {"score": 0.008437231763926573, "phrase": "jitc_methods"}, {"score": 0.008378579656917509, "phrase": "aotc_methods"}, {"score": 0.00481495049065317, "phrase": "hybrid_java_compilation_of"}, {"score": 0.004616859702338596, "phrase": "embedded_systems."}, {"score": 0.004568617813032014, "phrase": "java_software_platforms"}, {"score": 0.004505074966056871, "phrase": "java_classes"}, {"score": 0.004395984840790689, "phrase": "client_device"}, {"score": 0.004304574865291508, "phrase": "service_providers"}, {"score": 0.004229847379280629, "phrase": "higher_performance"}, {"score": 0.004112961231504503, "phrase": "static_java_classes"}, {"score": 0.004027412633636142, "phrase": "time_compiler"}, {"score": 0.003929843413153981, "phrase": "dynamically_downloaded_classes"}, {"score": 0.0039024014688338964, "phrase": "just-in-time_compiler"}, {"score": 0.0038078492247427594, "phrase": "hybrid_compilation_environment"}, {"score": 0.0037286231222250065, "phrase": "hybrid_java_compilation_approach"}, {"score": 0.0036767202303156854, "phrase": "initial_case_study"}, {"score": 0.003525291235622844, "phrase": "existing_aotc"}, {"score": 0.0033213460816510685, "phrase": "generally_accepted_approach"}, {"score": 0.0027100527874262446, "phrase": "naive_merge"}, {"score": 0.0022110183535859374, "phrase": "desired_performance"}, {"score": 0.0021049977753042253, "phrase": "efficient_hybrid_execution"}], "paper_keywords": ["Hybrid Java compilation", " ahead-of-time compiler", " just-in-time compiler", " JVM"], "paper_abstract": "Many embedded Java software platforms execute two types of Java classes: those installed statically on the client device and those downloaded dynamically from service providers at runtime. For higher performance, it would be desirable to compile static Java classes by ahead-of-time compiler (AOTC) and to handle dynamically downloaded classes by just-in-time compiler (JITC), providing a hybrid compilation environment. This paper proposes a hybrid Java compilation approach and performs an initial case study with a hybrid environment, which is constructed simply by merging an existing AOTC and a JITC for the same Java virtual machine. Both compilers are developed independently for their own performance advantages with a generally accepted approach of compilation, but we merged them as effciently as possible. Contrary to our expectations, the hybrid environment does not deliver a performance, in-between of full-JITC's and full-AOTC's. In fact, its performance is even lower than full-JITC's for many benchmarks. We analyzed the result and found that a naive merge of JITC and AOTC may result in ineffciencies, especially due to calls between JITC methods and AOTC methods. Based on these observations, we propose some ideas to reduce such a call overhead. We also observed that the distribution of JITC methods and AOTC methods is also important, and experimented with various distributions to understand when a hybrid environment can deliver a desired performance. Finally, we discuss how JITC and AOTC should be designed for efficient hybrid execution.", "paper_title": "HYBRID JAVA COMPILATION OF JUST-IN-TIME AND AHEAD-OF TIME FOR EMBEDDED SYSTEMS", "paper_id": "WOS:000305249100002"}