{"auto_keywords": [{"score": 0.045366511165128576, "phrase": "definition-site_variance"}, {"score": 0.030552048419689396, "phrase": "use-site_variance_annotations"}, {"score": 0.00481495049065317, "phrase": "safe_integration"}, {"score": 0.004732785510739708, "phrase": "subtype_polymorphism"}, {"score": 0.0045726187330434025, "phrase": "use-site_variance"}, {"score": 0.0042683173335408406, "phrase": "scala"}, {"score": 0.0041773934798743405, "phrase": "simple_type-instantiation_rules"}, {"score": 0.004106063237069123, "phrase": "fractured_definitions"}, {"score": 0.0040708542958968605, "phrase": "naturally_invariant_classes"}, {"score": 0.0040186038781533946, "phrase": "-site_variance"}, {"score": 0.003950192074285975, "phrase": "java"}, {"score": 0.003865826699096508, "phrase": "class_definitions"}, {"score": 0.003816197777388722, "phrase": "complex_type-instantiation_rules"}, {"score": 0.0036710872046569532, "phrase": "unifying_framework"}, {"score": 0.0032820385246266773, "phrase": "small_core_calculus"}, {"score": 0.0031982609080278643, "phrase": "specific_type_systems"}, {"score": 0.003157174936641705, "phrase": "general_framework"}, {"score": 0.0031166151196841308, "phrase": "multiple_applications"}, {"score": 0.0028468767420392945, "phrase": "scala_type_system"}, {"score": 0.0027150087516999047, "phrase": "java_type_system"}, {"score": 0.0024586427394152196, "phrase": "six_java_generic_libraries"}, {"score": 0.002416589459425828, "phrase": "java_core_library"}, {"score": 0.002294686545883412, "phrase": "generic_definitions"}, {"score": 0.0022073031056287903, "phrase": "method_signatures"}, {"score": 0.0021049977753042253, "phrase": "existing_wildcard_annotations"}], "paper_keywords": ["Design", " Languages", " variance", " definition-site variance", " use-site variance", " wildcards", " language extensions"], "paper_abstract": "Variance allows the safe integration of parametric and subtype polymorphism. Two flavors of variance, definition-site versus use-site variance, have been studied and have had their merits hotly debated. Definition-site variance (as in Scala and C#) offers simple type-instantiation rules, but causes fractured definitions of naturally invariant classes; Use-site variance (as in Java) offers simplicity in class definitions, yet complex type-instantiation rules that elude most programmers. We present a unifying framework for reasoning about variance. Our framework is quite simple and entirely denotational, that is, it evokes directly the definition of variance with a small core calculus that does not depend on specific type systems. This general framework can have multiple applications to combine the best of both worlds: for instance, it can be used to add use-site variance annotations to the Scala type system. We show one such application in detail: we extend the Java type system with a mechanism that modularly infers the definition-site variance of type parameters, while allowing use-site variance annotations on any type-instantiation. Applying our technique to six Java generic libraries (including the Java core library) shows that 20-58% (depending on the library) of generic definitions are inferred to have single-variance; 8-63% of method signatures can be relaxed through this inference, and up to 91% of existing wildcard annotations are unnecessary and can be elided.", "paper_title": "Taming the Wildcards: Combining Definition- and Use-Site Variance", "paper_id": "WOS:000294609500052"}