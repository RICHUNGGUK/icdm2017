{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "instruction_selection"}, {"score": 0.01258015225178894, "phrase": "embedded_systems"}, {"score": 0.004749106104067268, "phrase": "well-studied_compiler_phase"}, {"score": 0.004662705558154439, "phrase": "compiler's_intermediate_representation"}, {"score": 0.004515252649226697, "phrase": "target-dependent_machine_instructions"}, {"score": 0.004119049028319832, "phrase": "single_statement"}, {"score": 0.004062682236016889, "phrase": "basic_block"}, {"score": 0.0039522429946090174, "phrase": "irregular_instruction_sets"}, {"score": 0.003757480190200645, "phrase": "optimal_technique"}, {"score": 0.0036721416244816455, "phrase": "static_single_assignment"}, {"score": 0.003555902292752528, "phrase": "intermediate_representation"}, {"score": 0.003459191419478298, "phrase": "partitioned_boolean_quadratic_problem"}, {"score": 0.003349670229755675, "phrase": "optimal_instruction_selection"}, {"score": 0.0033037970113095577, "phrase": "existing_approaches"}, {"score": 0.0032436052954996097, "phrase": "instruction_patterns"}, {"score": 0.003140888248194296, "phrase": "simple_tree_structure"}, {"score": 0.003083655376444887, "phrase": "complex_patterns"}, {"score": 0.0030554300179552415, "phrase": "multiple_results"}, {"score": 0.002851798299862983, "phrase": "simd"}, {"score": 0.002686284749214443, "phrase": "pbqp"}, {"score": 0.0026257460385777733, "phrase": "np"}, {"score": 0.002394457015440996, "phrase": "llvm"}, {"score": 0.0023400004981080818, "phrase": "extensive_experiments"}, {"score": 0.002276283303864666, "phrase": "typical_dsp_kernels"}, {"score": 0.002183938718432764, "phrase": "test_programs"}, {"score": 0.0021049977753042253, "phrase": "heuristic_pbqp_solver"}], "paper_keywords": ["algorithms", " languages", " performance", " compiler", " code generation", " instruction selection", " PBQP"], "paper_abstract": "Instruction selection is a well-studied compiler phase that translates the compiler's intermediate representation of programs to a sequence of target-dependent machine instructions optimizing for various compiler objectives (e. g. speed and space). Most existing instruction selection techniques are limited to the scope of a single statement or a basic block and cannot cope with irregular instruction sets that are frequently found in embedded systems. We consider an optimal technique for instruction selection that uses Static Single Assignment (SSA) graphs as an intermediate representation of programs and employs the Partitioned Boolean Quadratic Problem (PBQP) for finding an optimal instruction selection. While existing approaches are limited to instruction patterns that can be expressed in a simple tree structure, we consider complex patterns producing multiple results at the same time including pre/post increment addressing modes, div-mod instructions, and SIMD extensions frequently found in embedded systems. Although both instruction selection on SSA-graphs and PBQP are known to be NP-complete, the problem can be solved efficiently-even for very large instances. Our approach has been implemented in LLVM for an embedded ARMv5 architecture. Extensive experiments show speedups of up to 57% on typical DSP kernels and up to 10% on SPECINT 2000 and MiBench benchmarks. All of the test programs could be compiled within less than half a minute using a heuristic PBQP solver that solves 99.83% of all instances optimally.", "paper_title": "Generalized instruction selection using SSA-graphs", "paper_id": "WOS:000257820500003"}