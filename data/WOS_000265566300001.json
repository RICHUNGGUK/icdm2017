{"auto_keywords": [{"score": 0.04676844994516407, "phrase": "internal_cell"}, {"score": 0.03549931087351771, "phrase": "sequential_scan_algorithm"}, {"score": 0.00481495049065317, "phrase": "fault-tolerant_version"}, {"score": 0.00477945927997702, "phrase": "sequential_scan_problem"}, {"score": 0.004720884905557622, "phrase": "identical_cells"}, {"score": 0.004640079189342692, "phrase": "scanning_head"}, {"score": 0.003780741771838863, "phrase": "previous_neighbor"}, {"score": 0.0036164075087020994, "phrase": "motion_direction"}, {"score": 0.0033915218806508693, "phrase": "execution_cost"}, {"score": 0.003228064431860277, "phrase": "worst-case_number"}, {"score": 0.0031260524791486347, "phrase": "entire_line"}, {"score": 0.003102971393985573, "phrase": "worst_case"}, {"score": 0.0030648798418258915, "phrase": "adversary's_decisions"}, {"score": 0.0028670988845838296, "phrase": "sequential_scan_algorithms"}, {"score": 0.002852965121474273, "phrase": "minimum_execution_cost"}, {"score": 0.002797121441432477, "phrase": "known_line_size"}, {"score": 0.0025844378567309685, "phrase": "fault-tolerant_sequential_scan"}, {"score": 0.0023997225665909707, "phrase": "arbitrary_n."}, {"score": 0.0023066549152384024, "phrase": "alternative_algorithm"}, {"score": 0.002152368701947456, "phrase": "infinitely_many_n."}, {"score": 0.0021364613650251786, "phrase": "asymptotic_performances"}, {"score": 0.0021049977753042253, "phrase": "unbounded_k"}], "paper_keywords": [""], "paper_abstract": "We consider the fault-tolerant version of the sequential scan problem. A line of identical cells has to be visited by a scanning head. The head can only distinguish an end of the line from an internal cell but can distinguish neither one end from the other, nor one internal cell from another. When the head starts at an internal cell, its first move is in a direction chosen by the adversary. When the head comes to an internal cell from a neighbor, it has two possible moves: forward, which means \"go to the other neighbor\", and back which means \"return to the previous neighbor\". At this point the adversary can place a fault whose effect is the change of the motion direction (going forward instead of back and vice-versa). The head is not aware of the occurrence of a fault. The execution cost of a sequential scan algorithm for a line of length n in the presence of at most k faults is the worst-case number of steps that the head must perform in order to scan the entire line. The worst case is taken over all adversary's decisions. We consider two scenarios: when the length of the line is known to the algorithm and when it is unknown. Our goal is to construct sequential scan algorithms with minimum execution cost. We completely solve this problem for known line size. For any parameters k and n we construct a sequential scan algorithm, analyze its complexity and prove a matching lower bound, thus showing that our algorithm is optimal. The problem of fault-tolerant sequential scan for unknown line size is solved partially. For any parameter k we construct a sequential scan algorithm which explores a line of length n with cost 2kn+o(kn), for arbitrary n. For k=1 our algorithm is shown to be optimal. However, we also show an alternative algorithm that has cost at most O(kn) (with a constant larger than 2) for any n and cost kn+o(kn) (which is asymptotically optimal) for infinitely many n. Hence the asymptotic performances of the two algorithms, for unbounded k and n, are incomparable.", "paper_title": "Fault-Tolerant Sequential Scan", "paper_id": "WOS:000265566300001"}