{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "fault-tolerant_distributed_programs"}, {"score": 0.04808171687412103, "phrase": "existing_fault-intolerant_distributed_programs"}, {"score": 0.042188392869170255, "phrase": "distributed_programs"}, {"score": 0.0047135086583390585, "phrase": "automated_addition"}, {"score": 0.004291848822287492, "phrase": "liveness_specifications"}, {"score": 0.0035291500435314016, "phrase": "np"}, {"score": 0.003409399407390298, "phrase": "program's_state_space"}, {"score": 0.003309124298009635, "phrase": "synthesis_problem"}, {"score": 0.003104038398386081, "phrase": "high_worst-case_complexity"}, {"score": 0.0030645676308053444, "phrase": "moderate-sized_masking_distributed_programs"}, {"score": 0.002886885861509621, "phrase": "bdd-based_synthesis_heuristic"}, {"score": 0.002583713580625699, "phrase": "reasonable_amount"}, {"score": 0.0022634699331607615, "phrase": "program_synthesis"}, {"score": 0.0021968238865548812, "phrase": "state_explosion_problem"}, {"score": 0.0021049977753042253, "phrase": "decision_procedures"}], "paper_keywords": ["Distributed programs", " Fault-tolerance", " Program synthesis", " Symbolic algorithms", " Program transformation", " Formal methods"], "paper_abstract": "We focus on automated addition of masking fault-tolerance to existing fault-intolerant distributed programs. Intuitively, a program is masking fault-tolerant, if it satisfies its safety and liveness specifications in the absence and presence of faults. Masking fault-tolerance is highly desirable in distributed programs, as the structure of such programs are fairly complex and they are often subject to various types of faults. However, the problem of synthesizing masking fault-tolerant distributed programs from their fault-intolerant version is NP-complete in the size of the program's state space, setting the practicality of the synthesis problem in doubt. In this paper, we show that in spite of the high worst-case complexity, synthesizing moderate-sized masking distributed programs is feasible in practice. In particular, we present and implement a BDD-based synthesis heuristic for adding masking fault-tolerance to existing fault-intolerant distributed programs automatically. Our experiments validate the efficiency and effectiveness of our algorithm in the sense that synthesis is possible in reasonable amount of time and memory. We also identify several bottlenecks in synthesis of distributed programs depending upon the structure of the program at hand. We conclude that unlike verification, in program synthesis, the most challenging barrier is not the state explosion problem by itself, but the time complexity of the decision procedures.", "paper_title": "Symbolic synthesis of masking fault-tolerant distributed programs", "paper_id": "WOS:000300893400005"}