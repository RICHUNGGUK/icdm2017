{"auto_keywords": [{"score": 0.03380803650925848, "phrase": "bta."}, {"score": 0.00481495049065317, "phrase": "machine_code"}, {"score": 0.004620093797504386, "phrase": "off-line_partial_evaluation"}, {"score": 0.004410248125081398, "phrase": "classical_two-phase_approach"}, {"score": 0.004364919932563366, "phrase": "binding-time_analysis"}, {"score": 0.004145143433523008, "phrase": "machine-code_partial_evaluation"}, {"score": 0.004039423410198574, "phrase": "new_challenges"}, {"score": 0.0038758293658651237, "phrase": "new_techniques"}, {"score": 0.0036427316134070007, "phrase": "instruction-rewriting_method"}, {"score": 0.003459191419478298, "phrase": "single_instruction"}, {"score": 0.003353521531649663, "phrase": "cascading_imprecision"}, {"score": 0.0031354779851351287, "phrase": "explicit_representation"}, {"score": 0.002977419551510206, "phrase": "residual_code"}, {"score": 0.0029467742734417255, "phrase": "machine-code_synthesis"}, {"score": 0.0027126684113045756, "phrase": "different_positions"}, {"score": 0.00257586859792573, "phrase": "specialization-time_addresses"}, {"score": 0.002471400498582011, "phrase": "symbolic_state"}, {"score": 0.00226322835801988, "phrase": "commonly_used_inputs"}, {"score": 0.0022283519468680475, "phrase": "faster_binaries"}, {"score": 0.002137947680862631, "phrase": "executable_component"}, {"score": 0.0021049977753042253, "phrase": "bloated_binary"}], "paper_keywords": ["Partial evaluation", " machine code", " BTA", " specialization", " machine-code synthesis", " IA-32 instruction set"], "paper_abstract": "This paper presents an algorithm for off-line partial evaluation of machine code. The algorithm follows the classical two-phase approach of binding-time analysis (BTA) followed by specialization. However, machine-code partial evaluation presents a number of new challenges, and it was necessary to devise new techniques for use in each phase. Our BTA algorithm makes use of an instruction-rewriting method that \"decouples\" multiple updates performed by a single instruction. This method counters the cascading imprecision that would otherwise occur with a more naive approach to BTA. Our specializer specializes an explicit representation of the semantics of an instruction, and emits residual code via machine-code synthesis. Moreover, to create code that allows the stack and heap to be at different positions at run-time than at specialization-time, the specializer represents specialization-time addresses using symbolic constants, and uses a symbolic state for specialization. Our experiments show that our algorithm can be used to specialize binaries with respect to commonly used inputs to produce faster binaries, as well as to extract an executable component from a bloated binary.", "paper_title": "Partial Evaluation of Machine Code", "paper_id": "WOS:000367256500049"}