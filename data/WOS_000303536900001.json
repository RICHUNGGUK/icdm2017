{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "comparison_primitives"}, {"score": 0.0045411156682300695, "phrase": "asynchronous_multiprocessors"}, {"score": 0.004282787299993434, "phrase": "shared_memory"}, {"score": 0.003454687811707182, "phrase": "remote_memory_references"}, {"score": 0.0031741489723036255, "phrase": "distributed-shared-memory_models"}, {"score": 0.0021049977753042253, "phrase": "constant-factor_increase"}], "paper_keywords": ["Comparison primitives", " Consensus", " Load-linked/store-conditional", " Mutual exclusion", " Remote memory references", " Shared memory"], "paper_abstract": "We consider asynchronous multiprocessors where processes communicate only by reading or writing shared memory. We show how to implement consensus, compare-and-swap and other comparison primitives, as well as load-linked/store-conditional (LL/SC) using only a constant number of remote memory references (RMRs), in both the cache-coherent and the distributed-shared-memory models of such multiprocessors. Our implementations are blocking, rather than wait-free: they ensure progress provided all processes that invoke the implemented primitive are live. Our results imply that any algorithm using read and write operations, and either comparison primitives or LL/SC, can be simulated by an algorithm that uses read and write operations only, with at most a constant-factor increase in RMR complexity.", "paper_title": "RMR-efficient implementations of comparison primitives using read and write operations", "paper_id": "WOS:000303536900001"}