{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "program_analysis_probably_counts"}, {"score": 0.004758053266234474, "phrase": "semantics-based_program_analysis"}, {"score": 0.004483450050677258, "phrase": "run-time_properties"}, {"score": 0.004352123742308589, "phrase": "compiler_technology"}, {"score": 0.004224627834741731, "phrase": "constant_propagation"}, {"score": 0.004174677062711731, "phrase": "constant_folding_transformations"}, {"score": 0.004076533120753605, "phrase": "pointer_values"}, {"score": 0.004004436217742343, "phrase": "buffer_overruns"}, {"score": 0.003728529119516347, "phrase": "security_constraints"}, {"score": 0.003619235073669304, "phrase": "non-functional_properties"}, {"score": 0.0034715658596258018, "phrase": "worst_case_execution_times"}, {"score": 0.0034304883989739804, "phrase": "hard_real-time_applications"}, {"score": 0.0033497809969621267, "phrase": "classical_approaches"}, {"score": 0.003232254571848865, "phrase": "discrete_mathematics"}, {"score": 0.0030454408569868347, "phrase": "recent_moves"}, {"score": 0.002991524908432975, "phrase": "probabilistic_and_quantitative_methods"}, {"score": 0.00248718591918233, "phrase": "simple_information_flow_analysis"}, {"score": 0.002428617044669043, "phrase": "classical_approach"}, {"score": 0.002357337046408753, "phrase": "covert_information"}, {"score": 0.002315574871863272, "phrase": "timing_channels"}, {"score": 0.002234252028553481, "phrase": "classical_techniques"}, {"score": 0.0021049977753042253, "phrase": "probabilistic_techniques"}], "paper_keywords": ["program analysis", " semantics", " abstract interpretation"], "paper_abstract": "Semantics-based program analysis uses an abstract semantics of programs/systems to statically determine run-time properties. Classic examples from compiler technology include analyses to support constant propagation and constant folding transformations and estimation of pointer values to prevent buffer overruns. More recent examples include the estimation of information flows (to enforce security constraints) and estimation of non-functional properties such as timing (to determine worst case execution times in hard real-time applications). The classical approaches are based on semantics involving discrete mathematics. Paralleling trends in model-checking, there have been recent moves towards using probabilistic and quantitative methods in program analysis. In this paper we start by reviewing both classical and probabilistic/quantitative approaches to program analysis. We shall provide a comparison of the two approaches. We shall use a simple information flow analysis to exemplify the classical approach. The existence of covert information flows through timing channels are difficult to detect using classical techniques; we show how such problems can be addressed using probabilistic techniques.", "paper_title": "Program Analysis Probably Counts", "paper_id": "WOS:000279185400019"}