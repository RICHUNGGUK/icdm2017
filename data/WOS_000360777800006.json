{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "scalable_parallel_recursive_backtracking"}, {"score": 0.004669845451682529, "phrase": "increasingly_large_number"}, {"score": 0.004568871736067739, "phrase": "computational_power"}, {"score": 0.004278807087784626, "phrase": "serial_algorithms"}, {"score": 0.004095692768056685, "phrase": "computational_resources"}, {"score": 0.003818807671883534, "phrase": "limiting_factors"}, {"score": 0.0037361664435836845, "phrase": "communication_overhead_and_poor_load_balancing"}, {"score": 0.003687439449869248, "phrase": "np-hard_graph_problems"}, {"score": 0.003623453648863547, "phrase": "exact_algorithms"}, {"score": 0.003408091901859624, "phrase": "limited_success"}, {"score": 0.0033636292024305406, "phrase": "large_scale_parallelism"}, {"score": 0.0032621183241997777, "phrase": "recursive_backtracking"}, {"score": 0.0029110999689379497, "phrase": "minimal_communication_overhead"}, {"score": 0.002860546817196148, "phrase": "load-balancing_strategy"}, {"score": 0.002725994306480105, "phrase": "problem-specific_knowledge"}, {"score": 0.002690406375639144, "phrase": "key_idea"}, {"score": 0.0026091594819333654, "phrase": "efficient_traversal_operations"}, {"score": 0.0025750928944698673, "phrase": "indexed_search_tree"}, {"score": 0.0024218895273910943, "phrase": "parallel_implementations"}, {"score": 0.0023694065215394593, "phrase": "well-known_vertex_cover"}, {"score": 0.0023384629381463054, "phrase": "set_problems"}, {"score": 0.0023079225317714815, "phrase": "sufficiently_hard_instances"}, {"score": 0.002287783663138828, "phrase": "experimental_results"}, {"score": 0.0022678201262721323, "phrase": "nearly_linear_speedups"}, {"score": 0.0021993066642488237, "phrase": "running_times"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Parallel algorithms", " Recursive backtracking", " Load balancing", " Vertex cover", " Dominating set"], "paper_abstract": "Supercomputers are equipped with an increasingly large number of cores to use computational power as a way of solving problems that are otherwise intractable. Unfortunately, getting serial algorithms to run in parallel to take advantage of these computational resources remains a challenge for several application domains. Many parallel algorithms can scale to only hundreds of cores. The limiting factors of such algorithms are usually communication overhead and poor load balancing. Solving NP-hard graph problems to optimality using exact algorithms is an example of an area in which there has so far been limited success in obtaining large scale parallelism. Many of these algorithms use recursive backtracking as their core solution paradigm. In this paper, we propose a lightweight, easy-to-use, scalable approach for transforming almost any recursive backtracking algorithm into a parallel one. Our approach incurs minimal communication overhead and guarantees a load-balancing strategy that is implicit, i.e., does not require any problem-specific knowledge. The key idea behind our approach is the use of efficient traversal operations on an indexed search tree that is oblivious to the problem being solved. We test our approach with parallel implementations of algorithms for the well-known Vertex Cover and Dominating Set problems. On sufficiently hard instances, experimental results show nearly linear speedups for thousands of cores, reducing running times from days to just a few minutes. (C) 2015 Elsevier Inc. All rights reserved.", "paper_title": "On scalable parallel recursive backtracking", "paper_id": "WOS:000360777800006"}