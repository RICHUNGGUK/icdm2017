{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "lisp-like_multi-staged_languages"}, {"score": 0.004518442937844318, "phrase": "polymorphic_modal_type_system"}, {"score": 0.004064117897000019, "phrase": "lisp's_staging_constructs"}, {"score": 0.0033937776228549557, "phrase": "practical_higher-order"}, {"score": 0.0030847461428168614, "phrase": "lisp's_quasi-quotation_system"}, {"score": 0.0027741761880779535, "phrase": "multi-staged_programming_practices"}, {"score": 0.002603012037901889, "phrase": "open_code"}, {"score": 0.002548331088496964, "phrase": "unrestricted_operations"}, {"score": 0.0024423826953133844, "phrase": "intentional_variable-capturing_substitution"}, {"score": 0.0023408288327263316, "phrase": "capture-avoiding_substitution"}], "paper_keywords": ["multi-staged languages", " type systems", " polymorphic types", " modal types", " ML", " let-polymorphism", " quasi-quotation", " Lisp", " scheme", " record type", " type inference"], "paper_abstract": "This article presents a polymorphic modal type system and its principal type inference algorithm that conservatively extend ML by all of Lisp's staging constructs (the quasi-quotation system). The combination is meaningful because ML is a practical higher-order, impure, and typed language, while Lisp's quasi-quotation system has long evolved to comply with the demands from multi-staged programming practices. Our type system supports open code, unrestricted operations on references, intentional variable-capturing substitution as well as capture-avoiding substitution, and lifting values into code, whose combination escaped all the previous systems.", "paper_title": "A polymorphic modal type system for Lisp-like multi-staged languages", "paper_id": "WOS:000235615800024"}