{"auto_keywords": [{"score": 0.031811450897395364, "phrase": "windowed_pq-grams"}, {"score": 0.015719716506582538, "phrase": "approximate_joins"}, {"score": 0.014280947487053204, "phrase": "approximate_join"}, {"score": 0.013018422099508072, "phrase": "data-centric_xml"}, {"score": 0.0047804843375940835, "phrase": "data-centric_xml."}, {"score": 0.004746263721902197, "phrase": "data_integration_applications"}, {"score": 0.004215571179806372, "phrase": "xml_data"}, {"score": 0.004110831924517065, "phrase": "ordered_tree_matching_technique"}, {"score": 0.004023120753104693, "phrase": "edit_distance"}, {"score": 0.003909065355459264, "phrase": "sibling_order"}, {"score": 0.0036247638406450735, "phrase": "unordered_tree_matching_techniques"}, {"score": 0.0034467717443162015, "phrase": "predefined_sibling_order"}, {"score": 0.0032774911048411804, "phrase": "unordered_tree_matching"}, {"score": 0.0031277316566463978, "phrase": "small_subtrees"}, {"score": 0.0030941521409613417, "phrase": "specific_shape"}, {"score": 0.003038983069081333, "phrase": "efficient_technique"}, {"score": 0.0029740732099993706, "phrase": "three-step_process"}, {"score": 0.002889672003089062, "phrase": "sorted_tree"}, {"score": 0.0028689475587958917, "phrase": "dummy_nodes"}, {"score": 0.0028177825595998023, "phrase": "extended_tree"}, {"score": 0.0027675275077806744, "phrase": "windowed_pq-grams_distance"}, {"score": 0.0024664004864629724, "phrase": "unordered_tree_edit_distance"}, {"score": 0.0022950308685133224, "phrase": "costly_computation"}, {"score": 0.0022298571016688335, "phrase": "input_trees"}, {"score": 0.0021979660485319523, "phrase": "synthetic_and_real_world_data"}], "paper_keywords": ["Hierarchical data", " XML", " Unordered tree", " Tree distance", " Similarity join", " Approximate matching", " pq-Grams"], "paper_abstract": "In data integration applications, a join matches elements that are common to two data sources. Since elements are represented slightly different in each source, an approximate join must be used to do the matching. For XML data, most existing approximate join strategies are based on some ordered tree matching technique, such as the tree edit distance. In data-centric XML, however, the sibling order is irrelevant, and two elements should match even if their subelement order varies. Thus, approximate joins for data-centric XML must leverage unordered tree matching techniques. This is computationally hard since the algorithms cannot rely on a predefined sibling order. In this paper, we give a solution for approximate joins based on unordered tree matching. The core of our solution are windowed pq-grams which are small subtrees of a specific shape. We develop an efficient technique to generate windowed pq-grams in a three-step process: sort the tree, extend the sorted tree with dummy nodes, and decompose the extended tree into windowed pq-grams. The windowed pq-grams distance between two trees is the number of pq-grams that are in one tree decomposition only. We show that our distance is a pseudo-metric and empirically demonstrate that it effectively approximates the unordered tree edit distance. The approximate join using windowed pq-grams can be efficiently implemented as an equality join on strings, which avoids the costly computation of the distance between every pair of input trees. Experiments with synthetic and real world data confirm the analytic results and show the effectiveness and efficiency of our technique.", "paper_title": "Windowed pq-grams for approximate joins of data-centric XML", "paper_id": "WOS:000306510200002"}