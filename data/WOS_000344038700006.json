{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "jmseq"}, {"score": 0.004642732368562623, "phrase": "java"}, {"score": 0.004212453011596424, "phrase": "method_calls"}, {"score": 0.003964007795174772, "phrase": "simple_but_expressive_language"}, {"score": 0.003640516896245813, "phrase": "java_program"}, {"score": 0.003384262486955773, "phrase": "possibly_nested_method_calls"}, {"score": 0.002685558057339722, "phrase": "aspect-oriented_programming"}, {"score": 0.0025578967205807843, "phrase": "code_annotation"}, {"score": 0.002264607102799332, "phrase": "component-based_software_verification"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Object monitoring", " Runtime verification", " Method call sequence specification", " Code annotation", " Component-based testing"], "paper_abstract": "In this paper we introduce JMSeq, a Java-based tool for monitoring sequences of method calls. JMSeq provides a simple but expressive language to specify the observables of a Java program in terms of sequences of possibly nested method calls. Similar to many monitoring-oriented environments, verification in JMSeq is done at runtime; unlike all other approaches based on aspect-oriented programming, JMSeq uses code annotation rather than instrumentation, and therefore is suitable for component-based software verification. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Monitoring method call sequences using annotations", "paper_id": "WOS:000344038700006"}