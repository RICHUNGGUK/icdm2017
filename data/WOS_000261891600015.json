{"auto_keywords": [{"score": 0.009511743776646056, "phrase": "linear_time"}, {"score": 0.007845360064432825, "phrase": "dominators_problem"}, {"score": 0.00481495049065317, "phrase": "linear-time_algorithms"}, {"score": 0.0045355866228818514, "phrase": "classic_problem"}, {"score": 0.004124688058533477, "phrase": "linear-time_solutions"}, {"score": 0.0038309141193444015, "phrase": "path_compression"}, {"score": 0.0036467403626789666, "phrase": "random-access_table"}, {"score": 0.0035705347414368696, "phrase": "radix_sort"}, {"score": 0.003434922209075514, "phrase": "easily_managed_parts"}, {"score": 0.003316098012193133, "phrase": "nearest_common_ancestors"}, {"score": 0.003223995503078124, "phrase": "minimum_spanning_trees"}, {"score": 0.0030906010704382374, "phrase": "component_tree"}, {"score": 0.0030581212589623737, "phrase": "weighted_tree"}, {"score": 0.0029522931151878505, "phrase": "random-access_machine"}, {"score": 0.0028702659563021047, "phrase": "pointer_machine"}, {"score": 0.002761176640988626, "phrase": "subtle_error"}, {"score": 0.0027034263575471352, "phrase": "previous_allegedly_linear-time_algorithm"}, {"score": 0.0024408384127819734, "phrase": "systematic_study"}, {"score": 0.002242879896352752, "phrase": "resulting_methods"}, {"score": 0.0021049977753042253, "phrase": "exactly_how_earlier_approaches"}], "paper_keywords": ["dominators", " flowgraphs", " pointer machine", " random-access machine", " set union", " path compression", " nearest common ancestors", " minimum spanning trees", " interval analysis", " component tree", " data structures", " analysis of algorithms"], "paper_abstract": "We present linear-time algorithms for the classic problem of finding dominators in a flowgraph, and for several other problems whose solutions require evaluating a function defined on paths in a tree. Although all these problems had linear-time solutions previously, our algorithms are simpler, in some cases substantially. Our improvements come from three new ideas: a refined analysis of path compression that gives a linear bound if the compressions favor certain nodes; replacement of random-access table look-up by a radix sort; and a more careful partitioning of a tree into easily managed parts. In addition to finding dominators, our algorithms find nearest common ancestors off-line, verify and construct minimum spanning trees, do interval analysis of a flowgraph, and build the component tree of a weighted tree. Our algorithms do not require the power of a random-access machine; they run in linear time on a pointer machine. The genesis of our work was the discovery of a subtle error in the analysis of a previous allegedly linear-time algorithm for finding dominators. That algorithm was an attempt to simplify a more complicated algorithm, which itself was intended to correct errors in a yet earlier algorithm. Our work provides a systematic study of the subtleties in the dominators problem, the techniques needed to solve it in linear time, and the range of application of the resulting methods. We have tried to make our techniques as simple and as general as possible and to understand exactly how earlier approaches to the dominators problem were either incorrect or overly complicated.", "paper_title": "LINEAR-TIME ALGORITHMS FOR DOMINATORS AND OTHER PATH-EVALUATION PROBLEMS", "paper_id": "WOS:000261891600015"}