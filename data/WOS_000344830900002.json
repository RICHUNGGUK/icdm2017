{"auto_keywords": [{"score": 0.04791786215360241, "phrase": "maximum_parallelism"}, {"score": 0.04687100580934199, "phrase": "program_code_section"}, {"score": 0.03296712883817119, "phrase": "precedence_order"}, {"score": 0.00481495049065317, "phrase": "improved_concurrency"}, {"score": 0.0046834372388970405, "phrase": "transactional_memory_execution_model"}, {"score": 0.004555499634179394, "phrase": "sequential_and_multithreaded_programs"}, {"score": 0.0038756055612167942, "phrase": "specific_fully_distributed_commit_control"}, {"score": 0.003734979290204709, "phrase": "correct_parallel_execution"}, {"score": 0.003683565150278339, "phrase": "partial_precedence_order_relation"}, {"score": 0.0033274664434575136, "phrase": "precedence_order_relation"}, {"score": 0.0032364494905485677, "phrase": "best_policy"}, {"score": 0.002991823455621222, "phrase": "new_transactional_state"}, {"score": 0.00274017282519193, "phrase": "intrathread_concurrency"}, {"score": 0.0026651772919894534, "phrase": "uncommitted_transactions"}, {"score": 0.0025329623864528317, "phrase": "new_state"}, {"score": 0.0025096359514694523, "phrase": "interthread_concurrency"}, {"score": 0.002418453525649304, "phrase": "order_transaction"}, {"score": 0.0022878396720586044, "phrase": "lightweight_software_transactional_memory_system"}, {"score": 0.002266765479420981, "phrase": "tinystm"}, {"score": 0.0021344259291927914, "phrase": "important_performance_improvement"}, {"score": 0.0021049977753042253, "phrase": "baseline_tm_system"}], "paper_keywords": ["Design", " Experimentation", " Performance", " Transactional memory", " concurrency exploitation", " dependence analysis", " optimistic concurrency", " program parallelization"], "paper_abstract": "This article describes a transactional memory execution model intended to exploit maximum parallelism from sequential and multithreaded programs. A program code section is partitioned into chunks that will be mapped onto threads and executed transactionally. These transactions run concurrently and out of order, trying to exploit maximum parallelism but managed by a specific fully distributed commit control to meet data dependencies. To accomplish correct parallel execution, a partial precedence order relation is derived from the program code section and/or defined by the programmer. When a conflict between chunks is eagerly detected, the precedence order relation is used to determine the best policy to solve the conflict that preserves the precedence order while maximizing concurrency. The model defines a new transactional state called executed but not committed. This state allows exploiting concurrency on two levels: intrathread and interthread. Intrathread concurrency is improved by having pending uncommitted transactions while executing a new one in the same thread. The new state improves interthread concurrency because it permits out-of-order transaction commits regarding the precedence order. Our model has been implemented in a lightweight software transactional memory system, TinySTM, and has been evaluated on a set of benchmarks obtaining an important performance improvement over the baseline TM system.", "paper_title": "Effective Transactional Memory Execution Management for Improved Concurrency", "paper_id": "WOS:000344830900002"}