{"auto_keywords": [{"score": 0.0370524624129902, "phrase": "code_cloning_operation"}, {"score": 0.02060839048588832, "phrase": "code_clones"}, {"score": 0.008860741284534065, "phrase": "consistent_changes"}, {"score": 0.007226084873021279, "phrase": "consistency_maintenance"}, {"score": 0.00481495049065317, "phrase": "consistency-maintenance_requirement"}, {"score": 0.00475300265048496, "phrase": "copy-and-paste_time"}, {"score": 0.004655531868142323, "phrase": "double_edged_sword"}, {"score": 0.004631476648170177, "phrase": "software_development"}, {"score": 0.0045013675768375665, "phrase": "existing_code"}, {"score": 0.004443436195282021, "phrase": "coding_effort"}, {"score": 0.0042851472210540436, "phrase": "cloned_code_segments"}, {"score": 0.004219039749566144, "phrase": "extra_maintenance_effort"}, {"score": 0.004197230381955294, "phrase": "even_bugs"}, {"score": 0.003883246045707406, "phrase": "code_clone"}, {"score": 0.0037740768331370324, "phrase": "useful_recommendations"}, {"score": 0.003687034798751446, "phrase": "code_cloning_operations"}, {"score": 0.003601992968088131, "phrase": "future_consistency_maintenance_effort"}, {"score": 0.003393439115707876, "phrase": "software_evolution_history"}, {"score": 0.0033410419715175846, "phrase": "novel_approach"}, {"score": 0.0032470659868712895, "phrase": "time_point"}, {"score": 0.0032218966066768022, "phrase": "copy-and-paste_operations"}, {"score": 0.0029270094525230953, "phrase": "cloned_code"}, {"score": 0.0028520371267470573, "phrase": "bayesian_networks"}, {"score": 0.0027645938157002687, "phrase": "intended_code_cloning_operation"}, {"score": 0.00243442966458809, "phrase": "cloning_operations"}, {"score": 0.0023293259149436323, "phrase": "first_scenario"}, {"score": 0.002171623684222479, "phrase": "second_scenario"}], "paper_keywords": ["Code cloning", " consistency maintenance", " programming aid"], "paper_abstract": "Code clones have always been a double edged sword in software development. On one hand, it is a very convenient way to reuse existing code, and to save coding effort. On the other hand, since developers may need to ensure consistency among cloned code segments, code clones can lead to extra maintenance effort and even bugs. Recently studies on the evolution of code clones show that only some of the code clones experience consistent changes during their evolution history. Therefore, if we can accurately predict whether a code clone will experience consistent changes, we will be able to provide useful recommendations to developers on leveraging the convenience of some code cloning operations, while avoiding other code cloning operations to reduce future consistency maintenance effort. In this paper, we define a code cloning operation as consistency-maintenance-required if its generated code clones experience consistent changes in the software evolution history, and we propose a novel approach that automatically predicts whether a code cloning operation requires consistency maintenance at the time point of performing copy-and-paste operations. Our insight is that whether a code cloning operation requires consistency maintenance may relate to the characteristics of the code to be cloned and the characteristics of its context. Based on a number of attributes extracted from the cloned code and the context of the code cloning operation, we use Bayesian Networks, a machine-learning technique, to predict whether an intended code cloning operation requires consistency maintenance. We evaluated our approach on four subjects-two large-scale Microsoft software projects, and two popular open-source software projects-under two usage scenarios: 1) recommend developers to perform only the cloning operations predicted to be very likely to be consistency-maintenance-free, and 2) recommend developers to perform all cloning operations unless they are predicted very likely to be consistency-maintenance-required. In the first scenario, our approach is able to recommend developers to perform more than 50 percent cloning operations with a precision of at least 94 percent in the four subjects. In the second scenario, our approach is able to avoid 37 to 72 percent consistency-maintenance-required code clones by warning developers on only 13 to 40 percent code clones, in the four subjects.", "paper_title": "Predicting Consistency-Maintenance Requirement of Code Clones at Copy-and-Paste Time", "paper_id": "WOS:000343898400003"}