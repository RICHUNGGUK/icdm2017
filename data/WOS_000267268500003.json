{"auto_keywords": [{"score": 0.04598947580092753, "phrase": "long-latency_load"}, {"score": 0.00481495049065317, "phrase": "fetch_policies"}, {"score": 0.004744018246633455, "phrase": "multithreading_processors"}, {"score": 0.004582528208024817, "phrase": "simultaneous_multithreading"}, {"score": 0.00427578268550103, "phrase": "execution_resources"}, {"score": 0.00395017798595193, "phrase": "stalled_thread"}, {"score": 0.0038919354605673104, "phrase": "long-latency_loads"}, {"score": 0.0034901729647741353, "phrase": "allocated_resources"}, {"score": 0.003387998090859985, "phrase": "smt"}, {"score": 0.0032563083791198534, "phrase": "available_memory-level_parallelism"}, {"score": 0.003114283314285167, "phrase": "key_idea"}, {"score": 0.0029490571526071016, "phrase": "isolated_long-latency_load"}, {"score": 0.002710735995572145, "phrase": "additional_resources"}, {"score": 0.002278856202878812, "phrase": "available_mlp._mlp-aware_fetch_policies"}, {"score": 0.002223039450439376, "phrase": "mlp-intensive_threads"}, {"score": 0.002147180332779021, "phrase": "higher_overall_system_throughput"}, {"score": 0.0021259846592569386, "phrase": "shorter_average_turnaround_time"}, {"score": 0.0021049977753042253, "phrase": "previously_proposed_fetch_policies"}], "paper_keywords": ["Design", " Performance", " Experimentation", " Simultaneous Multithreading (SMT)", " Fetch Policy", " Memory-Level Parallelism (MLP)"], "paper_abstract": "A thread executing on a simultaneous multithreading (SMT) processor that experiences a long-latency load will eventually stall while holding execution resources. Existing long-latency load aware SMT fetch policies limit the amount of resources allocated by a stalled thread by identifying long-latency loads and preventing the thread from fetching more instructions-and in some implementations, instructions beyond the long-latency load are flushed to release allocated resources. This article proposes an SMT fetch policy that takes into account the available memory-level parallelism (MLP) in a thread. The key idea proposed in this article is that in case of an isolated long-latency load (i.e., there is no MLP), the thread should be prevented from allocating additional resources. However, in case multiple independent long-latency loads overlap (i.e., there is MLP), the thread should allocate as many resources as needed in order to fully expose the available MLP. MLP-aware fetch policies achieve better performance for MLP-intensive threads on SMT processors, leading to higher overall system throughput and shorter average turnaround time than previously proposed fetch policies.", "paper_title": "Memory-Level Parallelism Aware Fetch Policies for Simultaneous Multithreading Processors", "paper_id": "WOS:000267268500003"}