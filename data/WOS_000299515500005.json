{"auto_keywords": [{"score": 0.03608820096569275, "phrase": "ram"}, {"score": 0.00481495049065317, "phrase": "short_patterns"}, {"score": 0.004643594260262632, "phrase": "classical_approximate_string_matching_problem"}, {"score": 0.004256703909255889, "phrase": "error_threshold_k"}, {"score": 0.004135010810625326, "phrase": "ending_positions"}, {"score": 0.0036553070575015344, "phrase": "lengths_m"}, {"score": 0.0034491650585057754, "phrase": "standard_unit-cost_word"}, {"score": 0.002416589459425828, "phrase": "previously_best_known_time_bounds"}, {"score": 0.002230984431056064, "phrase": "novel_implementation"}, {"score": 0.002182881082103045, "phrase": "landau-vishkin_algorithm"}, {"score": 0.0021049977753042253, "phrase": "word-level_parallelism"}], "paper_keywords": ["Algorithms", " Approximate string matching", " Word level parallelism"], "paper_abstract": "We study the classical approximate string matching problem, that is, given strings P and Q and an error threshold k, find all ending positions of substrings of Q whose edit distance to P is at most k. Let P and Q have lengths m and n, respectively. On a standard unit-cost word RAM with word size w >= log n we present an algorithm using time O(nk . min(log(2) m/log n, log(2) m log w/w) + n) When P is short, namely, m = 2(o(root logn)) or m = 2(o(root w/logw) this improves the previously best known time bounds for the problem. The result is achieved using a novel implementation of the Landau-Vishkin algorithm based on tabulation and word-level parallelism.", "paper_title": "Faster Approximate String Matching for Short Patterns", "paper_id": "WOS:000299515500005"}