{"auto_keywords": [{"score": 0.03232541789808835, "phrase": "predicate_events"}, {"score": 0.013702142208420615, "phrase": "time_interval"}, {"score": 0.013447586106808004, "phrase": "event_stream"}, {"score": 0.011718160496039978, "phrase": "time_intervals"}, {"score": 0.007966228693282361, "phrase": "tree_structure"}, {"score": 0.00481495049065317, "phrase": "line_rule"}, {"score": 0.004769616966550469, "phrase": "event_prediction"}, {"score": 0.00469500313566324, "phrase": "future_events"}, {"score": 0.004665483918844599, "phrase": "great_importance"}, {"score": 0.004534917050845832, "phrase": "episode_rules"}, {"score": 0.0043527164193299574, "phrase": "episode_rule"}, {"score": 0.003922283019437895, "phrase": "specified_time_constraint"}, {"score": 0.0037409118365761894, "phrase": "consequent_event"}, {"score": 0.0032556926399045635, "phrase": "efficient_and_effective_event_predictor"}, {"score": 0.0031247264362609614, "phrase": "effective_scheme"}, {"score": 0.003027568488234868, "phrase": "redundant_time_intervals"}, {"score": 0.002824292971306322, "phrase": "efficient_matching"}, {"score": 0.002788823648033457, "phrase": "event_streams"}, {"score": 0.0027364508381415866, "phrase": "forward_retrieval"}, {"score": 0.0027106334164712057, "phrase": "queue_structure"}, {"score": 0.0026513335370556474, "phrase": "matched_results"}, {"score": 0.002576988153314685, "phrase": "backward_scans"}, {"score": 0.002473256335879102, "phrase": "backward_retrieval"}, {"score": 0.002449915958738505, "phrase": "recently_arrived_events"}, {"score": 0.0023587312574818208, "phrase": "identifiable_events"}, {"score": 0.002321744299010337, "phrase": "efficient_retrieval"}, {"score": 0.0022709326810964386, "phrase": "exhaustive_scans"}, {"score": 0.0022494973475924024, "phrase": "arrived_events"}, {"score": 0.0021453112313233554, "phrase": "proposed_approaches"}, {"score": 0.0021183508914633478, "phrase": "particular_data_distributions"}, {"score": 0.0021049977753042253, "phrase": "parameter_settings"}], "paper_keywords": ["Continuous query", " Episode rules", " Minimal occurrence", " Event stream", " Prediction"], "paper_abstract": "The prediction of future events has great importance in many applications. The prediction is based on episode rules which are composed of events and two time constraints which require all the events in the episode rule and in the predicate of the rule to occur in a time interval, respectively. In an event stream, a sequence of events which matches the predicate of the rule satisfying the specified time constraint is called an occurrence of the predicate. After finding the occurrence, the consequent event which will occur in a time interval can be predicted. However, the time intervals computed from some occurrences for predicting the event can be contained in the time intervals computed from other occurrence and become redundant. As a result, how to design an efficient and effective event predictor in a stream environment is challenging. In this paper, an effective scheme is proposed to avoid matching the predicate events corresponding to redundant time intervals for prediction. Based on the scheme, we respectively consider two methodologies, forward retrieval and backward retrieval, for the efficient matching of predicate events over event streams. The approach based on forward retrieval construct a queue structure to incrementally maintain parts of the matched results as events arrive, and thus it avoids backward scans of the event stream. On the other hand, the approach based on backward retrieval maintains the recently arrived events in a tree structure. The matching of predicate events is triggered by identifiable events and achieved by an efficient retrieval on the tree structure, which avoids exhaustive scans of the arrived events. By running a series of experiments, we show that each of the proposed approaches has its advantages on particular data distributions and parameter settings.", "paper_title": "On-line rule matching for event prediction", "paper_id": "WOS:000290802400001"}