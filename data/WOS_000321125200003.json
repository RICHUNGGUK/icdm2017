{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "polychronous_programs"}, {"score": 0.040280228365713704, "phrase": "synchronous_programs"}, {"score": 0.00475924837336259, "phrase": "synchronous_ones"}, {"score": 0.0042859292226559535, "phrase": "different_models"}, {"score": 0.003950453462399077, "phrase": "compilation_techniques"}, {"score": 0.003619993477999133, "phrase": "underlying_paradigms"}, {"score": 0.0034551632687788857, "phrase": "synchronous_systems"}, {"score": 0.003336468343971626, "phrase": "discrete_steps"}, {"score": 0.0031845067058084583, "phrase": "reactive_systems"}, {"score": 0.003129317057177867, "phrase": "totally_ordered_notion"}, {"score": 0.0030042210975126616, "phrase": "polychronous_system_models"}, {"score": 0.002952146666681891, "phrase": "partially_ordered_notion"}, {"score": 0.002720785798036066, "phrase": "asynchronous_environment"}, {"score": 0.0026119782818898193, "phrase": "deterministic_controller"}, {"score": 0.0024784363584530976, "phrase": "particular_examples"}, {"score": 0.002435453488008121, "phrase": "mentioned_cross_fertilization"}, {"score": 0.002310915790114425, "phrase": "verification_backend"}, {"score": 0.002205560249972527, "phrase": "polychronous_specifications"}, {"score": 0.002142161017595363, "phrase": "first_step"}, {"score": 0.0021049977753042253, "phrase": "heterogeneous_models"}], "paper_keywords": ["Model-driven embedded software", " synchronous programming", " polychronous programming", " programming models", " synchrony hypothesis", " synchronous guarded commands"], "paper_abstract": "This paper presents an embedding of polychronous programs into synchronous ones. Due to this embedding, it is not only possible to deepen the understanding of these different models of computation, but, more importantly, it is possible to transfer compilation techniques that were developed for synchronous programs to polychronous programs. This transfer is nontrivial because the underlying paradigms differ more than their names suggest: Since synchronous systems react deterministically to given inputs in discrete steps, they are typically used to describe reactive systems with a totally ordered notion of time. In contrast, polychronous system models entail a partially ordered notion of time, and are most suited to interface a system with an asynchronous environment by specifying input/output constraints from which a deterministic controller may eventually be refined and synthesized. As particular examples for the mentioned cross fertilization, we show how a simulator and a verification backend for synchronous programs can be made available to polychronous specifications, which is a first step toward integrating heterogeneous models of computation.", "paper_title": "Embedding Polychrony into Synchrony", "paper_id": "WOS:000321125200003"}