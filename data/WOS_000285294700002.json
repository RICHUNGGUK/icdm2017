{"auto_keywords": [{"score": 0.048636009815037955, "phrase": "just-in-time_compilers"}, {"score": 0.00481495049065317, "phrase": "efficient_interpretation"}, {"score": 0.0034911335714333507, "phrase": "existing_just-in-time_compilation_infrastructures"}, {"score": 0.0030414140732789186, "phrase": "optimizing_interpreters"}, {"score": 0.0027955219242123013, "phrase": "dynamic_translation_system"}, {"score": 0.002731971103291716, "phrase": "\"ultima_ratio"}, {"score": 0.002629238854352447, "phrase": "programming_languages"}, {"score": 0.00254983442025512, "phrase": "optimization_techniques"}, {"score": 0.0023798115577749225, "phrase": "just-in-time_compilation"}, {"score": 0.002290291401956985, "phrase": "ease-of-implementation_characteristic"}, {"score": 0.0021049977753042253, "phrase": "first_place"}], "paper_keywords": ["Design", " Languages", " Performance", " Python", " interpreter", " quickening", " reference counting", " instruction format"], "paper_abstract": "Just-in-time compilers offer the biggest achievable payoff performance-wise, but their implementation is a non-trivial, time-consuming task-affecting the interpreter's maintenance for years to come, too. Recent research addresses this issue by providing ways of leveraging existing just-in-time compilation infrastructures. Though there has been considerable research on improving the efficiency of just-in-time compilers, the area of optimizing interpreters has gotten less attention-as if the implementation of a dynamic translation system was the \"ultima ratio\" for efficiently interpreting programming languages. We present optimization techniques for improving the efficiency of interpreters without requiring just-in-time compilation-thereby maintaining the ease-of-implementation characteristic that brought many people to implementing an interpreter in the first place.", "paper_title": "Efficient Interpretation using Quickening", "paper_id": "WOS:000285294700002"}