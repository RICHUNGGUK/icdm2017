{"auto_keywords": [{"score": 0.01834412767885476, "phrase": "primary_keys"}, {"score": 0.010413421958101172, "phrase": "modern_applications"}, {"score": 0.0093301444509013, "phrase": "null_columns"}, {"score": 0.008139543129549287, "phrase": "possible_and_certain_keys"}, {"score": 0.00481495049065317, "phrase": "relational_model"}, {"score": 0.004530371221172796, "phrase": "fundamental_notion"}, {"score": 0.004444921827311577, "phrase": "relational_databases"}, {"score": 0.004411206380636782, "phrase": "nulls"}, {"score": 0.004361077072629878, "phrase": "sql_database_systems"}, {"score": 0.00434449804021954, "phrase": "primary_key_columns"}, {"score": 0.0041662189933067, "phrase": "unique_constraints"}, {"score": 0.003995226376780718, "phrase": "null_markers"}, {"score": 0.0038166522763373434, "phrase": "different_function"}, {"score": 0.003536526698282596, "phrase": "possible_worlds"}, {"score": 0.003456554957885269, "phrase": "sql_table"}, {"score": 0.003404244237372396, "phrase": "possible_keys"}, {"score": 0.003352722512047951, "phrase": "unique_constraint"}, {"score": 0.0033272782363384375, "phrase": "sql"}, {"score": 0.003190584226787897, "phrase": "sql_standard"}, {"score": 0.003036263091666092, "phrase": "sufficient_and_necessary_condition"}, {"score": 0.0028347983387988847, "phrase": "basic_characterization"}, {"score": 0.0027812405653371503, "phrase": "simple_discovery_approaches"}, {"score": 0.00266693888510356, "phrase": "armstrong_tables"}, {"score": 0.002616544154458438, "phrase": "indexing_scheme"}, {"score": 0.0024804352736263005, "phrase": "real-world_databases"}, {"score": 0.0024428607154967806, "phrase": "related_computational_problems"}, {"score": 0.0022894012453842064, "phrase": "data_quality"}, {"score": 0.002246124435189668, "phrase": "codd's_entity_integrity"}, {"score": 0.0021211305348270413, "phrase": "incomplete_data"}, {"score": 0.0021049977753042253, "phrase": "different_formats"}], "paper_keywords": [""], "paper_abstract": "Driven by the dominance of the relational model, the requirements of modern applications, and the veracity of data, we revisit the fundamental notion of a key in relational databases with NULLs. In SQL database systems primary key columns are NOT NULL by default. NULL columns may occur in unique constraints which only guarantee uniqueness for tuples which do not feature null markers in any of the columns involved, and therefore serve a different function than primary keys. We investigate the notions of possible and certain keys, which are keys that hold in some or all possible worlds that can originate from an SQL table, respectively. Possible keys coincide with the unique constraint of SQL, and thus provide a semantics for their syntactic definition in the SQL standard. Certain keys extend primary keys to include NULL columns, and thus form a sufficient and necessary condition to identify tuples uniquely, while primary keys are only sufficient for that purpose. In addition to basic characterization, axiomatization, and simple discovery approaches for possible and certain keys, we investigate the existence and construction of Armstrong tables, and describe an indexing scheme for enforcing certain keys. Our experiments show that certain keys with NULLs do occur in real-world databases, and that related computational problems can be solved efficiently. Certain keys are therefore semantically well-founded and able to maintain data quality in the form of Codd's entity integrity rule while handling the requirements of modern applications, that is, higher volumes of incomplete data from different formats.", "paper_title": "Possible and Certain SQL Keys", "paper_id": "WOS:000362283300001"}