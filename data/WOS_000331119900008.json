{"auto_keywords": [{"score": 0.039883608566730115, "phrase": "dependent_types"}, {"score": 0.039299987230067404, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "dependently_typed_haskell_programming"}, {"score": 0.004741845603430361, "phrase": "haskell's_type_system"}, {"score": 0.004227653047394939, "phrase": "dependently_typed_programming"}, {"score": 0.0035997452281985465, "phrase": "new_ones"}, {"score": 0.003438058620195309, "phrase": "extended_examples"}, {"score": 0.003088384809415812, "phrase": "haskell's_constraint_solver"}, {"score": 0.003018196463874475, "phrase": "theorem_prover"}, {"score": 0.002860546817196148, "phrase": "agda_programmers"}, {"score": 0.0024918548761791435, "phrase": "dependent_function_space"}, {"score": 0.0022041312401435346, "phrase": "evolving_language_design"}, {"score": 0.0021049977753042253, "phrase": "dependently_typed_languages"}], "paper_keywords": ["dependent types", " singletons", " data type promotion", " proof search", " invariants"], "paper_abstract": "Haskell's type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples-merge-sort and rectangular tilings-we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.", "paper_title": "Hasochism The Pleasure and Pain of Dependently Typed Haskell Programming", "paper_id": "WOS:000331119900008"}