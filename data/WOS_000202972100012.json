{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "interleaved_data"}, {"score": 0.0047468516620285525, "phrase": "simd._most_implementations"}, {"score": 0.004613541815868266, "phrase": "simd"}, {"score": 0.004389089062127892, "phrase": "data_elements"}, {"score": 0.004265760046406154, "phrase": "vector_registers"}, {"score": 0.004145882022189891, "phrase": "disjoint_vector_elements"}, {"score": 0.003944112858235306, "phrase": "explicit_data_reorganization_manipulations"}, {"score": 0.0035949949979695063, "phrase": "important_applications"}, {"score": 0.003419943984098415, "phrase": "simd_instructions"}, {"score": 0.003094920033010818, "phrase": "ambitious_challenge"}, {"score": 0.002986461855862617, "phrase": "vectorizing_compilers"}, {"score": 0.002881793492919646, "phrase": "automatic_compilation_scheme"}, {"score": 0.0028207566216121856, "phrase": "effective_vectorization"}, {"score": 0.002683304054823427, "phrase": "constant_strides"}, {"score": 0.0025343769150179764, "phrase": "data_reorganization"}, {"score": 0.0023936956017015696, "phrase": "dominant_simd_architectures"}, {"score": 0.002342972434255588, "phrase": "present_experimental_results"}, {"score": 0.0022933216359142736, "phrase": "wide_range"}, {"score": 0.0022608057001451414, "phrase": "key_kernels"}, {"score": 0.002181514206602054, "phrase": "execution_time"}, {"score": 0.0021049977753042253, "phrase": "interleaving_levels"}], "paper_keywords": ["performance", " algorithms", " SIMD", " vectorization", " subword parallelism", " data reuse", " Viterbi"], "paper_abstract": "Most implementations of the Single Instruction Multiple Data (SIMD) model available today require that data elements be packed in vector registers. Operations on disjoint vector elements are not supported directly and require explicit data reorganization manipulations. Computations on non-contiguous and especially interleaved data appear in important applications, which can greatly benefit from SIMD instructions once the data is reorganized properly. Vectorizing such computations efficiently is therefore an ambitious challenge for both programmers and vectorizing compilers. We demonstrate an automatic compilation scheme that supports effective vectorization in the presence of interleaved data with constant strides that are powers of 2, facilitating data reorganization. We demonstrate how our vectorization scheme applies to dominant SIMD architectures, and present experimental results on a wide range of key kernels, showing speedups in execution time up to 3.7 for interleaving levels (stride) as high as 8.", "paper_title": "Auto-vectorization of interleaved data for SIMD", "paper_id": "WOS:000202972100012"}