{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "heap-manipulating_code"}, {"score": 0.00475070135279933, "phrase": "chalice"}, {"score": 0.004687305496643216, "phrase": "stepwise_refinement"}, {"score": 0.004593787100061613, "phrase": "well-studied_technique"}, {"score": 0.004382737590042589, "phrase": "abstract_description"}, {"score": 0.004295269532032448, "phrase": "concrete_implementation"}, {"score": 0.00407042677958844, "phrase": "automated_tool_support"}, {"score": 0.0038833278847237858, "phrase": "state-of-the-art_verification_engine"}, {"score": 0.003679969180334367, "phrase": "previous_refinement_systems"}, {"score": 0.003558294449586273, "phrase": "presented_system"}, {"score": 0.0033946556965877873, "phrase": "programming_language"}, {"score": 0.003131393466870228, "phrase": "dynamically_allocated_objects"}, {"score": 0.0029873281676201565, "phrase": "data_representations"}, {"score": 0.002927626967420519, "phrase": "abstract_program"}, {"score": 0.0025935941070969575, "phrase": "familiar_imperative_features"}, {"score": 0.002541741549046619, "phrase": "sequential_composition"}, {"score": 0.002297585503415527, "phrase": "program_changes"}, {"score": 0.0021049977753042253, "phrase": "non-deterministic_programs"}], "paper_keywords": ["Stepwise refinement", " Data refinement", " Heap refinement", " Chalice", " Abstract predicates", " Fractional permissions", " Program verification"], "paper_abstract": "Stepwise refinement is a well-studied technique for developing a program from an abstract description to a concrete implementation. This paper describes a system with automated tool support for refinement, powered by a state-of-the-art verification engine that uses an SMT solver. Unlike previous refinement systems, users of the presented system interact only via declarations in the programming language. Another aspect of the system is that it accounts for dynamically allocated objects in the heap, so that data representations in an abstract program can be refined into ones that use more objects. Finally, the system uses a language with familiar imperative features, including sequential composition, loops, and recursive calls, offers a syntax with skeletons for describing program changes between refinements, and provides a mechanism for supplying witnesses when refining non-deterministic programs.", "paper_title": "Stepwise refinement of heap-manipulating code in Chalice", "paper_id": "WOS:000305830700007"}