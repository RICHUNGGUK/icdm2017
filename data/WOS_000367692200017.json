{"auto_keywords": [{"score": 0.05007852962010534, "phrase": "partial_functions"}, {"score": 0.004745665541429529, "phrase": "constraint_logic_programming"}, {"score": 0.004543708337879809, "phrase": "common_abstractions"}, {"score": 0.004478308876320956, "phrase": "formal_specification_notations"}, {"score": 0.004256777116204984, "phrase": "alloy"}, {"score": 0.004135010810625326, "phrase": "executable_programming_languages"}, {"score": 0.0036553070575015344, "phrase": "primitive_feature"}, {"score": 0.003115908199991072, "phrase": "first-class_citizens"}, {"score": 0.002897710777957041, "phrase": "set-theoretic_formulas"}, {"score": 0.0023817332409567403, "phrase": "new_primitive_constraints"}, {"score": 0.0022472527731744974, "phrase": "new_version"}, {"score": 0.0021049977753042253, "phrase": "non-trivial_set-theoretical_goals"}], "paper_keywords": ["CLP", " {log}", " set theory", " partial functions"], "paper_abstract": "Partial functions are common abstractions in formal specification notations such as Z, B and Alloy. Conversely, executable programming languages usually provide little or no support for them. In this paper we propose to add partial functions as a primitive feature to a Constraint Logic Programming (CLP) language, namely {log}. Although partial functions could be programmed on top of {log}, providing them as first-class citizens adds valuable flexibility and generality to the form of set-theoretic formulas that the language can safely deal with. In particular, the paper shows how the {log} constraint solver is naturally extended in order to accommodate for the new primitive constraints dealing with partial functions. Efficiency of the new version is empirically assessed by running a number of non-trivial set-theoretical goals involving partial functions, obtained from specifications written in Z.", "paper_title": "Adding partial functions to Constraint Logic Programming with sets", "paper_id": "WOS:000367692200017"}