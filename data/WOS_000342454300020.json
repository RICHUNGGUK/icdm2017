{"auto_keywords": [{"score": 0.03803555857487162, "phrase": "register_file_assignment"}, {"score": 0.029264273123224487, "phrase": "spifr_method"}, {"score": 0.00481495049065317, "phrase": "spilling-friendly_register_file_assignment"}, {"score": 0.004679406537319203, "phrase": "distributed"}, {"score": 0.004640929126263433, "phrase": "file_architectures"}, {"score": 0.004565609517511076, "phrase": "multiple_sets"}, {"score": 0.004436716583179764, "phrase": "register_files"}, {"score": 0.004206879557938045, "phrase": "register_allocation"}, {"score": 0.0041725881174377345, "phrase": "high_register_pressure"}, {"score": 0.003813269577615793, "phrase": "performance_decline"}, {"score": 0.0036753171449945654, "phrase": "high_pressure"}, {"score": 0.0036453427552753533, "phrase": "improper_register_file_assignment"}, {"score": 0.0035278613436978933, "phrase": "virtual_registers"}, {"score": 0.003428164458163043, "phrase": "communication_costs"}, {"score": 0.0030944828434567966, "phrase": "spilling_cost"}, {"score": 0.002970260970134645, "phrase": "mibench_and_eembc_benchmarks"}, {"score": 0.0028627183712016894, "phrase": "cycle-accurate_instruction_set_simulator"}, {"score": 0.002827741128550955, "phrase": "mibench"}, {"score": 0.002510843167476253, "phrase": "average_cycle"}, {"score": 0.0024398167078355224, "phrase": "average_spilling_ratio"}, {"score": 0.0023610946923597405, "phrase": "eembc_benchmarks"}, {"score": 0.002256973121326987, "phrase": "average_speedup"}, {"score": 0.0022111720236287547, "phrase": "speedup_average"}, {"score": 0.002184137736856711, "phrase": "kernel_functions"}, {"score": 0.002131054594847684, "phrase": "average_reduction"}, {"score": 0.0021049977753042253, "phrase": "spilling_ratio"}], "paper_keywords": ["Spilling", " Register file assignment", " Register allocation", " DSP", " VLIW"], "paper_abstract": "Distributed register file architectures divide registers into multiple sets, and it follows that the register files could be small. This can increase the frequency of spilling if register allocation encounters high register pressure, which will reduce the performance. That is, there is extra spilling to handle the pressure and results in performance decline. One of the factors that can produce high pressure is improper register file assignment. Register file assignment is a phase that assigns virtual registers to suitable register files and avoids communication costs. To reduce spilling in the phase of register file assignment, this paper proposes the SPIlling-FRiendly (SPIFR) method, which attempts to improve spilling by estimating the spilling cost from two aspects: assignment and spilling. We used MiBench and EEMBC benchmarks in experiments performed with the Open64-based compiler and a cycle-accurate instruction set simulator. The MiBench experimental results show that the SPIFR method improved the average cycle counts of the benchmarks by 6.0 %. For the kernels of the benchmarks, the method improved the average cycle counts by 20.5 % and reduced the average spilling ratio by 19.0 %. The results on the EEMBC benchmarks indicate that the method improved the cycle counts with the average speedup of 7.0 %, the speedup average of the kernel functions was 11.3 %, and the average reduction in the spilling ratio was 11.7 %, respectively. We conclude that the SPIFR method can reduce spilling and increase the performance.", "paper_title": "Achieving spilling-friendly register file assignment for highly distributed register files", "paper_id": "WOS:000342454300020"}