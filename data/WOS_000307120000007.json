{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "atomicity-violation_bugs"}, {"score": 0.008389673210921147, "phrase": "concurrent_programs"}, {"score": 0.004762893197005439, "phrase": "unserializable_interleaving_testing"}, {"score": 0.004745629779492866, "phrase": "ctrigger"}, {"score": 0.0047113960612140335, "phrase": "multicore_hardware"}, {"score": 0.004342430078306461, "phrase": "different_types"}, {"score": 0.004295459433506106, "phrase": "concurrency_bugs"}, {"score": 0.0042489946866108895, "phrase": "atomicity_violations"}, {"score": 0.004024072318264299, "phrase": "interleaving_space"}, {"score": 0.0038948525410795517, "phrase": "open_problem"}, {"score": 0.0038178995533949176, "phrase": "stress_testing"}, {"score": 0.0034180189629740426, "phrase": "coverage_criterion"}, {"score": 0.002934764205541183, "phrase": "common_practice"}, {"score": 0.002779217021776702, "phrase": "unserializable_interleaving_coverage"}, {"score": 0.002646267286675984, "phrase": "unserializable_interleaving_coverage_criterion"}, {"score": 0.0025892330566358503, "phrase": "trace_analysis"}, {"score": 0.0025472634689904772, "phrase": "feasible_unserializable_interleavings"}, {"score": 0.0024788167298469455, "phrase": "low-probability_interleavings"}, {"score": 0.0023602032679095955, "phrase": "real-world_atomicity-violation_bugs"}], "paper_keywords": ["Testing and debugging", " debugging aids", " diagnostics", " testing strategies", " test coverage of code", " concurrent programming", " bug characteristics"], "paper_abstract": "Multicore hardware is making concurrent programs pervasive. Unfortunately, concurrent programs are prone to bugs. Among different types of concurrency bugs, atomicity violations are common and important. How to test the interleaving space and expose atomicity-violation bugs is an open problem. This paper makes three contributions. First, it designs and evaluates a hierarchy of four interleaving coverage criteria using 105 real-world concurrency bugs. This study finds a coverage criterion (Unserializable Interleaving Coverage) that balances the complexity and the capability of exposing atomicity-violation bugs well. Second, it studies stress testing to understand why this common practice cannot effectively expose atomicity-violation bugs from the perspective of unserializable interleaving coverage. Third, it designs CTrigger following the unserializable interleaving coverage criterion. CTrigger uses trace analysis to identify feasible unserializable interleavings, and then exercises low-probability interleavings to expose atomicity-violation bugs. We evaluate CTrigger with real-world atomicity-violation bugs from seven applications. CTrigger efficiently exposes these bugs within 1-235 seconds, two to four orders of magnitude faster than stress testing. Without CTrigger, some of these bugs do not manifest even after seven days of stress testing. Furthermore, once a bug is exposed, CTrigger can reliably reproduce it, usually within 5 seconds, for diagnosis.", "paper_title": "Finding Atomicity-Violation Bugs through Unserializable Interleaving Testing", "paper_id": "WOS:000307120000007"}