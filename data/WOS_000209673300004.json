{"auto_keywords": [{"score": 0.040639063427152566, "phrase": "reachability_properties"}, {"score": 0.04020394874646987, "phrase": "behavioral_properties"}, {"score": 0.029207532255041337, "phrase": "computed_states"}, {"score": 0.027961740081157146, "phrase": "state_transition_graph"}, {"score": 0.00481495049065317, "phrase": "static_analysis"}, {"score": 0.004761494044422926, "phrase": "state_transition_graphs"}, {"score": 0.00465634671242413, "phrase": "event-condition-action_systems"}, {"score": 0.004027031316965272, "phrase": "structurally_complex_systems"}, {"score": 0.0034245614958572012, "phrase": "execution_paths"}, {"score": 0.003311604528903634, "phrase": "linear_temporal_logic_formulas"}, {"score": 0.0031140747752837826, "phrase": "finite_state_space"}, {"score": 0.0030282147475402736, "phrase": "symbolic_analysis"}, {"score": 0.002977835845437357, "phrase": "exhaustive_state_space_exploration"}, {"score": 0.002722930209707764, "phrase": "run-time_behavior"}, {"score": 0.0025178072071268534, "phrase": "ltl_verifier"}, {"score": 0.0024346858809238766, "phrase": "different_impact"}, {"score": 0.0022261705957258506, "phrase": "memory_consumption"}, {"score": 0.0022013916728990564, "phrase": "subsequent_phases"}, {"score": 0.0021406417439887907, "phrase": "different_analysis_variants"}, {"score": 0.0021049977753042253, "phrase": "rers_benchmarks"}], "paper_keywords": ["Program Analysis", " Model Checking", " Verification", " Event-Condition-Action System"], "paper_abstract": "We present a combination of approaches for the verification of event-condition-action (ECA) systems. The analyzed ECA systems range from structurally simple to structurally complex systems. We address the verification of reachability properties and behavioral properties. Reachability properties are represented by assertions in the program and we determine statically whether an assertion holds for all execution paths. Behavioral properties are represented as linear temporal logic formulas specifying the input/output behavior of the program. Our approach assumes a finite state space. We compare a symbolic analysis with an exhaustive state space exploration and discuss the trade-offs between the approaches in terms of the number of computed states and run-time behavior. All variants compute a state transition graph which can also be passed to an LTL verifier. The variants have a different impact on the number of computed states in the state transition graph which in turn impacts the run-time and memory consumption of subsequent phases. We evaluate the different analysis variants with the RERS benchmarks.", "paper_title": "Combining static analysis and state transition graphs for verification of event-condition-action systems in the RERS 2012 and 2013 challenges", "paper_id": "WOS:000209673300004"}