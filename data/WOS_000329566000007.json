{"auto_keywords": [{"score": 0.04871683326767197, "phrase": "ctl"}, {"score": 0.007101054894514313, "phrase": "satisfiability_problem"}, {"score": 0.00481495049065317, "phrase": "satisfiability_games_for_branching-time_logics."}, {"score": 0.004577777897335174, "phrase": "important_applications"}, {"score": 0.004544859094594241, "phrase": "program_specification"}, {"score": 0.004305364955542171, "phrase": "doubly_exponential_time"}, {"score": 0.004213123914295882, "phrase": "single_exponential_time"}, {"score": 0.0041677440361312604, "phrase": "decision_procedures"}, {"score": 0.004034504342397309, "phrase": "tree_automata"}, {"score": 0.003976656675903324, "phrase": "axiom_systems"}, {"score": 0.0038634281440398355, "phrase": "uniform_game-theoretic_framework"}, {"score": 0.003766991006640731, "phrase": "branching-time_temporal_logics"}, {"score": 0.003764420082051926, "phrase": "input_formula"}, {"score": 0.003712964709503484, "phrase": "satisfiability_games"}, {"score": 0.0036729522133392175, "phrase": "full_branching-time_temporal_logic_ctl"}, {"score": 0.0035683401689358993, "phrase": "winning_condition"}, {"score": 0.0034666972896389777, "phrase": "least_fixpoint_unfoldings"}, {"score": 0.0034293295415901807, "phrase": "winning_conditions"}, {"score": 0.0034046409849387365, "phrase": "formal_languages"}, {"score": 0.0029893477597041493, "phrase": "buchi_games"}, {"score": 0.0029571101238632783, "phrase": "worst-case_complexity"}, {"score": 0.0029252191241632888, "phrase": "obtained_algorithms"}, {"score": 0.0028936710552719806, "phrase": "known_lower_bounds"}, {"score": 0.0027708353425467927, "phrase": "complexity-theoretically_optimal_treatment"}, {"score": 0.002643624979574088, "phrase": "temporal_logic_machinery"}, {"score": 0.002558985036330194, "phrase": "syntactical_relationship"}, {"score": 0.0023890733439136586, "phrase": "buchi_game"}, {"score": 0.0023125643872311994, "phrase": "fischer-ladner_closure"}, {"score": 0.002143416464171068, "phrase": "tool_support"}, {"score": 0.0021049977753042253, "phrase": "complex_branching-time_logics"}], "paper_keywords": ["temporal logic", " automata", " parity games", " decidability"], "paper_abstract": "The satisfiability problem for branching-time temporal logics like CTL , CTL and CTL + has important applications in program specification and verification. Their computational complexities are known: CTL and CTL + are complete for doubly exponential time, CTL is complete for single exponential time. Some decision procedures for these logics are known; they use tree automata, tableaux or axiom systems. In this paper we present a uniform game-theoretic framework for the satisfiability problem of these branching-time temporal logics. We define satisfiability games for the full branching-time temporal logic CTL using a high-level definition of winning condition that captures the essence of well-foundedness of least fixpoint unfoldings. These winning conditions form formal languages of ! -words. We analyse which kinds of deterministic ! -automata are needed in which case in order to recognise these languages. We then obtain a reduction to the problem of solving parity or Buchi games. The worst-case complexity of the obtained algorithms matches the known lower bounds for these logics. This approach provides a uniform, yet complexity-theoretically optimal treatment of satisfiability for branching-time temporal logics. It separates the use of temporal logic machinery from the use of automata thus preserving a syntactical relationship between the input formula and the object that represents satisfiability, i.e. a winning strategy in a parity or Buchi game. The games presented here work on a Fischer-Ladner closure of the input formula only. Last but not least, the games presented here come with an attempt at providing tool support for the satisfiability problem of complex branching-time logics like CTL and CTL", "paper_title": "SATISFIABILITY GAMES FOR BRANCHING-TIME LOGICS", "paper_id": "WOS:000329566000007"}