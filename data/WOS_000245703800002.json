{"auto_keywords": [{"score": 0.04290345039043387, "phrase": "integral_host"}, {"score": 0.04134567426628143, "phrase": "partial_inlining"}, {"score": 0.00907272692400313, "phrase": "hot_function"}, {"score": 0.00481495049065317, "phrase": "frequently_invoked_large_functions"}, {"score": 0.0047415081747150065, "phrase": "non-numeric_applications"}, {"score": 0.004687159050154687, "phrase": "large_functions"}, {"score": 0.004615656893404919, "phrase": "modern_compilers"}, {"score": 0.004441616106463486, "phrase": "compilation_time"}, {"score": 0.004257708925521277, "phrase": "function_inlining"}, {"score": 0.004208881856146758, "phrase": "large_portions"}, {"score": 0.0038973170902076707, "phrase": "natural_solution"}, {"score": 0.0037937873032347, "phrase": "cold_code_segments"}, {"score": 0.0037072310568610723, "phrase": "hot_functions"}, {"score": 0.0035263833746562788, "phrase": "cold_statements"}, {"score": 0.003240139593712436, "phrase": "ablego"}, {"score": 0.0028867712833776046, "phrase": "cold_regions"}, {"score": 0.0027777389949155975, "phrase": "flexible_heuristics"}, {"score": 0.0025130941721410558, "phrase": "new_technique"}, {"score": 0.0024842242921857705, "phrase": "negative_side-effects"}, {"score": 0.0024181413029825205, "phrase": "proper_strategy"}, {"score": 0.0023357478549318102, "phrase": "performance_study"}, {"score": 0.00230003335593664, "phrase": "partial_inlining's_effect"}, {"score": 0.0022302306304023602, "phrase": "performance_improvement"}, {"score": 0.0021792693001152896, "phrase": "better_code_placement"}, {"score": 0.0021625417261202603, "phrase": "better_code_generation"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler optimization", " inlining", " partial inlining", " outlining", " function splitting", " code locality", " Itanium"], "paper_abstract": "Frequently invoked large functions are common in non-numeric applications. These large functions present challenges to modern compilers not only because they require more time and resources at compilation time, but also because they may prevent optimizations such as function inlining. Often large portions of the code in a hot function integral host are executed much less frequently than integral host itself. Partial inlining is a natural solution to the problems caused by including cold code segments that are seldom executed into hot functions that are frequently invoked. When applying partial inlining, a compiler outlines cold statements from a hot function integral host. After outlining,integral host becomes smaller and thus can be easily inlined. This paper presents Ablego, a framework for function outlining and partial inlining that includes several innovations: (1) an abstract-syntax-tree-based analysis and transformation to form cold regions for outlining; (2) a set of flexible heuristics to control the aggressiveness of function outlining; (3) several possible function outlining strategies; (4) explicit variable spilling, a new technique that overcomes negative side-effects of function outlining. With the proper strategy, partial inlining improves performance by up to 5.75%. A performance study also suggests that partial inlining's effect on enabling more aggressive inlining is limited. The performance improvement from partial inlining actually comes from better code placement and better code generation. Copyright (C) 2006 John Wiley & Sons, Ltd.", "paper_title": "Ablego: a function outlining and partial inlining framework", "paper_id": "WOS:000245703800002"}