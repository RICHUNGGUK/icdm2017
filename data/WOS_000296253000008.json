{"auto_keywords": [{"score": 0.04785710122151866, "phrase": "coded_packets"}, {"score": 0.015719716506582538, "phrase": "rateless_code"}, {"score": 0.01557276120808942, "phrase": "noisy_channels"}, {"score": 0.010143915461433178, "phrase": "new_attempt"}, {"score": 0.004635477242873163, "phrase": "potentially_infinite_number"}, {"score": 0.004337276328199398, "phrase": "reliable_recovery"}, {"score": 0.004296264970612285, "phrase": "multiple_information_packets"}, {"score": 0.0042354707960660706, "phrase": "conventional_rateless_decoder"}, {"score": 0.004136044939878838, "phrase": "parallel_manner"}, {"score": 0.004019797503157808, "phrase": "new_belief_propagation"}, {"score": 0.003944112858235306, "phrase": "newly_received_collection"}, {"score": 0.003815064377019477, "phrase": "prohibitive_decoding_complexity"}, {"score": 0.0036207206487324506, "phrase": "novel_serial_decoding_algorithm"}, {"score": 0.003355515315708125, "phrase": "rateless_codes"}, {"score": 0.0032149396890830575, "phrase": "new_group"}, {"score": 0.002909342017421165, "phrase": "previous_attempt"}, {"score": 0.002881793492919646, "phrase": "initial_input"}, {"score": 0.0024630345285372958, "phrase": "newly_updated_messages"}, {"score": 0.0023485549678832628, "phrase": "information_packets"}, {"score": 0.0022824314760583834, "phrase": "proposed_serial_decoding_algorithm"}, {"score": 0.0022608057001451414, "phrase": "significantly_lower_complexity"}, {"score": 0.0022287497627555895, "phrase": "existing_parallel_decoding_algorithms"}, {"score": 0.002155737496501148, "phrase": "awgn"}, {"score": 0.002135370916143782, "phrase": "rayleigh"}, {"score": 0.0021049977753042253, "phrase": "rician_fading_channels"}], "paper_keywords": ["Rateless code", " Fountain codes", " Serial decoding", " Noisy channel"], "paper_abstract": "Rateless code usually generates a potentially infinite number of coded packets at the encoder and collects enough packets at the decoder to ensure reliable recovery of multiple information packets. The conventional rateless decoder usually works in a parallel manner which needs to initiate a new belief propagation (BP) decoding procedure upon each newly received collection of coded packets, thereby resulting in prohibitive decoding complexity in practice. In this paper, we present a novel serial decoding algorithm, i.e., the serial storage belief propagation (SS BP) algorithm, for rateless codes over noisy channels. Specifically, upon receiving a new group of coded packets, the decoder initiates a new attempt to decode all the packets received so far, using the results of the previous attempt as initial input. Moreover, in each iteration of the new attempt, the decoder serially propagates the messages group by group from the most recent one to the earliest one. In this way, the newly updated messages can be propagated faster, expediting the recovery of information packets. In addition, the proposed serial decoding algorithm has significantly lower complexity than the existing parallel decoding algorithms. Simulation results validate its effectiveness in AWGN, Rayleigh, and Rician fading channels.", "paper_title": "Serial decoding of rateless code over noisy channels", "paper_id": "WOS:000296253000008"}