{"auto_keywords": [{"score": 0.03806837886274612, "phrase": "empirical_study"}, {"score": 0.00481495049065317, "phrase": "nullable_types"}, {"score": 0.004707672504464783, "phrase": "monotonic_non-null"}, {"score": 0.004534136929881113, "phrase": "marked_increase"}, {"score": 0.004416465443332974, "phrase": "potential_null_dereferences"}, {"score": 0.004205940624913343, "phrase": "nullity_modifiers"}, {"score": 0.004143196873246147, "phrase": "api_libraries"}, {"score": 0.00396050388346298, "phrase": "moderately_large_code_bases"}, {"score": 0.003886770770835211, "phrase": "non-null_annotations"}, {"score": 0.003591733916159209, "phrase": "five_open_source_projects"}, {"score": 0.003356675879109443, "phrase": "reference_declarations"}, {"score": 0.003021141590548526, "phrase": "-default_semantics"}, {"score": 0.002987236799291296, "phrase": "new_default"}, {"score": 0.002942619810718864, "phrase": "better_matching"}, {"score": 0.002931569771634119, "phrase": "general_practice"}, {"score": 0.0028986672783671147, "phrase": "developer_annotation_burden"}, {"score": 0.0027916287357898544, "phrase": "eclipse_java_modelling_language"}, {"score": 0.0027499252661633525, "phrase": "java_development_tooling"}, {"score": 0.0026583500966092044, "phrase": "new_semantics"}, {"score": 0.0025795066118838067, "phrase": "extensive_api_library_specifications"}, {"score": 0.0025409639091476363, "phrase": "jml._issues"}, {"score": 0.0025219085140220773, "phrase": "backwards_compatibility"}, {"score": 0.002465593351432208, "phrase": "second_phase"}, {"score": 0.0023040642263522505, "phrase": "nullable_field_references"}, {"score": 0.0022696277881969896, "phrase": "non-null_values"}, {"score": 0.0021530945641993152, "phrase": "monotonic_non-null_type"}], "paper_keywords": [""], "paper_abstract": "With Java 5 annotations, the authors note a marked increase in tools that can statically detect potential null dereferences. To be effective, such tools require that developers annotate declarations with nullity modifiers and have annotated API libraries. Unfortunately, in the experience of the authors, specifying moderately large code bases, the use of non-null annotations is more labour intensive than it should be. Motivated by this experience, the authors conducted an empirical study of five open source projects totalling 700K lines-of-code, which confirms that, on average, 75% of reference declarations are meant to be non-null, by design. Guided by these results, the authors propose the adoption of non-null-by-default semantics. This new default has advantages of better matching general practice, lightening developer annotation burden and being safer. The authors also describe the Eclipse Java Modelling Language (JML) Java Development Tooling (JDT), a tool supporting the new semantics, including the ability to read the extensive API library specifications written in the JML. Issues of backwards compatibility are addressed. In a second phase of the empirical study, the authors analysed the uses of null and noted that over half of the nullable field references are only assigned non-null values. For this category of reference, the authors introduce the concept of monotonic non-null type and illustrate the benefits of its use.", "paper_title": "Reducing the use of nullable types through non-null by default and monotonic non-null", "paper_id": "WOS:000262613500004"}