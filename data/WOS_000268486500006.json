{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "obstruction-free_implementations"}, {"score": 0.04425618028201676, "phrase": "step_contention"}, {"score": 0.004417848254181138, "phrase": "common_case"}, {"score": 0.0028468767420392945, "phrase": "corresponding_generic_object_implementations"}, {"score": 0.0027503564589458837, "phrase": "lower_bounds"}, {"score": 0.0025014259919355453, "phrase": "worst-case_operation_time_complexity"}, {"score": 0.0021049977753042253, "phrase": "lock-based_implementations"}], "paper_keywords": ["Algorithms", " Theory", " Shared memory", " solo-fast implementations", " perturbable objects", " step contention", " memory contention", " lower bounds"], "paper_abstract": "Obstruction-free implementations of concurrent objects are optimized for the common case where there is no step contention, and were recently advocated as a solution to the costs associated with synchronization without locks. In this article, we study this claim and this goes through precisely defining the notions of obstruction-freedom and step contention. We consider several classes of obstruction-free implementations, present corresponding generic object implementations, and prove lower bounds on their complexity. Viewed collectively, our results establish that the worst-case operation time complexity of obstruction-free implementations is high, even in the absence of step contention. We also show that lock-based implementations are not subject to some of the time-complexity lower bounds we present.", "paper_title": "The Complexity of Obstruction-Free Implementations", "paper_id": "WOS:000268486500006"}