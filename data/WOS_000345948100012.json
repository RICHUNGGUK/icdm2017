{"auto_keywords": [{"score": 0.043404787683005264, "phrase": "separate_compilation"}, {"score": 0.00481495049065317, "phrase": "modular_polymorphic_defunctionalization"}, {"score": 0.0037913267098534887, "phrase": "modular_variant"}, {"score": 0.0034660938095219846, "phrase": "functional_programming_language"}, {"score": 0.003397683082821229, "phrase": "parametric_polymorphism"}, {"score": 0.0031686717525002935, "phrase": "haskell-like_language"}, {"score": 0.0027557911038816256, "phrase": "executable_program"}, {"score": 0.0026217213613095322, "phrase": "prototype_implementation"}, {"score": 0.0023028105026714533, "phrase": "large_subset"}, {"score": 0.0022573345256334783, "phrase": "haskell"}, {"score": 0.0022127018991294047, "phrase": "low-level_c_code"}, {"score": 0.0021049977753042253, "phrase": "intensional_transformation"}], "paper_keywords": ["defunctionalization", " separate compilation", " polymorphism", " Haskell"], "paper_abstract": "Defunctionalization is generally considered a whole-program transformation and thus incompatible with separate compilation. In this paper, we formalize a modular variant of defunctionalization which can support separate compilation for a functional programming language with parametric polymorphism. Our technique allows modules in a Haskell-like language to be separately defunctionalized and compiled, then linked together to generate an executable program. We provide a prototype implementation of our modular defunctionalization technique and we discuss the experiences of its application in compiling a large subset of Haskell to low-level C code, based on the intensional transformation.", "paper_title": "Modular Polymorphic Defunctionalization", "paper_id": "WOS:000345948100012"}