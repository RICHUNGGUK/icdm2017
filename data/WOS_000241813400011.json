{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "formal_semantics"}, {"score": 0.045998857053669226, "phrase": "advice_weaving"}, {"score": 0.004730158389701481, "phrase": "aspectj_weaving"}, {"score": 0.004327982403666242, "phrase": "aspectj."}, {"score": 0.0039248128268720645, "phrase": "bytecode_weaving"}, {"score": 0.0036229421570951807, "phrase": "\".class\"_files"}, {"score": 0.003465350958971198, "phrase": "java_virtual_machine"}, {"score": 0.0032852362426476554, "phrase": "aspectj"}, {"score": 0.003032405563826263, "phrase": "advice_functionality"}, {"score": 0.0027495914857929584, "phrase": "join_points"}, {"score": 0.002405853977978678, "phrase": "static_pointcuts"}, {"score": 0.0021049977753042253, "phrase": "dynamic_pointcuts"}], "paper_keywords": [""], "paper_abstract": "This paper ascribes a formal semantics to advice weaving in AspectJ. Since the version 1.1, AspectJ language is developed using bytecode weaving, which combines aspects and classes to produce \".class\" files that run in a Java Virtual Machine (JVM). In AspectJ, advice weaving is done statically by inserting the advice functionality in some regions of the code. These regions are join points that are declared using pointcuts. In this paper, we focus only on static pointcuts, i.e., pointcuts that correspond directly to locations in the bytecode. AspectJ dynamic pointcuts such as target, this, and cflow are not in the focus of this paper.", "paper_title": "Towards a formal semantics for AspectJ weaving", "paper_id": "WOS:000241813400011"}