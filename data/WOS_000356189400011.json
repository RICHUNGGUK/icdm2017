{"auto_keywords": [{"score": 0.041712156789843864, "phrase": "python"}, {"score": 0.011870856369036658, "phrase": "high-level_language"}, {"score": 0.00481495049065317, "phrase": "filtered_queries"}, {"score": 0.0047895188927660525, "phrase": "attributed_semantic_graphs"}, {"score": 0.004739056045644449, "phrase": "complex_analytic_queries"}, {"score": 0.004714023408114857, "phrase": "massive_semantic_graphs"}, {"score": 0.004676720995756667, "phrase": "challenging_problem"}, {"score": 0.004652016085325825, "phrase": "big-data_analytics"}, {"score": 0.004615202066192795, "phrase": "high-performance_parallel_computing"}, {"score": 0.004566567411073082, "phrase": "semantic_graph"}, {"score": 0.004435436814742896, "phrase": "analytic_queries"}, {"score": 0.0041074234667687875, "phrase": "previous_investigations"}, {"score": 0.003947358102140903, "phrase": "parallel_graph_computations"}, {"score": 0.003916098498242888, "phrase": "kdt"}, {"score": 0.00385431710959668, "phrase": "custom_graph_algorithms"}, {"score": 0.0036942726653704213, "phrase": "existing_graph_algorithms"}, {"score": 0.0035786000713014625, "phrase": "domain_scientists"}, {"score": 0.0035127984203919033, "phrase": "customized_queries"}, {"score": 0.0033937776228549557, "phrase": "python_virtual_machine"}, {"score": 0.0032099453192629976, "phrase": "sejits"}, {"score": 0.0031592690527974285, "phrase": "semiring_operations"}, {"score": 0.00309293916022985, "phrase": "lower-level_efficiency_language"}, {"score": 0.002964415652865295, "phrase": "high-performance_combinatorial_bias_engine"}, {"score": 0.002833689453299307, "phrase": "low-level_parallel_environment"}, {"score": 0.0027963461768409667, "phrase": "system's_flexibility"}, {"score": 0.0027087124176536806, "phrase": "new_vertex_and_edge_types"}, {"score": 0.0026518169452004465, "phrase": "new_roofline_model"}, {"score": 0.0026377802995807085, "phrase": "graph_traversals"}, {"score": 0.002521422168371979, "phrase": "roofline"}, {"score": 0.002468450551616404, "phrase": "complex_interaction"}, {"score": 0.0024488738006005133, "phrase": "underlying_architecture"}, {"score": 0.0024037949232582462, "phrase": "performance_counters"}, {"score": 0.002365815362517737, "phrase": "hardware_behavior"}, {"score": 0.0022977342663599042, "phrase": "first_known_solution"}, {"score": 0.0022614266476954467, "phrase": "high_performance"}, {"score": 0.0022434880661725493, "phrase": "productivity_language"}, {"score": 0.002225691463551672, "phrase": "graph_algorithms"}, {"score": 0.002208035721125305, "phrase": "semantic_graphs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Graph analysis systems", " Attributed semantic graphs", " Graph filtering", " Parallel computing", " Knowledge discovery", " Domain-specific languages", " SEJITS", " High-performance graph analysis"], "paper_abstract": "Execution of complex analytic queries on massive semantic graphs is a challenging problem in big-data analytics that requires high-performance parallel computing. In a semantic graph, vertices and edges carry attributes of various types and the analytic queries typically depend on the values of these attributes. Thus, the computation must view the graph through a filter that passes only those individual vertices and edges of interest. Previous investigations have developed Knowledge Discovery Toolbox (KDT), a sophisticated Python library for parallel graph computations. In KDT, the user can write custom graph algorithms by specifying operations between edges and vertices (semiring operations). The user can also customize existing graph algorithms by writing filters. Although the high-level language for this customization enables domain scientists to productively express their graph analytics requirements, the customized queries perform poorly due to the overhead of having to call into the Python virtual machine for each vertex and edge. In this work, we use the Selective Embedded Just-In-Time Specialization (SEJITS) approach to automatically translate semiring operations and filters defined by programmers into a lower-level efficiency language, bypassing the upcall into Python. We evaluate our approach by comparing it with the high-performance Combinatorial BIAS engine and show that our approach combines the benefits of programming in a high-level language with executing in a low-level parallel environment. We increase the system's flexibility by developing techniques that provide users with the ability to define new vertex and edge types from Python. We also present a new Roofline model for graph traversals and show that we achieve performance that is significantly closer to the bounds suggested by the Roofline. Finally, to further understand the complex interaction with the underlying architecture, we present an analysis using performance counters that quantifies the improvement in hardware behavior in the context our SEJITS methodology. Overall, we demonstrate the first known solution to the problem of obtaining high performance from a productivity language when applying graph algorithms selectively on semantic graphs with hundreds of millions of edges and scaling to thousands of processors for graphs. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "Parallel processing of filtered queries in attributed semantic graphs", "paper_id": "WOS:000356189400011"}