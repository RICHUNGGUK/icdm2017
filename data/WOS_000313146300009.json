{"auto_keywords": [{"score": 0.03578134506239711, "phrase": "guest_systems"}, {"score": 0.014273453219943286, "phrase": "embedded_systems"}, {"score": 0.010199193256213919, "phrase": "kernel_space"}, {"score": 0.008219973931096329, "phrase": "spumone"}, {"score": 0.00481495049065317, "phrase": "simple_hardware_assistance"}, {"score": 0.004698985440736935, "phrase": "virtualization_architecture"}, {"score": 0.004660951511671023, "phrase": "multi-core_embedded_system"}, {"score": 0.00442708558833968, "phrase": "complex_protection_mechanism"}, {"score": 0.004391242726632591, "phrase": "virtualization_layer"}, {"score": 0.0041935232812319295, "phrase": "new_technique"}, {"score": 0.0038975628221865313, "phrase": "multicore_platforms"}, {"score": 0.0038242899532391914, "phrase": "virtualization_system"}, {"score": 0.003803608030258807, "phrase": "better_performance"}, {"score": 0.0037830375312466608, "phrase": "lower_power_consumption"}, {"score": 0.0037625778604875046, "phrase": "embedded_virtualization_design"}, {"score": 0.003652004401697793, "phrase": "traditional_vmm"}, {"score": 0.003544668879158414, "phrase": "embedded_environment"}, {"score": 0.003525493807130663, "phrase": "additional_special_hardware.support"}, {"score": 0.0034218637688148653, "phrase": "modular_design"}, {"score": 0.0033302915283097367, "phrase": "considerable_modifications"}, {"score": 0.0032061793819537633, "phrase": "user_space"}, {"score": 0.0030866782791708837, "phrase": "second_approach"}, {"score": 0.0029716179574996626, "phrase": "better_reliability"}, {"score": 0.002939536124277051, "phrase": "virtualization_layer_design_lightweight"}, {"score": 0.0028920597454305526, "phrase": "common_hardware_component"}, {"score": 0.002868609051439957, "phrase": "multi-core_embedded_processors"}, {"score": 0.002814625507877128, "phrase": "additional_on-chip_local_memory"}, {"score": 0.0027541694378728004, "phrase": "local_memory_areas"}, {"score": 0.0026659048913727106, "phrase": "memory_architecture"}, {"score": 0.0026228362985699113, "phrase": "above-mentioned_problems"}, {"score": 0.0025456716198597627, "phrase": "virtualization_layer's_program"}, {"score": 0.0025250225524928124, "phrase": "local_memory"}, {"score": 0.002398069885234319, "phrase": "additional_reliability"}, {"score": 0.0023657330062474996, "phrase": "entire_system"}, {"score": 0.0023465400668244386, "phrase": "spumone_design"}, {"score": 0.002327502474395314, "phrase": "multi-core_platform"}, {"score": 0.0022836785412390544, "phrase": "separate_processor_core"}, {"score": 0.002246771033171679, "phrase": "traditional_virtualization_layer_design"}, {"score": 0.0021049977753042253, "phrase": "overall_performance"}], "paper_keywords": ["operating system", " embedded system", " virtualization", " local memory", " scratch-pad memory"], "paper_abstract": "In this paper, we propose a virtualization architecture for a multi-core embedded system to provide more system reliability and security while maintaining performance and without introducing additional special hardware supports or implementing a complex protection mechanism in the virtualization layer. Embedded systems, especially consumer electronics, have often used virtualization. Virtualization is not a new technique, as there are various uses for both GPOS (General Purpose Operating System) and RTOS (Real Time Operating System). The surge of the multicore platforms in embedded systems also helps consolidate the virtualization system for better performance and lower power consumption. Embedded virtualization design usually uses two approaches. The first is to use the traditional VMM, but it is too complicated for use in the embedded environment without additional special hardware.support. The other approach uses the microkernel, which imposes a modular design. The guest systems, however, would suffer from considerable modifications in this approach, as the microkernel allows guest systems to run in the user space. For some RTOSes and their applications originally running in the kernel space, this second approach is more difficult to use because those codes use many privileged instructions. To achieve better reliability and keep the virtualization layer design lightweight, this work uses a common hardware component adopted in multi-core embedded processors. In most embedded platforms, vendors provide additional on-chip local memory for each physical core, and these local memory areas are only private to their cores. By taking advantage of this memory architecture, we can mitigate the above-mentioned problems at once. We choose to re-map the virtualization layer's program on the local memory, called SPUMONE, which runs all guest systems in the kernel space. Doing so, it can provide additional reliability and security for the entire system because the SPUMONE design in a multi-core platform has each instance installed on a separate processor core. This design differs from traditional virtualization layer design, and the content of each SPUMONE is inaccessible to the others. We also achieve this goal without adding overhead to the overall performance.", "paper_title": "Robust Lightweight Embedded Virtualization Layer Design with Simple Hardware Assistance", "paper_id": "WOS:000313146300009"}