{"auto_keywords": [{"score": 0.038794026399331626, "phrase": "skeletonized_code"}, {"score": 0.00481495049065317, "phrase": "code_skeletonization"}, {"score": 0.004746617697932655, "phrase": "optimization_hints"}, {"score": 0.004719555598790209, "phrase": "program_developers"}, {"score": 0.004679250110504641, "phrase": "severe_obstacles"}, {"score": 0.004599664074521038, "phrase": "meaningful_guidance"}, {"score": 0.004534372661692015, "phrase": "real_life_applications"}, {"score": 0.004495641511172577, "phrase": "main_reason"}, {"score": 0.004431820105931162, "phrase": "high_code_complexity"}, {"score": 0.00436890075128947, "phrase": "commercially_valuable_code"}, {"score": 0.004257878852754296, "phrase": "heavily_nested_conditional_statements"}, {"score": 0.004209441837971887, "phrase": "based_loops"}, {"score": 0.004185429483528935, "phrase": "function_calls"}, {"score": 0.0041024553904726955, "phrase": "existing_compiler_analysis"}, {"score": 0.004055779248961644, "phrase": "full_parallelization_potential"}, {"score": 0.003998177174467956, "phrase": "new_paradigm"}, {"score": 0.0037435277798679722, "phrase": "existing_tools"}, {"score": 0.0037221632527328183, "phrase": "source_level_automatic_parallelization"}, {"score": 0.003637913064193312, "phrase": "possible_parallelization_patterns"}, {"score": 0.003606811438631612, "phrase": "skeleton_code"}, {"score": 0.0035555630508414954, "phrase": "parallelized_version"}, {"score": 0.003396394281733363, "phrase": "proposed_skeletonization_algorithm"}, {"score": 0.0033577243441658302, "phrase": "integer_indexes"}, {"score": 0.003338554240844867, "phrase": "c-struct_references"}, {"score": 0.0033005406650551236, "phrase": "multi-dimensional_arrays"}, {"score": 0.0032536298009154052, "phrase": "automatic_parallelizers"}, {"score": 0.0032165800743224645, "phrase": "pointer_expressions"}, {"score": 0.0028357713679488983, "phrase": "avalll"}, {"score": 0.0027874519404992673, "phrase": "original_list"}, {"score": 0.00273995357773402, "phrase": "main_goal"}, {"score": 0.0027165079504297726, "phrase": "skeletonization_process"}, {"score": 0.002685558057339722, "phrase": "pointer-based_data_structures"}, {"score": 0.0025873791889845167, "phrase": "original_code"}, {"score": 0.002543281384021076, "phrase": "possible_parallelization_pattern"}, {"score": 0.002521514414371778, "phrase": "code_segment"}, {"score": 0.002471444757523519, "phrase": "effective_parallelization_hint"}, {"score": 0.0023879077085067137, "phrase": "spec_cpu"}, {"score": 0.0022940016281840564, "phrase": "parallelization_patterns"}, {"score": 0.0022743632836269307, "phrase": "generated_skeletons"}, {"score": 0.0022484395042896284, "phrase": "different_set"}, {"score": 0.002166206144892777, "phrase": "larger_set"}], "paper_keywords": ["Skeletonization", " Parallelization", " Vectorization"], "paper_abstract": "Tools that provide optimization hints for program developers are facing severe obstacles and often unable to provide meaningful guidance on how to parallelize real life applications. The main reason is due to the high code complexity and its large size when considering commercially valuable code. Such code is often rich with pointers, heavily nested conditional statements, nested while based loops, function calls, etc. These constructs prevent existing compiler analysis from extracting the full parallelization potential. We propose a new paradigm to overcome this issue by automatically transforming the code into a much simpler skeletonlike form that is more conductive for auto-parallelization. We then apply existing tools of source level automatic parallelization on the skeletonized code in order to expose possible parallelization patterns. The skeleton code, along with the parallelized version, are then provided to the programmer in the form of an IDE (Integrated Development Environment) recommendation. The proposed skeletonization algorithm replaces pointers by integer indexes and C-struct references by references to multi-dimensional arrays. This is because automatic parallelizers cannot handle pointer expressions. For example, while(p not equal NULL){p -> val + +; p = p -> next;} will be skeletonized to the parallelizable f or(Ip = 0; Ip < N; I-p ++){Aval[Ip]++; where Avalll holds the embedding of the original list. It follows that the main goal of the skeletonization process is to embed pointer-based data structures into arrays. Though the skeletonized code is not semantically equivalent to the original code, it points out a possible parallelization pattern for this code segment and can be used as an effective parallelization hint to the programmer. We applied the method on several representative benchmarks from SPEC CPU 2000 and reached up to 80% performance gain after several sequential code segments had been manually parallelized based on the parallelization patterns of the generated skeletons. In a different set of experiments we tried to estimate the potential of skeletonization for a larger set of programs in SPEC 2000 and obtained an estimation of 27% additional loops that can be parallelized/vectorized due to skeletonization.", "paper_title": "Parallelization Hints via Code Skeletonization", "paper_id": "WOS:000349142100034"}