{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "mining_iterative_generators"}, {"score": 0.03808286282826766, "phrase": "iterative_pattern_mining"}, {"score": 0.02826960909881761, "phrase": "iterative_generators"}, {"score": 0.004728874038094706, "phrase": "software_specification_discovery"}, {"score": 0.004577777897335174, "phrase": "software-related_cost"}, {"score": 0.004447509888681154, "phrase": "software_cost"}, {"score": 0.004320932773749168, "phrase": "existing_systems"}, {"score": 0.004274396662662802, "phrase": "maintenance_tasks"}, {"score": 0.0039623243082901214, "phrase": "software_products"}, {"score": 0.003794297119656863, "phrase": "documented_specifications"}, {"score": 0.003699579190650754, "phrase": "program_understanding"}, {"score": 0.0036729522133392175, "phrase": "lo_et_al"}, {"score": 0.0034918342672996066, "phrase": "program_trace"}, {"score": 0.0034417406427881075, "phrase": "multiple_traces"}, {"score": 0.003380129564214184, "phrase": "frequent_iterative_patterns"}, {"score": 0.0033557940171476683, "phrase": "frequent_program_behaviors"}, {"score": 0.0032957163929772716, "phrase": "software_specifications"}, {"score": 0.0031108298225006013, "phrase": "lo"}, {"score": 0.0030328769643087066, "phrase": "mining_closed_iterative_patterns"}, {"score": 0.0026151058979100596, "phrase": "closed_patterns"}, {"score": 0.002468107263634476, "phrase": "temporal_constraints"}, {"score": 0.002363293825140551, "phrase": "representative_rules"}, {"score": 0.002337791830793841, "phrase": "comprehensive_performance_study"}, {"score": 0.0022711207841260767, "phrase": "case_study"}, {"score": 0.002230418233881411, "phrase": "industrial_system"}, {"score": 0.0021825348057711628, "phrase": "iterative_patterns"}, {"score": 0.00213567715613494, "phrase": "useful_rules"}, {"score": 0.0021049977753042253, "phrase": "software_design"}], "paper_keywords": ["Frequent pattern mining", " sequence database", " iterative patterns", " generators", " representative rules", " software engineering", " reverse engineering", " program comprehension"], "paper_abstract": "Billions of dollars are spent annually on software-related cost. It is estimated that up to 45 percent of software cost is due to the difficulty in understanding existing systems when performing maintenance tasks (i.e., adding features, removing bugs, etc.). One of the root causes is that software products often come with poor, incomplete, or even without any documented specifications. In an effort to improve program understanding, Lo et al. have proposed iterative pattern mining which outputs patterns that are repeated frequently within a program trace, or across multiple traces, or both. Frequent iterative patterns reflect frequent program behaviors that likely correspond to software specifications. To reduce the number of patterns and improve the efficiency of the algorithm, Lo et al. have also introduced mining closed iterative patterns, i.e., maximal patterns without any superpattern having the same support. In this paper, to technically deepen research on iterative pattern mining, we introduce mining iterative generators, i.e., minimal patterns without any subpattern having the same support. Iterative generators can be paired with closed patterns to produce a set of rules expressing forward, backward, and in-between temporal constraints among events in one general representation. We refer to these rules as representative rules. A comprehensive performance study shows the efficiency of our approach. A case study on traces of an industrial system shows how iterative generators and closed iterative patterns can be merged to form useful rules shedding light on software design.", "paper_title": "Mining Iterative Generators and Representative Rules for Software Specification Discovery", "paper_id": "WOS:000285391700009"}