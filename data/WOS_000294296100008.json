{"auto_keywords": [{"score": 0.03350109222308385, "phrase": "mv_codes"}, {"score": 0.004961037413739501, "phrase": "constant_fraction"}, {"score": 0.004681076799813777, "phrase": "n-bit_codeword"}, {"score": 0.0044619403653966645, "phrase": "ith_message_bit"}, {"score": 0.004313434109653615, "phrase": "randomized_decoding_procedure"}, {"score": 0.004123054121415497, "phrase": "delta_n_locations"}, {"score": 0.00407678138571414, "phrase": "new_class"}, {"score": 0.004053839332787437, "phrase": "locally_decodable_codes"}, {"score": 0.0039299374000275195, "phrase": "restricted_dot_products"}, {"score": 0.0035763868395444023, "phrase": "rm_ldcs"}, {"score": 0.003500454947375897, "phrase": "earlier_generations"}, {"score": 0.0034416557738293947, "phrase": "large_values"}, {"score": 0.0033552975070941416, "phrase": "r-query_mv_codes"}, {"score": 0.003317612543400555, "phrase": "error_rates"}, {"score": 0.003271099035362546, "phrase": "larger_query_complexity"}, {"score": 0.0032526761451728537, "phrase": "shorter_length_codes"}, {"score": 0.003144290575504966, "phrase": "superconstant_number"}, {"score": 0.0029632081217391866, "phrase": "new_view"}, {"score": 0.002938202365941281, "phrase": "vector_codes"}, {"score": 0.002872546253812061, "phrase": "reed-muller"}, {"score": 0.002784646536952332, "phrase": "deeper_insights"}, {"score": 0.002616816751982508, "phrase": "existing_families"}, {"score": 0.002551102421211472, "phrase": "large_constant_fraction"}, {"score": 0.0024245711012002083, "phrase": "moderate_increase"}, {"score": 0.0023305026804332947, "phrase": "first_families"}, {"score": 0.0023043010697170246, "phrase": "superconstant_query_complexity"}, {"score": 0.0021531499016013704, "phrase": "constant_c."}, {"score": 0.0021049977753042253, "phrase": "mv_code"}], "paper_keywords": ["locally decodable codes", " Reed-Muller codes", " matching vectors"], "paper_abstract": "An (r, delta, epsilon)-locally decodable code encodes a k-bit message x to an N-bit codeword C(x), such that for every i is an element of [k], the ith message bit can be recovered with probability 1 - epsilon, by a randomized decoding procedure that queries only r bits, even if the codeword C(x) is corrupted in up to delta N locations. Recently a new class of locally decodable codes (LDCs), based on families of vectors with restricted dot products, has been discovered. We refer to those codes as matching vector (MV) codes. Several families of (r, delta, Theta(r delta))-locally decodable MV codes have been obtained. While codes in those families were shorter than codes of earlier generations, they suffered from having large values of epsilon = Omega(r delta), which meant that r-query MV codes could only handle error rates below 1/r. Thus larger query complexity gave shorter length codes but at the price of less error tolerance. No MV codes of a superconstant number of queries capable of tolerating a constant fraction of errors were known to exist. In this paper we present a new view of matching vector codes and uncover certain similarities between MV codes and classical Reed-Muller (RM) codes. Our view allows us to obtain deeper insights into the power and limitations of MV codes. Specifically, we obtain the following: (1) We show that existing families of MV codes can be enhanced to tolerate a large constant fraction of errors, independent of the number of queries. Such enhancement comes at a price of a moderate increase in the number of queries. (2) Our construction yields the first families of MV codes of superconstant query complexity that can tolerate a constant fraction of errors. Our codes are shorter than RM LDCs for all values of r <= log k/(log log k)(c), for some constant c. (3) We show that any MV code encodes messages of length k to codewords of length at least k2 Omega(root log k). Therefore MV codes do not improve upon RM LDCs for r >= (log k)(Omega(root log k)).", "paper_title": "MATCHING VECTOR CODES", "paper_id": "WOS:000294296100008"}