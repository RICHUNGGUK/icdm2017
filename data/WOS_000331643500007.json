{"auto_keywords": [{"score": 0.04204224612471482, "phrase": "software_engineers"}, {"score": 0.04082865113596906, "phrase": "textual_specification"}, {"score": 0.02713580930221474, "phrase": "natural_language_specifications"}, {"score": 0.00481495049065317, "phrase": "uml_models"}, {"score": 0.00469445816161498, "phrase": "automatic_processing"}, {"score": 0.00457696724030363, "phrase": "requirements_engineering"}, {"score": 0.004530794611704416, "phrase": "software_engineering"}, {"score": 0.004395040468458808, "phrase": "structured_process"}, {"score": 0.004328689762198895, "phrase": "manual_tasks"}, {"score": 0.0040525061916685924, "phrase": "skilled_analysts"}, {"score": 0.0038325685550319863, "phrase": "envisioned_system"}, {"score": 0.003569763795153386, "phrase": "quite_a_bit"}, {"score": 0.0034277338119963886, "phrase": "requirement_changes"}, {"score": 0.003393115177189967, "phrase": "implementation_decisions"}, {"score": 0.0031603487697867538, "phrase": "actual_software"}, {"score": 0.0028120022457134267, "phrase": "feedback_system"}, {"score": 0.0025793874956029795, "phrase": "overall_processing"}, {"score": 0.0024023079401125492, "phrase": "already_published_workshop_paper"}, {"score": 0.0023066199295447686, "phrase": "even_non-software-engineers"}, {"score": 0.002237357942660354, "phrase": "case_studies"}, {"score": 0.002126502291103601, "phrase": "creation_texts"}], "paper_keywords": ["Natural language specification", " Ontology", " Modeling", " UML"], "paper_abstract": "Software engineering is supposed to be a structured process, but manual tasks leave much leeway. Ideally, these tasks lie in the hands of skilled analysts and software engineers. This includes creating the textual specification of the envisioned system as well as creating models for the software engineers. Usually, there is quite a bit of erosion during the process due to requirement changes, implementation decisions, etc. To deliver the software as specified, textual requirements, models, and the actual software need to be synchronized. However, in practice, the cost of manually maintaining consistency is too high. Our requirements engineering feedback system automates the process of keeping textual specification and models consistent when the models change. To improve overall processing of natural language specifications, our approach finds flaws in natural language specifications. In addition to the already published workshop paper, we show how well our tools support even non-software-engineers in improving texts. The case studies show that we can speed up the process of creation texts with fewer flaws significantly.", "paper_title": "From requirements to UML models and back: how automatic processing of text can support requirements engineering", "paper_id": "WOS:000331643500007"}