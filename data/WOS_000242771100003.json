{"auto_keywords": [{"score": 0.040537135041717604, "phrase": "recurring_real-time_tasks"}, {"score": 0.00481495049065317, "phrase": "event-triggered_real-time_embedded_systems"}, {"score": 0.004488946121663966, "phrase": "independent_tasks"}, {"score": 0.004334280585565239, "phrase": "event-triggered_code_blocks"}, {"score": 0.004227064760262924, "phrase": "scheduling_tasks"}, {"score": 0.004060986196931943, "phrase": "execution_order"}, {"score": 0.003980400251874277, "phrase": "real-time_constraints"}, {"score": 0.0035292625231068517, "phrase": "exponential_complexity"}, {"score": 0.0033905067962602515, "phrase": "limited_resources"}, {"score": 0.003356675879109443, "phrase": "preemptive_scheduling"}, {"score": 0.003240895431893263, "phrase": "high_context_switching"}, {"score": 0.0031448288291084, "phrase": "dynamic_scheduling"}, {"score": 0.0030363332738004454, "phrase": "high_cpu_overhead"}, {"score": 0.0029169007179202164, "phrase": "static_priority_scheduling"}, {"score": 0.0027881294891497115, "phrase": "schedule-theoretic_results"}, {"score": 0.0027464781499539296, "phrase": "non-preemptive_uniprocessor_case"}, {"score": 0.0023745087648471613, "phrase": "latter_technique"}, {"score": 0.00223570488212345, "phrase": "optimal_solution"}, {"score": 0.002158505888557746, "phrase": "reasonable_time"}, {"score": 0.0021049977753042253, "phrase": "good_candidates"}], "paper_keywords": ["real-time embedded systems", " static priority scheduling", " simulated annealing search framework"], "paper_abstract": "Real-time embedded systems are often specified as a collection of independent tasks, each generating a sequence of event-triggered code blocks. The goal of scheduling tasks in this domain is to find an execution order which satisfies all real-time constraints. Within the context of recurring real-time tasks, all previous work either allowed preemptions, or only considered dynamic scheduling, and generally had exponential complexity. However, for many embedded systems running on limited resources, preemptive scheduling may be very costly due to high context switching and memory overheads, and dynamic scheduling can be less desirable due to high CPU overhead. In this paper, we study static priority scheduling of recurring real-time tasks. We focus on and obtain schedule-theoretic results for the non-preemptive uniprocessor case. To achieve this, we derive a sufficient (albeit not necessary) condition for schedulability under static priority scheduling and show that this condition can be efficiently tested in practice. The latter technique is demonstrated with examples, where in each case, an optimal solution for a given problem specification is obtained within reasonable time, by first detecting good candidates using meta-heuristics, and then by testing them for schedulability.", "paper_title": "Static priority scheduling of event-triggered real-time embedded systems", "paper_id": "WOS:000242771100003"}