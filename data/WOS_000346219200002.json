{"auto_keywords": [{"score": 0.038170323568475995, "phrase": "fpga"}, {"score": 0.00829603801296548, "phrase": "rlff"}, {"score": 0.00481495049065317, "phrase": "rapid_evaluation_of_custom_instruction_selection"}, {"score": 0.00475254914916922, "phrase": "fpga_estimation"}, {"score": 0.004690952711665194, "phrase": "main_aim"}, {"score": 0.0045108906244892165, "phrase": "fast_and_accurate_fpga_estimation_engine"}, {"score": 0.004375613460102577, "phrase": "custom_instruction"}, {"score": 0.004189337956225294, "phrase": "fpga_estimation_engine"}, {"score": 0.004046020290832207, "phrase": "fpga_performance_measures"}, {"score": 0.004010960493946656, "phrase": "selected_custom_instructions"}, {"score": 0.003907586297783078, "phrase": "fpga_estimation_technique"}, {"score": 0.0038401488612789963, "phrase": "high-level_representation"}, {"score": 0.0036926236934657864, "phrase": "structural_organization"}, {"score": 0.0035507457285983268, "phrase": "account_general_logic_synthesis_principles"}, {"score": 0.003340768341189764, "phrase": "widely_used_graph"}, {"score": 0.0032546105164772995, "phrase": "custom_instruction_selection"}, {"score": 0.003115908199991072, "phrase": "refined_largest_fit_first"}, {"score": 0.0028065957753430713, "phrase": "basic_templates"}, {"score": 0.002770150086489194, "phrase": "initial_solution"}, {"score": 0.0026986685585382347, "phrase": "overlapping_templates"}, {"score": 0.0025611773887867255, "phrase": "higher_performance"}, {"score": 0.0024519545383399773, "phrase": "ilp_method"}, {"score": 0.0022967713922705, "phrase": "worst_performance"}, {"score": 0.002218054404179068, "phrase": "worthy_proposition"}, {"score": 0.0021892345747666977, "phrase": "design_flows"}, {"score": 0.0021702292394814144, "phrase": "accurate_fpga_estimation"}], "paper_keywords": ["Design", " Algorithms", " FPGA", " customizable processors", " ISA extension", " approximation algorithms"], "paper_abstract": "The main aim of this article is to demonstrate that a fast and accurate FPGA estimation engine is indispensable in design flows for custom instruction (template) selection. The need for a FPGA estimation engine stems from the difficulty in predicting the FPGA performance measures of selected custom instructions. We will present a FPGA estimation technique that partitions the high-level representation of custom instructions into clusters based on the structural organization of the target FPGA, while taking into account general logic synthesis principles adopted by FPGA tools. In this work, we have evaluated a widely used graph covering algorithm with various heuristics for custom instruction selection. In addition, we present an algorithm called Refined Largest Fit First (RLFF) that relies on a graph covering heuristic to select non-overlapping superset templates, which typically incorporate frequently used basic templates. The initial solution is further refined by considering overlapping templates that were ignored previously to see if their introduction could lead to higher performance. While RLFF provides the most efficient cover compared to the ILP method and other graph covering heuristics, FPGA estimation results reveals that RLFF leads to the worst performance in certain applications. It is therefore a worthy proposition to equip design flows with accurate FPGA estimation in order to rapidly determine the most profitable custom instruction approach for a given application.", "paper_title": "Rapid Evaluation of Custom Instruction Selection Approaches with FPGA Estimation", "paper_id": "WOS:000346219200002"}