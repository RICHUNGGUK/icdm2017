{"auto_keywords": [{"score": 0.0496213341565463, "phrase": "generic_programming"}, {"score": 0.00481495049065317, "phrase": "language_support"}, {"score": 0.004545240514015278, "phrase": "type-safe_polymorphic_containers"}, {"score": 0.0043738432231020885, "phrase": "basic_support"}, {"score": 0.0039729853486821995, "phrase": "comprehensive_comparison"}, {"score": 0.0038600230206554792, "phrase": "eight_programming_languages"}, {"score": 0.0037864980290391354, "phrase": "objective_caml"}, {"score": 0.0037502752817270466, "phrase": "haskell"}, {"score": 0.0036788860751106275, "phrase": "java"}, {"score": 0.003522993271769176, "phrase": "cecil"}, {"score": 0.0034392837410790293, "phrase": "substantial_example"}, {"score": 0.003262035294895737, "phrase": "basic_roles"}, {"score": 0.0030642636185693054, "phrase": "eight_language_properties"}, {"score": 0.0030058503645435455, "phrase": "broader_view"}, {"score": 0.0029203055813347874, "phrase": "multi-type_concepts"}, {"score": 0.002850875630787708, "phrase": "type_parameters"}, {"score": 0.0028235667474151714, "phrase": "convenient_associated_type_access"}, {"score": 0.0027697290872182477, "phrase": "associated_types"}, {"score": 0.0027431953780099826, "phrase": "retroactive_modeling"}, {"score": 0.002716915166374506, "phrase": "type_aliases"}, {"score": 0.002690886043654469, "phrase": "separate_compilation"}, {"score": 0.0026395715432958665, "phrase": "data_structures"}, {"score": 0.002601727192945944, "phrase": "implicit_argument_type_deduction"}, {"score": 0.002432152706473349, "phrase": "awkward_designs"}, {"score": 0.0024088451312725924, "phrase": "poor_maintainability"}, {"score": 0.0023743009016047424, "phrase": "painfully_verbose_code"}, {"score": 0.0022409963215568565, "phrase": "language_designers"}, {"score": 0.0021563019696857768, "phrase": "effective_use"}], "paper_keywords": [""], "paper_abstract": "Many modern programming languages support basic generics, sufficient to implement type-safe polymorphic containers. Some languages have moved beyond this basic support, and in. doing so have enabled a broader, more powerful form of generic programming. This paper reports on a comprehensive comparison of facilities for generic programming in eight programming languages: C++, Standard ML, Objective Caml, Haskell, Eiffel, Java, C# (with its proposed generics extension), and Cecil. By implementing a substantial example in each of these languages, we illustrate how the basic roles of generic programming can be represented in each language. We also identify eight language properties that support this broader view of generic programming: support for multi-type concepts, multiple constraints on type parameters, convenient associated type access, constraints on associated types, retroactive modeling, type aliases, separate compilation of algorithms and data structures, and implicit argument type deduction for generic algorithms. We find that these features are necessary to avoid awkward designs, poor maintainability, and painfully verbose code. As languages increasingly support generics, it is important that language designers understand the features necessary to enable the effective use of generics and that their absence can cause difficulties for programmers.", "paper_title": "An extended comparative study of language support for generic programming", "paper_id": "WOS:000245092700001"}