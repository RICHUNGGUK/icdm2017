{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "strongly-typed_functional_languages"}, {"score": 0.004541712637353326, "phrase": "domain-specific_languages"}, {"score": 0.004248294537944227, "phrase": "type-safe_functions"}, {"score": 0.004108742905942481, "phrase": "embedded_dsl"}, {"score": 0.004007083686875716, "phrase": "application-specific_type_constraints"}, {"score": 0.0037480753312398754, "phrase": "dsl_data_types"}, {"score": 0.003197843245296877, "phrase": "dsl_expressions"}, {"score": 0.002966084234963723, "phrase": "simple_solution"}, {"score": 0.0028209599545587745, "phrase": "application-specific_constraints"}, {"score": 0.0025730425700096365, "phrase": "dsl_expression"}, {"score": 0.00246765655376112, "phrase": "dsl's_embedding_types"}, {"score": 0.0021049977753042253, "phrase": "higher-rank_types"}], "paper_keywords": ["Static typing", " constraints", " domain-specific languages"], "paper_abstract": "Strongly-typed functional languages provide a powerful framework for embedding Domain-Specific Languages (DSLs). However, building type-safe functions defined over an embedded DSL can introduce application-specific type constraints that end up being imposed on the DSL data types themselves. At best, these constraints are unwieldy and at worst they can limit the range of DSL expressions that can be built. We present a simple solution to this problem that allows application-specific constraints to be specified at the point of use of a DSL expression rather than when the DSL's embedding types are defined. Our solution applies equally to both tagged and tagless representations and, importantly, also works in the presence of higher-rank types.", "paper_title": "Deconstraining DSLs", "paper_id": "WOS:000311296000029"}