{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "first-class_modules"}, {"score": 0.03610310423475187, "phrase": "static_modules"}, {"score": 0.03120307591735523, "phrase": "plt_scheme"}, {"score": 0.004772593750252861, "phrase": "behavioral_software_contracts"}, {"score": 0.004235793609579307, "phrase": "theorem_provers"}, {"score": 0.003999217176949845, "phrase": "contract_violation"}, {"score": 0.003826231150275071, "phrase": "contract_violator"}, {"score": 0.003660700128133065, "phrase": "contract_monitoring"}, {"score": 0.003628460216207393, "phrase": "static_module_interfaces"}, {"score": 0.00354909279546064, "phrase": "contract_compiler"}, {"score": 0.0034714553759044664, "phrase": "disjoint_obligations"}, {"score": 0.003163439005885435, "phrase": "contract_violations"}, {"score": 0.00278237555651743, "phrase": "open_software_systems"}, {"score": 0.0025465957200502404, "phrase": "source_program"}, {"score": 0.0023724065150232897, "phrase": "semantic_framework"}, {"score": 0.002320449502337321, "phrase": "dynamic_modules"}, {"score": 0.0022696277881969896, "phrase": "internal_consistency"}], "paper_keywords": ["Reliability", " contracts", " first-class module systems"], "paper_abstract": "Behavioral software contracts express properties concerning the flow of values across component (modules, classes, etc) interfaces. These properties are often beyond the reach of theorem provers and are therefore monitored at run-time. When the monitor discovers a contract violation, it raises an exception that simultaneously pinpoints the contract violator and explains the nature of the violation. Currently contract monitoring assumes static module interfaces. Specifically, the contract compiler partitions a contract into disjoint obligations for the static modules that communicate to an interface. At run-time, the information is used for catching and explaining contract violations. While static modules suffice for many situations, first-class modules-such as the units provided by PLT Scheme-support the dynamic and multiple linking that is often required in open software systems. The problem is, of course, that in such a world, it becomes impossible to tell from the source program alone which components have agreed to which contracts. In this paper, we develop the semantic framework of monitoring contracts for dynamic modules. We establish the internal consistency of the semantics, and we sketch an implementation based on our experience of equipping PLT Scheme with such contracts.", "paper_title": "Contracts for First-Class Modules", "paper_id": "WOS:000280884100004"}