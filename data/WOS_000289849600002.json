{"auto_keywords": [{"score": 0.03833105225751244, "phrase": "enforcement_monitors"}, {"score": 0.00481495049065317, "phrase": "runtime_enforcement"}, {"score": 0.004690952711665194, "phrase": "powerful_technique"}, {"score": 0.0041170581247889654, "phrase": "previous_work"}, {"score": 0.0037087324991876727, "phrase": "generic_notion"}, {"score": 0.0035199624440843892, "phrase": "memory_device"}, {"score": 0.003459191419478298, "phrase": "finite_sets"}, {"score": 0.003399466007862412, "phrase": "control_states"}, {"score": 0.003340768341189764, "phrase": "enforcement_operations"}, {"score": 0.00303553181618577, "phrase": "safety-progress"}, {"score": 0.0027822459052173113, "phrase": "systematic_technique"}, {"score": 0.002462664392109308, "phrase": "response_property"}, {"score": 0.0021049977753042253, "phrase": "previous_runtime_enforcement_mechanisms"}], "paper_keywords": ["Runtime enforcement", " Monitor", " Safety-progress classification", " Monitor synthesis", " Composition"], "paper_abstract": "Runtime enforcement is a powerful technique to ensure that a program will respect a given set of properties. We extend previous work on this topic in several directions. Firstly, we propose a generic notion of enforcement monitors based on a memory device and finite sets of control states and enforcement operations. Moreover, we specify their enforcement abilities w.r.t. the general Safety-Progress classification of properties. Furthermore, we propose a systematic technique to produce a monitor from the automaton recognizing a given safety, guarantee, obligation or response property. Finally, we show that this notion of enforcement monitors is more amenable to implementation and encompasses previous runtime enforcement mechanisms.", "paper_title": "Runtime enforcement monitors: composition, synthesis, and enforcement abilities", "paper_id": "WOS:000289849600002"}