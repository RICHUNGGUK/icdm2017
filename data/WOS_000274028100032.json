{"auto_keywords": [{"score": 0.028930494932271376, "phrase": "herman"}, {"score": 0.006250292427788383, "phrase": "flanagan"}, {"score": 0.005095267225879261, "phrase": "threesomes"}, {"score": 0.004627441072541506, "phrase": "static_and_dynamic_types"}, {"score": 0.004290969772225093, "phrase": "tail_calls"}, {"score": 0.004240116703465252, "phrase": "non-tail_calls"}, {"score": 0.004206548500039536, "phrase": "increasing_space_consumption"}, {"score": 0.003978866233891427, "phrase": "new_solution"}, {"score": 0.003931697356115479, "phrase": "old_problem"}, {"score": 0.003800964615265999, "phrase": "tomb"}, {"score": 0.0036456298076415652, "phrase": "target_type"}, {"score": 0.0034208822062692127, "phrase": "intermediate_type"}, {"score": 0.0031217859267564344, "phrase": "single_threesome"}, {"score": 0.002988101395789399, "phrase": "intermediate_types"}, {"score": 0.0029060170624404242, "phrase": "blame_labels"}, {"score": 0.0027815466400771768, "phrase": "offending_twosome"}, {"score": 0.0027485326424697095, "phrase": "source_program"}, {"score": 0.0026099289298770023, "phrase": "space_problem"}, {"score": 0.002548331088496964, "phrase": "coercion_calculus"}, {"score": 0.00252812242767189, "phrase": "henglein"}, {"score": 0.002439143581855858, "phrase": "theoretical_limit"}, {"score": 0.0024101837218440834, "phrase": "space_overhead"}, {"score": 0.0023626775529531486, "phrase": "practical_question"}, {"score": 0.0023069016803337365, "phrase": "coercion_reduction"}, {"score": 0.0022168460543913787, "phrase": "streamlined_data_structure"}, {"score": 0.0021645053655350703, "phrase": "normalizing_coercions"}, {"score": 0.0021049977753042253, "phrase": "typed-based_explanation"}], "paper_keywords": ["Languages", " Theory", " casts", " coercions", " blame tracking", " lambda-calculus"], "paper_abstract": "How to integrate static and dynamic types? Recent work focuses on casts to mediate between the two. However, adding casts may degrade tail calls into a non-tail calls, increasing space consumption from constant to linear in the depth of calls. We present a new solution to this old problem, based on the notion of a threesome. A cast is specified by a source and a target type-a twosome. Any twosome factors into a downcast from the source to an intermediate type, followed by an upcast from the intermediate to the target-a threesome. Any chain of threesomes collapses to a single threesome, calculated by taking the greatest lower bound of the intermediate types. We augment this solution with blame labels to map any failure of a threesome back to the offending twosome in the source program. Herman, Tomb, and Flanagan (2007) solve the space problem by representing casts with the coercion calculus of Henglein (1994). While they provide a theoretical limit on the space overhead, there remains the practical question of how best to implement coercion reduction. The threesomes presented in this paper provide a streamlined data structure and algorithm for representing and normalizing coercions. Furthermore, threesomes provide a typed-based explanation of coercion reduction.", "paper_title": "Threesomes, With and Without Blame", "paper_id": "WOS:000274028100032"}