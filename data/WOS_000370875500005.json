{"auto_keywords": [{"score": 0.04961597900198376, "phrase": "dsp"}, {"score": 0.00481495049065317, "phrase": "short-vector_simd"}, {"score": 0.0046993598473345395, "phrase": "popular_extensions"}, {"score": 0.004653900688892822, "phrase": "common_isas"}, {"score": 0.004542158659382197, "phrase": "excellent_performance"}, {"score": 0.004498213310668266, "phrase": "compact_code"}, {"score": 0.00443308765153716, "phrase": "compute-intensive_applications"}, {"score": 0.004326624385772596, "phrase": "specialised_compiler_support"}, {"score": 0.0040027552011993005, "phrase": "platform-specific_intrinsic_functions"}, {"score": 0.003614044704141927, "phrase": "non-portable_code"}, {"score": 0.0034760655218366, "phrase": "novel_methodology"}, {"score": 0.003215659239270654, "phrase": "similar_intrinsics"}, {"score": 0.0031690434364310435, "phrase": "target_platform"}, {"score": 0.003092842645798083, "phrase": "description_language"}, {"score": 0.002931569771634119, "phrase": "graph-based_pattern_matching"}, {"score": 0.0029031614127920232, "phrase": "high-level_code_transformations"}, {"score": 0.0028058765785670546, "phrase": "target's_intrinsics"}, {"score": 0.002608218347502229, "phrase": "free_rider_tool"}, {"score": 0.0025085435314540837, "phrase": "opencv_samples"}, {"score": 0.00247215300812495, "phrase": "complex_embedded_application"}, {"score": 0.002366110899738696, "phrase": "intel_edison_module"}, {"score": 0.0022101055924375725, "phrase": "plain_c_baseline"}, {"score": 0.0021049977753042253, "phrase": "manually_ported_and_optimised_versions"}], "paper_keywords": ["Languages", " Performance", " Retargeting", " intrinsics", " compiler-known functions", " graph pattern matching"], "paper_abstract": "Short-vector SIMD and DSP instructions are popular extensions to common ISAs. These extensions deliver excellent performance and compact code for some compute-intensive applications, but they require specialised compiler support. To enable the programmer to explicitly request the use of such an instruction, many C compilers provide platform-specific intrinsic functions, whose implementation is handled specially by the compiler. The use of such intrinsics, however, inevitably results in non-portable code. In this paper we develop a novel methodology for retargeting such non-portable code, which maps intrinsics from one platform to another, taking advantage of similar intrinsics on the target platform. We employ a description language to specify the signature and semantics of intrinsics and perform graph-based pattern matching and high-level code transformations to derive optimised implementations exploiting the target's intrinsics, wherever possible. We demonstrate the effectiveness of our new methodology, implemented in the FREE RIDER tool, by automatically retargeting benchmarks derived from OPENCV samples and a complex embedded application optimised to run on an ARM CORTEX-M4 to an INTEL EDISON module with SSE4.2 instructions. We achieve a speedup of up to 3.73 over a plain C baseline, and on average 96.0% of the speedup of manually ported and optimised versions of the benchmarks.", "paper_title": "FREE RIDER: A Tool for Retargeting Platform-Specific Intrinsic Functions", "paper_id": "WOS:000370875500005"}