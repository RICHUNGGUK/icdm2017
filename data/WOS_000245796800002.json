{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "software_evolution"}, {"score": 0.004783852487938866, "phrase": "configuration_management_tools"}, {"score": 0.004646366831056171, "phrase": "software_industry"}, {"score": 0.004616352597792864, "phrase": "software_configuration_management"}, {"score": 0.004586581774641889, "phrase": "scm"}, {"score": 0.004542158659382197, "phrase": "minute_information"}, {"score": 0.004498213310668266, "phrase": "entire_evolution"}, {"score": 0.004469151810727749, "phrase": "complex_software_systems"}, {"score": 0.004397313229350093, "phrase": "good_source"}, {"score": 0.00436890075128947, "phrase": "process_accounting"}, {"score": 0.00418862323286423, "phrase": "entire_spectrum"}, {"score": 0.004081385289516914, "phrase": "significant_effort"}, {"score": 0.003925633992809873, "phrase": "software_repositories"}, {"score": 0.0038499929374478125, "phrase": "relevant_assessments"}, {"score": 0.0037513920123532097, "phrase": "concerted_set"}, {"score": 0.00372713741845688, "phrase": "visualization_tools"}, {"score": 0.0035616743422949766, "phrase": "scm_systems"}, {"score": 0.0034817084307034955, "phrase": "generic_way"}, {"score": 0.00342568771304873, "phrase": "source_code"}, {"score": 0.0034035317633176352, "phrase": "different_levels"}, {"score": 0.003348764681887211, "phrase": "different_perspectives"}, {"score": 0.00325238798404366, "phrase": "visual_representations"}, {"score": 0.0031281730014429666, "phrase": "code_models"}, {"score": 0.0030778231027679434, "phrase": "specific_questions"}, {"score": 0.003018468582368033, "phrase": "detailed_code_developer_perspective"}, {"score": 0.0029602552900111407, "phrase": "system_architects"}, {"score": 0.002941100683384888, "phrase": "project_managers"}, {"score": 0.002893753089970741, "phrase": "concrete_implementation"}, {"score": 0.0028564228386290615, "phrase": "corresponding_visual_representations"}, {"score": 0.002828740624702789, "phrase": "file_view"}, {"score": 0.0028104345972072534, "phrase": "code_change"}, {"score": 0.0027922467043592597, "phrase": "line_level"}, {"score": 0.0027741761880779535, "phrase": "multiple_versions"}, {"score": 0.0027472888482450776, "phrase": "single_file"}, {"score": 0.002720661389788773, "phrase": "small_number"}, {"score": 0.0026768530320943063, "phrase": "project_view"}, {"score": 0.0026423134393535243, "phrase": "file_level"}, {"score": 0.0026252106881752067, "phrase": "complete_software_projects"}, {"score": 0.00233557144141627, "phrase": "single_screen"}, {"score": 0.002268287853885277, "phrase": "real_world"}, {"score": 0.0022536005664642294, "phrase": "industry-size_code_bases"}, {"score": 0.002224510044064184, "phrase": "concrete_findings"}, {"score": 0.002160419006055386, "phrase": "code_changes"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["SCM data mining", " software evolution", " software visualization"], "paper_abstract": "Configuration management tools have become well and widely accepted by the software industry. Software Configuration Management (SCM) systems hold minute information about the entire evolution of complex software systems and thus represent a good source for process accounting and auditing. However, it is still difficult to use the entire spectrum of information such tools maintain. Currently, significant effort is being done in the direction of mining this kind of software repositories for extracting data to support relevant assessments. In this article we propose a concerted set of visualization tools and techniques for the assessment of software evolution based on the information stored into SCM systems. Firstly, we introduce a generic way to obtain models of source code at different levels of detail and from different perspectives. Secondly, we propose a set of visual representations and techniques to efficiently and effectively depict the evolution of these code models. These techniques target specific questions and assessments, from the detailed code developer perspective to the overview required by system architects and project managers. We detail the concrete implementation of two such code models and corresponding visual representations. The file view describes code change at line level across multiple versions of a single file, or small number of files. The project view shows changes at file level across complete software projects. All our views share the same visual and interactive techniques, enabling users to easily switch among and correlate between them. We implement our visual techniques to quickly and compactly display and navigate the evolution of tens of thousands of artifacts on a single screen. We demonstrate our techniques with several use cases performed on real world, industry-size code bases and outline the concrete findings and ways our visualizations helped in understanding various types of code changes. (c) 2007 Published by Elsevier B.V.", "paper_title": "Visual assessment of software evolution", "paper_id": "WOS:000245796800002"}