{"auto_keywords": [{"score": 0.03762867376091313, "phrase": "drars"}, {"score": 0.022486001560525545, "phrase": "dsm"}, {"score": 0.015842541981818937, "phrase": "parallel_program"}, {"score": 0.010612387000973441, "phrase": "parallel_programs"}, {"score": 0.004775335634705251, "phrase": "distributed_shared_memory_systems"}, {"score": 0.004736164957690492, "phrase": "distributed"}, {"score": 0.004525629293824217, "phrase": "distributed_computers"}, {"score": 0.0044514440242754815, "phrase": "global_virtual_shared_memory"}, {"score": 0.004396600680348434, "phrase": "data_racing_bugs"}, {"score": 0.004236074477264556, "phrase": "multi-threaded_process"}, {"score": 0.0041666157975446564, "phrase": "physically_distributed_memory"}, {"score": 0.004132312946154097, "phrase": "earlier_tools"}, {"score": 0.0039813976794342, "phrase": "non-dsm_parallel_programs"}, {"score": 0.0038838500580958744, "phrase": "dsm_systems"}, {"score": 0.0037886833451021723, "phrase": "data_race_avoidance"}, {"score": 0.003757480190200645, "phrase": "replay_scheme"}, {"score": 0.0036653985479652854, "phrase": "debugging_parallel_programs"}, {"score": 0.0036052633308076933, "phrase": "multi-core_systems"}, {"score": 0.003531474887552889, "phrase": "novel_tool"}, {"score": 0.003473529187092258, "phrase": "consistency_protocol"}, {"score": 0.0034306925765832633, "phrase": "target_program"}, {"score": 0.003360464999544279, "phrase": "large_class"}, {"score": 0.0031193028729331667, "phrase": "manual_debugging"}, {"score": 0.0029194625087935345, "phrase": "deterministic_replay-type_function"}, {"score": 0.00276653157720066, "phrase": "run_time"}, {"score": 0.0026543514413663893, "phrase": "remaining_manual_debugging_task"}, {"score": 0.0025892330566358503, "phrase": "previous_debugging_methods"}, {"score": 0.0024535580495414783, "phrase": "specific_style"}, {"score": 0.0024333239726872604, "phrase": "programming_language"}, {"score": 0.0022306602656266545, "phrase": "real_experiments"}, {"score": 0.002203117204010397, "phrase": "eager_release_consistency_protocol"}, {"score": 0.002175913488493802, "phrase": "dsm_system"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Parallel program", " Distributed shared memory", " DSM", " Debugger", " Data race", " Access conflict", " Deterministic replay"], "paper_abstract": "Distributed shared memory (DSM) allows parallel programs to run on distributed computers by simulating a global virtual shared memory, but data racing bugs may easily occur when the threads of a multi-threaded process concurrently access the physically distributed memory. Earlier tools to help programmers locate data racing bugs in non-DSM parallel programs are not easily applied to DSM systems. This study presents the data race avoidance and replay scheme (DRARS) to assist debugging parallel programs on DSM or multi-core systems. DRARS is a novel tool which controls the consistency protocol of the target program, automatically preventing a large class of data racing bugs when the parallel program is subsequently run, obviating much of the need for manual debugging. For data racing bugs that cannot be avoided automatically, DRARS performs a deterministic replay-type function on DSM systems, faithfully reproducing the behavior of the parallel program during run time. Because one class of data racing bugs has already been eliminated, the remaining manual debugging task is greatly simplified. Unlike previous debugging methods, DRARS does not require that the parallel program be written in a specific style or programming language. Moreover. DRARS can be implemented in most consistency protocols. In this paper, DRARS is realized and verified in real experiments using the eager release consistency protocol on a DSM system with various applications. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Data race avoidance and replay scheme for developing and debugging parallel programs on distributed shared memory systems", "paper_id": "WOS:000287350600002"}