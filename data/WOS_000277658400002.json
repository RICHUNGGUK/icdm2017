{"auto_keywords": [{"score": 0.027457111799361052, "phrase": "mlton"}, {"score": 0.00481495049065317, "phrase": "large-scale_software_systems"}, {"score": 0.004531637625717547, "phrase": "meaningful_semantics"}, {"score": 0.004497410940849537, "phrase": "safe_reexecution"}, {"score": 0.0044634416051962545, "phrase": "multithreaded_code"}, {"score": 0.0038938807148174975, "phrase": "meaningful_earlier_state"}, {"score": 0.0037918465913284478, "phrase": "data_inconsistencies"}, {"score": 0.0036093693971289754, "phrase": "consistent_global_checkpoint"}, {"score": 0.0035415392642831616, "phrase": "thread_interactions"}, {"score": 0.0033329032920236994, "phrase": "safe_and_efficient_checkpointing_mechanism"}, {"score": 0.00330770035909988, "phrase": "concurrent_ml"}, {"score": 0.0031604223680801774, "phrase": "transient_faults"}, {"score": 0.0031010029460927864, "phrase": "new_linguistic_abstraction"}, {"score": 0.002985484575498061, "phrase": "per-thread_monitors"}, {"score": 0.002929344511491418, "phrase": "globally_consistent_checkpoints"}, {"score": 0.002907184330345933, "phrase": "safe_global_states"}, {"score": 0.00286336417751658, "phrase": "lightweight_monitoring"}, {"score": 0.002841701708055512, "phrase": "communication_events"}, {"score": 0.0026945722090537397, "phrase": "formal_characterization"}, {"score": 0.002623881637290192, "phrase": "detailed_description"}, {"score": 0.002497470177389344, "phrase": "standard_ml."}, {"score": 0.002386181960126766, "phrase": "server-style_cml_applications"}, {"score": 0.002350196395175188, "phrase": "web_server"}, {"score": 0.0023235629819760018, "phrase": "windowing_toolkit"}, {"score": 0.0021453734588569823, "phrase": "viable_mechanism"}, {"score": 0.002121056250381627, "phrase": "safe_checkpoints"}], "paper_keywords": [""], "paper_abstract": "Transient faults that arise in large-scale software systems can often be repaired by reexecuting the code in which they occur. Ascribing a meaningful semantics for safe reexecution in multithreaded code is not obvious, however. For a thread to reexecute correctly a region of code, it must ensure that all other threads that have witnessed its unwanted effects within that region are also reverted to a meaningful earlier state. If not done properly, data inconsistencies and other undesirable behavior might result. However, automatically determining what constitutes a consistent global checkpoint is not straightforward because thread interactions are a dynamic properly of the program. In this paper, we present a safe and efficient checkpointing mechanism for Concurrent ML (CM L) that can be used to recover from transient faults. We introduce a new linguistic abstraction, called stabilizers, that permits the specification of per-thread monitors and the restoration of globally consistent checkpoints. Safe global states are computed through lightweight monitoring of communication events among threads (e.g., message-passing operations or updates to shared variables). We present a formal characterization of its design, and provide a detailed description of its implementation within MLton, a whole-program optimizing compiler for Standard ML. Our experimental results on microbenchmarks as well as several realistic, multithreaded, server-style CML applications, including a web server and a windowing toolkit, show that the overheads to use stabilizers are small, and lead us to conclude that they are a viable mechanism for defining safe checkpoints in concurrent functional programs.(1)", "paper_title": "Lightweight checkpointing for concurrent ML", "paper_id": "WOS:000277658400002"}