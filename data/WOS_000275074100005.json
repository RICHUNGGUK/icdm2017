{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "ott"}, {"score": 0.036385594120006304, "phrase": "proof_assistant_code"}, {"score": 0.004677032188041644, "phrase": "working_semanticist"}, {"score": 0.004638354165775803, "phrase": "semantic_definitions"}, {"score": 0.004599994523941615, "phrase": "full-scale_programming_languages"}, {"score": 0.0043401761815767, "phrase": "available_metalanguages"}, {"score": 0.004146327465630697, "phrase": "informal_mathematics"}, {"score": 0.0040949726088047225, "phrase": "formal_mathematics"}, {"score": 0.003863568356785813, "phrase": "large_definitions"}, {"score": 0.003424905100387569, "phrase": "coq"}, {"score": 0.003396500082053222, "phrase": "hol"}, {"score": 0.0032717489668326275, "phrase": "production-quality_typesetting"}, {"score": 0.003231201258675141, "phrase": "ocaml"}, {"score": 0.003177892611195514, "phrase": "main_innovations"}, {"score": 0.0028640745158229875, "phrase": "binding_structures"}, {"score": 0.0026354246446771324, "phrase": "modular_specifications"}, {"score": 0.002581165831422692, "phrase": "tapl_text"}, {"score": 0.0024656866249273125, "phrase": "large_fragment"}, {"score": 0.00235536166148219, "phrase": "mechanised_proofs"}, {"score": 0.00224061675049049, "phrase": "phase_change"}, {"score": 0.0021492686054379755, "phrase": "heroic_effort"}, {"score": 0.0021225958499898182, "phrase": "rigorous_semantic_definitions"}, {"score": 0.0021049977753042253, "phrase": "realistic_languages"}], "paper_keywords": [""], "paper_abstract": "Semantic definitions of full-scale programming languages are rarely given, despite the many potential benefits. Partly this is because the available metalanguages for expressing semantics usually either (LTEX)-T-A for informal mathematics or the formal mathematics of a proof assistant make it Much harder than necessary to work with large definitions. We present a metalanguage specifically designed for this problem, and a tool, Ott, that sanity-checks Such definitions and compiles them into proof assistant code for Coq, HOL, and Isabelle/HOL, together with (LTEX)-T-A code for production-quality typesetting, and OCaml boilerplate. The main innovations are (1) metalanguage design to make definitions concise, and easy to read and edit: (2) an expressive but intuitive metalanguage for specifying binding structures; and (3) compilation to proof assistant code. This has been tested ill Substantial ease Studies, including modular Specifications of calculi from the TAPL text, a Lightweight Java with Java JSR 277/294 module system proposals, and a large fragment of OCaml (OCaml(light), 310 rules). with mechanised proofs of various soundness results. Our aim with this work is to enable a phase change: making it feasible to work routinely, without heroic effort, With rigorous semantic definitions of realistic languages.", "paper_title": "Ott: Effective tool support for the working semanticist", "paper_id": "WOS:000275074100005"}