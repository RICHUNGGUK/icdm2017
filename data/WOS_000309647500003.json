{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "embedded_software"}, {"score": 0.004723847090183984, "phrase": "system_development"}, {"score": 0.00459039896577789, "phrase": "wrong_behavior"}, {"score": 0.004525088883501587, "phrase": "software-an_activity"}, {"score": 0.004334657104697421, "phrase": "complex_activity"}, {"score": 0.004252602474733162, "phrase": "real-time_embedded_systems"}, {"score": 0.004112711391952791, "phrase": "physical_world"}, {"score": 0.004054169947971483, "phrase": "heavy_use"}, {"score": 0.0037377733149169573, "phrase": "non-linear_control_flow"}, {"score": 0.0034459835582278746, "phrase": "debugging_embedded_systems"}, {"score": 0.0033166379485150507, "phrase": "control_flows_offline"}, {"score": 0.0031018195951638882, "phrase": "data_tracing_part"}, {"score": 0.0029569247903654477, "phrase": "interrupt_behavior"}, {"score": 0.00283229915062791, "phrase": "observed_principle"}, {"score": 0.0028053237950173508, "phrase": "return_address_clustering"}, {"score": 0.00276534038425712, "phrase": "formal_model"}, {"score": 0.002739001004969201, "phrase": "quantitative_reasoning"}, {"score": 0.002699960312990493, "phrase": "tracing_mechanism"}, {"score": 0.002661474607275484, "phrase": "presented_heuristic"}, {"score": 0.0024652715040303416, "phrase": "non-optimal_selector_functions"}, {"score": 0.0023388183537341213, "phrase": "equal_portion"}, {"score": 0.0022617389804167943, "phrase": "return_address"}, {"score": 0.0022188370388602813, "phrase": "best_results"}, {"score": 0.002176747110119268, "phrase": "crown_copyright"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Embedded Systems", " Record and Replay", " Debugging", " Tracing"], "paper_abstract": "During the system development, developers often must correct wrong behavior in the software-an activity colloquially called program debugging. Debugging is a complex activity, especially in real-time embedded systems because such systems interact with the physical world and make heavy use of interrupts for timing and driving I/O devices. Debugging interrupts is difficult, because they cause non-linear control flow in programs which is hard to reproduce in software. Record/replay mechanisms have proven their use to debugging embedded systems, because they provide means to recreate control flows offline where they can be debugged. In this work, we present the data tracing part of the record/replay mechanism that is specifically targeted to record interrupt behavior. To tune our tracing mechanism, we use the observed principle of return address clustering and a formal model for quantitative reasoning about the tracing mechanism. The presented heuristic and mechanisms show surprisingly good results-with higher fingerprint widths an 800 percent speedup on the selector function and a 300 percent reduction on duplicates for non-optimal selector functions-considering the leanness of the approach. Using an equal portion for the fingerprint and for the return address lead to the best results in our experiments. Crown Copyright (c) 2012 Published by Elsevier B.V. All rights reserved.", "paper_title": "Tracing and recording interrupts in embedded software", "paper_id": "WOS:000309647500003"}