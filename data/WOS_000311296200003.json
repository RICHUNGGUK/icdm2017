{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "transaction_checkpointing_and_recovery"}, {"score": 0.004691136491297242, "phrase": "large_fraction"}, {"score": 0.004587535692463736, "phrase": "memory_transactions"}, {"score": 0.004553510708976456, "phrase": "representative_programs"}, {"score": 0.004338390136272005, "phrase": "aborts_inside_long_running_transactions"}, {"score": 0.0041642891310893, "phrase": "tm_programming_model"}, {"score": 0.004087469540575263, "phrase": "finegrained_locking"}, {"score": 0.004027031316965272, "phrase": "large_critical_sections"}, {"score": 0.0039822874870125095, "phrase": "large_transactions"}, {"score": 0.0038510053729959074, "phrase": "wasted_work"}, {"score": 0.003737934295442975, "phrase": "practical_transaction_checkpoint"}, {"score": 0.0037101871762082153, "phrase": "recovery_scheme"}, {"score": 0.0035216195857272403, "phrase": "local_context"}, {"score": 0.003405472159599445, "phrase": "dynamic_program_point"}, {"score": 0.003256526411907174, "phrase": "state_saving"}, {"score": 0.0031845067058084583, "phrase": "checkpoint_operations"}, {"score": 0.00307944332532505, "phrase": "transactions_body"}, {"score": 0.002847540262784593, "phrase": "runtime_system"}, {"score": 0.0028053842615436706, "phrase": "checkpointed_states"}, {"score": 0.0027331033178323145, "phrase": "right_checkpointed_state"}, {"score": 0.0026726283357752585, "phrase": "particular_transactional_access"}, {"score": 0.0024075916292945715, "phrase": "checkpoint_generation"}, {"score": 0.002389696110283506, "phrase": "optimization_scheme"}, {"score": 0.002363101338529545, "phrase": "llvm_compiler"}, {"score": 0.002345535736297701, "phrase": "runtime_support"}, {"score": 0.002217880187104576, "phrase": "upto_several_orders"}, {"score": 0.0022013916728990564, "phrase": "magnitude_reduction"}, {"score": 0.0021526564019119466, "phrase": "significant_execution_time_speedups"}, {"score": 0.002128694000627911, "phrase": "plain_transactional_programs"}], "paper_keywords": ["software transactional memory", " checkpointing", " continuations"], "paper_abstract": "Several studies have shown that a large fraction of the work performed inside memory transactions in representative programs is wasted due to the transaction experiencing a conflict and aborting. Aborts inside long running transactions are especially influential to performance and the simplicity of the TM programming model (relative to using finegrained locking) in synchronizing large critical sections means that large transactions are common and this exacerbates the problem of wasted work. In this paper we present a practical transaction checkpoint and recovery scheme in which transactions that experience a conflict can restore their state (including the local context in which they were executing) to some dynamic program point before this access and begin execution from that point. This state saving and restoration is implemented by checkpoint operations that are generated by a compiler into the transactions body and are also optimized to reduce the amount of state that is saved and restored. We also describe a runtime system that manages these checkpointed states and orchestrates the restoration of the right checkpointed state for a conflict on a particular transactional access. Moreover the synthesis of these save & restore operations, their optimization and invocation at runtime are completely transparent to the programmer. We have implemented the checkpoint generation and optimization scheme in the LLVM compiler and runtime support for the TL2 STM system. Our experiments indicate that for many parallel programs using such checkpoint recovery schemes can result in upto several orders of magnitude reduction in number of aborts and significant execution time speedups relative to plain transactional programs for the same number of threads.", "paper_title": "Safe Compiler-driven Transaction Checkpointing and Recovery", "paper_id": "WOS:000311296200003"}