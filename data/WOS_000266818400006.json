{"auto_keywords": [{"score": 0.04358136766574205, "phrase": "task_state"}, {"score": 0.00481495049065317, "phrase": "cross-layer_customization"}, {"score": 0.004776417866116047, "phrase": "rapid"}, {"score": 0.004624751696958501, "phrase": "multitasked_embedded_systems"}, {"score": 0.0045876189888390895, "phrase": "preemptive_multitasking"}, {"score": 0.0043533862892678864, "phrase": "frequent_and_asynchronous_context_switches"}, {"score": 0.004064958518350867, "phrase": "large_number"}, {"score": 0.004032302251481604, "phrase": "memory_transfer_instructions"}, {"score": 0.003935892934907777, "phrase": "task_responsiveness"}, {"score": 0.0039042694651106884, "phrase": "application_throughput"}, {"score": 0.003704797078215222, "phrase": "cross-layer_customization_framework"}, {"score": 0.0036454883790271843, "phrase": "close_cooperation"}, {"score": 0.0035439655241057207, "phrase": "hardware_architecture"}, {"score": 0.003515479934694842, "phrase": "rapid_and_low-cost_task_switch"}, {"score": 0.003403801095792972, "phrase": "state_liveness"}, {"score": 0.0032956583072431423, "phrase": "minimal_amount"}, {"score": 0.0032428780373184207, "phrase": "task_preemption"}, {"score": 0.0031398318568608505, "phrase": "application-aware_state_preservation"}, {"score": 0.0030646951765987414, "phrase": "compiler-generated_custom_routines"}, {"score": 0.00301560261110296, "phrase": "extremely_small_live_context"}, {"score": 0.0029913511336659327, "phrase": "judiciously_selected_points"}, {"score": 0.0029553380263320195, "phrase": "application_code"}, {"score": 0.0029197572138773237, "phrase": "second_technique"}, {"score": 0.002838387600282891, "phrase": "os-controlled_register_file_mapping"}, {"score": 0.0027929100418926725, "phrase": "rapid_context_switch"}, {"score": 0.0027370835853738626, "phrase": "small_fraction"}, {"score": 0.0027041233221381756, "phrase": "register_file"}, {"score": 0.0026715589067557526, "phrase": "single_clock_cycle"}, {"score": 0.002639385610609024, "phrase": "context_switch"}, {"score": 0.0025866199378466754, "phrase": "memory_transfers"}, {"score": 0.002494279207996077, "phrase": "live_state"}, {"score": 0.0024444073418288703, "phrase": "aggressively_replicated_register_files"}, {"score": 0.002319346861878611, "phrase": "hardware_cost"}, {"score": 0.0021917966722180132, "phrase": "novel_mechanisms"}, {"score": 0.002165388556451298, "phrase": "significant_improvement"}, {"score": 0.0021479597698614373, "phrase": "task_response_time"}, {"score": 0.0021049977753042253, "phrase": "context-switch_cost"}], "paper_keywords": ["Algorithms", " design", " experimentation", " performance"], "paper_abstract": "Preemptive multitasking is widely used in many low-cost and real-time embedded applications for its superior hardware utilization. The frequent and asynchronous context switches, however, require the preservation and restoration of the task state, thus resulting in a large number of memory transfer instructions. As a consequence, task responsiveness and application throughput can be significantly deteriorated. To address this problem we propose a cross-layer customization framework which through the close cooperation of compiler, OS, and hardware architecture achieves rapid and low-cost task switch. Application information extracted during compile-time regarding state liveness is exploited in order to preserve a minimal amount of task state on task preemption. We introduce two complementary techniques to implement the application-aware state preservation. The first technique utilizes compiler-generated custom routines which preserve/restore an extremely small live context at judiciously selected points in the application code. The second technique requires more sophisticated hardware support. It employs an OS-controlled register file mapping to achieve a rapid context switch. By mapping a small fraction of the register file in a single clock cycle, a context switch is achieved requiring no memory transfers for the majority of cases to preserve/restore the live state. The effect of aggressively replicated register files, where each task is given its own replica, is achieved with the hardware cost of only adding from 25% to 50% extra physical registers. Through the utilization of these novel mechanisms, a significant improvement on task response time is achieved as the context-switch cost is minimized.", "paper_title": "Cross-Layer Customization for Rapid and Low-Cost Task Preemption in Multitasked Embedded Systems", "paper_id": "WOS:000266818400006"}