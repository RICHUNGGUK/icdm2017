{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "synchronization_faults"}, {"score": 0.037876599612591905, "phrase": "tsafe"}, {"score": 0.018077306018701046, "phrase": "verification_approach"}, {"score": 0.01034028768631076, "phrase": "concurrency_controllers"}, {"score": 0.00771673794279822, "phrase": "concurrency_controller_design_pattern"}, {"score": 0.005050693313168606, "phrase": "presented_design"}, {"score": 0.004783607451937166, "phrase": "air_traffic_control_software"}, {"score": 0.004645057834614705, "phrase": "increasing_level"}, {"score": 0.004584769330512473, "phrase": "critical_infrastructures"}, {"score": 0.004525259757290933, "phrase": "effective_ways"}, {"score": 0.0044374341132573936, "phrase": "critical_software_components"}, {"score": 0.004379828513102091, "phrase": "concurrent_components"}, {"score": 0.004184010117063648, "phrase": "thread_interleavings"}, {"score": 0.00398387063819657, "phrase": "experimental_study"}, {"score": 0.003919299546627271, "phrase": "model_checking_techniques"}, {"score": 0.0038431888954930083, "phrase": "critical_software"}, {"score": 0.0036473491893281125, "phrase": "automated_air_traffic_control_software_component"}, {"score": 0.0034276650497743603, "phrase": "modular_verification_strategy"}, {"score": 0.00320016832003312, "phrase": "finite_state_machines"}, {"score": 0.0031379788088249576, "phrase": "concurrency_controller"}, {"score": 0.0030769941082173314, "phrase": "arbitrary_numbers"}, {"score": 0.0030270771166811296, "phrase": "infinite_state_model"}, {"score": 0.002958546936891755, "phrase": "alv"}, {"score": 0.0028821186265508597, "phrase": "controller_classes"}, {"score": 0.0028446460307503343, "phrase": "interface_violations"}, {"score": 0.002816860758719358, "phrase": "finite_state_model"}, {"score": 0.002753076537673495, "phrase": "jpf"}, {"score": 0.0026907324647716395, "phrase": "thread_isolation"}, {"score": 0.002578662558305782, "phrase": "interface_verification"}, {"score": 0.0025038150103055823, "phrase": "verification_techniques"}, {"score": 0.00242319012632962, "phrase": "manual_fault_seeding"}, {"score": 0.002189347748410919, "phrase": "randomly_seeded_faults"}, {"score": 0.0021327478049969423, "phrase": "fault_classification"}], "paper_keywords": ["model checking", " concurrent programming", " synchronization", " design patterns", " interfaces"], "paper_abstract": "The increasing level of automation in critical infrastructures requires development of effective ways for finding faults in safety critical software components. Synchronization in concurrent components is especially prone to errors and, due to difficulty of exploring all thread interleavings, it is difficult to find synchronization faults. In this paper we present an experimental study demonstrating the effectiveness of model checking techniques in finding synchronization faults in safety critical software when they are combined with a design for verification approach. We based our experiments on an automated air traffic control software component called the Tactical Separation Assisted Flight Environment (TSAFE). We first reengineered TSAFE using the concurrency controller design pattern. The concurrency controller design pattern enables a modular verification strategy by decoupling the behaviors of the concurrency controllers from the behaviors of the threads that use them using interfaces specified as finite state machines. The behavior of a concurrency controller is verified with respect to arbitrary numbers of threads using the infinite state model checking techniques implemented in the Action Language Verifier (ALV). The threads which use the controller classes are checked for interface violations using the finite state model checking techniques implemented in the Java Path Finder (JPF). We present techniques for thread isolation which enables us to analyze each thread in the program separately during interface verification. We conducted two sets of experiments using these verification techniques. First, we created 40 faulty versions of TSAFE using manual fault seeding. During this exercise we also developed a classification of faults that can be found using the presented design for verification approach. Next, we generated another 100 faulty versions of TSAFE using randomly seeded faults that were created automatically based on this fault classification. We used both infinite and finite state verification techniques for finding the seeded faults. The results of our experiments demonstrate the effectiveness of the presented design for verification approach in eliminating synchronization faults.", "paper_title": "Eliminating synchronization faults in air traffic control software via design for verification with concurrency controllers", "paper_id": "WOS:000249586000002"}