{"auto_keywords": [{"score": 0.04916281891691642, "phrase": "cache-memory_interface"}, {"score": 0.04122234602538828, "phrase": "full_fault_resilience"}, {"score": 0.025056099022670694, "phrase": "cache_block"}, {"score": 0.00481495049065317, "phrase": "relaxed_synchronization"}, {"score": 0.004654826737377134, "phrase": "multicore_platforms"}, {"score": 0.004610058444728656, "phrase": "significant_speedup"}, {"score": 0.004435230698216773, "phrase": "increased_reliability_problems"}, {"score": 0.004287680323820891, "phrase": "device_size"}, {"score": 0.004225950334493496, "phrase": "projected_elevation"}, {"score": 0.004185289462328125, "phrase": "fault_rate"}, {"score": 0.004085333687668526, "phrase": "diverse_behavior"}, {"score": 0.004046020290832207, "phrase": "fault_manifestation"}, {"score": 0.0039685202936462815, "phrase": "highly_efficient_solutions"}, {"score": 0.0038364365168131586, "phrase": "checkpointing_strategies"}, {"score": 0.0037811784409635023, "phrase": "sizable_overhead"}, {"score": 0.003744780941673966, "phrase": "checkpointing_execution_results"}, {"score": 0.0036026484429137998, "phrase": "value_checking"}, {"score": 0.003350480663660326, "phrase": "integrated_fault_detection"}, {"score": 0.0033182152378613767, "phrase": "checkpointing_framework"}, {"score": 0.0032546105164772995, "phrase": "comparison_and_checkpointing_process"}, {"score": 0.003100865267124765, "phrase": "single_cache"}, {"score": 0.0030414140732789186, "phrase": "execution_results"}, {"score": 0.0027741761880779535, "phrase": "execution_faults"}, {"score": 0.002707829887747594, "phrase": "unconfirmed_data"}, {"score": 0.0023990982005125763, "phrase": "strict_execution_synchronization_model"}, {"score": 0.0022202042044679984, "phrase": "cache_design"}, {"score": 0.0021049977753042253, "phrase": "intermediate_values"}], "paper_keywords": ["Checkpointing", " fault detection", " multicore reliability", " recovery", " redundant execution"], "paper_abstract": "While multicore platforms promise significant speedup for many current applications, they also suffer from increased reliability problems as a result of ever scaling device size. The projected elevation in fault rate, together with the diverse behavior of fault manifestation, argues for highly efficient solutions of full fault resilience. Traditional duplication and checkpointing strategies typically impose sizable overhead in checkpointing execution results, or in constantly synchronizing two threads for value checking. To reduce such overhead while at the same time delivering full fault resilience, we propose an integrated fault detection and checkpointing framework, wherein the comparison and checkpointing process is performed at the cache-memory interface. By sharing a single cache between two duplicated threads, execution results can be directly verified in the cache before being written back, thus strictly protecting the memory against execution faults. Meanwhile, as unconfirmed data are allowed to be written into the cache, one thread can run well ahead of the other, thus relaxing the straightjacket of the strict execution synchronization model. If a cache block is constantly updated, further synchronization relaxation can be achieved through extending the cache design to duplicate a cache block and skip the comparison of the intermediate values.", "paper_title": "Full Fault Resilience and Relaxed Synchronization Requirements at the Cache-Memory Interface", "paper_id": "WOS:000294869500006"}