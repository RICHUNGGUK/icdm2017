{"auto_keywords": [{"score": 0.04776606071215511, "phrase": "symbolic_execution"}, {"score": 0.040062918732317924, "phrase": "initial_context"}, {"score": 0.00481495049065317, "phrase": "symbolic_execution_of_multithreaded_programs"}, {"score": 0.004767546015485477, "phrase": "arbitrary_program_contexts"}, {"score": 0.004515004397496303, "phrase": "multithreaded_program"}, {"score": 0.00442651096522781, "phrase": "arbitrary_program_context"}, {"score": 0.004212759658511567, "phrase": "deep_code_paths"}, {"score": 0.004171259063201874, "phrase": "multithreaded_programs"}, {"score": 0.004089475312474684, "phrase": "symbolic_engine"}, {"score": 0.003989487818395848, "phrase": "program_contexts"}, {"score": 0.0038919354605673104, "phrase": "key_challenge"}, {"score": 0.003778004256546193, "phrase": "reasonable_precision-an_overly_approximate_model"}, {"score": 0.00320826350799124, "phrase": "first_place"}, {"score": 0.0031297538950335233, "phrase": "context-specific_dataflow_analysis"}, {"score": 0.0029344771385297137, "phrase": "common_causes"}, {"score": 0.0029055323737809825, "phrase": "infeasible-path_explosion"}, {"score": 0.002724207384182295, "phrase": "memory_state"}, {"score": 0.002618278365749875, "phrase": "simple_questions"}, {"score": 0.00240662380079115, "phrase": "novel_algorithm"}, {"score": 0.0023710856920150574, "phrase": "symbolic_synchronization"}, {"score": 0.0022010965931147735, "phrase": "underlying_smt_solver"}, {"score": 0.002157857111130435, "phrase": "initial_experiments"}], "paper_keywords": ["static analysis", " symbolic execution", " multithreading"], "paper_abstract": "We describe an algorithm to perform symbolic execution of a multithreaded program starting from an arbitrary program context. We argue that this can enable more efficient symbolic exploration of deep code paths in multithreaded programs by allowing the symbolic engine to jump directly to program contexts of interest. The key challenge is modeling the initial context with reasonable precision-an overly approximate model leads to exploration of many infeasible paths during symbolic execution, while a very precise model would be so expensive to compute that computing it would defeat the purpose of jumping directly to the initial context in the first place. We propose a context-specific dataflow analysis that approximates the initial context cheaply, but precisely enough to avoid some common causes of infeasible-path explosion. This model is necessarily approximate it may leave portions of the memory state unconstrained, leaving our symbolic execution unable to answer simple questions such as \"which thread holds lock A?\". For such cases, we describe a novel algorithm for evaluating symbolic synchronization during symbolic execution. Our symbolic execution semantics are sound and complete up to the limits of the underlying SMT solver. We describe initial experiments on an implementation in Cloud9.", "paper_title": "Symbolic Execution of Multithreaded Programs from Arbitrary Program Contexts", "paper_id": "WOS:000348907400028"}