{"auto_keywords": [{"score": 0.03166862986068805, "phrase": "many-core_architectures"}, {"score": 0.02988869905879018, "phrase": "multi-core_architectures"}, {"score": 0.029420333683948755, "phrase": "addto_algorithm"}, {"score": 0.00481495049065317, "phrase": "multi-core_and_many-core_architectures"}, {"score": 0.004586531354697466, "phrase": "finite_element_methods"}, {"score": 0.004252793172311465, "phrase": "gpu"}, {"score": 0.00394264312173188, "phrase": "finite_element"}, {"score": 0.0038375280115736958, "phrase": "increased_performance"}, {"score": 0.0036159990127332315, "phrase": "specific_and_diverse_algorithmic_choices"}, {"score": 0.003519561814102764, "phrase": "high-level_structure"}, {"score": 0.003334309053314909, "phrase": "high_performance"}, {"score": 0.0032806521851034766, "phrase": "single_architecture"}, {"score": 0.0031759067385562553, "phrase": "performance_portability"}, {"score": 0.0031417377608722, "phrase": "data_structures"}, {"score": 0.0030911702059432224, "phrase": "redundant_data"}, {"score": 0.003057910095857785, "phrase": "enable_coalesced_memory_accesses"}, {"score": 0.002944284514509205, "phrase": "redundancy-free_data_structures"}, {"score": 0.0027443174539994925, "phrase": "global_assembly"}, {"score": 0.0026280534600940137, "phrase": "local_matrix_approach"}, {"score": 0.00235843888868088, "phrase": "correct_choice"}, {"score": 0.0023079225317714815, "phrase": "data_structure"}, {"score": 0.002246292543825748, "phrase": "spectral_element_methods"}, {"score": 0.0022101055924375725, "phrase": "discontinuous_galerkin_methods"}, {"score": 0.0021863046959469863, "phrase": "modern_high-performance_architectures"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["FEM", " GPU", " multi-core", " many-core"], "paper_abstract": "We demonstrate that radically differing implementations of finite element methods (FEMs) are needed on multi-core (CPU) and many-core (GPU) architectures, if their respective performance potential is to be realised. Our numerical investigations using a finite element advectiondiffusion solver show that increased performance on each architecture can only be achieved by committing to specific and diverse algorithmic choices that cut across the high-level structure of the implementation. Making these commitments to achieve high performance for a single architecture leads to a loss of performance portability. Data structures that include redundant data but enable coalesced memory accesses are faster on many-core architectures, whereas redundancy-free data structures that are accessed indirectly are faster on multi-core architectures. The Addto algorithm for global assembly is optimal on multi-core architectures, whereas the Local Matrix Approach is optimal on many-core architectures despite requiring more computation than the Addto algorithm. These results demonstrate the value in making the correct choice of algorithm and data structure when implementing FEMs, spectral element methods and low-order discontinuous Galerkin methods on modern high-performance architectures. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "Finite element assembly strategies on multi-core and many-core architectures", "paper_id": "WOS:000312150500005"}