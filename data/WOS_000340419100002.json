{"auto_keywords": [{"score": 0.04066031201468573, "phrase": "benchmark_framework"}, {"score": 0.010612452814117705, "phrase": "bench"}, {"score": 0.004769702911065878, "phrase": "software_engineering_frameworks"}, {"score": 0.004658426838467567, "phrase": "large_collections"}, {"score": 0.004549734943142138, "phrase": "structural_invariants"}, {"score": 0.004120130206000757, "phrase": "closely_related_benchmarks"}, {"score": 0.004023947242621452, "phrase": "query_engine_implementation_strategies"}, {"score": 0.0036958398682001015, "phrase": "semantically_rich_ways"}, {"score": 0.0033308077968426937, "phrase": "data_format"}, {"score": 0.0032838979278935814, "phrase": "schema_constraints"}, {"score": 0.003207173639414978, "phrase": "different_workload"}, {"score": 0.003176989124468379, "phrase": "paramount"}, {"score": 0.0031174595932694036, "phrase": "benchmark_frameworks"}, {"score": 0.002987557906013826, "phrase": "individual_benchmarks"}, {"score": 0.002822712709335093, "phrase": "benchmark_component"}, {"score": 0.002769805263310232, "phrase": "overarching_ecosystem"}, {"score": 0.0027178867838199734, "phrase": "detailed_case_study"}, {"score": 0.002580061425699194, "phrase": "ten_individual_benchmarks"}, {"score": 0.00254372317522412, "phrase": "xml"}, {"score": 0.0025197429766616914, "phrase": "xquery"}, {"score": 0.0024960069794216977, "phrase": "xml_schema"}, {"score": 0.0024608291385978926, "phrase": "psm"}, {"score": 0.002414684268765849, "phrase": "temporal_extensions"}, {"score": 0.002358220053411644, "phrase": "second_case_study"}, {"score": 0.0022492129111567824, "phrase": "potential_benefits"}, {"score": 0.0022070310530794097, "phrase": "tpc_family"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["benchmarks", " XML", " temporal databases"], "paper_abstract": "Software engineering frameworks tame the complexity of large collections of classes by identifying structural invariants, regularizing interfaces, and increasing sharing across the collection. We wish to appropriate these benefits for families of closely related benchmarks, say for evaluating query engine implementation strategies. We introduce the notion of a benchmark framework, an ecosystem of benchmarks that are related in semantically rich ways and enabled by organizing principles. A benchmark framework is realized by iteratively changing one individual benchmark into another, say by modifying the data format, adding schema constraints, or instantiating a different workload. Paramount to our notion of benchmark frameworks are the ease of describing the differences between individual benchmarks and the utility of methods to validate the correctness of each benchmark component by exploiting the overarching ecosystem. As a detailed case study, we introduce Bench, a benchmark framework consisting of ten individual benchmarks, spanning XML, XQuery, XML Schema, and PSM, along with temporal extensions to each. The second case study examines the Mining Unstructured Data benchmark framework, and the third examines the potential benefits of rendering the TPC family as a benchmark framework. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Benchmark frameworks and tau Bench", "paper_id": "WOS:000340419100002"}