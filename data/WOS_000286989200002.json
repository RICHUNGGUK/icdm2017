{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "higher-order_theorem_provers"}, {"score": 0.004718897469501381, "phrase": "correct_software"}, {"score": 0.0045876189888390895, "phrase": "especially_code_generation"}, {"score": 0.004370973501074594, "phrase": "sophisticated_algorithms"}, {"score": 0.004318422955036175, "phrase": "efficient_code"}, {"score": 0.004081385289516914, "phrase": "compiler_transformations"}, {"score": 0.003999907278478564, "phrase": "formal_notion"}, {"score": 0.0036454883790271843, "phrase": "certificate_checker"}, {"score": 0.003282383509542342, "phrase": "concrete_compilation_algorithms"}, {"score": 0.003040050100579337, "phrase": "involved_languages"}, {"score": 0.0027929100418926725, "phrase": "small_and_well_understood_trusted_computing_base"}, {"score": 0.0027370835853738626, "phrase": "efficient_certificate_checking"}, {"score": 0.002494279207996077, "phrase": "computational_reflection"}, {"score": 0.0024149629835339926, "phrase": "executable_way"}, {"score": 0.0022546720211200893, "phrase": "checking_process"}, {"score": 0.0022095803687183107, "phrase": "implemented_prototype_performing_code_generation"}, {"score": 0.002182976006380117, "phrase": "coq"}, {"score": 0.0021479597698614373, "phrase": "certificate_checkers"}, {"score": 0.0021220787047953093, "phrase": "typical_challenges"}], "paper_keywords": ["Translation validation", " Compiler correctness", " Theorem proving", " Coq", " Isabelle/HOL"], "paper_abstract": "Correct software requires compilers to work correctly. Especially code generation can be an error prone task, since it potentially uses sophisticated algorithms to produce efficient code. In this paper we present an approach to guarantee the correctness of compiler transformations with respect to a formal notion of correctness. We certify the results of each compilation run. With the help of a compiler generated certificate and a certificate checker, we verify the results of each compilation run automatically. Thereby we ensure the correctness of the compilation run without having to look at concrete compilation algorithms. We use higher-order theorem provers to check the certificates and to formally define syntax, and semantics of the involved languages as well as a criterion under which we regard a compilation as correct. The use of higher-order theorem provers ensures a small and well understood trusted computing base. The task of efficient certificate checking is especially crucial for the acceptance of certifying compilation. We present methods to facilitate this task, most notably by using computational reflection: We present small-in an executable way specified-evaluators that solve certain properties appearing in our certificates and are used to speed up certain subtasks in the checking process. We discuss an implemented prototype performing code generation. Using Coq and Isabelle/HOL as certificate checkers we highlight typical challenges and their solutions.", "paper_title": "Certifying compilers using higher-order theorem provers as certificate checkers", "paper_id": "WOS:000286989200002"}