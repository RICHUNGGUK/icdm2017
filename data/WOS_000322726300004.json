{"auto_keywords": [{"score": 0.04931481962834528, "phrase": "cetus"}, {"score": 0.04881146774921728, "phrase": "llvm"}, {"score": 0.00481495049065317, "phrase": "parallel_codes"}, {"score": 0.004514714250357749, "phrase": "high-performance_computing"}, {"score": 0.0043482604833437735, "phrase": "increasing_necessity"}, {"score": 0.004301834610818624, "phrase": "fault_tolerance"}, {"score": 0.004165497627464024, "phrase": "checkpoint_and_restart_techniques"}, {"score": 0.0038638811223100184, "phrase": "system_level"}, {"score": 0.003781772207256374, "phrase": "application_level"}, {"score": 0.0036422425344358037, "phrase": "interesting_alternative"}, {"score": 0.003451766520526601, "phrase": "different_environments"}, {"score": 0.003378385493203297, "phrase": "application-level_checkpointing_tools"}, {"score": 0.002937879003671346, "phrase": "user_code"}, {"score": 0.002875391177926809, "phrase": "kernel_routines"}, {"score": 0.0027102997281261733, "phrase": "automatic_checkpointing"}, {"score": 0.002681315076008658, "phrase": "parallel_applications"}, {"score": 0.0026384167183586015, "phrase": "cppc_application-level_checkpointing_framework"}, {"score": 0.002473560912156024, "phrase": "llvm._cetus"}, {"score": 0.0024339783012484032, "phrase": "java-based_compiler_infrastructure"}, {"score": 0.0023694065215394593, "phrase": "easy_to_use_and_clean_ir"}, {"score": 0.00234410113028844, "phrase": "api"}], "paper_keywords": ["Fault tolerance", " Checkpointing", " Parallel programming", " Message-passing", " Compiler support", " Cetus", " LLVM"], "paper_abstract": "With the evolution of high-performance computing, parallel applications have developed an increasing necessity for fault tolerance, most commonly provided by checkpoint and restart techniques. Checkpointing tools are typically implemented at one of two different abstraction levels: at the system level or at the application level. The latter has become an interesting alternative due to its flexibility and the possibility of operating in different environments. However, application-level checkpointing tools often require the user to manually insert checkpoints in order to ensure that certain requirements are met (e.g. forcing checkpoints to be taken at the user code and not inside kernel routines). This paper examines the transformations required to enable automatic checkpointing of parallel applications in the CPPC application-level checkpointing framework. These transformations have been implemented on two very different compiler infrastructures: Cetus and LLVM. Cetus is a Java-based compiler infrastructure aiming to provide an easy to use and clean IR and API for program transformation. LLVM is a low-level, SSA-based toolchain. The fundamental differences of both approaches are analyzed from the structural, behavioral and performance perspectives.", "paper_title": "Compiler-Assisted Checkpointing of Parallel Codes: The Cetus and LLVM Experience", "paper_id": "WOS:000322726300004"}