{"auto_keywords": [{"score": 0.04981057254655336, "phrase": "rule_based_specifications"}, {"score": 0.015161752998591193, "phrase": "cache_coherence_protocols"}, {"score": 0.011221404355411671, "phrase": "independence_relation"}, {"score": 0.008022293774534927, "phrase": "po_reduction"}, {"score": 0.00481495049065317, "phrase": "partial_order_reduction"}, {"score": 0.004577440795549049, "phrase": "murphi"}, {"score": 0.0045262653692203815, "phrase": "bluespec_language"}, {"score": 0.004400804926266097, "phrase": "unordered_rules"}, {"score": 0.004266794077108026, "phrase": "sequential_process"}, {"score": 0.004242868712089958, "phrase": "local_scope"}, {"score": 0.004219076936280787, "phrase": "specialized_communication_channels"}, {"score": 0.004125230994378402, "phrase": "multiple_fields"}, {"score": 0.004090577229368418, "phrase": "global_state"}, {"score": 0.0038559853156801094, "phrase": "partial_order_reductions"}, {"score": 0.003802135020791801, "phrase": "smaller_set"}, {"score": 0.0035539019235553897, "phrase": "earlier_work"}, {"score": 0.0034944094552943, "phrase": "suitable_algorithm"}, {"score": 0.0033879057307626328, "phrase": "symbolic_analysis"}, {"score": 0.003368901187735966, "phrase": "sat."}, {"score": 0.0032205608521157477, "phrase": "commonly_seen_characteristics"}, {"score": 0.003113601003720005, "phrase": "transactional_nature"}, {"score": 0.002727700630869639, "phrase": "sat-based_computation"}, {"score": 0.0025710670135348198, "phrase": "parameterized_instances"}, {"score": 0.0024856240785174444, "phrase": "sat-based_independence_computation"}, {"score": 0.002122866345896679, "phrase": "rule_based_systems"}, {"score": 0.0021049977753042253, "phrase": "efficient_and_effective_po_reduction_algorithms"}], "paper_keywords": [""], "paper_abstract": "Rule based specifications are popular for specifying protocols, such as cache coherence protocols specified in TLA+, Murphi, or the BlueSpec language. Specifications in these notations are a collection of unordered rules of the form guard -> atomic-updates. There is no notion of a sequential process with local scope or specialized communication channels, and each rule tends to update multiple fields of the global state. It is believed that partial order (PO) reduction, a powerful state space reduction technique, is difficult to achieve in such a setting. Partial order reductions attempt to visit a smaller set of states by selectively exploring a subset of all enabled transitions at each state, based on the independence of transitions. In earlier work, we have reported a suitable algorithm for this purpose, where the independence relation is computed using symbolic analysis and SAT. In this paper, we expand on this algorithm and show how to exploit some commonly seen characteristics of rule based specifications. First, many of these systems have a transactional nature, such as the request/grant transactions of cache coherence protocols. We show how to use this information while picking subsets of transitions at each state. Second, many of these systems are parameterized, and also exhibit symmetry. We show that, for such systems, the SAT-based computation of the independence relation between rules can be performed once and for all in a manner that is accurate for all parameterized instances of the protocol. Third, we show that sharpening the SAT-based independence computation through local invariants can aid PO reduction. Here, we propose a way by which users may guess these invariants: we can check these invariants and the property of interest in one combined phase under PO reduction (we prove that there is no circularity in this process). Our results indicate that with the above measures, rule based systems can have efficient and effective PO reduction algorithms.", "paper_title": "Exploiting symmetry and transactions for partial order reduction of rule based specifications", "paper_id": "WOS:000236941300015"}