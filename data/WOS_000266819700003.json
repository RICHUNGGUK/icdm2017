{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "haskell"}, {"score": 0.04684002413595463, "phrase": "session_types"}, {"score": 0.004267163206961948, "phrase": "client-server_communication"}, {"score": 0.003459191419478298, "phrase": "exotic_features"}, {"score": 0.0033295966773779174, "phrase": "minimal_modification"}, {"score": 0.003164376986014026, "phrase": "ml"}, {"score": 0.0031243284244636474, "phrase": "java"}, {"score": 0.003026391655379905, "phrase": "existing_haskell_concurrency_mechanisms"}, {"score": 0.0029691377785333872, "phrase": "multiple_communication_channels"}, {"score": 0.002931569771634119, "phrase": "recursive_session_types"}, {"score": 0.002750721367040336, "phrase": "unsafe_operations"}, {"score": 0.0026140878612307536, "phrase": "haskell's_safety_guarantees"}, {"score": 0.0024842242921857705, "phrase": "concurrent_calculus"}, {"score": 0.0024527767211457046, "phrase": "unsafe_communication_primitives"}, {"score": 0.0022434880661725493, "phrase": "session_types_layer"}, {"score": 0.0021049977753042253, "phrase": "channel-based_communication"}], "paper_keywords": ["Languages", " Session types", " concurrency", " Haskell", " type classes", " phantom types", " functional programming", " embedded type systems"], "paper_abstract": "We describe an implementation of session types in Haskell. Session types statically enforce that client-server communication proceeds according to protocols. They have been added to several concurrent calculi, but few implementations of session types are available. Our embedding takes advantage of Haskell where appropriate, but we rely on no exotic features. Thus our approach translates with minimal modification to other polymorphic, typed languages such as ML and Java. Our implementation works with existing Haskell concurrency mechanisms, handles multiple communication channels and recursive session types, and infers protocols automatically. While our implementation uses unsafe operations in Haskell, it does not violate Haskell's safety guarantees. We formalize this claim in a concurrent calculus with unsafe communication primitives over which we layer our implementation of session types, and we prove that the session types layer is safe. In particular, it enforces that channel-based communication follows consistent protocols.", "paper_title": "Haskell Session Types with (Almost) No Class", "paper_id": "WOS:000266819700003"}