{"auto_keywords": [{"score": 0.013219647041734794, "phrase": "program_versions"}, {"score": 0.013122443143966113, "phrase": "change_contracts"}, {"score": 0.00481495049065317, "phrase": "software_change_contracts"}, {"score": 0.00477924690801092, "phrase": "software_errors"}, {"score": 0.00470862827326028, "phrase": "incorrect_changes"}, {"score": 0.00465634671242413, "phrase": "incorrect_program_fixes"}, {"score": 0.004621813738791474, "phrase": "incorrect_feature_updates"}, {"score": 0.004486212539464774, "phrase": "intended_program_behavior"}, {"score": 0.004370814742381778, "phrase": "attractive_proposition"}, {"score": 0.004195418010131832, "phrase": "\"change_contracts"}, {"score": 0.0039674831861175935, "phrase": "program_contracts"}, {"score": 0.0037940502405699765, "phrase": "intended_behavior"}, {"score": 0.0037518852820756323, "phrase": "program_features"}, {"score": 0.003561205990687285, "phrase": "formal_semantics"}, {"score": 0.0034566143156030426, "phrase": "java_modeling_language"}, {"score": 0.0033550841271846065, "phrase": "behavioral_as_well_as_structural_changes"}, {"score": 0.003256526411907174, "phrase": "change_contract_language"}, {"score": 0.0031845067058084583, "phrase": "final-year_undergraduate_students"}, {"score": 0.0030113280682863234, "phrase": "writing_contracts"}, {"score": 0.002977835845437357, "phrase": "written_contracts"}, {"score": 0.002826383890518307, "phrase": "dynamic_and_static_checkers"}, {"score": 0.0026826140171754675, "phrase": "software_changes"}, {"score": 0.002268088741853586, "phrase": "buggy_method"}, {"score": 0.0022428442879034614, "phrase": "regression_errors"}, {"score": 0.002176887956041267, "phrase": "test_failure"}, {"score": 0.002136651746284283, "phrase": "production_code"}, {"score": 0.0021049977753042253, "phrase": "test_code"}], "paper_keywords": ["Languages", " Reliability", " Theory", " Verification", " Software changes", " dynamic checking", " static checking"], "paper_abstract": "Software errors often originate from incorrect changes, including incorrect program fixes, incorrect feature updates, and so on. Capturing the intended program behavior explicitly via contracts is thus an attractive proposition. In our recent work, we had espoused the notion of \"change contracts\" to express the intended program behavior changes across program versions. Change contracts differ from program contracts in that they do not require the programmer to describe the intended behavior of those program features which are unchanged across program versions. In this work, we present the formal semantics of our change contract language built on top of the Java modeling language (JML). Our change contract language can describe behavioral as well as structural changes. We evaluate the expressivity of the change contract language via a survey given to final-year undergraduate students. The survey results enable to understand the usability of our change contract language for purposes of writing contracts, comprehending written contracts, and modifying programs according to given change contracts. Finally, we develop both dynamic and static checkers for change contracts, and show how they can be used in maintaining software changes. We use our dynamic checker to automatically suggest tests that manifest violations of change contracts. Meanwhile, we use our static checker to verify that a program is changed as specified in its change contract. Apart from verification, our static checker also performs various other software engineering tasks, such as localizing the buggy method, detecting/debugging regression errors, and classifying the cause for a test failure as either error in production code or error in test code.", "paper_title": "Software Change Contracts", "paper_id": "WOS:000354826200006"}