{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "controlled_logical_clock"}, {"score": 0.004760394308239882, "phrase": "event_traces"}, {"score": 0.004600389726895716, "phrase": "performance_behavior"}, {"score": 0.004548253531664032, "phrase": "parallel_applications"}, {"score": 0.004420472010542188, "phrase": "in-depth_analysis"}, {"score": 0.0043208252177835815, "phrase": "synchronization_patterns"}, {"score": 0.0041517954514423625, "phrase": "synchronized_clocks"}, {"score": 0.003944112858235306, "phrase": "inaccurate_relative_event_timings"}, {"score": 0.0038551626276406175, "phrase": "logical_event_order"}, {"score": 0.0035189057079817285, "phrase": "time-line_visualization_tools"}, {"score": 0.003211883390828745, "phrase": "scalable_algorithm"}, {"score": 0.003068537223324389, "phrase": "inconsistent_inter-process_timings"}, {"score": 0.002982203248352076, "phrase": "pure_mpi_applications"}, {"score": 0.002898291237210567, "phrase": "large_processor_configurations"}, {"score": 0.0026604207233593973, "phrase": "computational_grids"}, {"score": 0.0026003455833291124, "phrase": "single_application"}, {"score": 0.002527150892127982, "phrase": "combined_computational_power"}, {"score": 0.0024005409468262203, "phrase": "extended_version"}, {"score": 0.0022802596433757565, "phrase": "message-passing_event_semantics"}, {"score": 0.0022034318550547866, "phrase": "shared-memory_event_semantics"}, {"score": 0.0021049977753042253, "phrase": "hybrid_applications"}], "paper_keywords": ["Event tracing", " Timestamp synchronization"], "paper_abstract": "Event traces are helpful in understanding the performance behavior of parallel applications since they allow the in-depth analysis of communication and synchronization patterns. However, the absence of synchronized clocks on most cluster systems may render the analysis ineffective because inaccurate relative event timings may misrepresent the logical event order and lead to errors when quantifying the impact of certain behaviors or confuse the users of time-line visualization tools by showing messages flowing backward in time. In our earlier work, we have developed a scalable algorithm called the controlled logical clock that eliminates inconsistent inter-process timings postmortem in traces of pure MPI applications, potentially running on large processor configurations. In this paper, we first demonstrate that our algorithm also proves beneficial in computational grids, where a single application is executed using the combined computational power of several geographically dispersed clusters. Second, we present an extended version of the algorithm that-in addition to message-passing event semantics-also preserves and restores shared-memory event semantics, enabling the correction of traces from hybrid applications.", "paper_title": "Extending the scope of the controlled logical clock", "paper_id": "WOS:000316011800013"}