{"auto_keywords": [{"score": 0.03786649627240986, "phrase": "hierarchical_system"}, {"score": 0.03716290535802973, "phrase": "hierarchical_components"}, {"score": 0.00481495049065317, "phrase": "hierarchical_systems"}, {"score": 0.00475924837336259, "phrase": "automated_synthesis"}, {"score": 0.004386887374401584, "phrase": "classical_temporal_synthesis_algorithms"}, {"score": 0.0042859292226559535, "phrase": "\"flat\"_system"}, {"score": 0.004154908228936342, "phrase": "real-life_software"}, {"score": 0.004027876348834879, "phrase": "preexisting_libraries"}, {"score": 0.003996727479807572, "phrase": "reusable_components"}, {"score": 0.003859500298805362, "phrase": "repeated_sub-systems"}, {"score": 0.0034618794528555063, "phrase": "\"bottom-up\"_approach"}, {"score": 0.0032406665327678616, "phrase": "system_designer"}, {"score": 0.0031660031870090434, "phrase": "currently_desired_module"}, {"score": 0.0030572112793962004, "phrase": "initial_library"}, {"score": 0.003021781956684419, "phrase": "previously_constructed_modules"}, {"score": 0.002952146666681891, "phrase": "synthesized_module"}, {"score": 0.002884111441153185, "phrase": "available_high-level_modules"}, {"score": 0.0026272754413908844, "phrase": "exptime"}, {"score": 0.002536975285505636, "phrase": "ltl"}, {"score": 0.0024688196796198766, "phrase": "complete_and_incomplete_information"}, {"score": 0.0023380300046435187, "phrase": "classical_synthesis_problem"}, {"score": 0.002301947614465974, "phrase": "flat_systems"}, {"score": 0.0022141537427057363, "phrase": "synthesized_hierarchical_system"}, {"score": 0.002154693685426657, "phrase": "flat_one"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Hierarchical systems", " mu-Calculus", " Temporal logics", " Parity games", " Synthesis"], "paper_abstract": "In automated synthesis, given a specification, we automatically create a system that is guaranteed to satisfy the specification. In the classical temporal synthesis algorithms, one usually creates a \"flat\" system \"from scratch\". However, real-life software and hardware systems are usually created using preexisting libraries of reusable components, and are not \"flat\" since repeated sub-systems are described only once. In this work we describe an algorithm for the synthesis of a hierarchical system from a library of hierarchical components, which follows the \"bottom-up\" approach to system design. Our algorithm works by synthesizing in many rounds, when at each round the system designer provides the specification of the currently desired module, which is then automatically synthesized using the initial library and the previously constructed modules. To ensure that the synthesized module actually takes advantage of the available high-level modules, we guide the algorithm by enforcing certain modularity criteria. We show that the synthesis of a hierarchical system from a library of hierarchical components is EXPTIME-complete for mu-calculus, and 2EXPTIME-complete for LTL, both in the cases of complete and incomplete information. Thus, in all cases, it is not harder than the classical synthesis problem (of synthesizing flat systems \"from scratch\"), even though the synthesized hierarchical system may be exponentially smaller than a flat one. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Synthesis of hierarchical systems", "paper_id": "WOS:000333945900004"}