{"auto_keywords": [{"score": 0.04397488238643157, "phrase": "orc"}, {"score": 0.04202312302218413, "phrase": "orc_programs"}, {"score": 0.04072967777303941, "phrase": "orc_language"}, {"score": 0.015719700919695684, "phrase": "computation_orchestration"}, {"score": 0.014150872517495576, "phrase": "web_services"}, {"score": 0.011295255348974952, "phrase": "operational_semantics"}, {"score": 0.004744437370338926, "phrase": "promising_programming_model"}, {"score": 0.004620093797504386, "phrase": "structured_way"}, {"score": 0.004579371037534175, "phrase": "distributed_web_services"}, {"score": 0.00447251540886613, "phrase": "concise_constructors"}, {"score": 0.00443308765153716, "phrase": "concurrent_communication"}, {"score": 0.004081385289516914, "phrase": "automatic_verification_tool"}, {"score": 0.0040334640350288, "phrase": "critical_properties"}, {"score": 0.0039276803200112695, "phrase": "orchestration_programs"}, {"score": 0.0037133478610481994, "phrase": "useful_tools"}, {"score": 0.003584025547693836, "phrase": "timed_automata_semantics"}, {"score": 0.0033883824438527316, "phrase": "timed_automata_models"}, {"score": 0.00330922510644499, "phrase": "practical_implication"}, {"score": 0.0032800186243040663, "phrase": "existing_tool_supports"}, {"score": 0.003260690513595527, "phrase": "timed_automata"}, {"score": 0.0032223756399415407, "phrase": "uppaal"}, {"score": 0.0031009188628557957, "phrase": "experimental_tool"}, {"score": 0.0029229166303837545, "phrase": "constraint_logic_programming"}, {"score": 0.0028546020769742177, "phrase": "systematic_translation"}, {"score": 0.002821044196775531, "phrase": "clp._powerful_constraint"}, {"score": 0.0027469703311742647, "phrase": "traditional_safety_properties"}, {"score": 0.0026045914281028473, "phrase": "time_interval"}, {"score": 0.0024842242921857705, "phrase": "stepwise_execution"}, {"score": 0.002426137929553722, "phrase": "simulation_steps"}, {"score": 0.002362408791114333, "phrase": "verification_problem"}, {"score": 0.002348475124046182, "phrase": "web_service_orchestration"}, {"score": 0.0023003498123420237, "phrase": "visualized_simulation"}, {"score": 0.002286781334850213, "phrase": "efficient_verification"}, {"score": 0.002259883463607508, "phrase": "well_developed_tools"}, {"score": 0.0022135695577201594, "phrase": "cpl_approach"}, {"score": 0.0022005118194652704, "phrase": "better_expressiveness"}, {"score": 0.0021049977753042253, "phrase": "complete_solution"}], "paper_keywords": ["Orc", " Web service orchestration", " Verification", " Timed automata", " Uppaal", " Constraint logic programming", " CLP(R)"], "paper_abstract": "Recently, a promising programming model called Orc has been proposed to support a structured way of orchestrating distributed Web Services. Orc is intuitive because it offers concise constructors to manage concurrent communication, time-outs, priorities, failure of Web Services or communication and so forth. The semantics of Orc is precisely defined. However, there is no automatic verification tool available to verify critical properties against Orc programs. Our goal is to verify the orchestration programs (written in Orc language) which invoke web services to achieve certain goals. To investigate this problem and build useful tools, we explore in two directions. Firstly, we define a Timed Automata semantics for the Orc language, which we prove is semantically equivalent to the operational semantics of Orc. Consequently, Timed Automata models are systematically constructed from Orc programs. The practical implication is that existing tool supports for Timed Automata, e.g., Uppaal, can be used to simulate and model check Orc programs. An experimental tool has been implemented to automate this approach. Secondly, we start with encoding the operational semantics of Orc language in Constraint Logic Programming (CLP), which allows a systematic translation from Orc to CLP. Powerful constraint solvers like CLP are then used to prove traditional safety properties and beyond, e.g., reachability, deadlock-freeness, lower or upper bound of a time interval, etc. Counterexamples are generated when properties are not satisfied. Furthermore, the stepwise execution traces can be automatically generated as the simulation steps. The two different approaches give an insight into the verification problem of Web Service orchestration. The Timed Automata approach has its merits in visualized simulation and efficient verification supported by the well developed tools. On the other hand, the CPL approach gives better expressiveness in both modeling and verification. The two approaches complement each other, which gives a complete solution for the simulation and verification of Computation Orchestration.", "paper_title": "Towards verification of computation orchestration", "paper_id": "WOS:000339105100004"}