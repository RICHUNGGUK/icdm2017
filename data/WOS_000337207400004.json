{"auto_keywords": [{"score": 0.04650334340899582, "phrase": "static_mapping"}, {"score": 0.010985032624953196, "phrase": "rhm"}, {"score": 0.00481495049065317, "phrase": "effective_memory_resource_usage"}, {"score": 0.0047124709448813674, "phrase": "llc"}, {"score": 0.004417848254181138, "phrase": "cache_blocks"}, {"score": 0.004361163586439822, "phrase": "llc_banks"}, {"score": 0.004305203085016233, "phrase": "poor_efficiency"}, {"score": 0.004035946043145475, "phrase": "dynamic_policies"}, {"score": 0.003577414339646767, "phrase": "statically_mapped_addresses"}, {"score": 0.003382547312072468, "phrase": "runtime_home_mapping"}, {"score": 0.0032259472087775138, "phrase": "llc_home_bank"}, {"score": 0.003130077012135034, "phrase": "memory_controller"}, {"score": 0.003037047249598515, "phrase": "main_memory"}, {"score": 0.002822434555587263, "phrase": "execution_time"}, {"score": 0.0027861630854233693, "phrase": "message_latencies"}, {"score": 0.002762240719058935, "phrase": "block_migration"}, {"score": 0.0026916956768363158, "phrase": "basic_rhm."}, {"score": 0.0025892330566358503, "phrase": "directory_structure"}, {"score": 0.0025449518236394103, "phrase": "specific_noc_optimizations"}, {"score": 0.0023958326775913165, "phrase": "alternative_solutions"}, {"score": 0.002294686545883412, "phrase": "load_and_store_latencies"}, {"score": 0.002197801146305747, "phrase": "average_reduction"}, {"score": 0.0021601997088758957, "phrase": "applications_execution"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Chip multiprocessors", " Network-on-chip", " Cache hierarchy", " Coherence protocols"], "paper_abstract": "In tiled Chip Multiprocessors (CMPs) last-level cache (LLC) banks are usually shared but distributed among the tiles. A static mapping of cache blocks to the LLC banks leads to poor efficiency since a block may be mapped away from the tiles actually accessing it. Dynamic policies either rely on the static mapping of blocks to a set of banks (D-NUCA) or rely on the OS to dynamically load pages to statically mapped addresses (first-touch). In this paper, we propose Runtime Home Mapping (RHM), a new dynamic approach where the LLC home bank is determined at runtime by the memory controller when the block is fetched from main memory, trying to map each block as close as possible to the requestor thus speeding up execution time and lowering message latencies. Block migration and replication provide further improvements to basic RHM. Also, in a further optimization we eliminate the directory structure. All these optimizations involve specific NoC optimizations and co-designs. Results with PARSEC and SPLASH-2 applications show, when compared with alternative solutions, that RHM achieves a 41% and 35% average reduction in load and store latencies respectively compared to static mapping. This leads to an average reduction of 28% in applications execution. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Runtime home mapping for effective memory resource usage", "paper_id": "WOS:000337207400004"}