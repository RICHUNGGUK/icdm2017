{"auto_keywords": [{"score": 0.04707318855673243, "phrase": "fetch_unit"}, {"score": 0.01353601941295389, "phrase": "power_consumption"}, {"score": 0.011941037913166789, "phrase": "ctc"}, {"score": 0.011197389595787094, "phrase": "stc"}, {"score": 0.00481495049065317, "phrase": "power_efficiency"}, {"score": 0.004785356349906913, "phrase": "trace_cache"}, {"score": 0.004697655699119423, "phrase": "issue_width"}, {"score": 0.004665464321662129, "phrase": "ctc."}, {"score": 0.004625795150473604, "phrase": "function_units"}, {"score": 0.00459735824483322, "phrase": "superscalar_processors"}, {"score": 0.004457762896411101, "phrase": "large_fetch_bandwidth"}, {"score": 0.004362564831572539, "phrase": "datapath_resources"}, {"score": 0.004295808080360233, "phrase": "power_issue"}, {"score": 0.004204054047427536, "phrase": "traditional_instruction_fetch_mechanism"}, {"score": 0.004188127682652533, "phrase": "dptc"}, {"score": 0.004038800378904376, "phrase": "extra_power_consumption"}, {"score": 0.004013957450249313, "phrase": "traditional_instruction_caches"}, {"score": 0.003976978140059542, "phrase": "dynamic_control_flows"}, {"score": 0.0038206161632040672, "phrase": "trace_caches"}, {"score": 0.0037854112749311844, "phrase": "potential_framework"}, {"score": 0.0037621210719690594, "phrase": "power_optimisation"}, {"score": 0.0036703791815812328, "phrase": "conventional_trace_caches"}, {"score": 0.0035260290145240464, "phrase": "simultaneous_access"}, {"score": 0.0034720284451902083, "phrase": "instruction_cache"}, {"score": 0.0034400245101881936, "phrase": "sequential_trace_caches"}, {"score": 0.0033561107040568747, "phrase": "lower_power_consumption"}, {"score": 0.0032945169562318575, "phrase": "significant_performance_loss"}, {"score": 0.0031746892156724006, "phrase": "detailed_study"}, {"score": 0.0031551446537729107, "phrase": "trace_distribution"}, {"score": 0.0031357200369281344, "phrase": "access_locality"}, {"score": 0.0030309961956273028, "phrase": "new_model"}, {"score": 0.002938821840519756, "phrase": "sltc"}, {"score": 0.002893788139084487, "phrase": "hardware_support"}, {"score": 0.0028582571226324293, "phrase": "trace_cache_lookup"}, {"score": 0.0028231611341151368, "phrase": "experimental_evaluation"}, {"score": 0.0027372898106427274, "phrase": "additional_reduction"}, {"score": 0.002621428624654101, "phrase": "perfomance_loss"}, {"score": 0.0025260203198771473, "phrase": "dynamic_direction_prediction"}, {"score": 0.002404175869425017, "phrase": "set_architecture"}, {"score": 0.002323826502178581, "phrase": "fetch_direction_predictor"}, {"score": 0.002295277579105177, "phrase": "competitive_power_efficiency"}, {"score": 0.0021049977753042253, "phrase": "performance_loss"}], "paper_keywords": [""], "paper_abstract": "As the issue width and the number of function units of superscalar processors continue to increase, the fetch unit must support a large fetch bandwidth in order to fully utilise the datapath resources. This trend makes power issue worse in the fetch unit since the traditional instruction fetch mechanism is not optimised for power consumption. This paper explores the problem of extra power consumption in traditional instruction caches because of dynamic control flows. Capturing the dynamic paths/characteristics of code during the course of execution, trace caches provide a potential framework for power optimisation in the fetch unit. Our study shows that conventional trace caches (CTC) may increase power consumption in the fetch unit because of the simultaneous access to both the trace cache and the instruction cache, and sequential trace caches (STC) have the advantage of lower power consumption at the cost of a significant performance loss. In order to address this problem, we perform a detailed study of trace distribution and access locality. Based on this study, we first propose a new model, the selective trace cache (SLTC). SLTC uses both compiler and hardware support to selectively control trace cache lookup and update. Experimental evaluation shows that our selective trace cache achieves up to 42.2% power reduction over CTC and an additional reduction of up to 21.8% over STC, on the average, while only trading a perfomance loss of no more than 1.8% compared to CTC. Further, we propose a dynamic direction prediction based trace cache (DPTC), which eliminates the need for compilation and instruction set architecture (ISA) modification involved in SLTC. Powered by a fetch direction predictor, DPTC achieves competitive power efficiency. On the average, DPTC reduces the power consumption by up to 40.5% and 17.6% in the fetch unit compared to CTC and STC, respectively, by trading a performance loss of less than 2.4% to CTC.", "paper_title": "Optimising power efficiency in trace cache fetch unit", "paper_id": "WOS:000248317000008"}