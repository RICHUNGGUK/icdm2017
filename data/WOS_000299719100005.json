{"auto_keywords": [{"score": 0.03159332441647393, "phrase": "memoryless_strategy"}, {"score": 0.004379977556546879, "phrase": "finite_state_system"}, {"score": 0.004286708921931472, "phrase": "gate_level"}, {"score": 0.004213519983188574, "phrase": "source_level"}, {"score": 0.004035946043145475, "phrase": "linear_temporal_logic"}, {"score": 0.003949974260471287, "phrase": "correction_problem"}, {"score": 0.003767203575060969, "phrase": "faulty_component"}, {"score": 0.0037188360359702182, "phrase": "alternative_behavior"}, {"score": 0.0036710872046569532, "phrase": "basic_approach"}, {"score": 0.0031435968684569112, "phrase": "doubly_exponential_blowup"}, {"score": 0.00306334226516593, "phrase": "nondeterministic_automata"}, {"score": 0.0030239842475439814, "phrase": "second_heuristic"}, {"score": 0.0028963961037320805, "phrase": "np-complete_problem"}, {"score": 0.0023548511815224098, "phrase": "suggested_correction"}, {"score": 0.0023245746777044766, "phrase": "art_arbitrary_combinational_function"}, {"score": 0.002294686545883412, "phrase": "current_state"}, {"score": 0.002226430168622392, "phrase": "experimental_results"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Debugging", " Fault localization", " Fault correction", " Verification", " Games", " Controller synthesis", " Linear temporal logic", " Memoryless strategies", " Repair"], "paper_abstract": "Knowing that a program has a bug is good, knowing its location is better, but a fix is best. We present a method to automatically locate and correct faults in a finite state system, either at the gate level or at the source level. We assume that the specification is given in Linear Temporal Logic, and state the correction problem as a game, in which the protagonist selects a faulty component and suggests alternative behavior. The basic approach is complete but as complex as synthesis. It also suffers from problems of readability: the correction may add state and logic to the system. We present two heuristics. The first avoids the doubly exponential blowup associated with synthesis by using nondeterministic automata. The second heuristic finds a memoryless strategy, which we show is an NP-complete problem. A memoryless strategy corresponds to a simple, local correction that does not add any state. The drawback of the two heuristics is that they are not complete unless the specification is an invariant. Our approach is general: the user can define what constitutes a component, and the suggested correction can be art arbitrary combinational function of the current state and the inputs. We show experimental results supporting the applicability of our approach. (C) 2011 Published by Elsevier Inc.", "paper_title": "Finding and fixing faults", "paper_id": "WOS:000299719100005"}