{"auto_keywords": [{"score": 0.04847725805604942, "phrase": "factor_graph"}, {"score": 0.03801964087844912, "phrase": "iteratively_encodable_codes"}, {"score": 0.02905077291658201, "phrase": "repetitive_pattern"}, {"score": 0.00481495049065317, "phrase": "circuit_implementation"}, {"score": 0.004745260932479212, "phrase": "sum-product_algorithm"}, {"score": 0.004161553532799662, "phrase": "area_and_verification_requirements"}, {"score": 0.004041879818641576, "phrase": "iterative_encoding_techniques"}, {"score": 0.003964007795174772, "phrase": "graphical_representation"}, {"score": 0.003831310632470526, "phrase": "code_design_constraints"}, {"score": 0.003775803846431323, "phrase": "encoder_convergence"}, {"score": 0.00342568771304873, "phrase": "jacobi_method"}, {"score": 0.003392507399258166, "phrase": "iterative_matrix_inversion"}, {"score": 0.003310951184365485, "phrase": "finite_field_matrices"}, {"score": 0.0032471155306148126, "phrase": "message_passing"}, {"score": 0.0031079352545607267, "phrase": "iterative_encoder"}, {"score": 0.00303319936111073, "phrase": "algebraic_construction"}, {"score": 0.0029892206557359836, "phrase": "free_iteratively_encodable_codes"}, {"score": 0.002608218347502229, "phrase": "low_pseudo-weight"}, {"score": 0.002424450174817922, "phrase": "recursive_technique"}, {"score": 0.0023546121947302877, "phrase": "new_codes"}, {"score": 0.0022756672722130424, "phrase": "code_length"}, {"score": 0.0021049977753042253, "phrase": "euclidean-geometry_codes"}], "paper_keywords": ["Bipartite graph", " block codes", " codes on graphs", " cycles in a graph", " encoding", " iterative decoding", " linear codes", " low-density parity-check (LDPC) codes", " sparse matrices"], "paper_abstract": "Low-density parity-check (LDPC) codes may be decoded using a circuit implementation of the sum-product algorithm which maps the factor graph of the code. By reusing the decoder for encoding, both tasks can be performed using the same circuit, thus reducing area and verification requirements. Motivated by this, iterative encoding techniques based upon the graphical representation of the code are proposed. Code design constraints which ensure encoder convergence are presented, and then used to design iteratively encodable codes, while also preventing 4-cycle creation. We show how the Jacobi method for iterative matrix inversion can be applied to finite field matrices, viewed as message passing, and employed as the core of an iterative encoder. We present an algebraic construction of 4-cycle free iteratively encodable codes using circulant matrices. Analysis of these codes identifies a weakness in their structure, due to a repetitive pattern in the factor graph. The graph supports pseudo-codewords of low pseudo-weight. In order to remove the repetitive pattern in the graph, we propose a recursive technique for generating iteratively encodable codes. The new codes offer flexibility in the choice of code length and rate, and performance that compares well to randomly generated, quasi-cyclic and extended Euclidean-geometry codes.", "paper_title": "Reversible Low-Density Parity-Check Codes", "paper_id": "WOS:000265713000007"}