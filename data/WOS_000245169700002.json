{"auto_keywords": [{"score": 0.04132712815039597, "phrase": "normal_mode"}, {"score": 0.03956997057006548, "phrase": "recovery_mode"}, {"score": 0.00481495049065317, "phrase": "consensus_failure_recovery"}, {"score": 0.004399905285945236, "phrase": "failure-free_synchronous_periods"}, {"score": 0.0033735490732324713, "phrase": "consensus_algorithms"}, {"score": 0.0033231814056233103, "phrase": "round-based_eventually_synchronous_model"}, {"score": 0.0031606404966938568, "phrase": "n_processes"}, {"score": 0.0027327327233891865, "phrase": "new_failure"}, {"score": 0.0024842242921857705, "phrase": "lower_bound"}, {"score": 0.0024105326885334962, "phrase": "global_decision"}, {"score": 0.0021369416775353107, "phrase": "matching_algorithms"}], "paper_keywords": [""], "paper_abstract": "Many reliable distributed systems are consensus-based and typically operate under two modes: a fast normal mode in failure-free synchronous periods, and a slower recovery mode following asynchrony and failures. A lot of work has been devoted to optimize the normal mode, but little has focused on optimizing the recovery mode. This paper seeks to understand whether the recovery mode is inherently slower than the normal mode. In particular, we consider consensus algorithms in the round-based eventually synchronous model of [11], where t out of n processes may fail by crashing, messages may be lost, and the system may be asynchronous for arbitrarily long, but eventually the system becomes synchronous and no new failure occurs (we say that the system becomes stable). For t >= n/3, we prove a lower bound of three rounds for achieving a global decision whenever the system becomes stable, and we contrast this with a bound of two rounds when t < n/3. We then give matching algorithms for both t >= n/3 and t < n/3.", "paper_title": "The overhead of consensus failure recovery", "paper_id": "WOS:000245169700002"}