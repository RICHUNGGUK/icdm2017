{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "multiple_inheritance"}, {"score": 0.004606479650820579, "phrase": "operational_semantics_and_type_safety_proof"}, {"score": 0.004374593906165761, "phrase": "semantics_models"}, {"score": 0.00424734451992536, "phrase": "method_calls"}, {"score": 0.004185108816866677, "phrase": "field_accesses"}, {"score": 0.003830312347175889, "phrase": "type_safety_proof"}, {"score": 0.003428665921276366, "phrase": "first_time"}, {"score": 0.0031146967095233586, "phrase": "implementation-level_artifacts"}, {"score": 0.0030464123943266673, "phrase": "virtual_function_tables"}, {"score": 0.0023346234464901978, "phrase": "semantics_and_type_safety_proof"}, {"score": 0.0021049977753042253, "phrase": "intricate_multiple_inheritance_model"}], "paper_keywords": ["languages", " theory", " multiple inheritance", " C plus", " semantics", " type safety"], "paper_abstract": "We present an operational semantics and type safety proof for multiple inheritance in C++. The semantics models the behaviour of method calls, field accesses, and two forms of casts in C++ class hierarchies exactly, and the type safety proof was formalized and machine-checked in Isabelle/HOL. Our semantics enables one, for the first time, to understand the behaviour of operations on C++ class hierarchies without referring to implementation-level artifacts such as virtual function tables. Moreover, it can-as the semantics is executable-act as a reference for compilers, and it can form the basis for more advanced correctness proofs of, e. g., automated program transformations. The paper presents the semantics and type safety proof, and a discussion of the many subtleties that we encountered in modeling the intricate multiple inheritance model of C++.", "paper_title": "An operational semantics and type safety proof for multiple inheritance in C++", "paper_id": "WOS:000202972500024"}