{"auto_keywords": [{"score": 0.04941343102175344, "phrase": "cork"}, {"score": 0.023227271015778938, "phrase": "memory_leaks"}, {"score": 0.009626570637607482, "phrase": "systematic_heap_growth"}, {"score": 0.006838870562052204, "phrase": "live_objects"}, {"score": 0.005802811851980708, "phrase": "growing_data_structures"}, {"score": 0.004781357546476652, "phrase": "managed_languages"}, {"score": 0.004698392162272106, "phrase": "memory_leak"}, {"score": 0.004649302313891199, "phrase": "managed_language"}, {"score": 0.0042446888127531945, "phrase": "program_crashes"}, {"score": 0.004027412633636142, "phrase": "heap_differencing"}, {"score": 0.003999292102785413, "phrase": "detailed_object_statistics"}, {"score": 0.003702581068329137, "phrase": "deployed_long-running_applications"}, {"score": 0.00355009076716969, "phrase": "heap_growth"}, {"score": 0.0032522091171602557, "phrase": "total_execution_time"}, {"score": 0.0030747771905143273, "phrase": "garbage_collection"}, {"score": 0.0029069972482610403, "phrase": "cpfg"}, {"score": 0.002767696345005216, "phrase": "specific_classes"}, {"score": 0.00268168157806506, "phrase": "corresponding_volume"}, {"score": 0.002607464886544904, "phrase": "multiple_collections"}, {"score": 0.0025711283781017424, "phrase": "class_slice"}, {"score": 0.0023387234705715154, "phrase": "false_positives"}, {"score": 0.002289993730291136, "phrase": "cork's_slice_report"}, {"score": 0.0022110183535859374, "phrase": "large_and_unfamiliar_programs"}], "paper_keywords": ["memory leaks", " runtime analysis", " dynamic", " garbage collection"], "paper_abstract": "A memory leak in a managed language occurs when the program inadvertently maintains references to objects that it no longer needs. Memory leaks cause systematic heap growth that degrade performance and can result in program crashes after perhaps days or weeks of execution. Prior approaches for detecting memory leaks rely on heap differencing or detailed object statistics which store state proportional to the number of objects in the heap. These overheads preclude their use on the same processor for deployed long-running applications. This paper introduces Cork as a toot that accurately identifies heap growth caused by leaks. It is space efficient (adding less than 1% to the heap) and time efficient (adding 2.3% on average to total execution time). We implement this approach of examining and summarizing the class of live objects during garbage collection in a class points-In graph (CPFG). Each node in the CPFG represents a class and edges between nodes represent references between objects of the specific classes. Cork annotates nodes and edges with the corresponding volume of live objects. Cork identifies growing data structures across multiple collections and computes a class slice to identify leaks for the user. We experiment with two functions for identifying growth and show that Cork is accurate: it identifies systematic heap growth with no false positives in 4 of 15 benchmarks we tested. Cork's slice report enabled us to quickly identify and eliminate growing data structures in large and unfamiliar programs, something their developers had not previously done. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Detecting memory leaks in managed languages with Cork", "paper_id": "WOS:000273666300001"}