{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "space_efficiency"}, {"score": 0.004556901872357751, "phrase": "managed_languages"}, {"score": 0.004518442937844318, "phrase": "modern_applications"}, {"score": 0.004276216827737399, "phrase": "small_objects"}, {"score": 0.00422218060227958, "phrase": "garbage_collector"}, {"score": 0.004151188559520802, "phrase": "program_performance"}, {"score": 0.0038624981944755813, "phrase": "fast_reclamation"}, {"score": 0.003813669883040509, "phrase": "mutator_performance"}, {"score": 0.0033579708256295847, "phrase": "collector_family"}, {"score": 0.0032321559007422087, "phrase": "opportunistic_defragmentation"}, {"score": 0.0031110402375026016, "phrase": "single_pass"}, {"score": 0.0028822153400215973, "phrase": "performance_objectives"}, {"score": 0.0028457440091791252, "phrase": "key_insight"}, {"score": 0.002750721367040336, "phrase": "contiguous_regions"}, {"score": 0.002704403349815203, "phrase": "coarse_block_grain"}, {"score": 0.0026140878612307536, "phrase": "finer_grain_lines"}, {"score": 0.0025375331660958665, "phrase": "existing_canonical_algorithms"}, {"score": 0.002505412457777352, "phrase": "total_application_performance"}, {"score": 0.0024012441367538455, "phrase": "mature_space"}, {"score": 0.0023708445073819277, "phrase": "generational_collector"}, {"score": 0.0023210293050850276, "phrase": "highly_tuned_generational_collector"}, {"score": 0.0021593396036472777, "phrase": "new_family"}, {"score": 0.0021229583685841405, "phrase": "new_opportunities"}, {"score": 0.0021049977753042253, "phrase": "garbage_collector_design"}], "paper_keywords": ["algorithms", " experimentation", " languages", " performance", " measurement", " fragmentation", " free-list", " compact", " mark-sweep", " semi-space", " mark-region", " immix", " sweep-to-region", " sweep-to-free-list"], "paper_abstract": "Programmers are increasingly choosing managed languages for modern applications, which tend to allocate many short-to-medium lived small objects. The garbage collector therefore directly determines program performance by making a classic space-time trade-off that seeks to provide space efficiency, fast reclamation, and mutator performance. The three canonical tracing garbage collectors: semi-space, mark-sweep, and mark-compact each sacrifice one objective. This paper describes a collector family, called mark-region, and introduces opportunistic defragmentation, which mixes copying and marking in a single pass. Combining both, we implement immix, a novel high performance garbage collector that achieves all three performance objectives. The key insight is to allocate and reclaim memory in contiguous regions, at a coarse block grain when possible and otherwise in groups of finer grain lines. We show that immix outperforms existing canonical algorithms, improving total application performance by 7 to 25% on average across 20 benchmarks. As the mature space in a generational collector, immix matches or beats a highly tuned generational collector, e. g. it improves jbb2000 by 5%. These innovations and the identification of a new family of collectors open new opportunities for garbage collector design.", "paper_title": "Immix: A mark-region garbage collector with space efficiency, fast collection, and mutator performance", "paper_id": "WOS:000257820400003"}