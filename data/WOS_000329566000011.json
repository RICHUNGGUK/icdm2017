{"auto_keywords": [{"score": 0.03867993705720378, "phrase": "strong_normalisation"}, {"score": 0.014790811907374331, "phrase": "explicit_substitutions"}, {"score": 0.01231669492348155, "phrase": "longest_reduction_sequence"}, {"score": 0.011076019115235857, "phrase": "lambda_s"}, {"score": 0.011004930332057317, "phrase": "lambda_lxr"}, {"score": 0.00481495049065317, "phrase": "typing_system"}, {"score": 0.004783852487938866, "phrase": "non-idempotent_intersection_types"}, {"score": 0.004722254884093624, "phrase": "term_syntax"}, {"score": 0.0038750439121298503, "phrase": "extra_information"}, {"score": 0.0038499929374478125, "phrase": "typing_trees"}, {"score": 0.0038003739322536156, "phrase": "simple_bounds"}, {"score": 0.003619910789366738, "phrase": "reducibility_techniques"}, {"score": 0.0034479873922329323, "phrase": "intersection_types"}, {"score": 0.0032208807810825933, "phrase": "modular_proofs"}, {"score": 0.0031793439438669176, "phrase": "well-known_typing_systems"}, {"score": 0.0031485421129798996, "phrase": "system_f"}, {"score": 0.0030778231027679434, "phrase": "filter_model"}, {"score": 0.003038125530190128, "phrase": "orthogonality_techniques"}, {"score": 0.0029602552900111407, "phrase": "abstract_notion"}, {"score": 0.002941100683384888, "phrase": "orthogonality_model"}, {"score": 0.002865710140187219, "phrase": "classical_realisability"}, {"score": 0.002566215899764419, "phrase": "strong_normalisation_results"}, {"score": 0.002389276641014013, "phrase": "exact_measure"}, {"score": 0.0023507916951658455, "phrase": "specific_typing_tree"}, {"score": 0.0022536005664642294, "phrase": "specific_reduction_sequence"}, {"score": 0.0021534125023440895, "phrase": "complexity_result"}, {"score": 0.0021187186371584674, "phrase": "de_carvalho's_result"}, {"score": 0.0021049977753042253, "phrase": "linear_head-reduction_sequences"}], "paper_keywords": ["intersection types", " non-idempotence", " strong normalisation", " orthogonality models", " filters", " complexity"], "paper_abstract": "We present a typing system with non-idempotent intersection types, typing a term syntax covering three different calculi: the pure lambda-calculus, the calculus with explicit substitutions lambda S, and the calculus with explicit substitutions, contractions and weakenings lambda lxr. In each of the three calculi, a term is typable if and only if it is strongly normalising, as it is the case in (many) systems with idempotent intersections. Non-idempotency brings extra information into typing trees, such as simple bounds on the longest reduction sequence reducing a term to its normal form. Strong normalisation follows, without requiring reducibility techniques. Using this, we revisit models of the lambda-calculus based on filters of intersection types, and extend them to lambda S and lambda lxr. Non-idempotency simplifies a methodology, based on such filter models, that produces modular proofs of strong normalisation for well-known typing systems (e.g. System F). We also present a filter model by means of orthogonality techniques, i.e. as an instance of an abstract notion of orthogonality model formalised in this paper and inspired by classical realisability. Compared to other instances based on terms (one of which rephrases a now standard proof of strong normalisation for the lambda-calculus), the instance based on filters is shown to be better at proving strong normalisation results for lambda S and lambda lxr. Finally, the bounds on the longest reduction sequence, read off our typing trees, are refined into an exact measure, read off a specific typing tree (called principal); in each of the three calculi, a specific reduction sequence of such length is identified. In the case of the lambda-calculus, this complexity result is, for longest reduction sequences, the counterpart of de Carvalho's result for linear head-reduction sequences.", "paper_title": "NON-IDEMPOTENT INTERSECTION TYPES AND STRONG NORMALISATION", "paper_id": "WOS:000329566000011"}