{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "graceful_graphs"}, {"score": 0.036115158017236984, "phrase": "second_model"}, {"score": 0.0045143706249204905, "phrase": "graceful_labelling"}, {"score": 0.004134372859330047, "phrase": "experimental_comparison"}, {"score": 0.003991449490087454, "phrase": "different_classes"}, {"score": 0.0038309141193444015, "phrase": "first_model"}, {"score": 0.0029766550209309127, "phrase": "third_model"}, {"score": 0.002924694271730544, "phrase": "best_features"}, {"score": 0.0025106241866273897, "phrase": "useful_case-study"}, {"score": 0.0024379730432321656, "phrase": "constraint_satisfaction_problems"}, {"score": 0.002326068563512387, "phrase": "constraint_programming"}, {"score": 0.002272053079580848, "phrase": "useful_tool"}], "paper_keywords": ["Constraint programming", " Modelling", " Search", " Graph theory"], "paper_abstract": "We present three constraint models of the problem of finding a graceful labelling of a graph, or proving that the graph is not graceful. An experimental comparison of the models applied to different classes of graph is given. The first model seems a natural way to represent the problem, but explores a much larger search tree than the other models. The second model does much less search, by making the most constrained decisions first, but is slow because the constraints are time-consuming to propagate. The third model combines the best features of the others, doing little more search than the second model while being much the fastest of the three. The comparison of the three models provides a useful case-study of modelling problems as constraint satisfaction problems. In addition, we show that constraint programming can be a useful tool for the study of graceful graphs; the models presented here have contributed many new results.", "paper_title": "Constraint models for graceful graphs", "paper_id": "WOS:000273744400003"}