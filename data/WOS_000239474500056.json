{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "regular_expression"}, {"score": 0.004371660146981191, "phrase": "classical_regular_expression_matching_problem"}, {"score": 0.00409895142748329, "phrase": "regular_expression_r"}, {"score": 0.003969018740062018, "phrase": "string_q"}, {"score": 0.003306559295382181, "phrase": "r._we"}, {"score": 0.00323625520042892, "phrase": "new_algorithms"}, {"score": 0.003100085797251317, "phrase": "standard_unit-cost_ram"}, {"score": 0.0027543636132088332, "phrase": "best_known_time_bounds"}, {"score": 0.0022213218042340735, "phrase": "fastest_known_algorithms"}], "paper_keywords": [""], "paper_abstract": "In this paper we revisit the classical regular expression matching problem, namely, given a regular expression R and a string Q consisting of m and n symbols, respectively, decide if Q matches one of the strings specified by R. We present new algorithms designed for a standard unit-cost RAM with word length w >= log n. We improve the best known time bounds for algorithms that use O(m) space, and whenever w >= log 2 n, we obtain the fastest known algorithms, regardless of how much space is used.", "paper_title": "New algorithms for regular expression matching", "paper_id": "WOS:000239474500056"}