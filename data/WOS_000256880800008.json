{"auto_keywords": [{"score": 0.028562217216475887, "phrase": "dbp"}, {"score": 0.015184603627552537, "phrase": "synchronous_program"}, {"score": 0.014069767046155124, "phrase": "fixed_priority"}, {"score": 0.00481495049065317, "phrase": "multitask_implementation"}, {"score": 0.004781357546476652, "phrase": "synchronous_programs"}, {"score": 0.004568617813032014, "phrase": "multiple_tasks"}, {"score": 0.004411406624893529, "phrase": "real-time_operating_system"}, {"score": 0.00436530211426514, "phrase": "preemptive_scheduling_policy"}, {"score": 0.004229847379280629, "phrase": "multitask_implementations"}, {"score": 0.0041129612315045, "phrase": "multiperiodic_applications"}, {"score": 0.004055730085399621, "phrase": "worst-case_execution_time"}, {"score": 0.003861596041315646, "phrase": "single-task_implementation"}, {"score": 0.003821215658570578, "phrase": "schedulability_assumption"}, {"score": 0.003741712498615481, "phrase": "synchrony_hypothesis"}, {"score": 0.003625537203803235, "phrase": "semantics-preserving_implementations"}, {"score": 0.0035129562812850784, "phrase": "output_sequence"}, {"score": 0.0033564619316337634, "phrase": "original_synchronous_program"}, {"score": 0.003286596407873823, "phrase": "possible_executions"}, {"score": 0.0032294837250130327, "phrase": "straightforward_implementation_techniques"}, {"score": 0.0031182092708983184, "phrase": "intertask_communication_protocol"}, {"score": 0.002937745193225725, "phrase": "semantical_preservation"}, {"score": 0.0029069972482610403, "phrase": "possible_triggering_patterns"}, {"score": 0.00263505298504827, "phrase": "earliest-deadline_first_scheduling"}, {"score": 0.0025892330566358503, "phrase": "nonblocking_protocol"}, {"score": 0.0025352969524471496, "phrase": "intermediate_buffers"}, {"score": 0.002289993730291136, "phrase": "distinguishing_feature"}, {"score": 0.0022739766507258105, "phrase": "dbp._dbp"}, {"score": 0.0021049977753042253, "phrase": "worst_case"}], "paper_keywords": [""], "paper_abstract": "We study the implementation of a synchronous program as a set of multiple tasks running on the same computer, and scheduled by a real-time operating system using some preemptive scheduling policy, such as fixed priority or earliest-deadline first. Multitask implementations are necessary, for instance, in multiperiodic applications, when the worst-case execution time of the program is larger than its smallest period. In this case, a single-task implementation violates the schedulability assumption and, therefore, the synchrony hypothesis does not hold. We are aiming at semantics-preserving implementations, where, for a given input sequence, the output sequence produced by the implementation is the same as that produced by the original synchronous program, and this under all possible executions of the implementation. Straightforward implementation techniques are not semantics-preserving. We present an intertask communication protocol, called DBP, that is semantics-preserving and memory-optimal. DBP guarantees semantical preservation under all possible triggering patterns of the synchronous program: thus, it is applicable not only to time-, but also event-triggered applications. DBP works under both fixed priority and earliest-deadline first scheduling. DBP is a nonblocking protocol based on the use of intermediate buffers and manipulations of write-to/read-from pointers to these buffers: these manipulations happen upon arrivals, rather than executions of tasks, which is a distinguishing feature of DBP. DBP is memory-optimal in the sense that it uses as few buffers as needed, for any given triggering pattern. In the worst case, DBP requires, at most, N + 2 buffers for each writer, where N is the number of readers for this writer.", "paper_title": "Semantics-preserving multitask implementation of synchronous programs", "paper_id": "WOS:000256880800008"}