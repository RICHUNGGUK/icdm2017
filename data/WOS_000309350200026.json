{"auto_keywords": [{"score": 0.004556901872357751, "phrase": "scalable_concurrent"}, {"score": 0.004404994123834589, "phrase": "familiar_imperative_object-oriented_programming_model"}, {"score": 0.004312622975366676, "phrase": "light-weight_asynchronous_tasks"}, {"score": 0.004204320052179726, "phrase": "multiple_address_spaces"}, {"score": 0.004151188559520802, "phrase": "crucial_aspect"}, {"score": 0.0040298010803060495, "phrase": "concurrent_tasks"}, {"score": 0.003995772867224968, "phrase": "work-stealing_schedulers"}, {"score": 0.0038789122930433305, "phrase": "balance_fine-grain_divide"}, {"score": 0.003797530813314321, "phrase": "task-parallel_program"}, {"score": 0.0036090884921108086, "phrase": "shared-memory_fork-join_parallelism"}, {"score": 0.0034299649219748513, "phrase": "conditional_atomic_blocks"}, {"score": 0.003400984514637656, "phrase": "remote_task_invocations"}, {"score": 0.00327356326590461, "phrase": "work-stealing_scheduling_principles"}, {"score": 0.003204841443605308, "phrase": "rich_programming_language"}, {"score": 0.0028822153400215973, "phrase": "portable_work-stealing_execution_engine"}, {"score": 0.002750721367040336, "phrase": "efficient_execution"}, {"score": 0.0027274643070540733, "phrase": "fork-join_parallelism"}, {"score": 0.0026140878612307536, "phrase": "especially_conditional_atomic_blocks"}, {"score": 0.0024947959375982614, "phrase": "run_time"}, {"score": 0.0024423826953133844, "phrase": "benchmark_programs"}, {"score": 0.002224510044064184, "phrase": "state-of-the_art_work-stealing_scheduler_implementations"}, {"score": 0.002159399246114883, "phrase": "java"}, {"score": 0.0021049977753042253, "phrase": "dramatic_increase"}], "paper_keywords": ["Languages", " Performance", " Scheduling", " Task Parallelism", " Work-Stealing", " X10"], "paper_abstract": "The X10 programming language is intended to ease the programming of scalable concurrent and distributed applications. X10 augments a familiar imperative object-oriented programming model with constructs to support light-weight asynchronous tasks as well as execution across multiple address spaces. A crucial aspect of X10's runtime system is the scheduling of concurrent tasks. Work-stealing schedulers have been shown to efficiently load balance fine-grain divide-and-conquer task-parallel program on SMPs and multicores. But X10 is not limited to shared-memory fork-join parallelism. X10 permits tasks to suspend and synchronize by means of conditional atomic blocks and remote task invocations. In this paper, we demonstrate that work-stealing scheduling principles are applicable to a rich programming language such as X10, achieving performance at scale without compromising expressivity, ease of use, or portability. We design and implement a portable work-stealing execution engine for X10. While this engine is biased toward the efficient execution of fork-join parallelism in shared memory, it handles the full X10 language, especially conditional atomic blocks and distribution. We show that this engine improves the run time of a series of benchmark programs by several orders of magnitude when used in combination with the C++ backend compiler and runtime for X10. It achieves scaling comparable to state-of-the art work-stealing scheduler implementations-the Cilk++ compiler and the Java fork/join framework-despite the dramatic increase in generality.", "paper_title": "A Work-Stealing Scheduler for X10's Task Parallelism with Suspension", "paper_id": "WOS:000309350200026"}