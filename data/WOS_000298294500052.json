{"auto_keywords": [{"score": 0.04774557279201613, "phrase": "aida"}, {"score": 0.005711818593884708, "phrase": "declarative_isolation"}, {"score": 0.00481495049065317, "phrase": "shared_data"}, {"score": 0.004672868619910998, "phrase": "parallel_programming"}, {"score": 0.004512372714977782, "phrase": "isolated_execution"}, {"score": 0.0044898971618201255, "phrase": "parallel_programs"}, {"score": 0.004434194655664715, "phrase": "pointer-based_shared_data_structures"}, {"score": 0.004093636514481246, "phrase": "isolated_manner"}, {"score": 0.003972754554131117, "phrase": "high_level"}, {"score": 0.003874740214227237, "phrase": "scalable_parallelization"}, {"score": 0.0038554283270433786, "phrase": "regular_as_well_as_irregular_shared-memory_applications"}, {"score": 0.003769704559197989, "phrase": "data_races"}, {"score": 0.003676681302049705, "phrase": "extra_burden"}, {"score": 0.0034800026627449182, "phrase": "transactional_memory"}, {"score": 0.003454008016586962, "phrase": "key_new_insight"}, {"score": 0.0033771793949625836, "phrase": "concurrent_isolated_tasks"}, {"score": 0.00329381027477194, "phrase": "assembly_a"}, {"score": 0.003228594424567862, "phrase": "shared_heap"}, {"score": 0.0027511447650243846, "phrase": "re-executing_the_task_a"}, {"score": 0.0024705891356454524, "phrase": "habanero_java_parallel_programming_language"}, {"score": 0.0023975191459662615, "phrase": "union-find_data_structure"}, {"score": 0.0023266052292186157, "phrase": "thorough_evaluation"}, {"score": 0.0022804957548193078, "phrase": "excellent_scalability"}, {"score": 0.002229711543930988, "phrase": "existing_approaches"}, {"score": 0.002158342205806634, "phrase": "state-of-the-art_customized_implementations"}, {"score": 0.0021155603555266453, "phrase": "coarse-grained_locking"}, {"score": 0.0021049977753042253, "phrase": "transactional_memory_approaches"}], "paper_keywords": ["Languages", " Design", " Isolation", " Programming abstractions", " Irregular parallelism", " Contention"], "paper_abstract": "Isolation-the property that a task can access shared data without interference from other tasks-is one of the most basic concerns in parallel programming. In this paper, we present Aida, a new model of isolated execution for parallel programs that perform frequent, irregular accesses to pointer-based shared data structures. The three primary benefits of Aida are dynamism, safety and liveness guarantees, and programmability. First, Aida allows tasks to dynamically select and modify, in an isolated manner, arbitrary fine-grained regions in shared data structures, all the while maintaining a high level of concurrency. Consequently, the model can achieve scalable parallelization of regular as well as irregular shared-memory applications. Second, the model offers freedom from data races, deadlocks, and livelocks. Third, no extra burden is imposed on programmers, who access the model via a simple, declarative isolation construct that is similar to that for transactional memory. The key new insight in Aida is a notion of delegation among concurrent isolated tasks (known in Aida as assemblies). Each assembly A is equipped with a region in the shared heap that it owns-the only objects accessed by A are those it owns, guaranteeing race-freedom. The region owned by A can grow or shrink flexibly-however, when A needs to own a datum owned by B, A delegates itself, as well as its owned region, to B. From now on, B has the responsibility of re-executing the task A set out to complete. Delegation as above is the only inter-assembly communication primitive in Aida. In addition to reducing contention in a local, data-driven manner, it guarantees freedom from deadlocks and livelocks. We offer an implementation of Aida on top of the Habanero Java parallel programming language. The implementation employs several novel ideas, including the use of a union-find data structure to represent tasks and the regions that they own. A thorough evaluation using several irregular data-parallel benchmarks demonstrates the low overhead and excellent scalability of Aida, as well as its benefits over existing approaches to declarative isolation. Our results show that Aida performs on par with the state-of-the-art customized implementations of irregular applications and much better than coarse-grained locking and transactional memory approaches.", "paper_title": "Delegated Isolation", "paper_id": "WOS:000298294500052"}