{"auto_keywords": [{"score": 0.04914219295495046, "phrase": "latency-critical_workloads"}, {"score": 0.011902874495264374, "phrase": "batch_applications"}, {"score": 0.010747558638803183, "phrase": "average_performance"}, {"score": 0.009147187608855972, "phrase": "last-level_caches"}, {"score": 0.008388233529290893, "phrase": "conventional_qos_frameworks"}, {"score": 0.007969464103602211, "phrase": "ubik"}, {"score": 0.006914983752271393, "phrase": "tail_latency"}, {"score": 0.00481495049065317, "phrase": "efficient_cache"}, {"score": 0.004758188582347737, "phrase": "strict_qos"}, {"score": 0.0045557008859819234, "phrase": "workload_mixes"}, {"score": 0.0045198174374297285, "phrase": "different_performance_requirements"}, {"score": 0.004293336465549723, "phrase": "low_tail"}, {"score": 0.004078157608867258, "phrase": "millisecond_range"}, {"score": 0.004014135205423942, "phrase": "inherently_low_utilization"}, {"score": 0.003919973783578995, "phrase": "compute-intensive_batch_applications"}, {"score": 0.0038584709509350214, "phrase": "mapreduce"}, {"score": 0.0037978390554858766, "phrase": "high_long-term"}, {"score": 0.0037234376132464463, "phrase": "current_cmps"}, {"score": 0.003508834578859094, "phrase": "shared_resources"}, {"score": 0.0029949359231919307, "phrase": "low_tail_latency"}, {"score": 0.0029595657769783314, "phrase": "microarchitectural_resources"}, {"score": 0.0028110458014332187, "phrase": "instantaneous_workload_performance"}, {"score": 0.0027559226203857316, "phrase": "highest_inertia"}, {"score": 0.002324238863944163, "phrase": "transient_behavior"}, {"score": 0.0022428042503686053, "phrase": "cache_space"}, {"score": 0.0021814396743238176, "phrase": "extensive_simulations"}], "paper_keywords": ["multicore", " interference", " isolation", " quality of service", " tail latency", " resource management", " cache partitioning"], "paper_abstract": "Chip-multiprocessors (CMPs) must often execute workload mixes with different performance requirements. On one hand, user-facing, latency-critical applications (e.g., web search) need low tail (i.e., worst-case) latencies, often in the millisecond range, and have inherently low utilization. On the other hand, compute-intensive batch applications (e.g., MapReduce) only need high long-term average performance. In current CMPs, latency-critical and batch applications cannot run concurrently due to interference on shared resources. Unfortunately, prior work on quality of service (QoS) in CMPs has focused on guaranteeing average performance, not tail latency. In this work, we analyze several latency-critical workloads, and show that guaranteeing average performance is insufficient to maintain low tail latency, because microarchitectural resources with state, such as caches or cores, exert inertia on instantaneous workload performance. Last-level caches impart the highest inertia, as workloads take tens of milliseconds to warm them up. When left unmanaged, or when managed with conventional QoS frameworks, shared last-level caches degrade tail latency significantly. Instead, we propose Ubik, a dynamic partitioning technique that predicts and exploits the transient behavior of latency-critical workloads to maintain their tail latency while maximizing the cache space available to batch applications. Using extensive simulations, we show that, while conventional QoS frameworks degrade tail latency by up to 2.3x, Ubik simultaneously maintains the tail latency of latency-critical workloads and significantly improves the performance of batch applications.", "paper_title": "Ubik: Efficient Cache Sharing with Strict QoS for Latency-Critical Workloads", "paper_id": "WOS:000360535000051"}