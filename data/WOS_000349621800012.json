{"auto_keywords": [{"score": 0.04973325992892517, "phrase": "distributed_graphs"}, {"score": 0.04754343387139429, "phrase": "graph_data"}, {"score": 0.00481495049065317, "phrase": "efficient_parallel_processing_of_distance_join_queries"}, {"score": 0.0045933810497156705, "phrase": "particularly_useful_operation"}, {"score": 0.004478308876320956, "phrase": "graph_similarity"}, {"score": 0.00442987501427177, "phrase": "meaningful_way"}, {"score": 0.0041051328120736575, "phrase": "current_methods"}, {"score": 0.004046020290832207, "phrase": "centralized_systems"}, {"score": 0.003916098498242888, "phrase": "effective_pruning"}, {"score": 0.003681923235979914, "phrase": "distributed_environment"}, {"score": 0.0034742854447532678, "phrase": "efficient_parallel_processing"}, {"score": 0.003399466007862412, "phrase": "distributed_large_graphs"}, {"score": 0.0032783186166708985, "phrase": "large_graphs"}, {"score": 0.0032546105164772995, "phrase": "distributed_and_parallel_systems"}, {"score": 0.003196091918220817, "phrase": "pregel"}, {"score": 0.0031386091093713706, "phrase": "iterative_computing_framework"}, {"score": 0.003115908199991072, "phrase": "haloop"}, {"score": 0.0028352726653271187, "phrase": "query_efficiency"}, {"score": 0.0027441220799352926, "phrase": "optimization_problem"}, {"score": 0.002704554429386671, "phrase": "iterative_join"}, {"score": 0.002675252546913683, "phrase": "graph_exploration_method"}, {"score": 0.0026366753045215558, "phrase": "evaluation_time"}, {"score": 0.0025518930446603335, "phrase": "system's_scalability"}, {"score": 0.0025059724686541263, "phrase": "light-weight_vertex_centric_encoding_schema"}, {"score": 0.002469830206270585, "phrase": "distance-aware_partition"}, {"score": 0.0024430651605100214, "phrase": "entire_graph"}, {"score": 0.0024253827365474734, "phrase": "extensive_experiments"}, {"score": 0.002347378595930709, "phrase": "adaptive_query_plan_generation"}, {"score": 0.002263639474937039, "phrase": "redundant_message"}, {"score": 0.002206801982145622, "phrase": "iterative_join_or_graph_exploration_method"}, {"score": 0.0021049977753042253, "phrase": "query_evaluation"}], "paper_keywords": ["Distance join query", " distributed graph processing"], "paper_abstract": "Distance join queries have recently been recognized as a particularly useful operation over graph data, since they capture graph similarity in a meaningful way. Consequently, they have been studied extensively in recent years [1], [2]. However, current methods are designed for centralized systems, and rely on the graph embedding for effective pruning and indexing. As graph sizes become very large and graph data must be deployed in the distributed environment, these techniques become impractical. In this work, we propose a solution for efficient parallel processing of distance join queries over distributed large graphs. There have been emerging efforts devoted to managing large graphs in distributed and parallel systems. Programming models like Pregel [3] and iterative computing framework like HaLoop [4] have been proposed to handle queries over distributed graphs. However, they are designed in the perspective of functionality instead of the query efficiency. In this work, we define an optimization problem: combining the iterative join and the graph exploration method to minimize the evaluation time of distance join queries. Without sacrificing a system's scalability, our technique exploits a light-weight vertex centric encoding schema built on a distance-aware partition of the entire graph. Extensive experiments over both real and synthetic large graphs show that, by employing an adaptive query plan generation and scheduling method, we can effectively reduce the redundant message passing and I/O costs. Compared to simply using iterative join or graph exploration method, our solution achieves as many as one order of magnitude of time saving for the query evaluation.", "paper_title": "Efficient Parallel Processing of Distance Join Queries Over Distributed Graphs", "paper_id": "WOS:000349621800012"}