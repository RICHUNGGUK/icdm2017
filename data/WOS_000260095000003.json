{"auto_keywords": [{"score": 0.03983926434466607, "phrase": "java_rmi"}, {"score": 0.017693750649035143, "phrase": "bluetooth"}, {"score": 0.010479126673145283, "phrase": "heterogeneous_wireless_networks"}, {"score": 0.01012113834117584, "phrase": "wireless_environments"}, {"score": 0.009060730504101335, "phrase": "rmi"}, {"score": 0.008318577193867242, "phrase": "heterogeneous_wireless_environments"}, {"score": 0.008008405058783157, "phrase": "gprs"}, {"score": 0.007932713525159589, "phrase": "wlan"}, {"score": 0.00481495049065317, "phrase": "mobile_java"}, {"score": 0.004664352260912174, "phrase": "distributed_object-oriented_platforms"}, {"score": 0.004518442937844318, "phrase": "collaborative_computation"}, {"score": 0.004447201233380302, "phrase": "large_pool"}, {"score": 0.004419018661564621, "phrase": "distributed_resources"}, {"score": 0.004349337717774093, "phrase": "important_layers"}, {"score": 0.004226657532307611, "phrase": "remoting_mechanisms"}, {"score": 0.004160073592940986, "phrase": "java"}, {"score": 0.004133627071344356, "phrase": "remote_method_invocation"}, {"score": 0.004055511503825102, "phrase": "distributed_controls"}, {"score": 0.003903663808332582, "phrase": "important_layer"}, {"score": 0.003709974534103202, "phrase": "case_study"}, {"score": 0.003525861581971337, "phrase": "important_middleware"}, {"score": 0.003503497128638099, "phrase": "component_communications"}, {"score": 0.0034702152241316763, "phrase": "bluetooth_layer"}, {"score": 0.0033829958125964877, "phrase": "protocol_stack_layers"}, {"score": 0.003144222265269426, "phrase": "java_rmi_sockets"}, {"score": 0.0030651710672229926, "phrase": "rmi_implementation"}, {"score": 0.0030457198309616694, "phrase": "ip_layer"}, {"score": 0.0028944757265206332, "phrase": "direct_connection"}, {"score": 0.0027159094186967247, "phrase": "existing_connection"}, {"score": 0.002690089103664187, "phrase": "mobile_node"}, {"score": 0.0025892330566358503, "phrase": "high-level_applications"}, {"score": 0.0024921488266216024, "phrase": "dynamic_addresses"}, {"score": 0.00247632489362785, "phrase": "dynamic_sockets"}, {"score": 0.0024063484128685367, "phrase": "handoff_process"}, {"score": 0.0023532890136269986, "phrase": "connect-loss_detection"}, {"score": 0.002338344706059989, "phrase": "data-integrity_maintenance"}, {"score": 0.0023087395374178144, "phrase": "roaming_scenarios"}, {"score": 0.00227225841515826, "phrase": "java_grande_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "java_layers"}], "paper_keywords": ["Java RMI support", " Heterogeneous wireless computing", " Component software in overlaying networks", " Service middleware for wireless environments", " Parallel and distributed computing"], "paper_abstract": "Distributed object-oriented platforms are increasingly important in wireless environments to provide frameworks for collaborative computation and for managing a large pool of distributed resources. One of the important layers for implementing distributed computing in such environments is via remoting mechanisms. For example, Java uses Remote Method Invocation (RMI) for handling distributed controls. In this paper, we investigate the support for this important layer on wireless environments and address the issues to support Java RMI over heterogeneous wireless environments. We present a case study for supporting Java RMI in Bluetooth, GPRS, and WLAN environments, which represents an important middleware for component communications. The Bluetooth layer is supported by incorporating a set of protocol stack layers for Bluetooth, known as JavaBT that has been developed by us, and by supporting an L2CAP layer with sockets to support Java RMI sockets. RMI over GPRS/WLAN is achieved by RMI implementation over IP layer. Our support for the roaming of Java RMI over heterogeneous wireless networks is based on the concept of direct connection, which avoids the problems caused by forwarding. The difficulty of this strategy is how to handle the existing connection when the mobile node moves to another location so as to avoid interruption of the high-level applications. We solve this problem in Java RMI by the support of dynamic addresses and dynamic sockets. We also propose algorithms to handle the handoff process. In addition, methods for connect-loss detection and data-integrity maintenance in dealing with roaming scenarios are also presented.Java Grande benchmarks are used to demonstrate that our RMI implementations over GPRS, WLAN, and Bluetooth networks are effective in supporting parallel and distributed control of Java layers in heterogeneous wireless environments. (C) 2008 Elsevier Inc. All rights reserved.", "paper_title": "Mobile Java RMI support over heterogeneous wireless networks: A case study", "paper_id": "WOS:000260095000003"}