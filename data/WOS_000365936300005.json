{"auto_keywords": [{"score": 0.027217304358135155, "phrase": "k-means"}, {"score": 0.00481495049065317, "phrase": "statistical_based"}, {"score": 0.004731928080086235, "phrase": "prioritizing_program"}, {"score": 0.0044718206943536514, "phrase": "strong_points"}, {"score": 0.00443308765153716, "phrase": "statistical_debugging"}, {"score": 0.004394688617163029, "phrase": "program_slicing_techniques"}, {"score": 0.004356620736507642, "phrase": "efficient_program_fault_localization"}, {"score": 0.004300133642951283, "phrase": "dynamic_slices"}, {"score": 0.004189337956225294, "phrase": "redundant_information"}, {"score": 0.003958937342925219, "phrase": "computed_slice"}, {"score": 0.0038401488612789963, "phrase": "conventional_statistical_debugging_techniques"}, {"score": 0.003757480190200645, "phrase": "dependence_relationships"}, {"score": 0.0037087324991876727, "phrase": "faulty_code"}, {"score": 0.0035662378173267647, "phrase": "erroneous_output"}, {"score": 0.0032404677650217407, "phrase": "new_method"}, {"score": 0.0032263862712733934, "phrase": "stat-slice"}, {"score": 0.003170667618004276, "phrase": "latent_bugs"}, {"score": 0.003048782877550259, "phrase": "wider_range"}, {"score": 0.0029701328654852246, "phrase": "omitted_code_faults"}, {"score": 0.0027581067089091434, "phrase": "traditional_program"}, {"score": 0.0026986685585382347, "phrase": "proposed_method"}, {"score": 0.002663620639539737, "phrase": "backward_dynamic_slices"}, {"score": 0.0025128628931797947, "phrase": "siemens"}, {"score": 0.0024950747439601863, "phrase": "new_ranking"}, {"score": 0.002473420909291381, "phrase": "pruning_technique"}, {"score": 0.0022277448907881306, "phrase": "flex_test_suites"}, {"score": 0.0021987994275190314, "phrase": "ranking_statements"}, {"score": 0.0021049977753042253, "phrase": "fault_localization"}], "paper_keywords": ["Fault localization", " dynamic slicing", " statistical debugging", " clustering", " Pearson", " fault"], "paper_abstract": "The aim of this paper is to integrate the strong points of statistical debugging and program slicing techniques for efficient program fault localization. The dynamic slices could be inappropriately large including redundant information considering that the statements are not ranked according to their fault relevance in the computed slice. On the other hand, the conventional statistical debugging techniques do not consider the dependence relationships between the faulty code (i.e., the cause) and the erroneous output (i.e., the effect). This information is very useful during the debugging. In this paper, a new method Stat-Slice for locating the latent bugs in programs is presented which could find a wider range of bugs, e.g. the omitted code faults, the header file faults, and etc., comparing with other techniques. Unlike the traditional program slicing techniques, the proposed method computes the backward dynamic slices of several failing and passing runs. Using K-means clustering in addition to a new ranking and pruning technique, we prioritize statements according to their likelihood to be the cause for failure. Our experiments on Siemens, grep, gzip, and flex test suites manifest that ranking statements according to their suspiciousness has considerably reduced the effort for fault localization.", "paper_title": "STATISTICAL BASED SLICING METHOD FOR PRIORITIZING PROGRAM FAULT RELEVANT STATEMENTS", "paper_id": "WOS:000365936300005"}