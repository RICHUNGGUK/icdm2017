{"auto_keywords": [{"score": 0.04261019441517552, "phrase": "beame"}, {"score": 0.04111927933175921, "phrase": "j._comput"}, {"score": 0.040956747808935386, "phrase": "system_sci"}, {"score": 0.015719697455965315, "phrase": "cell_probe_model"}, {"score": 0.012929418275760409, "phrase": "predecessor_problem"}, {"score": 0.01012033558803443, "phrase": "query_schemes"}, {"score": 0.008824220013682788, "phrase": "noam_nisan"}, {"score": 0.008788170723307672, "phrase": "s._safra"}, {"score": 0.00875226740346064, "phrase": "a._wigderson"}, {"score": 0.008698684849285316, "phrase": "data_structures"}, {"score": 0.008663143921111099, "phrase": "asymmetric_communication_complexity"}, {"score": 0.00471700544744796, "phrase": "subset_s"}, {"score": 0.004300226713421209, "phrase": "a.c.-c._yao"}, {"score": 0.004238775572746022, "phrase": "j._assoc"}, {"score": 0.0042041721145332465, "phrase": "mach"}, {"score": 0.004051281014722791, "phrase": "fich"}, {"score": 0.0039362878637371574, "phrase": "related_problems"}, {"score": 0.003808845109556467, "phrase": "optimal_bounds"}, {"score": 0.003677938447045585, "phrase": "deterministic_query_scheme"}, {"score": 0.0036553070575015344, "phrase": "associated_storage_scheme"}, {"score": 0.0036030386046805598, "phrase": "word_size"}, {"score": 0.0035224030823976186, "phrase": "new_lower_bound_proof"}, {"score": 0.003373422841342524, "phrase": "randomised_query_schemes"}, {"score": 0.0033457659530207306, "phrase": "beame_and_fich's_proof"}, {"score": 0.0033251716926666437, "phrase": "deterministic_query_schemes"}, {"score": 0.003244050414264445, "phrase": "fich's_proof"}, {"score": 0.0031518989079229714, "phrase": "'quantum_address-only'_query_schemes"}, {"score": 0.003074991770768925, "phrase": "quantum_parallelism"}, {"score": 0.0030372426452745073, "phrase": "'address_lines"}, {"score": 0.0029876282026237207, "phrase": "subsume_classical_randomised_query_schemes"}, {"score": 0.0029509483926257645, "phrase": "grover's_algorithm"}, {"score": 0.002938821840519756, "phrase": "l._grover"}, {"score": 0.002890810475014827, "phrase": "database_search"}, {"score": 0.002757092564498226, "phrase": "miltersen"}, {"score": 0.002745765961579447, "phrase": "nisan"}, {"score": 0.002734474367289978, "phrase": "safra"}, {"score": 0.0027232394167563054, "phrase": "wigderson"}, {"score": 0.002539061433603083, "phrase": "information_theory"}, {"score": 0.0025130460190930554, "phrase": "strong_round_elimination_lemma"}, {"score": 0.0024017007954518065, "phrase": "quantum_communication_complexity"}, {"score": 0.002347887699678059, "phrase": "communication_tradeoff"}, {"score": 0.002333421318779658, "phrase": "'greater-than'_problem"}, {"score": 0.0021488235554917128, "phrase": "independent_interest"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["predecessor searching problem", " cell probe model", " data structures", " lower bounds"], "paper_abstract": "We consider a fundamental problem in data structures, static predecessor searching: Given a subset S of size n from the universe [m], store S so that queries of the form \"What is the predecessor of x in S?\" can be answered efficiently. We study this problem in the cell probe model introduced by Yao [A.C.-C. Yao, Should tables be sorted, J. Assoc. Comput. Mach. 28 (3) (1981) 615-628]. Recently, Beame and Fich [P. Beame, F. Fich, Optimal bounds for the predecessor problem and related problems, J. Comput. System Sci. 65 (1) (2002) 38-72] obtained optimal bounds as functions of either m or n only on the number of probes needed by any deterministic query scheme if the associated storage scheme uses only n(O(1)) cells of word size (log m)(O(1)) bits. We give a new lower bound proof for this problem that matches the bounds of Beame and Fich. Our lower bound proof has the following advantages: it works for randomised query schemes too, while Beame and Fich's proof works for deterministic query schemes only. In addition, it is simpler than Beame and Fich's proof. In fact, our lower bound for predecessor searching extends to the 'quantum address-only' query schemes that we define in this paper. In these query schemes, quantum parallelism is allowed only over the 'address lines' of the queries. These query schemes subsume classical randomised query schemes, and include many quantum query algorithms like Grover's algorithm [L. Grover, A fast quantum mechanical algorithm for database search, in: Proceedings of the 28th Annual ACM Symposium on Theory of Computing, 1996, pp. 212-219]. We prove our lower bound using the round elimination approach of Miltersen, Nisan, Safra and Wigderson [P. Bro Miltersen, Noam Nisan, S. Safra, A. Wigderson, On data structures and asymmetric communication complexity, J. Comput. System Sci. 57 (1) (1998) 37-49]. Using tools from information theory, we prove a strong round elimination lemma for communication complexity that enables us to obtain a tight lower bound for the predecessor problem. Our strong round elimination lemma also extends to quantum communication complexity. We also use our round elimination lemma to obtain a rounds versus communication tradeoff for the 'greater-than' problem, improving on the tradeoff in [P. Bro Miltersen, Noam Nisan, S. Safra, A. Wigderson, On data structures and asymmetric communication complexity, J. Comput. System Sci. 57 (1) (1998) 37-49]. We believe that our round elimination lemma is of independent interest and should have other applications. (c) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Lower bounds for predecessor searching in the cell probe model", "paper_id": "WOS:000253501500008"}