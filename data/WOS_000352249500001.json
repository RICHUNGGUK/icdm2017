{"auto_keywords": [{"score": 0.04961049691122095, "phrase": "structural_analysis"}, {"score": 0.00481495049065317, "phrase": "legacy_parallel_applications"}, {"score": 0.004561386908745206, "phrase": "large_hpc_applications"}, {"score": 0.004342430078306461, "phrase": "major_difficulties"}, {"score": 0.004257806363128601, "phrase": "disaggregated_environment"}, {"score": 0.004216112320418982, "phrase": "hpc_application_development"}, {"score": 0.004053362743156545, "phrase": "local_decisions"}, {"score": 0.0036914757355166966, "phrase": "major_global_change"}, {"score": 0.003531474887552889, "phrase": "large_portions"}, {"score": 0.003479692058963528, "phrase": "source_code"}, {"score": 0.0033950634506367235, "phrase": "-automated_techniques"}, {"score": 0.0032319109979344184, "phrase": "global_transformations"}, {"score": 0.0031845067058084613, "phrase": "hpc_application_source_code"}, {"score": 0.0030615444518947337, "phrase": "fortran"}, {"score": 0.002928682556953258, "phrase": "nwchem"}, {"score": 0.0028154895878702633, "phrase": "structural_rewriting_techniques"}, {"score": 0.0026933542552712033, "phrase": "multiple_sections"}, {"score": 0.0026538282523433684, "phrase": "application's_source_code"}, {"score": 0.0025014259919355453, "phrase": "systematic_fashion"}, {"score": 0.002464709648714996, "phrase": "source_code_bases"}, {"score": 0.0024405312482831646, "phrase": "minimal_manual_effort"}, {"score": 0.0023346234464901978, "phrase": "scf_benchmark"}, {"score": 0.0022223176391038785, "phrase": "full_ccsd_module"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Source-to-source transformations", " Term rewriting", " Semantic patches", " Legacy parallel applications"], "paper_abstract": "Performance and scalability optimization of large HPC applications is currently a labor-intensive, manual process with very low productivity. Major difficulties come from the disaggregated environment for HPC application development: the compiler is only involved in local decisions (core or multithreaded domain), while a library-based, communication-oriented programming model realizes whole-machine parallelism. Realizing any major global change in such a disaggregated environment is very difficult and involves changing large portions of the source code. We present semi-automated techniques, based on structural analysis and rewriting, for performing global transformations on an HPC application source code. We present two case studies using the Self-Consistent Field (SCF) standalone benchmark as well as the Coupled Cluster (CCSD) module (2.9 million lines of Fortran code), a key module of the NWChem computational chemistry application. We demonstrate how structural rewriting techniques can be used to automate transformations that affect multiple sections of the application's source code. We show that the transformations can be applied in a systematic fashion across the source code bases with minimal manual effort. These transformations improve the scalability of the SCF benchmark by more than two orders of magnitude and the performance of the full CCSD module by a factor of four. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Global transformations for legacy parallel applications via structural analysis and rewriting", "paper_id": "WOS:000352249500001"}