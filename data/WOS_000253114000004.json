{"auto_keywords": [{"score": 0.04229912314242765, "phrase": "stateless_traits"}, {"score": 0.03468161201150871, "phrase": "stateful_traits"}, {"score": 0.00481495049065317, "phrase": "fine-grained_mechanism"}, {"score": 0.00471503739362446, "phrase": "reusable_components"}, {"score": 0.004559451202070545, "phrase": "multiple_inheritance"}, {"score": 0.003936698872193083, "phrase": "required_methods"}, {"score": 0.003604506544515223, "phrase": "software_components"}, {"score": 0.0034130176595901104, "phrase": "significant_amounts"}, {"score": 0.0033844715014920233, "phrase": "boilerplate_glue_code"}, {"score": 0.0032046343506232588, "phrase": "guiding_principle"}, {"score": 0.00299632091372281, "phrase": "minimal_extension"}, {"score": 0.0029340342068081247, "phrase": "instance_variables"}, {"score": 0.0027088948471991454, "phrase": "composing_client"}, {"score": 0.002586513876943306, "phrase": "formal_object_calculus"}, {"score": 0.002500987934534128, "phrase": "flattening_property"}, {"score": 0.0022800613046444563, "phrase": "case_study"}, {"score": 0.0021861845339709533, "phrase": "trait-based_version"}, {"score": 0.002158780936704905, "phrase": "smalltalk_collection_hierarchy"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["traits", " mixin", " multiple-inheritance", " Eiffel", " Jigsaw", " flattening"], "paper_abstract": "Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy. (c) 2007 Elsevier Ltd. All rights reserved.", "paper_title": "Stateful traits and their formalization", "paper_id": "WOS:000253114000004"}