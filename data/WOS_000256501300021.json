{"auto_keywords": [{"score": 0.04925795561529137, "phrase": "code_mutation"}, {"score": 0.04018921998628565, "phrase": "proprietary_application"}, {"score": 0.015719716506582538, "phrase": "proprietary_applications"}, {"score": 0.00469159356595623, "phrase": "industry_vendors"}, {"score": 0.004531997388646422, "phrase": "third_party_vendors"}, {"score": 0.004415857432588371, "phrase": "bench-marking_process"}, {"score": 0.004084920064588169, "phrase": "real-life_applications"}, {"score": 0.0037786899855446, "phrase": "reverse_engineering"}, {"score": 0.003405671497507337, "phrase": "key_idea"}, {"score": 0.003361702510958392, "phrase": "proposed_code_mutation_approach"}, {"score": 0.0032896745636186824, "phrase": "proprietary_application's_dynamic_memory_access"}, {"score": 0.00308269056870936, "phrase": "application_code"}, {"score": 0.0029776614744264724, "phrase": "program_slices"}, {"score": 0.0029519664912853938, "phrase": "memory_access_operations"}, {"score": 0.002863762666256937, "phrase": "constant_value"}, {"score": 0.0028390477456009568, "phrase": "branch_profiles"}, {"score": 0.0026835045963349647, "phrase": "binary_rewriting"}, {"score": 0.0026146111113065393, "phrase": "mibench"}, {"score": 0.0025364615261136655, "phrase": "promising_technique"}, {"score": 0.0024713335323674223, "phrase": "static_binary"}, {"score": 0.0024183363693242943, "phrase": "dynamically_executed_instructions"}, {"score": 0.0022758994740331258, "phrase": "performance_characteristics"}, {"score": 0.0021418339161425994, "phrase": "wide_range"}, {"score": 0.0021049977753042253, "phrase": "hardware_implementations"}], "paper_keywords": ["experimentation", " measurement", " performance", " benchmark generation", " code mutation"], "paper_abstract": "Industry vendors hesitate to disseminate proprietary applications to academia and third party vendors. By consequence, the bench-marking process is typically driven by standardized, open-source benchmarks which may be very different from and likely not representative of the real-life applications of interest. This paper proposes code mutation, a novel technique that mutates a proprietary application to complicate reverse engineering so that it can be distributed as a benchmark. The benchmark mutant then serves as a proxy for the proprietary application. The key idea in the proposed code mutation approach is to preserve the proprietary application's dynamic memory access and/or control flow behavior in the benchmark mutant while mutating the rest of the application code. To this end, we compute program slices for memory access operations and/or control flow operations trimmed through constant value and branch profiles; and subsequently mutate the instructions not appearing in these slices through binary rewriting. Our experimental results using SPEC CPU2000 and MiBench benchmarks show that code mutation is a promising technique that mutates up to 90% of the static binary, up to 50% of the dynamically executed instructions, and up to 35% of the at run time exposed inter-operation data dependencies. The performance characteristics of the mutant are very similar to those of the proprietary application across a wide range of microarchitectures and hardware implementations.", "paper_title": "Dispersing proprietary applications as benchmarks through code mutation", "paper_id": "WOS:000256501300021"}