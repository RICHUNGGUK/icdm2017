{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "locally_stable_predicate"}, {"score": 0.011535686525332819, "phrase": "underlying_computation"}, {"score": 0.004746065479362881, "phrase": "distributed_system"}, {"score": 0.004633429997452688, "phrase": "efficient_approach"}, {"score": 0.004480196733208298, "phrase": "distributed_computation"}, {"score": 0.004270003565426343, "phrase": "locally_stable_predicates"}, {"score": 0.0039729853486821995, "phrase": "application_messages"}, {"score": 0.0038600230206554792, "phrase": "control_information"}, {"score": 0.0034725269588525534, "phrase": "worst-case_message_complexity"}, {"score": 0.0026523079380037706, "phrase": "time_units"}, {"score": 0.0025521085778978042, "phrase": "communication_topology"}, {"score": 0.0022302306304023602, "phrase": "stable_predicate"}, {"score": 0.0021876814398268775, "phrase": "monotonic_function"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["monitoring distributed computation", " stable property detection", " termination detection", " deadlock detection", " global virtual time computation", " inconsistent snapshots"], "paper_abstract": "We present an efficient approach to detect a locally stable predicate in a distributed computation. Examples of properties that can be formulated as locally stable predicates include termination and deadlock of a subset of processes. Our algorithm does not require application messages to be modified to carry control information (e.g., vector timestamps), nor does it inhibit events (or actions) of the underlying computation. The worst-case message complexity of our algorithm is O(n(m + 1)), where n is the number of processes in the system and m is the number of events executed by the underlying computation. We show that, in practice, its message complexity should be much lower than its worst-case message complexity. The detection latency of our algorithm is O(d) time units, where d is the diameter of communication topology. Our approach also unifies several known algorithms for detecting termination and deadlock. We also show that our algorithm for detecting a locally stable predicate can be used to efficiently detect a stable predicate that is a monotonic function of other locally stable predicates. (c) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Efficient detection of a locally stable predicate in a distributed system", "paper_id": "WOS:000245827300003"}