{"auto_keywords": [{"score": 0.04187714396259639, "phrase": "register_allocator"}, {"score": 0.015719716506582538, "phrase": "register_allocation"}, {"score": 0.004638602678192715, "phrase": "allocation_algorithms"}, {"score": 0.003571751184289622, "phrase": "incorrect_output_code"}, {"score": 0.0035150223642728437, "phrase": "output_program"}, {"score": 0.0033861224940737846, "phrase": "test_data"}, {"score": 0.003159106878239524, "phrase": "novel_data_flow_analyses"}, {"score": 0.0030595112110658675, "phrase": "output_code"}, {"score": 0.0027058852678238632, "phrase": "error_locations"}, {"score": 0.0026345758986796703, "phrase": "false_alarms"}, {"score": 0.002497531381123025, "phrase": "sarac"}, {"score": 0.0021620042653528846, "phrase": "average_compile-time_overhead"}, {"score": 0.0021049977753042253, "phrase": "modest_average_memory_overhead"}], "paper_keywords": [""], "paper_abstract": "Although there are many register allocation algorithms that work well, it can be difficult to correctly implement these algorithms. As a result, it is common for bugs to remain in the register allocator, even after the compiler is released. The register allocator may run, but bugs can cause it to produce incorrect output code. The output program may even execute properly on some test data, but errors can remain. In this paper, we propose novel data flow analyses to statically check that the output code from the register allocator is correct in terms of its data dependences. The approach is accurate, fast, and can identify and report error locations and types. No false alarms are produced. The paper describes our approach, called SARAC, and a tool, called ra-analyzer, that statically checks a register allocation and reports the errors it finds. The tool has an average compile-time overhead of only 8% and a modest average memory overhead of 85KB.", "paper_title": "Catching and identifying bugs in register allocation", "paper_id": "WOS:000240590200019"}