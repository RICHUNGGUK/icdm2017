{"auto_keywords": [{"score": 0.04937387161038603, "phrase": "taint_data"}, {"score": 0.04242092921688311, "phrase": "buffer_overflow"}, {"score": 0.04201891621603315, "phrase": "taint_tracking"}, {"score": 0.030626517746046304, "phrase": "dynamic_instrumentation"}, {"score": 0.00481495049065317, "phrase": "lightweight_run-time"}, {"score": 0.004697308822154191, "phrase": "buffer_overflow_attacks"}, {"score": 0.004628101576367193, "phrase": "buffer_overflow_attack"}, {"score": 0.00442651096522781, "phrase": "allocated_memory"}, {"score": 0.004171259063201874, "phrase": "software_vulnerabilities"}, {"score": 0.00395017798595193, "phrase": "novel_technique"}, {"score": 0.003853583126988071, "phrase": "previous_studies"}, {"score": 0.0037593414153801394, "phrase": "victim's_program"}, {"score": 0.0034047882921717913, "phrase": "malicious_code"}, {"score": 0.0032887360307856635, "phrase": "critical_problem"}, {"score": 0.002862648127577722, "phrase": "taint_information_maintenance"}, {"score": 0.0027787638791664663, "phrase": "new_taint-style_system"}, {"score": 0.0027513507830537165, "phrase": "embedded_tainttracker"}, {"score": 0.002579622880371082, "phrase": "checking_mechanism"}, {"score": 0.0025415366388578465, "phrase": "operating_system"}, {"score": 0.0023947191132328233, "phrase": "compilation_time"}, {"score": 0.0023245146355917626, "phrase": "proposed_system"}, {"score": 0.0022901862321082407, "phrase": "previous_work"}, {"score": 0.0021365562685368767, "phrase": "taintcheck"}], "paper_keywords": ["software security", " buffer overflow", " taint tracking"], "paper_abstract": "A buffer overflow attack occurs when a program writes data outside the allocated memory in an attempt to invade a system. Approximately forty percent of all software vulnerabilities over the past several years are attributed to buffer overflow. Taint tracking is a novel technique to prevent buffer overflow. Previous studies on taint tracking ran a victim's program on an emulator to dynamically instrument the code for tracking the propagation of taint data in memory and checking whether malicious code is executed. However, the critical problem of this approach is its heavy performance overhead. Analysis of this overhead shows that 60% of the overhead is from the emulator, and the remaining 40% is from dynamic instrumentation and taint information maintenance. This article proposes a new taint-style system called Embedded TaintTracker to eliminate the overhead in the emulator and dynamic instrumentation by compressing a checking mechanism into the operating system (OS) kernel and moving the instrumentation from runtime to compilation time. Results show that the proposed system outperforms the previous work. TaintCheck, by at least 8 times on throughput degradation, and is about 17.5 times faster than TaintCheck when browsing 1 KB web pages.", "paper_title": "Embedded TaintTracker: Lightweight Run-Time Tracking of Taint Data against Buffer Overflow Attacks", "paper_id": "WOS:000296673400008"}