{"auto_keywords": [{"score": 0.036129459385606084, "phrase": "memory_graph"}, {"score": 0.00481495049065317, "phrase": "statically_typed_language_require"}, {"score": 0.004633429997452688, "phrase": "type_safety"}, {"score": 0.0043738432231020885, "phrase": "incoming_values"}, {"score": 0.004076157223660074, "phrase": "programming_languages"}, {"score": 0.003998531873723384, "phrase": "parametric_polymorphism"}, {"score": 0.003947601392882997, "phrase": "uniform_data_representation"}, {"score": 0.0029391032882625473, "phrase": "constraint_solver"}, {"score": 0.002864628676257225, "phrase": "rewriting_system"}, {"score": 0.002738797804069541, "phrase": "proposed_algorithm"}, {"score": 0.002568542343945288, "phrase": "algebraic_data_types"}, {"score": 0.002535779689260244, "phrase": "mutable_data"}, {"score": 0.0021049977753042253, "phrase": "ocaml_compiler"}], "paper_keywords": ["Languages", " Safety", " Type-safe marshalling", " OCaml"], "paper_abstract": "Unmarshalling primitives in statically typed language require, in order to preserve type safety, to dynamically verify the compatibility between the incoming values and the statically expected type. In the context of programming languages based on parametric polymorphism and uniform data representation, we propose a relation of compatibility between (unmarshalled) memory graphs and types. It is defined as constraints over nodes of the memory graph. Then, we propose an algorithm to check the compatibility between a memory graph and a type. It is described as a constraint solver based on a rewriting system. We have shown that the proposed algorithm is sound and semi-complete in presence of algebraic data types, mutable data, polymorphic sharing, cycles, and functional values, however, in its general form, it may not terminate. We have implemented a prototype tailored for the OCaml compiler [17] that always terminates and still seems sufficiently complete in practice.", "paper_title": "Typing Unmarshalling without Marshalling Types", "paper_id": "WOS:000311296000028"}