{"auto_keywords": [{"score": 0.04520816487989674, "phrase": "native_code"}, {"score": 0.013541372968831155, "phrase": "java_bytecode"}, {"score": 0.011717728819329176, "phrase": "runtime_exception_check_sites"}, {"score": 0.011058204463700363, "phrase": "runtime_exceptions"}, {"score": 0.00481495049065317, "phrase": "formal_methods"}, {"score": 0.004653900688892822, "phrase": "just-in-time_compilation"}, {"score": 0.004520132822496416, "phrase": "runtime_performances"}, {"score": 0.004476399615305783, "phrase": "restrained_systems"}, {"score": 0.00443308765153716, "phrase": "java_card"}, {"score": 0.00436890075128947, "phrase": "critical_java_methods"}, {"score": 0.0038876302202924644, "phrase": "memory_constraints"}, {"score": 0.003631671435460452, "phrase": "natively-compiled_code"}, {"score": 0.003231349231968127, "phrase": "java_program"}, {"score": 0.003200045185608395, "phrase": "jml_annotations"}, {"score": 0.002989220655735981, "phrase": "compiled_methods"}, {"score": 0.0028058765785670546, "phrase": "generated_native_code"}, {"score": 0.002545468362709126, "phrase": "java_applications"}, {"score": 0.0024601402359002056, "phrase": "almost_all_the_exception_check_sites"}, {"score": 0.0022756672722130424, "phrase": "non-optimized_version"}, {"score": 0.0021049977753042253, "phrase": "arm_thumb"}], "paper_keywords": [""], "paper_abstract": "Ahead-of-Time and Just-in-Time compilation are common ways to improve runtime performances of restrained systems like Java Card by turning critical Java methods into native code. However, native code is much bigger than Java bytecode, which severely limits or even forbids these practices for devices with memory constraints. In this paper, we describe and evaluate a method for reducing natively-compiled code by suppressing runtime exception check sites, which are emitted when compiling bytecodes that may potentially throw runtime exceptions. This is made possible by completing the Java program with JML annotations, and using a theorem prover in order to formally prove that the compiled methods never throw runtime exceptions. Runtime exception check sites can then safely be removed from the generated native code, as it is proved they will never be entered. We have experimented our approach on several card-range and embedded Java applications, and were able to remove almost all the exception check sites. Results show memory footprints for native code that are up to 70% smaller than the non-optimized version, and sometimes as low than 115% the size of the Java bytecode when compiled for ARM thumb.", "paper_title": "A low-footprint Java-to-native compilation scheme using formal methods", "paper_id": "WOS:000237245000024"}