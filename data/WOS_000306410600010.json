{"auto_keywords": [{"score": 0.04547624598453918, "phrase": "additional_compiler_support"}, {"score": 0.00481495049065317, "phrase": "indirect-branch_targets"}, {"score": 0.004687305496643216, "phrase": "performance_bottleneck"}, {"score": 0.004563028873351776, "phrase": "previous_high-performance_indirect-branch_predictors"}, {"score": 0.004125513927068713, "phrase": "processor_front-end"}, {"score": 0.0038833278847237858, "phrase": "complexity-effective_indirect-branch_prediction_mechanism"}, {"score": 0.0034872225047008648, "phrase": "multiple_indirect-branch_targets"}, {"score": 0.00344062888674746, "phrase": "different_branch_target_buffer"}, {"score": 0.0033946562014968706, "phrase": "btb"}, {"score": 0.003260377175139591, "phrase": "way_locations"}, {"score": 0.0031738126998349775, "phrase": "set-way_index_pointers"}, {"score": 0.00300749708357049, "phrase": "existing_branch-direction_predictor"}, {"score": 0.002888488567436329, "phrase": "branch_direction_predictor"}, {"score": 0.0027187231747900814, "phrase": "pointed_btb_entries"}, {"score": 0.002664375650349975, "phrase": "predicted_indirect-branch_target"}, {"score": 0.002558909812664716, "phrase": "swip_prediction"}, {"score": 0.002507748938616919, "phrase": "attractive_performance_improvement"}, {"score": 0.0024576084154573396, "phrase": "large_dedicated_storage"}, {"score": 0.002344468886431959, "phrase": "indirect-branch_prediction_accuracy"}, {"score": 0.0022215160785078797, "phrase": "commonly-used_btb"}, {"score": 0.0021624739899833868, "phrase": "average_performance_improvement"}], "paper_keywords": ["microprocessor", " indirect-branch prediction", " energy-efficient", " branch target buffer"], "paper_abstract": "Predicting indirect-branch targets has become a performance bottleneck for many applications. Previous high-performance indirect-branch predictors usually require significant hardware storage or additional compiler support, which increases the complexity of the processor front-end or the compilers. This paper proposes a complexity-effective indirect-branch prediction mechanism, called the Set-Way Index Pointing (SWIP) prediction. It stores multiple indirect-branch targets in different branch target buffer (BTB) entries, whose set indices and way locations are treated as set-way index pointers. These pointers are stored in the existing branch-direction predictor. SWIP prediction reuses the branch direction predictor to provide such pointers, and then accesses the pointed BTB entries for the predicted indirect-branch target. Our evaluation shows that SWIP prediction could achieve attractive performance improvement without requiring large dedicated storage or additional compiler support. It improves the indirect-branch prediction accuracy by 36.5% compared to that of a commonly-used BTB, resulting in average performance improvement of 18.56%. Its energy consumption is also reduced by 14.34% over that of the baseline.", "paper_title": "SWIP Prediction: Complexity-Effective Indirect-Branch Prediction Using Pointers", "paper_id": "WOS:000306410600010"}