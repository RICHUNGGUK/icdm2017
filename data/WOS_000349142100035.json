{"auto_keywords": [{"score": 0.040018529529699524, "phrase": "memory_accesses"}, {"score": 0.031143489006296914, "phrase": "proposed_technique"}, {"score": 0.00481495049065317, "phrase": "shared_memory_access_pairs"}, {"score": 0.004656871909510407, "phrase": "concurrent_programs"}, {"score": 0.004319830179921363, "phrase": "sequential_programs"}, {"score": 0.004007083686875716, "phrase": "new_technique"}, {"score": 0.003716894849271535, "phrase": "concurrency_bugs"}, {"score": 0.0035947360742084253, "phrase": "existing_fault_localization_techniques"}, {"score": 0.0034476484413811987, "phrase": "empirical_statistical_approaches"}, {"score": 0.003066945490483524, "phrase": "concurrent_program"}, {"score": 0.0027510752634224726, "phrase": "shared_data"}, {"score": 0.0021049977753042253, "phrase": "failed_runs"}], "paper_keywords": ["Bug Localization", " Shared Memory Access Pair"], "paper_abstract": "Non-determinism in concurrent programs makes their debugging much more challenging than that in sequential programs. To mitigate such difficulties, we propose a new technique to automatically locate buggy shared memory accesses that triggered concurrency bugs. Compared to existing fault localization techniques that are based on empirical statistical approaches, this technique has two advantages. First, as long as enough successful runs of a concurrent program are collected, the proposed technique can locate buggy memory accesses to the shared data even with only one single failed run captured, as opposed to the need of capturing multiple failed runs in other statistical approaches. Second, the proposed technique is more precise because it considers memory accesses in those failed runs that terminate prematurely.", "paper_title": "Concurrency Bug Localization using Shared Memory Access Pairs", "paper_id": "WOS:000349142100035"}