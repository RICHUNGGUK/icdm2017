{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "circular_programs"}, {"score": 0.004667149874736771, "phrase": "higher-order_syntax_functional_pearl"}, {"score": 0.004250302819248558, "phrase": "novel_technique"}, {"score": 0.003993216345115755, "phrase": "first-order_syntax_tree"}, {"score": 0.0037516215763875225, "phrase": "higher-order_interface"}, {"score": 0.0035245918797629804, "phrase": "circular_programming"}, {"score": 0.0032599633778910516, "phrase": "new_variables"}, {"score": 0.003015143226706584, "phrase": "simple_yet_efficient_method"}, {"score": 0.002702887319160534, "phrase": "embedded_languages"}, {"score": 0.002619748321217153, "phrase": "variable_binding"}, {"score": 0.002311933249234786, "phrase": "higher-order_syntax"}, {"score": 0.0021049977753042253, "phrase": "first-order_syntax"}], "paper_keywords": ["higher-order syntax", " embedded languages", " circular programming"], "paper_abstract": "This pearl presents a novel technique for constructing a first-order syntax tree directly from a higher-order interface. We exploit circular programming to generate names for new variables, resulting in a simple yet efficient method. Our motivating application is the design of embedded languages supporting variable binding, where it is convenient to use higher-order syntax when constructing programs, but first-order syntax when processing or transforming programs.", "paper_title": "Using Circular Programs for Higher-Order Syntax Functional pearl", "paper_id": "WOS:000327696700024"}