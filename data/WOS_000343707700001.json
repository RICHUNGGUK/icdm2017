{"auto_keywords": [{"score": 0.049217710328296, "phrase": "orc_language"}, {"score": 0.04879257974669139, "phrase": "execution_status"}, {"score": 0.0048149533512024095, "phrase": "utp"}, {"score": 0.0046432244185370605, "phrase": "fault_handling"}, {"score": 0.004518442937844318, "phrase": "concurrency_calculus"}, {"score": 0.004417012437860011, "phrase": "orchestration_patterns"}, {"score": 0.004377077848734575, "phrase": "service_oriented_computing"}, {"score": 0.004259418153299952, "phrase": "high_concurrency"}, {"score": 0.004070276454809864, "phrase": "web_applications"}, {"score": 0.003996983218174335, "phrase": "web_services"}, {"score": 0.003942877273973905, "phrase": "conventional_semantics"}, {"score": 0.003907217785875898, "phrase": "orc"}, {"score": 0.0031845067058084583, "phrase": "fault_handler"}, {"score": 0.0028422946420821075, "phrase": "utp_methods"}, {"score": 0.0027910516355928983, "phrase": "denotational_semantic_model"}, {"score": 0.0027282915297520624, "phrase": "execution_status_information"}, {"score": 0.0025951294037626174, "phrase": "failure_execution"}, {"score": 0.002525248554951453, "phrase": "refinement_order"}, {"score": 0.002305589818994465, "phrase": "failure_recovery_mechanism"}, {"score": 0.002213065910356615, "phrase": "extended_operational_semantics"}, {"score": 0.0021049977753042253, "phrase": "denotational_semantics"}], "paper_keywords": ["Orc language", " service oriented computing", " unifying theories of programming", " denotational semantics", " operational semantics"], "paper_abstract": "The Orc language is a concurrency calculus proposed to study the orchestration patterns in service oriented computing. Its special features, such as high concurrency and asynchronism make it a brilliant subject for studying web applications that rely on web services. The conventional semantics for Orc does not contain the execution status of services so that a program cannot determine whether a service has terminated normally or halted with a failure after it published some results. It means that this kind of failure cannot be captured by the fault handler. Furthermore, such a semantic model cannot establish an order saying that a program is better if it fails less often. This paper employs UTP methods to propose a denotational semantic model for Orc that contains execution status information. A failure handling semantics is defined to recover a failure execution back to normal. A refinement order is defined to compare two systems based on their execution failures. Based on this order, a system that introduces a failure recovery mechanism is considered better than one without. An extended operational semantics is also proposed and proven to be equivalent to the denotational semantics.", "paper_title": "A UTP semantic model for Orc language with execution status and fault handling", "paper_id": "WOS:000343707700001"}