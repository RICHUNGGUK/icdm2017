{"auto_keywords": [{"score": 0.04045998690442279, "phrase": "native_code"}, {"score": 0.033457925072458865, "phrase": "virtual_machine_instructions"}, {"score": 0.00481495049065317, "phrase": "code-copying_jit_compilers"}, {"score": 0.004605565335682916, "phrase": "stack-based_virtual_machines"}, {"score": 0.00452101969521343, "phrase": "java_and_net_virtual_machines"}, {"score": 0.004198010835867604, "phrase": "target_machine"}, {"score": 0.004120915812750583, "phrase": "machine-specific_code_generation_methods"}, {"score": 0.004000486064911652, "phrase": "high-level_language"}, {"score": 0.003956234229826621, "phrase": "virtual_machine_instruction"}, {"score": 0.0038122196479548425, "phrase": "normal_c_compiler"}, {"score": 0.0033981387193790353, "phrase": "existing_implementation"}, {"score": 0.003360527337581911, "phrase": "forth_language"}, {"score": 0.0032987614613108345, "phrase": "novel_system"}, {"score": 0.0031904205547902695, "phrase": "common_sequences"}, {"score": 0.0031086137705026483, "phrase": "small_domain"}, {"score": 0.0030288982511487835, "phrase": "stack-optimized_code"}, {"score": 0.0028862231180242053, "phrase": "code-copying_compiler"}, {"score": 0.0028017745468000587, "phrase": "resulting_executable_code"}, {"score": 0.002760478838718213, "phrase": "machine-specific_sequences"}, {"score": 0.0026996706283276407, "phrase": "machine-dependent_code"}, {"score": 0.002650018880406324, "phrase": "experimental_results"}, {"score": 0.002353120949568249, "phrase": "generated_code"}, {"score": 0.002176560171729638, "phrase": "wide_range"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler", " interpreter", " virtual machine"], "paper_abstract": "Just-in-time (JIT) compilers are widely used to implement stack-based virtual machines, such as the Java and NET virtual machines. One disadvantage of most JIT compilers is that they are unportable; much of the back-end is specific to the target machine. An alternative to machine-specific code generation methods is to define a routine in a high-level language for each virtual machine instruction. These can be compiled to native code using a normal C compiler. The native code for these routines can then be strung together, allowing very simple, unoptimized code to be produced just in time. In this paper we present such a system based on an existing implementation of the Forth language. We present a novel system of optimizations for the system based on exploiting common sequences of virtual machine instructions. We use a small domain specific language and tool to generate stack-optimized code for sequences of virtual machine instructions, and for choosing the most useful sequences for a code-copying compiler. By measuring the length of the resulting executable code, we allow machine-specific sequences to be chosen without any machine-dependent code in our system. Experimental results show that best (average) speedups of 47.2 % (15.75 %) are possible on a Pentium 4 machine, and even higher an a PowerPC based machine. Furthermore, our optimizations allow the size of the generated code to be reduced by an average of 17.9% on the Pentium 4, and 20.5% on the PowerPC over a wide range of programs. Copyright (c) 2006 John Wiley & Sons, Ltd.", "paper_title": "Optimizing code-copying JIT compilers for virtual stack machines", "paper_id": "WOS:000240214200007"}