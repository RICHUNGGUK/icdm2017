{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "variable_automata"}, {"score": 0.04917503970392539, "phrase": "data_graphs"}, {"score": 0.004605434064238641, "phrase": "query_languages"}, {"score": 0.00454725669814484, "phrase": "graphs_databases"}, {"score": 0.004133627071344356, "phrase": "data_values"}, {"score": 0.00385431710959668, "phrase": "somewhat_dual_behaviour"}, {"score": 0.0030071857666598193, "phrase": "query_language"}, {"score": 0.002733260122876447, "phrase": "expressive_power"}, {"score": 0.002421726275597666, "phrase": "previously_used_languages"}, {"score": 0.0023013968622710847, "phrase": "query_evaluation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Databases", " Query languages", " Variable automata"], "paper_abstract": "Thus far query languages for graphs databases that, in addition to navigating the structure of a graph, also consider data values encountered along the paths they traverse, seem to exhibit somewhat dual behaviour in terms of the efficiency of their query evaluation problem. Namely, their combined complexity is either tractable, or are at least PSPACE-hard. In this paper we show how to use the model of variable automata to get a query language with intermediate (NP-complete) combined complexity of query evaluation. Since variable automata are incomparable in terms of expressive power with previously studied querying mechanisms for data graphs we also show how to join their capabilities with the ones of previously used languages without an increase in the complexity of query evaluation, thus getting the best of both worlds. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Using variable automata for querying data graphs", "paper_id": "WOS:000348891200005"}