{"auto_keywords": [{"score": 0.03865864227321236, "phrase": "ownership_type_system"}, {"score": 0.012292583076440778, "phrase": "local_and_boundary_objects"}, {"score": 0.010307422736196984, "phrase": "fine-grained_reuse"}, {"score": 0.00481495049065317, "phrase": "ownership_types"}, {"score": 0.004764004403553372, "phrase": "java-like_setting"}, {"score": 0.004713594814274419, "phrase": "box_model"}, {"score": 0.004663716126870148, "phrase": "lightweight_component_model"}, {"score": 0.004614362802631256, "phrase": "object-oriented_paradigm"}, {"score": 0.0045332598718792515, "phrase": "flat_object-heap"}, {"score": 0.004501217435918426, "phrase": "hierarchical_runtime_components"}, {"score": 0.004406436661912347, "phrase": "clear_runtime_boundaries"}, {"score": 0.0036123093557208492, "phrase": "domain_annotations"}, {"score": 0.003486316700608598, "phrase": "local_objects"}, {"score": 0.003212906206685004, "phrase": "class_hierarchy"}, {"score": 0.00265208877121581, "phrase": "standard_inheritance"}, {"score": 0.0025961429982767257, "phrase": "specific_problem"}, {"score": 0.0025686131021181134, "phrase": "box_ownership_type_system"}, {"score": 0.002532359001507531, "phrase": "box_classes"}, {"score": 0.0024877583128884457, "phrase": "standard_classes"}, {"score": 0.002228203424338522, "phrase": "corresponding_soundness_proofs"}, {"score": 0.0021657265492371976, "phrase": "object-oriented_language"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Boxes", " Featherweight Java", " Ownership types", " Traits"], "paper_abstract": "The box model is a lightweight component model for the object-oriented paradigm, which structures the flat object-heap into hierarchical runtime components called boxes. Boxes have clear runtime boundaries that divide the objects of a box into objects that can be used to interact with the box (the boundary objects) and objects that are encapsulated and represent the state of the box (the local objects). The distinction into local and boundary objects is statically achieved by an ownership type system for boxes that uses domain annotations to classify objects into local and boundary objects and that guarantees that local objects can never be directly accessed by the context of a box. A trait is a set of methods divorced from any class hierarchy. Traits are units of fine-grained reuse that can be composed together to form classes or other traits. This paper integrates traits into an ownership type system for boxes. This combination is fruitful in two ways: it can statically guarantee encapsulation of objects and still provide fine-grained reuse among classes that goes beyond the possibilities of standard inheritance. It also solves a specific problem of the box ownership type system: namely that box classes cannot inherit from standard classes (and vice versa), and thus code sharing between these two kinds of classes was not possible in this setting so far. We present an ownership type system and the corresponding soundness proofs that guarantee encapsulation of objects in an object-oriented language with traits. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Combining traits with boxes and ownership types in a Java-like setting", "paper_id": "WOS:000312522700005"}