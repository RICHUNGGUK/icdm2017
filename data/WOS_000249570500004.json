{"auto_keywords": [{"score": 0.04962913836247387, "phrase": "stack-based_assembly_languages"}, {"score": 0.0433312844265797, "phrase": "security_level"}, {"score": 0.04197548893255256, "phrase": "instruction-level_security_analysis"}, {"score": 0.030336914577021794, "phrase": "security_levels"}, {"score": 0.00481495049065317, "phrase": "information_flow"}, {"score": 0.004592905436175987, "phrase": "secure_information_flow"}, {"score": 0.0044435677598780796, "phrase": "external_environment"}, {"score": 0.0043194180167921165, "phrase": "output_channels"}, {"score": 0.004081385289516914, "phrase": "memory_variable"}, {"score": 0.004043003243656031, "phrase": "stack_element"}, {"score": 0.0037309384824565695, "phrase": "standard_security_typing"}, {"score": 0.0035755653799043, "phrase": "abstract_interpretation"}, {"score": 0.0035085965086415474, "phrase": "concrete_operational_semantics"}, {"score": 0.0033943947596098583, "phrase": "execution_aspects"}, {"score": 0.002987557906013826, "phrase": "abstract_domain"}, {"score": 0.002917736974519881, "phrase": "concrete_one"}, {"score": 0.0028093921138602606, "phrase": "actual_values"}, {"score": 0.002782938683493689, "phrase": "operand_stack"}, {"score": 0.0027307746993761035, "phrase": "fixed-length_stacks"}, {"score": 0.0026543514413663893, "phrase": "abstract_state"}, {"score": 0.0025678829712650437, "phrase": "abstract_machine"}, {"score": 0.002426137929553722, "phrase": "abstract_semantics"}, {"score": 0.002358220053411644, "phrase": "abstract_rules"}, {"score": 0.002336004938424957, "phrase": "abstract_states"}, {"score": 0.0023030731312573246, "phrase": "instruction-level_security_typing"}, {"score": 0.0022385926290967263, "phrase": "efficient_fixpoint_iteration_algorithm"}, {"score": 0.0021656385587456952, "phrase": "bytecode_verification"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["abstract interpretation", " flow-sensitive", " language-based security", " static analysis"], "paper_abstract": "We propose a method to analyze secure information flow in stack-based assembly languages, communicating with the external environment by means of input and output channels. The method computes for each instruction a security level for each memory variable and stack element. Instruction-level security analysis is flow-sensitive and hence is more precise than other analyses, such as standard security typing. Instruction-level security analysis is specified in the framework of abstract interpretation. We define concrete operational semantics which handles, in addition to execution aspects, the flow of information of the program. The basis of the approach is that each value is annotated by a security level and that the abstract domain is obtained from the concrete one by keeping the security levels and forgetting the actual values. Operand stack are abstracted as fixed-length stacks of security levels. An abstract state is a map from instructions to abstract machine. configurations, where values are substituted by security levels. The abstract semantics consists of a set of abstract rules manipulating abstract states. The instruction-level security typing can be performed by an efficient fixpoint iteration algorithm, similar to that used by bytecode verification. (c) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Instruction-level security analysis for information flow in stack-based assembly languages", "paper_id": "WOS:000249570500004"}