{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "safety-first_approach"}, {"score": 0.004539005582217309, "phrase": "recent_efforts"}, {"score": 0.004342430078306461, "phrase": "concurrency_semantics"}, {"score": 0.004216112320418982, "phrase": "programming_languages"}, {"score": 0.004093453936415085, "phrase": "memory_accesses"}, {"score": 0.0032319109979344184, "phrase": "explicit_annotations"}, {"score": 0.0031377955308198634, "phrase": "data_races"}, {"score": 0.0030017216162807245, "phrase": "unsafe"}, {"score": 0.0027878797103973313, "phrase": "simple_programming_mistakes"}, {"score": 0.0026277995163948263, "phrase": "counterintuitive_program_semantics"}, {"score": 0.0021049977753042253, "phrase": "memory_access"}], "paper_keywords": [""], "paper_abstract": "Recent efforts to standardize concurrency semantics for programming languages assume memory accesses are data-race-free (\"Safe\") by default and require explicit annotations on data races (\"Unsafe\" accesses). Simple programming mistakes can result in counterintuitive program semantics. Instead, the authors argue for and demonstrate a safety-first approach that treats every memory access as potentially unsafe unless proven otherwise.", "paper_title": "A SAFETY-FIRST APPROACH TO MEMORY MODELS", "paper_id": "WOS:000320014900012"}