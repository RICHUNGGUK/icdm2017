{"auto_keywords": [{"score": 0.04463905750041684, "phrase": "near-perfect_accuracy"}, {"score": 0.029673548100470126, "phrase": "original_code"}, {"score": 0.02859130335732279, "phrase": "npu"}, {"score": 0.00481495049065317, "phrase": "general-purpose_approximate_programs"}, {"score": 0.00474493382693875, "phrase": "per-transistor_speed"}, {"score": 0.004662250189344776, "phrase": "radical_departures"}, {"score": 0.004635008910530911, "phrase": "conventional_approaches"}, {"score": 0.004501160823792861, "phrase": "energy_efficiency"}, {"score": 0.004474856549909555, "phrase": "general-purpose_processors"}, {"score": 0.004422706216600923, "phrase": "approximate_computing"}, {"score": 0.004294962474996283, "phrase": "traditional_robust_digital_abstraction"}, {"score": 0.004220086640742953, "phrase": "conventional_techniques"}, {"score": 0.004195418010131832, "phrase": "energy-efficient_computing"}, {"score": 0.0041586840496756474, "phrase": "design_space"}, {"score": 0.0039449104968131655, "phrase": "general-purpose_approximate_computing"}, {"score": 0.003910361300258558, "phrase": "third_dimension-error"}, {"score": 0.003698442219929622, "phrase": "large_savings"}, {"score": 0.003676811616723809, "phrase": "small_errors"}, {"score": 0.003581023208223685, "phrase": "new_approach"}, {"score": 0.0035496495489801667, "phrase": "machine_learning-based_transformations"}, {"score": 0.003518549786513923, "phrase": "approximation-tolerant_programs"}, {"score": 0.003487721546598799, "phrase": "core_idea"}, {"score": 0.0034369381458785025, "phrase": "learning_model"}, {"score": 0.0032505921489759224, "phrase": "original_code_region"}, {"score": 0.0032221040639939668, "phrase": "efficient_computation"}, {"score": 0.0031938648476635225, "phrase": "learned_model"}, {"score": 0.0031565959573536194, "phrase": "neural_networks"}, {"score": 0.0031289290660162145, "phrase": "code_behavior"}, {"score": 0.0030563268358422503, "phrase": "parrot_algorithmic_transformation"}, {"score": 0.0030118058266380503, "phrase": "simple_programmer_annotation"}, {"score": 0.0029332911632061523, "phrase": "code_region"}, {"score": 0.0029075757820516634, "phrase": "von_neumann_model"}, {"score": 0.0028820851891355904, "phrase": "neural_model"}, {"score": 0.002848444028358522, "phrase": "learning_phase"}, {"score": 0.002749851878361472, "phrase": "low-power_accelerator"}, {"score": 0.002615977783510631, "phrase": "processor_pipeline"}, {"score": 0.002593036969574861, "phrase": "profitable_acceleration"}, {"score": 0.002570296816631395, "phrase": "small_regions"}, {"score": 0.0025180070278214613, "phrase": "approximable_code_regions"}, {"score": 0.002388368786294332, "phrase": "diverse_applications"}, {"score": 0.00237438198085184, "phrase": "npu_acceleration"}, {"score": 0.0023604768913655463, "phrase": "whole-application_speedup"}, {"score": 0.002332909962395378, "phrase": "energy_savings"}, {"score": 0.0022921606484547713, "phrase": "average_quality_loss"}, {"score": 0.0022455164874830777, "phrase": "new_class"}, {"score": 0.002206290313627494, "phrase": "significant_gains"}, {"score": 0.002142426911242168, "phrase": "traditional_abstraction"}, {"score": 0.0021049977753042253, "phrase": "general-purpose_computing"}], "paper_keywords": [""], "paper_abstract": "As improvements in per-transistor speed and energy efficiency diminish, radical departures from conventional approaches are needed to continue improvements in the performance and energy efficiency of general-purpose processors. One such departure is approximate computing, where error in computation is acceptable and the traditional robust digital abstraction of near-perfect accuracy is relaxed. Conventional techniques in energy-efficient computing navigate a design space defined by the two dimensions of performance and energy, and traditionally trade one for the other. General-purpose approximate computing explores a third dimension-error-and trades the accuracy of computation for gains in both energy and performance. Techniques to harvest large savings from small errors have proven elusive. This paper describes a new approach that uses machine learning-based transformations to accelerate approximation-tolerant programs. The core idea is to train a learning model how an approximable region of code-code that can produce imprecise but acceptable results-behaves and replace the original code region with an efficient computation of the learned model. We use neural networks to learn code behavior and approximate it. We describe the Parrot algorithmic transformation, which leverages a simple programmer annotation (\"approximable\") to transform a code region from a von Neumann model to a neural model. After the learning phase, the compiler replaces the original code with an invocation of a low-power accelerator called a neural processing unit (NPU). The NPU is tightly coupled to the processor pipeline to permit profitable acceleration even when small regions of code are transformed. Offloading approximable code regions to NPUs is faster and more energy efficient than executing the original code. For a set of diverse applications, NPU acceleration provides whole-application speedup of 2.3x and energy savings of 3.0x on average with average quality loss of at most 9.6%. NPUs form a new class of accelerators and show that significant gains in both performance and efficiency are achievable when the traditional abstraction of near-perfect accuracy is relaxed in general-purpose computing.", "paper_title": "Neural Acceleration for General-Purpose Approximate Programs", "paper_id": "WOS:000348302400029"}