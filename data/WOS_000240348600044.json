{"auto_keywords": [{"score": 0.03171525019468471, "phrase": "hash_function_encoding"}, {"score": 0.029262716579216683, "phrase": "auxiliary_data_structure"}, {"score": 0.00481495049065317, "phrase": "external_memory_efficient_hash_tables"}, {"score": 0.004736045157669388, "phrase": "typical_applications"}, {"score": 0.004684157900507474, "phrase": "hashing_algorithms"}, {"score": 0.004312622975366672, "phrase": "internal_memory"}, {"score": 0.00373682045166829, "phrase": "new_randomized_algorithms"}, {"score": 0.003675517796014622, "phrase": "hash_tables"}, {"score": 0.0035953368057880593, "phrase": "hash_function"}, {"score": 0.0034975571855450343, "phrase": "constant_time"}, {"score": 0.0033465923623290034, "phrase": "consecutive_external_memory_cells"}, {"score": 0.00325555555110395, "phrase": "dynamic_version"}, {"score": 0.0032198357970567595, "phrase": "pagh's_hashing_scheme"}, {"score": 0.00280496585980086, "phrase": "log_n_space"}, {"score": 0.0027286224888843956, "phrase": "update_operations"}, {"score": 0.002669042572650594, "phrase": "expected_constant_amortized_time"}, {"score": 0.002312174113289583, "phrase": "static_version"}, {"score": 0.0021049977753042253, "phrase": "dynamic_case"}], "paper_keywords": [""], "paper_abstract": "In typical applications of hashing algorithms the amount of data to be stored is often too large to fit into internal memory. In this case it is desirable to find the data with as few as possible non-consecutive or at least non-oblivious probes into external memory. Extending a static scheme of Pagh [11] we obtain new randomized algorithms for maintaining hash tables, where a hash function can be evaluated in constant time and by probing only one external memory cell or O(1) consecutive external memory cells. We describe a dynamic version of Pagh's hashing scheme achieving 100% table utilization but requiring (2 + epsilon) center dot n log n space for the hash function encoding as well as (3 + epsilon) center dot n log n space for the auxiliary data structure. Update operations are possible in expected constant amortized time. Then we show how to reduce the space for the hash function encoding and the auxiliary data structure to o(n log log n). We achieve 100% utilization in the static version (and thus a minimal perfect hash function) and 1 - epsilon utilization in the dynamic case.", "paper_title": "Maintaining external memory efficient hash tables", "paper_id": "WOS:000240348600044"}