{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "disassembly_processes"}, {"score": 0.0047602693158272655, "phrase": "sequence-dependent_cost"}, {"score": 0.004670504053818028, "phrase": "optimum_disassembly_sequence"}, {"score": 0.004547656324173302, "phrase": "mathematical_programming"}, {"score": 0.004041155193307942, "phrase": "exact_method"}, {"score": 0.003995226376780718, "phrase": "sequence-dependent_costs"}, {"score": 0.003934795713147731, "phrase": "previously_presented_methods"}, {"score": 0.0038605361756636667, "phrase": "sequential_disassembly"}, {"score": 0.003687960013746783, "phrase": "full_problem"}, {"score": 0.0035908627899097407, "phrase": "elaborate_transformation"}, {"score": 0.0034697573205392887, "phrase": "integer_linear_programming"}, {"score": 0.003391290302481397, "phrase": "alternate_approach"}, {"score": 0.0033399639721674954, "phrase": "binary_integer_linear_programming_approach"}, {"score": 0.003190584226787897, "phrase": "proposed_method"}, {"score": 0.0031422859551159506, "phrase": "arbitrary_instances"}, {"score": 0.003106541164572609, "phrase": "product_structures"}, {"score": 0.0028456326741466494, "phrase": "gradual_increase"}, {"score": 0.002824005136794786, "phrase": "product_complexity"}, {"score": 0.002718301574682098, "phrase": "iteration_process"}, {"score": 0.0026567830878420347, "phrase": "required_cpu_time"}, {"score": 0.002351389889948836, "phrase": "integer_linear_programming_model"}, {"score": 0.002324620886282579, "phrase": "iterative_method"}, {"score": 0.0022719915771356354, "phrase": "modularized_products"}, {"score": 0.002220551141101661, "phrase": "heuristic_algorithms"}, {"score": 0.0021537671245615286, "phrase": "still_higher_complexity"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["disassembly planning", " assembly", " network", " mathematical programming", " optimization", " traveling salesperson problem"], "paper_abstract": "Detection of the optimum disassembly sequence for a given product can proceed via mathematical programming, which is based on the AND/OR graph representation of its disassembly process. This is called the exact method for it reveals the global optimum. This paper describes an extension of the exact method in case sequence-dependent costs are considered. Previously presented methods confined themselves either to sequential disassembly, or were based on heuristics. The only exact method for the full problem known so far, needs an elaborate transformation of the AND/OR graph, and is based on integer linear programming. This paper discusses an alternate approach that uses a binary integer linear programming approach and that lacks the need of transforming the AND/OR graph. The proposed method is applied to arbitrary instances of some product structures that have been taken from the literature. Apart from this, the method is applied to an expandable AND/OR graph, that enables gradual increase of product complexity. It is demonstrated that the convergence of the iteration process is satisfactory, and the required CPU time appears comparatively small and only moderately increases with the number of constraints. It appears that the method applies to products with a complexity that cannot be managed with the integer linear programming model. The iterative method is promising for dealing with modularized products and as a benchmark for heuristic algorithms, which are used if products exhibit still higher complexity. (c) 2005 Elsevier Ltd. All rights reserved.", "paper_title": "Optimizing disassembly processes subjected to sequence-dependent cost", "paper_id": "WOS:000241086900012"}