{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "gcc_source-code-level_register_allocation"}, {"score": 0.003967021436047945, "phrase": "hard_registers"}, {"score": 0.003623949225126944, "phrase": "hardregistered_virtual_program_counter_and_stack_pointer"}, {"score": 0.0031435968684569112, "phrase": "register-rich_powerpc"}, {"score": 0.002946809790084156, "phrase": "intel"}, {"score": 0.0025230952890994236, "phrase": "hard_register"}, {"score": 0.0021049977753042253, "phrase": "higher_register_pressure"}], "paper_keywords": ["interpreter", " performance", " GCC source-code-level register allocation"], "paper_abstract": "An anomaly of unexpected performance in an interpreter whose frequently accessed variables are manually assigned to hard registers by GCC source-code-level register allocation is presented. A hardregistered virtual program counter and stack pointer as well as a bytecode translation are experimented on both register-rich PowerPC and register-limited Intel x86. According to the study of the anomaly, a hard register should not be assigned singly to a variable in an interpreter due to higher register pressure.", "paper_title": "An anomaly in an interpreter using GCC source-code-level register allocation", "paper_id": "WOS:000253408500002"}