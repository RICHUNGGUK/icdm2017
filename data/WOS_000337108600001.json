{"auto_keywords": [{"score": 0.043575434099009436, "phrase": "frame-level_statistics"}, {"score": 0.04082397693273621, "phrase": "edge_detection_performance"}, {"score": 0.00481495049065317, "phrase": "distributed_canny_edge_detector"}, {"score": 0.0047999380503311335, "phrase": "algorithm"}, {"score": 0.004753343247456767, "phrase": "fpga"}, {"score": 0.004692227830462433, "phrase": "canny_edge_detector"}, {"score": 0.00424538577579635, "phrase": "higher_latency"}, {"score": 0.003992729692096799, "phrase": "canny_algorithm"}, {"score": 0.003954229201647876, "phrase": "block_level"}, {"score": 0.0038409323908446297, "phrase": "original_frame-level_canny_algorithm"}, {"score": 0.003779393063001438, "phrase": "original_canny_algorithm"}, {"score": 0.003706841132853073, "phrase": "excessive_edges"}, {"score": 0.0036829668399442914, "phrase": "smooth_regions"}, {"score": 0.003623949225126944, "phrase": "significant_edges"}, {"score": 0.0036006068766833103, "phrase": "high-detailed_regions"}, {"score": 0.0035658739518719907, "phrase": "original_canny"}, {"score": 0.003531474887552889, "phrase": "high_and_low_thresholds"}, {"score": 0.0033752674784204412, "phrase": "distributed_canny_edge_detection_algorithm"}, {"score": 0.0033211641484589775, "phrase": "edge_detection_thresholds"}, {"score": 0.003278504512223807, "phrase": "block_type"}, {"score": 0.0032468685934998335, "phrase": "local_distribution"}, {"score": 0.0031845067058084583, "phrase": "image_block"}, {"score": 0.0031233388358844188, "phrase": "new_algorithm"}, {"score": 0.003093195541269291, "phrase": "nonuniform_gradient_magnitude_histogram"}, {"score": 0.00306334226516593, "phrase": "block-based_hysteresis_thresholds"}, {"score": 0.003033776234384367, "phrase": "resulting_block-based_algorithm"}, {"score": 0.003004494701922268, "phrase": "significantly_reduced_latency"}, {"score": 0.0028715299874549245, "phrase": "fast_edge_detection"}, {"score": 0.00281635677605879, "phrase": "high_resolutions"}, {"score": 0.0027004145919012736, "phrase": "block_size"}, {"score": 0.0026657070241024963, "phrase": "frame_size"}, {"score": 0.002622947550220266, "phrase": "quantitative_conformance_evaluations"}, {"score": 0.0026060359255636444, "phrase": "subjective_tests"}, {"score": 0.002547697135598078, "phrase": "proposed_algorithm"}, {"score": 0.00250682585023182, "phrase": "original_frame-based_algorithm"}, {"score": 0.002297162511308007, "phrase": "synthesized_architecture"}, {"score": 0.0022312377180023282, "phrase": "computation_time"}, {"score": 0.0021672007484097575, "phrase": "usc_sipi_database"}, {"score": 0.0021049977753042253, "phrase": "existing_fpga_and_gpu_implementations"}], "paper_keywords": ["Distributed image processing", " Canny edge detector", " high throughput", " parallel processing", " FPGA"], "paper_abstract": "The Canny edge detector is one of the most widely used edge detection algorithms due to its superior performance. Unfortunately, not only is it computationally more intensive as compared with other edge detection algorithms, but it also has a higher latency because it is based on frame-level statistics. In this paper, we propose a mechanism to implement the Canny algorithm at the block level without any loss in edge detection performance compared with the original frame-level Canny algorithm. Directly applying the original Canny algorithm at the block-level leads to excessive edges in smooth regions and to loss of significant edges in high-detailed regions since the original Canny computes the high and low thresholds based on the frame-level statistics. To solve this problem, we present a distributed Canny edge detection algorithm that adaptively computes the edge detection thresholds based on the block type and the local distribution of the gradients in the image block. In addition, the new algorithm uses a nonuniform gradient magnitude histogram to compute block-based hysteresis thresholds. The resulting block-based algorithm has a significantly reduced latency and can be easily integrated with other block-based image codecs. It is capable of supporting fast edge detection of images and videos with high resolutions, including full-HD since the latency is now a function of the block size instead of the frame size. In addition, quantitative conformance evaluations and subjective tests show that the edge detection performance of the proposed algorithm is better than the original frame-based algorithm, especially when noise is present in the images. Finally, this algorithm is implemented using a 32 computing engine architecture and is synthesized on the Xilinx Virtex-5 FPGA. The synthesized architecture takes only 0.721 ms (including the SRAM READ/WRITE time and the computation time) to detect edges of 512 x 512 images in the USC SIPI database when clocked at 100 MHz and is faster than existing FPGA and GPU implementations.", "paper_title": "A Distributed Canny Edge Detector: Algorithm and FPGA Implementation", "paper_id": "WOS:000337108600001"}