{"auto_keywords": [{"score": 0.04967088836874542, "phrase": "legacy_systems"}, {"score": 0.01462751667543545, "phrase": "object_orientation"}, {"score": 0.00481495049065317, "phrase": "support_object_orientation"}, {"score": 0.004613175917207636, "phrase": "c_face"}, {"score": 0.004593467306126913, "phrase": "maintainability_issues"}, {"score": 0.0045348429403481464, "phrase": "tight_coupling"}, {"score": 0.004216434794603139, "phrase": "better_programmability"}, {"score": 0.004074397977869244, "phrase": "c_software"}, {"score": 0.0037398106866046972, "phrase": "designated_initializers"}, {"score": 0.003447349911141396, "phrase": "manual_efforts"}, {"score": 0.0033026956021014204, "phrase": "global_constructors"}, {"score": 0.003274499008699115, "phrase": "exception_handling"}, {"score": 0.0032465423581390625, "phrase": "runtime_type_inference"}, {"score": 0.003123652729688503, "phrase": "target_system"}, {"score": 0.0030573959252626695, "phrase": "traditional_procedural_language_compiler"}, {"score": 0.002879237498994052, "phrase": "programming_language"}, {"score": 0.0026767629720554397, "phrase": "case_study"}, {"score": 0.0026538960171433963, "phrase": "linux_kernel"}, {"score": 0.002608744950946475, "phrase": "major_issues"}, {"score": 0.0025424508991051483, "phrase": "runtime_support"}, {"score": 0.0023233800372985686, "phrase": "large_c_based_software"}, {"score": 0.002244969789802093, "phrase": "proposed_extension"}, {"score": 0.0022257833099336858, "phrase": "significant_manual_efforts"}, {"score": 0.0021231452870210965, "phrase": "performance_study"}], "paper_keywords": ["g plus", " programming language", " Linux kernel", " legacy systems", " object orientation"], "paper_abstract": "The contemporary software systems written in C face maintainability issues because of tight coupling. Introducing object orientation can address these problems by raising the abstraction to objects, thereby providing better programmability and understandability. However, compiling a C software with a C++ compiler is difficult because of the incompatibilities between C and C++. Some of the incompatibilities such as designated initializers are nontrivial in nature and hence are very difficult to handle by automation such as scripting or by manual efforts. Moreover, runtime support for features such as global constructors, exception handling, runtime type inference, etc. is also required in the target system. Clearly, the traditional procedural language compiler cannot provide these features. In this paper, we propose extending programming language such as C++ to support object orientation in legacy systems instead of completely redesigning them. With a case study of Linux kernel, we report major issues in providing the compile and runtime support for C++ in legacy systems, and provide a solution to these issues. Our approach paves the way for converting a large C based software into C++. The experiments demonstrate that the proposed extension saves significant manual efforts with very little change in the g++ compiler. In addition, the performance study considers other legacy systems written in C and shows that the overhead resulting from the modifications in the compiler is negligible in comparison to the functionality achieved.", "paper_title": "Extending Programming Language to Support Object Orientation in Legacy Systems", "paper_id": "WOS:000327912000008"}