{"auto_keywords": [{"score": 0.02891803957757625, "phrase": "logical_operators"}, {"score": 0.00481495049065317, "phrase": "tree-pattern_xml_queries"}, {"score": 0.004714164141934584, "phrase": "xml"}, {"score": 0.004664352260912174, "phrase": "tree-based_data_representation_format"}, {"score": 0.004518442937844318, "phrase": "xml_queries"}, {"score": 0.004300453431933622, "phrase": "document_elements"}, {"score": 0.004240116703465252, "phrase": "existing_elements"}, {"score": 0.004195418010131832, "phrase": "xml_query"}, {"score": 0.004078502325220629, "phrase": "tree-pattern_structure"}, {"score": 0.004035500442527029, "phrase": "query_tree_pattern"}, {"score": 0.0037868092509097404, "phrase": "main_task"}, {"score": 0.003760137090849196, "phrase": "query_execution"}, {"score": 0.0033937776228549557, "phrase": "guidance_structure"}, {"score": 0.003310813458610484, "phrase": "extracted_information"}, {"score": 0.003207108833360533, "phrase": "focused_document"}, {"score": 0.0030738557655525913, "phrase": "logical_operator"}, {"score": 0.00290473242917264, "phrase": "new_structure"}, {"score": 0.0026968054141106547, "phrase": "xor"}, {"score": 0.0026682899925377142, "phrase": "not."}, {"score": 0.0023995451127366983, "phrase": "efficient_method"}, {"score": 0.00229164285862567, "phrase": "match_patterns"}, {"score": 0.0022276618873985445, "phrase": "qtp_parsing"}, {"score": 0.002180848602315088, "phrase": "qtp_execution"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": [""], "paper_abstract": "XML is a tree-based data representation format which combines data and structure. Therefore, XML queries not only contain predicates to filter data but also refer to relationships between document elements searched. The existing elements in an XML query are connected to each other using a tree-pattern structure, called Query Tree Pattern (QTP). Finding elements of a document, which satisfy the given QTP, is the main task during query execution. To optimize this processing, we presented two methods in [13]. Instead of directly executing the QTP against the document, our methods first evaluate a guidance structure, called QueryGuide. Using the extracted information, called match pattern, we provided a focused document access and minimized the required I/O. However, we only supported the logical operator AND (called AND-QTPs). In this paper, we use a new structure, called Evaluation Tree, to execute QTPs. We also extend our method to support QTPs having logical operators OR, XOR, and NOT. Parsing QTPs into some AND-QTPs is typically assumed non-efficient. To process QTPs having logical operators OR and NOT, we therefore parse them but we use an efficient method to prevent redundant I/O and QTP matching. This is done by optimizing the selection of match patterns which were derived from the QueryGuide during QTP parsing. As a result, QTP execution is not inefficient anymore. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "S-3: Processing tree-pattern XML queries with all logical operators", "paper_id": "WOS:000300072600002"}