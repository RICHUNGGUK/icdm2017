{"auto_keywords": [{"score": 0.044608811621491724, "phrase": "felleisen"}, {"score": 0.00481495049065317, "phrase": "abstract_machines"}, {"score": 0.004736973212570135, "phrase": "derivational_approach"}, {"score": 0.0047061353684963655, "phrase": "abstract_interpretation"}, {"score": 0.004629912133717504, "phrase": "transparently_sound_static_analyses"}, {"score": 0.004569819304126685, "phrase": "well-established_abstract_machines"}, {"score": 0.004481132747216135, "phrase": "imperative_programming_languages"}, {"score": 0.004294813202198633, "phrase": "cek_machine"}, {"score": 0.004239141266288502, "phrase": "friedman"}, {"score": 0.0038810583785936505, "phrase": "krivine's_machine"}, {"score": 0.003565568471711694, "phrase": "cm"}, {"score": 0.0035300339843761675, "phrase": "clements"}, {"score": 0.0034277109304270605, "phrase": "lang"}, {"score": 0.0032529303004879325, "phrase": "abstract_interpretations"}, {"score": 0.00320016832003312, "phrase": "resulting_analyses"}, {"score": 0.003179303164775306, "phrase": "temporal_ordering"}, {"score": 0.0031585736196310726, "phrase": "program_events"}, {"score": 0.003107337317471694, "phrase": "stack-inspection_behavior"}, {"score": 0.0030171910207671205, "phrase": "by-need_parameters"}, {"score": 0.0028821186265508597, "phrase": "well-known_concrete_machine_refactorings"}, {"score": 0.002826092315294647, "phrase": "store-allocated_continuations"}, {"score": 0.002753076401091352, "phrase": "static_analyses"}, {"score": 0.0026557415971295633, "phrase": "allocation_functions"}, {"score": 0.0024152714799789547, "phrase": "static_analysis"}, {"score": 0.0023995115472744376, "phrase": "realistic_language_features"}, {"score": 0.0023760637960293257, "phrase": "tail_calls"}, {"score": 0.002314647987893668, "phrase": "first-class_continuations"}, {"score": 0.0022920276083063947, "phrase": "even_garbage_collection"}, {"score": 0.002139742163351676, "phrase": "haskell_code"}, {"score": 0.002118827457244586, "phrase": "initial_development"}], "paper_keywords": [""], "paper_abstract": "We describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well-established abstract machines for higher-order and imperative programming languages. To demonstrate the technique and support our claim, we transform the CEK machine of Felleisen and Friedman (Proc. of the 14th ACM SIGACT-SIGPLAN Symp. Prin. Program. Langs, 1987, pp. 314-325), a lazy variant of Krivine's machine (Higher-Order Symb. Comput. Vol 20, 2007, pp. 199-207), and the stack-inspecting CM machine of Clements and Felleisen (ACM Trans. Program. Lang. Syst. Vol 26, 2004, pp. 1029-1052) into abstract interpretations of themselves. The resulting analyses bound temporal ordering of program events; predict return-flow and stack-inspection behavior; and approximate the flow and evaluation of by-need parameters. For all of these machines, we find that a series of well-known concrete machine refactorings, plus a technique of store-allocated continuations, leads to machines that abstract into static analyses simply by bounding their stores. These machines are parameterized by allocation functions that tune performance and precision and substantially expand the space of analyses that this framework can represent. We demonstrate that the technique scales up uniformly to allow static analysis of realistic language features, including tail calls, conditionals, mutation, exceptions, first-class continuations, and even garbage collection. In order to close the gap between formalism and implementation, we provide translations of the mathematics as running Haskell code for the initial development of our method.", "paper_title": "Systematic abstraction of abstract machines", "paper_id": "WOS:000308672600008"}