{"auto_keywords": [{"score": 0.03246855872517173, "phrase": "atomic_statements"}, {"score": 0.03096908870370557, "phrase": "unguarded_accesses"}, {"score": 0.00481495049065317, "phrase": "-default_parallel_language"}, {"score": 0.004718431349852634, "phrase": "deterministic_parallel_programming_models"}, {"score": 0.0046803650677267146, "phrase": "strong_safety_guarantees"}, {"score": 0.004586531354697466, "phrase": "similar_support"}, {"score": 0.004549524321051407, "phrase": "nondeterministic_algorithms"}, {"score": 0.004440277230269978, "phrase": "bound_search"}, {"score": 0.00436890075128947, "phrase": "open_question"}, {"score": 0.0041784516085055035, "phrase": "effect_system"}, {"score": 0.00412796126884884, "phrase": "nondeterministic_computations"}, {"score": 0.004078078530972285, "phrase": "deterministic-by-default_guarantee"}, {"score": 0.003947973513495612, "phrase": "special_parallel_constructs"}, {"score": 0.0037150687722055727, "phrase": "nd_construct"}, {"score": 0.003685067218455088, "phrase": "deterministic_input-output_behavior"}, {"score": 0.0036257863613963245, "phrase": "deterministic_parallel_constructs"}, {"score": 0.0035386420095120706, "phrase": "sequential_composition"}, {"score": 0.003223494720348768, "phrase": "nd_constructs"}, {"score": 0.0029965060407413898, "phrase": "data_races"}, {"score": 0.0027741761880779535, "phrase": "strong_isolation"}, {"score": 0.0026423134393535265, "phrase": "modular_checking"}, {"score": 0.0026209522797963447, "phrase": "novel_extensions"}, {"score": 0.0025892330566358503, "phrase": "previously_described_effect_system"}, {"score": 0.0024963543716522087, "phrase": "unnecessary_transactional_synchronization"}, {"score": 0.0024461989110005447, "phrase": "static_semantics"}, {"score": 0.0024264193359373977, "phrase": "dynamic_semantics"}, {"score": 0.002264607102799332, "phrase": "barrier_removal_feature"}, {"score": 0.0022371907579775796, "phrase": "experimental_evaluation"}, {"score": 0.002183347623351868, "phrase": "good_scalability"}, {"score": 0.002165688807780663, "phrase": "realistic_parallel_algorithms"}, {"score": 0.0021221627745801478, "phrase": "barrier_removal_techniques"}, {"score": 0.0021049977753042253, "phrase": "significant_performance_gains"}], "paper_keywords": ["Languages", " Verification", " Performance"], "paper_abstract": "A number of deterministic parallel programming models with strong safety guarantees are emerging, but similar support for nondeterministic algorithms, such as branch and bound search, remains an open question. We present a language together with a type and effect system that supports nondeterministic computations with a deterministic-by-default guarantee: nondeterminism must be explicitly requested via special parallel constructs (marked nd), and any deterministic construct that does not execute any nd construct has deterministic input-output behavior. Moreover, deterministic parallel constructs are always equivalent to a sequential composition of their constituent tasks, even if they enclose, or are enclosed by, nd constructs. Finally, in the execution of nd constructs, interference may occur only between pairs of accesses guarded by atomic statements, so there are no data races, either between atomic statements and unguarded accesses (strong isolation) or between pairs of unguarded accesses (stronger than strong isolation alone). We enforce the guarantees at compile time with modular checking using novel extensions to a previously described effect system. Our effect system extensions also enable the compiler to remove unnecessary transactional synchronization. We provide a static semantics, dynamic semantics, and a complete proof of soundness for the language, both with and without the barrier removal feature. An experimental evaluation shows that our language can achieve good scalability for realistic parallel algorithms, and that the barrier removal techniques provide significant performance gains.", "paper_title": "Safe Nondeterminism in a Deterministic-by-Default Parallel Language", "paper_id": "WOS:000286472700045"}