{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "collection_attributes"}, {"score": 0.004551781491498328, "phrase": "complicated_analysis_tasks"}, {"score": 0.004351595642056769, "phrase": "original_knuth_formalism"}, {"score": 0.004160177106153782, "phrase": "collection_attribute_mechanism"}, {"score": 0.0037595947142663997, "phrase": "distant_nodes"}, {"score": 0.0036966717141736355, "phrase": "abstract_syntax_tree"}, {"score": 0.0035141291835319682, "phrase": "circular_attributes"}, {"score": 0.0034359094594153304, "phrase": "fixed-point_iteration"}, {"score": 0.0030017207229983385, "phrase": "jastadd"}, {"score": 0.002607527117561699, "phrase": "key_design_criterion"}, {"score": 0.0024786330057813225, "phrase": "demand_evaluation"}, {"score": 0.0023035922232490106, "phrase": "particular_program"}, {"score": 0.0021651504858015364, "phrase": "large_practical_problems"}, {"score": 0.0021049977753042253, "phrase": "large_java_programs"}], "paper_keywords": ["Attribute grammars", " Collection attributes", " Circular attributes", " Fixed-point computations", " Source code analysis"], "paper_abstract": "In order to make attribute grammars useful for complicated analysis tasks, a number of extensions to the original Knuth formalism have been suggested. One such extension is the collection attribute mechanism, which allows the value of an attribute to be defined as a combination of contributions from distant nodes in the abstract syntax tree. Another extension that has proven useful is circular attributes, evaluated using fixed-point iteration. In this paper we show how collection attributes and the combined formalism, circular collection attributes, have been implemented in our declarative meta programming system JastAdd, and how they can be used for a variety of applications including devirtualization analysis, metrics and flow analysis. A number of evaluation algorithms are introduced and compared for applicability and efficiency. The key design criterion for our algorithms is that they work well with demand evaluation, i.e., defined properties are computed only if they are actually needed for a particular program. We show that the best algorithms work well on large practical problems including the analysis of large Java programs.", "paper_title": "Demand-driven evaluation of collection attributes", "paper_id": "WOS:000265084000005"}