{"auto_keywords": [{"score": 0.04641494111758786, "phrase": "pipeline_stages"}, {"score": 0.010601561672388227, "phrase": "periscope"}, {"score": 0.00481495049065317, "phrase": "code_optimizations"}, {"score": 0.004764220976404241, "phrase": "data-parallel_pipelines"}, {"score": 0.004377077848734575, "phrase": "distributed_data-parallel_program"}, {"score": 0.004173244935967375, "phrase": "full_awareness"}, {"score": 0.0038953958723049287, "phrase": "traditional_compilers"}, {"score": 0.003813669883040509, "phrase": "procedural_code"}, {"score": 0.0037534983455974947, "phrase": "data-parallel_program"}, {"score": 0.0034849681064606543, "phrase": "poor_performance"}, {"score": 0.0031342307827666675, "phrase": "data-parallel_program's_procedural_code"}, {"score": 0.0029409171055888804, "phrase": "program's_pipeline_topology"}, {"score": 0.002863921785266393, "phrase": "unnecessary_code"}, {"score": 0.0027889366191837504, "phrase": "early_data_filtering"}, {"score": 0.0027303606813078255, "phrase": "small_derived_values"}, {"score": 0.0023532890136269986, "phrase": "symbolic_execution"}, {"score": 0.0022434880661725493, "phrase": "dead_code"}, {"score": 0.0021049977753042253, "phrase": "real_production_jobs"}], "paper_keywords": ["Data-parallel", " data-shuffling I/O", " optimization", " static analysis", " symbolic execution"], "paper_abstract": "To minimize the amount of data-shuffling I/O that occurs between the pipeline stages of a distributed data-parallel program, its procedural code must be optimized with full awareness of the pipeline that it executes in. Unfortunately, neither pipeline optimizers nor traditional compilers examine both the pipeline and procedural code of a data-parallel program so programmers must either hand-optimize their program across pipeline stages or live with poor performance. To resolve this tension between performance and programmability, this paper describes PeriSCOPE, which automatically optimizes a data-parallel program's procedural code in the context of data flow that is reconstructed from the program's pipeline topology. Such optimizations eliminate unnecessary code and data, perform early data filtering, and calculate small derived values (e.g., predicates) earlier in the pipeline, so that less data-sometimes much less data-is transferred between pipeline stages. PeriSCOPE further leverages symbolic execution to enlarge the scope of such optimizations by eliminating dead code. We describe how PeriSCOPE is implemented and evaluate its effectiveness on real production jobs.", "paper_title": "Spotting Code Optimizations in Data-Parallel Pipelines through PeriSCOPE", "paper_id": "WOS:000354526000019"}