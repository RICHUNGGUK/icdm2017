{"auto_keywords": [{"score": 0.034462762924261675, "phrase": "zero-lifetime_objects"}, {"score": 0.01399344657837207, "phrase": "application-_independent_heuristics"}, {"score": 0.011082630029170992, "phrase": "fully_precise_prediction"}, {"score": 0.00481495049065317, "phrase": "java_object_lifetimes"}, {"score": 0.0047468516620285525, "phrase": "object_lifetimes"}, {"score": 0.004663074596384574, "phrase": "memory_management_systems"}, {"score": 0.004629977311316031, "phrase": "current_garbage_collectors"}, {"score": 0.0045971138571344345, "phrase": "relatively_coarse-grained_predictions"}, {"score": 0.004220406575749275, "phrase": "local_characteristics"}, {"score": 0.004087207102190335, "phrase": "prediction_method"}, {"score": 0.003633652174971415, "phrase": "smallest_unit"}, {"score": 0.0034690732089830045, "phrase": "high_precision"}, {"score": 0.0034077704063304208, "phrase": "single_lifetime_predictor"}, {"score": 0.0033119237381809617, "phrase": "first_time"}, {"score": 0.0031393948330209255, "phrase": "significant_fraction"}, {"score": 0.0031170783606525856, "phrase": "object_allocations"}, {"score": 0.003094920033010818, "phrase": "benchmark_programs"}, {"score": 0.003061976628792769, "phrase": "java_programming_language"}, {"score": 0.002790723338582723, "phrase": "longer_lived_objects"}, {"score": 0.0024895500851796603, "phrase": "spec_benchmark_programs"}, {"score": 0.002445514186654732, "phrase": "dynamically_allocated_objects"}, {"score": 0.002419466507425567, "phrase": "accurate_predictors"}, {"score": 0.002309754152767196, "phrase": "garbage_collectors"}, {"score": 0.0022608057001451414, "phrase": "death-_ordered_collector"}, {"score": 0.002150580119047236, "phrase": "memory_performance"}, {"score": 0.0021049977753042253, "phrase": "extra_information"}], "paper_keywords": ["object lifetimes", " workload characterization", " pretenuring", " object-oriented programming languages", " garbage collection", " program behavior"], "paper_abstract": "Accurately predicting object lifetimes is important for improving memory management systems. Current garbage collectors make relatively coarse-grained predictions ( e. g., \"short-lived\" versus \"long-lived\") and rely on application- independent heuristics related to the local characteristics of an allocation. This paper introduces a prediction method which is fully precise and makes its predictions based on application- specific training rather than application- independent heuristics. By \"fully precise\" we mean that the granularity of predictions is equal to the smallest unit of allocation. The method described here is the first to combine high precision and efficiency in a single lifetime predictor. Fully precise prediction enables us, for the first time, to study zero-lifetime objects. The paper reports results showing that zero-lifetime objects comprise a significant fraction of object allocations in benchmark programs for the Java programming language and that they are correlated with their allocation context ( the call stack and allocation site). Beyond zero-lifetime objects, the paper reports results on predicting longer lived objects, where, in some cases, it is possible to predict the lifetime of objects based on their allocation context ( the call stack and allocation site) well. For the SPEC benchmark programs, the number of dynamically allocated objects whose call sites have accurate predictors ranges from 0.2 percent to 61 percent. This method could potentially improve the performance of garbage collectors. The paper proposes a death- ordered collector (DOC) and analyzes its implementation overheads and its best possible performance. The study shows how memory performance could be enhanced using the extra information provided by fully precise prediction.", "paper_title": "On the prediction of Java object lifetimes", "paper_id": "WOS:000237631000008"}