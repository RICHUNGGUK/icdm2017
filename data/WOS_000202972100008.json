{"auto_keywords": [{"score": 0.03629903481395276, "phrase": "artemis"}, {"score": 0.00481495049065317, "phrase": "execution_anomalies"}, {"score": 0.004716520738331953, "phrase": "hardware_and_software_techniques"}, {"score": 0.004601045179623499, "phrase": "dynamic_program_behaviors"}, {"score": 0.004324521292490181, "phrase": "high_overheads"}, {"score": 0.0039323225960857956, "phrase": "long-running_programs"}, {"score": 0.003680587852807675, "phrase": "traditional_techniques"}, {"score": 0.003531474887552889, "phrase": "compiler-based_instrumentation_framework"}, {"score": 0.0034024277222012597, "phrase": "baseline_monitoring_techniques"}, {"score": 0.0031977096047057898, "phrase": "low_asymptotic_monitoring_overhead"}, {"score": 0.003132236287543072, "phrase": "system-load_aware_runtime_monitoring"}, {"score": 0.0029437270961011077, "phrase": "extra_cycles"}, {"score": 0.002907405102646616, "phrase": "system_load"}, {"score": 0.002665362204725326, "phrase": "artemis'_asymptotic_overhead"}, {"score": 0.002621590601574503, "phrase": "performance_floor"}, {"score": 0.0025892330566358503, "phrase": "random_sampling"}, {"score": 0.002473959963690124, "phrase": "monitoring_tool"}, {"score": 0.0024434201175883674, "phrase": "buggy_regions"}, {"score": 0.0023249757987087055, "phrase": "hardware-based_pc-invariance_monitoring_scheme"}, {"score": 0.002122507495446441, "phrase": "moderate_impact"}], "paper_keywords": ["reliability", " debugging", " runtime monitoring", " selective monitoring", " dynamic context", " context invariant", " value invariant", " pointer-type table"], "paper_abstract": "A number of hardware and software techniques have been proposed to detect dynamic program behaviors that may indicate a bug in a program. Because these techniques suffer from high overheads they are useful in finding bugs in programs before they are released, but are significantly less useful in finding bugs in long-running programs on production systems - the same bugs that are the most difficult to find using traditional techniques. In this paper we propose the Artemis(1) compiler-based instrumentation framework that complements many pre-existing runtime monitoring techniques. The Artemis framework guides baseline monitoring techniques toward regions of the program where bugs are likely to occur, yielding a low asymptotic monitoring overhead. Artemis also facilitates system-load aware runtime monitoring that allows the monitoring coverage to be dynamically scaled up to take advantage of extra cycles when the system load is low, and dynamically scaled down to monitor only the most suspicious regions when the system load is high. Our experiments show that Artemis' asymptotic overhead can outperform the performance floor overhead of random sampling for many tools, and that Artemis can effectively guide a monitoring tool to the buggy regions of a program. Our experimental results show that Artemis applied to a hardware-based PC-invariance monitoring scheme and a value-based invariance detection and checking scheme significantly improves their runtime monitoring overhead ( by up to 4.6 times) with moderate impact on their bug-detecting capabilities.", "paper_title": "Artemis: Practical runtime monitoring of applications for execution anomalies", "paper_id": "WOS:000202972100008"}