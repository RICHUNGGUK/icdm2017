{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "memoryless_computation"}, {"score": 0.030204949035849547, "phrase": "shorter_programs"}, {"score": 0.004737579882204798, "phrase": "modern_paradigm"}, {"score": 0.004561826854638056, "phrase": "famous_xor_swap_algorithm"}, {"score": 0.003675120438902734, "phrase": "maximum_and_average_number"}, {"score": 0.003407214479510987, "phrase": "exact_number"}, {"score": 0.002928399649340438, "phrase": "memoryless_programs"}, {"score": 0.002599763359352916, "phrase": "memoryless_computation_framework"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Memoryless computation", " Models of computation", " Computational difficulty", " Symmetric group", " Theory of data", " Combinatorics"], "paper_abstract": "In this paper, we are interested in memoryless computation, a modern paradigm to compute functions which generalises the famous XOR swap algorithm to exchange the contents of two variables without using a buffer. In memoryless computation, programs are only allowed to update one variable at a time. We first consider programs which do not use any memory. We study the maximum and average number of updates required to compute functions without memory. We then derive the exact number of instructions required to compute any manipulation of variables. This shows that combining variables, instead of simply moving them around, not only allows for memoryless programs, but also yields shorter programs. Second, we show that allowing programs to use memory is also incorporated in the memoryless computation framework. We then quantify the gains obtained by using memory: this leads to shorter programs and allows us to use only binary instructions, which is not sufficient in general when no memory is used. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Memoryless computation: New results, constructions, and extensions", "paper_id": "WOS:000347602000011"}