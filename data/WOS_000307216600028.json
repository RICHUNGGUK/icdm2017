{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "computer_scientists"}, {"score": 0.0045726187330434025, "phrase": "physical_systems"}, {"score": 0.00436742595270452, "phrase": "continuous_dynamics"}, {"score": 0.003938650032712796, "phrase": "mathematical_analysis"}, {"score": 0.0034512514926836667, "phrase": "arbitrarily_small_changes"}, {"score": 0.0029722900280316216, "phrase": "mostly-automatic_framework"}, {"score": 0.002544951823639408, "phrase": "immediate_application"}, {"score": 0.0023480892503414596, "phrase": "uncertain_inputs"}, {"score": 0.002294686545883412, "phrase": "longer_run"}, {"score": 0.0021049977753042253, "phrase": "logical_and_analytical_mathematics"}], "paper_keywords": [""], "paper_abstract": "Computer scientists have long believed that software is different from physical systems in one fundamental way: while the latter have continuous dynamics, the former do not. In this paper, we argue that notions of continuity from mathematical analysis are relevant and interesting even for software. First, we demonstrate that many everyday programs are continuous (i.e., arbitrarily small changes to their inputs only cause arbitrarily small changes to their outputs) or Lipschitz continuous (i.e., when their inputs change, their outputs change at most proportionally). Second, we give an mostly-automatic framework for verifying that a program is continuous or Lipschitz, showing that traditional, discrete approaches to proving programs correct can be extended to reason about these properties. An immediate application of our analysis is in reasoning about the robustness of programs that execute on uncertain inputs. In the longer run, it raises hopes for a toolkit for reasoning about programs that freely combines logical and analytical mathematics.", "paper_title": "Continuity and Robustness of Programs", "paper_id": "WOS:000307216600028"}