{"auto_keywords": [{"score": 0.03814106342618422, "phrase": "piecewise_schedules"}, {"score": 0.02837191345962502, "phrase": "ast_expressions"}, {"score": 0.00481495049065317, "phrase": "polyhedral_ast_generation"}, {"score": 0.004700193486903964, "phrase": "integer_polyhedra"}, {"score": 0.004560568143816105, "phrase": "computational_kernels"}, {"score": 0.004505881071218599, "phrase": "complex_loop_transformations"}, {"score": 0.004438439373358016, "phrase": "abstract_syntax_tree"}, {"score": 0.004372002674739612, "phrase": "mathematical_representation"}, {"score": 0.004319566932528865, "phrase": "imperative_program"}, {"score": 0.004203864747683794, "phrase": "transformation-specific_code_generators"}, {"score": 0.003981637972909267, "phrase": "existing_ast_generators"}, {"score": 0.0036479584876742085, "phrase": "complex_transformations"}, {"score": 0.0035824802350703376, "phrase": "modulo_arithmetic"}, {"score": 0.003507567662772987, "phrase": "limited_support"}, {"score": 0.003444600613447231, "phrase": "generated_code"}, {"score": 0.0033827600969034873, "phrase": "vectorizable_kernels"}, {"score": 0.003362393461932223, "phrase": "high_arithmetic_intensity"}, {"score": 0.003312009953245191, "phrase": "peak_performance"}, {"score": 0.0032920678776655783, "phrase": "modern_hardware"}, {"score": 0.0031941384895530426, "phrase": "memory_layout_transformations"}, {"score": 0.003117890043128058, "phrase": "insufficient_control"}, {"score": 0.0030897670291134645, "phrase": "ast_generation_strategy"}, {"score": 0.0030434561939032597, "phrase": "complex_domain-specific_optimizations"}, {"score": 0.0029978373992477028, "phrase": "new_ast_generation_approach"}, {"score": 0.0029707940194245216, "phrase": "classical_polyhedral_scanning"}, {"score": 0.002943993876557772, "phrase": "full_generality"}, {"score": 0.0029262611715147454, "phrase": "presburger_arithmetic"}, {"score": 0.002899861600151726, "phrase": "existentially_quantified_variables"}, {"score": 0.0028477727736832283, "phrase": "new_optimizations"}, {"score": 0.0027881805415682437, "phrase": "shifted_strides"}, {"score": 0.0027298319171606498, "phrase": "flow_generation"}, {"score": 0.002656598121865532, "phrase": "arbitrary_piecewise_quasi-affine_expressions"}, {"score": 0.0025853238923610076, "phrase": "data-layout_transformations"}, {"score": 0.0025083651612064144, "phrase": "polyhedral_unrolling"}, {"score": 0.0024932498388507084, "phrase": "user-directed_versioning"}, {"score": 0.0023328599525181707, "phrase": "finegrained_user_control"}, {"score": 0.0023118013999542594, "phrase": "ast_generation_strategies"}, {"score": 0.0022771244331421586, "phrase": "generalized_idea"}, {"score": 0.0022633993976138387, "phrase": "ast_generation"}, {"score": 0.0022160085332710265, "phrase": "complex_domain-specific_transformations"}, {"score": 0.002176176622950153, "phrase": "specialized_code_generators"}, {"score": 0.0021306081217770173, "phrase": "generic_ast_generator"}, {"score": 0.0021049977753042253, "phrase": "specific_problem_domain"}], "paper_keywords": ["Algorithms", " Performance", " Polyhedral compilation", " code generation", " unrolling", " index set splitting", " Presburger relations"], "paper_abstract": "mathematical representations such as integer polyhedra have been shown to be useful to precisely analyze computational kernels and to express complex loop transformations. Such transformations rely on abstract syntax tree (AST) generators to convert the mathematical representation back to an imperative program. Such generic AST generators avoid the need to resort to transformation-specific code generators, which may be very costly or technically difficult to develop as transformations become more complex. Existing AST generators have proven their effectiveness, but they hit limitations in more complex scenarios. Specifically, (1) they do not support or may fail to generate control flow for complex transformations using piecewise schedules or mappings involving modulo arithmetic; (2) they offer limited support for the specialization of the generated code exposing compact, straightline, vectorizable kernels with high arithmetic intensity necessary to exploit the peak performance of modern hardware; (3) they offer no support for memory layout transformations; and (4) they provide insufficient control over the AST generation strategy, preventing their application to complex domain-specific optimizations. We present a new AST generation approach that extends classical polyhedral scanning to the full generality of Presburger arithmetic, including existentially quantified variables and piecewise schedules, and introduce new optimizations for the detection of components and shifted strides. Not limiting ourselves to control flow generation, we expose functionality to generate AST expressions from arbitrary piecewise quasi-affine expressions, which enables the use of our AST generator for data-layout transformations. We complement this with support for specialization by polyhedral unrolling, user-directed versioning, and specialization of AST expressions according to the location at which they are generated, and we complete this work with finegrained user control over the AST generation strategies used. Using this generalized idea of AST generation, we present how to implement complex domain-specific transformations without the need to write specialized code generators, but instead relying on a generic AST generator parametrized to a specific problem domain.", "paper_title": "Polyhedral AST Generation Is More Than Scanning Polyhedra", "paper_id": "WOS:000360005000002"}