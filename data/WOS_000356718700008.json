{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "optimization"}, {"score": 0.004712988631183401, "phrase": "data-intensive_applications"}, {"score": 0.004613175917207636, "phrase": "modern_multi"}, {"score": 0.004216434794603139, "phrase": "off-chip_accesses"}, {"score": 0.004109454074072009, "phrase": "long-latency_memory_accesses"}, {"score": 0.0040223714916651845, "phrase": "useful_computation"}, {"score": 0.0037398106866046972, "phrase": "microarchitectural_interactions"}, {"score": 0.003692040748097991, "phrase": "epoch_profile"}, {"score": 0.0036448787596988423, "phrase": "intuitive_way"}, {"score": 0.003359816816853762, "phrase": "reorder_window"}, {"score": 0.003316884515934182, "phrase": "out-of-order_processor"}, {"score": 0.003232653376857698, "phrase": "processor_stalls"}, {"score": 0.002916521664779295, "phrase": "application's_memory_reference_behavior"}, {"score": 0.002842428606954139, "phrase": "design_space"}, {"score": 0.0028060889647071787, "phrase": "epoch_profiles"}, {"score": 0.0026882700311968025, "phrase": "single_application"}, {"score": 0.0025099367332615794, "phrase": "core_count_constraints"}, {"score": 0.0024884913795612707, "phrase": "additional_challenges"}, {"score": 0.002467228805628948, "phrase": "epoch-based_microarchitectural_analysis"}, {"score": 0.002414861891567233, "phrase": "better_way"}, {"score": 0.002353483216544667, "phrase": "memory-bound_applications"}, {"score": 0.0022936610196951962, "phrase": "physical_constraints"}, {"score": 0.0021692000054033956, "phrase": "multidimensional_design_space"}, {"score": 0.0021049977753042253, "phrase": "high-level_model-driven_techniques"}], "paper_keywords": ["Microarchitecture analysis", " memory-level parallelism", " visualization"], "paper_abstract": "The performance of data-intensive applications, when running on modern multi-and many-core processors, is largely determined by their memory access behavior. Its most important contributors are the frequency and latency of off-chip accesses and the extent to which long-latency memory accesses can be overlapped with useful computation or with each other. In this paper we present two methods to better understand application and microarchitectural interactions. An epoch profile is an intuitive way to understand the relationships between three important characteristics: the on-chip cache size, the size of the reorder window of an out-of-order processor, and the frequency of processor stalls caused by long-latency, off-chip requests (epochs). By relating these three quantities one can more easily understand an application's memory reference behavior and thus significantly reduce the design space. While epoch profiles help to provide insight into the behavior of a single application, developing an understanding of a number of applications in the presence of area and core count constraints presents additional challenges. Epoch-based microarchitectural analysis is presented as a better way to understand the trade-offs for memory-bound applications in the presence of these physical constraints. Through epoch profiling and optimization, one can significantly reduce the multidimensional design space for hardware/software optimization through the use of high-level model-driven techniques.", "paper_title": "Epoch Profiles: Microarchitecture-Based Application Analysis and Optimization", "paper_id": "WOS:000356718700008"}