{"auto_keywords": [{"score": 0.03309478076749225, "phrase": "new_algorithm"}, {"score": 0.004656259417077092, "phrase": "tm"}, {"score": 0.004016072233242585, "phrase": "best_known_solution"}, {"score": 0.0038833278847237858, "phrase": "java_concurrency_package"}, {"score": 0.003780286517897356, "phrase": "blocking_concurrent_implementation"}, {"score": 0.0035344448639851827, "phrase": "highly_scalable_wait-free_implementation"}, {"score": 0.003282383509542342, "phrase": "new_lock-free_interrupting_snapshots_algorithm"}, {"score": 0.0030482430937467013, "phrase": "snapshot_scan_methods"}, {"score": 0.0028498718992429825, "phrase": "shared_linearization_point"}, {"score": 0.0025935941070969575, "phrase": "classical_atomic_snapshot_problem"}, {"score": 0.0024084679931209514, "phrase": "shared_global_view"}, {"score": 0.0021917966722180132, "phrase": "existing_implementations"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Multicore algorithms", " Java concurrency", " Concurrent data-structures", " Wait-free", " Lock-free"], "paper_abstract": "The Java (TM) m developers kit requires a size () operation for all objects, tracking the number of elements in the object. Unfortunately, the best known solution, available in the Java concurrency package, has a blocking concurrent implementation that does not scale. This paper presents a highly scalable wait-free implementation of a concurrent size () operation based on a new lock-free interrupting snapshots algorithm. The key idea behind the new algorithm is to allow snapshot scan methods to interrupt each other until they agree on a shared linearization point with respect to update methods. This contrasts sharply with past approaches to the classical atomic snapshot problem, that have had threads coordinate the collecting of a shared global view. As we show empirically, the new algorithm scales well, significantly outperforming existing implementations. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "Interrupting snapshots and the Java (TM) size method", "paper_id": "WOS:000304844600005"}