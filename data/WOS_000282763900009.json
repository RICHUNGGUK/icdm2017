{"auto_keywords": [{"score": 0.0365567961388598, "phrase": "shared_memory"}, {"score": 0.03251579192862461, "phrase": "timing_analysis"}, {"score": 0.02926876360393359, "phrase": "memory_access_time"}, {"score": 0.00481495049065317, "phrase": "emerging_trend"}, {"score": 0.004784448637292493, "phrase": "embedded_systems"}, {"score": 0.004649552749844436, "phrase": "real-time_java_multiprocessor"}, {"score": 0.004561732093492262, "phrase": "symmetric_shared-memory_multiprocessor"}, {"score": 0.004213240903095234, "phrase": "chip_bus"}, {"score": 0.0041074234667687875, "phrase": "multiple_cpus"}, {"score": 0.004068427912211707, "phrase": "shared_main_memory"}, {"score": 0.003829877278269543, "phrase": "average-case_performance"}, {"score": 0.0037935066882208235, "phrase": "fixed_priority"}, {"score": 0.003593812067062062, "phrase": "different_cpus"}, {"score": 0.0035146616294377386, "phrase": "others'_execution_times"}, {"score": 0.0033084729942065142, "phrase": "worst-case_execution_time"}, {"score": 0.0031242709509664806, "phrase": "main_memory"}, {"score": 0.0030167734733376984, "phrase": "homogeneous_multiprocessor_systems"}, {"score": 0.0028761045789798103, "phrase": "time-sliced_memory_arbitration"}, {"score": 0.0028397103530211415, "phrase": "viable_worst-case_execution_time_bounds"}, {"score": 0.0027419768837926885, "phrase": "equal_time_slots"}, {"score": 0.0026815568068027547, "phrase": "cpu."}, {"score": 0.002664513608074113, "phrase": "memory_arbitration_scheme"}, {"score": 0.0026140878612307536, "phrase": "upper_bounds"}, {"score": 0.0025974916908139472, "phrase": "java_application_worst-case_execution_times"}, {"score": 0.0025160740422447837, "phrase": "time_slot_size"}, {"score": 0.0024527767211457046, "phrase": "worst-case_execution_time_calculation"}, {"score": 0.0024063484128685367, "phrase": "analyzed_results"}, {"score": 0.0023834640793589414, "phrase": "real-world_application_task"}, {"score": 0.0023532890136269986, "phrase": "measured_execution_time_results"}, {"score": 0.00227225841515826, "phrase": "time-predictable_solution"}, {"score": 0.0021049977753042253, "phrase": "cmp_prototype"}], "paper_keywords": ["Design", " Experimentation", " Measurement", " Performance", " Real-time system", " multiprocessor", " Java processor", " shared memory", " worst-case execution time"], "paper_abstract": "Chip-multiprocessors are an emerging trend for embedded systems. In this article, we introduce a real-time Java multiprocessor called JopCMP. It is a symmetric shared-memory multiprocessor, and consists of up to eight Java Optimized Processor (JOP) cores, an arbitration control device, and a shared memory. All components are interconnected via a system on chip bus. The arbiter synchronizes the access of multiple CPUs to the shared main memory. In this article, three different arbitration policies are presented, evaluated, and compared with respect to their real-time and average-case performance: a fixed priority, a fair-based, and a time-sliced arbiter. Tasks running on different CPUs of a chip-multiprocessor (CMP) influence each others' execution times when accessing a shared memory. Therefore, the system needs an arbiter that is able to limit the worst-case execution time of a task running on a CPU, even though tasks executing simultaneously on other CPUs access the main memory. Our research shows that timing analysis is in fact possible for homogeneous multiprocessor systems with a shared memory. The timing analysis of tasks, executing on the CMP using time-sliced memory arbitration, leads to viable worst-case execution time bounds. The time-sliced arbiter divides the memory access time into equal time slots, one time slot for each CPU. This memory arbitration scheme allows for a calculation of upper bounds of Java application worst-case execution times, depending on the number of CPUs, the time slot size, and the memory access time. Examples of worst-case execution time calculation are presented, and the analyzed results of a real-world application task are compared to measured execution time results. Finally, we evaluate the tradeoffs when using a time-predictable solution compared to using average-case optimized chip-multiprocessors, applying three different benchmarks. These experiments are carried out by executing the programs on the CMP prototype.", "paper_title": "A Real-Time Java Chip-Multiprocessor", "paper_id": "WOS:000282763900009"}