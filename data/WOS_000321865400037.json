{"auto_keywords": [{"score": 0.049465088868450455, "phrase": "dijkstra_monad"}, {"score": 0.014810298491524336, "phrase": "javascript"}, {"score": 0.013143708000830244, "phrase": "dijkstra"}, {"score": 0.00481495049065317, "phrase": "higher-order_programs"}, {"score": 0.004712463245074863, "phrase": "modern_programming_languages"}, {"score": 0.004632066547115808, "phrase": "haskell"}, {"score": 0.004456167724505754, "phrase": "java"}, {"score": 0.004379977556546879, "phrase": "extensive_use"}, {"score": 0.004342430078306461, "phrase": "higher-order_state"}, {"score": 0.004231699728933577, "phrase": "new_verification_methodology"}, {"score": 0.004195418010131832, "phrase": "higher-order_stateful_programs"}, {"score": 0.004106063237069123, "phrase": "new_monad"}, {"score": 0.0040708542958968605, "phrase": "predicate_transformers"}, {"score": 0.0037028514035425037, "phrase": "weakest_pre-condition_calculus"}, {"score": 0.003623949225126944, "phrase": "computed_specifications"}, {"score": 0.003486123304074186, "phrase": "single-state_post-conditions"}, {"score": 0.0031435968684569112, "phrase": "heap_invariants"}, {"score": 0.0029467742734417255, "phrase": "f-star_programming_language"}, {"score": 0.0027741761880779535, "phrase": "javascript_programs"}, {"score": 0.0026916956768363158, "phrase": "tool_chain"}, {"score": 0.0025449518236394103, "phrase": "loop_invariants"}, {"score": 0.0023548511815224098, "phrase": "smt_solver"}, {"score": 0.0022651818270925704, "phrase": "core_model"}, {"score": 0.002236055625099805, "phrase": "javascript_runtime"}, {"score": 0.0022168460543913787, "phrase": "f-star_respects"}, {"score": 0.0021416404045850224, "phrase": "javascript_source_programs"}, {"score": 0.0021049977753042253, "phrase": "runtime_errors"}], "paper_keywords": ["Verification", " Predicate transformer", " Hoare monad", " refinement types", " dynamic languages"], "paper_abstract": "Modern programming languages, ranging from Haskell and ML, to JavaScript, C# and Java, all make extensive use of higher-order state. This paper advocates a new verification methodology for higher-order stateful programs, based on a new monad of predicate transformers called the Dijkstra monad. Using the Dijkstra monad has a number of benefits. First, the monad naturally yields a weakest pre-condition calculus. Second, the computed specifications are structurally simpler in several ways, e.g., single-state post-conditions are sufficient (rather than the more complex two-state post-conditions). Finally, the monad can easily be varied to handle features like exceptions and heap invariants, while retaining the same type inference algorithm. We implement the Dijkstra monad and its type inference algorithm for the F-star programming language. Our most extensive case study evaluates the Dijkstra monad and its F-star implementation by using it to verify JavaScript programs. Specifically, we describe a tool chain that translates programs in a subset of JavaScript decorated with assertions and loop invariants to F-star. Once in F-star, our type inference algorithm computes verification conditions and automatically discharges their proofs using an SMT solver. We use our tools to prove that a core model of the JavaScript runtime in F-star respects various invariants and that a suite of JavaScript source programs are free of runtime errors.", "paper_title": "Verifying Higher-order Programs with the Dijkstra Monad", "paper_id": "WOS:000321865400037"}