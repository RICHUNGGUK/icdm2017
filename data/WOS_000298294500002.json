{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "false_sharing"}, {"score": 0.0047341211614980085, "phrase": "insidious_problem"}, {"score": 0.004702168843383725, "phrase": "multithreaded_programs"}, {"score": 0.004654642380553263, "phrase": "multicore_processors"}, {"score": 0.0044844333655153605, "phrase": "previous_tools"}, {"score": 0.00427673687759065, "phrase": "true_sharing"}, {"score": 0.004233492114255375, "phrase": "high_false_positive_rates"}, {"score": 0.004176509019758331, "phrase": "limited_assistance"}, {"score": 0.0040264770111135524, "phrase": "different_threads"}, {"score": 0.003905530615974537, "phrase": "performance_impact"}, {"score": 0.0036224139706218916, "phrase": "separate_processes"}, {"score": 0.003561538703076064, "phrase": "api"}, {"score": 0.0034898187091432806, "phrase": "per-thread_memory_isolation"}, {"score": 0.0034311578789991363, "phrase": "per-page_basis"}, {"score": 0.003384937597777401, "phrase": "sheriff"}, {"score": 0.003350679980619693, "phrase": "independent_interest"}, {"score": 0.0029455250501196286, "phrase": "low_overhead"}, {"score": 0.0028089019809364817, "phrase": "exact_objects"}, {"score": 0.0027336881691956186, "phrase": "case_study"}, {"score": 0.0027152006721460347, "phrase": "sheriff-detect's_effectiveness"}, {"score": 0.0024440836179156593, "phrase": "memory_consumption"}, {"score": 0.0024111277643627154, "phrase": "runtime_performance"}, {"score": 0.0023465400668244386, "phrase": "shared_updates"}, {"score": 0.0023148964315569866, "phrase": "separate_physical_addresses"}, {"score": 0.0022074592164608134, "phrase": "sheriff-protect"}, {"score": 0.0021556211190198703, "phrase": "catastrophic_false_sharing"}, {"score": 0.0021049977753042253, "phrase": "programmer_intervention"}], "paper_keywords": ["Performance", " Measurement", " False Sharing", " Multi-threaded"], "paper_abstract": "False sharing is an insidious problem for multithreaded programs running on multicore processors, where it can silently degrade performance and scalability. Previous tools for detecting false sharing are severely limited: they cannot distinguish false sharing from true sharing, have high false positive rates, and provide limited assistance to help programmers locate and resolve false sharing. This paper presents two tools that attack the problem of false sharing: SHERIFF-DETECT and SHERIFF-PROTECT. Both tools leverage a framework we introduce here called SHERIFF. SHERIFF breaks out threads into separate processes, and exposes an API that allows programs to perform per-thread memory isolation and tracking on a per-page basis. We believe SHERIFF is of independent interest. SHERIFF-DETECT finds instances of false sharing by comparing updates within the same cache lines by different threads, and uses sampling to rank them by performance impact. SHERIFF-DETECT is precise (no false positives), runs with low overhead (on average, 20%), and is accurate, pinpointing the exact objects involved in false sharing. We present a case study demonstrating SHERIFF-DETECT's effectiveness at locating false sharing in a variety of benchmarks. Rewriting a program to fix false sharing can be infeasible when source is unavailable, or undesirable when padding objects would unacceptably increase memory consumption or further worsen runtime performance. SHERIFF-PROTECT mitigates false sharing by adaptively isolating shared updates from different threads into separate physical addresses, effectively eliminating most of the performance impact of false sharing. We show that SHERIFF-PROTECT can improve performance for programs with catastrophic false sharing by up to 9x, without programmer intervention.", "paper_title": "SHERIFF: Precise Detection and Automatic Mitigation of False Sharing", "paper_id": "WOS:000298294500002"}