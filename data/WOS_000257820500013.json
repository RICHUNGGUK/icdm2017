{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "embedded_stream_programs"}, {"score": 0.0047057084749407485, "phrase": "live_data_streams"}, {"score": 0.004412780054037622, "phrase": "wavescript"}, {"score": 0.004352411290383643, "phrase": "domain-specific_language"}, {"score": 0.0039341294012600085, "phrase": "streaming_domain"}, {"score": 0.003809628721278519, "phrase": "novel_evaluation_strategy"}, {"score": 0.0035722806911457545, "phrase": "stream_dataflow_graphs"}, {"score": 0.0034751259234824913, "phrase": "profile-driven_compilation"}, {"score": 0.003213920601037463, "phrase": "dataflow_domain"}, {"score": 0.0031121406603482112, "phrase": "extensible_system"}, {"score": 0.003083655376444887, "phrase": "rewrite_rules"}, {"score": 0.0030414140732789186, "phrase": "algebraic_properties"}, {"score": 0.0030135741897058844, "phrase": "specific_domains"}, {"score": 0.0029586543333524904, "phrase": "signal_processing"}, {"score": 0.0027614468443073028, "phrase": "acoustic_localization"}, {"score": 0.0027361626349903744, "phrase": "wild_animals"}, {"score": 0.0026616868981501006, "phrase": "yellow-bellied"}, {"score": 0.0026011706232569316, "phrase": "wavescript's_performance"}, {"score": 0.0024956789310376635, "phrase": "good_performance"}, {"score": 0.002461472107682778, "phrase": "embedded_and_desktop-class_machines"}, {"score": 0.0023944552329463035, "phrase": "substantial_parallel_speedups"}, {"score": 0.0022450768409733807, "phrase": "previous_c_implementation"}], "paper_keywords": ["design", " languages", " performance", " stream processing language", " sensor networks"], "paper_abstract": "Applications that combine live data streams with embedded, parallel, and distributed processing are becoming more commonplace. WaveScript is a domain-specific language that brings high-level, type-safe, garbage-collected programming to these domains. This is made possible by three primary implementation techniques, each of which leverages characteristics of the streaming domain. First, we employ a novel evaluation strategy that uses a combination of interpretation and reification to partially evaluate programs into stream dataflow graphs. Second, we use profile-driven compilation to enable many optimizations that are normally only available in the synchronous (rather than asynchronous) dataflow domain. Finally, we incorporate an extensible system for rewrite rules to capture algebraic properties in specific domains (such as signal processing). We have used our language to build and deploy a sensor-network for the acoustic localization of wild animals, in particular, the Yellow-Bellied marmot. We evaluate WaveScript's performance on this application, showing that it yields good performance on both embedded and desktop-class machines, including distributed execution and substantial parallel speedups. Our language allowed us to implement the application rapidly, while outperforming a previous C implementation by over 35%, using fewer than half the lines of code. We evaluate the contribution of our optimizations to this success.", "paper_title": "Design and evaluation of a compiler for embedded stream programs", "paper_id": "WOS:000257820500013"}