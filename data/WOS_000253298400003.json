{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "software_architecture_design"}, {"score": 0.0047109772769370496, "phrase": "java"}, {"score": 0.004435514622798228, "phrase": "early_analysis"}, {"score": 0.004292212137716459, "phrase": "subsequent_development_activities"}, {"score": 0.004222299135545249, "phrase": "additional_major_benefit"}, {"score": 0.004130842663662047, "phrase": "partial_prototype_implementation"}, {"score": 0.0037226570791514184, "phrase": "software_architecture_designs"}, {"score": 0.0033916328188225843, "phrase": "software_architectural_description"}, {"score": 0.0031069334778456633, "phrase": "additional_monitoring_code"}, {"score": 0.0030562674358159945, "phrase": "desirable_behavior_properties"}, {"score": 0.0030229485340586473, "phrase": "runtime_verification"}, {"score": 0.0029412271277166873, "phrase": "software_description"}, {"score": 0.0028933067178028766, "phrase": "sam"}, {"score": 0.0027843339377323878, "phrase": "dual_formal_methods"}, {"score": 0.00276913590663651, "phrase": "petri"}, {"score": 0.002522662955545598, "phrase": "sam_architecture_description"}, {"score": 0.0024951467586005094, "phrase": "archjava_code"}, {"score": 0.002454432810862053, "phrase": "behavior_models"}, {"score": 0.002388043660169452, "phrase": "petri_nets"}, {"score": 0.002349073225500705, "phrase": "plain_java_code"}, {"score": 0.0022980978400845144, "phrase": "property_specifications"}, {"score": 0.002260591903283384, "phrase": "temporal_logic"}, {"score": 0.0022359278646792153, "phrase": "aspectj_code"}, {"score": 0.0021399277552314067, "phrase": "java_code"}, {"score": 0.0021049977753042253, "phrase": "experimental_result"}], "paper_keywords": ["formal methods", " Petri nets", " temporal logic", " software architecture descriptions", " translation", " correctness"], "paper_abstract": "A software architecture design has many benefits including aiding comprehension, supporting early analysis, and providing guidance for subsequent development activities. An additional major benefit is if a partial prototype implementation can be automatically generated from a given software architecture design. However, in the past decade less progress was made on automatically realizing software architecture designs. In this paper, we present a translator for automatically generating an implementation from a software architectural description. The implementation not only captures the functionality of the given architecture description, but also contains additional monitoring code for ensuring desirable behavior properties through runtime verification. Our method takes a software description written in SAM, a software architecture model integrating dual formal methods Petri nets and temporal logic, and generates ArchJava/Java/AspectJ code. More specifically, the structure of a SAM architecture description produces ArchJava code, the behavior models of components/connectors represented in Petri nets lead to plain Java code, and the property specifications defined in temporal logic generate AspectJ code; the above code segments are then integrated into Java code. An experimental result is provided.", "paper_title": "A translator of software architecture design from sam to Java", "paper_id": "WOS:000253298400003"}