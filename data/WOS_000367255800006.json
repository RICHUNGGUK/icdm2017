{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "refinement_types"}, {"score": 0.004494570360108983, "phrase": "bounded_quantification"}, {"score": 0.00376488621224566, "phrase": "typed_combinators"}, {"score": 0.0027200305495826797, "phrase": "refined_io_monad"}, {"score": 0.0025892330566358503, "phrase": "resource_usage"}, {"score": 0.0021049977753042253, "phrase": "automated_and_decidable_smt_based_checking"}], "paper_keywords": ["haskell", " refinement types", " abstract interpretation"], "paper_abstract": "We present a notion of bounded quantification for refinement types and show how it expands the expressiveness of refinement typing by using it to develop typed combinators for: (1) relational algebra and safe database access, (2) Floyd-Hoare logic within a state transformer monad equipped with combinators for branching and looping, and (3) using the above to implement a refined IO monad that tracks capabilities and resource usage. This leap in expressiveness comes via a translation to \"ghost\" functions, which lets us retain the automated and decidable SMT based checking and inference that makes refinement typing effective in practice.", "paper_title": "Bounded Refinement Types", "paper_id": "WOS:000367255800006"}