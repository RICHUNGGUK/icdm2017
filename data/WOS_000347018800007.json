{"auto_keywords": [{"score": 0.04562069191431079, "phrase": "talm"}, {"score": 0.012168313906117964, "phrase": "data-flow_graph"}, {"score": 0.01161810086566556, "phrase": "trebuchet"}, {"score": 0.00481495049065317, "phrase": "coarse-grained_data-flow_compilation"}, {"score": 0.00467424463996457, "phrase": "natural_approach"}, {"score": 0.004461359547152617, "phrase": "fine-grained_data-flow_tasks"}, {"score": 0.004404994123834589, "phrase": "complex_and_present_unwanted_overheads"}, {"score": 0.004098725744818192, "phrase": "user-defined_coarse-grained_parallel_data-flow_model"}, {"score": 0.003459191419478298, "phrase": "talm's_usefulness"}, {"score": 0.003245900262372709, "phrase": "couillard"}, {"score": 0.003097865379563127, "phrase": "annotated_c-program"}, {"score": 0.0028457440091791252, "phrase": "data-flow_execution"}, {"score": 0.002809732883291955, "phrase": "sophisticated_parallel_programming_techniques"}, {"score": 0.0027741761880779535, "phrase": "small_effort"}, {"score": 0.0026475981474045414, "phrase": "real_applications"}, {"score": 0.0026140878612307536, "phrase": "large_multi-core_machine"}, {"score": 0.002570064617803693, "phrase": "popular_parallel_programming_methods"}, {"score": 0.0024842242921857705, "phrase": "easier_parallel_programing_approach"}, {"score": 0.0023708445073819277, "phrase": "wavefront_method"}, {"score": 0.0023309080951251335, "phrase": "big_inputs"}, {"score": 0.002253051156676227, "phrase": "intel"}, {"score": 0.002205692205167157, "phrase": "novel_flow-graph_approach"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Parallel programming", " Data-flow", " Language", " Compiler", " Run-time environment"], "paper_abstract": "Data-flow is a natural approach to parallelism. However, describing dependencies and control between fine-grained data-flow tasks can be complex and present unwanted overheads. TALM (TALM is an Architecture and Language for Multi-threading) introduces a user-defined coarse-grained parallel data-flow model, where programmers identify code blocks, called super-instructions, to be run in parallel and connect them in a data-flow graph. TALM has been implemented as a hybrid Von Neumann/data-flow execution system: the Trebuchet. We have observed that TALM's usefulness largely depends on how programmers specify and connect super-instructions. Thus, we present Couillard, a full compiler that creates, based on an annotated C-program, a data-flow graph and C-code corresponding to each super-instruction. We show that our toolchain allows one to benefit from data-flow execution and explore sophisticated parallel programming techniques, with small effort. To evaluate our system we have executed a set of real applications on a large multi-core machine. Comparison with popular parallel programming methods shows competitive speedups, while providing an easier parallel programing approach. More specifically, for an application that follows the wavefront method, running with big inputs, Trebuchet achieved up to 4.7% speedup over Intel (R) TBB novel flow-graph approach and up to 44% over OpenMP. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Couillard: Parallel programming via coarse-grained Data-flow Compilation", "paper_id": "WOS:000347018800007"}