{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "self-aware_parallelism"}, {"score": 0.009242994330888318, "phrase": "streamaware"}, {"score": 0.004665764181113345, "phrase": "big_data"}, {"score": 0.004556901872357751, "phrase": "new_approach"}, {"score": 0.004521179256835894, "phrase": "data_exploration"}, {"score": 0.004415675459182871, "phrase": "increasing_complexities"}, {"score": 0.004346704947011699, "phrase": "modern_it_systems"}, {"score": 0.0041136473765874815, "phrase": "multicore_platforms"}, {"score": 0.004081385289516914, "phrase": "computing_systems"}, {"score": 0.003939296259436904, "phrase": "self-aware_software"}, {"score": 0.003787191644093659, "phrase": "distributed_applications"}, {"score": 0.003757480190200645, "phrase": "changing_environments"}, {"score": 0.003684213587410217, "phrase": "closed-loop_system"}, {"score": 0.00361237042013781, "phrase": "optimization_strategies"}, {"score": 0.003527998934981411, "phrase": "data_processing"}, {"score": 0.003445591238183763, "phrase": "adaptation_mechanisms"}, {"score": 0.003405109584265324, "phrase": "stream_programs"}, {"score": 0.0033651019362620866, "phrase": "distributed_parallelism"}, {"score": 0.003312486229143855, "phrase": "traditional_stream_programming_models"}, {"score": 0.00320970209394799, "phrase": "human_supervision"}, {"score": 0.0031595084685030845, "phrase": "stream_graph"}, {"score": 0.003097865379563127, "phrase": "one-time_optimization_strategy"}, {"score": 0.0030017207229983385, "phrase": "costly_and_time-consuming_procedures"}, {"score": 0.0028405715222684183, "phrase": "self-aware_stream_programming_model"}, {"score": 0.002785133616425661, "phrase": "key_property"}, {"score": 0.0026045914281028473, "phrase": "dynamic_and_reconfigurable_stream_graph"}, {"score": 0.0025537472239953807, "phrase": "data_flow_changes"}, {"score": 0.002494039334114861, "phrase": "self-awareness_loop"}, {"score": 0.002464709648714996, "phrase": "finite_state_machine"}, {"score": 0.002445347925313158, "phrase": "stream_applications"}, {"score": 0.0023976048394496446, "phrase": "continuous_optimization_strategy"}, {"score": 0.0022958180852458215, "phrase": "empirical_evaluation"}, {"score": 0.0022070310530794097, "phrase": "parsec_benchmark_problems"}, {"score": 0.0021639364229318896, "phrase": "watt"}, {"score": 0.002121670413111008, "phrase": "significant_changes"}, {"score": 0.0021049977753042253, "phrase": "stream_processing"}], "paper_keywords": ["Self-aware parallelism", " Reconfigration", " Multicore", " Message-driven execution", " Stream programming", " Distributed computing"], "paper_abstract": "The age of big data open the door to a new approach in data exploration and utilization. With the increasing complexities and dynamics of modern IT systems and services, it has become a challenge to effectively exploit parallelism on multicore platforms in computing systems that are heterogeneous, dynamic and decentralised. Self-aware software is a response to these demands in dealing with distributed applications in changing environments. It is a closed-loop system with a series of optimization strategies to adjust itself dynamicly during data processing. We focus on incorporating adaptation mechanisms into the stream programs for exposing distributed parallelism. In the traditional stream programming models, changing data and status normally require human supervision to adjust the stream graph for performance. As one-time optimization strategy, the reconfiguration and maintenance lead to costly and time-consuming procedures during the operating phase. To address these problems, we propose a self-aware stream programming model called StreamAware. A key property of this model is that exposing self-aware parallelism in the message driven execution paradigm, which provides dynamic and reconfigurable stream graph in adapting to the data flow changes. The model defines the self-awareness loop based on finite state machine for stream applications to adjust their own stream graph with continuous optimization strategy. This paper presents three different self-aware systems built using StreamAware. The empirical evaluation demonstrate how these systems can exploit self-aware parallelism using the Parsec benchmark problems, optimize performance per Watt, and respond to significant changes in stream processing.", "paper_title": "Achieving self-aware parallelism in stream programs", "paper_id": "WOS:000354412400038"}