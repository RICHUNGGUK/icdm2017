{"auto_keywords": [{"score": 0.04870300013732668, "phrase": "reverse_engineering"}, {"score": 0.03411844897479422, "phrase": "evolution_history"}, {"score": 0.00481495049065317, "phrase": "database_schema_evolution"}, {"score": 0.004745260932479212, "phrase": "case_study"}, {"score": 0.00386876598761639, "phrase": "information_sources"}, {"score": 0.0037392451233558234, "phrase": "sufficient_quality"}, {"score": 0.0036671822784770463, "phrase": "dre_process"}, {"score": 0.003527181559366122, "phrase": "real-world_data"}, {"score": 0.00342568771304873, "phrase": "information_systems"}, {"score": 0.003376037544631762, "phrase": "private_data"}, {"score": 0.003200045185608395, "phrase": "software_programs"}, {"score": 0.0031383410838018953, "phrase": "increasing_role"}, {"score": 0.00303319936111073, "phrase": "comparatively_little_such_research"}, {"score": 0.0029031614127920232, "phrase": "database_reverse_engineering"}, {"score": 0.0026337482179592422, "phrase": "database_evolution_history"}, {"score": 0.00259554612218815, "phrase": "additional_information_source"}, {"score": 0.0025578967205807843, "phrase": "database_schema_reverse_engineering"}, {"score": 0.0024963543716522087, "phrase": "tool-supported_method"}, {"score": 0.002424450174817922, "phrase": "legacy_databases"}, {"score": 0.0023431692392929353, "phrase": "large-scale_case_study"}, {"score": 0.002286781334850213, "phrase": "complex_information_system"}, {"score": 0.002199363362666037, "phrase": "future_research_efforts"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Database understanding", " Schema evolution", " Software repository mining"], "paper_abstract": "Database reverse engineering (DRE) has traditionally been carried out by considering three main information sources: (1) the database schema, (2) the stored data, and (3) the application programs. Not all of these information sources are always available, or of sufficient quality to inform the DRE process. For example, getting access to real-world data is often extremely problematic for information systems that maintain private data. In recent years, the analysis of the evolution history of software programs have gained an increasing role in reverse engineering in general, but comparatively little such research has been carried out in the context of database reverse engineering. The goal of this paper is to contribute to narrowing this gap and exploring the use of the database evolution history as an additional information source to aid database schema reverse engineering. We present a tool-supported method for analyzing the evolution history of legacy databases, and we report on a large-scale case study of reverse engineering a complex information system and curate it as a benchmark for future research efforts within the community. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Understanding database schema evolution: A case study", "paper_id": "WOS:000345725100020"}