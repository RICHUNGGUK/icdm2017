{"auto_keywords": [{"score": 0.0329947502002775, "phrase": "vpc_prediction"}, {"score": 0.008713768692145006, "phrase": "virtual_program_counter"}, {"score": 0.0073248812125234685, "phrase": "indirect_branches"}, {"score": 0.005070740522619259, "phrase": "average_performance"}, {"score": 0.004513255056769647, "phrase": "conditional_branch_prediction_hardware"}, {"score": 0.004315487055548749, "phrase": "modular_programs"}, {"score": 0.004251500979153001, "phrase": "modern_object-oriented_languages"}, {"score": 0.004209369306023422, "phrase": "virtual-machine-based_runtime_systems"}, {"score": 0.0038676325043529524, "phrase": "conditional_branches"}, {"score": 0.003753738096719609, "phrase": "indirect_branch_predictors"}, {"score": 0.00367967106192446, "phrase": "significant_amount"}, {"score": 0.003643185395780667, "phrase": "extra_hardware_storage"}, {"score": 0.0033639840192975835, "phrase": "new_technique"}, {"score": 0.003152915289414825, "phrase": "key_idea"}, {"score": 0.003044785536429499, "phrase": "existing_conditional_branch_prediction_hardware"}, {"score": 0.00299958349498286, "phrase": "indirect_branch_targets"}, {"score": 0.0028966970007550824, "phrase": "separate_storage_structure"}, {"score": 0.0027284410545226306, "phrase": "average_energy_consumption"}, {"score": 0.0026480044868438875, "phrase": "commonly_used_branch_target_buffer"}, {"score": 0.002457110101089137, "phrase": "full_set"}, {"score": 0.0024327171018928458, "phrase": "object-oriented_java_dacapo_applications"}, {"score": 0.0022127018991294047, "phrase": "existing_conditional_branch_prediction_mechanism"}], "paper_keywords": ["Indirect branch prediction", " virtual functions", " devirtualization", " object-oriented languages", " Java"], "paper_abstract": "Indirect branches have become increasingly common in modular programs written in modern object-oriented languages and virtual-machine-based runtime systems. Unfortunately, the prediction accuracy of indirect branches has not improved as much as that of conditional branches. Furthermore, previously proposed indirect branch predictors usually require a significant amount of extra hardware storage and complexity, which makes them less attractive to implement. This paper proposes a new technique for handling indirect branches, called Virtual Program Counter (VPC) prediction. The key idea of VPC prediction is to use the existing conditional branch prediction hardware to predict indirect branch targets, avoiding the need for a separate storage structure. Our comprehensive evaluation shows that VPC prediction improves average performance by 26.7 percent and reduces average energy consumption by 19 percent compared to a commonly used branch target buffer based predictor on 12 indirect branch intensive C/C++ applications. Moreover, VPC prediction improves the average performance of the full set of object-oriented Java DaCapo applications by 21.9 percent, while reducing their average energy consumption by 22 percent. We show that VPC prediction can be used with any existing conditional branch prediction mechanism and that the accuracy of VPC prediction improves when a more accurate conditional branch predictor is used.", "paper_title": "Virtual Program Counter (VPC) Prediction: Very Low Cost Indirect Branch Prediction Using Conditional Branch Prediction Hardware", "paper_id": "WOS:000268162600001"}