{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "mth_roots"}, {"score": 0.03533975786035378, "phrase": "minimum_redundancy"}, {"score": 0.03501467026270221, "phrase": "balanced_code"}, {"score": 0.024825435707528657, "phrase": "balanced_codes"}, {"score": 0.004363185834249464, "phrase": "block_code"}, {"score": 0.004240116703465252, "phrase": "code_word"}, {"score": 0.004133627071344356, "phrase": "complex_sum"}, {"score": 0.00385431710959668, "phrase": "balanced_words"}, {"score": 0.0036167509502276294, "phrase": "prime_number"}, {"score": 0.003582397044768098, "phrase": "set_b-m"}, {"score": 0.0023458049872325214, "phrase": "efficient_coding_methods"}, {"score": 0.002194011800331242, "phrase": "efficient_coding_schemes"}, {"score": 0.0021252141682683123, "phrase": "efficient_balanced_codes"}], "paper_keywords": ["balanced codes", " bipolar alphabet", " DC-free communication", " digital communication", " line codes", " m-ary alphabet", " m-ary communication", " mth roots of unity"], "paper_abstract": "Let Phi(m) subset of C be the set of all mth roots of unity, m is an element of IN. A balanced code over Phi(m) is a block code over the alphabet Phi(m) such that each code word is balanced; that is, the complex sum of its components (or weight) is equal to 0. Let B-m (n) be the set of all balanced words of length n over Phi(m). In this correspondence, it is shown that when m is a prime number, the set B-m (n) is not empty if, and only if, m divides n. In this case, the minimum redundancy for a balanced code over Phi(m) of length n is rho(B-m(n)) = n [log(m) vertical bar B-m(n)vertical bar] approximate to[(m-1)/2]log(m)(2 pi n) - m/2. On the other hand, it is shown that when m = 4, the set B-4 (n) is not empty if, and only if, n is even, and in this case, the minimum redundancy for a balanced code over Phi(4) of length n is rho(B-4(n)) = n - [log(4) vertical bar B-4(n)vertical bar] approximate to log(4) n + 0.326. Further, this correspondence completely solves the problem of designing efficient coding methods for balanced codes over Phi(m), when m = 4. In fact, it reduces the problem of designing efficient coding schemes for balanced codes over Phi(4) to the design of efficient balanced codes over the usual bipolar alphabet Phi(2) = {-1,+1}.", "paper_title": "Efficient balanced codes over the mth roots of unity", "paper_id": "WOS:000237147400030"}