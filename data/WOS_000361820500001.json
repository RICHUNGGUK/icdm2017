{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "edge_corruptions"}, {"score": 0.007243264605005947, "phrase": "honest_nodes"}, {"score": 0.005505511787039418, "phrase": "constant_fraction"}, {"score": 0.004778343328603978, "phrase": "secure_multi-party_computation"}, {"score": 0.004172785303872399, "phrase": "wrong_messages"}, {"score": 0.004086063600095538, "phrase": "information-theoretic_setting"}, {"score": 0.0040318140262464814, "phrase": "computationally_unbounded_adversary"}, {"score": 0.004001136965104636, "phrase": "fully_connected_network"}, {"score": 0.0038659420564511166, "phrase": "constant_factor"}, {"score": 0.003756762595796621, "phrase": "sparse_networks"}, {"score": 0.0037352981333544193, "phrase": "connected_networks"}, {"score": 0.003692735061656311, "phrase": "fully_connected_networks"}, {"score": 0.0036646295642011185, "phrase": "garay"}, {"score": 0.0036506606399414497, "phrase": "ostrovsky"}, {"score": 0.0035004092995878306, "phrase": "node-corruption_model"}, {"score": 0.0034276132805096705, "phrase": "secure_channels"}, {"score": 0.003299360599121341, "phrase": "mpc"}, {"score": 0.003230477584678407, "phrase": "possible_poor_connectivity"}, {"score": 0.0030272372030681325, "phrase": "underlying_communication_graph"}, {"score": 0.003009928329430238, "phrase": "adversarial_set"}, {"score": 0.002885975712278446, "phrase": "exactly_the_same_problem"}, {"score": 0.002788355636042803, "phrase": "communication_channels"}, {"score": 0.0027565529537839943, "phrase": "\"corrupt\"_edges"}, {"score": 0.002678619901335681, "phrase": "secure_computation_protocol"}, {"score": 0.00266329899653395, "phrase": "original_node-corruption_model"}, {"score": 0.0026278892442822416, "phrase": "computation_protocol"}, {"score": 0.002592949056545665, "phrase": "reduced_fraction"}, {"score": 0.002548705970687936, "phrase": "node_corruptions"}, {"score": 0.002529284849052859, "phrase": "polynomial-time_protocol"}, {"score": 0.0022250774838566507, "phrase": "computation_protocols"}, {"score": 0.0022038970103110964, "phrase": "adversarial_edges"}, {"score": 0.002182917712227941, "phrase": "given-up_nodes"}, {"score": 0.0021049977753042253, "phrase": "corrupted_edges"}], "paper_keywords": ["Almost-everywhere secure computation", " bounded-degree network", " Secure message transmission", " Byzantine agreement"], "paper_abstract": "We consider secure multi-party computation (MPC) in a setting where the adversary can separately corrupt not only the parties (nodes) but also the communication channels (edges), and can furthermore choose selectively and adaptively which edges or nodes to corrupt. Note that if an adversary corrupts an edge, even if the two nodes that share that edge are honest, the adversary can control the link and thus deliver wrong messages to both players. We consider this question in the information-theoretic setting, and require security against a computationally unbounded adversary. In a fully connected network the above question is simple (and we also provide an answer that is optimal up to a constant factor). What makes the problem more challenging is to consider the case of sparse networks. Partially connected networks are far more realistic than fully connected networks, which led Garay and Ostrovsky [Eurocrypt'08] to formulate the notion of (unconditional) almost everywhere (a.e.) secure computation in the node-corruption model, i.e., a model in which not all pairs of nodes are connected by secure channels and the adversary can corrupt some of the nodes (but not the edges). In such a setting, MPC among all honest nodes cannot be guaranteed due to the possible poor connectivity of some honest nodes with other honest nodes, and hence some of them must be \"given up\" and left out of the computation. The number of such nodes is a function of the underlying communication graph and the adversarial set of nodes. In this work we introduce the notion of almost-everywhere secure computation with edge corruptions, which is exactly the same problem as described above, except that we additionally allow the adversary to completely control some of the communication channels between two correct nodes-i.e., to \"corrupt\" edges in the network. While it is easy to see that an a.e. secure computation protocol for the original node-corruption model is also an a.e. secure computation protocol tolerating edge corruptions (albeit for a reduced fraction of edge corruptions with respect to the bound for node corruptions), no polynomial-time protocol is known in the case where a constant fraction of the edges can be corrupted (i.e., the maximum that can be tolerated) and the degree of the network is sublinear. We make progress on this front, by constructing graphs of degree O(n (I mu) ) (for arbitrary constant 0 < I mu < 1) on which we can run a.e. secure computation protocols tolerating a constant fraction of adversarial edges. The number of given-up nodes in our construction is mu n (for some constant 0 <mu < 1 that depends on the fraction of corrupted edges), which is also asymptotically optimal.", "paper_title": "Almost-Everywhere Secure Computation with Edge Corruptions", "paper_id": "WOS:000361820500001"}