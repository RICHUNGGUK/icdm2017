{"auto_keywords": [{"score": 0.05007567598103821, "phrase": "parametric_polymorphism"}, {"score": 0.04813182210417669, "phrase": "xml"}, {"score": 0.004778775266506072, "phrase": "xml."}, {"score": 0.004689462599037994, "phrase": "recent_investigations"}, {"score": 0.004654210559456924, "phrase": "static_typing"}, {"score": 0.004464987136420614, "phrase": "well-established_typing_discipline"}, {"score": 0.004365022891478405, "phrase": "xml_processing"}, {"score": 0.004251210982670317, "phrase": "parametric_schemas"}, {"score": 0.0037959868107895053, "phrase": "\"semantic\"_approach"}, {"score": 0.003614124997453808, "phrase": "naive_extension"}, {"score": 0.0035734052458933547, "phrase": "\"semantic\"_quantification"}, {"score": 0.0035065523764817143, "phrase": "type_variables"}, {"score": 0.0033893426032054366, "phrase": "nexptime-complete_problem"}, {"score": 0.0033385105985286154, "phrase": "practical_algorithm"}, {"score": 0.003263683763829895, "phrase": "subtyping_relation"}, {"score": 0.0031784960695034645, "phrase": "programmer's_intuition"}, {"score": 0.00307221807606505, "phrase": "different_method"}, {"score": 0.003014713272570927, "phrase": "semantic_approach"}, {"score": 0.0029360049890445944, "phrase": "key_idea"}, {"score": 0.0028485585670146025, "phrase": "simple_marking_technique"}, {"score": 0.0027846824619356583, "phrase": "polymorphic_type"}, {"score": 0.002495521662819317, "phrase": "type_arguments"}, {"score": 0.0023938516706864775, "phrase": "sensible_system"}, {"score": 0.0023490143960001675, "phrase": "usual_expected_behavior"}, {"score": 0.0023313149689465386, "phrase": "polymorphic_type_systems-\"values"}, {"score": 0.0023137485947956732, "phrase": "abstract_types"}, {"score": 0.002253299769886694, "phrase": "reynold's_parametricity_theory"}, {"score": 0.0021778895748464024, "phrase": "practical_algorithms"}, {"score": 0.0021451873499061633, "phrase": "local_modifications"}, {"score": 0.002129020447793464, "phrase": "existing_ones"}, {"score": 0.0021049977753042253, "phrase": "monomorphic_system"}], "paper_keywords": ["Algorithms", " Design", " Language", " Theory", " XML", " polymorphism", " subtyping", " tree automata"], "paper_abstract": "Despite the extensiveness of recent investigations on static typing for XML, parametric polymorphism has rarely been treated. This well-established typing discipline can also be useful in XML processing in particular for programs involving \"parametric schemas,\" that is, schemas parameterized over other schemas (e. g., SOAP). The difficulty in treating polymorphism for XML lies in how to extend the \"semantic\" approach used in the mainstream (monomorphic) XML type systems. A naive extension would be \"semantic\" quantification over all substitutions for type variables. However, this approach reduces to an NEXPTIME-complete problem for which no practical algorithm is known and induces a subtyping relation that may not always match the programmer's intuition. In this article, we propose a different method that smoothly extends the semantic approach yet is algorithmically easier. The key idea here is to devise a novel and simple marking technique, where we interpret a polymorphic type as a set of values with annotations of which subparts are parameterized. We exploit this interpretation in every ingredient of our polymorphic type system such as subtyping, inference of type arguments, etc. As a result, we achieve a sensible system that directly represents a usual expected behavior of polymorphic type systems-\"values of abstract types are never reconstructed\"-in a reminiscence of Reynold's parametricity theory. Also, we obtain a set of practical algorithms for typechecking by local modifications to existing ones for a monomorphic system.", "paper_title": "Parametric Polymorphism for XML", "paper_id": "WOS:000272629000002"}