{"auto_keywords": [{"score": 0.0296346382211672, "phrase": "commensal_compiler"}, {"score": 0.00481495049065317, "phrase": "high-performance_stream_programming"}, {"score": 0.004502943680955863, "phrase": "performance_benefits"}, {"score": 0.004370814742381778, "phrase": "domain-specific_languages"}, {"score": 0.0041488110506566825, "phrase": "high_cost"}, {"score": 0.004027031316965272, "phrase": "optimizing_compiler"}, {"score": 0.0039088121438737924, "phrase": "commensal_compilation"}, {"score": 0.0037101871762082153, "phrase": "embedded_domain-specific_languages"}, {"score": 0.003601235776892337, "phrase": "massive_investment"}, {"score": 0.0035479614996805383, "phrase": "modern_language_virtual_machine_platforms"}, {"score": 0.003392804886610623, "phrase": "host_language's_front-end"}, {"score": 0.0031963987773420068, "phrase": "back-end_optimizations"}, {"score": 0.0031257046538823354, "phrase": "host_platform"}, {"score": 0.003102493111015758, "phrase": "jit"}, {"score": 0.0029447150254434842, "phrase": "optimization_selection"}, {"score": 0.0026726283357752585, "phrase": "domain-specific_optimizations"}, {"score": 0.002443784721651744, "phrase": "stream_programming_language_streamjit"}, {"score": 0.002389696110283506, "phrase": "java_platform"}, {"score": 0.002217880187104576, "phrase": "streamit_native_code"}, {"score": 0.0021687910153853174, "phrase": "gcc"}, {"score": 0.0021049977753042253, "phrase": "considerably_less_implementation_effort"}], "paper_keywords": ["Domain-specific languages", " embedded domain-specific languages"], "paper_abstract": "There are many domain libraries, but despite the performance benefits of compilation, domain-specific languages are comparatively rare due to the high cost of implementing an optimizing compiler. We propose commensal compilation, a new strategy for compiling embedded domain-specific languages by reusing the massive investment in modern language virtual machine platforms. Commensal compilers use the host language's front-end, use host platform APIs that enable back-end optimizations by the host platform JIT, and use an autotuner for optimization selection. The cost of implementing a commensal compiler is only the cost of implementing the domain-specific optimizations. We demonstrate the concept by implementing a commensal compiler for the stream programming language StreamJIT atop the Java platform. Our compiler achieves performance 2.8 times better than the StreamIt native code (via GCC) compiler with considerably less implementation effort.", "paper_title": "StreamJIT: A Commensal Compiler for High-Performance Stream Programming", "paper_id": "WOS:000348907400011"}