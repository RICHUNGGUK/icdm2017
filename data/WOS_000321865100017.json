{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multicore_embedded_systems"}, {"score": 0.04974351188371698, "phrase": "mca_apis"}, {"score": 0.009884892696087218, "phrase": "posix_threads"}, {"score": 0.004616034337089482, "phrase": "telecommunication_systems"}, {"score": 0.004551563730037998, "phrase": "medical_applications"}, {"score": 0.004394281902031765, "phrase": "low-power_solution"}, {"score": 0.004317682099870507, "phrase": "efficient_way"}, {"score": 0.004067051881100314, "phrase": "software_developers"}, {"score": 0.00395417485449239, "phrase": "low-level_details"}, {"score": 0.0038852284795658286, "phrase": "dma"}, {"score": 0.0038444185258456245, "phrase": "cache_coherency"}, {"score": 0.0037906837773782, "phrase": "synchronization_primitives"}, {"score": 0.003608437115371213, "phrase": "software_toolchain"}, {"score": 0.003459191419478298, "phrase": "particular_hardware"}, {"score": 0.0033044432971036652, "phrase": "runtime_system"}, {"score": 0.0032467792804296036, "phrase": "high-level_programming_model"}, {"score": 0.003224015885726169, "phrase": "openmp"}, {"score": 0.0031455000569352454, "phrase": "key_feature"}, {"score": 0.0030689098754563982, "phrase": "existing_approaches"}, {"score": 0.002941913249957503, "phrase": "openmp_translation_layer"}, {"score": 0.0028601736602156033, "phrase": "low-level_apis"}, {"score": 0.002810240488642749, "phrase": "inter-process_communications"}, {"score": 0.002600661525224505, "phrase": "embedded_systems"}, {"score": 0.0025194861926779223, "phrase": "mca_layer"}, {"score": 0.002381365139274329, "phrase": "single_openmp_code_base"}, {"score": 0.002242879896352752, "phrase": "different_possible_types"}, {"score": 0.002134888329742086, "phrase": "promising_and_competitive_performance"}, {"score": 0.0021049977753042253, "phrase": "native_approach"}], "paper_keywords": ["Languages", " Performance", " Standardization", " OpenMP", " MCA", " Runtime optimizations", " Embedded systems"], "paper_abstract": "Multicore embedded systems are being widely used in telecommunication systems, robotics, medical applications and more. While they offer a high-performance with low-power solution, programming in an efficient way is still a challenge. In order to exploit the capabilities that the hardware offers, software developers are expected to handle many of the low-level details of programming including utilizing DMA, ensuring cache coherency, and inserting synchronization primitives explicitly. The state-of-the-art involves solutions where the software toolchain is too vendor-specific thus tying the software to a particular hardware leaving no room for portability. In this paper we present a runtime system to explore mapping a high-level programming model, OpenMP, on to multicore embedded systems. A key feature of our scheme is that unlike the existing approaches that largely rely on POSIX threads, our approach leverages the Multicore Association (MCA) APIs as an OpenMP translation layer. The MCA APIs is a set of low-level APIs handling resource management, inter-process communications and task scheduling for multicore embedded systems. By deploying the MCA APIs, our runtime is able to effectively capture the characteristics of multicore embedded systems compared with the POSIX threads. Furthermore, the MCA layer enables our runtime implementation to be portable across various architectures. Thus programmers only need to maintain a single OpenMP code base which is compatible by various compilers, while on the other hand, the code is portable across different possible types of platforms. We have evaluated our runtime system using several embedded benchmarks. The experiments demonstrate promising and competitive performance compared to the native approach for the platform.", "paper_title": "Portable Mapping of OpenMP to Multicore Embedded Systems Using MCA APIs", "paper_id": "WOS:000321865100017"}