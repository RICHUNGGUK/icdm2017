{"auto_keywords": [{"score": 0.03947447987613366, "phrase": "finitely-ground_programs"}, {"score": 0.015719716506582538, "phrase": "function_symbols"}, {"score": 0.0083306856677198, "phrase": "dfrp_programs"}, {"score": 0.0047804843375940835, "phrase": "logic_programming"}, {"score": 0.0047292449487169345, "phrase": "set_semantics"}, {"score": 0.004628400269774981, "phrase": "modeling_limitations"}, {"score": 0.00446506039438222, "phrase": "infinite_domains"}, {"score": 0.0043230124508350865, "phrase": "asp"}, {"score": 0.004230749292148046, "phrase": "general_case"}, {"score": 0.004155399041702324, "phrase": "research_community"}, {"score": 0.004066740842661956, "phrase": "proper_subclasses"}, {"score": 0.0037845987749316632, "phrase": "finitary_programs"}, {"score": 0.003459191419478298, "phrase": "top-down_evaluation_strategy"}, {"score": 0.00333697550984782, "phrase": "answer_sets"}, {"score": 0.00326572165784246, "phrase": "bottom-up_evaluation_strategy"}, {"score": 0.0031959843979467704, "phrase": "main_advantages"}, {"score": 0.0030499378654797143, "phrase": "current_asp_systems"}, {"score": 0.0029740732099993706, "phrase": "bottom-up_computational_model"}, {"score": 0.002889672003089062, "phrase": "interesting_programs"}, {"score": 0.0028381384547894865, "phrase": "top-down_query_evaluation"}, {"score": 0.0025660347613972573, "phrase": "magic_sets"}, {"score": 0.0025021765811679446, "phrase": "query_equivalence"}, {"score": 0.00247529638625566, "phrase": "brave_and_cautious_reasoning"}, {"score": 0.0024050158199950024, "phrase": "input_program"}, {"score": 0.002387758958649797, "phrase": "dfrp"}, {"score": 0.0023116191163488824, "phrase": "finitely_ground"}, {"score": 0.002197966048531954, "phrase": "also_an_effective_method"}, {"score": 0.0021049977753042253, "phrase": "asp_system"}], "paper_keywords": ["Answer set programming", " function symbols", " magic sets", " knowledge representation"], "paper_abstract": "The support for function symbols in logic programming under answer set semantics allows us to overcome some modeling limitations of traditional Answer Set Programming (ASP) systems, such as the inability of handling infinite domains. On the other hand, admitting function symbols in ASP makes inference undecidable in the general case. Recently, the research community has been focusing on finding proper subclasses of programs with functions for which decidability of inference is guaranteed. The two major proposals, so far, are finitary programs and finitely-ground programs. These two proposals are somehow complementary: indeed, the former is conceived to allow decidable querying (by means of a top-down evaluation strategy), while the latter supports the computability of answer sets (by means of a bottom-up evaluation strategy). One of the main advantages of finitely-ground programs is that they can be \"directly\" evaluated by current ASP systems, which are based on a bottom-up computational model. However, there are also some interesting programs which are suitable for top-down query evaluation; but they do not fall in the class of finitely-ground programs. In this paper, we focus on disjunctive finitely recursive positive (DFRP) programs. We design a version of the magic sets technique for DFRP programs, which ensures query equivalence under both brave and cautious reasoning. We show that, if the input program is DFRP, then its magic-sets rewriting is guaranteed to be finitely ground. Reasoning on DFRP programs turns out to be decidable; and we provide also an effective method that allows one to simply perform this reasoning by using the ASP system DLV.", "paper_title": "Finitely recursive programs: Decidability and bottom-up computation", "paper_id": "WOS:000298375800002"}