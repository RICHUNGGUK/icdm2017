{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "prolog"}, {"score": 0.013432610823449136, "phrase": "dl_axioms"}, {"score": 0.013113894513289561, "phrase": "prolog_program"}, {"score": 0.00889824093421089, "phrase": "base_transformation"}, {"score": 0.00759607655570533, "phrase": "dlog"}, {"score": 0.004737829884207618, "phrase": "traditional_algorithms"}, {"score": 0.004712397190881752, "phrase": "description_logic"}, {"score": 0.004599621236228673, "phrase": "large_amounts"}, {"score": 0.004574927037264451, "phrase": "underlying_data"}, {"score": 0.004538195324804831, "phrase": "dl"}, {"score": 0.004393879198242113, "phrase": "semantic_web_and_information_integration"}, {"score": 0.004231343677223056, "phrase": "large_data_sets"}, {"score": 0.004052907939298019, "phrase": "shiq_dl_language"}, {"score": 0.003977217946137447, "phrase": "unique_name_assumption"}, {"score": 0.003871525389474755, "phrase": "particular_individuals"}, {"score": 0.00378898953201521, "phrase": "normal_prolog_execution"}, {"score": 0.003758492534305375, "phrase": "generated_program"}, {"score": 0.003678357491240075, "phrase": "top-down_prolog_execution"}, {"score": 0.003338305188748132, "phrase": "better_scalability"}, {"score": 0.0032936225456909676, "phrase": "dl_ontologies"}, {"score": 0.0032495360221984045, "phrase": "existing_information_sources"}, {"score": 0.003223366954327026, "phrase": "transformation_process"}, {"score": 0.003112373698668253, "phrase": "first-order_clauses"}, {"score": 0.003087305801054765, "phrase": "restricted_form"}, {"score": 0.0028860835366779033, "phrase": "present_paper"}, {"score": 0.0027567761303683683, "phrase": "shiq_knowledge_base"}, {"score": 0.002626154851822891, "phrase": "simple_interpreter"}, {"score": 0.002590979439059358, "phrase": "executable_prolog_code"}, {"score": 0.0023703197993221407, "phrase": "dl_reasoner_implementors"}, {"score": 0.002325979556988998, "phrase": "ail_overview"}, {"score": 0.0021393542556570706, "phrase": "widely_used_dl_reasoners"}, {"score": 0.0021163883202110034, "phrase": "racerpro"}, {"score": 0.0021050027911012482, "phrase": "pellet"}], "paper_keywords": ["description logic", " logic programming", " resolution", " large data sets", " open world"], "paper_abstract": "Traditional algorithms for description logic (DL) instance retrieval are inefficient for large amounts of underlying data. As DL is becoming more and more Popular in areas Such as the Semantic Web and information integration, it is very important to have systems which can reason efficiently over large data sets. In this paper we present all approach to transform DL axioms, formalised in the SHIQ DL language, into a Prolog program under the unique name assumption. This transformation is performed with no knowledge about particular individuals: they are accessed dynamically during the normal Prolog execution of the generated program. This technique, together with the top-down Prolog execution, implies that only those pieces of data are accessed that are indeed important for answering the query. This makes it possible to store the individuals in a database instead of memory, which results in better scalability and helps in using DL ontologies directly on top of existing information sources. The transformation process consists of two steps: (1) the DL axioms are converted to first-order clauses of a restricted form, and (2) a Prolog program is generated from these clauses. Step (2), which is the focus of the present paper, actually works on more general clauses than those obtainable by applying step (1) to a SHIQ knowledge base. We first present a base transformation, the Output of which can be either executed Using a simple interpreter or further extended to executable Prolog code. We then discuss several optimisation techniques, applicable to the output of the base transformation. Some of these techniques are specific to our approach, while others are general enough to be interesting for DL reasoner implementors not using Prolog. We give ail overview of DLog, a DL reasoner in Prolog, which is an implementation of the techniques outlined above. We evaluate the performance of DLog and compare it to some widely used DL reasoners, such as RacerPro, Pellet and KAON2.", "paper_title": "Efficient description logic reasoning in Prolog: The DLog system", "paper_id": "WOS:000268508600003"}