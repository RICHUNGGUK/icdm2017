{"auto_keywords": [{"score": 0.037828081657135235, "phrase": "semi-nice_tree-decomposition"}, {"score": 0.011272635229829136, "phrase": "dynamic_programming"}, {"score": 0.004667698705233127, "phrase": "branchwidth"}, {"score": 0.004610126239307353, "phrase": "treewidth"}, {"score": 0.003802135020791801, "phrase": "simple_algorithms"}, {"score": 0.003234425353582135, "phrase": "vertex_subsets"}, {"score": 0.0031549249117721946, "phrase": "optimization_problems"}, {"score": 0.0031159081999910694, "phrase": "edge_subsets"}, {"score": 0.0030017207229983385, "phrase": "resulting_runtime"}, {"score": 0.0025691622090542304, "phrase": "n_vertices"}, {"score": 0.002444333100610621, "phrase": "width_pw"}, {"score": 0.0021049977753042253, "phrase": "single_dynamic_programming_algorithm"}], "paper_keywords": [""], "paper_abstract": "In this paper we introduce semi-nice tree-decompositions and show that they combine the best of both branchwidth and treewidth. We first give simple algorithms to transform a given tree-decomposition or branch-decomposition into a semi-nice tree-decomposition. We then give two templates for dynamic programming along a semi-nice tree-decomposition, one for optimization problems over vertex subsets and another for optimization problems over edge subsets. We show that the resulting runtime will match or beat the runtimes achieved by doing dynamic programming directly on either a branch- or tree-decomposition. For example, given a graph G on n vertices with path-, tree- and branch-decompositions of width pw, tw and bw respectively, the Minimum Dominating Set problem on G is solved in time O(n2(min{1.58 pw,2 tw,2.38 bw})) by a single dynamic programming algorithm along a semi-nice tree-decomposition.", "paper_title": "Two birds with one stone: The best of Branchwidth and Treewidth with one algorithm", "paper_id": "WOS:000236886100037"}