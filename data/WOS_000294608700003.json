{"auto_keywords": [{"score": 0.04810417603515557, "phrase": "task_level"}, {"score": 0.00481495049065317, "phrase": "task-level_analysis"}, {"score": 0.004472935829694716, "phrase": "maximum_number"}, {"score": 0.004025885154716127, "phrase": "input_data"}, {"score": 0.00398370478688858, "phrase": "static_knowledge"}, {"score": 0.0038597866217852353, "phrase": "utmost_importance"}, {"score": 0.003819339842998955, "phrase": "understanding_and_debugging_parallel_programs"}, {"score": 0.003720060615588018, "phrase": "guiding_task_schedulers"}, {"score": 0.003492155652400838, "phrase": "first_static_analysis"}, {"score": 0.003437387719239532, "phrase": "safe_and_precise_approximations"}, {"score": 0.0032954888655173666, "phrase": "async-finish_parallelism"}, {"score": 0.0032437952431945724, "phrase": "parallel_languages"}, {"score": 0.0031428202743657057, "phrase": "basic_constructs"}, {"score": 0.002219040041886641, "phrase": "total_number"}, {"score": 0.0021049977753042253, "phrase": "accurate_estimation"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Verification", " Parallelism", " Static Analysis", " Resource Consumption", " X10", " Java"], "paper_abstract": "The task level of a program is the maximum number of tasks that can be available (i.e., not finished nor suspended) simultaneously during its execution for any input data. Static knowledge of the task level is of utmost importance for understanding and debugging parallel programs as well as for guiding task schedulers. We present, to the best of our knowledge, the first static analysis which infers safe and precise approximations on the task level for a language with async-finish parallelism. In parallel languages, async and finish are basic constructs for, respectively, spawning tasks and waiting until they terminate. They are the core of modern, parallel, distributed languages like X10. Given a (parallel) program, our analysis returns a task-level upper bound, i.e., a function on the program's input arguments that guarantees that the task level of the program will never exceed its value along any execution. Our analysis provides a series of useful (over) approximations, going from the total number of tasks spawned in the execution up to an accurate estimation of the task level.", "paper_title": "Task-Level Analysis for a Language with async/finish Parallelism", "paper_id": "WOS:000294608700003"}