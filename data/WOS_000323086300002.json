{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "attribute_grammars"}, {"score": 0.03152938003499141, "phrase": "kiama"}, {"score": 0.004688321299229397, "phrase": "powerful_specification_paradigm"}, {"score": 0.00458940888106061, "phrase": "particularly_semantic_analysis"}, {"score": 0.004540734419151103, "phrase": "programming_languages"}, {"score": 0.004492573860101133, "phrase": "recent_attribute_grammar_systems"}, {"score": 0.004444921827311577, "phrase": "dynamic_scheduling_algorithms"}, {"score": 0.0038900709793274484, "phrase": "dynamic_approach"}, {"score": 0.003571751184289622, "phrase": "kiama's_attribute_grammar_library"}, {"score": 0.0034777028461723198, "phrase": "advanced_features"}, {"score": 0.0033680968918579717, "phrase": "higher_order"}, {"score": 0.003159106878239524, "phrase": "higher_order_attributes"}, {"score": 0.003010893527930816, "phrase": "attribute_value_propagation"}, {"score": 0.002931569771634119, "phrase": "new_techniques"}, {"score": 0.002900426826591769, "phrase": "dynamic_extension"}, {"score": 0.0028391271282216758, "phrase": "attribute_equations"}, {"score": 0.0027643161113894018, "phrase": "scala_programming_language"}, {"score": 0.0026914710445743693, "phrase": "domain-specific_notations"}, {"score": 0.00256514094268541, "phrase": "specialised_notation"}, {"score": 0.0024842242921857705, "phrase": "standard_scala_notations"}, {"score": 0.0024447258861321685, "phrase": "pattern-matching_functions"}, {"score": 0.002317533977770783, "phrase": "implicit_parameters"}, {"score": 0.002256435842862802, "phrase": "benchmarking_exercise"}, {"score": 0.0021735890994119757, "phrase": "realistic_language_processing"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Language processing", " Compilers", " Domain-specific languages"], "paper_abstract": "Attribute grammars are a powerful specification paradigm for many language processing tasks, particularly semantic analysis of programming languages. Recent attribute grammar systems use dynamic scheduling algorithms to evaluate attributes on demand. In this paper, we show how to remove the need for a generator, by embedding a dynamic approach in a modern, object-oriented and functional programming language. The result is a small, lightweight attribute grammar library that is part of our larger Kiama language processing library. Kiama's attribute grammar library supports a range of advanced features including cached, uncached, higher order, parameterised and circular attributes. Forwarding is available to modularise higher order attributes and decorators abstract away from the details of attribute value propagation. Kiama also implements new techniques for dynamic extension and variation of attribute equations. We use the Scala programming language because of its support for domain-specific notations and emphasis on scalability. Unlike generators with specialised notation, Kiama attribute grammars use standard Scala notations such as pattern-matching functions for equations, traits and mixins for composition and implicit parameters for forwarding. A benchmarking exercise shows that our approach is practical for realistic language processing. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "A pure embedding of attribute grammars", "paper_id": "WOS:000323086300002"}