{"auto_keywords": [{"score": 0.05007852962010534, "phrase": "tail_latency"}, {"score": 0.008651636822276716, "phrase": "interactive_services"}, {"score": 0.0057707583807024955, "phrase": "interval_table"}, {"score": 0.004909895021007566, "phrase": "lucene"}, {"score": 0.00467855218490191, "phrase": "web_search"}, {"score": 0.004066740842661956, "phrase": "individual_requests"}, {"score": 0.00374399358035391, "phrase": "hardware_resources"}, {"score": 0.003637822529522622, "phrase": "numerous_short_requests"}, {"score": 0.003361069456060196, "phrase": "request_service_demand_profiles"}, {"score": 0.0032893028281789287, "phrase": "offline_phase"}, {"score": 0.002900090135006575, "phrase": "dynamic_system_load"}, {"score": 0.0028792911886505526, "phrase": "request_execution_time_progress"}, {"score": 0.002396374747067876, "phrase": "bing"}, {"score": 0.0021278653331014592, "phrase": "incremental_parallelism"}, {"score": 0.0021049977753042253, "phrase": "powerful_tool"}], "paper_keywords": ["Dynamic Parallelism", " Interactive Services", " Multithreading", " Tail Latency", " Thread Scheduling", " Web Search"], "paper_abstract": "Interactive services, such as Web search, recommendations, games, and finance, must respond quickly to satisfy customers. Achieving this goal requires optimizing tail (e.g., 99th+ percentile) latency. Although every server is multi-core, parallelizing individual requests to reduce tail latency is challenging because (1) service demand is unknown when requests arrive; (2) blindly parallelizing all requests quickly oversubscribes hardware resources; and (3) parallelizing the numerous short requests will not improve tail latency. This paper introduces Few-to-Many (FM) incremental parallelization, which dynamically increases parallelism to reduce tail latency. FM uses request service demand profiles and hardware parallelism in an offline phase to compute a policy, represented as an interval table, which specifies when and how much software parallelism to add. At runtime, FM adds parallelism as specified by the interval table indexed by dynamic system load and request execution time progress. The longer a request executes, the more parallelism FM adds. We evaluate FM in Lucene, an open-source enterprise search engine, and in Bing, a commercial Web search engine. FM improves the 99th percentile response time up to 32% in Lucene and up to 26% in Bing, compared to prior state-of-the-art parallelization. Compared to running requests sequentially in Bing, FM improves tail latency by a factor of two. These results illustrate that incremental parallelism is a powerful tool for reducing tail latency.", "paper_title": "Few-to-Many: Incremental Parallelism for Reducing Tail Latency in Interactive Services", "paper_id": "WOS:000370874900012"}