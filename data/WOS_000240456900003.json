{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "garbage_collection"}, {"score": 0.015547084727554788, "phrase": "heap_growth"}, {"score": 0.015040308686576824, "phrase": "java_applications"}, {"score": 0.00465634671242413, "phrase": "execution_time"}, {"score": 0.0038725824361608243, "phrase": "unnecessary_overheads"}, {"score": 0.003311604528903634, "phrase": "large_amount"}, {"score": 0.0032747835779400212, "phrase": "virtual_memory"}, {"score": 0.003166751241099304, "phrase": "large_footprint"}, {"score": 0.0030794433253250476, "phrase": "increased_execution_times"}, {"score": 0.0028795712616923462, "phrase": "large_set"}, {"score": 0.002574788013427524, "phrase": "application's_execution_time"}, {"score": 0.002263861731320045, "phrase": "conservative_garbage_collector"}, {"score": 0.0022013916728990564, "phrase": "application_execution_times"}, {"score": 0.0021406417439887907, "phrase": "new_strategies"}, {"score": 0.0021049977753042253, "phrase": "garbage_collection_and_heap_growth_that_impact_not_only_the_frequency_with_which_garbage_collection_occurs_but_also_the_points"}], "paper_keywords": ["garbage collection", " heap growth", " implementation", " Java", " memory", " management", " performance measurement", " programming languages"], "paper_abstract": "In systems that support garbage collection, a tension exists between collecting garbage too frequently and not collecting it frequently enough. Garbage collection that occurs too frequently may introduce unnecessary overheads at the risk of not collecting much garbage during each cycle. On the other hand, collecting garbage too infrequently can result in applications that execute with a large amount of virtual memory (i.e., with a large footprint) and suffer from increased execution times due to paging. In this article, we use a large set of Java applications and the highly tuned and widely used Boehm-Demers-Weiser (BDW) conservative mark-and-sweep garbage collector to experimentally examine the extent to which the frequency of garbage collection impacts an application's execution time, footprint, and pause times. We use these results to devise some guidelines for controlling garbage collection and heap growth in a conservative garbage collector in order to minimize application execution times. Then we describe new strategies for controlling garbage collection and heap growth that impact not only the frequency with which garbage collection occurs but also the points at which it occurs. Experimental results demonstrate that when compared with the existing", "paper_title": "Controlling garbage collection and heap growth to reduce the execution time of Java applications", "paper_id": "WOS:000240456900003"}