{"auto_keywords": [{"score": 0.02321620888525547, "phrase": "sgi_altix"}, {"score": 0.00481495049065317, "phrase": "task_scheduling_strategies"}, {"score": 0.004779406424192843, "phrase": "multicore_numa_systems"}, {"score": 0.004726579360618152, "phrase": "recent_addition"}, {"score": 0.004691684576246597, "phrase": "task_parallelism"}, {"score": 0.004639881171471413, "phrase": "openmp"}, {"score": 0.004605565335682916, "phrase": "memory_api"}, {"score": 0.004471035765089235, "phrase": "high_level"}, {"score": 0.004324361008753555, "phrase": "parallel_execution"}, {"score": 0.004276541976450121, "phrase": "openmp_run-time_system"}, {"score": 0.004167001961564886, "phrase": "modern_multi-socket"}, {"score": 0.004120915812750583, "phrase": "memory_systems"}, {"score": 0.0040904740665330805, "phrase": "careful_consideration"}, {"score": 0.004045230861702083, "phrase": "increasingly_complex_memory_hierarchy"}, {"score": 0.0038263829059336564, "phrase": "open_source"}, {"score": 0.0038122196479548425, "phrase": "qthreads_threading_library"}, {"score": 0.0037700424606538856, "phrase": "different_scheduler_designs"}, {"score": 0.0037283301619292636, "phrase": "openmp_programs"}, {"score": 0.0036870776660851007, "phrase": "rose_compiler"}, {"score": 0.0036327808996444904, "phrase": "diverse_openmp_task-parallel_benchmarks"}, {"score": 0.0036059320136308808, "phrase": "seven_different_task-parallel_run-time_scheduler_implementations"}, {"score": 0.003566028957296066, "phrase": "intel_nehalem"}, {"score": 0.003436169600453596, "phrase": "per-core_work-stealing_scheduler"}, {"score": 0.003348086122594862, "phrase": "lifo"}, {"score": 0.0033233521151462032, "phrase": "fifo"}, {"score": 0.0032743731084995515, "phrase": "qthreads_round-robin_scheduler"}, {"score": 0.0031551009669284545, "phrase": "intel_and_gnu_openmp_implementations"}, {"score": 0.0031086137705026483, "phrase": "different_scheduling_methods"}, {"score": 0.0030856268625708695, "phrase": "different_levels"}, {"score": 0.0028648759706752162, "phrase": "single_chip"}, {"score": 0.002740059168271987, "phrase": "costly_remote_steals"}, {"score": 0.002650018880406324, "phrase": "shared_lifo_queue"}, {"score": 0.0026109540617641593, "phrase": "cache_locality"}, {"score": 0.0025916375737852506, "phrase": "sibling_tasks"}, {"score": 0.002534539169474629, "phrase": "parent_task"}, {"score": 0.0024786956187352327, "phrase": "performance_evaluation"}, {"score": 0.002353120949568249, "phrase": "seven_benchmarks"}, {"score": 0.002301265368019983, "phrase": "absolute_performance"}, {"score": 0.0022091400304857043, "phrase": "similar_performance_benefits"}, {"score": 0.0021927897271015657, "phrase": "amd_magny_cours"}], "paper_keywords": ["Task parallelism", " run-time systems", " work stealing", " scheduling", " multicore", " OpenMP"], "paper_abstract": "The recent addition of task parallelism to the OpenMP shared memory API allows programmers to express concurrency at a high level of abstraction and places the burden of scheduling parallel execution on the OpenMP run-time system. Efficient scheduling of tasks on modern multi-socket multicore shared memory systems requires careful consideration of an increasingly complex memory hierarchy, including shared caches and non-uniform memory access (NUMA) characteristics. In order to evaluate scheduling strategies, we extended the open source Qthreads threading library to implement different scheduler designs, accepting OpenMP programs through the ROSE compiler. Our comprehensive performance study of diverse OpenMP task-parallel benchmarks compares seven different task-parallel run-time scheduler implementations on an Intel Nehalem multi-socket multicore system: our proposed hierarchical work-stealing scheduler, a per-core work-stealing scheduler, a centralized scheduler, and LIFO and FIFO versions of the Qthreads round-robin scheduler. In addition, we compare our results against the Intel and GNU OpenMP implementations. Our hierarchical scheduling strategy leverages different scheduling methods at different levels of the hierarchy. By allowing one thread to steal work on behalf of all of the threads within a single chip that share a cache, the scheduler limits the number of costly remote steals. For cores on the same chip, a shared LIFO queue allows exploitation of cache locality between sibling tasks as well as between a parent task and its newly created child tasks. In the performance evaluation, our Qthreads hierarchical scheduler is competitive on all benchmarks tested. On five of the seven benchmarks, it demonstrates speedup and absolute performance superior to both the Intel and GNU OpenMP run-time systems. Our run-time also demonstrates similar performance benefits on AMD Magny Cours and SGI Altix systems, enabling several benchmarks to successfully scale to 192 CPUs of an SGI Altix.", "paper_title": "OpenMP task scheduling strategies for multicore NUMA systems", "paper_id": "WOS:000304698700003"}