{"auto_keywords": [{"score": 0.04543044910850528, "phrase": "memory_bandwidth"}, {"score": 0.00481495049065317, "phrase": "bandwidth-efficient_sdram_address_generators"}, {"score": 0.004703149944841539, "phrase": "commodity_technology"}, {"score": 0.0044002186469797476, "phrase": "sdram_memory"}, {"score": 0.004100620365805411, "phrase": "hard_real-time_performance_requirements"}, {"score": 0.003974071684351861, "phrase": "compile_time"}, {"score": 0.0038363485899400285, "phrase": "hard_real-time_deadlines"}, {"score": 0.003732526540522333, "phrase": "sdram_memories"}, {"score": 0.0035750047462243836, "phrase": "conservative_implementations"}, {"score": 0.003547084456662448, "phrase": "on-chip_memory_buffers"}, {"score": 0.0035056109035307716, "phrase": "possible_data_reuse"}, {"score": 0.0033708244679086265, "phrase": "sdram_interface"}, {"score": 0.0032539388572032563, "phrase": "automated_procedure"}, {"score": 0.0032158817866929563, "phrase": "application-specific_address_generators"}, {"score": 0.0031534367609709264, "phrase": "on-chip_memory"}, {"score": 0.0030800962618484844, "phrase": "external_memory_interface"}, {"score": 0.002915514089373717, "phrase": "representative_benchmarks"}, {"score": 0.002847691227421257, "phrase": "parameterized_designs"}, {"score": 0.0027167292419065514, "phrase": "external_memory"}, {"score": 0.0025614418906438744, "phrase": "memory_access_time"}, {"score": 0.002472552537325606, "phrase": "synthesis_procedure_results"}, {"score": 0.002453221048083196, "phrase": "monotonic_memory"}, {"score": 0.00238674051726235, "phrase": "tight_worst-case_execution"}, {"score": 0.0023038997972591193, "phrase": "system_analysis"}, {"score": 0.002232675154416128, "phrase": "performance_guarantees"}, {"score": 0.0021721582450016, "phrase": "absolute_worst-case"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["SDRAM memory", " Analytical design technique", " FPGA", " Worst case execution time"], "paper_abstract": "SDRAM memories are a commodity technology which deliver fast, cheap and high capacity external memory in many cost-sensitive embedded applications. When designing with SDRAM memory, the memory bandwidth available is strongly dependent on the sequence of addresses requested. For applications with hard real-time performance requirements, it is prudent to perform at compile time, some form of analysis to guarantee those hard real-time deadlines are met. In general with SDRAM memories, this analysis is difficult, and this leads to conservative implementations. On-chip memory buffers can make possible data reuse and request reordering which together ensure bandwidth on an SDRAM interface is used efficiently. This paper outlines an automated procedure for synthesizing application-specific address generators which exploit data-reuse in on-chip memory and transaction reordering on an external memory interface. We quantify the impact this has on memory bandwidth over a range of representative benchmarks. Across a range of parameterized designs, we observe up to 50x reduction in the quantity of data fetched from external memory. This, combined with reordering of the transactions, allows up to 128x reduction in the memory access time of certain memory-intensive benchmarks implemented in an FPGA. Since the synthesis procedure results in monotonic memory addressing functions, we can extract tight worst-case execution (WCET) bounds that are useful in system analysis. We show that we can extract performance guarantees which are significantly tighter than the absolute worst-case SDRAM performance. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Analytical synthesis of bandwidth-efficient SDRAM address generators", "paper_id": "WOS:000311654100007"}