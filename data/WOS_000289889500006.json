{"auto_keywords": [{"score": 0.04812537342841172, "phrase": "dynamic_type"}, {"score": 0.04032641138077569, "phrase": "static_typing"}, {"score": 0.034618800592204124, "phrase": "single_inheritance"}, {"score": 0.03432564602532818, "phrase": "multiple_subtyping"}, {"score": 0.03403488639313882, "phrase": "multiple_inheritance"}, {"score": 0.03289543711618733, "phrase": "global_compilation"}, {"score": 0.03206512174694877, "phrase": "whole_program"}, {"score": 0.0313887041743059, "phrase": "dynamic_loading"}, {"score": 0.027908411215593443, "phrase": "separate_compilation"}, {"score": 0.00481495049065317, "phrase": "statically_typed_object-oriented_programming_languages"}, {"score": 0.004731273170913247, "phrase": "original_implementation_issue"}, {"score": 0.004659243692466103, "phrase": "program_behavior"}, {"score": 0.004528358128300352, "phrase": "late_binding_mechanism"}, {"score": 0.0044594040116588355, "phrase": "underlying_principle"}, {"score": 0.004391495239703706, "phrase": "actually_called_procedure"}, {"score": 0.004249423746938383, "phrase": "distinguished_parameter"}, {"score": 0.004184699158981139, "phrase": "similar_issue"}, {"score": 0.004102922352636175, "phrase": "object_layout"}, {"score": 0.004049290621332043, "phrase": "object's_dynamic_type"}, {"score": 0.003987602129769316, "phrase": "original_feature"}, {"score": 0.003884020437483909, "phrase": "specific_implementations"}, {"score": 0.0038670192985614574, "phrase": "data_structures"}, {"score": 0.0038248400678308164, "phrase": "late_binding"}, {"score": 0.0037831191567360913, "phrase": "so-called_virtual_function_tables"}, {"score": 0.003676754409052219, "phrase": "small_fixed_number"}, {"score": 0.003660657181175391, "phrase": "extra_indirections"}, {"score": 0.0036207206487324506, "phrase": "object-oriented_programming_yields"}, {"score": 0.0035577232319940802, "phrase": "usual_procedural_languages"}, {"score": 0.003367810786715825, "phrase": "even_a_mixing"}, {"score": 0.003323939462271468, "phrase": "java"}, {"score": 0.0032020289757058416, "phrase": "well-known_complication"}, {"score": 0.0031532071369076626, "phrase": "executable_programs"}, {"score": 0.0030779820790357193, "phrase": "closed-world_assumption"}, {"score": 0.003064500101699398, "phrase": "cwa"}, {"score": 0.003004546232322994, "phrase": "compile_time"}, {"score": 0.0029393033788624985, "phrase": "program_unit"}, {"score": 0.0028565950081363665, "phrase": "open-world_assumption"}, {"score": 0.0026452734009203764, "phrase": "language-independent_survey"}, {"score": 0.0024875003567559695, "phrase": "global_compilation_framework"}, {"score": 0.0024657410567099102, "phrase": "dynamically_typed_languages"}, {"score": 0.0024281181691350085, "phrase": "eiffel_language"}, {"score": 0.002391067964886602, "phrase": "global_techniques"}, {"score": 0.002359759876402679, "phrase": "implementation_efficiency"}, {"score": 0.0023288607717731067, "phrase": "open_and_closed_world_assumptions"}, {"score": 0.0022484224116448787, "phrase": "provisional_cwa"}, {"score": 0.002218977936429331, "phrase": "possible_recompilations"}, {"score": 0.0021803162647889463, "phrase": "experimental_compiler-linker"}, {"score": 0.00215176400112417, "phrase": "owa"}, {"score": 0.0021049980887993046, "phrase": "cwa."}], "paper_keywords": ["Languages", " Measurement", " Performance", " Binary tree dispatch", " casting", " coloring", " downcast", " dynamic loading", " genericity", " late binding", " linking", " message sending", " method dispatch", " multiple inheritance", " pointer adjustment", " single inheritance", " static typing", " type analysis", " separate compilation", " virtual function tables", " C plus", " C#", " Eiffel", " Java", " PRM", " Theta"], "paper_abstract": "Object-oriented programming represents an original implementation issue due to its philosophy of making the program behavior depend on the dynamic type of objects. This is expressed by the late binding mechanism, aka message sending. The underlying principle is that the address of the actually called procedure is not statically determined at compile-time, but depends on the dynamic type of a distinguished parameter known as the receiver. A similar issue arises with attributes, because their position in the object layout may also depend on the object's dynamic type. Furthermore, subtyping introduces another original feature (i.e., runtime subtype checks). All three mechanisms need specific implementations and data structures. In static typing, late binding is generally implemented with so-called virtual function tables. These tables reduce method calls to pointers to functions via a small fixed number of extra indirections. It follows that object-oriented programming yields some overhead, as compared to the usual procedural languages. The different techniques and their resulting overhead depend on several parameters. First, inheritance and subtyping may be single or multiple, and even a mixing is possible, as in JAVA and. NET which present single inheritance for classes and multiple subtyping for interfaces. Multiple inheritance is a well-known complication. Second, the production of executable programs may involve various schemes, from global compilation, which implies the closed-world assumption (CWA), as the whole program is known at compile time, to separate compilation and dynamic loading, where each program unit is compiled and loaded independently of any usage, hence under the open-world assumption (OWA). Global compilation is well-known to facilitate optimization. This article reviews the various implementation techniques available in static typing and in the three cases of single inheritance, multiple inheritance, and multiple subtyping. This language-independent survey focuses on separate compilation and dynamic loading, as they represent the most commonly used and the most demanding framework. However, many works have been undertaken in the global compilation framework, mostly for dynamically typed languages, but also applied to the EIFFEL language. Hence, we also examine global techniques and how they can improve implementation efficiency. Finally, mixed frameworks that combine open and closed world assumptions are considered. For instance, just-in-time (JIT) compilers work under provisional CWA, at the expense of possible recompilations. In contrast, we present an experimental compiler-linker, where separate compilation implies the OWA, whereas the whole program is finally linked under the CWA.", "paper_title": "Implementing Statically Typed Object-Oriented Programming Languages", "paper_id": "WOS:000289889500006"}