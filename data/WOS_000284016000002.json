{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "fast_and_reentrant_operating_system_kernel_tracing"}, {"score": 0.004655285779819366, "phrase": "operating_system"}, {"score": 0.004577440795549049, "phrase": "performance_monitoring"}, {"score": 0.0045262653692203815, "phrase": "debugging_infrastructure"}, {"score": 0.003910595307634916, "phrase": "kernel_infrastructure"}, {"score": 0.003823584649521733, "phrase": "kernel_tracer"}, {"score": 0.003738502710504415, "phrase": "infinite_recursion"}, {"score": 0.003474799999519295, "phrase": "execution_contexts"}, {"score": 0.0033594249301033604, "phrase": "tracing_code"}, {"score": 0.003303177222901723, "phrase": "existing_kernel_infrastructure"}, {"score": 0.003070086433952691, "phrase": "existing_operating_system_kernel"}, {"score": 0.0029681091946289757, "phrase": "new_low_overhead_tracing_mechanism"}, {"score": 0.0028695095228791724, "phrase": "synchronization_sequences"}, {"score": 0.002805597755796506, "phrase": "system_kernel_tracing"}, {"score": 0.0023827927890399357, "phrase": "wait-free_algorithm"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["tracing", " operating system", " synchronization", " wait-free algorithms", " low overhead", " clock"], "paper_abstract": "To effectively trace an operating system, a performance monitoring and debugging infrastructure needs the ability to trace various execution contexts. These contexts range from kernel running as a thread to Non-Maskable Interrupt (NMI) contexts. Given that any part of the kernel infrastructure used by a kernel tracer could lead to infinite recursion if traced, and because most kernel primitives require synchronization unsuitable for some execution contexts, all interactions of the tracing code with the existing kernel infrastructure must be considered in order to correctly inter-operate with the existing operating system kernel. This paper presents a new low overhead tracing mechanism and motivates the choice of synchronization sequences suitable for operating system kernel tracing, namely local atomic instructions as main buffer synchronization primitive and the Read-Copy Update (RCU) mechanism to control tracing. It also proposes a wait-free algorithm extending the time-base needed by the tracer to 64-bit on architectures that lack hardware 64-bit time-base support. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "Synchronization for fast and reentrant operating system kernel tracing", "paper_id": "WOS:000284016000002"}