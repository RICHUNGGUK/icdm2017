{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "performance_modeling"}, {"score": 0.0046739596755881185, "phrase": "emerging_challenges"}, {"score": 0.004591345494188032, "phrase": "hpc_systems"}, {"score": 0.004378078970574258, "phrase": "exascale_applications"}, {"score": 0.0041995784967999985, "phrase": "performance_consequences"}, {"score": 0.004149922666541166, "phrase": "different_hardware_designs"}, {"score": 0.004100851549096203, "phrase": "analytic_models"}, {"score": 0.003933609372601274, "phrase": "fast_feedback"}, {"score": 0.0038640303886081444, "phrase": "co-design_centers"}, {"score": 0.0037507793596022326, "phrase": "costly_simulations"}, {"score": 0.0036625643243684827, "phrase": "current_attempts"}, {"score": 0.003619235073669304, "phrase": "analytically_model_program_performance"}, {"score": 0.0034304883989739804, "phrase": "performance_model"}, {"score": 0.003329901594166227, "phrase": "exasat_framework"}, {"score": 0.0032130703855586685, "phrase": "parameterized_performance_models"}, {"score": 0.0031561961485589663, "phrase": "source_code"}, {"score": 0.003118838635447237, "phrase": "compiler_analysis"}, {"score": 0.003063627258654102, "phrase": "parameterized_analytic_model"}, {"score": 0.0030273620861817055, "phrase": "quantitative_evaluation"}, {"score": 0.0029737652463012318, "phrase": "broad_range"}, {"score": 0.002938560664857691, "phrase": "hardware_design_trade-offs"}, {"score": 0.002801849371896573, "phrase": "different_performance_metrics"}, {"score": 0.0027358910467781155, "phrase": "primary_focus"}, {"score": 0.0027034948760997564, "phrase": "data_movement"}, {"score": 0.0025776913268808124, "phrase": "exasat_framework's_ability"}, {"score": 0.002532035301903554, "phrase": "deep_code_analysis"}, {"score": 0.00248718591918233, "phrase": "proxy_application"}, {"score": 0.002371424085814217, "phrase": "exascale_co-design_process"}, {"score": 0.0022610379771517966, "phrase": "hardware_and_software_trade-offs"}, {"score": 0.00213023743193503, "phrase": "design_points"}, {"score": 0.0021049977753042253, "phrase": "cycle-accurate_architectural_simulators"}], "paper_keywords": ["Performance modeling", " exascale co-design", " exascale systems", " performance analysis", " combustion codes", " abstract machine model", " compiler analysis", " cache modeling", " stencil applications", " design trade-offs"], "paper_abstract": "One of the emerging challenges to designing HPC systems is understanding and projecting the requirements of exascale applications. In order to determine the performance consequences of different hardware designs, analytic models are essential because they can provide fast feedback to the co-design centers and chip designers without costly simulations. However, current attempts to analytically model program performance typically rely on the user manually specifying a performance model. We introduce the ExaSAT framework that automates the extraction of parameterized performance models directly from source code using compiler analysis. The parameterized analytic model enables quantitative evaluation of a broad range of hardware design trade-offs and software optimizations on a variety of different performance metrics, with a primary focus on data movement as a metric. We demonstrate the ExaSAT framework's ability to perform deep code analysis of a proxy application from the Department of Energy Combustion Co-design Center to illustrate its value to the exascale co-design process. ExaSAT analysis provides insights into the hardware and software trade-offs and lays the groundwork for exploring a more targeted set of design points using cycle-accurate architectural simulators.", "paper_title": "ExaSAT: An exascale co-design tool for performance modeling", "paper_id": "WOS:000353463200007"}