{"auto_keywords": [{"score": 0.046769512189469904, "phrase": "abstract_model"}, {"score": 0.013847048815216699, "phrase": "new_algorithms"}, {"score": 0.010528904161239997, "phrase": "software_model"}, {"score": 0.006840253546514943, "phrase": "spurious_counterexamples"}, {"score": 0.00481495049065317, "phrase": "cegar_more_efficient"}, {"score": 0.004720269202737973, "phrase": "counter-example_guided_abstraction_refinement"}, {"score": 0.004429566229017728, "phrase": "state_space"}, {"score": 0.004140203942496321, "phrase": "desired_property"}, {"score": 0.004042635935882651, "phrase": "concrete_model"}, {"score": 0.0039005612858880115, "phrase": "reported_counterexample"}, {"score": 0.003823791479971016, "phrase": "key_problem"}, {"score": 0.0037784540167266497, "phrase": "abstraction-refinement_loop"}, {"score": 0.0036456298076415652, "phrase": "spurious_counterexample"}, {"score": 0.0034619440946558186, "phrase": "np-hard_state_separation_problem"}, {"score": 0.003248483521309273, "phrase": "great_attention"}, {"score": 0.0030602966787192745, "phrase": "new_formal_definition"}, {"score": 0.003036040409062437, "phrase": "spurious_paths"}, {"score": 0.0027926389474730927, "phrase": "infinite_counterexamples"}, {"score": 0.0027594936602962075, "phrase": "finite_prefix"}, {"score": 0.002599560451267203, "phrase": "existing_algorithms"}, {"score": 0.002548331088496964, "phrase": "practical_terms"}, {"score": 0.0024488738006005133, "phrase": "multi-core_processors"}, {"score": 0.0024101837218440834, "phrase": "spurious_counterexample_checking"}, {"score": 0.0023532890136269986, "phrase": "novel_refining_approach"}, {"score": 0.0023253461255420436, "phrase": "extra_boolean_variables"}, {"score": 0.002147333949483224, "phrase": "smaller_refined_abstract_model"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": ["Model checking", " formal verification", " abstraction", " refinement", " CEGAR"], "paper_abstract": "Counter-example guided abstraction refinement (CEGAR) is widely used in software model checking. With an abstract model, the state space is largely reduced, however, a counterexample found in such a model that does not satisfy the desired property may not exist in the concrete model. Therefore, how to check whether a reported counterexample is spurious is a key problem in the abstraction-refinement loop. Next, in the case that a spurious counterexample is found, the abstract model needs to be further refined where an NP-hard state separation problem is often involved. Thus, how to refine the abstract model efficiently has attracted a great attention in the past years. In this paper, by re-analyzing spurious counterexamples, a new formal definition of spurious paths is given. Based on it, efficient algorithms for detecting spurious counterexamples are presented. By the new algorithms, when dealing with infinite counterexamples, the finite prefix to be analyzed will be polynomially shorter than the one dealt with by the existing algorithms. Moreover, in practical terms, the new algorithms can naturally be parallelized that enables multi-core processors contributes more in spurious counterexample checking. In addition, a novel refining approach by adding extra Boolean variables to the abstract model is presented. With this approach, not only the NP-hard state separation problem can be avoided, but also a smaller refined abstract model can be obtained. Experimental results show that the new algorithms perform well in practice.", "paper_title": "Making CEGAR More Efficient in Software Model Checking", "paper_id": "WOS:000346224400004"}