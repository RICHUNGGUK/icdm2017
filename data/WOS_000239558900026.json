{"auto_keywords": [{"score": 0.03772476186444677, "phrase": "adaptive_code"}, {"score": 0.03113636274786321, "phrase": "demeter_interfaces"}, {"score": 0.015600419465503895, "phrase": "ap"}, {"score": 0.008959821863605322, "phrase": "interface_class_graph"}, {"score": 0.00481495049065317, "phrase": "adaptive_programming"}, {"score": 0.0047224703862074665, "phrase": "advanced_modularization_mechanisms"}, {"score": 0.0046859752697029355, "phrase": "traversal_related_concerns"}, {"score": 0.00464976086880886, "phrase": "data_structures"}, {"score": 0.004613825044585923, "phrase": "object-oriented_programs"}, {"score": 0.00445550467119693, "phrase": "specialized_visitors"}, {"score": 0.0042859292226559535, "phrase": "graph-based_model"}, {"score": 0.004236321075918639, "phrase": "underlying_data_structure"}, {"score": 0.004122781047853192, "phrase": "graph_node_names"}, {"score": 0.0040592684984881245, "phrase": "modifying"}, {"score": 0.003965818535880531, "phrase": "program's_data_structure"}, {"score": 0.003889583851551197, "phrase": "program's_overall_behavior"}, {"score": 0.003698136685049485, "phrase": "current_ap_tools"}, {"score": 0.0036695284042874395, "phrase": "code_reuse"}, {"score": 0.0036411406244705557, "phrase": "system_evolvability"}, {"score": 0.003408512155673965, "phrase": "data_structure"}, {"score": 0.003253279945540651, "phrase": "adaptive_programs"}, {"score": 0.003178326919668771, "phrase": "program's_complete_underlying_data_structure"}, {"score": 0.0031050953733360825, "phrase": "hardcoded_dependencies"}, {"score": 0.0028067105937184954, "phrase": "traversal_specifications"}, {"score": 0.0026997176829763746, "phrase": "additional_constraints"}, {"score": 0.002668420182908979, "phrase": "structural_properties"}, {"score": 0.0024977819584875573, "phrase": "demeter_interface"}, {"score": 0.0024307237540684076, "phrase": "program's_concrete_data_structure"}, {"score": 0.0023289568500915207, "phrase": "higher_levels"}, {"score": 0.002248863090203165, "phrase": "static_verification"}, {"score": 0.0021049977753042253, "phrase": "xml_technologies"}], "paper_keywords": [""], "paper_abstract": "Adaptive Programming (AP) provides advanced modularization mechanisms for traversal related concerns over data structures in object-oriented programs. Computation along a traversal is defined through specialized visitors while the traversal itself is separately defined against a graph-based model of the underlying data structure with the ability to abstract over graph node names and edges. Modifying, under certain restrictions, the program's data structure does not alter the program's overall behavior. Even though AP is geared towards more easily evolvable systems, certain limitations of current AP tools hamper code reuse and system evolvability. Reasoning about adaptive code becomes difficult since there is no guarantee that a modification to a data structure will not alter the meaning of the program. Furthermore, adaptive programs are defined directly against a program's complete underlying data structure exposing unrelated information and introducing hardcoded dependencies decreasing reusability, modularity and hampering evolution. In this paper we present Demeter Interfaces through which a more thorough design method of adaptive programs allows for more resilient software. Traversal specifications and Visitors are defined against an interface class graph augmented with additional constraints that capture structural properties that must hold in order for the adaptive code to function correctly. A program implements a Demeter interface by providing a mapping between the program's concrete data structure and the interface class graph. We show how Demeter interfaces allow for higher levels of reusability and modularity of adaptive code while the static verification of constraints guards against behavior altering modifications. We also discuss the applicability of Demeter Interfaces to XML technologies.", "paper_title": "Demeter interfaces: Adaptive programming without surprises", "paper_id": "WOS:000239558900026"}