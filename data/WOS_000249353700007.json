{"auto_keywords": [{"score": 0.026863829048053338, "phrase": "singer"}, {"score": 0.00481495049065317, "phrase": "adaptive_codes"}, {"score": 0.004740823885631586, "phrase": "protein's_structural_class"}, {"score": 0.00464976086880886, "phrase": "fundamental_problem"}, {"score": 0.004613825044585923, "phrase": "computational_biology"}, {"score": 0.004578165674080246, "phrase": "recent_machine_learning_work"}, {"score": 0.004438250823243621, "phrase": "new_input_space_representations"}, {"score": 0.004187284711626886, "phrase": "state-of-the-art_performance"}, {"score": 0.003935147683802319, "phrase": "underlying_protein_classification_problem"}, {"score": 0.003859500298805362, "phrase": "huge_multiclass_problem"}, {"score": 0.0037853015963603682, "phrase": "even_more_structural_subcategories"}, {"score": 0.0036553070575015344, "phrase": "challenging_many-class_problem"}, {"score": 0.00354349559754076, "phrase": "binary_problem"}, {"score": 0.0034753508746887957, "phrase": "adaptive_code_approach"}, {"score": 0.003435092524339692, "phrase": "output_space"}, {"score": 0.003408512155673968, "phrase": "one-vs-the-rest_prediction_scores"}, {"score": 0.0033170847930578473, "phrase": "ranking_perceptron_algorithm"}, {"score": 0.0032406665327678616, "phrase": "binary_classifiers"}, {"score": 0.0032031180198375283, "phrase": "multi-class_prediction"}, {"score": 0.003141498438356646, "phrase": "fixed_set"}, {"score": 0.0031171827624599693, "phrase": "output_codes"}, {"score": 0.002963640433319524, "phrase": "output_vectors"}, {"score": 0.002817639725689939, "phrase": "protein_structural_hierarchy"}, {"score": 0.002731381261399358, "phrase": "standard_one-vs-all_method"}, {"score": 0.002583181909360701, "phrase": "crammer"}, {"score": 0.0025766822940260963, "phrase": "previous_code_learning_approach"}, {"score": 0.0024025371556472557, "phrase": "code_vectors"}, {"score": 0.0021970000365512227, "phrase": "protein_sequence_analysis"}, {"score": 0.0021049977753042253, "phrase": "structure_classification_problem"}], "paper_keywords": ["multi-class classification", " error-correcting output codes", " structured outputs"], "paper_abstract": "Predicting a protein's structural class from its amino acid sequence is a fundamental problem in computational biology. Recent machine learning work in this domain has focused on developing new input space representations for protein sequences, that is, string kernels, some of which give state-of-the-art performance for the binary prediction task of discriminating between one class and all the others. However, the underlying protein classification problem is in fact a huge multiclass problem, with over 1000 protein folds and even more structural subcategories organized into a hierarchy. To handle this challenging many-class problem while taking advantage of progress on the binary problem, we introduce an adaptive code approach in the output space of one-vs-the-rest prediction scores. Specifically, we use a ranking perceptron algorithm to learn a weighting of binary classifiers that improves multi-class prediction with respect to a fixed set of output codes. We use a cross-validation set-up to generate output vectors for training, and we define codes that capture information about the protein structural hierarchy. Our code weighting approach significantly improves on the standard one-vs-all method for two difficult multi-class protein classification problems: remote homology detection and fold recognition. Our algorithm also outperforms a previous code learning approach due to Crammer and Singer, trained here using a perceptron, when the dimension of the code vectors is high and the number of classes is large. Finally, we compare against PSI-BLAST, one of the most widely used methods in protein sequence analysis, and find that our method strongly outperforms it on every structure classification problem that we consider.", "paper_title": "Multi-class protein classification using adaptive codes", "paper_id": "WOS:000249353700007"}