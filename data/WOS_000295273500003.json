{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "state-retentive_power_gating"}, {"score": 0.008581978929068883, "phrase": "multicore_processors"}, {"score": 0.008148502555923027, "phrase": "leakage_reduction"}, {"score": 0.007666261632704199, "phrase": "memory_stall"}, {"score": 0.007168456360906853, "phrase": "register_file"}, {"score": 0.005428465855972085, "phrase": "proposed_techniques"}, {"score": 0.004684157900507474, "phrase": "-order_cores"}, {"score": 0.004195418010131832, "phrase": "corresponding_register_file"}, {"score": 0.004119049028319832, "phrase": "low_leakage_state"}, {"score": 0.004093901605219401, "phrase": "power_gating"}, {"score": 0.0034066004178183117, "phrase": "multicore_architectures"}, {"score": 0.003375429082739004, "phrase": "first_time"}, {"score": 0.0033037970113095577, "phrase": "specific_techniques"}, {"score": 0.003213920601037463, "phrase": "multithreading_model"}, {"score": 0.002949598537993663, "phrase": "design_extensions"}, {"score": 0.0029225966332070462, "phrase": "control_units"}, {"score": 0.0028958411976400646, "phrase": "in-order_cores"}, {"score": 0.002834357813044087, "phrase": "leakage_states"}, {"score": 0.0026091594819333654, "phrase": "wake-up_latency"}, {"score": 0.002499508839669243, "phrase": "third_approach"}, {"score": 0.002453934333239467, "phrase": "wake-up_process"}, {"score": 0.002431458888197052, "phrase": "thread_context"}, {"score": 0.002286781334850213, "phrase": "multiprogrammed_workloads"}, {"score": 0.0021772489804440646, "phrase": "average_leakage_savings"}, {"score": 0.0021506938783242215, "phrase": "coarse-grained_multithreading"}, {"score": 0.0021049977753042253, "phrase": "finegrained_and_simultaneous_multithreading"}], "paper_keywords": ["FGMT", " SMT", " Niagara", " M5", " in-order"], "paper_abstract": "In this work, we investigate state-retentive power gating of register files for leakage reduction in multicore processors supporting multithreading. In an in-order core, when a thread gets blocked due to a memory stall, the corresponding register file can be placed in a low leakage state through power gating for leakage reduction. When the memory stall gets resolved, the register file is activated for being accessed again. Since the contents of the register file are not lost and restored on wakeup, this is referred to as state-retentive power gating of register files. While state-retentive power gating in single cores has been studied in the literature, it is being investigated for multicore architectures for the first time in this work. We propose specific techniques to implement state-retentive power gating for three different multicore processor configurations based on the multithreading model: 1) coarse-grained multithreading, 2) fine-grained multithreading, and 3) simultaneous multithreading. The proposed techniques can be implemented as design extensions within the control units of the in-order cores. Each technique uses two different modes of leakage states: low-leakage savings and low wake-up and high-leakage savings and high wake-up latency. The overhead due to wake-up latency is completely avoided in two techniques while it is hidden for most part in the third approach, either by overlapping the wake-up process with the thread context switching latency or by executing instructions from other threads ready for execution. The proposed techniques were evaluated through simulations with multiprogrammed workloads comprised of SPEC 2000 integer benchmarks. Experimental results show that in an 8-core processor executing 64 threads, the average leakage savings were 42 percent in coarse-grained multithreading, while they were between seven percent and eight percent for finegrained and simultaneous multithreading.", "paper_title": "State-Retentive Power Gating of Register Files in Multicore Processors Featuring Multithreaded In-Order Cores", "paper_id": "WOS:000295273500003"}