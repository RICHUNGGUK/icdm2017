{"auto_keywords": [{"score": 0.046954660357611575, "phrase": "software_development_tools"}, {"score": 0.04386695071483712, "phrase": "worst-case_execution_time"}, {"score": 0.00481495049065317, "phrase": "real-time_programs"}, {"score": 0.004747141873785, "phrase": "increasing_performance_demand"}, {"score": 0.004713594814274419, "phrase": "real-time_systems"}, {"score": 0.0044535760439663235, "phrase": "performance-relevant_code_parts"}, {"score": 0.004406436661912347, "phrase": "real-time_program"}, {"score": 0.004163296527417903, "phrase": "wcet"}, {"score": 0.003961526165403768, "phrase": "wcep"}, {"score": 0.003905689096176873, "phrase": "partial_information"}, {"score": 0.0035487559182107112, "phrase": "comprehensive_view"}, {"score": 0.003511159930253876, "phrase": "entire_code_base"}, {"score": 0.0033172506969692626, "phrase": "efficient_approach"}, {"score": 0.0032820992275066274, "phrase": "worst-case_timing_information"}, {"score": 0.003167587258150065, "phrase": "complementary_metric"}, {"score": 0.003024655649924378, "phrase": "criticality_value"}, {"score": 0.0028984332556216946, "phrase": "global_wcet."}, {"score": 0.00286770704394124, "phrase": "valuable_information"}, {"score": 0.002827243416398972, "phrase": "worst_execution_path"}, {"score": 0.0027873491386063913, "phrase": "specific_program_part"}, {"score": 0.002748016244165687, "phrase": "global_wcep."}, {"score": 0.002699627613420169, "phrase": "criticality_metric"}, {"score": 0.0025961429982767257, "phrase": "control-flow_graphs"}, {"score": 0.00240089402509933, "phrase": "complete_programs"}, {"score": 0.0022441016229967025, "phrase": "well-established_real-time_benchmark_programs"}, {"score": 0.002188947861949892, "phrase": "criticality_values"}, {"score": 0.0021657265492371976, "phrase": "considerable_amounts"}, {"score": 0.0021503823972534096, "phrase": "highly_critical_as_well_as_uncritical_code"}, {"score": 0.0021049977753042253, "phrase": "ideal_information"}], "paper_keywords": ["Criticality", " Worst-case execution time", " Program profiling"], "paper_abstract": "With the increasing performance demand in real-time systems it becomes more and more important to provide feedback to programmers and software development tools on the performance-relevant code parts of a real-time program. So far, this information was limited to an estimation of the worst-case execution time (WCET) and its associated worst-case execution path (WCEP) only. However, both, the WCET and the WCEP, only provide partial information. Only code parts that are on one of the WCEPs are indicated to the programmer. No information is provided for all other code parts. To give a comprehensive view covering the entire code base, tools in the spirit of program profiling are required. This work proposes an efficient approach to compute worst-case timing information for all code parts of a program using a complementary metric, called criticality. Every statement of a program is assigned a criticality value, expressing how critical the code is with respect to the global WCET. This gives valuable information how close the worst execution path passing through a specific program part is to the global WCEP. We formally define the criticality metric and investigate some of its properties with respect to dominance in control-flow graphs. Exploiting some of those properties, we propose an algorithm that reduces the overhead of computing the metric to cover complete programs. We also investigate ways to efficiently find only those code parts whose criticality is above a given threshold. Experiments using well-established real-time benchmark programs show an interesting distribution of the criticality values, revealing considerable amounts of highly critical as well as uncritical code. The metric thus provides ideal information to programmers and software development tools to optimize the worst-case execution time of these programs.", "paper_title": "Criticality: static profiling for real-time programs", "paper_id": "WOS:000334195100004"}