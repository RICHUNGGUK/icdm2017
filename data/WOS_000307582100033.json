{"auto_keywords": [{"score": 0.04713957641895842, "phrase": "simd_parallelism"}, {"score": 0.01402327778046268, "phrase": "existing_applications"}, {"score": 0.00481495049065317, "phrase": "dynamic_trace-based_analysis_of_vectorization_potential_of_applications"}, {"score": 0.00477924690801092, "phrase": "recent_hardware_trends"}, {"score": 0.004691136491297242, "phrase": "increasing_vector_lengths"}, {"score": 0.00465634671242413, "phrase": "sse-like_isa_extensions"}, {"score": 0.004553510708976456, "phrase": "effective_exploitation"}, {"score": 0.00443638953122199, "phrase": "high_performance"}, {"score": 0.004370814742381778, "phrase": "future_architectures"}, {"score": 0.004322267755421529, "phrase": "vast_majority"}, {"score": 0.0041488110506566825, "phrase": "effective_vectorizability"}, {"score": 0.004027031316965272, "phrase": "production_compilers"}, {"score": 0.0039822874870125095, "phrase": "gnu_gcc"}, {"score": 0.003952757498837138, "phrase": "intel"}, {"score": 0.0039088121438737924, "phrase": "pgi_pgcc"}, {"score": 0.0038654089132884512, "phrase": "ibm"}, {"score": 0.003808209866576388, "phrase": "considerable_effort"}, {"score": 0.0037658881407605445, "phrase": "significant_advances"}, {"score": 0.003724034990158436, "phrase": "automatic_vectorization_capabilities"}, {"score": 0.0035216195857272403, "phrase": "considerable_interest"}, {"score": 0.0034309482755326016, "phrase": "inherent_latent_potential"}, {"score": 0.0033177813460815346, "phrase": "manual_code_changes"}, {"score": 0.0031726587374218277, "phrase": "program's_simd_parallelization_potential"}, {"score": 0.0031257046538823354, "phrase": "dynamic_data-dependence_graph"}, {"score": 0.0030794433253250476, "phrase": "sequential_execution_trace"}, {"score": 0.002933756577145939, "phrase": "execution_order"}, {"score": 0.0028688545415450407, "phrase": "dependence-preserving_reordering"}, {"score": 0.002815864555488112, "phrase": "potential_simd_parallelism"}, {"score": 0.002613487968156893, "phrase": "computationally-intensive_loops"}, {"score": 0.0025844090835070986, "phrase": "high_potential"}, {"score": 0.002285075675790214, "phrase": "transformation_capabilities"}, {"score": 0.002268088741853586, "phrase": "vectorizing_compilers"}, {"score": 0.0022013916728990564, "phrase": "code_regions"}, {"score": 0.0021207658298095845, "phrase": "performance_improvement"}, {"score": 0.0021049977753042253, "phrase": "existing_compilers"}], "paper_keywords": ["Performance", " Measurement", " Algorithms", " Performance analysis", " dynamic analysis", " vectorization"], "paper_abstract": "Recent hardware trends with GPUs and the increasing vector lengths of SSE-like ISA extensions for multicore CPUs imply that effective exploitation of SIMD parallelism is critical for achieving high performance on emerging and future architectures. A vast majority of existing applications were developed without any attention by their developers towards effective vectorizability of the codes. While developers of production compilers such as GNU gcc, Intel icc, PGI pgcc, and IBM xlc have invested considerable effort and made significant advances in enhancing automatic vectorization capabilities, these compilers still cannot effectively vectorize many existing scientific and engineering codes. It is therefore of considerable interest to analyze existing applications to assess the inherent latent potential for SIMD parallelism, exploitable through further compiler advances and/or via manual code changes. In this paper we develop an approach to infer a program's SIMD parallelization potential by analyzing the dynamic data-dependence graph derived from a sequential execution trace. By considering only the observed run-time data dependences for the trace, and by relaxing the execution order of operations to allow any dependence-preserving reordering, we can detect potential SIMD parallelism that may otherwise be missed by more conservative compile-time analyses. We show that for several benchmarks our tool discovers regions of code within computationally-intensive loops that exhibit high potential for SIMD parallelism but are not vectorized by state-of-the-art compilers. We present several case studies of the use of the tool, both in identifying opportunities to enhance the transformation capabilities of vectorizing compilers, as well as in pointing to code regions to manually modify in order to enable auto-vectorization and performance improvement by existing compilers.", "paper_title": "Dynamic Trace-Based Analysis of Vectorization Potential of Applications", "paper_id": "WOS:000307582100033"}