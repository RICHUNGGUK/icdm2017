{"auto_keywords": [{"score": 0.033775525781890345, "phrase": "false_locate"}, {"score": 0.02322730111336097, "phrase": "location_function"}, {"score": 0.01624358882993835, "phrase": "false_hit"}, {"score": 0.008877262131984708, "phrase": "structural_joins"}, {"score": 0.004755054742217193, "phrase": "structural_join"}, {"score": 0.0047155367844327, "phrase": "structural_relationship"}, {"score": 0.004503959683578956, "phrase": "xml_elements"}, {"score": 0.004392565073466714, "phrase": "important_computation_unit"}, {"score": 0.0043560464825349275, "phrase": "xml_pattern_matching"}, {"score": 0.004160531596936783, "phrase": "efficient_structural_joins"}, {"score": 0.0039737570920809215, "phrase": "unmatchable_elements"}, {"score": 0.003924284136338428, "phrase": "typical_use"}, {"score": 0.0035947360742084253, "phrase": "indexed_set"}, {"score": 0.003292770855568091, "phrase": "index_probe"}, {"score": 0.003265365666305185, "phrase": "unnecessary_data"}, {"score": 0.0032381878248821383, "phrase": "real_results"}, {"score": 0.0031056437850836326, "phrase": "zero_answers"}, {"score": 0.0028209599545587745, "phrase": "new_structural_join_algorithm"}, {"score": 0.0026494723416072316, "phrase": "false_hit_property"}, {"score": 0.002530359917257626, "phrase": "good_candidate"}, {"score": 0.00241658945942583, "phrase": "new_function"}, {"score": 0.0023566987138026285, "phrase": "probing_points"}, {"score": 0.0022133711375320244, "phrase": "space-efficient_structure"}, {"score": 0.0021049977753042253, "phrase": "extensive_experiments"}], "paper_keywords": [""], "paper_abstract": "A structural join evaluates structural relationship (parent-child or ancestor-descendant) between XML elements. It serves as an important computation unit in XML pattern matching, such as twig joins. There exists many work on efficient structural joins. In particular, indexes can expedite structural joins by skipping unmatchable elements. A typical use of indexes is to retrieve, for a given element, all its ancestor (or descendant) elements from an indexed set. However we observed two possible limitations with such index probes, namely false hit and false locate. A false hit means that an index probe touches unnecessary data besides real results; a false locate stands for a (wasted) probe that has zero answers. Obviously false hit and false locate can affect negatively the efficiency of structural joins. In this paper, we challenge ourselves to develop new structural join algorithm with no false hit and no false locate. We illustrate that R-Tree has the no false hit property (in contrast to B+-Tree) and hence is a good candidate for our algorithm. For no false locate, we propose a new function called Location which tells the probing points that will result in matches. We design and implement the Location function using a space-efficient structure, and present our algorithm using R-Ree together with the Location function. Extensive experiments show the efficiency of our algorithm.", "paper_title": "Fast structural join with a location function", "paper_id": "WOS:000238093200055"}