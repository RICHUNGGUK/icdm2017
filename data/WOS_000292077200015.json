{"auto_keywords": [{"score": 0.048949445942657245, "phrase": "approximate_string_matching"}, {"score": 0.004815112813718618, "phrase": "cache"}, {"score": 0.004313996835376177, "phrase": "text_t"}, {"score": 0.0038834787946979863, "phrase": "input_pattern"}, {"score": 0.0035632774896594524, "phrase": "internal-memory_setting"}, {"score": 0.003413183361838603, "phrase": "recent_results"}, {"score": 0.0033806943112103397, "phrase": "external-memory_solutions"}, {"score": 0.003072285184441679, "phrase": "k-error_matches"}, {"score": 0.0027259252868643926, "phrase": "disk_page"}, {"score": 0.0025737890313763407, "phrase": "first_external-memory_data_structure"}, {"score": 0.0023840346303791032, "phrase": "second_index"}], "paper_keywords": ["String matching", " Indexing", " Approximate queries", " Cache-oblivious", " I/O model"], "paper_abstract": "This paper revisits the problem of indexing a text for approximate string matching. Specifically, given a text T of length n and a positive integer k, we want to construct an index of T such that for any input pattern P. we can find all its k-error matches in T efficiently. This problem is well-studied in the internal-memory setting. Here, we extend some of these recent results to external-memory solutions, which are also cache-oblivious. Our first index occupies O((n log(k) n)/B) disk pages and finds all k-error matches with O((vertical bar P vertical bar + occ)/B + log(k) n log log(B) n) I/Os, where B denotes the number of words in a disk page. To the best of our knowledge, this index is the first external-memory data structure that does not require Omega (vertical bar P vertical bar + occ + poly(log n)) I/Os. The second index reduces the space to O((n log n)/B) disk pages, and the I/O complexity is O((vertical bar P vertical bar + occ)/B + log(k(k+1)) n log log n). (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Cache-oblivious index for approximate string matching", "paper_id": "WOS:000292077200015"}