{"auto_keywords": [{"score": 0.03483809260190114, "phrase": "target_system"}, {"score": 0.01547225000326257, "phrase": "performance_evaluation"}, {"score": 0.015349958661752023, "phrase": "embedded_software"}, {"score": 0.015048378016057028, "phrase": "early_development_phase"}, {"score": 0.00481495049065317, "phrase": "cross-profiling"}, {"score": 0.004776484866276242, "phrase": "java_processors"}, {"score": 0.004390607370861926, "phrase": "embedded_device's_limited_computing_resources"}, {"score": 0.004150761431291174, "phrase": "embedded_target"}, {"score": 0.0036504182609411852, "phrase": "customizable_cross-profiling_framework"}, {"score": 0.0036068106929520592, "phrase": "java"}, {"score": 0.0035067452724203124, "phrase": "method_cache"}, {"score": 0.0033822643082593285, "phrase": "host_environment"}, {"score": 0.0032491108935498794, "phrase": "standard_java_virtual_machine"}, {"score": 0.00319732428387928, "phrase": "generated_profiles"}, {"score": 0.0031590250068577867, "phrase": "execution_time_metric"}, {"score": 0.0030468495296763617, "phrase": "bytecode_instrumentation"}, {"score": 0.0028115863316685937, "phrase": "cpu_cycle_consumption"}, {"score": 0.002711715684313774, "phrase": "jop"}, {"score": 0.0026900059414552823, "phrase": "java_processor"}, {"score": 0.002615381301695394, "phrase": "high_profile_accuracy"}, {"score": 0.0025944417620244924, "phrase": "moderate_overhead"}, {"score": 0.002512342528545883, "phrase": "new_processor_architectures"}, {"score": 0.002432834929068545, "phrase": "case_study"}, {"score": 0.002384422461262006, "phrase": "performance_impact"}, {"score": 0.002308953751676031, "phrase": "different_cache_sizes"}, {"score": 0.0022904619303011097, "phrase": "pipeline_organizations"}, {"score": 0.0022268964676199292, "phrase": "improved_processor_design"}, {"score": 0.002165091261117016, "phrase": "standard_java_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["cross-profiling", " embedded Java processors", " bytecode instrumentation", " platform-independent dynamic metrics", " processor architecture design space exploration"], "paper_abstract": "Performance evaluation of embedded software is essential in an early development phase so as to ensure that the software will run on the embedded device's limited computing resources. The prevailing approaches either require the deployment of the software on the embedded target, which can be tedious and may be impossible in an early development phase, or rely on simulation, which can be very slow. In this article, we introduce a customizable cross-profiling framework for embedded Java processors, including processors featuring a method cache. The developer profiles the embedded software in the host environment, completely decoupled from the target system, on any standard Java virtual machine, but the generated profiles represent the execution time metric of the target system. Our cross-profiling framework is based on bytecode instrumentation. We identify several pointcuts in the execution of bytecode that need to be instrumented in order to estimate the CPU cycle consumption on the target system. An evaluation using the JOP embedded Java processor as target confirms that our approach reconciles high profile accuracy with moderate overhead. Our cross-profiling framework also enables the performance evaluation of new processor architectures before they are implemented. As a case study, we explore the performance impact of various processor design choices and optimizations, such as different cache sizes or pipeline organizations, and come up with an improved processor design that yields speedups of up to 40% on standard Java benchmarks. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Cross-profiling for Java processors", "paper_id": "WOS:000272736100001"}