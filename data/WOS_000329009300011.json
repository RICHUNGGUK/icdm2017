{"auto_keywords": [{"score": 0.03973761244758953, "phrase": "order_execution"}, {"score": 0.0225640873640547, "phrase": "stream_applications"}, {"score": 0.010155468495214587, "phrase": "multi-gpu_systems"}, {"score": 0.006406510218090957, "phrase": "multiple_gpus"}, {"score": 0.00481495049065317, "phrase": "gpu-chariot"}, {"score": 0.00447251540886613, "phrase": "stream_programming_framework"}, {"score": 0.004407106644548925, "phrase": "gpu"}, {"score": 0.004216112320418982, "phrase": "graphics_processing_units"}, {"score": 0.004093453936415085, "phrase": "main_contribution"}, {"score": 0.003954837422946628, "phrase": "efficient_software_pipelines"}, {"score": 0.0037463983616303786, "phrase": "cpu_functions"}, {"score": 0.0036553070575015344, "phrase": "data_transfers"}, {"score": 0.0034118234596993836, "phrase": "runtime_scheduler"}, {"score": 0.0032800186243040663, "phrase": "system_resources"}, {"score": 0.002986969236641105, "phrase": "load-balancing_capability"}, {"score": 0.0028293966058473476, "phrase": "callback_interface"}, {"score": 0.0028016507334576216, "phrase": "overlapping_execution"}, {"score": 0.0027469703311742647, "phrase": "third-party_libraries"}, {"score": 0.00266693888510356, "phrase": "different_performance_bottlenecks"}, {"score": 0.0022443390559699974, "phrase": "manually_pipelined_code"}, {"score": 0.0021049977753042253, "phrase": "software_pipelines"}], "paper_keywords": ["stream processing", " GPGPU", " CUDA", " task scheduling"], "paper_abstract": "This paper presents a stream programming framework, named GPU-chariot, for accelerating stream applications running on graphics processing units (GPUs). The main contribution of our framework is that it realizes efficient software pipelines on multi-GPU systems by enabling out-of-order execution of CPU functions, kernels, and data transfers. To achieve this out-of-order execution, we apply a runtime scheduler that not only maximizes the utilization of system resources but also encapsulates the number of GPUs available in the system. In addition, we implement a load-balancing capability to flow data efficiently through multiple GPUs. Furthermore, a callback interface enables overlapping execution of functions in third-party libraries. By using kernels with different performance bottlenecks, we show that our out-of-order execution is up to 20% faster than in-order execution. Finally, we conduct several case studies on a 4-GPU system and demonstrate the advantages of GPU-chariot over a manually pipelined code. We conclude that GPU-chariot can be useful when developing stream applications with software pipelines on multiple GPUs and CPUs.", "paper_title": "GPU-Chariot: A Programming Framework for Stream Applications Running on Multi-GPU Systems", "paper_id": "WOS:000329009300011"}