{"auto_keywords": [{"score": 0.035884478140401375, "phrase": "minimum_number"}, {"score": 0.004860218511356111, "phrase": "time"}, {"score": 0.004626255242038005, "phrase": "multi-writer_snapshots"}, {"score": 0.0045346863560033175, "phrase": "snapshot_object"}, {"score": 0.004242291530697285, "phrase": "consistent_view"}, {"score": 0.004103212598803194, "phrase": "shared_memory"}, {"score": 0.004021954624114115, "phrase": "distributed_system"}, {"score": 0.003942299471749811, "phrase": "concurrent_changes"}, {"score": 0.003712640297460159, "phrase": "m-component_snapshot_objects"}, {"score": 0.002842920225545139, "phrase": "fastest_such_implementation"}, {"score": 0.0023113506171584157, "phrase": "snapshot_implementations"}, {"score": 0.0022806798371116698, "phrase": "single-writer_registers"}, {"score": 0.0021049977753042253, "phrase": "swap_objects"}], "paper_keywords": ["theory", " algorithms", " distributed computing", " lower bound", " registers", " shared memory", " snapshot", " wait-free"], "paper_abstract": "A snapshot object is an abstraction of the problem of obtaining a consistent view of the contents of shared memory in a distributed system, despite concurrent changes to the memory. There are implementations of m-component snapshot objects shared by n >= m processes using m registers. This is the minimum number of registers possible. We prove a time lower bound for implementations that use this minimum number of registers. It matches the time taken by the fastest such implementation. Our proof yields insight into the structure of any such implementation, showing that processes must access the registers in a very constrained way. We also prove a time lower bound for snapshot implementations using single-writer registers in addition to m historyless objects ( such as registers and swap objects).", "paper_title": "Time lower bounds for implementations of multi-writer snapshots", "paper_id": "WOS:000251908700004"}