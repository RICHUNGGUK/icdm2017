{"auto_keywords": [{"score": 0.044869792207088685, "phrase": "safe_lambda_calculus"}, {"score": 0.012928555548813513, "phrase": "simply-typed_lambda_calculus"}, {"score": 0.00481495049065317, "phrase": "safe_lambda_calculus._safety"}, {"score": 0.004749106104067268, "phrase": "syntactic_condition"}, {"score": 0.0047057084749407485, "phrase": "higher-order_grammars"}, {"score": 0.004536029676655286, "phrase": "production_rules"}, {"score": 0.004062682236016889, "phrase": "safety_condition"}, {"score": 0.0038447943243941685, "phrase": "original_definition"}, {"score": 0.00338060449446278, "phrase": "bound_variables"}, {"score": 0.0032886455096627324, "phrase": "variable_capture"}, {"score": 0.003126481516783286, "phrase": "adequate_notion"}, {"score": 0.0027614468443073028, "phrase": "exactly_the_multivariate_polynomials"}, {"score": 0.0025892330566358503, "phrase": "representable_word_functions"}, {"score": 0.0024842242921857705, "phrase": "beta-eta_equality"}, {"score": 0.002297327670408112, "phrase": "game-semantic_analysis"}, {"score": 0.002224510044064184, "phrase": "safe_terms"}, {"score": 0.002183938718432764, "phrase": "p-incrementally_justified_strategies"}, {"score": 0.002124461969404541, "phrase": "game_semantics"}, {"score": 0.0021049977753042253, "phrase": "safe_lambda-terms"}], "paper_keywords": ["lambda calculus", " higher-order recursion scheme", " safety restriction", " game semantics"], "paper_abstract": "Safety is a syntactic condition of higher-order grammars that constrains occurrences of variables in the production rules according to their type-theoretic order. In this paper, we introduce the safe lambda calculus, which is obtained by transposing (and generalizing) the safety condition to the setting of the simply-typed lambda calculus. In contrast to the original definition of safety, our calculus does not constrain types (to be homogeneous). We show that in the safe lambda calculus, there is no need to rename bound variables when performing substitution, as variable capture is guaranteed not to happen. We also propose an adequate notion of beta-reduction that preserves safety. In the same vein as Schwichtenberg's 1976 characterization of the simply-typed lambda calculus, we show that the numeric functions representable in the safe lambda calculus are exactly the multivariate polynomials; thus conditional is not definable. We also give a characterization of representable word functions. We then study the complexity of deciding beta-eta equality of two safe simply-typed terms and show that this problem is PSPACE-hard. Finally we give a game-semantic analysis of safety: We show that safe terms are denoted by P-incrementally justified strategies. Consequently pointers in the game semantics of safe lambda-terms are only necessary from order 4 onwards.", "paper_title": "THE SAFE LAMBDA CALCULUS", "paper_id": "WOS:000268642200003"}