{"auto_keywords": [{"score": 0.04583497690769901, "phrase": "observational_behavior"}, {"score": 0.012143074056118414, "phrase": "logical_relations"}, {"score": 0.00481495049065317, "phrase": "syntactic_logical_relations"}, {"score": 0.004733123544564746, "phrase": "haskell-like_languages"}, {"score": 0.004636756166068091, "phrase": "fundamental_and_powerful_tool"}, {"score": 0.004511297689862029, "phrase": "parametric_polymorphism"}, {"score": 0.004359216541892805, "phrase": "polymorphic_calculi"}, {"score": 0.0038793218280304825, "phrase": "implemented_languages"}, {"score": 0.0036469533983843755, "phrase": "real_languages"}, {"score": 0.003523907167337646, "phrase": "intermediate_language"}, {"score": 0.003475875644538218, "phrase": "haskell"}, {"score": 0.0032675746199502614, "phrase": "program_equivalence"}, {"score": 0.0031899784784921222, "phrase": "abstract_notion"}, {"score": 0.0030612062471277388, "phrase": "observational_approximation"}, {"score": 0.003019444345150991, "phrase": "selective_strictness"}, {"score": 0.0029175079344240227, "phrase": "different_kinds"}, {"score": 0.0028975361811534265, "phrase": "computational_failure"}, {"score": 0.002838435157502933, "phrase": "failed_pattern_matching"}, {"score": 0.0027144744718498102, "phrase": "relative_definedness"}, {"score": 0.0026958888229781618, "phrase": "different_failure"}, {"score": 0.002622806755354039, "phrase": "different_orders"}, {"score": 0.0025959133277517824, "phrase": "different_observational_relations"}, {"score": 0.002431861192375809, "phrase": "entire_family"}, {"score": 0.002374063735432571, "phrase": "definedness_order"}, {"score": 0.0023578033235964356, "phrase": "failure_causes"}, {"score": 0.0022938652373998337, "phrase": "corresponding_observational_relation"}, {"score": 0.0021562588804528667, "phrase": "type-erasing_semantics"}, {"score": 0.0021049977753042253, "phrase": "actual_implementations"}], "paper_keywords": [""], "paper_abstract": "Logical relations are a fundamental and powerful tool for reasoning about programs in languages with parametric polymorphism. Logical relations suitable for reasoning about observational behavior in polymorphic calculi supporting various programming language features have been introduced in recent years. Unfortunately, the calculi studied are typically idealized, and the results obtained for them offer only partial insight into the impact of such features on observational behavior in implemented languages. In this paper, we show how to bring reasoning via logical relations closer to bear on real languages by deriving results that are more pertinent to an intermediate language for the (mostly) lazy functional language Haskell like GHC Core. To provide a more fine-grained analysis of program behavior than is possible by reasoning about program equivalence alone, we work with an abstract notion of relating observational behavior of computations which has among its specializations both observational equivalence and observational approximation. We take selective strictness into account, and we consider the impact of different kinds of computational failure, e.g., divergence versus failed pattern matching, because such distinctions are significant in practice. Once distinguished, the relative definedness of different failure causes needs to be considered, because different orders here induce different observational relations on programs (including the choice between equivalence and approximation). Our main contribution is the construction of an entire family of logical relations, parameterized over a definedness order on failure causes, each member of which characterizes the corresponding observational relation. Although we deal with properties very much tied to types, we base our results on a type-erasing semantics since this is more faithful to actual implementations. (c) 2008 Elsevier Inc. All rights reserved.", "paper_title": "A family of syntactic logical relations for the semantics of Haskell-like languages", "paper_id": "WOS:000264109400012"}