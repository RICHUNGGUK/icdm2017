{"auto_keywords": [{"score": 0.04406814292154228, "phrase": "fibonacci_heaps"}, {"score": 0.026897811453592893, "phrase": "key_decrease"}, {"score": 0.00481495049065317, "phrase": "rank-pairing"}, {"score": 0.004618166136069052, "phrase": "rank-pairing_heap"}, {"score": 0.004283913685201902, "phrase": "asymptotic_efficiency"}, {"score": 0.0034476484413811987, "phrase": "balance_condition"}, {"score": 0.002447101794397243, "phrase": "worst_case"}, {"score": 0.00223196703759329, "phrase": "node_ranks"}], "paper_keywords": ["algorithm", " data structure", " heap", " priority queue", " amortized analysis"], "paper_abstract": "We introduce the rank-pairing heap, an implementation of heaps that combines the asymptotic efficiency of Fibonacci heaps with much of the simplicity of pairing heaps. Other heap implementations that match the bounds of Fibonacci heaps do so by maintaining a balance condition on the trees representing the heap. In contrast to these structures but like pairing heaps, our trees can evolve to have arbitrary (unbalanced) structure. Also like pairing heaps, our structure requires at most one cut and no other restructuring per key decrease, in the worst case: the only changes that can cascade during a key decrease are changes in node ranks. Although our data structure is simple, its analysis is not.", "paper_title": "RANK-PAIRING HEAPS", "paper_id": "WOS:000298377900001"}