{"auto_keywords": [{"score": 0.037011009195315615, "phrase": "modern_hardware"}, {"score": 0.00481495049065317, "phrase": "barriers_reconsidered"}, {"score": 0.0044275118637330975, "phrase": "mutator_actions"}, {"score": 0.00426344619171077, "phrase": "powerful_tool"}, {"score": 0.004157446556371582, "phrase": "heap_management_algorithm"}, {"score": 0.0040882422992520925, "phrase": "prevailing_wisdom"}, {"score": 0.004003348169928476, "phrase": "significant_costs"}, {"score": 0.003589404014552974, "phrase": "useful_barriers"}, {"score": 0.0034130176595901104, "phrase": "old_results"}, {"score": 0.00330025288273863, "phrase": "microarchitectural_sensitivity"}, {"score": 0.0032726467814278345, "phrase": "barrier_performance"}, {"score": 0.0032046343506232588, "phrase": "benchmark_suites"}, {"score": 0.0029463874016490976, "phrase": "known_pathology"}, {"score": 0.002789763110395331, "phrase": "average_overheads"}, {"score": 0.0026525671788921205, "phrase": "barrier_overheads"}, {"score": 0.002543392353000551, "phrase": "modern_dacapo_benchmarks"}, {"score": 0.0024284701569889113, "phrase": "barrier_behavior"}, {"score": 0.0022609695885550058, "phrase": "different_barrier_choices"}, {"score": 0.0022420373745572837, "phrase": "different_platforms"}, {"score": 0.0022139352210982398, "phrase": "changing_costs"}, {"score": 0.0021861845339709533, "phrase": "algorithm_designers"}], "paper_keywords": ["Experimentation", " Languages", " Performance", " Measurement", " Write barriers", " Memory management", " Garbage collection", " Java"], "paper_abstract": "Read and write barriers mediate access to the heap allowing the collector to control and monitor mutator actions. For this reason, barriers are a powerful tool in the design of any heap management algorithm, but the prevailing wisdom is that they impose significant costs. However, changes in hardware and workloads make these costs a moving target. Here, we measure the cost of a range of useful barriers on a range of modern hardware and workloads. We confirm some old results and overturn others. We evaluate the microarchitectural sensitivity of barrier performance and the differences among benchmark suites. We also consider barriers in context, focusing on their behavior when used in combination, and investigate a known pathology and evaluate solutions. Our results show that read and write barriers have average overheads as low as 5.4% and 0.9% respectively. We find that barrier overheads are more exposed on the workload provided by the modern DaCapo benchmarks than on old SPECjvm98 benchmarks. Moreover, there are differences in barrier behavior between in-order and out-of-order machines, and their respective memory subsystems, which indicate different barrier choices for different platforms. These changing costs mean that algorithm designers need to reconsider their design choices and the nature of their resulting algorithms in order to exploit the opportunities presented by modern hardware.", "paper_title": "Barriers Reconsidered, Friendlier Still!", "paper_id": "WOS:000313659800004"}