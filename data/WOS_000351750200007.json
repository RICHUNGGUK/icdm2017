{"auto_keywords": [{"score": 0.04105135335087916, "phrase": "petri_net"}, {"score": 0.00481495049065317, "phrase": "gals_systems"}, {"score": 0.004775203689274285, "phrase": "concurrent_system"}, {"score": 0.004147364535298904, "phrase": "practical_implementations"}, {"score": 0.004067865478263316, "phrase": "single_atomic_action"}, {"score": 0.003945993835171648, "phrase": "single_transition"}, {"score": 0.003806650177153472, "phrase": "gals"}, {"score": 0.0036823699601344962, "phrase": "vlsi_circuits"}, {"score": 0.003426802993964843, "phrase": "signal_management"}, {"score": 0.0033797211728461584, "phrase": "concurrent_events"}, {"score": 0.0033332840586431413, "phrase": "concurrent_reachability_graph"}, {"score": 0.0031018692201038004, "phrase": "single_clock_tick"}, {"score": 0.003076219973714196, "phrase": "best_candidates"}, {"score": 0.0028944757265206332, "phrase": "'persistent'_sets"}, {"score": 0.002784436042659089, "phrase": "sequential_semantics"}, {"score": 0.0026859955072188932, "phrase": "based_execution"}, {"score": 0.0024650347199954817, "phrase": "formal_definition"}, {"score": 0.0023193155235550354, "phrase": "pruned_reachability_graph"}, {"score": 0.002281087456676369, "phrase": "re-engineered_system"}, {"score": 0.0022187659808640433, "phrase": "new_petri_net"}, {"score": 0.0022004029656808224, "phrase": "standard_techniques"}, {"score": 0.002188245279475924, "phrase": "net_synthesis"}, {"score": 0.002134359860048694, "phrase": "persistent_and_safe_nets"}, {"score": 0.0021049977753042253, "phrase": "maximally_concurrent_steps"}], "paper_keywords": ["asynchronous and synchronous circuit", " GALS system", " persistence", " nonviolence", " step transition system", " step semantics", " Petri net"], "paper_abstract": "A concurrent system is persistent if throughout its operation no activity which became enabled can subsequently be prevented from being executed by any other activity. This is often a highly desirable (or even necessary) property; in particular, if the system is to be implemented in hardware. Over the past 40 years, persistence has been investigated and applied in practical implementations assuming that each activity is a single atomic action which can be represented, for example, by a single transition of a Petri net. In this paper we investigate the behaviour of GALS (Globally Asynchronous Locally Synchronous) systems in the context of VLSI circuits. The specification of a system is given in the form of a Petri net. Our aim is to re-design the system to optimise signal management, by grouping together concurrent events. Looking at the concurrent reachability graph of the given Petri net, we are interested in discovering events that appear in 'bundles', so that they all can be executed in a single clock tick. The best candidates for bundles are sets of events that appear and re-appear over and over again in the same configurations, forming 'persistent' sets of events. Persistence was considered so far only in the context of sequential semantics. In this paper, we move to the realm of step based execution and consider not only steps which are persistent and cannot be disabled by other steps, but also steps which are nonviolent and cannot disable other steps. We then introduce a formal definition of a bundle and propose an algorithm to prune the behaviour of a system, so that only bundled steps remain. The pruned reachability graph represents the behaviour of a re-engineered system, which in turn can be implemented in a new Petri net using the standard techniques of net synthesis. The proposed algorithm prunes reachability graphs of persistent and safe nets leaving bundles that represent maximally concurrent steps.", "paper_title": "Persistent and Nonviolent Steps and the Design of GALS Systems", "paper_id": "WOS:000351750200007"}