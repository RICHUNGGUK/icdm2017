{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "combinational_logic_decomposition"}, {"score": 0.004770211811866158, "phrase": "self-timed_circuits"}, {"score": 0.004703878334423852, "phrase": "attractive_solution"}, {"score": 0.004595356579614969, "phrase": "process_variation"}, {"score": 0.004489327204473076, "phrase": "self-timed_combinational_logic"}, {"score": 0.00428451995524549, "phrase": "external_timing_references"}, {"score": 0.003848088904418221, "phrase": "internal_signals"}, {"score": 0.003741712498615481, "phrase": "large_function_blocks"}, {"score": 0.003570889780957037, "phrase": "new_signals"}, {"score": 0.003407839062159497, "phrase": "novel_method"}, {"score": 0.0032827577713351336, "phrase": "n-encoded_function_block"}, {"score": 0.0029343128039167185, "phrase": "input_encoding"}, {"score": 0.0029069972482610403, "phrase": "smaller_unordered_codes"}, {"score": 0.0027741761880779535, "phrase": "potential_re-encodings"}, {"score": 0.002735522834514124, "phrase": "exact_branch"}, {"score": 0.0027100527874262446, "phrase": "bound_approach"}, {"score": 0.002562123444678208, "phrase": "unordered_encodings"}, {"score": 0.0025028892126605124, "phrase": "function_blocks"}, {"score": 0.002300734266971646, "phrase": "algebraic_extraction_techniques"}, {"score": 0.002237036807966899, "phrase": "potential_encodings"}, {"score": 0.0021750990136123367, "phrase": "synthesis_procedures"}, {"score": 0.0021049977753042253, "phrase": "combinational_function_blocks"}], "paper_keywords": [""], "paper_abstract": "Self-timed circuits present an attractive solution to the problem of process variation. However, implementing self-timed combinational logic is complex and expensive. As there are no external timing references, data must be encoded within an unordered (DI) encoding and the outputs of functions must indicate to the environment that transitions on inputs and internal signals have taken place. Mapping large function blocks into cell-libraries is extremely difficult as decomposing gates introduces new signals which may violate indication. This study presents a novel method for implementing any m-of-n-encoded function block using 'bounded gates', where any gate may be decomposed without violating indication. This is achieved by successively decomposing the input encoding into smaller unordered codes. The study presents algorithms to determine and quantify potential re-encodings. An exact branch and bound approach to the solution is shown, but the complexity of determining unordered encodings restricts the size of function blocks that may be decomposed. To overcome this problem, an approach has been proposed that uses algebraic extraction techniques to efficiently determine and quantify potential encodings. The results of the synthesis procedures are demonstrated on a range of combinational function blocks.", "paper_title": "Indicating combinational logic decomposition", "paper_id": "WOS:000292591600013"}