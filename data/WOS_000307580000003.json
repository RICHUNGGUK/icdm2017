{"auto_keywords": [{"score": 0.027993974324647976, "phrase": "jit-compiled_regions"}, {"score": 0.00481495049065317, "phrase": "instruction_set_simulation"}, {"score": 0.004785022360244881, "phrase": "embedded_multi-core_processors"}, {"score": 0.004580646169804186, "phrase": "embedded_systems"}, {"score": 0.004509780213218666, "phrase": "modern_mobile_phones"}, {"score": 0.004384960761826366, "phrase": "multi-core_processors"}, {"score": 0.003894772585498127, "phrase": "many-core_devices"}, {"score": 0.003870541730075597, "phrase": "today's_multi-core_machines"}, {"score": 0.0038106195546165574, "phrase": "heavy_demands"}, {"score": 0.0037516215763875225, "phrase": "simulation_engines"}, {"score": 0.0035245918797629804, "phrase": "dbt_simulators"}, {"score": 0.0034700069041302003, "phrase": "trace-based_dbt"}, {"score": 0.003300932921856956, "phrase": "region-based_dbt_simulators"}, {"score": 0.0032195006850887363, "phrase": "different_techniques"}, {"score": 0.0031205207286957013, "phrase": "innovative_approach"}, {"score": 0.003043526025781942, "phrase": "dbt."}, {"score": 0.0029963684169267406, "phrase": "jit_code_generator"}, {"score": 0.0028861422653675283, "phrase": "particular_thread"}, {"score": 0.0027712889576554556, "phrase": "thread-agnostic_code_generation"}, {"score": 0.0027368750412376215, "phrase": "thread-specific_code"}, {"score": 0.0025872113569311555, "phrase": "sharing_optimisation"}, {"score": 0.0025312385659888178, "phrase": "significant_performance_improvements"}, {"score": 0.0025154693498317757, "phrase": "multi-threaded_applications"}, {"score": 0.0023410164207985297, "phrase": "parallel_workloads"}, {"score": 0.0022760856906838814, "phrase": "overall_performance_improvement"}, {"score": 0.0021384143802602226, "phrase": "arc"}], "paper_keywords": ["Design", " experimentation", " performance", " Dynamic binary translation", " parallelization"], "paper_abstract": "Embedded systems, as typified by modern mobile phones, are already seeing a drive toward using multi-core processors. The number of cores will likely increase rapidly in the future. Engineers and researchers need to be able to simulate systems, as they are expected to be in a few generations time, running simulations of many-core devices on today's multi-core machines. These requirements place heavy demands on the scalability of simulation engines, the fastest of which have typically evolved from just-in-time (JIT) dynamic binary translators (DBT). Existing work aimed at parallelizing DBT simulators has focused exclusively on trace-based DBT, wherein linear execution traces or perhaps trees thereof are the units of translation. Region-based DBT simulators have not received the same attention and require different techniques than their trace-based cousins. In this paper we develop an innovative approach to scaling multi-core, embedded simulation through region-based DBT. We initially modify the JIT code generator of such a simulator to emit code that does not depend on a particular thread with its thread-specific context and is, therefore, thread-agnostic. We then demonstrate that this thread-agnostic code generation is comparable to thread-specific code with respect to performance, but also enables the sharing of JIT-compiled regions between different threads. This sharing optimisation, in turn, leads to significant performance improvements for multi-threaded applications. In fact, our results confirm that an average of 76% of all JIT-compiled regions can be shared between 128 threads in representative, parallel workloads. We demonstrate that this translates into an overall performance improvement by 1.44x on average and up to 2.40x across 12 multi-threaded benchmarks taken from the SPLASH-2 benchmark suite, targeting our high-performance multi-core DBT simulator for embedded ARC processors running on a 4-core Intel host machine.", "paper_title": "Efficiently Parallelizing Instruction Set Simulation of Embedded Multi-Core Processors Using Region-based Just-in-Time Dynamic Binary Translation", "paper_id": "WOS:000307580000003"}