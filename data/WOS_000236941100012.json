{"auto_keywords": [{"score": 0.011644010726567787, "phrase": "constraint_system"}, {"score": 0.007535301521712377, "phrase": "constraint_programming_techniques"}, {"score": 0.005385447449672353, "phrase": "boolean_constraint_system"}, {"score": 0.00481495049065317, "phrase": "constraint_programming"}, {"score": 0.004779085953614184, "phrase": "software_verification"}, {"score": 0.004569414098372132, "phrase": "software_engineering_process"}, {"score": 0.00453537012358554, "phrase": "numerous_techniques"}, {"score": 0.004500954126202215, "phrase": "boolean_constraints"}, {"score": 0.00448477700778838, "phrase": "formal_proofs"}, {"score": 0.004451360793577698, "phrase": "testing_methods"}, {"score": 0.0040691889755318155, "phrase": "test_data"}, {"score": 0.0037058116979705857, "phrase": "new_approach"}, {"score": 0.003154836091281154, "phrase": "considered_domains"}, {"score": 0.0030847461428168614, "phrase": "verification_process"}, {"score": 0.002883655046524374, "phrase": "control_flow_graph"}, {"score": 0.0028090313440881937, "phrase": "sat_solver"}, {"score": 0.0027057544777834086, "phrase": "boolean_solution"}, {"score": 0.002665511985052972, "phrase": "new_constraint_system"}, {"score": 0.00264561514767961, "phrase": "finite_domains"}, {"score": 0.0025868090345615197, "phrase": "latter_system"}, {"score": 0.0025578967205807843, "phrase": "operational_part"}, {"score": 0.002454615536099159, "phrase": "essential_role"}, {"score": 0.0024000447011533078, "phrase": "search_space"}, {"score": 0.002373214852820709, "phrase": "search_and_enumeration_processes"}, {"score": 0.0022018377054878534, "phrase": "powerful_tool"}, {"score": 0.002177218756653181, "phrase": "wrong_behaviours"}, {"score": 0.0021609589091422608, "phrase": "different_execution_paths"}, {"score": 0.0021208374456760447, "phrase": "first_experimental_results"}, {"score": 0.0021049977753042253, "phrase": "standard_benchmarks"}], "paper_keywords": [""], "paper_abstract": "Verification and validation are two of the most critical issues in the software engineering process. Numerous techniques ranging from formal proofs to testing methods have been used during the last years to verify the conformity of a program with its specification. Recently, constraint programming techniques have been used to generate test data. In this paper we investigate the capabilities of constraint programming techniques to verify the conformity of a program with its specification. We introduce here a new approach based on a transformation of both the program and its specification in a constraint system. To establish the conformity we demonstrate that the union of the constraint system derived from the program and the negation of the constraint system derived from its specification is inconsistent (for the considered domains of values). This verification process consists of three steps. First, we generate a Boolean constraint system which captures the information provided by the control flow graph. Then, we use a SAT solver to solve the Boolean constraint system. Finally, for each Boolean solution we build a new constraint system over finite domains and solve it. The latter system captures the operational part of the program and the specification. Boolean constraints play an essential role since they drastically reduce the search space before the search and enumeration processes start. Moreover, in the case where the program is not conforming with its specification, Boolean constraints provide a powerful tool for finding wrong behaviours in different execution paths of the program. First experimental results on standard benchmarks are very promising.", "paper_title": "Exploration of the capabilities of constraint programming for software verification", "paper_id": "WOS:000236941100012"}