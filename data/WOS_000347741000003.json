{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "actor_model"}, {"score": 0.005508538190380228, "phrase": "shared_state"}, {"score": 0.004731638279336065, "phrase": "concurrency_model"}, {"score": 0.00451642066363115, "phrase": "data_races"}, {"score": 0.004336115760817672, "phrase": "concurrent_programming"}, {"score": 0.004090901264701185, "phrase": "distributed_computations"}, {"score": 0.003904713104101532, "phrase": "concurrent_computations"}, {"score": 0.003837089839193524, "phrase": "single_shared_memory_machine"}, {"score": 0.003770633265791941, "phrase": "component_based_software"}, {"score": 0.003516079377293321, "phrase": "different_actors"}, {"score": 0.0034551632687788857, "phrase": "message-passing_concurrency"}, {"score": 0.0032031180198375283, "phrase": "actor_model_sacrifices"}, {"score": 0.0030750809317435304, "phrase": "parallel_access"}, {"score": 0.0024784363584530976, "phrase": "synchronization_views"}, {"score": 0.002351705899181029, "phrase": "semantic_properties"}, {"score": 0.002244494905883452, "phrase": "resulting_concurrency_model"}, {"score": 0.0021799789348982534, "phrase": "low-level_data_races"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Actor model", " Domains", " Synchronization", " Shared state", " Race-free mutation"], "paper_abstract": "The actor model is a concurrency model that avoids issues such as deadlocks and data races by construction, and thus facilitates concurrent programming. While it has mainly been used for expressing distributed computations, it is equally useful for modeling concurrent computations in a single shared memory machine. In component based software, the actor model lends itself to divide the components naturally over different actors and use message-passing concurrency for the interaction between these components. The tradeoff is that the actor model sacrifices expressiveness and efficiency with respect to parallel access to shared state. This paper gives an overview of the disadvantages of the actor model when trying to express shared state and then formulates an extension of the actor model to solve these issues. Our solution proposes domains and synchronization views to solve the issues without compromising on the semantic properties of the actor model. Thus, the resulting concurrency model maintains deadlock-freedom and avoids low-level data races. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Domains: Safe sharing among actors", "paper_id": "WOS:000347741000003"}