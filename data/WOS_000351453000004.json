{"auto_keywords": [{"score": 0.02508382763347649, "phrase": "blinddate"}, {"score": 0.00481495049065317, "phrase": "neighbor_discovery_protocol"}, {"score": 0.004686963264680882, "phrase": "efficient_neighbor_discovery_protocol"}, {"score": 0.004461051281091779, "phrase": "service_providers"}, {"score": 0.004342430078306461, "phrase": "intrinsic_constraints"}, {"score": 0.004303591748086452, "phrase": "wireless_devices"}, {"score": 0.004133055661437163, "phrase": "clock_synchronization"}, {"score": 0.004005083535629333, "phrase": "effective_and_efficient_neighbor_discovery_protocols"}, {"score": 0.0038119123317396954, "phrase": "neighbor_discovery_protocols"}, {"score": 0.003660788124282824, "phrase": "asynchronous_symmetry_neighbor_discovery_problem"}, {"score": 0.003595552309967789, "phrase": "potential_neighbor_devices"}, {"score": 0.003563370084662192, "phrase": "asynchronous_time_clocks"}, {"score": 0.0033459905006404207, "phrase": "efficient_protocol"}, {"score": 0.0033012036267224235, "phrase": "bouncing"}, {"score": 0.0032423089921154503, "phrase": "blind_date"}, {"score": 0.0032132782979796895, "phrase": "guaranteed_worst-case_performance"}, {"score": 0.0030307927228223883, "phrase": "small_fraction"}, {"score": 0.00295008998986066, "phrase": "time_slot_unit"}, {"score": 0.0028844769395018595, "phrase": "duty_cycle"}, {"score": 0.0027575842698911173, "phrase": "asynchronous_asymmetry_neighbor_discovery_problem"}, {"score": 0.0026720866990543744, "phrase": "duty_cycles"}, {"score": 0.0026481480455339055, "phrase": "potential_neighbors"}, {"score": 0.002543043781904587, "phrase": "extensive_experiments"}, {"score": 0.0024202176034746337, "phrase": "proposed_protocols"}, {"score": 0.0023241387549221408, "phrase": "existing_approaches"}, {"score": 0.002262209824105154, "phrase": "known_protocols"}, {"score": 0.0022019274077124795, "phrase": "better_worst-case_discovery_latency"}], "paper_keywords": ["Neighbor discovery", " energy efficiency", " latency"], "paper_abstract": "Many wireless applications urgently demand an efficient neighbor discovery protocol to build up bridges connecting user themselves or to some service providers. However, due to intrinsic constraints of wireless devices, e.g., limited energy and error of clock synchronization, there is still absence of effective and efficient neighbor discovery protocols in the literature. In this work, we propose neighbor discovery protocols for the following two problems. First, we study Asynchronous Symmetry Neighbor Discovery problem, in which potential neighbor devices with asynchronous time clocks but the same duty cycle aim to find each other. Second, we propose an efficient protocol (utilizing Bouncing strategy) named Blind Date with guaranteed worst-case performance 9/10 (1 + delta)(2) x(2) where d is a small fraction of the length of a time slot unit and 1/x is the duty cycle. Third, we extend this strategy to address Asynchronous Asymmetry Neighbor Discovery problem, in which both the time clock and the duty cycles of potential neighbors are considered to be heterogeneous. We conduct extensive experiments and simulations to examine the feasibility and efficiency of the proposed protocols, and results show that BlindDate greatly outperforms existing approaches in average-case. Compared with known protocols, BlindDate also achieves a better worst-case discovery latency bound (e.g., 10 percent performance gain comparing with Searchlight [1]).", "paper_title": "BlindDate: A Neighbor Discovery Protocol", "paper_id": "WOS:000351453000004"}