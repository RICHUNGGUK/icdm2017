{"auto_keywords": [{"score": 0.04940203756018457, "phrase": "distributed_systems"}, {"score": 0.006306427344761223, "phrase": "cache-based_model_checking"}, {"score": 0.00481495049065317, "phrase": "modular_software_model"}, {"score": 0.004420472010542188, "phrase": "concurrent_execution"}, {"score": 0.004077508669922702, "phrase": "traditional_testing"}, {"score": 0.003944112858235306, "phrase": "possible_program_execution"}, {"score": 0.0038515000499988673, "phrase": "model_checking"}, {"score": 0.0037432199549135826, "phrase": "concurrent_system"}, {"score": 0.0036727235025069828, "phrase": "possible_state"}, {"score": 0.0034037221513153566, "phrase": "modeling_language"}, {"score": 0.0031244995579170465, "phrase": "model_checkers"}, {"score": 0.003094920033010818, "phrase": "program_code"}, {"score": 0.0025954008219792337, "phrase": "execution_environment"}, {"score": 0.0024630345285372958, "phrase": "java_pathfinder"}, {"score": 0.0024281628678284825, "phrase": "java"}, {"score": 0.0023485549678832628, "phrase": "scalable_and_promising_technique"}, {"score": 0.0022608057001451414, "phrase": "larger_class"}, {"score": 0.0022076314894741394, "phrase": "checkpointing_tool"}, {"score": 0.0021454671611847507, "phrase": "verification_system"}, {"score": 0.0021251363422701446, "phrase": "experimental_results"}], "paper_keywords": ["Software model checking", " software verification", " distributed systems", " checkpointing"], "paper_abstract": "Distributed systems are complex, being usually composed of several subsystems running in parallel. Concurrent execution and inter-process communication in these systems are prone to errors that are difficult to detect by traditional testing, which does not cover every possible program execution. Unlike testing, model checking can detect such faults in a concurrent system by exploring every possible state of the system. However, most model-checking techniques require that a system be described in a modeling language. Although this simplifies verification, faults may be introduced in the implementation. Recently, some model checkers verify program code at runtime but tend to be limited to stand-alone programs. This paper proposes cache-based model checking, which relaxes this limitation to some extent by verifying one process at a time and running other processes in another execution environment. This approach has been implemented as an extension of Java PathFinder, a Java model checker. It is a scalable and promising technique to handle distributed systems. To support a larger class of distributed systems, a checkpointing tool is also integrated into the verification system. Experimental results on various distributed systems show the capability and scalability of cache-based model checking.", "paper_title": "Modular Software Model Checking for Distributed Systems", "paper_id": "WOS:000337950500004"}