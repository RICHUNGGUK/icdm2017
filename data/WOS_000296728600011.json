{"auto_keywords": [{"score": 0.02991821064924838, "phrase": "correct_use"}, {"score": 0.015021854922452057, "phrase": "embedded_systems"}, {"score": 0.012958015392274511, "phrase": "task_graphs"}, {"score": 0.012102396158681592, "phrase": "data_dependencies"}, {"score": 0.00481495049065317, "phrase": "coarse-grain_dependencies"}, {"score": 0.0047057084749407485, "phrase": "shared_memory_programs"}, {"score": 0.0045464538515249085, "phrase": "tight_constraints"}, {"score": 0.004443276312972159, "phrase": "response_time"}, {"score": 0.004147523799581407, "phrase": "timely_delivery"}, {"score": 0.0041001740903338834, "phrase": "new_designs"}, {"score": 0.004007083686875716, "phrase": "parallel_programs"}, {"score": 0.0038492126993451337, "phrase": "worst-case_execution_times"}, {"score": 0.0034512514926836667, "phrase": "source_code"}, {"score": 0.003334309053314909, "phrase": "compiler_analysis"}, {"score": 0.003277327351139926, "phrase": "actual_dependencies"}, {"score": 0.003130077012135034, "phrase": "potential_data_dependencies"}, {"score": 0.0028715299874549245, "phrase": "annotated_code"}, {"score": 0.002680114113899346, "phrase": "compile_time"}, {"score": 0.0024586427394152196, "phrase": "dynamic_array_bounds"}, {"score": 0.0021049977753042253, "phrase": "runtime_checks"}], "paper_keywords": ["Assertions", " data dependencies", " real-time and embedded systems", " scheduling and task partitioning"], "paper_abstract": "Designers of embedded systems face tight constraints on resources, response time and cost. The ability to analyze embedded systems is essential to timely delivery of new designs. Many analysis techniques model parallel programs as task graphs. Task graphs capture the worst-case execution times of individual program tasks and the data dependencies among these. This paper introduces two compiler directives which let programmers annotate source code with data dependencies among tasks. Compiler analysis overapproximates the actual dependencies among tasks. The directives help eliminate potential data dependencies that do not occur at runtime. This lets tools compute more accurate task graphs from the annotated code. The correct use of the directives cannot be verified at compile time. Therefore, the check for correct use is done at runtime-not unlike dynamic array bounds checking in many languages. The overhead of verifying the correct use of the directives was measured on a set of benchmarks on two platforms. The overhead of runtime checks was found to be negligible in all instances.", "paper_title": "Expressing Coarse-Grain Dependencies Among Tasks in Shared Memory Programs", "paper_id": "WOS:000296728600011"}