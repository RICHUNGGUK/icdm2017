{"auto_keywords": [{"score": 0.03347481202019757, "phrase": "alembic"}, {"score": 0.0045324756541157574, "phrase": "implicit_-_dereferencing_global_pointers"}, {"score": 0.004118587636081584, "phrase": "locality_-_poor_placement"}, {"score": 0.003995876175614403, "phrase": "excessive_and_even_unnecessary_communication"}, {"score": 0.003876806615011266, "phrase": "modern_pgas_languages"}, {"score": 0.003780288204042785, "phrase": "chapel"}, {"score": 0.003723536314736054, "phrase": "upc"}, {"score": 0.00363080961099728, "phrase": "data-layout_constraints"}, {"score": 0.003469676666252421, "phrase": "extra_burden"}, {"score": 0.002878785759716458, "phrase": "pgas_programs"}, {"score": 0.0024617483174454134, "phrase": "local_data"}, {"score": 0.002328739460403743, "phrase": "llvm"}, {"score": 0.0022706700510423954, "phrase": "irregular_application_kernels"}, {"score": 0.002158836285985314, "phrase": "hand-tuned_communication"}, {"score": 0.0021049977753042253, "phrase": "naive_compiler-generated_communication"}], "paper_keywords": ["Compilers", " Distributed systems", " Languages", " PGAS", " LLVM", " Locality", " Thread migration", " Continuation-passing style"], "paper_abstract": "Partitioned Global Address Space (PGAS) environments simplify writing parallel code for clusters because they make data movement implicit - dereferencing global pointers automatically moves data around. However, it does not free the programmer from needing to reason about locality - poor placement of data can lead to excessive and even unnecessary communication. For this reason, modern PGAS languages such as X10, Chapel, and UPC allow programmers to express data-layout constraints and explicitly move computation. This places an extra burden on the programmer, and is less effective for applications with limited or data-dependent locality (e.g., graph analytics). This paper proposes Alembic, a new static analysis that frees programmers from having to manually move computation to exploit locality in PGAS programs. It works by determining regions of code that access the same cluster node, then transforming the code to migrate parts of the execution to increase the proportion of accesses to local data. We implement the analysis and transformation for C++ in LLVM and show that in irregular application kernels, Alembic can achieve 82% of the performance of hand-tuned communication (for comparison, naive compiler-generated communication achieves only 13%).", "paper_title": "Alembic: Automatic Locality Extraction via Migration", "paper_id": "WOS:000348907400050"}