{"auto_keywords": [{"score": 0.04924934083174297, "phrase": "ssp"}, {"score": 0.00481495049065317, "phrase": "software_pipelining"}, {"score": 0.004773040022691547, "phrase": "single-dimension_software_pipelining"}, {"score": 0.004588891098290524, "phrase": "effective_software_pipelining_technique"}, {"score": 0.004548939310612501, "phrase": "multi-dimensional_loops"}, {"score": 0.004354315061804687, "phrase": "first_time"}, {"score": 0.004316396683332752, "phrase": "scheduling_methods"}, {"score": 0.004223032986655664, "phrase": "kernel_code"}, {"score": 0.0041316803676012155, "phrase": "multi-dimensional_nature"}, {"score": 0.004024651422626329, "phrase": "scheduling_problem"}, {"score": 0.0038862297330905836, "phrase": "traditional_modulo_scheduling"}, {"score": 0.0037855348847339655, "phrase": "multiple_subkernels"}, {"score": 0.003752550907120244, "phrase": "initiation_rates"}, {"score": 0.0037198532511087566, "phrase": "specific_scheduling_constraints"}, {"score": 0.0035761913760242697, "phrase": "execution_time"}, {"score": 0.003529543381704363, "phrase": "final_schedule"}, {"score": 0.0033197446406648626, "phrase": "level_method"}, {"score": 0.0032336801561165113, "phrase": "loop_level_order"}, {"score": 0.0030281251520610604, "phrase": "already_scheduled_levels"}, {"score": 0.002898378776839434, "phrase": "different_loop_levels"}, {"score": 0.002690406375639144, "phrase": "level_mechanism"}, {"score": 0.0026552818091968543, "phrase": "innermost_level"}, {"score": 0.0026206146061151917, "phrase": "flat_solution"}, {"score": 0.002606368891834785, "phrase": "nas"}, {"score": 0.002566700680460905, "phrase": "livermore"}, {"score": 0.002530359917257626, "phrase": "huff's_modulo_scheduling"}, {"score": 0.002475532161577715, "phrase": "single_loops"}, {"score": 0.002443206010337041, "phrase": "special_case"}, {"score": 0.0023798115577749225, "phrase": "scheduling_constraint"}, {"score": 0.0022678201262721323, "phrase": "proposed_approaches"}, {"score": 0.0021705796895687864, "phrase": "loop_nests"}], "paper_keywords": [""], "paper_abstract": "Single-dimension Software Pipelining (SSP) has been proposed as an effective software pipelining technique for multi-dimensional loops [16]. This paper introduces for the first time the scheduling methods that actually produce the kernel code. Because of the multi-dimensional nature of the problem, the scheduling problem is more complex and challenging than with traditional modulo scheduling. The scheduler must handle multiple subkernels and initiation rates under specific scheduling constraints, while producing a solution that minimizes the execution time of the final schedule. In this paper three approaches are proposed: the level-by-level method, which schedules operations in loop level order, starting from the innermost, and does not let other operations interfere with the already scheduled levels, the flat method, which schedules operations from different loop levels with the same priority, and the hybrid method, which uses the level-by-level mechanism for the innermost level and the flat solution for the other levels. The methods subsume Huff's modulo scheduling [8] for single loops as a special case. We also break a scheduling constraint introduced in earlier publications and allow for a more compact kernel. The proposed approaches were implemented in the Open64/ORC compiler, and evaluated on loop nests from the Livermore, SPEC200 and NAS benchmarks.", "paper_title": "Multi-dimensional kernel generation for loop nest Software Pipelining", "paper_id": "WOS:000241469500028"}