{"auto_keywords": [{"score": 0.036135424430821815, "phrase": "functional_graphs"}, {"score": 0.015429611993466246, "phrase": "eds"}, {"score": 0.00481495049065317, "phrase": "model-based_mutation_testing"}, {"score": 0.004754828422696271, "phrase": "event-driven_software"}, {"score": 0.004564544414530739, "phrase": "incoming_events"}, {"score": 0.004535950496583731, "phrase": "web_and_desktop_applications"}, {"score": 0.0044792964927609456, "phrase": "user-initiated_events"}, {"score": 0.0044372687709897446, "phrase": "graphical_user_interface"}, {"score": 0.004354387464909719, "phrase": "embedded_software"}, {"score": 0.0041408296624638125, "phrase": "testing_eds"}, {"score": 0.00411487907113509, "phrase": "great_challenges"}, {"score": 0.00408909044445249, "phrase": "software_testers"}, {"score": 0.003937704225837731, "phrase": "huge_number"}, {"score": 0.003913021620260308, "phrase": "possible_event_sequences"}, {"score": 0.003839894670436311, "phrase": "eds's_state_space"}, {"score": 0.0037093463810112656, "phrase": "new_six-stage_testing_procedure"}, {"score": 0.0036860898876135534, "phrase": "event-driven_web_applications"}, {"score": 0.0035384237846107793, "phrase": "testing_procedure"}, {"score": 0.003312238122534935, "phrase": "coverage_criteria"}, {"score": 0.0032811244238035455, "phrase": "test_paths"}, {"score": 0.0032503020402680385, "phrase": "event_sequences"}, {"score": 0.0032197682621899703, "phrase": "longer_ones"}, {"score": 0.0031595558075901164, "phrase": "test_cases"}, {"score": 0.003032918641059871, "phrase": "fault_detection_density"}, {"score": 0.0028839835971201846, "phrase": "unique_fault"}, {"score": 0.0027858433744614767, "phrase": "prioritized_test_cases"}, {"score": 0.002725131817708033, "phrase": "unique_faults"}, {"score": 0.0026910337912859268, "phrase": "suggested_test_cases"}, {"score": 0.0026657398039253008, "phrase": "sample_real-world_web_application"}, {"score": 0.0024873549393945424, "phrase": "requirements_document"}, {"score": 0.002433132434417479, "phrase": "infeasible_test_cases"}, {"score": 0.002372606268769639, "phrase": "\"add_edge\"_operator"}, {"score": 0.002320879380255764, "phrase": "suggested_testing_procedure"}, {"score": 0.0021587119099287337, "phrase": "testing_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Event-driven software", " Web application", " Event", " Test case generation", " Functional graph", " Mutation analysis"], "paper_abstract": "Context: Event-Driven Software (EDS) is a class of software whose behavior is driven by incoming events. Web and desktop applications that respond to user-initiated events on their Graphical User Interface (GUI), or embedded software responding to events and signals received from the equipment in its operating environment are examples of EDS. Testing EDS poses great challenges to software testers. One of these challenges is the need to generate a huge number of possible event sequences that could sufficiently cover the EDS's state space. Objective: In this paper, we introduce a new six-stage testing procedure for event-driven web applications to overcome EDS testing challenges. Method: The stages of the testing procedure include dividing the application based on its structure, creating functional graphs for each section, creating mutants from functional graphs, choosing coverage criteria to produce test paths, merging event sequences to make longer ones, and deriving and running test cases. We have analyzed our proposed testing procedure with the help of four metrics consisting of Fault Detection Density (FDD), Fault Detection Effectiveness (FDE), Mutation Score, and Unique Fault. Results: Using this procedure, we have prepared prioritized test cases and also discovered a list of unique faults by running the suggested test cases on a sample real-world web application called Academic E-mail System. Conclusion: We propose that our suggested testing procedure has some advantages such as creating functional graphs with requirements document, resolving the problem of removing infeasible test cases with these graphs and conditions on the \"add edge\" operator before creating mutants. But the suggested testing procedure, like any other method, had some drawbacks. Because most of the stages in the approach were performed manually, the testing time was increased. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Event-driven web application testing based on model-based mutation testing", "paper_id": "WOS:000362604600009"}