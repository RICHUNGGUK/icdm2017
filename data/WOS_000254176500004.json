{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "inconsistent_databases"}, {"score": 0.004478308876320956, "phrase": "consistent_query_answering"}, {"score": 0.004397875849247165, "phrase": "general_case"}, {"score": 0.004225950334493496, "phrase": "exponential_complexity"}, {"score": 0.004195418010131832, "phrase": "polynomial_techniques"}, {"score": 0.0041051328120736575, "phrase": "restricted_forms"}, {"score": 0.004016782710006123, "phrase": "functional_dependencies"}, {"score": 0.003831801113154043, "phrase": "\"approximate\"_consistent_answers"}, {"score": 0.003642070943285037, "phrase": "wide_class"}, {"score": 0.0035123375166604344, "phrase": "datalog"}, {"score": 0.003461702544605219, "phrase": "proposed_approach"}, {"score": 0.003399466007862412, "phrase": "repairing_strategy"}, {"score": 0.0033748847621075536, "phrase": "update_operations"}, {"score": 0.0033383446480705894, "phrase": "undefined_truth_value"}, {"score": 0.0030157628075954588, "phrase": "three-valued_database"}, {"score": 0.0029722900280316216, "phrase": "specified_constraints"}, {"score": 0.002897710777957041, "phrase": "new_semantics"}, {"score": 0.0027943943921568456, "phrase": "constraint_satisfaction"}, {"score": 0.0027441220799352926, "phrase": "three-valued_databases"}, {"score": 0.002675252546913683, "phrase": "intuitive_meaning"}, {"score": 0.0026366753045215558, "phrase": "three-valued_logic"}, {"score": 0.0025334249463305875, "phrase": "\"approximate\"_consistent_query_answers"}, {"score": 0.0024253827365474734, "phrase": "unique_repair"}, {"score": 0.0023135183406982414, "phrase": "\"_all_the_possible_repairs"}, {"score": 0.0021049977753042253, "phrase": "classical_two-valued_semantics"}], "paper_keywords": ["three-valued semantics", " querying", " databases"], "paper_abstract": "The problem of managing and querying inconsistent databases has been deeply investigated in the last few years. As the problem of consistent query answering is hard in the general case, most of the techniques proposed so far have an exponential complexity. Polynomial techniques have been proposed only for restricted forms of constraints (such as functional dependencies) and queries. In this paper, a technique for computing \"approximate\" consistent answers in polynomial time is proposed, which works in the presence of a wide class of constraints (namely, full constraints) and Datalog queries. The proposed approach is based on a repairing strategy where update operations assigning an undefined truth value to the \"reliability\" of tuples are allowed, along with updates inserting or deleting tuples. The result of a repair can be viewed as a three-valued database which satisfies the specified constraints. In this regard, a new semantics (namely, partial semantics) is introduced for constraint satisfaction in the context of three-valued databases, which aims at capturing the intuitive meaning of constraints under three-valued logic. It is shown that, in order to compute \"approximate\" consistent query answers, it suffices to evaluate queries by taking into account a unique repair (called deterministic repair), which in some sense \"summarizes\" all the possible repairs. The so obtained answers are \"approximate\" in the sense that are safe (true and false atoms in the answers are, respectively, true and false under the classical two-valued semantics), but not complete.", "paper_title": "A three-valued semantics for querying and repairing inconsistent databases", "paper_id": "WOS:000254176500004"}