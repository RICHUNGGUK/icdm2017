{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "pragmatic_reuse_tasks"}, {"score": 0.024039117451172657, "phrase": "reused_test_cases"}, {"score": 0.004749106104067268, "phrase": "existing_test_suites"}, {"score": 0.0047057084749407485, "phrase": "traditional_industrial_practice"}, {"score": 0.004620093797504386, "phrase": "ad_hoc_reuse"}, {"score": 0.004577869668211548, "phrase": "source_code"}, {"score": 0.004332471656145115, "phrase": "important_role"}, {"score": 0.0042928648367867835, "phrase": "disciplined_software_development"}, {"score": 0.004253618550301311, "phrase": "pragmatic_reuse"}, {"score": 0.004044064541716598, "phrase": "systematic_support"}, {"score": 0.0038802832668554457, "phrase": "reused_code"}, {"score": 0.003757480190200645, "phrase": "target_system"}, {"score": 0.0037060428445111664, "phrase": "recent_work"}, {"score": 0.003349670229755675, "phrase": "novel_approach"}, {"score": 0.0031991799574455555, "phrase": "relevant_portions"}, {"score": 0.0031553611552558986, "phrase": "test_suite"}, {"score": 0.0031121406603482112, "phrase": "pragmatically_reused_code"}, {"score": 0.002985988377995789, "phrase": "relevant_constraints"}, {"score": 0.002945081009084692, "phrase": "originating_system"}, {"score": 0.0027361626349903744, "phrase": "formal_experiment"}, {"score": 0.002711109302199029, "phrase": "experienced_developers"}, {"score": 0.0025537472239953807, "phrase": "standard_ide"}, {"score": 0.0023725232579531273, "phrase": "manual_approach"}, {"score": 0.002318566141177149, "phrase": "task_completion_time"}, {"score": 0.002286781334850213, "phrase": "instruction_coverage"}], "paper_keywords": ["pragmatic software reuse", " test suite reuse", " semi-automatic", " lightweight", " pragmatic-reuse plan", " Skipper"], "paper_abstract": "Traditional industrial practice often involves the ad hoc reuse of source code that was not designed for that reuse. Such pragmatic reuse tasks play an important role in disciplined software development. Pragmatic reuse has been seen as problematic due to a lack of systematic support, and an inability to validate that the reused code continues to operate correctly within the target system. Although recent work has successfully systematized support for pragmatic reuse tasks, the issue of validation remains unaddressed. In this paper, we present a novel approach and tool to semi-automatically reuse and transform relevant portions of the test suite associated with pragmatically reused code, as a means to validate that the relevant constraints from the originating system continue to hold, while minimizing the burden on the developer. We conduct a formal experiment with experienced developers, to compare the application of our approach versus the use of a standard IDE (the 'manual approach'). We find that, relative to the manual approach, our approach: reduces task completion time; improves instruction coverage by the reused test cases; and improves the correctness of the reused test cases. Copyright (C) 2012 John Wiley & Sons, Ltd.", "paper_title": "Validating pragmatic reuse tasks by leveraging existing test suites", "paper_id": "WOS:000322712200002"}