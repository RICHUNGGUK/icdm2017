{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "branch_prediction-directed"}, {"score": 0.04818691642695348, "phrase": "cache_locking"}, {"score": 0.004671588539217021, "phrase": "embedded_systems"}, {"score": 0.004555371402128666, "phrase": "cache_management_technique"}, {"score": 0.004419703921314433, "phrase": "locked_cache_contents"}, {"score": 0.004245051445971095, "phrase": "cache_access_predictability"}, {"score": 0.004202472962684885, "phrase": "worst-case_execution_time"}, {"score": 0.004077272409331917, "phrase": "static_cache"}, {"score": 0.004056769841308405, "phrase": "locking_methods"}, {"score": 0.003916098498242888, "phrase": "average-case_execution_time"}, {"score": 0.0036676174658755683, "phrase": "dynamic_cache_locking"}, {"score": 0.003540392285585644, "phrase": "system_performance"}, {"score": 0.0035048567587934254, "phrase": "cache_conflict"}, {"score": 0.0034003686971964707, "phrase": "proposed_approach"}, {"score": 0.0033492947290751996, "phrase": "control_flow_graph"}, {"score": 0.003216804708106142, "phrase": "disjoint_execution_regions"}, {"score": 0.0030278017562213265, "phrase": "locking_profit"}, {"score": 0.002878785759716458, "phrase": "compilation_time"}, {"score": 0.0027788478707700274, "phrase": "branch_predictions"}, {"score": 0.002750934994181092, "phrase": "locking_routines"}, {"score": 0.0026823700218343506, "phrase": "small_high-speed_buffer"}, {"score": 0.0026155094974689595, "phrase": "locking_contents"}, {"score": 0.0025374674652885354, "phrase": "specific_execution_points"}, {"score": 0.0025119730908615104, "phrase": "program_execution"}, {"score": 0.002486734224234698, "phrase": "experimental_results"}, {"score": 0.002437012847684331, "phrase": "proposed_bpdcl_method"}, {"score": 0.002400373755068185, "phrase": "average_improvement"}, {"score": 0.0022706700510423954, "phrase": "rate_reduction"}, {"score": 0.0021479597698614373, "phrase": "static_locking_method"}, {"score": 0.0021049977753042253, "phrase": "dynamic_locking_method"}], "paper_keywords": ["Design", " Algorithms", " Performance", " Dynamic cache locking", " branch prediction", " instruction cache", " execution region partitioning", " system performance"], "paper_abstract": "Cache locking is a cache management technique to preclude the replacement of locked cache contents. Cache locking is often adopted to improve cache access predictability in Worst-Case Execution Time (WCET) analysis. Static cache locking methods have been proposed recently to improve Average-Case Execution Time (ACET) performance. This article presents an approach, Branch Prediction-directed Dynamic Cache Locking (BPDCL), to improve system performance through cache conflict miss reduction. In the proposed approach, the control flow graph of a program is first partitioned into disjoint execution regions, then memory blocks worth locking are determined by calculating the locking profit for each region. These two steps are conducted during compilation time. At runtime, directed by branch predictions, locking routines are prefetched into a small high-speed buffer. The predetermined cache locking contents are loaded and locked at specific execution points during program execution. Experimental results show that the proposed BPDCL method exhibits an average improvement of 25.9%, 13.8%, and 8.0% on cache miss rate reduction in comparison to cases with no cache locking, the static locking method, and the dynamic locking method, respectively.", "paper_title": "Branch Prediction-Directed Dynamic Instruction Cache Locking for Embedded Systems", "paper_id": "WOS:000346416300012"}