{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "disk_rouing"}, {"score": 0.0047323590206695305, "phrase": "disk_mirroring_or_raid_level"}, {"score": 0.004454237726525018, "phrase": "single_disk_failures"}, {"score": 0.004340081802944066, "phrase": "high_storage_overhead"}, {"score": 0.004174287115855492, "phrase": "storage_cost"}, {"score": 0.0040672766251859975, "phrase": "disk_capacities"}, {"score": 0.00374610869916551, "phrase": "important_advantage"}, {"score": 0.003602922164562919, "phrase": "disk_access_bandwidth"}, {"score": 0.003510507340837656, "phrase": "efficient_routing"}, {"score": 0.003480230347985338, "phrase": "read_requests"}, {"score": 0.0034204548167213545, "phrase": "local_disk_scheduling"}, {"score": 0.0030560920414081645, "phrase": "independent_queues-iq_method"}, {"score": 0.002913837945508097, "phrase": "shared_quette-sq_method"}, {"score": 0.0026033013834547507, "phrase": "random_number-driven_simulation"}, {"score": 0.0024078737745407614, "phrase": "local_disk_scheduling_policy"}, {"score": 0.0023767561522363367, "phrase": "sq_method"}, {"score": 0.0023562342764987254, "phrase": "resource_sharing"}, {"score": 0.0022562464662197867, "phrase": "based_routing"}, {"score": 0.0021049977753042253, "phrase": "disk_drives"}], "paper_keywords": ["storage systems", " mirrored disks", " RAID level 1", " routing of requests", " affinity based routing", " disk scheduling", " shortest access time first"], "paper_abstract": "Disk mirroring or RAID level 1 stores the same data twice, on two independent disks, to ensure that all single disk failures can be tolerated. This high storage overhead is acceptable in view of the drop in storage cost per gigabyte and rapidly increasing disk capacities. Disk access time, on the other hand, is improving at a very slow pace, so that another important advantage of disk mirroring is the doubling of the disk access bandwidth in processing read requests. Efficient routing of read requests to disks and local disk scheduling can be used to improve performance even further. We are primarily concerned with two RAID I configurations: (i) source-initiated routing with the independent queues-IQ method; (ii) destination-initiated routing with the shared quette-SQ method. Static, dynamic, and affinity-based (AB) routing methods are used to distribute requests with the IQ method. We compare the performance of various IQ and SQ based routing policies using a random number-driven simulation. While there is some improvement in performance with the more sophisticated routing policies, performance is dominated by the local disk scheduling policy. The SQ method allows resource sharing, so that it tends to outperform the IQ based routing, but it requires the scheduler to keep, track of the state of the disk drives. As a further means to improve performance, we consider the effect of prioritizing reads with respect to writes, transposed data allocation, and replicating data more than twice.", "paper_title": "Mirrored disk rouing and scheduling", "paper_id": "WOS:000242007500008"}