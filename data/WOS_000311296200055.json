{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "reasonable_interposition"}, {"score": 0.004666228956744244, "phrase": "run-time_support"}, {"score": 0.004569630374630379, "phrase": "primitive_operations"}, {"score": 0.004498490110526062, "phrase": "function_calls"}, {"score": 0.004451676867747938, "phrase": "array_access"}, {"score": 0.0043367547691560175, "phrase": "structure_field"}, {"score": 0.0038854765143440965, "phrase": "interposing_code"}, {"score": 0.0037066895459425824, "phrase": "abstraction_mechanisms"}, {"score": 0.0035920758080335655, "phrase": "compiler_analyses"}, {"score": 0.003286162779730436, "phrase": "racket"}, {"score": 0.003102195256794215, "phrase": "racket's_contract_system"}, {"score": 0.0030062165552187086, "phrase": "mutable_data"}, {"score": 0.002898029292484965, "phrase": "api"}, {"score": 0.0027936239349923464, "phrase": "large_data_structures"}, {"score": 0.0025156683465194967, "phrase": "lower_overhead"}, {"score": 0.002476424729269258, "phrase": "contract_wrappers"}, {"score": 0.0024377918036784336, "phrase": "object_equality"}, {"score": 0.002337684811187166, "phrase": "gradual_typing_systems"}, {"score": 0.002289180040240783, "phrase": "typed_racket"}, {"score": 0.002183684303511462, "phrase": "untyped_code"}, {"score": 0.0021383680500215267, "phrase": "mutable_values"}, {"score": 0.0021049977753042253, "phrase": "typed_and_untyped_modules"}], "paper_keywords": ["Proxies", " interposition", " intercession", " contracts"], "paper_abstract": "Chaperones and impersonators provide run-time support for interposing on primitive operations such as function calls, array access and update, and structure field access and update. Unlike most interposition support, chaperones and impersonators are restricted so that they constrain the behavior of the interposing code to reasonable interposition, which in practice preserves the abstraction mechanisms and reasoning that programmers and compiler analyses rely on. Chaperones and impersonators are particularly useful for implementing contracts, and our implementation in Racket allows us to improve both the expressiveness and the performance of Racket's contract system. Specifically, contracts on mutable data can be enforced without changing the API to that data; contracts on large data structures can be checked lazily on only the accessed parts of the structure; contracts on objects and classes can be implemented with lower overhead; and contract wrappers can preserve object equality where appropriate. With this extension, gradual typing systems, such as Typed Racket, that rely on contracts for interoperation with untyped code can now pass mutable values safely between typed and untyped modules.", "paper_title": "Chaperones and Impersonators: Run-time Support for Reasonable Interposition", "paper_id": "WOS:000311296200055"}