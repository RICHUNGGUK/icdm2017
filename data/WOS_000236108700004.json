{"auto_keywords": [{"score": 0.03734802881411346, "phrase": "large_class"}, {"score": 0.00481495049065317, "phrase": "inherent_weakness"}, {"score": 0.004743806810821005, "phrase": "conditional_primitives"}, {"score": 0.0046390482426405324, "phrase": "well-known_primitive_operations"}, {"score": 0.0038510053729959074, "phrase": "wait-free_manner"}, {"score": 0.0032444113660668743, "phrase": "single-writer_snapshots"}, {"score": 0.0027535633837592597, "phrase": "base_objects"}, {"score": 0.0025178072071268534, "phrase": "implemented_object"}, {"score": 0.002354302193867031, "phrase": "starvation-free_mutual_exclusion"}, {"score": 0.0021850254717637172, "phrase": "wait-free_implementations"}, {"score": 0.002136651746284283, "phrase": "closely_related_class"}, {"score": 0.0021049977753042253, "phrase": "one-time_objects"}], "paper_keywords": ["conditionals", " space lower bounds", " object implementations", " mutual exclusion"], "paper_abstract": "Some well-known primitive operations, such as compare-and-swap, can be used, together with read and write, to implement any object in a wait-free manner. However, this paper shows that, for a large class of objects, including counters, queues, stacks, and single-writer snapshots, wait-free implementations using only these primitive operations and a large class of other primitive operations cannot be space efficient: the number of base objects required is at least linear in the number of processes that share the implemented object. The same lower bounds are obtained for implementations of starvation-free mutual exclusion using only primitive operations from this class. For wait-free implementations of a closely related class of one-time objects, lower bounds on the tradeoff between time and space are presented.", "paper_title": "On the inherent weakness of conditional primitives", "paper_id": "WOS:000236108700004"}