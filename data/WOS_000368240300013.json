{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "binary_lambda_calculus"}, {"score": 0.004336115760817672, "phrase": "combinatory_logic"}, {"score": 0.004236321075918639, "phrase": "john_tromp"}, {"score": 0.004090901264701185, "phrase": "simple_way"}, {"score": 0.003996727479807572, "phrase": "encoding_lambda_calculus_terms"}, {"score": 0.0033952989364738353, "phrase": "binary_strings"}, {"score": 0.0031660031870090434, "phrase": "lambda_terms"}, {"score": 0.0023380300046435187, "phrase": "second_part"}, {"score": 0.002154693685426657, "phrase": "random_lambda_terms"}, {"score": 0.0021049977753042253, "phrase": "boltzmann_samplers"}], "paper_keywords": [""], "paper_abstract": "In a paper, entitled Binary lambda calculus and combinatory logic, John Tromp presents a simple way of encoding lambda calculus terms as binary sequences. In what follows, we study the numbers of binary strings of a given size that represent lambda terms and derive results from their generating functions, especially that the number of terms of size n grows roughly like 1.963447954...(n). In a second part we use this approach to generate random lambda terms using Boltzmann samplers.", "paper_title": "Counting and generating terms in the binary lambda calculus", "paper_id": "WOS:000368240300013"}