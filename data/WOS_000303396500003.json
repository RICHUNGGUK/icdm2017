{"auto_keywords": [{"score": 0.02666664503291797, "phrase": "dynamic_programming"}, {"score": 0.00481495049065317, "phrase": "counting_knapsack_solutions."}, {"score": 0.004739056045644449, "phrase": "n_elements"}, {"score": 0.004664352260912174, "phrase": "nonnegative_integer_weights"}, {"score": 0.003947358102140903, "phrase": "classic_knapsack_problem"}, {"score": 0.0037634608487353183, "phrase": "distinct_subsets"}, {"score": 0.00347574024760684, "phrase": "deterministic_algorithm"}, {"score": 0.0032355864829403413, "phrase": "relative_error"}, {"score": 0.002429451930463481, "phrase": "randomized_polynomial-time_approximation_schemes"}, {"score": 0.002334651949919468, "phrase": "morris"}, {"score": 0.002297745898743975, "phrase": "sinclair"}, {"score": 0.0022614266476954467, "phrase": "markov_chain"}, {"score": 0.0022434880661725493, "phrase": "monte_carlo_techniques"}, {"score": 0.0021731601844813624, "phrase": "dyer"}, {"score": 0.0021049977753042253, "phrase": "rejection_sampling"}], "paper_keywords": ["approximate counting", " knapsack", " dynamic programming"], "paper_abstract": "Given n elements with nonnegative integer weights w(1),..., w(n) and an integer capacity C, we consider the counting version of the classic knapsack problem: find the number of distinct subsets whose weights add up to at most the given capacity. We give a deterministic algorithm that estimates the number of solutions to within relative error 1 +/-epsilon in time polynomial in n and 1/epsilon ( fully polynomial approximation scheme). More precisely, our algorithm takes time O(n(3)epsilon(-1) log(n/epsilon)). Our algorithm is based on dynamic programming. Previously, randomized polynomial-time approximation schemes were known first by Morris and Sinclair via Markov chain Monte Carlo techniques and subsequently by Dyer via dynamic programming and rejection sampling.", "paper_title": "A DETERMINISTIC POLYNOMIAL-TIME APPROXIMATION SCHEME FOR COUNTING KNAPSACK SOLUTIONS", "paper_id": "WOS:000303396500003"}