{"auto_keywords": [{"score": 0.03999449666921275, "phrase": "bop"}, {"score": 0.00481495049065317, "phrase": "continuous_speculative_program"}, {"score": 0.004642091843977788, "phrase": "software"}, {"score": 0.004152502093643003, "phrase": "coarse-grained_parallelism"}, {"score": 0.00405127920820053, "phrase": "large_sequential_code"}, {"score": 0.0035808664384880213, "phrase": "software_speculative_parallelization"}, {"score": 0.003244050414264445, "phrase": "possibly_parallel_regions"}, {"score": 0.002797121441432477, "phrase": "ppr_instances"}, {"score": 0.002728847267539957, "phrase": "unix_processes"}, {"score": 0.002629539710839523, "phrase": "short_paper"}, {"score": 0.0025338369486914364, "phrase": "new_run-time_support"}, {"score": 0.002295277579105177, "phrase": "available_parallelism"}, {"score": 0.002157697367447098, "phrase": "ppr_task_size"}, {"score": 0.0021049977753042253, "phrase": "processor_speed"}], "paper_keywords": ["Languages", " Performance", " Software speculative parallelization"], "paper_abstract": "This paper addresses the problem of extracting coarse-grained parallelism from large sequential code. It builds on BOP, a system for software speculative parallelization. BOP lets a user to mark possibly parallel regions (PPR) in a program and at run-time speculatively executes PPR instances using Unix processes. This short paper presents a new run-time support called continuous speculation, which fully utilizes available parallelism to tolerate differences in PPR task size and processor speed.", "paper_title": "Continuous Speculative Program Parallelization in Software", "paper_id": "WOS:000280548100035"}