{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "balanced_bloom_filters"}, {"score": 0.004771435352180973, "phrase": "bloom_filters"}, {"score": 0.004706895428234964, "phrase": "network_devices"}, {"score": 0.004317848984770719, "phrase": "bloom_filters_hash_elements"}, {"score": 0.0041637779492720295, "phrase": "high_memory-access_rates"}, {"score": 0.003978866233891427, "phrase": "bloom_filter_elements"}, {"score": 0.003925004567341077, "phrase": "single_memory_block_yields"}, {"score": 0.003907212558276185, "phrase": "high_false_positive_rates"}, {"score": 0.0037336520904376687, "phrase": "load-balancing_schemes"}, {"score": 0.0036332251283046997, "phrase": "memory_block"}, {"score": 0.0035515951985356374, "phrase": "optional_overflow_list"}, {"score": 0.0034876091188625535, "phrase": "better_false_positive_rates"}, {"score": 0.003424771860049617, "phrase": "high_memory-access_efficiency"}, {"score": 0.0032135959043774085, "phrase": "fundamental_access-constrained_balancing_problem"}, {"score": 0.003015401937358271, "phrase": "average_and_instantaneous_constraints"}, {"score": 0.002947611960613497, "phrase": "memory_accesses"}, {"score": 0.0028813415821988156, "phrase": "current_load"}, {"score": 0.0027159094186967247, "phrase": "new_access-efficient_bloom_filter_scheme"}, {"score": 0.002536763634539386, "phrase": "worst-case_operation_cost"}, {"score": 0.0024349853033241663, "phrase": "overflow_list_size"}, {"score": 0.002316105585203396, "phrase": "false_positive_rate"}, {"score": 0.0021632743048552536, "phrase": "single_memory_block"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["High-speed networks", " Bloom Filters", " Load-balancing"], "paper_abstract": "Bloom Filters particularly suit network devices, because of their low theoretical memory-access rates. However, in practice, since memory is often divided into blocks and Bloom Filters hash elements into several arbitrary memory blocks, Bloom Filters actually need high memory-access rates. Unfortunately, a simple solution of hashing all Bloom Filter elements into a single memory block yields high false positive rates. In this paper, we propose to implement load-balancing schemes for the choice of the memory block, along with an optional overflow list, resulting in better false positive rates while keeping a high memory-access efficiency. To study this problem, we define, analyze and solve a fundamental access-constrained balancing problem, where incoming elements need to be optimally balanced across resources while satisfying average and instantaneous constraints on the number of memory accesses associated with checking the current load of the resources. We then use these results and suggest a new access-efficient Bloom Filter scheme in networking devices, called the Balanced Bloom Filter. Finally, we show that with a worst-case operation cost of up to 3 memory accesses for each element and an overflow list size of at most 0.5% of the elements, our scheme can reduce the false positive rate by up to two orders of magnitude compared to a filter that hashes all elements into a single memory block. (c) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Access-efficient Balanced Bloom Filters", "paper_id": "WOS:000315366500002"}