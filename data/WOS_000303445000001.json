{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "obfuscating_programs"}, {"score": 0.004745665541429529, "phrase": "obfuscator_o"}, {"score": 0.004491313367627919, "phrase": "new_program"}, {"score": 0.004153041453795458, "phrase": "wide_variety"}, {"score": 0.004129017936622578, "phrase": "cryptographic_and_complexity-theoretic_applications"}, {"score": 0.004046020290832207, "phrase": "homomorphic_encryption"}, {"score": 0.0040226133433241065, "phrase": "complexity-theoretic_analogues"}, {"score": 0.003999341265409082, "phrase": "rice's_theorem"}, {"score": 0.0038513073787989054, "phrase": "\"unintelligibility\"_condition"}, {"score": 0.0037411604449359794, "phrase": "\"virtual_black_box"}, {"score": 0.003399466007862412, "phrase": "theoretical_investigation"}, {"score": 0.0031431690368229443, "phrase": "efficient_programs"}, {"score": 0.0030179530101642612, "phrase": "efficient_program_p"}, {"score": 0.002948646905471742, "phrase": "program_p"}, {"score": 0.002880927789104712, "phrase": "\"_source_code"}, {"score": 0.0026791410961432677, "phrase": "efficient_algorithm"}, {"score": 0.002542642270762272, "phrase": "negligible_probability"}, {"score": 0.002455519317224794, "phrase": "even_obfuscators"}, {"score": 0.002385196172577967, "phrase": "polynomial_time"}, {"score": 0.0021420294823879292, "phrase": "\"unobfuscatable\"_signature_schemes"}, {"score": 0.0021049977753042253, "phrase": "pseudorandom_function_families"}], "paper_keywords": ["Theory", " Complexity theory", " cryptography", " homomorphic encryption", " pseudorandom functions", " Rice's Theorem", " software protection", " software watermarking", " statistical zero knowledge"], "paper_abstract": "Informally, an obfuscator O is an (efficient, probabilistic) \"compiler\" that takes as input a program (or circuit) P and produces a new program O(P) that has the same functionality as P yet is \"unintelligible\" in some sense. Obfuscators, if they exist, would have a wide variety of cryptographic and complexity-theoretic applications, ranging from software protection to homomorphic encryption to complexity-theoretic analogues of Rice's theorem. Most of these applications are based on an interpretation of the \"unintelligibility\" condition in obfuscation as meaning that O(P) is a \"virtual black box,\" in the sense that anything one can efficiently compute given O(P), one could also efficiently compute given oracle access to P. In this work, we initiate a theoretical investigation of obfuscation. Our main result is that, even under very weak formalizations of the above intuition, obfuscation is impossible. We prove this by constructing a family of efficient programs P that are unobfuscatable in the sense that (a) given any efficient program P' that computes the same function as a program P is an element of P, the \" source code\" P can be efficiently reconstructed, yet (b) given oracle access to a (randomly selected) program P is an element of P, no efficient algorithm can reconstruct P (or even distinguish a certain bit in the code from random) except with negligible probability. We extend our impossibility result in a number of ways, including even obfuscators that (a) are not necessarily computable in polynomial time, (b) only approximately preserve the functionality, and (c) only need to work for very restricted models of computation (TC0). We also rule out several potential applications of obfuscators, by constructing \"unobfuscatable\" signature schemes, encryption schemes, and pseudorandom function families.", "paper_title": "On the (Im)possibility of Obfuscating Programs", "paper_id": "WOS:000303445000001"}