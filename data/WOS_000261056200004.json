{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "optimized_custom_precision_function_evaluation"}, {"score": 0.004760765880314089, "phrase": "embedded_processors"}, {"score": 0.004707188147442449, "phrase": "fixed-point_processors"}, {"score": 0.004575854901681043, "phrase": "enormous_variety"}, {"score": 0.004275347843870176, "phrase": "mathematical_functions"}, {"score": 0.004156012879026324, "phrase": "automated_method"}, {"score": 0.004109212945115815, "phrase": "mapping_functions"}, {"score": 0.0039050245929822354, "phrase": "native_word_length"}, {"score": 0.0037109446302945903, "phrase": "execution_time"}, {"score": 0.003467040410632942, "phrase": "traditional_mathematical_libraries"}, {"score": 0.0032946562900625187, "phrase": "hand-tuned_processor-specific_code"}, {"score": 0.003148612096891635, "phrase": "efficient_implementations"}, {"score": 0.0030433302702291116, "phrase": "significant_design_time"}, {"score": 0.002958281631770322, "phrase": "automated_design_flow"}, {"score": 0.0029249294679606656, "phrase": "multiword_arithmetic"}, {"score": 0.0028756028995504035, "phrase": "overflow_protection"}, {"score": 0.0027480831196871093, "phrase": "last_place"}, {"score": 0.002671263324230699, "phrase": "analytical_approaches"}, {"score": 0.002552781867125423, "phrase": "fixed-width_operands"}, {"score": 0.0024257447861185813, "phrase": "precision_requirements"}, {"score": 0.0023445770108033288, "phrase": "automated_generation"}, {"score": 0.002318127769195112, "phrase": "processor-optimized_code"}, {"score": 0.002253299769886694, "phrase": "design_space"}, {"score": 0.002215274527909304, "phrase": "rich_range"}, {"score": 0.0021049977753042253, "phrase": "memory_cost"}], "paper_keywords": ["Computer arithmetic", " elementary function approximation", " minimax approximation and algorithms", " processors", " real-time and embedded systems", " simulated annealing", " spline and piecewise polynomial approximation"], "paper_abstract": "Fixed-point processors are utilized in an enormous variety of applications, often for tasks that require the evaluation of mathematical functions. We present an automated method for mapping functions to such processors via polynomials that explicitly targets the native word length of the processor, thereby significantly reducing the execution time relative to commonly used floating-point emulation approaches based on traditional mathematical libraries. The methods presented here also contrast with hand-tuned processor-specific code, which has the potential to deliver efficient implementations but at the cost of significant design time. We describe an automated design flow utilizing multiword arithmetic to provide overflow protection and precision accurate to one unit in the last place (ulp). Analytical approaches are used to minimize the number of fixed-width operands required for each operation and to ensure that precision requirements are met. This allows automated generation of processor-optimized code and characterization of a design space representing a rich range of trade-offs among precision, latency, and memory cost.", "paper_title": "Optimized Custom Precision Function Evaluation for Embedded Processors", "paper_id": "WOS:000261056200004"}