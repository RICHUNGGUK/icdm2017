{"auto_keywords": [{"score": 0.04461509693576422, "phrase": "instantiated_inductive_types"}, {"score": 0.00481495049065317, "phrase": "parametric_inductive_types"}, {"score": 0.0045119929871912405, "phrase": "type_parameters"}, {"score": 0.0031697368057340895, "phrase": "functor_w.r.t"}, {"score": 0.002997735656669146, "phrase": "standard_reductions"}, {"score": 0.0028615323526689582, "phrase": "simple_type_system"}, {"score": 0.0028087949095629955, "phrase": "inductive_types"}, {"score": 0.002656327554326748, "phrase": "modular_rewriting_techniques"}, {"score": 0.002607362103727335, "phrase": "new_reductions"}, {"score": 0.0022258906408344973, "phrase": "internal_conversion_relation"}, {"score": 0.0021445492649196955, "phrase": "strong_normalization"}, {"score": 0.0021049977753042253, "phrase": "confluence_properties"}], "paper_keywords": [""], "paper_abstract": "Parametric inductive types can be seen as functions taking type parameters as arguments and returning the instantiated inductive types. Given functions between parameters one can construct a function between the instantiated inductive types representing the change of parameters along these functions. It is well known that it is not a functor w.r.t. intensional equality based on standard reductions. We investigate a simple type system with inductive types and iteration and show by modular rewriting techniques that new reductions can be safely added to make this construction a functor, while the decidability of the internal conversion relation based on the strong normalization and confluence properties is preserved. Possible applications: new categorical and computational structures on lambda-calculus, certified computation.", "paper_title": "Inductive type schemas as functors", "paper_id": "WOS:000238109200007"}