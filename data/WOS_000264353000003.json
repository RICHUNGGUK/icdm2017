{"auto_keywords": [{"score": 0.04902194563396072, "phrase": "data-stream_model"}, {"score": 0.00481495049065317, "phrase": "data-stream_model."}, {"score": 0.004743806810821005, "phrase": "computing_graph_distances"}, {"score": 0.004502943680955863, "phrase": "arbitrary_order"}, {"score": 0.004338390136272005, "phrase": "massive_graphs"}, {"score": 0.004295529579407818, "phrase": "web_graph"}, {"score": 0.004232028007240846, "phrase": "better_theoretical_understanding"}, {"score": 0.004077334133756166, "phrase": "model_parameters"}, {"score": 0.003987234470468046, "phrase": "total_space"}, {"score": 0.003775252292179034, "phrase": "graph_problems"}, {"score": 0.0037286623612913603, "phrase": "previous_streaming_work"}, {"score": 0.0036735099701128604, "phrase": "statistical_nature"}, {"score": 0.0031963987773420068, "phrase": "semistreaming_space_restriction"}, {"score": 0.003141278536391916, "phrase": "per-edge_processing_time"}, {"score": 0.0030794433253250476, "phrase": "open_question"}, {"score": 0.0030414185985395913, "phrase": "theoret"}, {"score": 0.0028510920402435554, "phrase": "bfs"}, {"score": 0.002726317042943758, "phrase": "first_k_layers"}, {"score": 0.00270605887875713, "phrase": "bfs_tree"}, {"score": 0.002685950839409376, "phrase": "prescribed_node"}, {"score": 0.002568393821852122, "phrase": "bfs_trees"}, {"score": 0.0025493061218364375, "phrase": "important_subroutine"}, {"score": 0.002492887827772678, "phrase": "new_algorithmic_techniques"}, {"score": 0.0022964707573414453, "phrase": "lower_bounds"}, {"score": 0.0022568341732198904, "phrase": "shortest_cycle"}, {"score": 0.0022013916728990564, "phrase": "per-edge_processing"}, {"score": 0.0021526564019119466, "phrase": "per-edge_computation_time"}], "paper_keywords": ["stream algorithms", " graph distances", " spanners"], "paper_abstract": "We explore problems related to computing graph distances in the data-stream model. The goal is to design algorithms that can process the edges of a graph in an arbitrary order given only a limited amount of working memory. We are motivated by both the practical challenge of processing massive graphs such as the web graph and the desire for a better theoretical understanding of the data-stream model. In particular, we are interested in the trade-offs between model parameters such as per-data-item processing time, total space, and the number of passes that may be taken over the stream. These trade-offs are more apparent when considering graph problems than they were in previous streaming work that solved problems of a statistical nature. Our results include the following: (1) Spanner construction: There exists a single-pass, (O) over tilde (tn(1+1/t))-space, (O) over tilde (t(2)n(1/t))-time-per-edge algorithm that constructs a (2t + 1)-spanner. For t = Omega(log n/log log n), the algorithm satisfies the semistreaming space restriction of O(n polylog n) and has per-edge processing time O(polylog n). This resolves an open question from [J. Feigenbaum et al., Theoret. Comput. Sci., 348 (2005), pp. 207-216]. (2) Breadth-first-search (BFS) trees: For any even constant k, we show that any algorithm that computes the first k layers of a BFS tree from a prescribed node with probability at least 2/3 requires either greater than k/2 passes or Omega(n(1+1/k)) space. Since constructing BFS trees is an important subroutine in many traditional graph algorithms, this demonstrates the need for new algorithmic techniques when processing graphs in the data-stream model. (3) Graph-distance lower bounds: Any t-approximation of the distance between two nodes requires Omega(n(1+1/t)) space. We also prove lower bounds for determining the length of the shortest cycle and other graph properties. (4) Techniques for decreasing per-edge processing: We discuss two general techniques for speeding up the per-edge computation time of streaming algorithms while increasing the space by only a small factor.", "paper_title": "GRAPH DISTANCES IN THE DATA-STREAM MODEL", "paper_id": "WOS:000264353000003"}