{"auto_keywords": [{"score": 0.04958309506789283, "phrase": "map-reduce_environment"}, {"score": 0.04355159126538614, "phrase": "reduce_process"}, {"score": 0.00481495049065317, "phrase": "multiway_joins"}, {"score": 0.004104132253183181, "phrase": "map_process"}, {"score": 0.004047500054405469, "phrase": "particular_tuple"}, {"score": 0.0035222812668916736, "phrase": "limited_fashion"}, {"score": 0.003378385493203297, "phrase": "map-key_attributes"}, {"score": 0.0031734538599865973, "phrase": "fixed_number"}, {"score": 0.0031514627590375354, "phrase": "reduce_processes"}, {"score": 0.002639251247218711, "phrase": "least_replication"}, {"score": 0.0025225467103906314, "phrase": "conventional_way"}, {"score": 0.0024109902338204873, "phrase": "important_cases"}, {"score": 0.0023942700905678735, "phrase": "large-scale_data"}, {"score": 0.002312388685547026, "phrase": "analytic_queries"}, {"score": 0.002248899833549883, "phrase": "smaller_dimension_tables"}, {"score": 0.002164432930854161, "phrase": "high_out-degree"}, {"score": 0.0021049977753042253, "phrase": "social_network"}], "paper_keywords": ["Map-reduce", " joins", " parallel computing", " query optimization"], "paper_abstract": "Implementations of map-reduce are being used to perform many operations on very large data. We examine strategies for joining several relations in the map-reduce environment. Our new approach begins by identifying the \"map-key,\" the set of attributes that identify the Reduce process to which a Map process must send a particular tuple. Each attribute of the map-key gets a \"share,\" which is the number of buckets into which its values are hashed, to form a component of the identifier of a Reduce process. Relations have their tuples replicated in limited fashion, the degree of replication depending on the shares for those map-key attributes that are missing from their schema. We study the problem of optimizing the shares, given a fixed number of Reduce processes. An algorithm for detecting and fixing problems where a variable is mistakenly included in the map-key is given. Then, we consider two important special cases: chain joins and star joins. In each case, we are able to determine the map-key and determine the shares that yield the least replication. While the method we propose is not always superior to the conventional way of using map-reduce to implement joins, there are some important cases involving large-scale data where our method wins, including: 1) analytic queries in which a very large fact table is joined with smaller dimension tables, and 2) queries involving paths through graphs with high out-degree, such as the Web or a social network.", "paper_title": "Optimizing Multiway Joins in a Map-Reduce Environment", "paper_id": "WOS:000292888400002"}