{"auto_keywords": [{"score": 0.04104198353993994, "phrase": "data_module"}, {"score": 0.03793718176699802, "phrase": "control_module"}, {"score": 0.03686508718914003, "phrase": "thread_interference"}, {"score": 0.023642062144373373, "phrase": "duet"}, {"score": 0.00481495049065317, "phrase": "parameterized_concurrent_programs"}, {"score": 0.004779406424192843, "phrase": "modular_reasoning"}, {"score": 0.00450429688285697, "phrase": "thread-state_properties"}, {"score": 0.004356535752468849, "phrase": "active_threads"}, {"score": 0.00388356203453764, "phrase": "thread-state_invariants"}, {"score": 0.0037700424606538856, "phrase": "global_variables"}, {"score": 0.0037421829222825964, "phrase": "local_variables"}, {"score": 0.0036598289615980837, "phrase": "thread_interference_information"}, {"score": 0.003448940584469061, "phrase": "incrementally_constructed_data_flow_graph"}, {"score": 0.0033981387193790353, "phrase": "data_invariants"}, {"score": 0.0031317713853981064, "phrase": "real_program_execution"}, {"score": 0.0030401601744013793, "phrase": "feedback_loop"}, {"score": 0.0027502501046865525, "phrase": "fixed_point"}, {"score": 0.0026012779346272848, "phrase": "infinite_state"}, {"score": 0.002469508424323385, "phrase": "verification_method"}, {"score": 0.002353120949568249, "phrase": "duet."}, {"score": 0.0022338938462817867, "phrase": "linux_device_drivers"}, {"score": 0.0021604504765314497, "phrase": "previous_work"}, {"score": 0.002128587147609539, "phrase": "parameterized_boolean_program"}, {"score": 0.0021049977753042253, "phrase": "boolean_abstractions"}], "paper_keywords": ["Verification", " Algorithms", " Reliability", " Concurrency", " Abstract Interpretation", " Compositional Reasoning", " Data Flow Graphs", " Parameterized Programs", " Thread Invariants"], "paper_abstract": "In this paper, we consider the problem of verifying thread-state properties of multithreaded programs in which the number of active threads cannot be statically bounded. Our approach is based on decomposing the task into two modules, where one reasons about data and the other reasons about control. The data module computes thread-state invariants (e. g., linear constraints over global variables and local variables of one thread) using the thread interference information computed by the control module. The control module computes a representation of thread interference, as an incrementally constructed data flow graph, using the data invariants provided by the data module. These invariants are used to rule out patterns of thread interference that can not occur in a real program execution. The two modules are incorporated into a feedback loop, so that the abstractions of data and interference are iteratively coarsened as the algorithm progresses (that is, they become weaker) until a fixed point is reached. Our approach is sound and terminating, and applicable to programs with infinite state (e. g., unbounded integers) and unboundedly many threads. The verification method presented in this paper has been implemented into a tool, called DUET. We demonstrate the effectiveness of our technique by verifying properties of a selection of Linux device drivers using DUET, and also compare DUET with previous work on verification of parameterized Boolean program using the Boolean abstractions of these drivers.", "paper_title": "Verification of Parameterized Concurrent Programs By Modular Reasoning about Data and Control", "paper_id": "WOS:000300548100023"}