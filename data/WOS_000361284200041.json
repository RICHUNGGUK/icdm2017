{"auto_keywords": [{"score": 0.043891862951523725, "phrase": "expressive_power"}, {"score": 0.004814956211723418, "phrase": "lightweight"}, {"score": 0.004542441734438654, "phrase": "generic_programming"}, {"score": 0.004494570360108983, "phrase": "modern_object-oriented_programming_languages"}, {"score": 0.004377077848734575, "phrase": "desirable_expressive_power"}, {"score": 0.004262643556463569, "phrase": "expressive_genericity_mechanism"}, {"score": 0.004129248271757936, "phrase": "static_checking"}, {"score": 0.003957833102043277, "phrase": "common_use_cases"}, {"score": 0.0037336520904376687, "phrase": "existing_types"}, {"score": 0.003674738405118697, "phrase": "type_constraints"}, {"score": 0.0032355864829403413, "phrase": "common_uses"}, {"score": 0.0030521898646210413, "phrase": "additional_programmer_effort"}, {"score": 0.0029409171055888804, "phrase": "object-oriented_style"}, {"score": 0.002863921785266393, "phrase": "model_generics"}, {"score": 0.002833689453299307, "phrase": "model-dependent_types"}, {"score": 0.0027594936602962075, "phrase": "model_multimethods"}, {"score": 0.0027303606813078255, "phrase": "constraint_entailment"}, {"score": 0.0027015344365793016, "phrase": "model_inheritance"}, {"score": 0.002658863179011018, "phrase": "existential_quantification"}, {"score": 0.002575526825728026, "phrase": "object-oriented_setting"}, {"score": 0.002508073621696602, "phrase": "new_genericity_features"}, {"score": 0.0024553821147953463, "phrase": "common_generic_programming_idioms"}, {"score": 0.002416589459425828, "phrase": "current_generic_libraries"}, {"score": 0.002279508335630797, "phrase": "static_semantics"}, {"score": 0.0021731423856364003, "phrase": "key_decidability_property"}, {"score": 0.0021049977753042253, "phrase": "associated_technical_report"}], "paper_keywords": ["Genus", " generic programming", " constraints", " models"], "paper_abstract": "The support for generic programming in modern object-oriented programming languages is awkward and lacks desirable expressive power. We introduce an expressive genericity mechanism that adds expressive power and strengthens static checking, while remaining lightweight and simple in common use cases. Like type classes and concepts, the mechanism allows existing types to model type constraints retroactively. For expressive power, we expose models as named constructs that can be defined and selected explicitly to witness constraints; in common uses of genericity, however, types implicitly witness constraints without additional programmer effort. Models are integrated into the object-oriented style, with features like model generics, model-dependent types, model enrichment, model multimethods, constraint entailment, model inheritance, and existential quantification further extending expressive power in an object-oriented setting. We introduce the new genericity features and show that common generic programming idioms, including current generic libraries, can be expressed more precisely and concisely. The static semantics of the mechanism and a proof of a key decidability property can be found in an associated technical report.", "paper_title": "Lightweight, Flexible Object-Oriented Generics", "paper_id": "WOS:000361284200041"}