{"auto_keywords": [{"score": 0.0288029107045205, "phrase": "input_symbols"}, {"score": 0.028599910780411436, "phrase": "equivalence_classes"}, {"score": 0.00481495049065317, "phrase": "state_machines"}, {"score": 0.004677372885331908, "phrase": "regular_language"}, {"score": 0.00456020621016909, "phrase": "finite_automaton"}, {"score": 0.004494570360108983, "phrase": "sufficiently_large_sample"}, {"score": 0.004462105963334103, "phrase": "accepted_and_nonaccepted_input_words"}, {"score": 0.004287680323820891, "phrase": "hardware_systems"}, {"score": 0.004165105357908494, "phrase": "test_case_generation"}, {"score": 0.004016782710006123, "phrase": "state_machine_models"}, {"score": 0.003958937342925219, "phrase": "communication_protocols"}, {"score": 0.0037087324991876727, "phrase": "protocol_data_unit_type"}, {"score": 0.003512308265830794, "phrase": "typical_algorithms"}, {"score": 0.003486913922294352, "phrase": "regular_inference"}, {"score": 0.003424225677958491, "phrase": "needed_input_words"}, {"score": 0.003138611911039635, "phrase": "angluin"}, {"score": 0.002855937840577789, "phrase": "dfa."}, {"score": 0.0028352726653271187, "phrase": "main_new_idea"}, {"score": 0.002598652897946253, "phrase": "equivalence_class"}, {"score": 0.002542642270762272, "phrase": "state_machine"}, {"score": 0.0023903999901926224, "phrase": "good_properties"}, {"score": 0.0023730978395564116, "phrase": "angluin's_original_algorithm"}, {"score": 0.0021435864990577945, "phrase": "synthesized_examples"}, {"score": 0.0021049977753042253, "phrase": "complexity_results"}], "paper_keywords": [""], "paper_abstract": "Techniques for inferring a regular language, in the form of a finite automaton, from a sufficiently large sample of accepted and nonaccepted input words, have been employed to construct models of software and hardware systems, for use, e.g., in test case generation. We intend to adapt these techniques to construct state machine models of entities of communication protocols. The alphabet of such state machines can be very large, since a symbol typically consists of a protocol data unit type with a number of parameters, each of which can assume many values. In typical algorithms for regular inference, the number of needed input words grows with the size of the alphabet and the size of the minimal DFA accepting the language. We therefore modify such an algorithm (Angluin's algorithm) so that its complexity grows not with the size of the alphabet, but only with the size of a certain symbolic representation of the DFA. The main new idea is to infer, for each state, a partitioning of input symbols into equivalence classes, tinder the hypothesis that all input symbols in an equivalence class have the same effect on the state machine. Whenever such a hypothesis is disproved, equivalence classes are refined. We show that our modification retains the good properties of Angluin's original algorithm, but that its complexity grows with the size of our symbolic DFA representation rather than with the size of the alphabet. We have implemented the algorithm; experiments on synthesized examples are consistent with these complexity results.", "paper_title": "Regular inference for state machines with parameters", "paper_id": "WOS:000236901100010"}