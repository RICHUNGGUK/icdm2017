{"auto_keywords": [{"score": 0.04126630752096141, "phrase": "sorting_stage"}, {"score": 0.00481495049065317, "phrase": "exact_oit"}, {"score": 0.004754600386388821, "phrase": "complex_scenes"}, {"score": 0.00469500313566324, "phrase": "exact_order-independent_transparency"}, {"score": 0.004009894739765119, "phrase": "alpha_transparency"}, {"score": 0.0038124354878360032, "phrase": "high_depth_complexity_scenes"}, {"score": 0.0036707250689857348, "phrase": "total_time"}, {"score": 0.0034028574973016933, "phrase": "typical_shader-based_sorting_speed"}, {"score": 0.003317970131738248, "phrase": "local_memory_latency"}, {"score": 0.00301801991152303, "phrase": "external_merge_sort"}, {"score": 0.002980124909321296, "phrase": "register-based_block"}, {"score": 0.0028692628457408025, "phrase": "memory_hierarchy"}, {"score": 0.0028155981750899407, "phrase": "gpu"}, {"score": 0.002780025943393764, "phrase": "improved_oit_rendering_performance"}, {"score": 0.002676587673012276, "phrase": "backwards_memory_allocation"}, {"score": 0.0024654516678953658, "phrase": "best_previous_method"}, {"score": 0.0023290951071300433, "phrase": "oit"}, {"score": 0.0021049977753042253, "phrase": "dominant_oit_component"}], "paper_keywords": ["Sorting", " OIT", " Transparency", " Shaders", " Performance", " Registers", " Register-based block sort"], "paper_abstract": "Exact order-independent transparency (OIT) techniques capture all fragments during rasterization. The fragments are then sorted per-pixel by depth and composited in order using alpha transparency. The sorting stage is a bottleneck for high depth complexity scenes, taking 70-95 % of the total time for those investigated. In this paper, we show that typical shader-based sorting speed is impacted by local memory latency and occupancy. We present and discuss the use of both registers and an external merge sort in register-based block sort to better use the memory hierarchy of the GPU for improved OIT rendering performance. This approach builds upon backwards memory allocation, achieving an OIT rendering speed up to 1.7 that of the best previous method and 6.3 that of the common straight forward OIT implementation. In some cases, the sorting stage is reduced to no longer be the dominant OIT component.", "paper_title": "Fast sorting for exact OIT of complex scenes", "paper_id": "WOS:000337054700005"}