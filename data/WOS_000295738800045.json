{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "nonblock_coding_of_binary"}, {"score": 0.00475254914916922, "phrase": "probabilistic_enumeration"}, {"score": 0.004690952711665194, "phrase": "simple_and_efficient_nonblock_coding_scheme"}, {"score": 0.004491313367627919, "phrase": "probability_model"}, {"score": 0.004413846562278824, "phrase": "source_string"}, {"score": 0.004356620736507642, "phrase": "unique_integer"}, {"score": 0.004189337956225294, "phrase": "possible_strings"}, {"score": 0.0041170581247889654, "phrase": "normal_enumerative_coding"}, {"score": 0.004063664475797303, "phrase": "new_method"}, {"score": 0.003907586297783078, "phrase": "code_value_symbol"}, {"score": 0.0038234714417849495, "phrase": "simple_arithmetic"}, {"score": 0.003581797255879607, "phrase": "memoryless_sources"}, {"score": 0.003311799410921826, "phrase": "symbol_probabilities"}, {"score": 0.0029961221584602405, "phrase": "arbitrary-precision_arithmetic"}, {"score": 0.0029443683459283955, "phrase": "practical_implementation"}, {"score": 0.002831158147480665, "phrase": "restricted-precision_arithmetic"}, {"score": 0.0027822459052173113, "phrase": "subtle_implicit_coding"}, {"score": 0.0027461155463816772, "phrase": "additional_redundancy"}, {"score": 0.002686935113435742, "phrase": "source_model"}, {"score": 0.002583597507349819, "phrase": "even_adaptivity"}, {"score": 0.0023371689326096476, "phrase": "higher-order_models"}, {"score": 0.0023068049914566975, "phrase": "string_suffix"}, {"score": 0.002218054404179068, "phrase": "context_domain"}, {"score": 0.0021607883988873492, "phrase": "practical_version"}, {"score": 0.0021049977753042253, "phrase": "binary_arithmetic_coders"}], "paper_keywords": ["Arithmetic coding", " binary source", " enumerative coding", " nonblock coding", " source coding"], "paper_abstract": "A simple and efficient nonblock coding scheme for binary sources is suggested. It uses a probability model to map any source string to a unique integer, and thereby defines an enumeration of all possible strings. Contrary to normal enumerative coding, the new method is noncombinatorial and operates sequentially, incrementing the code value symbol by symbol, by simple arithmetic. It is akin to arithmetic coding but does not use intervals. For memoryless sources, the redundancy per symbol is shown to be asymptotically less than p(3) bits, where p is the smaller of symbol probabilities. Especially, for integer-valued 1/p, the code is asymptotically optimal. These results are confirmed by both analysis and experiments with arbitrary-precision arithmetic. In a practical implementation, the source is partitioned into substrings enabling restricted-precision arithmetic. Thanks to subtle implicit coding, the additional redundancy is marginal. The source model can be also context-based, and even adaptivity can be incorporated. A peculiarity of the method is that decoding is done backwards (LIFO). Hence, for higher-order models, the string suffix, not prefix, is used as the context domain. The speed of the practical version is close to that of binary arithmetic coders.", "paper_title": "Nonblock Coding of Binary Sources by Probabilistic Enumeration", "paper_id": "WOS:000295738800045"}