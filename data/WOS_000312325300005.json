{"auto_keywords": [{"score": 0.0471913809101942, "phrase": "data_races"}, {"score": 0.00481495049065317, "phrase": "async-finish_parallelism"}, {"score": 0.004726052718910578, "phrase": "major_productivity_hurdle"}, {"score": 0.0046676969718111765, "phrase": "parallel_programming"}, {"score": 0.004278807087784626, "phrase": "harmful_program_behaviors"}, {"score": 0.004199766284749713, "phrase": "determinism_violations"}, {"score": 0.00402094658848301, "phrase": "runtime_overheads"}, {"score": 0.003971262520692664, "phrase": "current_dynamic_data_race_detectors"}, {"score": 0.0035728978842974246, "phrase": "mainstream_software_development"}, {"score": 0.003378385493203297, "phrase": "efficient_dynamic_race_detection_algorithm"}, {"score": 0.0031549249117721946, "phrase": "habanero_java"}, {"score": 0.0031159230343460434, "phrase": "hj"}, {"score": 0.003039311963787733, "phrase": "spawn-sync_constructs"}, {"score": 0.002983100181626917, "phrase": "cilk"}, {"score": 0.002803104254950008, "phrase": "taskchecker"}, {"score": 0.0025532173213934422, "phrase": "dynamic_analysis"}, {"score": 0.002226357953581725, "phrase": "average_slowdown"}, {"score": 0.0021446993452098597, "phrase": "serial_execution"}, {"score": 0.0021049977753042253, "phrase": "optimized_case"}], "paper_keywords": ["Parallel programming", " Program analysis", " Data races", " Determinism"], "paper_abstract": "A major productivity hurdle for parallel programming is the presence of data races. Data races can lead to all kinds of harmful program behaviors, including determinism violations and corrupted memory. However, runtime overheads of current dynamic data race detectors are still prohibitively large (often incurring slowdowns of 10x or more) for use in mainstream software development. In this paper, we present an efficient dynamic race detection algorithm that handles both the async-finish task-parallel programming model used in languages such as X10 and Habanero Java (HJ) and the spawn-sync constructs used in Cilk. We have implemented our algorithm in a tool called TaskChecker and evaluated it on a suite of 12 benchmarks. To reduce overhead of the dynamic analysis, we have also implemented various static optimizations in the tool. Our experimental results indicate that our approach performs well in practice, incurring an average slowdown of 3.05x compared to a serial execution in the optimized case.", "paper_title": "Efficient data race detection for async-finish parallelism", "paper_id": "WOS:000312325300005"}