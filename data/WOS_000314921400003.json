{"auto_keywords": [{"score": 0.04968114352851346, "phrase": "large_object-oriented_software_systems"}, {"score": 0.00481495049065317, "phrase": "software_evolution"}, {"score": 0.004485200522202792, "phrase": "important_but_difficult_task"}, {"score": 0.0043560464825349275, "phrase": "fundamental_role"}, {"score": 0.004108742905942481, "phrase": "evolving_classes"}, {"score": 0.004040688646993605, "phrase": "stable_structure"}, {"score": 0.0035648266669315943, "phrase": "class_diagrams"}, {"score": 0.00347657813672945, "phrase": "novel_etgm_algorithm"}, {"score": 0.003092690568543981, "phrase": "class_diagram_evolution_problem"}, {"score": 0.0029909851863915283, "phrase": "new_algorithm"}, {"score": 0.0026164433143193015, "phrase": "tuned_parameters"}, {"score": 0.002530359917257626, "phrase": "extensive_empirical_evaluation"}, {"score": 0.002346865734863793, "phrase": "mozilla"}, {"score": 0.0022507188208913394, "phrase": "novel_algorithm"}, {"score": 0.0021857667493036786, "phrase": "better_time_performance"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["software evolution", " error-tolerant graph matching algorithms", " oracle"], "paper_abstract": "Analyzing and understanding the evolution of large object-oriented software systems is an important but difficult task in which matching algorithms play a fundamental role. An error-tolerant graph matching (ETGM) algorithm can identify evolving classes that maintain a stable structure of relations (associations, inheritances, and aggregations) with other classes and thus likely constitute the backbone of the system. Therefore, to study the evolution of class diagrams, we first develop a novel ETGM algorithm, which improves the performance of our previous algorithm. Second, we describe the process of building an oracle to validate the results of our approach to solve the class diagram evolution problem. Third, we report for the new algorithm the impact of its parameters on the F-measure summarizing precision (quantifying the exactness of the solution) and recall (quantifying the completeness of the solution). Finally, with tuned parameters, we carry out and report an extensive empirical evaluation of our algorithm using small (Rhino), medium (Azureus and ArgoUML), and large systems (Mozilla and Eclipse). We thus show that this novel algorithm is scalable, stable and has better time performance than its earlier version. Copyright (c) 2010 John Wiley & Sons, Ltd.", "paper_title": "Studying software evolution of large object-oriented software systems using an ETGM algorithm", "paper_id": "WOS:000314921400003"}