{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "recovery-driven_design"}, {"score": 0.014485609560573565, "phrase": "nominal_operation"}, {"score": 0.013823789626348065, "phrase": "processor_module"}, {"score": 0.012248990054245297, "phrase": "significant_power_benefits"}, {"score": 0.004758457292840376, "phrase": "error_resilience"}, {"score": 0.004684157900507474, "phrase": "energy-efficient_processors"}, {"score": 0.004468117364177126, "phrase": "timing_violations"}, {"score": 0.004178935413340453, "phrase": "target_timing_error_rate"}, {"score": 0.003817137134650275, "phrase": "hardware_or_software_error_resilience_mechanism"}, {"score": 0.0036697319652557363, "phrase": "recovery-driven_design_approach"}, {"score": 0.0035699363258657212, "phrase": "voltage_overscaling"}, {"score": 0.003432044343307207, "phrase": "error_resilience_technique"}, {"score": 0.003312486229143855, "phrase": "detailed_evaluation"}, {"score": 0.0030614565460256897, "phrase": "design-level_methodology"}, {"score": 0.0029899137403982027, "phrase": "recovery-driven_processors"}, {"score": 0.0028743610212291727, "phrase": "hardware_or_software_error_resilience"}, {"score": 0.002807178116892454, "phrase": "gradual_slack_recovery-driven_design_approach"}, {"score": 0.0026986685585382347, "phrase": "soft_processors"}, {"score": 0.0026459927476753585, "phrase": "graceful_failure_characteristics"}, {"score": 0.0025638362414466278, "phrase": "output_quality"}, {"score": 0.0025436978068459565, "phrase": "additional_energy_savings"}, {"score": 0.0023694065215394593, "phrase": "er_targets"}, {"score": 0.0023048904639724438, "phrase": "individual_modules"}, {"score": 0.002286781334850213, "phrase": "processor-level_benefits"}, {"score": 0.002155412043665635, "phrase": "error_resilience_mechanism"}, {"score": 0.0021049977753042253, "phrase": "available_voltage_domains"}], "paper_keywords": ["Cell sizing", " error resilience", " power minimization", " recovery-driven design", " slack redistribution"], "paper_abstract": "Conventional computer-aided design (CAD) methodologies optimize a processor module for correct operation and prohibit timing violations during nominal operation. We propose recovery-driven design, a design approach that optimizes a processor module for a target timing error rate (ER) instead of correct operation. The target ER is chosen based on how many errors can be gainfully tolerated by a hardware or software error resilience mechanism. We show that significant power benefits are possible from a recovery-driven design approach that deliberately allows errors caused by voltage overscaling to occur during nominal operation, while relying on an error resilience technique to tolerate these errors. We present a detailed evaluation and analysis of such a CAD methodology that minimizes the power of a processor module for a target ER. We show how this design-level methodology can be extended to design recovery-driven processors-processors that are optimized to take advantage of hardware or software error resilience. We also discuss a gradual slack recovery-driven design approach that optimizes for a range of ERs to create soft processors-processors that have graceful failure characteristics and the ability to trade throughput or output quality for additional energy savings over a range of ERs. We demonstrate significant power benefits over conventional design-11.8% on average over all modules and ER targets, and up to 29.1% for individual modules. Processor-level benefits were 19.0%, on average. Benefits increase when recovery-driven design is coupled with an error resilience mechanism or when the number of available voltage domains increases.", "paper_title": "Recovery-Driven Design: Exploiting Error Resilience in Design of Energy-Efficient Processors", "paper_id": "WOS:000300513500007"}