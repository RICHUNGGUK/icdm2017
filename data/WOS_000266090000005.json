{"auto_keywords": [{"score": 0.027920842522465412, "phrase": "interprocedural_phase"}, {"score": 0.024779825747836073, "phrase": "type_annotations"}, {"score": 0.00481495049065317, "phrase": "interprocedural_and"}, {"score": 0.004504969093304219, "phrase": "c_code"}, {"score": 0.004430629452265786, "phrase": "explicit_memory_management"}, {"score": 0.004381749459671914, "phrase": "type_conversion"}, {"score": 0.004309434349688514, "phrase": "c_language"}, {"score": 0.004009555045206973, "phrase": "system_programming"}, {"score": 0.0038998328617557013, "phrase": "appealing_features"}, {"score": 0.0037721073763702486, "phrase": "programs'_safety"}, {"score": 0.003668859054928118, "phrase": "c_language_permissiveness"}, {"score": 0.003628352506247126, "phrase": "highly_skilled_but_inadvertent_programmers"}, {"score": 0.0035684266744407485, "phrase": "insidious_programming_errors"}, {"score": 0.003509487090932835, "phrase": "exploitable_code"}, {"score": 0.0033384259516301223, "phrase": "novel_type"}, {"score": 0.0033015555065209865, "phrase": "effect_analysis"}, {"score": 0.0032470094613727433, "phrase": "memory_and_type_errors"}, {"score": 0.003211145390854807, "phrase": "c_source_code"}, {"score": 0.003123203316511694, "phrase": "standard_c_type_system"}, {"score": 0.0029380909574836587, "phrase": "valuable_safety_information"}, {"score": 0.002857605453835429, "phrase": "static_safety_checks"}, {"score": 0.002810373366887749, "phrase": "safety_errors"}, {"score": 0.002763919794139171, "phrase": "aforementioned_annotations"}, {"score": 0.0026732973536990373, "phrase": "intraprocedural_phase"}, {"score": 0.002585638506308606, "phrase": "flow-sensitive_and_alias-sensitive_intraprocedural_phase"}, {"score": 0.002445865715873089, "phrase": "program_point"}, {"score": 0.0023525345110929326, "phrase": "unification_constraints"}, {"score": 0.00230080652063411, "phrase": "function_boundaries"}, {"score": 0.0022377394845878268, "phrase": "inference_algorithm"}, {"score": 0.002152332983488664, "phrase": "safety_checks"}, {"score": 0.0021049977753042253, "phrase": "programmers'_interaction"}], "paper_keywords": ["Type and effect analysis", " Memory safety", " Type safety", " C language"], "paper_abstract": "The explicit memory management and type conversion endow the C language with flexibility and performance that render it the de facto language for system programming. However, these appealing features come at the cost of programs' safety. Due to the C language permissiveness, highly skilled but inadvertent programmers often spawn insidious programming errors that yield exploitable code. In this paper, we present a novel type and effect analysis for detecting memory and type errors in C source code. We extend the standard C type system with effect, region, and host annotations that hold valuable safety information. We also define static safety checks to detect safety errors using the aforementioned annotations. Our analysis performs in an intraprocedural phase and an interprocedural phase. The flow-sensitive and alias-sensitive intraprocedural phase propagates type annotations and applies safety checks at each program point. The interprocedural phase generates and propagates unification constraints on type annotations across function boundaries. We present an inference algorithm that automatically infers type annotations and applies safety checks to programs without programmers' interaction.", "paper_title": "Interprocedural and Flow-Sensitive Type Analysis for Memory and Type Safety of C Code", "paper_id": "WOS:000266090000005"}