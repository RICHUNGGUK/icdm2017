{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "java_virtual_machine"}, {"score": 0.004728780808284175, "phrase": "cold_code_removal"}, {"score": 0.00468627326602559, "phrase": "optimistic_partial_program_loading"}, {"score": 0.004581660953729745, "phrase": "limited_storage_capacity"}, {"score": 0.00439918275666155, "phrase": "modern_virtual_machine_platforms"}, {"score": 0.004320421465896323, "phrase": "large_amounts"}, {"score": 0.004281568920264999, "phrase": "library_code"}, {"score": 0.004167086373747367, "phrase": "client_device"}, {"score": 0.004110993414942228, "phrase": "conflicting_requirements"}, {"score": 0.0040010534672646775, "phrase": "specialized_embedded_versions"}, {"score": 0.003947186611084043, "phrase": "standard_libraries"}, {"score": 0.00389404213807752, "phrase": "even_these_stripped_down_libraries"}, {"score": 0.0037052054802048707, "phrase": "always_connected\"_mobile_devices"}, {"score": 0.003638823482920949, "phrase": "zero_footprint_client_paradigm"}, {"score": 0.0034780071331554003, "phrase": "remote_server"}, {"score": 0.003220709449062307, "phrase": "mobile_client_device"}, {"score": 0.003023129616910419, "phrase": "run_time"}, {"score": 0.0029689311901364797, "phrase": "static_analysis"}, {"score": 0.002942196368747418, "phrase": "opportunistic_off-target_linking"}, {"score": 0.0028120802837806234, "phrase": "high_likelihood"}, {"score": 0.0026634937939104177, "phrase": "exception_code"}, {"score": 0.00237861522566195, "phrase": "unused_code"}, {"score": 0.0022836785412390544, "phrase": "class_files"}, {"score": 0.00222249726328354, "phrase": "individual_basic_blocks"}, {"score": 0.0021826210858934933, "phrase": "total_code_size_reductions"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Java virtual machine", " Just-in-time compilation", " Embedded connected devices", " Cold code removal"], "paper_abstract": "Embedded systems provide limited storage capacity. This limitation conflicts with the demands of modern virtual machine platforms, which require large amounts of library code to be present on each client device. These conflicting requirements are often resolved by providing specialized embedded versions of the standard libraries, but even these stripped down libraries consume significant resources. We present a solution for \"always connected\" mobile devices based on a zero footprint client paradigm. In our approach, all code resides on a remote server. Only those parts of applications and libraries that are likely to be needed are transferred to the mobile client device. Since it is difficult to predict statically which library parts will be needed at run time, we combine static analysis, opportunistic off-target linking and lazy code loading to transfer code with a high likelihood of execution ahead of time while the other code, such as exception code, remains on the server and is transferred only on demand. This allows us to perform not only dead code elimination, but also aggressive elimination of unused code. The granularity of our approach is flexible from class files all the way down to individual basic blocks. Our method achieves total code size reductions of up to 95%. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Slimming a Java virtual machine by way of cold code removal and optimistic partial program loading", "paper_id": "WOS:000292671000005"}