{"auto_keywords": [{"score": 0.044435149165965256, "phrase": "linux_kernel"}, {"score": 0.00481495049065317, "phrase": "linux_kernel_source_code"}, {"score": 0.004545240514015278, "phrase": "analysis_tool"}, {"score": 0.0043738432231020885, "phrase": "c_code"}, {"score": 0.0028923335491735564, "phrase": "thousand_c_source_files"}, {"score": 0.0027564303939865476, "phrase": "source_code"}, {"score": 0.0025521085778978042, "phrase": "freed_memory"}, {"score": 0.002432152706473349, "phrase": "model-checking_techniques"}], "paper_keywords": [""], "paper_abstract": "This article describes an analysis tool aimed at the C code of the Linux kernel, having been first described as a prototype (in this forum) in 2004. Its continuing maturation means that it is now capable of treating millions of lines of code in a few hours on very modest platforms. It detects about two uncorrected deadlock situations per thousand C source files or million lines of source code in the Linux kernel, and three accesses to freed memory. In distinction to model-checking techniques, the tool uses a configurable \"3-phase\" programming logic to perform its analysis. It carries out several different analyses simultaneously.", "paper_title": "One million (LOC) and counting: Static analysis for errors and vulnerabilities in the Linux kernel source code", "paper_id": "WOS:000238387000005"}