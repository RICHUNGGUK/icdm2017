{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "decision-making_programs"}, {"score": 0.004684157900507474, "phrase": "discrete_decisions"}, {"score": 0.004556901872357751, "phrase": "limited_numerical_precision"}, {"score": 0.004463723624910583, "phrase": "sensor-derived_inputs"}, {"score": 0.004372442291178139, "phrase": "individual_decisions"}, {"score": 0.004209893377338457, "phrase": "contradictory_decisions"}, {"score": 0.004180992206290323, "phrase": "different_points"}, {"score": 0.004053362743156545, "phrase": "otherwise_correct_program"}, {"score": 0.0038492126993451337, "phrase": "essential_program_invariants"}, {"score": 0.0032176163279340206, "phrase": "program_execution"}, {"score": 0.0028616432465945097, "phrase": "program_location_l"}, {"score": 0.002793380001054064, "phrase": "fixpoint_constraint-solver"}, {"score": 0.0026616868981501006, "phrase": "new_decisions"}, {"score": 0.002527451565708784, "phrase": "computational_geometry"}, {"score": 0.0023834640793589435, "phrase": "correctness_property"}, {"score": 0.002318566141177149, "phrase": "first_attempt"}, {"score": 0.002302619021497886, "phrase": "automated_verification"}, {"score": 0.0022710523337245337, "phrase": "geometric_algorithms"}, {"score": 0.0022168460543913787, "phrase": "convex_hull_computation"}, {"score": 0.0021789194955896102, "phrase": "point_location_algorithms"}, {"score": 0.0021564750534280863, "phrase": "almost_all_examples"}], "paper_keywords": ["Program Analysis", " Uncertainty", " Consistency", " Geometry", " Robustness"], "paper_abstract": "Applications in many areas of computing make discrete decisions under uncertainty, for reasons such as limited numerical precision in calculations and errors in sensor-derived inputs. As a result, individual decisions made by such programs may be nondeterministic, and lead to contradictory decisions at different points of an execution. This means that an otherwise correct program may execute along paths, that it would not follow under its ideal semantics, violating essential program invariants on the way. A program is said to be consistent if it does not suffer from this problem despite uncertainty in decisions. In this paper, we present a sound, automatic program analysis for verifying that a program is consistent in this sense. Our analysis proves that each decision made along a program execution is consistent with the decisions made earlier in the execution. The proof is done by generating an invariant that abstracts the set of all decisions made along executions that end at a program location l, then verifying, using a fixpoint constraint-solver, that no contradiction can be derived when these decisions are combined with new decisions made at l. We evaluate our analysis on a collection of programs implementing algorithms in computational geometry. Consistency is known to be a critical, frequently-violated, and thoroughly studied correctness property in geometry, but ours is the first attempt at automated verification of consistency of geometric algorithms. Our benchmark suite consists of implementations of convex hull computation, triangulation, and point location algorithms. On almost all examples that are not consistent (with two exceptions), our analysis is able to verify consistency within a few minutes.", "paper_title": "Consistency Analysis of Decision-Making Programs", "paper_id": "WOS:000331120500046"}