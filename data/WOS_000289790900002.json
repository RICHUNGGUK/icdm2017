{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "circus"}, {"score": 0.012138731249903147, "phrase": "utp"}, {"score": 0.004635187610736025, "phrase": "complex_data_operations"}, {"score": 0.0044379811758919864, "phrase": "csp"}, {"score": 0.003958937342925219, "phrase": "design_models"}, {"score": 0.0037903327482565097, "phrase": "unifying_theories"}, {"score": 0.0034554281349858836, "phrase": "refinement-oriented_languages"}, {"score": 0.003344407169522133, "phrase": "abstract_data_types"}, {"score": 0.003290237137651949, "phrase": "model-based_style"}, {"score": 0.0030821633718368206, "phrase": "circus_testing_theory"}, {"score": 0.002918826667294298, "phrase": "sound_test-generation_techniques"}, {"score": 0.0028404241985421096, "phrase": "state-rich_reactive_languages"}, {"score": 0.0027641218567092665, "phrase": "data_operations"}, {"score": 0.002704554429386671, "phrase": "symbolic_tests"}, {"score": 0.002675252546913683, "phrase": "exhaustive_test_sets"}, {"score": 0.002575167114383286, "phrase": "test-generation_techniques"}, {"score": 0.00251966141432339, "phrase": "coverage_criteria"}, {"score": 0.0024653491388223546, "phrase": "transition_models"}, {"score": 0.0023730978395564116, "phrase": "circus_refinement"}, {"score": 0.0022718774783143203, "phrase": "failures-divergences_refinement"}, {"score": 0.0021049977753042253, "phrase": "operational_and_denotational_semantics"}], "paper_keywords": [""], "paper_abstract": "Circus combines constructs to define complex data operations and interactions; it integrates Z and CSP, and, distinctively, it is a language for refinement that can describe programs as well as specification and design models. The semantics is based on the unifying theories of programming (UTP). Most importantly, Circus is representative of a class of refinement-oriented languages that combines facilities to specify abstract data types in a model-based style and patterns of interaction. What we present here is the Circus testing theory; this work is relevant as a foundation for sound test-generation techniques for a plethora of state-rich reactive languages. To cater for data operations, we define symbolic tests and exhaustive test sets. They are the basis for test-generation techniques that can combine coverage criteria for data and transition models. The notion of correctness is Circus refinement, a UTP-based generalisation of failures-divergences refinement that considers data modelling. Proof of exhaustivity exploits the correspondence between the operational and denotational semantics.", "paper_title": "Testing for refinement in Circus", "paper_id": "WOS:000289790900002"}