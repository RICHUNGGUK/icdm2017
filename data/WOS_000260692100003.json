{"auto_keywords": [{"score": 0.008438596066113373, "phrase": "streamline_buffers"}, {"score": 0.00481495049065317, "phrase": "long_latency_instructions"}, {"score": 0.004672212052212814, "phrase": "-order_execution"}, {"score": 0.00462135806316341, "phrase": "wide-issue_processors"}, {"score": 0.00454610829874136, "phrase": "instruction_scheduling_window"}, {"score": 0.004496620666180353, "phrase": "issue_queue"}, {"score": 0.004375235319787951, "phrase": "hardware_complexity"}, {"score": 0.004164905340575487, "phrase": "instruction_level_parallelism"}, {"score": 0.0040192915527630995, "phrase": "long_latency_load_operations"}, {"score": 0.003836497950356168, "phrase": "new_instructions"}, {"score": 0.003682100144121148, "phrase": "growing_disparity"}, {"score": 0.003661987063211563, "phrase": "processor_and_memory_speeds"}, {"score": 0.0035630521026402736, "phrase": "iq."}, {"score": 0.0034478392374444177, "phrase": "novel_technique"}, {"score": 0.0034009367367442175, "phrase": "separate_buffers"}, {"score": 0.00327296539768831, "phrase": "parent_instruction"}, {"score": 0.0032196005492571796, "phrase": "source_operand"}, {"score": 0.0031671030360367843, "phrase": "long_latency_memory_operations"}, {"score": 0.0030064251340251196, "phrase": "potentially_executable_instructions"}, {"score": 0.0029011962350829956, "phrase": "load_cache"}, {"score": 0.00273141641397918, "phrase": "long_latency_memory_dependent_instructions"}, {"score": 0.002701629385101091, "phrase": "in-order_buffers"}, {"score": 0.0026430237246954373, "phrase": "proposed_architecture"}, {"score": 0.002508867228980776, "phrase": "wakeup_logic_complexity"}, {"score": 0.0024679299547216956, "phrase": "conventional_design"}, {"score": 0.0024276590297034064, "phrase": "performance_speedup"}, {"score": 0.002193410120879393, "phrase": "large_overhead"}, {"score": 0.0021814110467069346, "phrase": "circuit_delay_complexity"}, {"score": 0.0021694774708817498, "phrase": "wakeup_logic"}], "paper_keywords": ["Wide-issue processors", " Dynamic scheduling", " Cut-of-order processing", " Long latency instructions", " Streamline buffers"], "paper_abstract": "In the current day wide-issue processors, the size of the instruction scheduling window (also called Issue Queue (IQ)) is limited mainly by the hardware complexity to design the logic, and thus limits the number of instructions scanned every cycle to extract instruction level parallelism (ILP). To exacerbate the problems, instructions depending on long latency load operations continue to reside in the IQ until their source operands are ready. Thus, such delayed instructions block any new instructions from entering the IQ even if potentially they are ready for execution. The growing disparity in processor and memory speeds is further aggravating the delay in dislodging instructions from IQ. To alleviate the problem, in this paper we propose a novel technique to streamline instructions in separate buffers according to the chain of dependencies. Each instruction is streamlined behind a parent instruction while it waits for the source operand to be supplied by the long latency memory operations. These instructions are segregated from the IQ and thus the pressure on IQ is relieved which enables flow of potentially executable instructions in the pipeline. Our analysis of SPEC2000 programs reveals that instructions dependent on load cache misses or their dependents, typically have their first source operand ready within 5-15% of their total wait time in the IQ Based on the observations, the long latency memory dependent instructions are streamlined into in-order buffers when their first operand is ready. In the proposed architecture, instructions from both the conventional IQ and the heads of the streamline buffers can be selected for execution, while the wakeup logic complexity remains same as in the conventional design. Our results show that the performance speedup of 32-entry IQ supplemented by 32 in-order buffers is 15.7% and 2% for FP and integer benchmark respectively, which is very much comparable to that of a conventional 64-entry IQ. A 64-entry IQ design can gain performance over a 32-entry IQ, albeit with a large overhead in circuit delay complexity of wakeup logic, while streamline buffers can gain performance over 32-entry IQ without any such overhead. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Streamlining long latency instructions for seamlessly combined out-of-order and in-order execution", "paper_id": "WOS:000260692100003"}