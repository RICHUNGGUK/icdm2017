{"auto_keywords": [{"score": 0.04890933270671448, "phrase": "static_and_dynamic_typing"}, {"score": 0.004628107076477297, "phrase": "racket"}, {"score": 0.004296998284839309, "phrase": "research_languages"}, {"score": 0.004275860201213859, "phrase": "sage"}, {"score": 0.0042336638794732255, "phrase": "gronski"}, {"score": 0.004191961958098439, "phrase": "knowles"}, {"score": 0.004150665390398236, "phrase": "tomb"}, {"score": 0.004109788631284306, "phrase": "freund"}, {"score": 0.004049193301164711, "phrase": "flanagan"}, {"score": 0.0039501873812289815, "phrase": "thorn"}, {"score": 0.003911253966141701, "phrase": "wrigstad"}, {"score": 0.0038727120021750973, "phrase": "eugster"}, {"score": 0.003861159620297356, "phrase": "field"}, {"score": 0.003796768990512154, "phrase": "nystrom"}, {"score": 0.0037407704200033607, "phrase": "vitek"}, {"score": 0.0035954555250614197, "phrase": "important_open_question"}, {"score": 0.003455765987713262, "phrase": "parametric_polymorphism"}, {"score": 0.003192406091820197, "phrase": "dynamic_type"}, {"score": 0.0030988889679192965, "phrase": "polymorphic_type"}, {"score": 0.0030081030319492343, "phrase": "relational_parametricity"}, {"score": 0.0029199689963238726, "phrase": "dynamic_sealing"}, {"score": 0.002834425876477136, "phrase": "matthews"}, {"score": 0.002394719113232821, "phrase": "more-precise_type"}, {"score": 0.0023593563827190626, "phrase": "less-precise_type"}, {"score": 0.0023245146355917626, "phrase": "cast_failures"}, {"score": 0.0022675820982741347, "phrase": "less-precisely-typed_portion"}], "paper_keywords": ["Languages", " Theory", " casts", " coercions", " blame tracking", " lambda-calculus"], "paper_abstract": "Several programming languages are beginning to integrate static and dynamic typing, including Racket (formerly PLT Scheme), Per1 6, and C# 4.0 and the research languages Sage (Gronski, Knowles, Tomb, Freund, and Flanagan, 2006) and Thorn (Wrigstad, Eugster, Field, Nystrom, and Vitek, 2009). However, an important open question remains, which is how to add parametric polymorphism to languages that combine static and dynamic typing. We present a system that permits a value of dynamic type to be cast to a polymorphic type and vice versa, with relational parametricity enforced by a kind of dynamic sealing along the lines proposed by Matthews and Ahmed (2008) and Neis, Dreyer, and Rossberg (2009). Our system includes a notion of blame, which allows us to show that when casting between a more-precise type and a less-precise type, any cast failures are due to the less-precisely-typed portion of the program. We also show that a cast from a subtype to its supertype cannot fail.", "paper_title": "Blame for All", "paper_id": "WOS:000286472700017"}