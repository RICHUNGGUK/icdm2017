{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "safe_programmable_speculative_parallelism"}, {"score": 0.00477924690801092, "phrase": "execution_order_constraints"}, {"score": 0.004290201740122912, "phrase": "value_speculation"}, {"score": 0.004179824713643488, "phrase": "low_level"}, {"score": 0.0038510053729959074, "phrase": "algorithmic_paradigm"}, {"score": 0.003808209866576388, "phrase": "seemingly_sequential_code"}, {"score": 0.0036826452656927877, "phrase": "speculative_iteration"}, {"score": 0.003561205990687285, "phrase": "speculative_parallelism"}, {"score": 0.0032686865485199806, "phrase": "mundane_implementation_details"}, {"score": 0.0032083351151314405, "phrase": "core_language"}, {"score": 0.0031845067058084583, "phrase": "speculation_constructs"}, {"score": 0.003160854709666311, "phrase": "mutable_state"}, {"score": 0.0031140747752837826, "phrase": "formal_operational_semantics"}, {"score": 0.0029447150254434842, "phrase": "correct_speculative_execution"}, {"score": 0.0028581775908203683, "phrase": "non-speculative_execution"}, {"score": 0.0027741761880779535, "phrase": "runtime_mechanism"}, {"score": 0.002712794864739074, "phrase": "speculative_computation"}, {"score": 0.0024897902536499005, "phrase": "static_analysis"}, {"score": 0.0021607035327962246, "phrase": "static_checker"}, {"score": 0.0021049977753042253, "phrase": "empirical_evaluation"}], "paper_keywords": ["Languages", " speculative parallelism", " value speculation", " safety", " purity", " rollback freedom"], "paper_abstract": "Execution order constraints imposed by dependences can serialize computation, preventing parallelization of code and algorithms. Speculating on the value(s) carried by dependences is one way to break such critical dependences. Value speculation has been used effectively at a low level, by compilers and hardware. In this paper, we focus on the use of speculation by programmers as an algorithmic paradigm to parallelize seemingly sequential code. We propose two new language constructs, speculative composition and speculative iteration. These constructs enable programmers to declaratively express speculative parallelism in programs: to indicate when and how to speculate, increasing the parallelism in the program, without concerning themselves with mundane implementation details. We present a core language with speculation constructs and mutable state and present a formal operational semantics for the language. We use the semantics to define the notion of a correct speculative execution as one that is equivalent to a non-speculative execution. In general, speculation requires a runtime mechanism to undo the effects of speculative computation in the case of mispredictions. We describe a set of conditions under which such rollback can be avoided. We present a static analysis that checks if a given program satisfies these conditions. This allows us to implement speculation efficiently, without the overhead required for rollbacks. We have implemented the speculation constructs as a C# library, along with the static checker for safety. We present an empirical evaluation of the efficacy of this approach to parallelization.", "paper_title": "Safe Programmable Speculative Parallelism", "paper_id": "WOS:000279357500005"}