{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "type_safety"}, {"score": 0.004714448392640623, "phrase": "foreign_function_interfaces"}, {"score": 0.004599831967997116, "phrase": "different_languages"}, {"score": 0.004332894955218135, "phrase": "tricky_low-level_code"}, {"score": 0.004139223748460922, "phrase": "rich_source"}, {"score": 0.0041102032028337366, "phrase": "hard-to-find_programming_errors"}, {"score": 0.0038444185258456245, "phrase": "c_ffi"}, {"score": 0.0035705347414368696, "phrase": "multilingual_type_inference_systems"}, {"score": 0.0035330290755534234, "phrase": "c_code"}, {"score": 0.003483631502938922, "phrase": "ffis_accesses_high-level_data"}, {"score": 0.0033988361874354306, "phrase": "representational_types"}, {"score": 0.0033631279928072314, "phrase": "c's_low-level_view"}, {"score": 0.0033395409230325503, "phrase": "ocaml"}, {"score": 0.0033162809884848756, "phrase": "java"}, {"score": 0.0032697235411641695, "phrase": "singleton_types"}, {"score": 0.0031901183059524804, "phrase": "memory_offsets"}, {"score": 0.0031565959573536194, "phrase": "type_tags"}, {"score": 0.0031344430376015033, "phrase": "c._j-saffire"}, {"score": 0.0029212625534156063, "phrase": "user-defined_wrapper_functions"}, {"score": 0.002790511479398411, "phrase": "monomorphic_flow-sensitive_analysis"}, {"score": 0.0026844452074327265, "phrase": "ocaml_ffi_flow-sensitivity"}, {"score": 0.0026375718041787, "phrase": "conditional_branches"}, {"score": 0.0025642664420937327, "phrase": "ocaml_data"}, {"score": 0.0025462598594116373, "phrase": "c._o-saffire"}, {"score": 0.0025194861926779223, "phrase": "garbage_collection_information"}, {"score": 0.0024842242921857705, "phrase": "local_c_pointers"}, {"score": 0.0024581013157048926, "phrase": "ocaml_heap"}, {"score": 0.0023646402184322205, "phrase": "jni."}, {"score": 0.0022192891418394514, "phrase": "questionable_coding_practices"}, {"score": 0.00217284779477444, "phrase": "static_checking"}, {"score": 0.0021273762177807876, "phrase": "valuable_tool"}, {"score": 0.0021049977753042253, "phrase": "correct_multilingual_software"}], "paper_keywords": ["languages", " verification", " foreign function interface", " FFI", " foreign function calls", " representational type", " multilingual type system", " multilingual type inference", " flow-sensitive type system", " dataflow analysis", " OCaml", " Java", " JNI", " Java Native Interface"], "paper_abstract": "Foreign function interfaces (FFIs) allow components in different languages to communicate directly with each other. While FFIs are useful, they often require writing tricky low-level code and include little or no static safety checking, thus providing a rich source of hard-to-find programming errors. In this article, we study the problem of enforcing type safety across the OCaml-to-C FFI and the Java Native Interface (JNI). We present O-Saffire and J-Saffire, a pair of multilingual type inference systems that ensure C code that uses these FFIs accesses high-level data safely. Our inference systems use representational types to model C's low-level view of OCaml and Java values, and singleton types to track integers, strings, memory offsets, and type tags through C. J-Saffire, our Java system, uses a polymorphic flow-insensitive, unification-based analysis. Polymorphism is important because it allows us to precisely model user-defined wrapper functions and the more than 200 JNI functions. O-Saffire, our OCaml system, uses a monomorphic flow-sensitive analysis because, while polymorphism is much less important for the OCaml FFI flow-sensitivity is critical to track conditional branches, which are used when pattern matching OCaml data in C. O-Saffire also tracks garbage collection information to ensure that local C pointers to the OCaml heap are registered properly, which is not necessary for the JNI. We have applied O-Saffire and J-Saffire to a set of benchmarks and found many bugs and questionable coding practices. These results suggest that static checking of FFIs can be a valuable tool in writing correct multilingual software.", "paper_title": "Checking type safety of foreign function calls", "paper_id": "WOS:000259035300001"}