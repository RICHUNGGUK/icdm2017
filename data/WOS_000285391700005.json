{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "inconsistency-tolerant_integrity_checking"}, {"score": 0.004632597963417253, "phrase": "efficient_integrity"}, {"score": 0.004491678520807451, "phrase": "integrity_constraints"}, {"score": 0.003246672441842787, "phrase": "integrity_checking"}, {"score": 0.0030994630902300133, "phrase": "unrealistic_theoretical_requirement"}, {"score": 0.003051887221639784, "phrase": "total_integrity"}, {"score": 0.002981885091155911, "phrase": "practical_need"}, {"score": 0.0029361086955646625, "phrase": "inconsistency_tolerance"}, {"score": 0.002802941205762953, "phrase": "integrity_checking_methods"}, {"score": 0.002364172626241202, "phrase": "current_state"}, {"score": 0.0021378442381693847, "phrase": "integrity_preservation"}, {"score": 0.0021049977753042253, "phrase": "query_answering"}], "paper_keywords": ["Integrity checking", " inconsistency tolerance"], "paper_abstract": "All methods for efficient integrity checking require all integrity constraints to be totally satisfied, before any update is executed. However, a certain amount of inconsistency is the rule, rather than the exception in databases. In this paper, we close the gap between theory and practice of integrity checking, i.e., between the unrealistic theoretical requirement of total integrity and the practical need for inconsistency tolerance, which we define for integrity checking methods. We show that most of them can still be used to check whether updates preserve integrity, even if the current state is inconsistent. Inconsistency-tolerant integrity checking proves beneficial both for integrity preservation and query answering. Also, we show that it is useful for view updating, repairs, schema evolution, and other applications.", "paper_title": "Inconsistency-Tolerant Integrity Checking", "paper_id": "WOS:000285391700005"}