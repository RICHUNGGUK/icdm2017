{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "instability_problems"}, {"score": 0.03394838660499529, "phrase": "inflated_error"}, {"score": 0.0047787596516662, "phrase": "floating-point_program_execution"}, {"score": 0.004671803485255806, "phrase": "floating_point_values"}, {"score": 0.00463668357590034, "phrase": "limited_precision"}, {"score": 0.004171730509424374, "phrase": "control_flow_path"}, {"score": 0.0040783049361415614, "phrase": "faulty_output"}, {"score": 0.003897659323896113, "phrase": "on-the-fly_efficient_monitoring_technique"}, {"score": 0.0036005006349430586, "phrase": "high_overhead"}, {"score": 0.0035198224928307854, "phrase": "possible_places"}, {"score": 0.00340217066797559, "phrase": "corresponding_value"}, {"score": 0.003154566400499823, "phrase": "inflation_bit_propagation"}, {"score": 0.002958281631770322, "phrase": "inflation_bit"}, {"score": 0.0029249294679606656, "phrase": "critical_execution_point"}, {"score": 0.002795228413298423, "phrase": "substantial_execution_difference"}, {"score": 0.0027532820796396713, "phrase": "different_execution_paths"}, {"score": 0.0026915366885986586, "phrase": "appropriate_thresholds"}, {"score": 0.002495521662819317, "phrase": "traditional_technique"}, {"score": 0.002458061764297103, "phrase": "inflation_detection"}, {"score": 0.00227040825063645, "phrase": "art_technique"}, {"score": 0.0022278779300543548, "phrase": "high_precision_computation"}], "paper_keywords": ["floating point representation", " floating point errors", " instability", " continuity", " discrete factors", " sampling"], "paper_abstract": "The machine representation of floating point values has limited precision such that errors may be introduced during execution. These errors may get propagated and magnified by the following operations, leading to instability problems, e. g., control flow path may be undesirably altered and faulty output may be emitted. In this paper, we develop an on-the-fly efficient monitoring technique that can predict if an execution is stable. The technique does not explicitly compute errors as doing so incurs high overhead. Instead, it detects possible places where an error becomes substantially inflated regarding the corresponding value, and then tags the value with one bit to denote that it has an inflated error. It then tracks inflation bit propagation, taking care of operations that may cut off such propagation. It reports instability if any inflation bit reaches a critical execution point, such as a predicate, where the inflated error may induce substantial execution difference, such as different execution paths. Our experiment shows that with appropriate thresholds, the technique can correctly detect that over 99.999996% of the inputs of all the programs we studied are stable while a traditional technique relying solely on inflation detection mistakenly classifies majority of the inputs as unstable for some of the programs. Compared to the state of the art technique that is based on high precision computation and causes several hundred times slowdown, our technique only causes 7.91 times slowdown on average and can report all the true unstable executions with the appropriate thresholds.", "paper_title": "On-the-fly Detection of Instability Problems in Floating-Point Program Execution", "paper_id": "WOS:000327697300046"}