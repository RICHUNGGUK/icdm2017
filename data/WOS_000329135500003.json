{"auto_keywords": [{"score": 0.04948580535995946, "phrase": "dynamic_loop_bounds"}, {"score": 0.00481495049065317, "phrase": "automated_generation_of_polyhedral_process_networks"}, {"score": 0.004785022360244881, "phrase": "affine_nested-loop_programs"}, {"score": 0.004638136142210615, "phrase": "suitable_parallel_model"}, {"score": 0.004509780213218666, "phrase": "embedded_streaming_applications"}, {"score": 0.004467785611058897, "phrase": "parallel_form"}, {"score": 0.004426180319550746, "phrase": "efficient_mapping"}, {"score": 0.004398657974555281, "phrase": "embedded_parallel_execution_platforms"}, {"score": 0.004276900895591895, "phrase": "parallel_moc"}, {"score": 0.004081385289516914, "phrase": "pn_compiler"}, {"score": 0.0040307683311441534, "phrase": "specific_polyhedral_process_networks"}, {"score": 0.004005716033063193, "phrase": "ppn"}, {"score": 0.003980776610391208, "phrase": "parallel_specifications"}, {"score": 0.003956012816350168, "phrase": "sequential_static_affine_nested_loop_programs"}, {"score": 0.003625009798162227, "phrase": "adaptive_and_dynamic_behavior"}, {"score": 0.003459191419478298, "phrase": "dynamic_multimedia_applications"}, {"score": 0.003373868246555499, "phrase": "important_question"}, {"score": 0.0031894825360137694, "phrase": "compile-time_analysis"}, {"score": 0.0029870247665469358, "phrase": "automated_way"}, {"score": 0.002959167753690868, "phrase": "main_contribution"}, {"score": 0.0029042284259394044, "phrase": "first_approach"}, {"score": 0.0028861422653675283, "phrase": "automated_translation"}, {"score": 0.002868168412858044, "phrase": "affine_nested_loop_programs"}, {"score": 0.0028325548627901004, "phrase": "input-output_equivalent_polyhedral_process_networks"}, {"score": 0.002619748321217153, "phrase": "presented_automated_translation_approach"}, {"score": 0.0025630734211267102, "phrase": "ppn_parallel_specification"}, {"score": 0.00253916011199984, "phrase": "real-life_application"}, {"score": 0.0024457118327295456, "phrase": "smart_cameras_domain"}, {"score": 0.0024077949834924264, "phrase": "derived_ppn"}, {"score": 0.002283210560032092, "phrase": "efficient_parallel_implementations"}, {"score": 0.002268983004273332, "phrase": "sequential_nested_loop_programs"}, {"score": 0.0021991611806433634, "phrase": "possible_parallelism"}, {"score": 0.0021248309394183945, "phrase": "multiple_cores"}, {"score": 0.0021049977753042253, "phrase": "efficient_way"}], "paper_keywords": ["Design", " Theory", " Algorithms", " Performance", " Models of Computation", " polyhedral process networks", " compiler techniques for MPSoCs", " parallel programing"], "paper_abstract": "The Process Networks (PNs) is a suitable parallel model of computation (MoC) used to specify embedded streaming applications in a parallel form facilitating the efficient mapping onto embedded parallel execution platforms. Unfortunately, specifying an application using a parallel MoC is a very difficult and highly error-prone task. To overcome the associated difficulties, we have developed the pn compiler, which derives specific Polyhedral Process Networks (PPN) parallel specifications from sequential static affine nested loop programs (SANLPs). However, there are many applications, for example, multimedia applications (MPEG coders/decoders, smart cameras, etc.) that have adaptive and dynamic behavior which cannot be expressed as SANLPs. Therefore, in order to handle dynamic multimedia applications, in this article we address the important question whether we can relax some of the restrictions of the SANLPs while keeping the ability to perform compile-time analysis and to derive PPNs. Achieving this would significantly extend the range of applications that can be parallelized in an automated way. The main contribution of this article is a first approach for automated translation of affine nested loop programs with dynamic loop bounds into input-output equivalent Polyhedral Process Networks. In addition, we present a method for analyzing the execution overhead introduced in the PPNs derived from programs with dynamic loop bounds. The presented automated translation approach has been evaluated by deriving a PPN parallel specification from a real-life application called Low Speed Obstacle Detection (LSOD) used in the smart cameras domain. By executing the derived PPN, we have obtained results which indicate that the approach we present in this article facilitates efficient parallel implementations of sequential nested loop programs with dynamic loop bounds. That is, our approach reveals the possible parallelism available in such applications, which allows for the utilization of multiple cores in an efficient way.", "paper_title": "Automated Generation of Polyhedral Process Networks from Affine Nested-Loop Programs with Dynamic Loop Bounds", "paper_id": "WOS:000329135500003"}