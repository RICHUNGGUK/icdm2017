{"auto_keywords": [{"score": 0.04745358435978179, "phrase": "formal_approaches"}, {"score": 0.004725385523804256, "phrase": "program_optimization"}, {"score": 0.0037363522297378777, "phrase": "comparatively_little_work"}, {"score": 0.003369322866499541, "phrase": "optimized_programs"}, {"score": 0.0030097975788892896, "phrase": "general-purpose_optimization_technique"}, {"score": 0.002688532127821979, "phrase": "call-by-need_variant"}, {"score": 0.002248366278757655, "phrase": "time_performance"}, {"score": 0.0021652891317252994, "phrase": "lazy_languages"}, {"score": 0.00210502285419412, "phrase": "haskell"}], "paper_keywords": ["general recursion", " improvement"], "paper_abstract": "Much research in program optimization has focused on formal approaches to correctness: proving that the meaning of programs is preserved by the optimisation. Paradoxically, there has been comparatively little work on formal approaches to efficiency: proving that the performance of optimized programs is actually improved. This paper addresses this problem for a general-purpose optimization technique, the worker/wrapper transformation. In particular, we use the call-by-need variant of improvement theory to establish conditions under which the worker/wrapper transformation is formally guaranteed to preserve or improve the time performance of programs in lazy languages such as Haskell.", "paper_title": "Worker/Wrapper/Makes it/Faster", "paper_id": "WOS:000349143000009"}