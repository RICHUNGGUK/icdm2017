{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "heap_data_growth_using_average_liveness"}, {"score": 0.004631335513513859, "phrase": "today's_programs"}, {"score": 0.004411588377842043, "phrase": "sizable_heap"}, {"score": 0.004284755353695709, "phrase": "dynamic_data"}, {"score": 0.004081385289516914, "phrase": "heap_dynamics"}, {"score": 0.003631671435460452, "phrase": "average_amount"}, {"score": 0.0028471655497661528, "phrase": "average_liveness"}, {"score": 0.0027651847105654363, "phrase": "linear-time_algorithms"}, {"score": 0.0025085435314540837, "phrase": "best_heap_size"}, {"score": 0.002320449502337321, "phrase": "java_tracing_system"}, {"score": 0.0022756672722130424, "phrase": "elephant_tracks"}, {"score": 0.0021674482571326283, "phrase": "dacapo_benchmarks"}], "paper_keywords": ["algorithms", " performance", " measurement", " liveness", " all-window statistics", " GC frequency", " heap data growth"], "paper_abstract": "Most of today's programs make use of a sizable heap to store dynamic data. To characterize the heap dynamics, this paper presents a set of metrics to measure the average amount of data live and dead in a period of execution. They are collectively called average liveness. The paper defines these metrics of average liveness, gives linear-time algorithms for measurement, and discusses their use in finding the best heap size. The algorithms are implemented in a Java tracing system called Elephant Tracks and evaluated using the DaCapo benchmarks running on the Oracle HotSpot and IBM J9 Java virtual machines.", "paper_title": "Modeling Heap Data Growth Using Average Liveness", "paper_id": "WOS:000358310800007"}