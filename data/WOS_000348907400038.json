{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "compiler_verification_meets_cross-language_linking"}, {"score": 0.004745056850725867, "phrase": "data_abstraction"}, {"score": 0.004541377162789232, "phrase": "multiple_different_programming_languages"}, {"score": 0.004252063063815893, "phrase": "formal_compiler_verification"}, {"score": 0.003952082333580496, "phrase": "high-level_language"}, {"score": 0.003810093416457147, "phrase": "compiler_correctness_theorem"}, {"score": 0.0036731870109004993, "phrase": "partial-correctness_hoare-logic_theorems"}, {"score": 0.003489714006817602, "phrase": "assembly_code_output"}, {"score": 0.0033890026927890058, "phrase": "assembly_code"}, {"score": 0.0031728680535262083, "phrase": "storable_cross-language_function_pointers"}, {"score": 0.003036468052876648, "phrase": "usual_benefits"}, {"score": 0.002905914725757534, "phrase": "different_compiler_phases"}, {"score": 0.002622647280008795, "phrase": "key_technical_innovation"}, {"score": 0.002565626044684815, "phrase": "mixed_operational_and_axiomatic_semantics"}, {"score": 0.002419542935774618, "phrase": "built-in_notion"}, {"score": 0.0023843376332011936, "phrase": "abstract_data_types"}, {"score": 0.002315452777999619, "phrase": "compiled_code_interfaces"}, {"score": 0.0022321322970228308, "phrase": "axiomatically_specified_methods"}, {"score": 0.0021676351850669017, "phrase": "private_data"}], "paper_keywords": ["compiler verification", " cross-language linking", " abstract data types", " program logics"], "paper_abstract": "Many real programs are written in multiple different programming languages, and supporting this pattern creates challenges for formal compiler verification. We describe our Coq verification of a compiler for a high-level language, such that the compiler correctness theorem allows us to derive partial-correctness Hoare-logic theorems for programs built by linking the assembly code output by our compiler and assembly code produced by other means. Our compiler supports such tricky features as storable cross-language function pointers, without giving up the usual benefits of being able to verify different compiler phases (including, in our case, two classic optimizations) independently. The key technical innovation is a mixed operational and axiomatic semantics for the source language, with a built-in notion of abstract data types, such that compiled code interfaces with other languages only through axiomatically specified methods that mutate encapsulated private data, represented in whatever formats are most natural for those languages.", "paper_title": "Compiler Verification Meets Cross-Language Linking via Data Abstraction", "paper_id": "WOS:000348907400038"}