{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "square_substrings"}, {"score": 0.004208881856146758, "phrase": "labeled_tree"}, {"score": 0.0039729853486821995, "phrase": "first_one"}, {"score": 0.0038230844545071303, "phrase": "distinct_squares"}, {"score": 0.0035856674209019234, "phrase": "crochemore_et_al"}, {"score": 0.003256808693019209, "phrase": "classical_strings"}, {"score": 0.002977061391551631, "phrase": "compact_representation"}, {"score": 0.0028463059289874637, "phrase": "maximal_cyclic_shifts"}, {"score": 0.0026865721000905235, "phrase": "second_obstacle"}, {"score": 0.0026184796288543878, "phrase": "adequate_algorithmic_tools"}, {"score": 0.002585081657512565, "phrase": "labeled_trees"}, {"score": 0.002259054486157494, "phrase": "imre_simon's_compact_representations"}, {"score": 0.0022159566043745724, "phrase": "failure_table"}, {"score": 0.0021876814398268775, "phrase": "pattern_matching_machines"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Tree", " Square in string", " Pattern matching"], "paper_abstract": "We give an algorithm which in O (n log(2)n) time counts all distinct squares in a labeled tree. There are two main obstacles to overcome. The first one is that the number of distinct squares in a tree is Omega(n(4/3)) (see Crochemore et al., 2012 17]), which differs substantially from the case of classical strings for which there are only linearly many distinct squares. We overcome this obstacle by using a compact representation of all squares (based on maximal cyclic shifts) which requires only O(n logn) space. The second obstacle is lack of adequate algorithmic tools for labeled trees, consequently we design several novel tools, this is the most complex part of the paper. In particular we extend to trees Imre Simon's compact representations of the failure table in pattern matching machines. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Efficient counting of square substrings in a tree", "paper_id": "WOS:000339536200005"}