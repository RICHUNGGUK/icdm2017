{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multi-threaded_programs"}, {"score": 0.04741138420449486, "phrase": "dynamic_thread_creation"}, {"score": 0.04631011650344564, "phrase": "regression_verification"}, {"score": 0.027895402021148232, "phrase": "concurrent_programs"}, {"score": 0.004021689117050817, "phrase": "arbitrary_yet_equal_context"}, {"score": 0.003414153126809511, "phrase": "single-threaded_deterministic_programs"}, {"score": 0.0027817658627604653, "phrase": "sequential_functions"}, {"score": 0.002322689143237591, "phrase": "fully_automatic_way"}, {"score": 0.002266246304762945, "phrase": "general_programs"}, {"score": 0.0021049977753042253, "phrase": "classical_verification"}], "paper_keywords": ["Regression verification", " Proving equivalence of programs", " Multi-threaded programs"], "paper_abstract": "Regression verification is the problem of deciding whether two similar programs are equivalent under an arbitrary yet equal context, given some definition of equivalence. So far this problem has only been studied for the case of single-threaded deterministic programs. We present a method for regression verification of multi-threaded programs. Specifically, we develop a proof-rule whose premise requires only to verify equivalence between sequential functions, whereas their consequents are equivalence of concurrent programs. This ability to avoid composing threads altogether when discharging premises, in a fully automatic way and for general programs, uniquely distinguishes our proof rule from others used for classical verification of concurrent programs. We also consider the effect of dynamic thread creation and synchronization primitives.", "paper_title": "Regression verification for multi-threaded programs (with extensions to locks and dynamic thread creation)", "paper_id": "WOS:000368632600002"}