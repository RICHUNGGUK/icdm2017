{"auto_keywords": [{"score": 0.03630916610929368, "phrase": "system_membership"}, {"score": 0.03370178240591534, "phrase": "membership_service"}, {"score": 0.00481495049065317, "phrase": "large-scale_reliable_storage_systems"}, {"score": 0.004778088905211055, "phrase": "byzantine-fault-tolerant_replication"}, {"score": 0.004651271219032404, "phrase": "internet_services"}, {"score": 0.004597951649247307, "phrase": "critical_state"}, {"score": 0.004475893575036647, "phrase": "software_errors"}, {"score": 0.004407599980762272, "phrase": "existing_byzantine-fault-tolerant_storage_systems"}, {"score": 0.003912335018240945, "phrase": "consistency_levels"}, {"score": 0.003622642432563435, "phrase": "system_lifetime"}, {"score": 0.0034993519231560637, "phrase": "complete_solution"}, {"score": 0.0034063576796640603, "phrase": "large-scale_byzantine-fault-tolerant_system"}, {"score": 0.00322769360059123, "phrase": "membership_changes"}, {"score": 0.0031058249097051555, "phrase": "human_configuration_errors"}, {"score": 0.0028867712833776046, "phrase": "consistent_views"}, {"score": 0.002703869368554536, "phrase": "novel_distributed_hash_table"}, {"score": 0.0026523079380037706, "phrase": "atomic_semantics"}, {"score": 0.002601727192945944, "phrase": "replica_sets"}, {"score": 0.0025034338848015187, "phrase": "existing_byzantine_quorum_protocols"}, {"score": 0.002372015603684862, "phrase": "previous_dhts"}, {"score": 0.002344762593995099, "phrase": "byzantine_fault_tolerance"}, {"score": 0.0023178219772486868, "phrase": "strong_semantics"}, {"score": 0.002256155453630723, "phrase": "dbqs._our_results"}, {"score": 0.0021049977753042253, "phrase": "large_system"}], "paper_keywords": ["Byzantine fault tolerance", " membership service", " dynamic system membership", " distributed hash tables"], "paper_abstract": "Byzantine-fault-tolerant replication enhances the availability and reliability of Internet services that store critical state and preserve it despite attacks or software errors. However, existing Byzantine-fault-tolerant storage systems either assume a static set of replicas, or have limitations in how they handle reconfigurations (e. g., in terms of the scalability of the solutions or the consistency levels they provide). This can be problematic in long-lived, large-scale systems where system membership is likely to change during the system lifetime. In this paper, we present a complete solution for dynamically changing system membership in a large-scale Byzantine-fault-tolerant system. We present a service that tracks system membership and periodically notifies other system nodes of membership changes. The membership service runs mostly automatically, to avoid human configuration errors; is itself Byzantine-fault-tolerant and reconfigurable; and provides applications with a sequence of consistent views of the system membership. We demonstrate the utility of this membership service by using it in a novel distributed hash table called dBQS that provides atomic semantics even across changes in replica sets. dBQS is interesting in its own right because its storage algorithms extend existing Byzantine quorum protocols to handle changes in the replica set, and because it differs from previous DHTs by providing Byzantine fault tolerance and offering strong semantics. We implemented the membership service and dBQS. Our results show that the approach works well, in practice: the membership service is able to manage a large system and the cost to change the system membership is low.", "paper_title": "Automatic Reconfiguration for Large-Scale Reliable Storage Systems", "paper_id": "WOS:000299280300001"}