{"auto_keywords": [{"score": 0.04381015920982132, "phrase": "tfa"}, {"score": 0.00481495049065317, "phrase": "light_combinators"}, {"score": 0.004777744121315302, "phrase": "finite_fields"}, {"score": 0.004525190364108967, "phrase": "basic_arithmetic_operations"}, {"score": 0.004490212943845175, "phrase": "binary_finite_fields"}, {"score": 0.00440394242852293, "phrase": "functional_terms"}, {"score": 0.004269329235934791, "phrase": "typeable_functional_assembly"}, {"score": 0.004106810349956121, "phrase": "dual_light_affine_logic"}, {"score": 0.003981243132108877, "phrase": "type_assignment"}, {"score": 0.003889583851551197, "phrase": "implicit_computational_complexity"}, {"score": 0.0038595097660519607, "phrase": "icc"}, {"score": 0.0037853015963603682, "phrase": "polynomial_time"}, {"score": 0.0036553070575015344, "phrase": "functional_programming_patterns"}, {"score": 0.0035297609635321203, "phrase": "cryptographic_primitives"}, {"score": 0.003408512155673965, "phrase": "least_hand-made_tuning"}, {"score": 0.0031050953733360825, "phrase": "potentially_interesting_low_cost_programs"}, {"score": 0.003010063382882408, "phrase": "predetermined_complexity"}, {"score": 0.002940697344380201, "phrase": "known_and_future_icc_compliant_programming_language"}, {"score": 0.0026788122684116224, "phrase": "comparable_interest"}, {"score": 0.0025867180355950816, "phrase": "applicative_outcome"}, {"score": 0.002310915790114425, "phrase": "binary_fields"}, {"score": 0.002248863090203165, "phrase": "known_and_efficient_imperative_implementation"}, {"score": 0.002137999646917136, "phrase": "fong's_implementation"}, {"score": 0.0021049977753042253, "phrase": "specific_hardware_architectures"}], "paper_keywords": ["Lambda calculus", " Finite fields arithmetic", " Type assignments", " Implicit computational complexity"], "paper_abstract": "This work completes the definition of a library which provides the basic arithmetic operations in binary finite fields as a set of functional terms with very specific features. Such a functional terms have type in Typeable Functional Assembly (TFA). TFA is an extension of Dual Light Affine Logic (DLAL). DIAL is a type assignment designed under the prescriptions of Implicit Computational Complexity (ICC), which characterises polynomial time costing computations. We plan to exploit the functional programming patterns of the terms in the library to implement cryptographic primitives whose running-time efficiency can be obtained by means of the least hand-made tuning as possible. We propose the library as a benchmark. It fixes a kind of lower bound on the difficulty of writing potentially interesting low cost programs inside languages that can express only computations with predetermined complexity. In principle, every known and future ICC compliant programming language for polynomially costing computations should supply a simplification over the encoding of the library we present, or some set of combinators of comparable interest and difficulty. We finally report on the applicative outcome that our library has and which is a reward we get by programming in the very restrictive scenario that TFA provides. The term of TFA which encodes the inversion in binary fields suggested us a variant of a known and efficient imperative implementation of the inversion itself given by Fong. Our variant, can outperform Fong's implementation of inversion on specific hardware architectures. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Light combinators for finite fields arithmetic", "paper_id": "WOS:000368556800002"}