{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "kahn"}, {"score": 0.004689650818647484, "phrase": "real-time_systems"}, {"score": 0.004621447740470602, "phrase": "high-performance_stream-processing_systems"}, {"score": 0.004461761855323898, "phrase": "high-end_tv"}, {"score": 0.00438399094249306, "phrase": "medical_imaging"}, {"score": 0.004307569753106432, "phrase": "surprisingly_demanding_task"}, {"score": 0.004232475065285966, "phrase": "algorithmic_and_conceptual_simplicity"}, {"score": 0.004134372859330047, "phrase": "close_cooperation"}, {"score": 0.0041102032028337366, "phrase": "numerical_analysts"}, {"score": 0.00408617426304956, "phrase": "parallel_programming_experts"}, {"score": 0.0040622852274783275, "phrase": "real-time_control_experts"}, {"score": 0.0039449104968131655, "phrase": "quality_insurance"}, {"score": 0.0038647641000798135, "phrase": "improved_productivity"}, {"score": 0.0038085117064624208, "phrase": "programming_model"}, {"score": 0.0037530749925749245, "phrase": "high-performance_stream_processing"}, {"score": 0.003676811616723809, "phrase": "synchronous_programming_model"}, {"score": 0.003644601816390735, "phrase": "domain_knowledge"}, {"score": 0.0036126731589251906, "phrase": "periodic_evolution"}, {"score": 0.0035082436540296406, "phrase": "construction_properties"}, {"score": 0.0033968425231674262, "phrase": "resource_requirements"}, {"score": 0.0033572130837348623, "phrase": "input_and_output_streams"}, {"score": 0.003298631258267805, "phrase": "tedious_and_error-prone_engineering"}, {"score": 0.0031845067058084613, "phrase": "multiple_data_rates"}, {"score": 0.0029766550209309127, "phrase": "relaxed_notion"}, {"score": 0.0029592333031063156, "phrase": "synchronous_composition"}, {"score": 0.0027823318789880714, "phrase": "fifo_buffer"}, {"score": 0.00270978310478061, "phrase": "core_synchronous_data-flow_language"}, {"score": 0.002670296619878048, "phrase": "periodic_clocks"}, {"score": 0.0026313840069327713, "phrase": "relaxed_clock_calculus"}, {"score": 0.002555247330102505, "phrase": "non_strictly_synchronous_processes"}, {"score": 0.002409503258044183, "phrase": "buffer_insertion"}, {"score": 0.002326068563512387, "phrase": "clock_types"}, {"score": 0.0023056642309229017, "phrase": "systematic_transformation"}, {"score": 0.0022854384756395116, "phrase": "standard_synchronous_program"}, {"score": 0.0021613897794439227, "phrase": "synchronization_transformation"}, {"score": 0.0021049977753042253, "phrase": "existing_formalisms"}], "paper_keywords": ["algorithms", " languages", " security", " theory", " correctness by construction", " resource constraints", " streaming applications", " Subtyping", " synchronous languages"], "paper_abstract": "The design of high-performance stream-processing systems is a fast growing domain, driven by markets such like high-end TV, gaming, 3D animation and medical imaging. It is also a surprisingly demanding task, with respect to the algorithmic and conceptual simplicity of streaming applications. It needs the close cooperation between numerical analysts, parallel programming experts, real-time control experts and computer architects, and incurs a very high level of quality insurance and optimization. In search for improved productivity, we propose a programming model and language dedicated to high-performance stream processing. This language builds on the synchronous programming model and on domain knowledge - the periodic evolution of streams - to allow correct-by-construction properties to be proven by the compiler. These properties include resource requirements and delays between input and output streams. Automating this task avoids tedious and error-prone engineering, due to the combinatorics of the composition of filters with multiple data rates and formats. Correctness of the implementation is also difficult to assess with traditional (asynchronous, simulation-based) approaches. This language is thus provided with a relaxed notion of synchronous composition, called n-synchrony: two processes are n-synchronous if they can communicate in the ordinary (0-)synchronous model with a FIFO buffer of size n. Technically, we extend a core synchronous data-flow language with a notion of periodic clocks, and design a relaxed clock calculus (a type system for clocks) to allow non strictly synchronous processes to be composed or correlated. This relaxation is associated with two sub-typing rules in the clock calculus. Delay, buffer insertion and control code for these buffers are automatically inferred from the clock types through a systematic transformation into a standard synchronous program. We formally define the semantics of the language and prove the soundness and completeness of its clock calculus and synchronization transformation. Finally, the language is compared with existing formalisms.", "paper_title": "N-synchronous Kahn networks - A relaxed model of synchrony for real-time systems", "paper_id": "WOS:000235615800018"}