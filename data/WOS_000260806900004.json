{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "search._backtracking_search"}, {"score": 0.004523272849033429, "phrase": "constraint_satisfaction"}, {"score": 0.0044608829094248985, "phrase": "propositional_satisfiability_problems"}, {"score": 0.004399349717218995, "phrase": "previous_studies"}, {"score": 0.003855347387268162, "phrase": "algorithms_-_can_dramatically_improve_performance"}, {"score": 0.0030017207229983385, "phrase": "problem_instances"}, {"score": 0.0027806165169981622, "phrase": "computational_resources"}, {"score": 0.0024876840172100567, "phrase": "simple_scheme"}, {"score": 0.002419393934835993, "phrase": "good_portfolio"}, {"score": 0.002320449502337321, "phrase": "small_sample"}, {"score": 0.002134508934917511, "phrase": "extensive_empirical_evaluation"}], "paper_keywords": ["Constraint satisfaction", " satisfiability", " backtracking search", " portfolios", " restarts"], "paper_abstract": "Backtracking search is often the method of choice for solving constraint satisfaction and propositional satisfiability problems. Previous studies have shown that portfolios of backtracking algorithms - a selection of one or more algorithms plus a schedule for executing the algorithms - can dramatically improve performance on some instances. In this paper, we consider a setting that often arises in practice where the instances to be solved arise over time, the instances all belong to some class of problem instances, and a limit or deadline is placed on the computational resources that can be consumed in solving any instance. For such a scenario, we present a simple scheme for learning a good portfolio of backtracking algorithms from a small sample of instances. We demonstrate the effectiveness of our approach through an extensive empirical evaluation using two testbeds: real-world instruction scheduling problems and the widely used quasigroup completion problems.", "paper_title": "PORTFOLIOS WITH DEADLINES FOR BACKTRACKING SEARCH", "paper_id": "WOS:000260806900004"}