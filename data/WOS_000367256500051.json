{"auto_keywords": [{"score": 0.03824046507309785, "phrase": "disjointness_domains"}, {"score": 0.00481495049065317, "phrase": "fine-grained_aliasing"}, {"score": 0.004681653551412616, "phrase": "useful_implementation_patterns"}, {"score": 0.00458869631642791, "phrase": "reasoning_about_programs"}, {"score": 0.004425979295788883, "phrase": "numerous_type-based_aliasing_control_mechanisms"}, {"score": 0.0037544644262310525, "phrase": "entire_system"}, {"score": 0.0036651042289628324, "phrase": "changing_requirements"}, {"score": 0.003549245218355768, "phrase": "alias_control"}, {"score": 0.0033958751452139984, "phrase": "arbitrary_reference_sharing"}, {"score": 0.0033283624928018177, "phrase": "aliasing_constraints"}, {"score": 0.0028229071631385634, "phrase": "different_sets"}, {"score": 0.002625914195439153, "phrase": "programmer_reason"}, {"score": 0.0025736694380861604, "phrase": "local_alias_invariants"}, {"score": 0.00254282157860369, "phrase": "resulting_system"}, {"score": 0.0025224615049571427, "phrase": "fine-grained_control"}, {"score": 0.0022904619303011097, "phrase": "formal_account"}, {"score": 0.002209060366991921, "phrase": "novel_means"}, {"score": 0.002182573128803447, "phrase": "may-alias_kinds"}, {"score": 0.0021049977753042253, "phrase": "compiler_optimisation"}], "paper_keywords": ["Design", " Theory", " Aliasing", " mutable state", " type systems", " uniqueness", " linear types"], "paper_abstract": "Aliasing is crucial for supporting useful implementation patterns, but it makes reasoning about programs difficult. To deal with this problem, numerous type-based aliasing control mechanisms have been proposed, expressing properties such as uniqueness. Uniqueness, however, is black-and-white: either a reference is unique or it can be arbitrarily aliased; and global: excluding aliases throughout the entire system, making code brittle to changing requirements. Disjointness domains, a new approach to alias control, address this problem by enabling more graduations between uniqueness and arbitrary reference sharing. They allow expressing aliasing constraints local to a certain set of variables (either stack variables or fields) for instance that no aliasing occurs between variables within some set of variables but between such sets or the opposite, that aliasing occurs within that set but not between different sets. A hierarchy of disjointness domains controls the flow of references through a program, helping the programmer reason about disjointness and enforce local alias invariants. The resulting system supports fine-grained control of aliasing between both variables and objects, making aliasing explicit to programmers, compilers, and tooling. This paper presents a formal account of disjointness domains along with examples. Disjointness domains provide novel means of expressing may-alias kinds of constraints, which may prove useful in compiler optimisation and verification.", "paper_title": "Disjointness Domains for Fine-Grained Aliasing", "paper_id": "WOS:000367256500051"}