{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "unbounded-length_keys"}, {"score": 0.04042336937151307, "phrase": "proposed_technique"}, {"score": 0.03936065961412097, "phrase": "input_symbol"}, {"score": 0.02783462458191885, "phrase": "space_complexity"}, {"score": 0.004792840757660423, "phrase": "comparison-driven_data_structures"}, {"score": 0.004770832063470752, "phrase": "applications_to_online_indexing."}, {"score": 0.004716249376880935, "phrase": "general_technique"}, {"score": 0.004662288240753673, "phrase": "dynamic_data_structure"}, {"score": 0.004619562134026677, "phrase": "atomic_and_indivisible_keys"}, {"score": 0.004598345457673231, "phrase": "constant-time_comparisons"}, {"score": 0.004556202652548916, "phrase": "data_structure"}, {"score": 0.004361215881131241, "phrase": "multidimensional_points"}, {"score": 0.004341180559883005, "phrase": "multiple-precision_numbers"}, {"score": 0.004242370305722692, "phrase": "url_addresses"}, {"score": 0.0040983385298583854, "phrase": "previous_work"}, {"score": 0.004070121948473653, "phrase": "particular_exploitation"}, {"score": 0.0040420988464698205, "phrase": "underlying_structure"}, {"score": 0.0038335435766197468, "phrase": "online_suffix_tree_construction"}, {"score": 0.0037896434956091293, "phrase": "worst_case_time"}, {"score": 0.003618995121318962, "phrase": "previously_known_algorithms"}, {"score": 0.003408549032776724, "phrase": "length_m"}, {"score": 0.003385065429154632, "phrase": "resulting_suffix_tree"}, {"score": 0.003363255509016693, "phrase": "sigma"}, {"score": 0.003101199695695401, "phrase": "alternative_methods"}, {"score": 0.0030727355400175186, "phrase": "suffix_sorting"}, {"score": 0.0030586012826569952, "phrase": "dynamic_lowest_common_ancestors"}, {"score": 0.003037521337114139, "phrase": "order_maintenance"}, {"score": 0.0030165862354028183, "phrase": "technical_features"}, {"score": 0.0029342745825574374, "phrase": "new_data_structure_d"}, {"score": 0.0027955816112500537, "phrase": "dietz-sleator_list"}, {"score": 0.0025788036065810356, "phrase": "memory_cells"}, {"score": 0.002561021942189551, "phrase": "n_keys"}, {"score": 0.0023733139437625587, "phrase": "time_complexity"}, {"score": 0.0023569458471923237, "phrase": "corresponding_operation"}, {"score": 0.002204413784381033, "phrase": "vertical_bar"}, {"score": 0.002159109661276094, "phrase": "special_case"}, {"score": 0.0021049977753042253, "phrase": "achieved_insertion_time"}], "paper_keywords": ["strings", " search trees", " text indexing", " suffix tree", " suffix sorting"], "paper_abstract": "This paper presents a general technique for optimally transforming any dynamic data structure that operates on atomic and indivisible keys by constant-time comparisons, into a data structure that handles unbounded-length keys whose comparison cost is not a constant. Examples of these keys are strings, multidimensional points, multiple-precision numbers, multikey data (e. g., records), XML paths, URL addresses, etc. The technique is more general than what has been done in previous work as no particular exploitation of the underlying structure is required. The only requirement is that the insertion of a key must identify its predecessor or its successor. Using the proposed technique, online suffix tree construction can be done in worst case time O(log n) per input symbol (as opposed to amortized O(log n) time per symbol, achieved by previously known algorithms). To our knowledge, our algorithm is the first that achieves O(log n) worst case time per input symbol. Searching for a pattern of length m in the resulting suffix tree takes O(min(m log vertical bar Sigma vertical bar, m + log n) + tocc) time, where tocc is the number of occurrences of the pattern. The paper also describes more applications and shows how to obtain alternative methods for dealing with suffix sorting, dynamic lowest common ancestors, and order maintenance. The technical features of the proposed technique for a given data structure D are the following ones. The new data structure D' is obtained from D by augmenting the latter with an oracle for strings, extending the functionalities of the Dietz-Sleator list for order maintenance [P. F. Dietz and D. D. Sleator, Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing, ACM, New York, 1987, pp. 365-372; A. Tsakalidis, Acta Inform., 21 (1984), pp. 101-112]. The space complexity of D' is S(n)+ O(n) memory cells for storing n keys, where S(n) denotes the space complexity of D. Then, each operation involving O(1) keys taken from D' requires O(T(n)) time, where T(n) denotes the time complexity of the corresponding operation originally supported in D. Each operation involving a key y not stored in D' takes O(T(n) + vertical bar y vertical bar) time, where vertical bar y vertical bar denotes the length of y. For the special case where the oracle handles suffixes of a string, the achieved insertion time is O(T(n)).", "paper_title": "MANAGING UNBOUNDED-LENGTH KEYS IN COMPARISON-DRIVEN DATA STRUCTURES WITH APPLICATIONS TO ONLINE INDEXING", "paper_id": "WOS:000341576200006"}