{"auto_keywords": [{"score": 0.025043029570240877, "phrase": "mold"}, {"score": 0.00481495049065317, "phrase": "imperative_code"}, {"score": 0.0045411156682300695, "phrase": "automatic_translation"}, {"score": 0.004395742407834023, "phrase": "parallel_mapreduce_framework"}, {"score": 0.00419997182602686, "phrase": "imperative_updates"}, {"score": 0.004039094712469991, "phrase": "functional_mapreduce_form"}, {"score": 0.0035923719610602214, "phrase": "input_code"}, {"score": 0.0035228596881051763, "phrase": "functional_representation"}, {"score": 0.0033658327434624457, "phrase": "fold_operations"}, {"score": 0.003236802914194731, "phrase": "rewrite_rules"}, {"score": 0.0030924870122337905, "phrase": "equivalent_programs"}, {"score": 0.0030326180561817497, "phrase": "effective_mapreduce_implementation"}, {"score": 0.0029163246959273605, "phrase": "novel_technique"}, {"score": 0.002859856368059419, "phrase": "irregular_loop-carried_dependencies"}, {"score": 0.0027145478956494356, "phrase": "greater_parallelism"}, {"score": 0.002543224008253855, "phrase": "mold."}, {"score": 0.0024939618994290016, "phrase": "sequential_java_code"}, {"score": 0.002413964586947992, "phrase": "apache_spark_runtime"}, {"score": 0.002189009136006588, "phrase": "desired_mapreduce_program"}, {"score": 0.0021049977753042253, "phrase": "complex_indirect_updates"}], "paper_keywords": ["Program Translation", " Rewriting", " Imperative", " Functional", " MapReduce", " Scala"], "paper_abstract": "We present an approach for automatic translation of sequential, imperative code into a parallel MapReduce framework. Automating such a translation is challenging: imperative updates must be translated into a functional MapReduce form in a manner that both preserves semantics and enables parallelism. Our approach works by first translating the input code into a functional representation, with loops succinctly represented by fold operations. Then, guided by rewrite rules, our system searches a space of equivalent programs for an effective MapReduce implementation. The rules include a novel technique for handling irregular loop-carried dependencies using group-by operations to enable greater parallelism. We have implemented our technique in a tool called MOLD. It translates sequential Java code into code targeting the Apache Spark runtime. We evaluated MOLD on several real-world kernels and found that in most cases MOLD generated the desired MapReduce program, even for codes with complex indirect updates.", "paper_title": "Translating Imperative Code to MapReduce", "paper_id": "WOS:000348907400052"}