{"auto_keywords": [{"score": 0.02747266016192697, "phrase": "lustre"}, {"score": 0.01186911282282415, "phrase": "supercollider"}, {"score": 0.005320794513071683, "phrase": "esterel"}, {"score": 0.00481495049065317, "phrase": "synchronous_programming"}, {"score": 0.004764542405129454, "phrase": "audio_processing"}, {"score": 0.00468991337957911, "phrase": "lookup_table_oscillator_case_study"}, {"score": 0.004544127927346964, "phrase": "programming_language"}, {"score": 0.004426092397211699, "phrase": "application_domain"}, {"score": 0.004199101289890982, "phrase": "software_development"}, {"score": 0.0039006600544599537, "phrase": "informed_decision"}, {"score": 0.003720060615588018, "phrase": "particular_version"}, {"score": 0.0035477930970463432, "phrase": "general-purpose_synchronous_programming_languages"}, {"score": 0.003492155652400838, "phrase": "domain-specific_languages"}, {"score": 0.0033480035183418642, "phrase": "computer_music"}, {"score": 0.003061072337623773, "phrase": "sound_synthesis"}, {"score": 0.0029657683623403085, "phrase": "significant_synchronous_programming_languages"}, {"score": 0.002858313353461727, "phrase": "specific_music_languages"}, {"score": 0.002613239644974825, "phrase": "general_synchronous_formalisms-signal"}, {"score": 0.0025318431634446426, "phrase": "lucid_synchrone"}, {"score": 0.0023891283748647416, "phrase": "initial_specification"}, {"score": 0.002219040041886641, "phrase": "language_designers"}, {"score": 0.0021957487795963666, "phrase": "possibly_software_developers"}, {"score": 0.0021385822825864425, "phrase": "programming_languages_design"}, {"score": 0.0021049977753042253, "phrase": "audio_domain"}], "paper_keywords": ["Design", " Languages", " Synchronous programming languages", " music programming languages", " computer music", " signal processing", " timing"], "paper_abstract": "The adequacy of a programming language to a given software project or application domain is often considered a key factor of success in software development and engineering, even though little theoretical or practical information is readily available to help make an informed decision. In this article, we address a particular version of this issue by comparing the adequacy of general-purpose synchronous programming languages to more Domain-Specific Languages (DSLs) in the field of computer music. More precisely, we implemented and tested the same lookup table oscillator example program, one of the most classical algorithms for sound synthesis, using a selection of significant synchronous programming languages, half of which designed as specific music languages-Csound, Pure Data, SuperCollider, ChucK, Faust- and the other half being general synchronous formalisms-Signal, Lustre, Esterel, Lucid Synchrone and C with the OpenMP Stream Extension (Matlab/Octave is used for the initial specification). The advantages of these two approaches are discussed, providing insights to language designers and possibly software developers of both communities regarding programming languages design for the audio domain.", "paper_title": "Synchronous Programming in Audio Processing: A Lookup Table Oscillator Case Study", "paper_id": "WOS:000330778700010"}