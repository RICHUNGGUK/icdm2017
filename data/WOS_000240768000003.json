{"auto_keywords": [{"score": 0.03348422535817348, "phrase": "total_runtime"}, {"score": 0.00481495049065317, "phrase": "sun's_java"}, {"score": 0.004769444094319619, "phrase": "just-in-time_compilers"}, {"score": 0.004420472010542188, "phrase": "sun's_hotspot_compilers"}, {"score": 0.004019797503157808, "phrase": "high-level_program_transformations"}, {"score": 0.003944112858235306, "phrase": "low-level_architecure_dependent_operations"}, {"score": 0.002937153116494391, "phrase": "individual_optimizations"}, {"score": 0.0028006988338192375, "phrase": "main_optimizations"}, {"score": 0.0027218799769229596, "phrase": "sun_hotspot_compilers"}, {"score": 0.0026452734009203764, "phrase": "wide_range"}, {"score": 0.0025954008219792337, "phrase": "scientific_and_non-scientific_benchmarks"}, {"score": 0.0022933216359142736, "phrase": "hotspot_technology"}], "paper_keywords": ["dynamic compilation", " Just-in-Time compiler", " compiler optimizations"], "paper_abstract": "Modern Java Compilers, such as Sun's HotSpot compilers, implement a number of optimizations, ranging from high-level program transformations to low-level architecure dependent operations such as instruction scheduling. In a Just-in-Time (JIT) environment, the impact of each optimization must be weighed against its cost in terms of total runtime. Towards better understanding the usefulness of individual optimizations, we study the main optimizations available on Sun HotSpot compilers for a wide range of scientific and non-scientific benchmarks, weighing their cost and benefits in total runtime. We chose the HotSpot technology because it is state of the art and its source code is available.", "paper_title": "Our experiences with optimizations in Sun's Java Just-in-Time compilers", "paper_id": "WOS:000240768000003"}