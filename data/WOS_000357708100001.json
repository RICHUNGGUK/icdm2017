{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "signed_data"}, {"score": 0.049378038061471535, "phrase": "partial_data_integrity"}, {"score": 0.03639249050492224, "phrase": "modified_blocks"}, {"score": 0.003945117054416623, "phrase": "n_blocks"}, {"score": 0.0036373553416391823, "phrase": "threshold_d"}, {"score": 0.0035054881943660096, "phrase": "maximum_amount"}, {"score": 0.0032319109979344184, "phrase": "efficient_algorithms"}, {"score": 0.0030239842475439814, "phrase": "reasonably_compact_signature_size"}, {"score": 0.0029576827451501956, "phrase": "controlled_sizes"}, {"score": 0.00266693888510356, "phrase": "standard_signature_size"}, {"score": 0.002233301265743633, "phrase": "nonadaptive_combinatorial_group_testing"}, {"score": 0.0022005118194652704, "phrase": "cover-free_families"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Digital signatures", " Partial data integrity", " Modification localization", " Combinatorial group testing", " Cover-free families", " Cryptography"], "paper_abstract": "We consider the problem of detecting and locating modifications in signed data to ensure partial data integrity. We assume that the data is divided into n blocks (not necessarily of the same size) and that a threshold d is given for the maximum amount of modified blocks that the scheme can support. We propose efficient algorithms for signature and verification steps which provide a reasonably compact signature size, for controlled sizes of d with respect to n. For instance, for fixed d the standard signature size gets multiplied by a factor of O (logn), while allowing the identification of up to d modified blocks. Our scheme is based on nonadaptive combinatorial group testing and cover-free families. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Locating modifications in signed data for partial data integrity", "paper_id": "WOS:000357708100001"}