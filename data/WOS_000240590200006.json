{"auto_keywords": [{"score": 0.04952134781811598, "phrase": "si"}, {"score": 0.00481495049065317, "phrase": "structural_invariants"}, {"score": 0.004487989502479992, "phrase": "verification_condition"}, {"score": 0.004358368398332723, "phrase": "static_single_assignment_form"}, {"score": 0.004257360656055417, "phrase": "linear_pass"}, {"score": 0.004183137595671171, "phrase": "dominator_tree"}, {"score": 0.003968112038249246, "phrase": "program_location"}, {"score": 0.0038085117064624208, "phrase": "program_statements"}, {"score": 0.0035496495489801667, "phrase": "k-level_si"}, {"score": 0.003447035529485425, "phrase": "dominating_join_points"}, {"score": 0.003212663446866794, "phrase": "join_point"}, {"score": 0.003119760592916715, "phrase": "tunable_selector"}, {"score": 0.0029766550209309127, "phrase": "program_paths"}, {"score": 0.00284009509859163, "phrase": "correspondingly_the_time"}, {"score": 0.0027741761880779535, "phrase": "validity_query"}, {"score": 0.002615977783510631, "phrase": "large_programs"}, {"score": 0.0023674192513753996, "phrase": "open-source_programs"}, {"score": 0.002258745901862197, "phrase": "specialized_analyses"}, {"score": 0.002142426911242168, "phrase": "automatic_and_scalable_algorithm"}, {"score": 0.0021049977753042253, "phrase": "low_false_positive_rate"}], "paper_keywords": [""], "paper_abstract": "We present structural invariants (SI), a new technique for incrementally overapproximating the verification condition of a program in static single assignment form by making a linear pass over the dominator tree of the program. The 1-level SI at a program location is the conjunction of all dominating program statements viewed as constraints. For any k, we define a k-level SI by recursively strengthening the dominating join points of the 1-level SI with the (k - 1)-level SI of the predecessors of the join point, thereby providing a tunable selector to add path-sensitivity incrementally. By ignoring program paths, the size of the SI and correspondingly the time to discharge the validity query remains small, allowing the technique to scale to large programs. We show experimentally that even with k <= 2, for a set of open-source programs totaling 570K lines and properties for which specialized analyses have been previously devised, our method provides an automatic and scalable algorithm with a low false positive rate.", "paper_title": "Structural invariants", "paper_id": "WOS:000240590200006"}