{"auto_keywords": [{"score": 0.048852464629815386, "phrase": "java"}, {"score": 0.02322619827072519, "phrase": "latte"}, {"score": 0.01934355522292897, "phrase": "local_variables"}, {"score": 0.008895411565740112, "phrase": "stack_entries"}, {"score": 0.0042656009036320585, "phrase": "java_bytecode"}, {"score": 0.004228839109569368, "phrase": "native_machine_code"}, {"score": 0.004120435930514554, "phrase": "java_jit_compilation"}, {"score": 0.0038613835226952117, "phrase": "register-based_computations"}, {"score": 0.0037786899855446, "phrase": "memory-based_ones"}, {"score": 0.0037299231609021783, "phrase": "jit_compilation_overhead"}, {"score": 0.0036500346000495317, "phrase": "whole_running_time"}, {"score": 0.003405671497507337, "phrase": "fast_generation"}, {"score": 0.0033762956164519286, "phrase": "efficiently_register-mapped_risc_code"}, {"score": 0.00327545462323687, "phrase": "\"_local_variables"}, {"score": 0.0031502008922533894, "phrase": "real_register_allocation"}, {"score": 0.0029012378668247397, "phrase": "latte's_sophisticated_register_mapping"}, {"score": 0.002802373595203129, "phrase": "twice_the_performance"}, {"score": 0.002766171878646582, "phrase": "naive_jit_compiler"}, {"score": 0.002449997042686432, "phrase": "register_mapping"}, {"score": 0.0021982976170703884, "phrase": "single-thread_java_performance"}, {"score": 0.0021049977753042253, "phrase": "memory_accesses"}], "paper_keywords": ["Java virtual machine", " just-in-time compilation", " register mapping", " register allocation", " copy coalescing"], "paper_abstract": "Java just-in-time (JIT) compilers improve the performance of a Java virtual machine (JVM) by translating Java bytecode into native machine code on demand. One important problem in Java JIT compilation is how to map stack entries and local variables to registers efficiently and quickly, since register-based computations are much faster than memory-based ones, while JIT compilation overhead is part of the whole running time. This paper introduces LaTTe, an open-source Java JIT compiler that performs fast generation of efficiently register-mapped RISC code. LaTTe first maps \"all\" local variables and stack entries into pseudoregisters, followed by real register allocation which also coalesces copies corresponding to pushes and pops between local variables and stack entries aggressively. Our experimental results indicate that LaTTe's sophisticated register mapping and allocation really pay off, achieving twice the performance of a naive JIT compiler that maps all local variables and stack entries to memory. It is also shown that LaTTe makes a reasonable trade-off between quality and speed of register mapping and allocation for the bytecode. We expect these results will also be beneficial to parallel and distributed Java computing 1) by enhancing single-thread Java performance and 2) by significantly reducing the number of memory accesses which the rest of the system must properly order to maintain coherence and keep threads synchronized.", "paper_title": "Efficient register mapping and allocation in LaTTe, an open-source Java just-in-time compiler", "paper_id": "WOS:000242312000005"}