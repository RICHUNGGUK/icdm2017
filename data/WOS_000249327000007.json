{"auto_keywords": [{"score": 0.03466338244607595, "phrase": "program_variables"}, {"score": 0.00481495049065317, "phrase": "modular_arithmetic"}, {"score": 0.004707913053935566, "phrase": "integer_arithmetic_modulo"}, {"score": 0.004500891637057374, "phrase": "mainstream_programming_languages"}, {"score": 0.004450813492665302, "phrase": "java"}, {"score": 0.004400804926266097, "phrase": "standard_implementations"}, {"score": 0.003802135020791801, "phrase": "zero_divisors"}, {"score": 0.00345530020388352, "phrase": "intra-_and_interprocedural_algorithms"}, {"score": 0.0033594249301033604, "phrase": "program_point"}, {"score": 0.0033218213825698417, "phrase": "affine_relations"}, {"score": 0.00319348234663792, "phrase": "conditional_branching"}, {"score": 0.0031223774204093713, "phrase": "nondeterministic_branching"}, {"score": 0.0028695095228791724, "phrase": "valid_affine_relations"}, {"score": 0.0028214413724451442, "phrase": "natural_class"}, {"score": 0.0026222551419772867, "phrase": "program_size"}, {"score": 0.0023694065215394593, "phrase": "target_language"}, {"score": 0.0021651504858015364, "phrase": "equality_guards"}, {"score": 0.0021049977753042253, "phrase": "interprocedural_setting"}], "paper_keywords": ["algorithms", " theory", " verification", " program analysis", " modular arithmetic", " abstract interpretation", " affine relation", " interprocedural analysis"], "paper_abstract": "We consider integer arithmetic modulo a power of 2 as provided by mainstream programming languages like Java or standard implementations of C. The difficulty here is that, for w > 1, the ring Z(m) of integers modulo m = 2(w) has zero divisors and thus cannot be embedded into a field. Not withstanding that, we present intra- and interprocedural algorithms for inferring for every program point u affine relations between program variables valid at u. If conditional branching is replaced with nondeterministic branching, our algorithms are not only sound but also complete in that they detect all valid affine relations in a natural class of programs. Moreover, they run in time linear in the program size and polynomial in the number of program variables and can be implemented by using the same modular integer arithmetic as the target language to be analyzed. We also indicate how our analysis can be extended to deal with equality guards, even in an interprocedural setting.", "paper_title": "Analysis of modular arithmetic", "paper_id": "WOS:000249327000007"}