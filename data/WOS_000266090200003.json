{"auto_keywords": [{"score": 0.04915285332263578, "phrase": "ufi"}, {"score": 0.00481495049065317, "phrase": "process_equivalence"}, {"score": 0.004748222479566159, "phrase": "ccs._unique_fixpoint_induction"}, {"score": 0.004669362683840143, "phrase": "chief_inference_rule"}, {"score": 0.004591806570773514, "phrase": "recursive_processes"}, {"score": 0.004528156929805637, "phrase": "communicating_systems"}, {"score": 0.004465390590641884, "phrase": "milner"}, {"score": 0.004378958522416482, "phrase": "major_role"}, {"score": 0.004342430078306461, "phrase": "equational_approach"}, {"score": 0.004294197002289641, "phrase": "equational_verification"}, {"score": 0.004258372598568333, "phrase": "special_interest"}, {"score": 0.004211069233133584, "phrase": "theoretical_advantages"}, {"score": 0.004083665825986903, "phrase": "infinite_state_space"}, {"score": 0.004049590638590415, "phrase": "parameterised_behaviour"}, {"score": 0.003883416084776375, "phrase": "value-passing"}, {"score": 0.003861779467354491, "phrase": "infinite-state"}, {"score": 0.003840261792655689, "phrase": "parameterised_systems"}, {"score": 0.003571171678599011, "phrase": "recursive_function_symbols"}, {"score": 0.003492217815589937, "phrase": "induction_rules"}, {"score": 0.0033208740593211467, "phrase": "process_substitution"}, {"score": 0.0031403029065308766, "phrase": "vips_verification"}, {"score": 0.0030451958332949735, "phrase": "existing_tools"}, {"score": 0.0030197596397721566, "phrase": "proof_task"}, {"score": 0.0029861739212143526, "phrase": "vpam"}, {"score": 0.002969573779903352, "phrase": "lin"}, {"score": 0.0028316582436089064, "phrase": "ufi."}, {"score": 0.002800158709933889, "phrase": "middle-out_reasoning"}, {"score": 0.0027845404283364837, "phrase": "bundy"}, {"score": 0.002524860443787105, "phrase": "processes'_state_space"}, {"score": 0.0024967652017219115, "phrase": "application_time"}, {"score": 0.0024278839351563764, "phrase": "equation_verification"}, {"score": 0.0023608984813230684, "phrase": "equation_plan"}, {"score": 0.002341164727388946, "phrase": "monroy_et_al"}, {"score": 0.0022324086872003985, "phrase": "automatic_verification_planner"}, {"score": 0.0021829882516961846, "phrase": "verification_problems"}, {"score": 0.0021049977753042253, "phrase": "current_degree"}], "paper_keywords": ["Unique fixpoint induction", " Equational verification Calculus of communicating systems"], "paper_abstract": "Unique Fixpoint Induction (UFI) is the chief inference rule to prove the equivalence of recursive processes in the Calculus of Communicating Systems (CCS) (Milner 1989). It plays a major role in the equational approach to verification. Equational verification is of special interest as it offers theoretical advantages in the analysis of systems that communicate values, have infinite state space or show parameterised behaviour. We call these kinds of systems VIPSs. VIPSs is the acronym of Value-passing, Infinite-State and Parameterised Systems. Automating the application of UFI in the context of VIPSs has been neglected. This is both because many VIPSs are given in terms of recursive function symbols, making it necessary to carefully apply induction rules other than UFI, and because proving that one VIPS process constitutes a fixpoint of another involves computing a process substitution, mapping states of one process to states of the other, that often is not obvious. Hence, VIPS verification is usually turned into equation solving (Lin 1995a). Existing tools for this proof task, such as VPAM (Lin 1993), are highly interactive. We introduce a method that automates the use of UFI. The method uses middle-out reasoning (Bundy et al. 1990a) and, so, is able to apply the rule even without elaborating the details of the application. The method introduces meta-variables to represent those bits of the processes' state space that, at application time, were not known, hence, changing from equation verification to equation solving. Adding this method to the equation plan developed by Monroy et al. (Autom Softw Eng 7(3):263-304, 2000a), we have implemented an automatic verification planner. This planner increases the number of verification problems that can be dealt with fully automatically, thus improving upon the current degree of automation in the field.", "paper_title": "On Process Equivalence = Equation Solving in CCS", "paper_id": "WOS:000266090200003"}