{"auto_keywords": [{"score": 0.03513507928523622, "phrase": "library_task"}, {"score": 0.006631781241759477, "phrase": "vertically_layered_software"}, {"score": 0.006092335211553929, "phrase": "special_actor"}, {"score": 0.005288484846914914, "phrase": "master-slave_connection"}, {"score": 0.00481495049065317, "phrase": "actor-based_parallel_programming_platform"}, {"score": 0.0047472380621488616, "phrase": "model-based_design"}, {"score": 0.004592905436175987, "phrase": "sw_design"}, {"score": 0.004464602028530629, "phrase": "potential_parallelism"}, {"score": 0.00438105507792004, "phrase": "architecture-neutral_form"}, {"score": 0.004159241394996858, "phrase": "data_channels"}, {"score": 0.0038930368103015467, "phrase": "flat_layer"}, {"score": 0.0037133478610481994, "phrase": "shared_library_functions"}, {"score": 0.0032838979278935814, "phrase": "new_types"}, {"score": 0.0030590445140753213, "phrase": "sharable_and_mappable_object"}, {"score": 0.00297346171320082, "phrase": "function_interfaces"}, {"score": 0.0027567336518542858, "phrase": "client-server_applications"}, {"score": 0.0025922974876210194, "phrase": "automatic_mapping_algorithm"}, {"score": 0.0025316905609748135, "phrase": "automatic_code_generator"}, {"score": 0.0024960069794216977, "phrase": "design_environment"}, {"score": 0.0023919484909181235, "phrase": "ibm"}, {"score": 0.0023694065215394593, "phrase": "broadband_engine"}, {"score": 0.0022706045233150795, "phrase": "preliminary_experiments"}, {"score": 0.002155412043665635, "phrase": "expression_power"}, {"score": 0.002125020720324262, "phrase": "previous_actor_model"}, {"score": 0.0021049977753042253, "phrase": "efficiently_generated_codes"}], "paper_keywords": ["Design methodology", " modeling", " parallel programming", " software development environment"], "paper_abstract": "Actor model-based design is actively researched for parallel embedded SW design since the model exposes the potential parallelism explicitly in an architecture-neutral form. In most actor-oriented models, actors are self-contained and data channels are the only sharable object between actors, and they compose a system in a flat layer. In contrast, it is common to use shared library functions and construct vertically layered software for efficiency and modularity. To fill this gap between modeling and implementation, we propose a special actor, library task, with new types of ports: library master port and library slave port. It is a sharable and mappable object that defines a set of function interfaces inside. N:1 master-slave connection allows sharing a library task and the master-slave connection can specify vertically layered software and client-server applications naturally. To support the library task in our embedded software design environment, we develop an automatic mapping algorithm as well as an automatic code generator. The design environment with the library task is applied for two target platforms: IBM CELL Broadband Engine and an ARM-based multicore simulator. Preliminary experiments show that the special actor, or library task, extends the expression power of the previous actor model with efficiently generated codes.", "paper_title": "Library Support in an Actor-Based Parallel Programming Platform", "paper_id": "WOS:000290414000018"}