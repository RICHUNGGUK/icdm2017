{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "worst_case"}, {"score": 0.03992659287798476, "phrase": "search_and_update_operations"}, {"score": 0.004752221133109136, "phrase": "constant_time_catenable"}, {"score": 0.00433531459712787, "phrase": "purely_functional_implementation"}, {"score": 0.004223032986655664, "phrase": "search_trees"}, {"score": 0.0030414140732789186, "phrase": "open_problem"}, {"score": 0.0029239116379409886, "phrase": "kaplan"}, {"score": 0.002848062435457452, "phrase": "tarjan"}, {"score": 0.002497319603143104, "phrase": "data_structure"}, {"score": 0.0023694065215394593, "phrase": "join_operation"}], "paper_keywords": ["data structures", " sorted lists", " purely functional programming"], "paper_abstract": "We present a purely functional implementation of search trees that requires O(log n) time for search and update operations and supports the join of two trees in worst case constant time. Hence, we solve an open problem posed by Kaplan and Tarjan as to whether it is possible to envisage a data structure supporting simultaneously the join operation in O(1) time and the search and update operations in O(log n) time.", "paper_title": "Purely functional worst case constant time catenable sorted lists", "paper_id": "WOS:000241478200016"}