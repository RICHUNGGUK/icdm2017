{"auto_keywords": [{"score": 0.039209128751934524, "phrase": "proposed_architecture"}, {"score": 0.011965321767357229, "phrase": "multiple_characters"}, {"score": 0.009596391761298765, "phrase": "transition_rules"}, {"score": 0.00481495049065317, "phrase": "architecture_based"}, {"score": 0.004775531918452571, "phrase": "aho-corasick_algorithm."}, {"score": 0.004564401713056939, "phrase": "string_matching"}, {"score": 0.004398589723893764, "phrase": "high_speed"}, {"score": 0.004344662696228875, "phrase": "intrusion_detection_systems"}, {"score": 0.004204054047427536, "phrase": "hardware_string"}, {"score": 0.004135458387200662, "phrase": "data_character"}, {"score": 0.004018087343963485, "phrase": "achievable_highest_clock_rate"}, {"score": 0.0037776319581225046, "phrase": "aho-corasick_algorithm"}, {"score": 0.003422371752150812, "phrase": "intuitive_algorithm"}, {"score": 0.0033664873319204027, "phrase": "multi-character_finite_state_machine"}, {"score": 0.003204232566468624, "phrase": "aho-corasick_prefix_tree"}, {"score": 0.0030372426452745073, "phrase": "multi-character_transition_string_matching"}, {"score": 0.0028553159147435424, "phrase": "derived_multi-character"}, {"score": 0.0028435818662656226, "phrase": "fsm."}, {"score": 0.002728847267539957, "phrase": "failure_links"}, {"score": 0.002607965563121546, "phrase": "failure_functions"}, {"score": 0.002565345470805401, "phrase": "initial_state"}, {"score": 0.002492425259337031, "phrase": "state_growth_rate"}, {"score": 0.0024116163689723333, "phrase": "derived_multi-character_transition_rules"}, {"score": 0.0022300169122921906, "phrase": "asic_device"}, {"score": 0.0021845387990972543, "phrase": "resulting_throughput"}], "paper_keywords": ["String matching", " Finite state machine", " Aho-Corasick algorithm"], "paper_abstract": "A hardware string matching architecture is usually used to accelerate string matching in various applications that need to filter content in high speed such as intrusion detection systems. However, the throughput of the hardware string matching architecture inspecting data character by character is limited by the achievable highest clock rate. In this paper, we present a string matching architecture based on the Aho-Corasick algorithm. The proposed architecture is able to inspect multiple characters simultaneously and the throughput of string matching can be multiplied. We first describe an intuitive algorithm to construct a multi-character finite state machine (FSM) that accepts multiple characters per transition based on an Aho-Corasick prefix tree (AC-trie). Then we propose an architecture for multi-character transition string matching consisting of multiple matching units for processing the transition rules that are generated from the derived multi-character FSM. The design of proposed architecture utilizes the properties of the failure links of an AC-trie to reduce the transition rules derived from the failure functions linked to the initial state. As a result, the state growth rate is moderate in the number of the derived multi-character transition rules as the number of the characters inspected at a time increases. The proposed architecture was implemented on an ASIC device for evaluation and the resulting throughput can achieve 4.5 Gbps for a 4-character string matching implementation operated at 142 MHz clock.", "paper_title": "A MULTI-CHARACTER TRANSITION STRING MATCHING ARCHITECTURE BASED ON AHO-CORASICK ALGORITHM", "paper_id": "WOS:000312435200024"}