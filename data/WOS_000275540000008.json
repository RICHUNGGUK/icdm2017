{"auto_keywords": [{"score": 0.05007851542092211, "phrase": "complete_memory_latency_hiding"}, {"score": 0.03400063745855725, "phrase": "irp"}, {"score": 0.030220837604689004, "phrase": "execution_time"}, {"score": 0.004736045157669388, "phrase": "widening_gap"}, {"score": 0.0046328364646343375, "phrase": "memory_performance"}, {"score": 0.004556901872357751, "phrase": "main_bottleneck"}, {"score": 0.004506968388996092, "phrase": "modern_computer_systems"}, {"score": 0.00443308765153716, "phrase": "high_processor_utilization"}, {"score": 0.00433645229352341, "phrase": "memory_latency"}, {"score": 0.004081385289516914, "phrase": "intermediate_fast_memories"}, {"score": 0.0039269071382230444, "phrase": "memory_management_techniques"}, {"score": 0.00373682045166829, "phrase": "new_loop_scheduling"}, {"score": 0.0036958398682001015, "phrase": "memory_management_technique"}, {"score": 0.0034212450542713607, "phrase": "memory_latencies"}, {"score": 0.0033465923623290034, "phrase": "multidimensional_loops"}, {"score": 0.00327356326590461, "phrase": "cell_processor"}, {"score": 0.0031669873302916, "phrase": "iteration_space"}, {"score": 0.003030247482854539, "phrase": "two-part_schedule"}, {"score": 0.0029641011108505785, "phrase": "processor_and_memory_parts"}, {"score": 0.00280496585980086, "phrase": "memory_part"}, {"score": 0.0026986685585382347, "phrase": "processor_part"}, {"score": 0.002337848196418384, "phrase": "right_partition_size"}, {"score": 0.002261666793030715, "phrase": "dsp_benchmarks"}, {"score": 0.0021879624017959493, "phrase": "optimal_solutions"}, {"score": 0.0021049977753042253, "phrase": "previous_techniques"}], "paper_keywords": ["Design", " Performance", " Languages", " Hardware/software", " codesign", " loop transformation", " memory latency hiding"], "paper_abstract": "The widening gap between processor and memory performance is the main bottleneck for modern computer systems to achieve high processor utilization. To hide memory latency, a variety of techniques have been proposed-from intermediate fast memories (caches) to various prefetching and memory management techniques. In this article, we propose a new loop scheduling with memory management technique, Iterational Retiming with Partitioning (IRP), that can completely hide memory latencies for applications with multidimensional loops on architectures like CELL processor. In IRP, the iteration space is first partitioned carefully. Then a two-part schedule, consisting of processor and memory parts, is produced such that the execution time of the memory part never exceeds the execution time of the processor part. These two parts are executed simultaneously and complete memory latency hiding is reached. In this article, we prove that such optimal two-part schedule can always be achieved given the right partition size and shape. Experiments on DSP benchmarks show that IRP consistently produces optimal solutions as well as significant improvement over previous techniques.", "paper_title": "Iterational Retiming with Partitioning: Loop Scheduling with Complete Memory Latency Hiding", "paper_id": "WOS:000275540000008"}