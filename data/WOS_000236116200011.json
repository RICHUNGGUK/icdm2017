{"auto_keywords": [{"score": 0.04363497344618853, "phrase": "distinguishing_sequence"}, {"score": 0.023035242671514567, "phrase": "checking_sequence"}, {"score": 0.007142339163149408, "phrase": "previous_work"}, {"score": 0.007003238089124174, "phrase": "upsilon"}, {"score": 0.00481495049065317, "phrase": "checking_sequences"}, {"score": 0.0047075518238435966, "phrase": "finite_state_machine"}, {"score": 0.004654749973584499, "phrase": "test_sequence"}, {"score": 0.004253018585673207, "phrase": "finite_state_machine_m"}, {"score": 0.00399704519135802, "phrase": "output_sequence"}, {"score": 0.0038313742407700144, "phrase": "different_states"}, {"score": 0.0038098079315016355, "phrase": "m._previous_work"}, {"score": 0.00368292623004839, "phrase": "efficient_checking_sequence"}, {"score": 0.0034513868338791193, "phrase": "set_upsilon"}, {"score": 0.0033934090791564856, "phrase": "individual_transitions"}, {"score": 0.0032803494445914944, "phrase": "final_state"}, {"score": 0.0031890066953304667, "phrase": "predefined_set"}, {"score": 0.0029799963905662447, "phrase": "single_sequence"}, {"score": 0.0029465141526991297, "phrase": "predefined_acyclic"}, {"score": 0.002888820296103727, "phrase": "optimization_algorithm"}, {"score": 0.002824262516441788, "phrase": "shortest_such_checking_sequence"}, {"score": 0.002522426900157144, "phrase": "appropriate_a"}, {"score": 0.0024590770730682377, "phrase": "checking_sequence_generation"}, {"score": 0.00224007572741723, "phrase": "optimization_step"}, {"score": 0.00221488852092224, "phrase": "checking_sequence_generation_algorithm"}, {"score": 0.0021531499016013704, "phrase": "optimal_e-c"}, {"score": 0.0021049977753042253, "phrase": "proposed_method"}], "paper_keywords": ["finite state machine", " checking sequence", " test minimization", " distinguishing sequence"], "paper_abstract": "A checking sequence, generated from a finite state machine, is a test sequence that is guaranteed to lead to a failure if the system under test is faulty and has no more states than the specification. The problem of generating a checking sequence for a finite state machine M is simplified if M has a distinguishing sequence: an input sequence (D) over bar D with the property that the output sequence produced by M in response to (D) over bar D is different for the different states of M. Previous work has shown that, where a distinguishing sequence is known, an efficient checking sequence can be produced from the elements of a set A of sequences that verify the distinguishing sequence used and the elements of a set Upsilon of subsequences that test the individual transitions by following each transition t by the distinguishing sequence that verifies the final state of t. In this previous work, A is a predefined set and Upsilon is defined in terms of A. The checking sequence is produced by connecting the elements of Upsilon and A to form a single sequence, using a predefined acyclic set E-c of transitions. An optimization algorithm is used in order to produce the shortest such checking sequence that can be generated on the basis of the given A and E-c. However, this previous work did not state how the sets A and E-c should be chosen. This paper investigates the problem of finding appropriate A and E-c to be used in checking sequence generation. We show how a set A may be chosen so that it minimizes the sum of the lengths of the sequences to be combined. Further, we show that the optimization step, in the checking sequence generation algorithm, may be adapted so that it generates the optimal E-c. Experiments are used to evaluate the proposed method.", "paper_title": "Optimizing the length of checking sequences", "paper_id": "WOS:000236116200011"}