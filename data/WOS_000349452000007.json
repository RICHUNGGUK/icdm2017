{"auto_keywords": [{"score": 0.047749554816546934, "phrase": "desktop_grids"}, {"score": 0.04063975765733019, "phrase": "independent_tasks"}, {"score": 0.040332633919831135, "phrase": "tightly_coupled_tasks"}, {"score": 0.03738133313641756, "phrase": "scheduling_problem"}, {"score": 0.00481495049065317, "phrase": "volatile_resource"}, {"score": 0.004678018655587085, "phrase": "iterative_applications"}, {"score": 0.0046535416582068785, "phrase": "volatile_processors"}, {"score": 0.004135296401536423, "phrase": "parallelization_spectrum"}, {"score": 0.00409211122248989, "phrase": "master-worker_scheduling_schemes"}, {"score": 0.0040387608245932086, "phrase": "good_trade-offs"}, {"score": 0.003986103192038901, "phrase": "worker_availability"}, {"score": 0.0038930368103015467, "phrase": "fixed_number"}, {"score": 0.0038121298895564173, "phrase": "key_feature"}, {"score": 0.003732898113268911, "phrase": "communication_model"}, {"score": 0.003703611021999795, "phrase": "bandwidth_capacity"}, {"score": 0.003645721851422349, "phrase": "application_data"}, {"score": 0.0034957206663520654, "phrase": "theoretical_sense"}, {"score": 0.003459191419478298, "phrase": "practical_sense"}, {"score": 0.0032223742018434856, "phrase": "preempted_state"}, {"score": 0.0031636612155559267, "phrase": "practical_settings"}, {"score": 0.0031141853323221414, "phrase": "master_bandwidth"}, {"score": 0.0030096178580223676, "phrase": "aforementioned_difficulties"}, {"score": 0.002962543869356265, "phrase": "master-worker_applications"}, {"score": 0.0028630535573013686, "phrase": "scheduling_problems"}, {"score": 0.0028034919876662595, "phrase": "processor_availability_behaviors"}, {"score": 0.0027033193708595345, "phrase": "np"}, {"score": 0.00251048377083841, "phrase": "close_formula"}, {"score": 0.0024777023459225307, "phrase": "analytical_approximation"}, {"score": 0.002419768110116695, "phrase": "markovian_assumption"}, {"score": 0.0024007585788965655, "phrase": "temporal_availability"}, {"score": 0.0023018623704073897, "phrase": "reliable'_processors"}, {"score": 0.0022837769780376846, "phrase": "sensible_manner"}, {"score": 0.0021441057555396013, "phrase": "best_strategy"}, {"score": 0.002116098276745512, "phrase": "processor_state_availability"}, {"score": 0.0021049977753042253, "phrase": "average_task_duration"}], "paper_keywords": ["Iterative applications", " scheduling", " complexity results", " heuristics", " volatile platforms"], "paper_abstract": "In this paper, we study the execution of iterative applications on volatile processors such as those found on desktop grids. We envision two models, one where all tasks are assumed to be independent, and another where all tasks are tightly coupled and keep exchanging information throughout the iteration. These two models cover the two extreme points of the parallelization spectrum. We develop master-worker scheduling schemes that attempt to achieve good trade-offs between worker speed and worker availability. Any iteration entails the execution of a fixed number of independent tasks or of tightly coupled tasks. A key feature of our approach is that we consider a communication model where the bandwidth capacity of the master for sending application data to workers is limited. This limitation makes the scheduling problem more difficult both in a theoretical sense and in a practical sense. Furthermore, we consider that a processor can be in one of three states: available, down, or temporarily preempted by its owner. This preempted state also complicates the scheduling problem. In practical settings, for example desktop grids, master bandwidth is limited and processors are temporarily reclaimed. Consequently, addressing the aforementioned difficulties is necessary for successfully deploying master-worker applications on volatile platforms. Our first contribution is to determine the complexity of the scheduling problems in their offline versions, that is, when processor availability behaviors are known in advance. Even with this knowledge, the problems are NP-hard. Our second contribution is an evaluation of the expectation of the time needed by a worker to complete a set of tasks. We obtain a close formula for independent tasks and an analytical approximation for tightly coupled tasks. Those evaluations rely on a Markovian assumption for the temporal availability of processors, and are at the heart of some heuristics that aim at favoring reliable' processors in a sensible manner. Our third contribution is a set of heuristics for both models, which we evaluate in simulation. Our results provide guidance in selecting the best strategy as a function of processor state availability vs average task duration.", "paper_title": "Mapping applications on volatile resource", "paper_id": "WOS:000349452000007"}