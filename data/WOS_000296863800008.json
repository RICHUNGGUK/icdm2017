{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "defect-tolerant_cache_memories"}, {"score": 0.043043153225929595, "phrase": "processor_architects"}, {"score": 0.004728780808284175, "phrase": "deep_submicron_technology_call"}, {"score": 0.004665162327051461, "phrase": "careful_review"}, {"score": 0.004623224002010226, "phrase": "existing_cache_designs"}, {"score": 0.004581660953729745, "phrase": "design_practices"}, {"score": 0.004281568920264999, "phrase": "design_and_evaluation_framework"}, {"score": 0.00389404213807752, "phrase": "unified_framework"}, {"score": 0.003191714656606822, "phrase": "design_space"}, {"score": 0.003134503353065008, "phrase": "early_stage"}, {"score": 0.0030644247579222333, "phrase": "complete_framework"}, {"score": 0.003023129616910419, "phrase": "proposed_defcam_design_flow"}, {"score": 0.002889444701599236, "phrase": "program_performance"}, {"score": 0.0028634235895823594, "phrase": "individual_processors"}, {"score": 0.0027867539356701302, "phrase": "defcam"}, {"score": 0.0027616550517346066, "phrase": "interesting_interactions"}, {"score": 0.0026157259734105, "phrase": "practical_set_remapping_schemes"}, {"score": 0.0025804616931593897, "phrase": "hard_faults"}, {"score": 0.0025572160146590623, "phrase": "cache_memory"}, {"score": 0.0025113494092413604, "phrase": "set_remapping_scheme"}, {"score": 0.0024220634963019114, "phrase": "unusable_faulty_set"}, {"score": 0.002367875199095903, "phrase": "sound_set"}, {"score": 0.0023465400668244386, "phrase": "case_studies"}, {"score": 0.002252880693912436, "phrase": "proposed_design_flow"}, {"score": 0.002232579371411546, "phrase": "developed_tools"}, {"score": 0.0022124605840026313, "phrase": "experimental_results"}, {"score": 0.0021727640931660038, "phrase": "set_remapping"}, {"score": 0.0021049977753042253, "phrase": "prevailing_strategies"}], "paper_keywords": ["Design", " Performance", " Reliability", " Process Variations", " Yield"], "paper_abstract": "Advances in deep submicron technology call for a careful review of existing cache designs and design practices in terms of yield, area, and performance. This article presents a Design and Evaluation Framework for defect-tolerant Cache Memories (DEFCAM), which enables processor architects to consider yield, area, and performance together in a unified framework. Since there is a complex, changing trade-off among these metrics depending on the technology, the cache organization, and the yield enhancement scheme employed, such a design flow is invaluable to processor architects when they assess a design and explore the design space quickly at an early stage. We develop a complete framework supporting the proposed DEFCAM design flow, from injecting defects into a wafer to evaluating program performance of individual processors on the wafer. Using DEFCAM, interesting interactions between architectural, organizational, and layout/defect related parameters can be easily evaluated. Moreover, we propose practical set remapping schemes to contain hard faults in cache memory. In a set remapping scheme, accesses that would go to an unusable faulty set are directed to a sound set. Case studies are presented to demonstrate the effectiveness of the proposed design flow and developed tools. Experimental results show that a set remapping is the most efficient fault covering method among prevailing strategies.", "paper_title": "DEFCAM: A Design and Evaluation Framework for Defect-Tolerant Cache Memories", "paper_id": "WOS:000296863800008"}