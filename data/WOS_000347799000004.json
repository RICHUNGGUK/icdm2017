{"auto_keywords": [{"score": 0.044308460471387805, "phrase": "mysql"}, {"score": 0.03545115781452284, "phrase": "lock_manager"}, {"score": 0.00481495049065317, "phrase": "modern_implementations"}, {"score": 0.004767826806287385, "phrase": "dbms_software"}, {"score": 0.004606479650820579, "phrase": "high_core_counts"}, {"score": 0.00447251540886613, "phrase": "high-end_servers"}, {"score": 0.004195418010131832, "phrase": "shore-mt"}, {"score": 0.0041136473765874815, "phrase": "commercial_system"}, {"score": 0.003531474887552889, "phrase": "read-only_workload"}, {"score": 0.0034118234596993836, "phrase": "latch_contention"}, {"score": 0.0031377955308198634, "phrase": "reduced_latching"}, {"score": 0.0027469703311742647, "phrase": "staged_allocation"}, {"score": 0.0024891269874339553, "phrase": "simple_list_manipulation_operations"}, {"score": 0.002323142666222693, "phrase": "lock_data_structures"}, {"score": 0.0021896891011033105, "phrase": "fast_implementations"}, {"score": 0.0021682027434117095, "phrase": "lock_acquisition"}, {"score": 0.0021049977753042253, "phrase": "concurrent_deadlock"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Transactions", " lock manager", " multicore", " scalability", " lock-free synchronization"], "paper_abstract": "Modern implementations of DBMS software are intended to take advantage of high core counts that are becoming common in high-end servers. However, we have observed that several database platforms, including MySQL, Shore-MT, and a commercial system, exhibit throughput collapse as load increases into oversaturation (where there are more request threads than cores), even for a workload with little or no logical contention for locks, such as a read-only workload. Our analysis of MySQL identifies latch contention within the lock manager as the bottleneck responsible for this collapse. We design a lock manager with reduced latching, implement it in MySQL, and show that it avoids the collapse and generally improves performance. Our efficient implementation of a lockmanager is enabled by a staged allocation and deallocation of locks. Locks are preallocated in bulk, so that the lock manager only has to perform simple list manipulation operations during the acquire and release phases of a transaction. Deallocation of the lock data structures is also performed in bulk, which enables the use of fast implementations of lock acquisition and release as well as concurrent deadlock checking.", "paper_title": "A Scalable Lock Manager for Multicores", "paper_id": "WOS:000347799000004"}