{"auto_keywords": [{"score": 0.048946208597162526, "phrase": "java"}, {"score": 0.04765083966579579, "phrase": "mutual-exclusion_locks"}, {"score": 0.00481495049065317, "phrase": "java_synchronization"}, {"score": 0.004776669953449352, "phrase": "concurrent_data_accesses"}, {"score": 0.0047386923107107645, "phrase": "high-level_languages"}, {"score": 0.004237512575106522, "phrase": "lock's_guarded_operations"}, {"score": 0.003927848423072668, "phrase": "atomicity_and_isolation_properties"}, {"score": 0.0038810583785936505, "phrase": "thread's_guarded_operations"}, {"score": 0.0038195342195623764, "phrase": "recent_proposals"}, {"score": 0.003669941438286456, "phrase": "concurrency_control_protocols"}, {"score": 0.0036262124965265015, "phrase": "well-known_problems"}, {"score": 0.003456427643307907, "phrase": "database_systems"}, {"score": 0.0034152340901585374, "phrase": "programming_language_context"}, {"score": 0.003294566092612857, "phrase": "software_transactions"}, {"score": 0.003268333444704392, "phrase": "significant_implementation_overhead"}, {"score": 0.002898930717812433, "phrase": "java's_monitor_abstraction"}, {"score": 0.0026547761341670505, "phrase": "concurrent_attempts"}, {"score": 0.0024703502756471514, "phrase": "java's_execution_semantics"}, {"score": 0.0024311346712789553, "phrase": "detailed_performance_evaluation"}, {"score": 0.0024117603727471654, "phrase": "different_workloads"}, {"score": 0.0023925401023682717, "phrase": "varying_levels"}, {"score": 0.0023079225317714815, "phrase": "low_overheads"}, {"score": 0.0022803854904010347, "phrase": "uncontended_case"}, {"score": 0.0022085455097790537, "phrase": "significant_performance_improvements"}, {"score": 0.0021049977753042253, "phrase": "contended_monitors"}], "paper_keywords": [""], "paper_abstract": "Concurrent data accesses in high-level languages like Java and C# are typically mediated using mutual-exclusion locks. Threads use locks to guard the operations performed while the lock is held, so that the lock's guarded operations can never be interleaved with operations of other threads that are guarded by the same lock. This way both atomicity and isolation properties of a thread's guarded operations are enforced. Recent proposals recognize that these properties can also be enforced by concurrency control protocols that avoid well-known problems associated with locking, by transplanting notions of transactions found in database systems to a programming language context. While higher-level than locks, software transactions incur significant implementation overhead. This overhead cannot be easily masked when there is little contention on the operations being guarded. We show how mutual-exclusion locks and transactions can be reconciled transparently within Java's monitor abstraction. We have implemented monitors for Java that execute using locks when contention is low and switch over to transactions when concurrent attempts to enter the monitor are detected. We formally argue the correctness of our solution with respect to Java's execution semantics and provide a detailed performance evaluation for different workloads and varying levels of contention. We demonstrate that our implementation has low overheads in the uncontended case (7% on average) and that significant performance improvements (up to 3 x) can be achieved from running contended monitors transactionally.", "paper_title": "Transparently reconciling transactions with locking for Java synchronization", "paper_id": "WOS:000239558900007"}