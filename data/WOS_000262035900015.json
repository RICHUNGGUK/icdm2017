{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "object_protocols"}, {"score": 0.04220106202005744, "phrase": "api_clients"}, {"score": 0.015486197052498344, "phrase": "runtime_analysis"}, {"score": 0.013291129575395858, "phrase": "api_designers"}, {"score": 0.011472359439069825, "phrase": "protocol_invariant"}, {"score": 0.004771573528404328, "phrase": "static"}, {"score": 0.004201774694043468, "phrase": "jdom"}, {"score": 0.003990935112773993, "phrase": "api_objects"}, {"score": 0.0038252396052150354, "phrase": "discussion_forums"}, {"score": 0.0036553070575015344, "phrase": "appropriate_object_protocols"}, {"score": 0.0035569798792881935, "phrase": "object_protocol"}, {"score": 0.0034823290869920804, "phrase": "fundamental_properties"}, {"score": 0.0033989238477802864, "phrase": "protocol_invariants"}, {"score": 0.003327579120205541, "phrase": "prolang"}, {"score": 0.0027407299369891502, "phrase": "static_analysis"}, {"score": 0.002603012037901889, "phrase": "higher_level"}, {"score": 0.002548331088496964, "phrase": "program's_source_code"}, {"score": 0.0024721971183379867, "phrase": "protocol_correctness"}, {"score": 0.0024129269611844794, "phrase": "theoretical_guarantees"}, {"score": 0.0023694065215394593, "phrase": "static_and_runtime_analysis"}, {"score": 0.0023479408542211875, "phrase": "empirical_evidence"}, {"score": 0.0023125950237602518, "phrase": "usage_errors"}, {"score": 0.002298605785178457, "phrase": "widely_used_apis"}, {"score": 0.0022571426190350157, "phrase": "statically_checking_protocol_correctness"}, {"score": 0.002209711182025705, "phrase": "program_conformance"}, {"score": 0.002137196729601873, "phrase": "api"}, {"score": 0.0021049977753042253, "phrase": "api_designer"}], "paper_keywords": ["Design", " Languages", " Reliability", " Verification", " Invariants", " Aspect Oriented Programming", " Program Verification"], "paper_abstract": "In this paper, we consider object protocols that constrain interactions between objects in a program. Several such protocols have been proposed in the literature [3, 9, 6, 5]. For many APIs (such as JDOM [23], JDBC [22]), API designers constrain how API clients interact with API objects. In practice, API clients violate such constraints, as evidenced by postings in discussion forums for these APIs. Thus, it is important that API designers specify constraints using appropriate object protocols and enforce them. The goal of an object protocol is expressed as a protocol invariant. Fundamental properties such as ownership can be expressed as protocol invariants. We present a language, PROLANG, to specify object protocols along with their protocol invariants, and a tool, INVCOP++, to check if a program satisfies a protocol invariant. INVCOP++ separates the problem of checking if a protocol satisfies its protocol invariant (called protocol correctness), from the problem of checking if a program conforms to a protocol (called program conformance). The former is solved using static analysis, and the latter using runtime analysis. Due to this separation (1) errors made in protocol design are detected at a higher level of abstraction, independent of the program's source code, and (2) performance of conformance checking is improved as protocol correctness has been verified statically. We present theoretical guarantees about the way we combine static and runtime analysis, and empirical evidence that our tool INVCOP++ finds usage errors in widely used APIs. We also show that statically checking protocol correctness greatly optimizes the overhead of checking program conformance, thus enabling API clients to test whether their programs use the API as intended by the API designer.", "paper_title": "Enforcing Object Protocols by Combining Static and Runtime Analysis", "paper_id": "WOS:000262035900015"}