{"auto_keywords": [{"score": 0.048951593908953754, "phrase": "ccp"}, {"score": 0.00481495049065317, "phrase": "program_equivalence"}, {"score": 0.004776853267973129, "phrase": "confluent_concurrent_constraint_programming"}, {"score": 0.004739056045644449, "phrase": "concurrent_constraint_programming"}, {"score": 0.004627441072541506, "phrase": "well-established_declarative_framework"}, {"score": 0.00405873677211836, "phrase": "automatic_verification_procedures"}, {"score": 0.0036893794227117194, "phrase": "ccp_program"}, {"score": 0.0034895911869254146, "phrase": "verification_algorithm"}, {"score": 0.0034482025128821548, "phrase": "exponential-time_complexity"}, {"score": 0.0033668870709083884, "phrase": "representative_sub-language"}, {"score": 0.0028715299874549245, "phrase": "better_time_complexity"}, {"score": 0.0027594936602962075, "phrase": "full_language"}, {"score": 0.002705121052747945, "phrase": "significant_state_space_reductions"}, {"score": 0.0024488738006005133, "phrase": "strong_ties"}, {"score": 0.002429451930463481, "phrase": "first-order_logic"}, {"score": 0.0024006068621542642, "phrase": "elegant_denotational_semantics"}, {"score": 0.002316105585203396, "phrase": "real-world_situations"}, {"score": 0.0021218313648947926, "phrase": "congruence_issues"}, {"score": 0.0021049977753042253, "phrase": "ccp's_program_equivalence"}], "paper_keywords": ["Concurrent constraint programming", " Bisimulation", " Partition refinement", " Observational equivalence"], "paper_abstract": "Concurrent Constraint Programming (CCP) is a well-established declarative framework from concurrency theory. Its foundations and principles e.g., semantics, proof systems, axiomatizations, have been thoroughly studied for over the last two decades. In contrast, the development of algorithms and automatic verification procedures for CCP have hitherto been far too little considered. To the best of our knowledge there is only one existing verification algorithm for the standard notion of CCP program (observational) equivalence. In this paper we first show that this verification algorithm has an exponential-time complexity even for programs from a representative sub-language of CCP; the summation-free fragment (CCP\\+). We then significantly improve on the complexity of this algorithm by providing two alternative polynomial-time decision procedures for CCP\\+ program equivalence. Each of these two procedures has an advantage over the other. One has a better time complexity. The other can be easily adapted for the full language of CCP to produce significant state space reductions. The relevance of both procedures derives from the importance of CCP\\+. This fragment, which has been the subject of many theoretical studies, has strong ties to first-order logic and an elegant denotational semantics, and it can be used to model real-world situations. Its most distinctive feature is that of confluence, a property we exploit to obtain our polynomial procedures. Finally, we also study the congruence issues regarding CCP's program equivalence. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Efficient algorithms for program equivalence for confluent concurrent constraint programming", "paper_id": "WOS:000368557000007"}