{"auto_keywords": [{"score": 0.04776153899320318, "phrase": "executable_test_code"}, {"score": 0.00481495049065317, "phrase": "class_state_models."}, {"score": 0.0046328364646343375, "phrase": "automated_generation"}, {"score": 0.0045318666714939905, "phrase": "class_models"}, {"score": 0.00443308765153716, "phrase": "uml_protocol_state_machines"}, {"score": 0.00428892403807229, "phrase": "state_models"}, {"score": 0.004218602458288531, "phrase": "state_coverage"}, {"score": 0.004172360444377281, "phrase": "transition_coverage"}, {"score": 0.004103942174451674, "phrase": "basic_and_extended_round-trip_coverage"}, {"score": 0.0038838500580958744, "phrase": "detailed_test_parameters"}, {"score": 0.003716273882758735, "phrase": "method_invocations"}, {"score": 0.003675517796014622, "phrase": "implementation-specific_environments"}, {"score": 0.003536346954940087, "phrase": "state_model"}, {"score": 0.003440166097491567, "phrase": "requirements_change"}, {"score": 0.0033837135367113004, "phrase": "hand-crafted_test_parameters"}, {"score": 0.0031495640320537252, "phrase": "working_load"}, {"score": 0.0030470127429039497, "phrase": "modified_models"}, {"score": 0.002851790448644913, "phrase": "state_wrapper_aspects"}, {"score": 0.0028204903432531136, "phrase": "aspectj"}, {"score": 0.0026838147966444783, "phrase": "expected_states"}, {"score": 0.0026543514413663893, "phrase": "test_execution"}, {"score": 0.0025820967615278073, "phrase": "automated_verdict"}, {"score": 0.0025257081555100556, "phrase": "test_cases"}, {"score": 0.0024299678474208023, "phrase": "source_code"}, {"score": 0.0021520139248317333, "phrase": "test_parameters"}, {"score": 0.0021049977753042253, "phrase": "object_interactions"}], "paper_keywords": ["Software testing", " UML", " protocol state machines", " test generation", " object-oriented programming"], "paper_abstract": "This paper presents an approach to automated generation of executable test code from class models represented by the UML protocol state machines. It supports several coverage criteria for state models, including state coverage, transition coverage, and basic and extended round-trip coverage. It allows the tester to add and modify detailed test parameters (e. g., actual arguments for method invocations and implementation-specific environments) if necessary. When the state model is modified due to requirements change, the hand-crafted test parameters, if still valid, are automatically reused. This reduces the working load for regeneration of tests for modified models. In addition to test code, we also automatically generate state wrapper aspects in AspectJ, which facilitates comparing actual object states to expected states during test execution. This enables the automated verdict of pass/failure for test cases without the need to modify the source code of the class under test. We present two examples for which the executable test code is generated. They demonstrate the reuse of test parameters and testing of object interactions, respectively.", "paper_title": "AUTOMATED TEST CODE GENERATION FROM CLASS STATE MODELS", "paper_id": "WOS:000269249400007"}