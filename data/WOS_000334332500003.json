{"auto_keywords": [{"score": 0.04861462157289284, "phrase": "lu_factorization"}, {"score": 0.015623434267671212, "phrase": "high_performance"}, {"score": 0.010149319631475749, "phrase": "trailing_submatrix"}, {"score": 0.00481495049065317, "phrase": "numerical_accuracy"}, {"score": 0.0047555023078686386, "phrase": "recursive_tile_lu_factorization"}, {"score": 0.004624401316503576, "phrase": "important_numerical_algorithm"}, {"score": 0.004553128404612054, "phrase": "linear_equations"}, {"score": 0.0042921238100956174, "phrase": "de_facto_numerical_algorithm"}, {"score": 0.004239103253656808, "phrase": "linpack_benchmark"}, {"score": 0.004058615475230867, "phrase": "multicore_processors"}, {"score": 0.003946650265907885, "phrase": "fast_and_robust_numerical_software"}, {"score": 0.0038978806337961565, "phrase": "increasing_levels"}, {"score": 0.0038737214010638745, "phrase": "hardware_parallelism"}, {"score": 0.003849711329589429, "phrase": "widening_gap"}, {"score": 0.0038258495055898713, "phrase": "core_and_memory_speeds"}, {"score": 0.0037087324991876727, "phrase": "new_algorithms"}, {"score": 0.0036742989715836745, "phrase": "scientific_community"}, {"score": 0.0034959622587016222, "phrase": "numerical_algorithm"}, {"score": 0.003431332820984854, "phrase": "new_approach"}, {"score": 0.003347008750837722, "phrase": "multicore_architectures"}, {"score": 0.0032749212355657215, "phrase": "overall_performance"}, {"score": 0.0032243796145539102, "phrase": "numerical_quality"}, {"score": 0.0031944286166257466, "phrase": "standard_lu_factorization_algorithm"}, {"score": 0.0030110748510795175, "phrase": "inherently_problematic_portion"}, {"score": 0.0029553828839333366, "phrase": "panel_factorization"}, {"score": 0.0028470613150369823, "phrase": "appropriate_pivots"}, {"score": 0.002803104254950008, "phrase": "parallel_fine-grained_recursive_formulation"}, {"score": 0.002675252546913683, "phrase": "tile_algorithm"}, {"score": 0.0026421521830403377, "phrase": "conflict-free_partitioning"}, {"score": 0.0026013505538490223, "phrase": "lockless_synchronization_mechanisms"}, {"score": 0.0025611773887867255, "phrase": "overall_computation_flow"}, {"score": 0.0025137856138000014, "phrase": "dynamic_runtime_system"}, {"score": 0.0024996666279962724, "phrase": "quark"}, {"score": 0.002436735294813786, "phrase": "heterogeneous_granularities"}, {"score": 0.0023990982005125763, "phrase": "algorithmic_lookahead"}, {"score": 0.0023767948946074547, "phrase": "performance_results"}, {"score": 0.0023183255207530193, "phrase": "currently_available_software_packages"}, {"score": 0.0021987994275190314, "phrase": "equivalent_intel_mkl_routine"}, {"score": 0.0021513909418006856, "phrase": "lapack"}, {"score": 0.0021380309053013647, "phrase": "multithreaded_intel_mkl_blas._copyright"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["recursion", " LU factorization", " parallel linear algebra", " shared memory synchronization", " threaded parallelism"], "paper_abstract": "The LU factorization is an important numerical algorithm for solving systems of linear equations in science and engineering and is a characteristic of many dense linear algebra computations. For example, it has become the de facto numerical algorithm implemented within the LINPACK benchmark to rank the most powerful supercomputers in the world, collected by the TOP500 website. Multicore processors continue to present challenges to the development of fast and robust numerical software due to the increasing levels of hardware parallelism and widening gap between core and memory speeds. In this context, the difficulty in developing new algorithms for the scientific community resides in the combination of two goals: achieving high performance while maintaining the accuracy of the numerical algorithm. This paper proposes a new approach for computing the LU factorization in parallel on multicore architectures, which not only improves the overall performance but also sustains the numerical quality of the standard LU factorization algorithm with partial pivoting. While the update of the trailing submatrix is computationally intensive and highly parallel, the inherently problematic portion of the LU factorization is the panel factorization due to its memory-bound characteristic as well as the atomicity of selecting the appropriate pivots. Our approach uses a parallel fine-grained recursive formulation of the panel factorization step and implements the update of the trailing submatrix with the tile algorithm. Based on conflict-free partitioning of the data and lockless synchronization mechanisms, our implementation lets the overall computation flow naturally without contention. The dynamic runtime system called QUARK is then able to schedule tasks with heterogeneous granularities and to transparently introduce algorithmic lookahead. The performance results of our implementation are competitive compared to the currently available software packages and libraries. For example, it is up to 40% faster when compared to the equivalent Intel MKL routine and up to threefold faster than LAPACK with multithreaded Intel MKL BLAS. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Achieving numerical accuracy and high performance using recursive tile LU factorization with partial pivoting", "paper_id": "WOS:000334332500003"}