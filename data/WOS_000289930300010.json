{"auto_keywords": [{"score": 0.049631680892871025, "phrase": "universal_neighborhood_automata"}, {"score": 0.015719716506582538, "phrase": "word_neighborhood"}, {"score": 0.004529881123652277, "phrase": "fundamental_operation"}, {"score": 0.004143196873246147, "phrase": "earlier_work"}, {"score": 0.003990385737207714, "phrase": "universal_levenshtein_automaton"}, {"score": 0.003861288537079326, "phrase": "deterministic_automaton"}, {"score": 0.003598492288058048, "phrase": "sequence_chi"}, {"score": 0.00351491577968631, "phrase": "levenshtein_distance"}, {"score": 0.0031845067058084583, "phrase": "arbitrary_input_words"}, {"score": 0.003066945490483524, "phrase": "underlying_input_alphabet"}, {"score": 0.0028986672783671147, "phrase": "large_abstract_family"}, {"score": 0.0028715299874549245, "phrase": "generalized_word_distances"}, {"score": 0.0026633568650501873, "phrase": "universal_levenshtein_automata"}, {"score": 0.002552946390854313, "phrase": "synchronized_finite-state_transducers"}, {"score": 0.0024818877663889813, "phrase": "small_neighborhood_bounds"}, {"score": 0.0024014759148123736, "phrase": "main_memory"}, {"score": 0.002291089893848235, "phrase": "evaluation_results"}, {"score": 0.0021652891317252994, "phrase": "dynamic_programming"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Dynamic programming", " Finite state automata", " Levenshtein distance"], "paper_abstract": "Given some form of distance between words, a fundamental operation is to decide whether the distance between two given words to and v is within a given bound. In earlier work, we introduced the concept of a universal Levenshtein automaton for a given distance bound n. This deterministic automaton takes as input a sequence chi of bitvectors computed from w and v. The sequence chi is accepted iff the Levenshtein distance between to and v does not exceed n. The automaton is called universal since the same automaton can be used for arbitrary input words in and v, regardless of the underlying input alphabet. Here, we extend this picture. After introducing a large abstract family of generalized word distances, we exactly characterize those members where word neighborhood can be decided using universal neighborhood automata similar to universal Levenshtein automata. Our theoretical results establish several bridges to the theory of synchronized finite-state transducers and dynamic programming. For small neighborhood bounds, universal neighborhood automata can be held in main memory. This leads to very efficient algorithms for the above decision problem. Evaluation results show that these algorithms are much faster than those based on dynamic programming. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Deciding word neighborhood with universal neighborhood automata", "paper_id": "WOS:000289930300010"}