{"auto_keywords": [{"score": 0.03130213614376333, "phrase": "fmls"}, {"score": 0.008747558502898644, "phrase": "fixed-point_scaling"}, {"score": 0.008246171487747962, "phrase": "irp-sa"}, {"score": 0.006574705009990408, "phrase": "irp-sa_scaling_algorithm"}, {"score": 0.00481495049065317, "phrase": "instruction-set_methods"}, {"score": 0.0047363569540686936, "phrase": "fixed-point_conversion_accuracy"}, {"score": 0.00458297991625839, "phrase": "instruction-set_techniques"}, {"score": 0.0044933373574179624, "phrase": "signal-processing_algorithms"}, {"score": 0.0044491728131708505, "phrase": "fixed-point_embedded_processors"}, {"score": 0.00422082596936636, "phrase": "fixed-point_compiler-based_conversion_process"}, {"score": 0.004179328666330398, "phrase": "novel_fixed-point_scaling_algorithm"}, {"score": 0.0041518899630102616, "phrase": "irp"}, {"score": 0.003675437054650504, "phrase": "modulo_nature"}, {"score": 0.0036392821787269727, "phrase": "'_s_complement_addition"}, {"score": 0.003521305923598047, "phrase": "redundant_sign-extension_bits"}, {"score": 0.0034866619130264048, "phrase": "complementary_scaling_technique"}, {"score": 0.003158367829177805, "phrase": "novel_instruction-set_enhancement_-_fractional_multiplication"}, {"score": 0.003015893651662638, "phrase": "interoperand_correlations"}, {"score": 0.002927705457700311, "phrase": "different_subset"}, {"score": 0.00289888453546698, "phrase": "full_product's_bits"}, {"score": 0.002879827926178628, "phrase": "traditional_fractional_fixed-point"}, {"score": 0.0027228088474257426, "phrase": "uniform_bitwidth_register_architectures"}, {"score": 0.002660662813907647, "phrase": "additional_precision"}, {"score": 0.0026171408377811687, "phrase": "signal-processing_benchmarks"}, {"score": 0.002339442939538852, "phrase": "scaling_shift"}, {"score": 0.002308768837799101, "phrase": "execution_time"}, {"score": 0.0022338432561549897, "phrase": "ids"}, {"score": 0.0022045353683203626, "phrase": "singlenested_loops"}, {"score": 0.002140021296668778, "phrase": "lattice_filter_benchmark"}], "paper_keywords": ["design", " economics", " performance", " compilation", " fixed-point", " signal-to-noise ratio", " fractional multiplication", " scaling", " digital signal processing"], "paper_abstract": "This paper proposes and evaluates compile time and instruction-set techniques for improving the accuracy of signal-processing algorithms run on fixed-point embedded processors. These techniques are proposed in the context of a profile guided floating-to fixed-point compiler-based conversion process. A novel fixed-point scaling algorithm (IRP) is introduced that exploits correlations between values in a program by applying fixed-point scaling, retaining as much precision as possible without causing overflow. This approach is extended into a more aggressive scaling algorithm ( IRP-SA) by leveraging the modulo nature of 2' s complement addition and subtraction to discard most significant bits that may not be redundant sign-extension bits. A complementary scaling technique (IDS) is then proposed that enables the fixed-point scaling of a variable to be parameterized, depending upon the context of its definitions and uses. Finally, a novel instruction-set enhancement - fractional multiplication with internal left shift (FMLS) - is proposed to further leverage interoperand correlations uncovered by the IRP-SA scaling algorithm. FMLS preserves a different subset of the full product's bits than traditional fractional fixed-point or integer multiplication. On average, FMLS combined with IRP-SA improves accuracy on processors with uniform bitwidth register architectures by the equivalent of 0.61 bits of additional precision for a set of signal-processing benchmarks ( up to 2 bits). Even without employing FMLS, the IRP-SA scaling algorithm achieves additional accuracy over two previous fixed-point scaling algorithms by averages of 1.71 and 0.49 bits. Furthermore, as FMLS combines multiplication with a scaling shift, it reduces execution time by an average of 9.8%. An implementation of IDS, specialized to singlenested loops, is found to improve accuracy of a lattice filter benchmark by the equivalent of more than 16- bits of precision.", "paper_title": "Compile-time and instruction-set methods for improving floating- to fixed-point conversion accuracy", "paper_id": "WOS:000256880900004"}