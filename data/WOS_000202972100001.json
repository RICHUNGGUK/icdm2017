{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "atomos"}, {"score": 0.006874127436743808, "phrase": "java"}, {"score": 0.004714869813251479, "phrase": "first_programming_language"}, {"score": 0.004649302313891199, "phrase": "implicit_transactions"}, {"score": 0.0045846424310611745, "phrase": "strong_atomicity"}, {"score": 0.004457995891964028, "phrase": "scalable_multiprocessor_implementation"}, {"score": 0.003985305257857655, "phrase": "simpler_transactional_alternatives"}, {"score": 0.0039024014688338964, "phrase": "atomos_watch_statement"}, {"score": 0.003768028741967194, "phrase": "fine-grained_watch_sets"}, {"score": 0.0036128527616772848, "phrase": "conditional_waiting_statement"}, {"score": 0.0035625556447293804, "phrase": "efficient_transactional_conflict-driven_wakeup"}, {"score": 0.0033682492486884364, "phrase": "limited_number"}, {"score": 0.0033213460816510685, "phrase": "transactional_contexts"}, {"score": 0.0032294837250130327, "phrase": "open-nested_transactions"}, {"score": 0.0030532878377173885, "phrase": "scalable_application_programs"}, {"score": 0.003010757286626405, "phrase": "virtual_machine_implementations"}, {"score": 0.0028866770996648057, "phrase": "atomos_scheduler"}, {"score": 0.002787181295054319, "phrase": "open_nesting"}, {"score": 0.002729133029776093, "phrase": "virtual_machine"}, {"score": 0.0026166287606163145, "phrase": "transactional_memory_violation_handlers"}, {"score": 0.0024912073108138613, "phrase": "data_dependency_violations"}, {"score": 0.002405309378904663, "phrase": "atomos_programming_examples"}, {"score": 0.0022739766507258105, "phrase": "transactional_programming_primitives"}], "paper_keywords": ["performance", " design", " languages", " transactional memory", " conditional synchronization", " Java", " multiprocessor architecture"], "paper_abstract": "Atomos is the first programming language with implicit transactions, strong atomicity, and a scalable multiprocessor implementation. Atomos is derived from Java, but replaces its synchronization and conditional waiting constructs with simpler transactional alternatives. The Atomos watch statement allows programmers to specify fine-grained watch sets used with the Atomos retry conditional waiting statement for efficient transactional conflict-driven wakeup even in transactional memory systems with a limited number of transactional contexts. Atomos supports open-nested transactions, which are necessary for building both scalable application programs and virtual machine implementations. The implementation of the Atomos scheduler demonstrates the use of open nesting within the virtual machine and introduces the concept of transactional memory violation handlers that allow programs to recover from data dependency violations without rolling back. Atomos programming examples are given to demonstrate the usefulness of transactional programming primitives. Atomos and Java are compared through the use of several benchmarks. The results demonstrate both the improvements in parallel programming ease and parallel program performance provided by Atomos.", "paper_title": "The ATOMO Sigma transactional programming language", "paper_id": "WOS:000202972100001"}