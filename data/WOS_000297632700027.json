{"auto_keywords": [{"score": 0.03853250580865732, "phrase": "frenetic"}, {"score": 0.00481495049065317, "phrase": "modern_networks"}, {"score": 0.004724571550328985, "phrase": "interrelated_services"}, {"score": 0.004653485665080485, "phrase": "traffic_monitoring"}, {"score": 0.004618342952383313, "phrase": "load_balancing"}, {"score": 0.004396267325338022, "phrase": "today's_networks"}, {"score": 0.004363058588000252, "phrase": "modern_features"}, {"score": 0.004232702713825967, "phrase": "low_level"}, {"score": 0.0041374874583908535, "phrase": "underlying_hardware"}, {"score": 0.0040444053843446326, "phrase": "even_rudimentary_support"}, {"score": 0.004013843843250455, "phrase": "modular_programming"}, {"score": 0.003923532450854754, "phrase": "network_programs"}, {"score": 0.003501452436803395, "phrase": "network_switches"}, {"score": 0.003435643372146385, "phrase": "declarative_query_language"}, {"score": 0.003371066990851953, "phrase": "network_traffic"}, {"score": 0.00330770035909988, "phrase": "functional_reactive_combinator_library"}, {"score": 0.0032702516771609957, "phrase": "high-level_packet-forwarding_policies"}, {"score": 0.0030196821790309165, "phrase": "modular_reasoning"}, {"score": 0.002985484575498061, "phrase": "code_reuse"}, {"score": 0.002951673109860487, "phrase": "important_property"}, {"score": 0.002907184330345933, "phrase": "frenetic's_novel_run-time_system"}, {"score": 0.002746225320405654, "phrase": "low-level_packet-processing_rules"}, {"score": 0.0024785689583828796, "phrase": "programming_networks"}, {"score": 0.0024411935317269705, "phrase": "key_limitations"}, {"score": 0.002368120987066921, "phrase": "language_design"}], "paper_keywords": ["Languages", " Design", " Network programming languages", " domain-specific languages", " functional reactive programming", " OpenFlow"], "paper_abstract": "Modern networks provide a variety of interrelated services including routing, traffic monitoring, load balancing, and access control. Unfortunately, the languages used to program today's networks lack modern features-they are usually defined at the low level of abstraction supplied by the underlying hardware and they fail to provide even rudimentary support for modular programming. As a result, network programs tend to be complicated, error-prone, and difficult to maintain. This paper presents Frenetic, a high-level language for programming distributed collections of network switches. Frenetic provides a declarative query language for classifying and aggregating network traffic as well as a functional reactive combinator library for describing high-level packet-forwarding policies. Unlike prior work in this domain, these constructs are-by design-fully compositional, which facilitates modular reasoning and enables code reuse. This important property is enabled by Frenetic's novel run-time system which manages all of the details related to installing, uninstalling, and querying low-level packet-processing rules on physical switches. Overall, this paper makes three main contributions: (1) We analyze the state-of-the art in languages for programming networks and identify the key limitations; (2) We present a language design that addresses these limitations, using a series of examples to motivate and validate our choices; (3) We describe an implementation of the language and evaluate its performance on several benchmarks.", "paper_title": "Frenetic: A Network Programming Language", "paper_id": "WOS:000297632700027"}