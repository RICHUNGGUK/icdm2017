{"auto_keywords": [{"score": 0.04383441248529016, "phrase": "sequential_code"}, {"score": 0.03500078727690864, "phrase": "ppmodel"}, {"score": 0.00481495049065317, "phrase": "source_code_maintenance"}, {"score": 0.004736820055728928, "phrase": "parallel_programs"}, {"score": 0.004659951478263083, "phrase": "computation_power"}, {"score": 0.004621984064678252, "phrase": "desktops_advances"}, {"score": 0.0045843245695654875, "phrase": "parallel_programming"}, {"score": 0.0044549056501745074, "phrase": "essential_skills"}, {"score": 0.0044005599565517875, "phrase": "next_generation_software_engineers"}, {"score": 0.004276306563103443, "phrase": "popular_parallel_programming_paradigms"}, {"score": 0.004224130367280183, "phrase": "substantial_amount"}, {"score": 0.004121672175779706, "phrase": "parallel_code"}, {"score": 0.0040713749949601915, "phrase": "supporting_different_platforms"}, {"score": 0.003972607172518598, "phrase": "optimum_version"}, {"score": 0.003876226041373242, "phrase": "available_resources"}, {"score": 0.0038446194432899183, "phrase": "problem_size"}, {"score": 0.0037360045780015804, "phrase": "benchmark_programs"}, {"score": 0.0035423376631308567, "phrase": "code_comprehensibility"}, {"score": 0.0030441844088874366, "phrase": "parallel_blocks"}, {"score": 0.0028510114763213596, "phrase": "entire_program"}, {"score": 0.0027931892160452513, "phrase": "graphical_modeling_tool"}, {"score": 0.0027253441561528495, "phrase": "eclipse_users"}, {"score": 0.0026920404458807444, "phrase": "domain-specific_language"}, {"score": 0.002637433799290365, "phrase": "non-eclipse_users"}, {"score": 0.002449839292715327, "phrase": "case_study"}, {"score": 0.00241989408309933, "phrase": "benchmark_program"}, {"score": 0.0023418133729330303, "phrase": "parallel_block"}, {"score": 0.002322732717128146, "phrase": "cuda"}, {"score": 0.0022477377970612847, "phrase": "modified_program"}, {"score": 0.0021662983565317283, "phrase": "sequential_counterpart"}, {"score": 0.0021049977753042253, "phrase": "existing_openmp_version"}], "paper_keywords": ["CUDA", " OpenMP", " PPModel", " tPPModel", " DSL"], "paper_abstract": "As the computation power in desktops advances, parallel programming has emerged as one of the essential skills needed by next generation software engineers. However, programs written in popular parallel programming paradigms have a substantial amount of sequential code mixed with the parallel code. Several such versions supporting different platforms are necessary to find the optimum version of the program for the available resources and problem size. As revealed by our study on benchmark programs, sequential code is often duplicated in these versions. This can affect code comprehensibility and re-usability of the software. In this paper, we discuss a framework named PPModel, which is designed and implemented to free programmers from these scenarios. Using PPModel, a programmer can separate parallel blocks in a program, map these blocks to various platforms, and re-execute the entire program. We provide a graphical modeling tool (PPModel) intended for Eclipse users and a Domain-Specific Language (tPPModel) for non-Eclipse users to facilitate the separation, the mapping, and the re-execution. This is illustrated with a case study from a benchmark program, which involves re-targeting a parallel block to CUDA and another parallel block to OpenMP. The modified program gave almost 5x performance gain compared to the sequential counterpart, and 1.5x gain compared to the existing OpenMP version.", "paper_title": "PPModel: a modeling tool for source code maintenance and optimization of parallel programs", "paper_id": "WOS:000310428700023"}