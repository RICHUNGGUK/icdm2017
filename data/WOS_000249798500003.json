{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "lookahead_delegators"}, {"score": 0.03684088411047262, "phrase": "lookahead_delegation"}, {"score": 0.02668867276892981, "phrase": "unambiguous_nfa"}, {"score": 0.004776674210320321, "phrase": "nfa."}, {"score": 0.004589763483242731, "phrase": "membership_problem"}, {"score": 0.004463296691378145, "phrase": "nfa"}, {"score": 0.004340263267055143, "phrase": "nfa's_resources"}, {"score": 0.004187049198138107, "phrase": "standard_nfa_simulation"}, {"score": 0.0038655854071187115, "phrase": "deterministic_finite_automata"}, {"score": 0.003714195746979591, "phrase": "\"right\"_nfa_transitions"}, {"score": 0.0036553070575015344, "phrase": "fixed_number"}, {"score": 0.0036262124965265015, "phrase": "input_symbols"}, {"score": 0.0034289106230496816, "phrase": "formal_study"}, {"score": 0.0034016119212097826, "phrase": "web_services_composition"}, {"score": 0.0026760974046034854, "phrase": "machine_property"}, {"score": 0.002623111480310373, "phrase": "language_property"}, {"score": 0.0024311346712789553, "phrase": "open_problem"}, {"score": 0.002121913011761504, "phrase": "compact_characterization"}, {"score": 0.0021049977753042253, "phrase": "nfa_delegation"}], "paper_keywords": ["deterministic NFA simulation", " lookahead delegator", " unambiguous NFA"], "paper_abstract": "We investigate deterministically simulating (i.e., solving the membership problem for) nondeterministic finite automata (NFA), relying solely on the NFA's resources (states and transitions). Unlike the standard NFA simulation, involving an algorithm which stores at each step all the states reached nondeterministically while reading the input, we consider deterministic finite automata (DFA) with lookahead, which choose the \"right\" NFA transitions based on a fixed number of input symbols read ahead. This concept, known as lookahead delegation, arose in a formal study of web services composition and its subsequent practical applications. Here we answer several related questions, such as \"when is lookahead delegation possible?\" and \"how hard is it to find a delegator with a given lookahead buffer size?\". In particular, we show that only finite languages have the property that all their NFA have delegators. This implies, among others, that delegation is a machine property, rather than a language property. We also prove that the existence of lookahead delegators for unambiguous NFA is decidable, thus partially solving an open problem. Finally, we show that finding delegators (even for a given buffer size) is hard in general, and is more efficient for unambiguous NFA, and we give an algorithm and a compact characterization for NFA delegation in general.", "paper_title": "On the existence of lookahead delegators for NFA", "paper_id": "WOS:000249798500003"}