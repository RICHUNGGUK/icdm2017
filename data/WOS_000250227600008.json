{"auto_keywords": [{"score": 0.04645838146569139, "phrase": "design_step"}, {"score": 0.03267271007380886, "phrase": "verification_problem"}, {"score": 0.025736047854426028, "phrase": "tracematch"}, {"score": 0.00481495049065317, "phrase": "multiprocessor_embedded_systems"}, {"score": 0.0046834372388970405, "phrase": "multiprocessor_embedded_platforms"}, {"score": 0.004270347498153512, "phrase": "multithreaded_partitioned_application"}, {"score": 0.0041154571996523505, "phrase": "processing_element"}, {"score": 0.003966162568548304, "phrase": "multiprocessor_platform"}, {"score": 0.003911578552479064, "phrase": "partitioned_application"}, {"score": 0.003752275718257509, "phrase": "native_unpartitioned_application"}, {"score": 0.0037006243674469657, "phrase": "verification_task"}, {"score": 0.0034528025626422154, "phrase": "code-block-level_containment-checking-based_methodology"}, {"score": 0.003312121699003206, "phrase": "uml-based_code-block-level_modeling_language"}, {"score": 0.0030476702431093687, "phrase": "special_case"}, {"score": 0.0030056887638095883, "phrase": "containment_checking_problem"}, {"score": 0.0026163210719740847, "phrase": "containment_checking"}, {"score": 0.0025565050791036973, "phrase": "efficient_containment_checking_algorithm"}, {"score": 0.0024409345168575833, "phrase": "containment_checking_tool"}, {"score": 0.002396179086883187, "phrase": "present_experimental_results"}, {"score": 0.0023091093387071593, "phrase": "state_space_reduction"}, {"score": 0.002225196379204285, "phrase": "formal_analysis"}, {"score": 0.002183407970607638, "phrase": "spin"}, {"score": 0.002154310588948615, "phrase": "pep"}, {"score": 0.0021344268827973275, "phrase": "prod"}, {"score": 0.0021049980887993046, "phrase": "lola."}], "paper_keywords": ["verification", " algorithms", " containment checking", " state space reduction", " multiprocessor embedded systems", " UML activity diagrams"], "paper_abstract": "With the advent of multiprocessor embedded platforms, application partitioning and mapping have gained primacy as a design step. The output of this design step is a multithreaded partitioned application where each thread is mapped to a processing element (processor or ASIC) in the multiprocessor platform. This partitioned application must be verified to be consistent with the native unpartitioned application. This verification task is called application (or task) partitioning verification. This work proposes a code-block-level containment-checking-based methodology for application partitioning verification. We use a UML-based code-block-level modeling language which is rich enough to model most designs. We formulate the application partitioning verification problem as a special case of the containment checking problem, which we call the complete containment checking problem. We propose a state space reduction technique specific to the containment checking, reachability analysis, and deadlock detection problems. We propose novel data structures and token propagation methodologies which enhance the efficiency of containment checking. We present an efficient containment checking algorithm for the application partitioning verification problem. We develop a containment checking tool called TraceMatch and present experimental results. We present a comparison of the state space reduction achieved by TraceMatch with that achieved by formal analysis and verification tools like Spin, PEP, PROD, and LoLA.", "paper_title": "Functional verification of task partitioning for multiprocessor embedded systems", "paper_id": "WOS:000250227600008"}