{"auto_keywords": [{"score": 0.04741892958012685, "phrase": "correctness_query"}, {"score": 0.030201072870748535, "phrase": "verification_process"}, {"score": 0.00481495049065317, "phrase": "formal_verification"}, {"score": 0.004703075081891693, "phrase": "temporal-logic_model-checking_tools"}, {"score": 0.004593787100061613, "phrase": "negative_answer"}, {"score": 0.004002596930301241, "phrase": "growing_awareness"}, {"score": 0.003767599364361092, "phrase": "case_model"}, {"score": 0.003704797078215222, "phrase": "main_justification"}, {"score": 0.0036553070575015344, "phrase": "possible_errors"}, {"score": 0.0034755154823256588, "phrase": "sanity_checks"}, {"score": 0.003131393466870228, "phrase": "unintended_trivial_way"}, {"score": 0.002664375650349975, "phrase": "vacuous_satisfaction"}, {"score": 0.002646501671714952, "phrase": "low_coverage"}, {"score": 0.0025675372701474035, "phrase": "user_helpful_information"}, {"score": 0.0025332005503938947, "phrase": "existing_work"}, {"score": 0.0023053339328456234, "phrase": "mutant_input"}], "paper_keywords": [""], "paper_abstract": "One of the advantages of temporal-logic model-checking tools is their ability to accompany a negative answer to the correctness query by a counterexample to the satisfaction of the specification in the system. On the other hand, when the answer to the correctness query is positive, most model-checking tools provide no additional information. In the last few years there has been growing awareness to the importance of suspecting the system or the specification of containing an error also in the case model checking succeeds. The main justification of such suspects are possible errors in the modeling of the system or of the specification. The goal of sanity checks is to detect such errors by further automatic reasoning. Two leading sanity checks are vacuity and coverage. In vacuity, the goal is to detect cases where the system satisfies the specification in some unintended trivial way. In coverage, the goal is to increase the exhaustiveness of the specification by detecting components of the system that do not play a role in verification process. For both checks, the challenge is to define vacuity and coverage formally, develop algorithms for detecting vacuous satisfaction and low coverage, and suggest methods for returning to the user helpful information. We survey existing work on vacuity and coverage and argue that, in many aspects, the two checks are essentially the same: both are based on repeating the verification process on some mutant input. In vacuity, mutations are in the specifications, whereas in coverage, mutations are in the system. This observation enables us to adopt work done in the context of vacuity to coverage, and vise versa.", "paper_title": "Sanity checks in formal verification", "paper_id": "WOS:000240256100003"}