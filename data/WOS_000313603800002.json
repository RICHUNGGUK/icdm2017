{"auto_keywords": [{"score": 0.04967710401179305, "phrase": "code_motion"}, {"score": 0.04927872927155838, "phrase": "data_dependence_graphs"}, {"score": 0.04888338488077779, "phrase": "register_allocation"}, {"score": 0.04226255901245674, "phrase": "interference_graphs"}, {"score": 0.031633843797337025, "phrase": "parallel_copy_motion"}, {"score": 0.00481495049065317, "phrase": "parallel_copies"}, {"score": 0.004500891637057374, "phrase": "decoupled_strategies"}, {"score": 0.004388450908826472, "phrase": "separate_phases"}, {"score": 0.004189523950071494, "phrase": "traditional_approaches"}, {"score": 0.003584025547693836, "phrase": "decoupled_approaches"}, {"score": 0.0034359094594153304, "phrase": "local_recoloring"}, {"score": 0.0033926758710459866, "phrase": "common_assumption"}, {"score": 0.0032524418285459324, "phrase": "original_ordering"}, {"score": 0.003014422649429416, "phrase": "local_recoloring_technique"}, {"score": 0.002853396755102163, "phrase": "useless_copies"}, {"score": 0.002735392281320413, "phrase": "valid_register_assignment"}, {"score": 0.002633355582628613, "phrase": "traditional_register_allocation"}, {"score": 0.002471661547432869, "phrase": "remaining_copies"}, {"score": 0.0024302416436559867, "phrase": "weighted_costs"}, {"score": 0.0024097920845706795, "phrase": "register_copies"}, {"score": 0.0021590588269751816, "phrase": "copy_costs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Parallel Copy Motion", " Data dependence graph", " Register allocation", " Register coalescing", " Copy elimination"], "paper_abstract": "Register allocation regained much interest in recent years due to the development of decoupled strategies that split the problem into separate phases: spilling, register assignment, and copy elimination. Traditional approaches to copy elimination during register allocation are based on interference graphs and register coalescing. Variables are represented as nodes in a graph, which are coalesced, if they can be assigned the same register. However, decoupled approaches strive to avoid interference graphs and thus often resort to local recoloring. A common assumption of existing coalescing and recoloring approaches is that the original ordering of the instructions in the program is not changed. This work presents an extension of a local recoloring technique called Parallel Copy Motion. We perform code motion on data dependence graphs in order to eliminate useless copies and reorder instructions, while at the same time a valid register assignment is preserved. Our results show that even after traditional register allocation with coalescing our technique is able to eliminate an additional 3% (up to 9%) of the remaining copies and reduce the weighted costs of register copies by up to 25% for the SPECINT 2000 benchmarks. In comparison to Parallel Copy Motion, our technique removes 11% (up to 20%) more copies and up to 39% more of the copy costs. (c) 2012 Elsevier Ltd. All rights reserved.", "paper_title": "Elimination of parallel copies using code motion on data dependence graphs", "paper_id": "WOS:000313603800002"}