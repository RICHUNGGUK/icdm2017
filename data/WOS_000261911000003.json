{"auto_keywords": [{"score": 0.026878733181628856, "phrase": "implanted_bicluster"}, {"score": 0.00481495049065317, "phrase": "finding_additive_biclusters"}, {"score": 0.004783607451937166, "phrase": "random_background"}, {"score": 0.004736973212570135, "phrase": "biclustering_problem"}, {"score": 0.004569819304126685, "phrase": "data_mining"}, {"score": 0.004540064673326908, "phrase": "machine_learning"}, {"score": 0.004510502900568775, "phrase": "pattern_recognition"}, {"score": 0.004365543827399888, "phrase": "n_x_m_matrix"}, {"score": 0.004239051185676412, "phrase": "main_goal"}, {"score": 0.003893763958273845, "phrase": "objective_function"}, {"score": 0.0038056875126935607, "phrase": "found_bicluster"}, {"score": 0.0034970001101467395, "phrase": "np"}, {"score": 0.003350096243772218, "phrase": "probabilistic_model"}, {"score": 0.0033173903774253856, "phrase": "implanted_additive_bicluster_problem"}, {"score": 0.0032423089921154503, "phrase": "n_x_m_background_matrix"}, {"score": 0.0030270771166811296, "phrase": "x_k_implanted_additive_bicluster"}, {"score": 0.0029779674919563734, "phrase": "error-free_additive_bicluster"}, {"score": 0.0028353540399641336, "phrase": "probability_theta"}, {"score": 0.002771152088379478, "phrase": "time_algorithm"}, {"score": 0.002570237158808816, "phrase": "voting_algorithm"}, {"score": 0.0023995115472744376, "phrase": "vote."}, {"score": 0.0022401007567642347, "phrase": "small_biclusters"}, {"score": 0.0022037303797015073, "phrase": "overlapping_implanted_biclusters"}, {"score": 0.002167949230651206, "phrase": "simulated_and_real_datasets"}, {"score": 0.0021049977753042253, "phrase": "high_accuracy"}], "paper_keywords": ["additive bicluster", " computational biology", " gene expression data analysis", " polynomial-time algorithm", " probability model"], "paper_abstract": "The biclustering problem has been extensively studied in many areas, including e-commerce, data mining, machine learning, pattern recognition, statistics, and, more recently, computational biology. Given an n x m matrix A ( n >= m), the main goal of biclustering is to identify a subset of rows ( called objects) and a subset of columns ( called properties) such that some objective function that specifies the quality of the found bicluster ( formed by the subsets of rows and of columns of A) is optimized. The problem has been proved or conjectured to be NP-hard for various objective functions. In this article, we study a probabilistic model for the implanted additive bicluster problem, where each element in the n x m background matrix is a random integer from [0; L - 1] for some integer L, and a k x k implanted additive bicluster is obtained from an error-free additive bicluster by randomly changing each element to a number in [0; L - 1] with probability theta. We propose an O(n(2)m) time algorithm based on voting to solve the problem. We show that when k >= Omega (root n logn), the voting algorithm can correctly find the implanted bicluster with probability at least 1 - 9/n(2). We also implement our algorithm as a C++ program named VOTE. The implementation incorporates several ideas for estimating the size of an implanted bicluster, adjusting the threshold in voting, dealing with small biclusters, and dealing with overlapping implanted biclusters. Our experimental results on both simulated and real datasets show that VOTE can find biclusters with a high accuracy and speed.", "paper_title": "An Efficient Voting Algorithm for Finding Additive Biclusters with Random Background", "paper_id": "WOS:000261911000003"}