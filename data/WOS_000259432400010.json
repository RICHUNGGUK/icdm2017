{"auto_keywords": [{"score": 0.03794275963095038, "phrase": "mtss"}, {"score": 0.012421383837255094, "phrase": "embedded_systems"}, {"score": 0.006351981876508242, "phrase": "out-of-memory_error"}, {"score": 0.004655924035639928, "phrase": "serious_source"}, {"score": 0.004502126088469323, "phrase": "main_memory"}, {"score": 0.004442032546224076, "phrase": "frequent_difficulty"}, {"score": 0.004382737590042589, "phrase": "memory_requirement"}, {"score": 0.0042521895049768875, "phrase": "input_data"}, {"score": 0.004111672925576111, "phrase": "typical_lack"}, {"score": 0.004056769841308405, "phrase": "virtual_memory"}, {"score": 0.00398916666053909, "phrase": "serious_consequence"}, {"score": 0.003767599364361092, "phrase": "available_memory"}, {"score": 0.0033268412940032103, "phrase": "stack_memory_space"}, {"score": 0.0029473940028924748, "phrase": "stack_space"}, {"score": 0.002907992115184249, "phrase": "overflowing_task"}, {"score": 0.002878785759716458, "phrase": "free_space"}, {"score": 0.0028023242231187363, "phrase": "conventional_systems"}, {"score": 0.002700485592691974, "phrase": "remedial_action"}, {"score": 0.00267335773670308, "phrase": "graceful_exit"}, {"score": 0.002646501671714952, "phrase": "recovered_space"}, {"score": 0.002524688179363081, "phrase": "required_physical_memory"}, {"score": 0.0024993218789131437, "phrase": "embedded_system"}, {"score": 0.002465895175961543, "phrase": "initial_memory"}, {"score": 0.0022668507535947976, "phrase": "runtime_and_energy_overheads"}, {"score": 0.0021335427588412056, "phrase": "virtually_all_systems"}], "paper_keywords": ["out-of-memory errors", " runtime checks", " reuse", " data compression", " stack overflow", " heap overflow", " reliability", " cactus stack", " meshed stack", " virtual memory"], "paper_abstract": "Out-of-memory errors are a serious source of unreliability in most embedded systems. Applications run out of main memory because of the frequent difficulty of estimating the memory requirement before deployment, either because it depends on input data, or because certain language features prevent estimation. The typical lack of disks and virtual memory in embedded systems has a serious consequence when an out-of-memory error occurs. Without swap space, the system crashes if its memory footprint exceeds the available memory by even 1 byte. This work improves reliability for multitasking embedded systems by proposing MTSS, a multitask stack sharing technique. If a task attempts to overflow the bounds of its allocated stack space, MTSS grows its stack into the stack memory space allocated for other tasks. This technique can avoid the out-of-memory error if the extra space recovered is sufficient to complete execution. Experiments show that MTSS is able to recover an average of 54% of the stack space allocated to the overflowing task in the free space of other tasks. In addition, unlike conventional systems, MTSS detects memory overflows, allowing the possibility of remedial action or a graceful exit if the recovered space is not enough. Alternatively, MTSS can be used for decreasing the required physical memory of an embedded system by reducing the initial memory allocated to each of the tasks and recovering the deficit by sharing stack with other tasks. The overheads of MTSS are low: the runtime and energy overheads are 3.1% and 3.2%, on average. These are tolerable given that reliability is the most important concern in virtually all systems, ahead of other concerns, such as runtime and energy.", "paper_title": "MTSS: Multitask stack sharing for embedded systems", "paper_id": "WOS:000259432400010"}