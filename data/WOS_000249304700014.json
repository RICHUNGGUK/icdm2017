{"auto_keywords": [{"score": 0.0500773937478301, "phrase": "type_system"}, {"score": 0.04953663923501101, "phrase": "haskell"}, {"score": 0.045149025721814125, "phrase": "principal_type"}, {"score": 0.0444143536254134, "phrase": "overloaded_symbol"}, {"score": 0.025549259389709027, "phrase": "multi-parameter_type_classes"}, {"score": 0.0046797114400479135, "phrase": "related_systems"}, {"score": 0.004548253531664032, "phrase": "open_world_approach"}, {"score": 0.0043953478557600565, "phrase": "open_world"}, {"score": 0.003966667994579941, "phrase": "type_class_declarations"}, {"score": 0.0035390378585554547, "phrase": "closed_world"}, {"score": 0.0031573626285069157, "phrase": "relevant_context"}, {"score": 0.002753138528582461, "phrase": "open_and_closed_worlds"}, {"score": 0.0024700776739384977, "phrase": "defined_system"}, {"score": 0.002442025065383455, "phrase": "haskell_type_classes"}, {"score": 0.0022672718785099666, "phrase": "functional_dependencies"}, {"score": 0.0021049977753042253, "phrase": "alternative_route"}], "paper_keywords": ["type system", " type inference", " constrained polymorphism", " closed and open world approaches for overloading"], "paper_abstract": "The type system of Haskell and some related systems are based on an open world approach for overloading. In an open world, the principal type of each overloaded symbol must be explicitly annotated ( in Haskell, annotations occur in type class declarations) and a definition of an overloaded symbol is required to exist only when overloading is resolved. In a closed world, on the other hand, each principal type is determined according to the types of definitions that exist in the relevant context and, furthermore, overloading resolution for an expression considers only the context of the definition of its constituent symbols. In this paper we formally characterize open and closed worlds, and discuss their relative advantages. We present a type system that supports both approaches together, and compare the defined system with Haskell type classes extended with multi-parameter type classes and functional dependencies. We show in particular that functional dependencies are not necessary in order to support multi-parameter type classes, and present an alternative route.", "paper_title": "Open and closed worlds for overloading: a definition and support for coexistence", "paper_id": "WOS:000249304700014"}