{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "energy_efficiency"}, {"score": 0.02048507440199724, "phrase": "custom_instructions"}, {"score": 0.010546805826185057, "phrase": "embedded_processors"}, {"score": 0.009669699054975086, "phrase": "custom_functional_units"}, {"score": 0.007542377700734867, "phrase": "proposed_rfu"}, {"score": 0.004755279364266046, "phrase": "post-fabrication_instruction"}, {"score": 0.004681724410889531, "phrase": "critical_computation_subgraphs"}, {"score": 0.0046526204980467676, "phrase": "application-specific_instruction_set_extensions"}, {"score": 0.004344123393283444, "phrase": "base_processor"}, {"score": 0.004197599791067716, "phrase": "automated_tools"}, {"score": 0.00410693065248228, "phrase": "long_design_time"}, {"score": 0.004043363653396813, "phrase": "new_extensible_processor"}, {"score": 0.003894772585498127, "phrase": "significant_non-recurring_engineering_and_design_costs"}, {"score": 0.0037516215763875225, "phrase": "adaptive_extensible_processor"}, {"score": 0.0034808560862878567, "phrase": "reconfigurable_functional_unit"}, {"score": 0.0033424156234057494, "phrase": "functional_units"}, {"score": 0.003239669066247637, "phrase": "conditional_execution"}, {"score": 0.0031400710087822487, "phrase": "basic_blocks"}, {"score": 0.0031010917912277845, "phrase": "multiple-exits_custom_instruction"}, {"score": 0.0030245745670310835, "phrase": "conditional_execution_capability"}, {"score": 0.002968424524565369, "phrase": "rfu"}, {"score": 0.002931569771634119, "phrase": "multi-exit_feature"}, {"score": 0.0028325548627901004, "phrase": "hardware_resources"}, {"score": 0.0027368750412376215, "phrase": "integrated_mapping-temporal_partitioning_framework"}, {"score": 0.0026776730572928777, "phrase": "generated_custom_instructions"}, {"score": 0.0025710943379540175, "phrase": "experimental_results"}, {"score": 0.0025471063852938783, "phrase": "multi-exit_custom_instructions"}, {"score": 0.0023704645774716743, "phrase": "maximum_speedup"}, {"score": 0.0023191700719613685, "phrase": "single-issue_embedded_processor"}, {"score": 0.0022903576812801432, "phrase": "average_speedup"}, {"score": 0.002247807356218318, "phrase": "mibench_benchmark_suite"}, {"score": 0.0022268288922192704, "phrase": "maximum_and_average_energy_saving"}], "paper_keywords": ["Reconfigurable processor", " Custom instruction", " High-performance low-power embedded processors", " Reconfigurable functional unit", " Conditional execution"], "paper_abstract": "Encapsulating critical computation subgraphs as application-specific instruction set extensions is an effective technique to enhance the performance and energy efficiency of embedded processors. However, the addition of custom functional units to the base processor is required to support the execution of custom instructions. Although automated tools have been developed to reduce the long design time needed to produce a new extensible processor for each application, short time-to-market, significant non-recurring engineering and design costs are issues. To address these concerns, we introduce an adaptive extensible processor in which custom instructions are generated and added after chip-fabrication. To support this feature, custom functional units (CFUs) are replaced by a reconfigurable functional unit (RFU). The proposed RFU is based on a matrix of functional units which is multi-cycle with the capability of conditional execution. To generate more effective custom instructions, they are extended over basic blocks and hence, multiple-exits custom instruction and intuition behind it are introduced. Conditional execution capability has been added to the RFU to support the multi-exit feature of custom instructions. Because the proposed RFU has limitations on hardware resources (i.e., connections and processing elements), an integrated mapping-temporal partitioning framework is proposed to guarantee that the generated custom instructions can be mapped on the RFU (mappable custom instructions). Experimental results show that multi-exit custom instructions enhance the performance and energy efficiency by an average of 32% and 3% compared to custom instructions limited to one basic block, respectively. A maximum speedup of 4.9, compared to a single-issue embedded processor, and an average speedup of 1.9 was achieved on MiBench benchmark suite. The maximum and average energy saving are 56% and 22%, respectively. These performance and energy efficiency are obtained at the cost of 30% area overhead.", "paper_title": "Improving performance and energy efficiency of embedded processors via post-fabrication instruction set customization", "paper_id": "WOS:000303460700003"}