{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "data_stream_management_systems"}, {"score": 0.012663654006488813, "phrase": "query_inputs"}, {"score": 0.0047701277915006, "phrase": "relational_database_management_systems"}, {"score": 0.004711009518112459, "phrase": "basic_query_constructs"}, {"score": 0.004609301940749165, "phrase": "\"higher-level\"_views"}, {"score": 0.004509780213218666, "phrase": "traditional_query_optimization"}, {"score": 0.004384960761826366, "phrase": "existing_materialized_views"}, {"score": 0.004055998173160551, "phrase": "data_stream_management_system"}, {"score": 0.0036591119109692545, "phrase": "synchronized_sql"}, {"score": 0.0036024511695930753, "phrase": "query_language"}, {"score": 0.003557752688779838, "phrase": "data_stream"}, {"score": 0.0034162643819889054, "phrase": "query_composition"}, {"score": 0.00338441786634626, "phrase": "unified_interpretation"}, {"score": 0.00331125524068286, "phrase": "important_issue"}, {"score": 0.0032906426750021153, "phrase": "continuous_queries"}, {"score": 0.0032701580015554025, "phrase": "data_streams"}, {"score": 0.003091422591911213, "phrase": "coarser_periodic_refresh_requirements"}, {"score": 0.0030435255729392204, "phrase": "sliding_windows"}, {"score": 0.0029777101656842803, "phrase": "sliding_window_approach"}, {"score": 0.0029224275921964724, "phrase": "synchronization_principle"}, {"score": 0.002868168412858044, "phrase": "formal_mechanism"}, {"score": 0.0028237205895435733, "phrase": "arbitrary_refresh_conditions"}, {"score": 0.0027198282355114646, "phrase": "algebraic_foundation"}, {"score": 0.002702887319160534, "phrase": "syncsql"}, {"score": 0.002669320541871186, "phrase": "query-matching_algorithm"}, {"score": 0.0026279461299595756, "phrase": "syncsql_expressions"}, {"score": 0.0025630734211267102, "phrase": "nile-syncsql_prototype"}, {"score": 0.00253916011199984, "phrase": "syncsql_queries"}, {"score": 0.002499798127196099, "phrase": "pipelined_incremental_evaluation_paradigm"}, {"score": 0.002468747242613056, "phrase": "query_pipeline"}, {"score": 0.002422890839801611, "phrase": "differential_operators"}, {"score": 0.0024002822777025906, "phrase": "cost_model"}, {"score": 0.0023410164207985297, "phrase": "syncsql_query_execution_pipelines"}, {"score": 0.0023047189563870593, "phrase": "best_execution_plan"}, {"score": 0.002268983004273332, "phrase": "different_plans"}, {"score": 0.0022268288922192704, "phrase": "experimental_study"}, {"score": 0.002171836484200008, "phrase": "nile-syncsql."}, {"score": 0.002158301441463052, "phrase": "experimental_results"}, {"score": 0.0021248309394183945, "phrase": "nile-syncsql"}, {"score": 0.0021049977753042253, "phrase": "significant_performance_gains"}], "paper_keywords": ["Language", " Experimentation", " Performance", " Data streams", " query language", " expression matching", " incremental evaluation", " views"], "paper_abstract": "In relational database management systems, views supplement basic query constructs to cope with the demand for \"higher-level\" views of data. Moreover, in traditional query optimization, answering a query using a set of existing materialized views can yield a more efficient query execution plan. Due to their effectiveness, views are attractive to data stream management systems. In order to support views over streams, a data stream management system should employ a closed (or composable) continuous query language. A closed query language is a language in which query inputs and outputs are interpreted in the same way, hence allowing query composition. This article introduces the Synchronized SQL (or SyncSQL) query language that defines a data stream as a sequence of modify operations against a relation. SyncSQL enables query composition through the unified interpretation of query inputs and outputs. An important issue in continuous queries over data streams is the frequency by which the answer gets refreshed and the conditions that trigger the refresh. Coarser periodic refresh requirements are typically expressed as sliding windows. In this article, the sliding window approach is generalized by introducing the synchronization principle that empowers SyncSQL with a formal mechanism to express queries with arbitrary refresh conditions. After introducing the semantics and syntax, we lay the algebraic foundation for SyncSQL and propose a query-matching algorithm for deciding containment of SyncSQL expressions. Then, the article introduces the Nile-SyncSQL prototype to support SyncSQL queries. Nile-SyncSQL employs a pipelined incremental evaluation paradigm in which the query pipeline consists of a set of differential operators. A cost model is developed to estimate the cost of SyncSQL query execution pipelines and to choose the best execution plan from a set of different plans for the same query. An experimental study is conducted to evaluate the performance of Nile-SyncSQL. The experimental results illustrate the effectiveness of Nile-SyncSQL and the significant performance gains when views are enabled in data stream management systems.", "paper_title": "Supporting Views in Data Stream Management Systems", "paper_id": "WOS:000274511000001"}