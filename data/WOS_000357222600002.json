{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "largest_common_subtree"}, {"score": 0.004745056850725867, "phrase": "bounded_degree"}, {"score": 0.004642105253191792, "phrase": "largest_common_subtree_problem"}, {"score": 0.004475436844227947, "phrase": "bijective_mapping"}, {"score": 0.003981106369547929, "phrase": "ancestry_relationship"}, {"score": 0.003756261010750332, "phrase": "np"}, {"score": 0.003646399625591736, "phrase": "unordered_trees"}, {"score": 0.0034139056533151, "phrase": "restricted_unordered_case"}, {"score": 0.003315374849824563, "phrase": "maximum_outdegree"}, {"score": 0.0032433414042726356, "phrase": "common_subtree"}, {"score": 0.0031267359296488118, "phrase": "constant_d."}, {"score": 0.00284275228258112, "phrase": "maximum_size"}, {"score": 0.0022321322970228308, "phrase": "maximum_height"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Tree edit distance", " Unordered trees", " Dynamic programming", " Parameterized complexity"], "paper_abstract": "The largest common subtree problem is to find a bijective mapping between subsets of nodes of two input rooted trees of maximum cardinality or weight that preserves labels and ancestry relationship. The problem is known to be NP-hard for unordered trees. In this paper, we consider a restricted unordered case in which the maximum outdegree of a common subtree is bounded by a constant D. We present an O(n(D)) time algorithm where n is the maximum size of two input trees, which improves a previous O(n(2D)) time algorithm. We also present an O((H-2 center dot 2(2H-1)center dot D-2H)(D-1) poly(n)) time algorithm, where H is the maximum height of two input trees. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "On the complexity of finding a largest common subtree of bounded degree", "paper_id": "WOS:000357222600002"}