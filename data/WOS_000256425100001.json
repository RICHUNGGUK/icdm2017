{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "floating-point_computations"}, {"score": 0.0046993598473345395, "phrase": "current_critical_systems"}, {"score": 0.00386876598761639, "phrase": "floating-point_operators"}, {"score": 0.0033029038236817372, "phrase": "common_implementations"}, {"score": 0.0027854565462509095, "phrase": "source-code_level"}, {"score": 0.002406799309495983, "phrase": "concrete_examples"}, {"score": 0.0021049977753042253, "phrase": "analysis_software"}], "paper_keywords": ["languages", " verification", " abstract interpretation", " static analysis", " program testing", " verification", " floating point", " embedded software", " safety-critical software", " x87", " IA32", " AMD64", " PowerPC", " FPU", " rounding", " IEEE-754"], "paper_abstract": "Current critical systems often use a lot of floating-point computations, and thus the testing or static analysis of programs containing floating-point operators has become a priority. However, correctly defining the semantics of common implementations of floating-point is tricky, because semantics may change according to many factors beyond source-code level, such as choices made by compilers. We here give concrete examples of problems that can appear and solutions for implementing in analysis software.", "paper_title": "The pitfalls of verifying floating-point computations", "paper_id": "WOS:000256425100001"}