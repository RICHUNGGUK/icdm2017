{"auto_keywords": [{"score": 0.031623865134248225, "phrase": "isabelle"}, {"score": 0.00481495049065317, "phrase": "compiler_transformation_safe"}, {"score": 0.004518442937844318, "phrase": "call_arity_analysis"}, {"score": 0.004151188559520802, "phrase": "haskell_compiler"}, {"score": 0.0030521898646210413, "phrase": "interactive_theorem"}, {"score": 0.002863921785266393, "phrase": "machine-checked_proof"}, {"score": 0.0026307897899760383, "phrase": "compiler_optimization_safety_theorems"}, {"score": 0.00241658945942583, "phrase": "trace_trees"}, {"score": 0.0023408288327263316, "phrase": "suitable_abstraction"}, {"score": 0.00229164285862567, "phrase": "abstract_cardinality_analyses"}, {"score": 0.0021049977753042253, "phrase": "formalization_gap"}], "paper_keywords": ["Functional programming", " arity analysis", " cardinality analysis", " interactive theorem proving"], "paper_abstract": "We prove that the Call Arity analysis and transformation, as implemented in the Haskell compiler GHC, is safe, i.e. does not impede the performance of the program. We formalized syntax, semantics, the analysis and the transformation in the interactive theorem prover Isabelle to obtain a machine-checked proof and hence a level of rigor rarely obtained for compiler optimization safety theorems. The proof is modular and introduces trace trees as a suitable abstraction in abstract cardinality analyses. We discuss the breadth of the formalization gap.", "paper_title": "Formally Proving a Compiler Transformation Safe", "paper_id": "WOS:000370549100005"}