{"auto_keywords": [{"score": 0.04880638758905066, "phrase": "maximum_flow_problem"}, {"score": 0.004815983325397707, "phrase": "pre"}, {"score": 0.004481132747216135, "phrase": "classic_pre"}, {"score": 0.004133055661437163, "phrase": "missing_link"}, {"score": 0.003677280504320636, "phrase": "common_high-level_conceptual_basis"}, {"score": 0.0030171910207671205, "phrase": "well-known_concepts"}, {"score": 0.0027575842698911173, "phrase": "unique_minimum_cut"}, {"score": 0.0026841368358805407, "phrase": "flow_network"}, {"score": 0.0021049977753042253, "phrase": "conceptual_simplicity"}], "paper_keywords": [""], "paper_abstract": "We show that classic PRE is also a maximum flow problem, thereby revealing the missing link between classic and speculative PRE, and more importantly, establishing a common high-level conceptual basis for this important compiler optimisation. To demonstrate this, we formulate a new, simple unidirectional bit-vector algorithm for classic PRE based only on the well-known concepts of availability and anticipatability. Designed to find a unique minimum cut in a flow network derived from a CFG, which is proved simply but rigorously, our algorithm is simple and intuitive, and its optimality is self-evident. This conceptual simplicity also translates into efficiency, as validated by experiments.", "paper_title": "A fresh look at PRE as a maximum flow problem", "paper_id": "WOS:000237082300012"}