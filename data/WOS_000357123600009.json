{"auto_keywords": [{"score": 0.04652122652620528, "phrase": "r_interpreter"}, {"score": 0.00481495049065317, "phrase": "dynamic_page_sharing_optimization"}, {"score": 0.00473320761888448, "phrase": "dynamic_languages"}, {"score": 0.0045543011700929096, "phrase": "large_data_sets"}, {"score": 0.00440093312826378, "phrase": "large_memory_overhead"}, {"score": 0.004344755264641137, "phrase": "wasteful_memory_allocation_policies"}, {"score": 0.004270960586542813, "phrase": "application's_working"}, {"score": 0.0041984140090404985, "phrase": "available_physical_memory"}, {"score": 0.0038702288460744274, "phrase": "memory_optimizations"}, {"score": 0.0037238193456845124, "phrase": "existing_r_optimizations"}, {"score": 0.0036448787596988423, "phrase": "dynamic_compilation"}, {"score": 0.0036137713873827374, "phrase": "native_libraries"}, {"score": 0.0030183163057929687, "phrase": "low-overhead_page_sharing_approach"}, {"score": 0.002929056388593134, "phrase": "interpreter's_memory_overhead"}, {"score": 0.0028302635493019867, "phrase": "high_runtime_overhead"}, {"score": 0.0028060889647071787, "phrase": "existing_generic_approaches"}, {"score": 0.0027821202902740846, "phrase": "memory_deduplication"}, {"score": 0.0026538960171433985, "phrase": "interpreter_data_structures"}, {"score": 0.0026312238938540787, "phrase": "memory_allocation_patterns"}, {"score": 0.002553382046204689, "phrase": "specific_r_applications"}, {"score": 0.0023942269247089277, "phrase": "memory_consumption"}, {"score": 0.002274059352027924, "phrase": "real-world_r_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "significant_speedups"}], "paper_keywords": ["R language", " memory optimization", " page sharing", " paging", " virtual memory"], "paper_abstract": "Dynamic languages such as R are increasingly used to process large data sets. Here, the R interpreter induces a large memory overhead due to wasteful memory allocation policies. If an application's working set exceeds the available physical memory, the OS starts to swap, resulting in slowdowns of a several orders of magnitude. Thus, memory optimizations for R will be beneficial to many applications. Existing R optimizations are mostly based on dynamic compilation or native libraries. Both methods are futile when the OS starts to page out memory. So far, only a few, data-type or application specific memory optimizations for R exist. To remedy this situation, we present a low-overhead page sharing approach for R that significantly reduces the interpreter's memory overhead. Concentrating on the most rewarding optimizations avoids the high runtime overhead of existing generic approaches for memory deduplication or compression. In addition, by applying knowledge of interpreter data structures and memory allocation patterns, our approach is not constrained to specific R applications and is transparent to the R interpreter. Our page sharing optimization enables us to reduce the memory consumption by up to 53.5% with an average of 18.0% for a set of real-world R benchmarks with a runtime overhead of only 5.3% on average. In cases where page I/O can be avoided, significant speedups are achieved.", "paper_title": "Dynamic Page Sharing Optimization for the R Language", "paper_id": "WOS:000357123600009"}