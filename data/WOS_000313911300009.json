{"auto_keywords": [{"score": 0.04507807793562587, "phrase": "side_effects"}, {"score": 0.00481495049065317, "phrase": "frp._functional_reactive_programming"}, {"score": 0.0047809300942547135, "phrase": "frp"}, {"score": 0.004713594814274419, "phrase": "useful_model"}, {"score": 0.004663716126870148, "phrase": "real-time_and_reactive_systems"}, {"score": 0.004565529359523792, "phrase": "signal_function"}, {"score": 0.004469400468609653, "phrase": "input_values"}, {"score": 0.0043908341845978575, "phrase": "output_values"}, {"score": 0.004032441847334232, "phrase": "previous_work"}, {"score": 0.004003929270871037, "phrase": "winograd"}, {"score": 0.0031229055434606003, "phrase": "core_component"}, {"score": 0.0029190995437264377, "phrase": "wormholes_less_verbose"}, {"score": 0.0027188802510720775, "phrase": "simply_typed_lambda_calculus"}, {"score": 0.0026805109390121706, "phrase": "typing_rules"}, {"score": 0.00266152927283908, "phrase": "operational_semantics"}, {"score": 0.0025869338215971536, "phrase": "new_form"}, {"score": 0.0025686131021181134, "phrase": "semantic_transition"}, {"score": 0.0025233755103976317, "phrase": "temporal_transition"}, {"score": 0.0024789326485851666, "phrase": "frp_program"}, {"score": 0.00240089402509933, "phrase": "better_reason"}, {"score": 0.002317055705600351, "phrase": "haskell_implementation"}, {"score": 0.0021049977753042253, "phrase": "frp_framework"}], "paper_keywords": ["Design", " Languages", " Functional Reactive Programming", " Arrows", " Resource Types", " Stream Processing", " Side Effects", " Causality"], "paper_abstract": "Functional reactive programming (FRP) is a useful model for programming real-time and reactive systems in which one defines a signal function to process a stream of input values into a stream of output values. However, performing side effects (e. g. memory mutation or input/output) in this model is tricky and typically unsafe. In previous work, Winograd-Cort et al. [2012] introduced resource types and wormholes to address this problem. This paper better motivates, expands upon, and formalizes the notion of a wormhole to fully unlock its potential. We show, for example, that wormholes can be used to define the concept of causality. This in turn allows us to provide behaviors such as looping, a core component of most languages, without building it directly into the language. We also improve upon our previous design by making wormholes less verbose and easier to use. To formalize the notion of a wormhole, we define an extension to the simply typed lambda calculus, complete with typing rules and operational semantics. In addition, we present a new form of semantic transition that we call a temporal transition to specify how an FRP program behaves over time and to allow us to better reason about causality. As our model is designed for a Haskell implementation, the semantics are lazy. Finally, with the language defined, we prove that our wormholes indeed allow side effects to be performed safely in an FRP framework.", "paper_title": "Wormholes: Introducing Effects to FRP", "paper_id": "WOS:000313911300009"}