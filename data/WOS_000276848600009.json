{"auto_keywords": [{"score": 0.028573535114768858, "phrase": "final_state"}, {"score": 0.015719716506582538, "phrase": "source_code_revisions"}, {"score": 0.004348936976349555, "phrase": "real_software_development_process"}, {"score": 0.004271490815763164, "phrase": "refactoring_operation"}, {"score": 0.0036553070575015344, "phrase": "software_version_archive"}, {"score": 0.0035473867669654174, "phrase": "easy_process"}, {"score": 0.0034220655476652683, "phrase": "impure_refactorings"}, {"score": 0.0032618078775887077, "phrase": "graph_search"}, {"score": 0.0025051811853674215, "phrase": "source_code_differences"}, {"score": 0.0022218413146898887, "phrase": "heuristic_distance"}, {"score": 0.0021561514733516654, "phrase": "case_studies"}], "paper_keywords": ["refactoring", " version archives", " source code differences", " informed search", " heuristics"], "paper_abstract": "This paper proposes a technique for detecting the occurrences of refactoring from source code revisions In a real software development process, a refactoring operation may sometimes be performed together with other modifications at the same revision. This is means that detecting refactorings from the differences between two versions stored in a software version archive is not usually an easy process In order to detect these impure refactorings. we model the detection within a graph search Our technique considers a version of a program as a state and a refactoring as a transition between two states It then searches for the path that approaches from the initial to the final state To improve the efficiency of the search, we use the source code differences between the current and the final state for choosing the candidates of refactoring to be applied next and estimating the heuristic distance to the final state Through case studies we show that our approach is feasible to detect combinations of refactorings.", "paper_title": "Search-Based Refactoring Detection from Source Code Revisions", "paper_id": "WOS:000276848600009"}