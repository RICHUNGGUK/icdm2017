{"auto_keywords": [{"score": 0.038667509867783875, "phrase": "ipl"}, {"score": 0.010496270230240735, "phrase": "flash-memory_storage_systems"}, {"score": 0.007653612593639957, "phrase": "merge_operations"}, {"score": 0.004847509551205885, "phrase": "aipl"}, {"score": 0.004815080616374359, "phrase": "adaptive"}, {"score": 0.004797225036013284, "phrase": "in-page_logging"}, {"score": 0.004623503587186056, "phrase": "embedded_devices"}, {"score": 0.0045895181082906715, "phrase": "enterprise_storage_systems"}, {"score": 0.004522291357556591, "phrase": "flash-based_storage_devices"}, {"score": 0.004456044928556639, "phrase": "flash_translation_layer"}, {"score": 0.004326436568191916, "phrase": "special_features"}, {"score": 0.004294625285753825, "phrase": "flash_memory"}, {"score": 0.004139031608167985, "phrase": "ftl"}, {"score": 0.0040334646345658145, "phrase": "bast"}, {"score": 0.003584025547693836, "phrase": "best_performance"}, {"score": 0.003353521531649663, "phrase": "overall_performance"}, {"score": 0.0031032109441552287, "phrase": "adaptive_ipl"}, {"score": 0.0030464123943266673, "phrase": "log_region"}, {"score": 0.003012831982759529, "phrase": "block_resizable"}, {"score": 0.0028189599390180536, "phrase": "large_log_region"}, {"score": 0.00266693888510356, "phrase": "cold_block"}, {"score": 0.002541817937194794, "phrase": "small_log_region"}, {"score": 0.0024586427394152196, "phrase": "update_pattern"}, {"score": 0.0023869914500743083, "phrase": "updatepattern-based_algorithm"}, {"score": 0.002343271162668978, "phrase": "log_region_size"}, {"score": 0.002317423416027688, "phrase": "newly_allocated_block"}, {"score": 0.0022665781920241245, "phrase": "tpc-c_traces"}, {"score": 0.0021442819603609835, "phrase": "merge_count"}, {"score": 0.0021049977753042253, "phrase": "elapsed_time"}], "paper_keywords": ["flash memory", " adaptive algorithm", " IPL", " update pattern"], "paper_abstract": "Flash memory is widely used in embedded devices and enterprise storage systems. Currently, flash-based storage devices usually use a flash translation layer (FTL) to cope with the special features of flash memory. Many methods for the design and implementation of the FTL have been proposed, such as BAST (block-associative sector translation), FAST (fully associative sector translation), and IPL (inpage logging), of which IPL has been demonstrated to have the best performance. However, IPL offers little consideration to reducing merge operations that consequently result in the degradation of the overall performance of flash-memory storage systems. We propose an improvement to IPL, called adaptive IPL (AIPL). The idea of adaptive IPL is to make the log region in a block resizable, therefore a hot block (i.e., a write-intensive block) will use a large log region so as to absorb more page updates and in turn reduce the merge operations, while a cold block, i.e., a block rarely written to, will use a small log region. This is realized by first detecting the update pattern of a block and then presenting an updatepattern-based algorithm to dynamically adjust the log region size of a newly allocated block. We conduct experiments on TPC-C traces and synthetic traces and compare the performance of AIPL with other competitors in terms of merge count, write count and elapsed time. The results demonstrate that compared with IPL, AIPL can reduce merge operations by 65% and write operations by 54% on average.", "paper_title": "Adaptive in-page logging for flash-memory storage systems", "paper_id": "WOS:000329625400009"}