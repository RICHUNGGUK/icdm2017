{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "optimal_cache-oblivious_priority_queue_data_structure"}, {"score": 0.004442032546224076, "phrase": "delete-min_operations"}, {"score": 0.004139401327448807, "phrase": "memory_transfers"}, {"score": 0.0037423521744765075, "phrase": "block_transfer_sizes"}, {"score": 0.003522579870903474, "phrase": "multilevel_memory_hierarchy"}, {"score": 0.0033832583769880576, "phrase": "cache-_oblivious_data_structure"}, {"score": 0.0024742098091226203, "phrase": "b._priority"}, {"score": 0.0023762535034673017, "phrase": "critical_component"}, {"score": 0.002259231376607264, "phrase": "best_known_external_memory_graph_algorithms"}], "paper_keywords": ["cache-oblivious algorithms", " priority queue"], "paper_abstract": "We develop an optimal cache-oblivious priority queue data structure, supporting insertion, deletion, and delete-min operations in O(1/B log M / B N/B) amortized memory transfers, where M and B are the memory and block transfer sizes of any two consecutive levels of a multilevel memory hierarchy. In a cache- oblivious data structure, M and B are not used in the description of the structure. Our structure is as efficient as several previously developed external memory (cache-aware) priority queue data structures, which all rely crucially on knowledge about M and B. Priority queues are a critical component in many of the best known external memory graph algorithms, and using our cache-oblivious priority queue we develop several cache-oblivious graph algorithms.", "paper_title": "An optimal cache-oblivious priority queue and its application to graph algorithms", "paper_id": "WOS:000246299400007"}