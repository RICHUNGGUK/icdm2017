{"auto_keywords": [{"score": 0.04703570948560471, "phrase": "memory_consumption"}, {"score": 0.00481495049065317, "phrase": "abstract_interpretation"}, {"score": 0.004774146014576968, "phrase": "inference"}, {"score": 0.004731492618963217, "phrase": "recursive_functions"}, {"score": 0.00462919213721188, "phrase": "abstract_interpretation-based_static_analysis"}, {"score": 0.004450568197899267, "phrase": "functional_language"}, {"score": 0.004335327481141741, "phrase": "safe"}, {"score": 0.0041136473765874815, "phrase": "heap_regions"}, {"score": 0.003937573222812911, "phrase": "garbage_collector"}, {"score": 0.003818807671883534, "phrase": "safe_features"}, {"score": 0.003752550907120244, "phrase": "intuitive_examples"}, {"score": 0.0035761913760242697, "phrase": "particular_program_executions"}, {"score": 0.003468287913322255, "phrase": "abstract_interpretation_rules"}, {"score": 0.003438058620195309, "phrase": "non-recursive_function_definitions"}, {"score": 0.0033197446406648626, "phrase": "recursive_ones"}, {"score": 0.003247868216333148, "phrase": "interesting_property"}, {"score": 0.003108735847242537, "phrase": "inferred_bounds"}, {"score": 0.0029110999689379497, "phrase": "prior_inferred_bound"}, {"score": 0.0028480459059007468, "phrase": "tighter_and_tighter_bounds"}, {"score": 0.0024325244760735566, "phrase": "complete_development"}, {"score": 0.002359046870732839, "phrase": "technical_report"}, {"score": 0.0023180581939456686, "phrase": "authors'_site"}, {"score": 0.0022579036318895753, "phrase": "related_work_discussion"}, {"score": 0.002228412982799273, "phrase": "small_examples"}, {"score": 0.0022089663761854657, "phrase": "bigger_case_studies"}, {"score": 0.0021610874773389096, "phrase": "fore-mentioned_technical_report"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Resource analysis", " Abstract interpretation", " Functional languages", " Regions"], "paper_abstract": "We present an abstract interpretation-based static analysis for inferring heap and stack memory consumption in a functional language. The language, called Safe, is eager and firstorder, and its memory management system is based on heap regions instead of the more conventional approach of having a garbage collector. This paper begins by presenting Safe features by means of intuitive examples, and then defines its formal semantics, including the memory consumption of particular program executions. It continues by giving the abstract interpretation rules for non-recursive function definitions, and then how the memory consumption of recursive ones is approximated. An interesting property of our analysis is that, under certain reasonable conditions, the inferred bounds are reductive, which means that by iterating the analysis using as input the prior inferred bound, we can get tighter and tighter bounds, all of them correct. In some cases, even the exact bound is obtained. However, and due to lack of space, reductivity is not presented in this paper. The complete development can however be found in a technical report available at the authors' site. The paper includes a related work discussion, and small examples. Bigger case studies are presented in the fore-mentioned technical report. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Space consumption analysis by abstract interpretation: Inference of recursive functions", "paper_id": "WOS:000368556800004"}