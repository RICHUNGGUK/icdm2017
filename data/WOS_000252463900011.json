{"auto_keywords": [{"score": 0.034860280623906045, "phrase": "linear_order"}, {"score": 0.00481495049065317, "phrase": "jth_solution"}, {"score": 0.004772668787820885, "phrase": "first-order_query"}, {"score": 0.004689210758225518, "phrase": "\"optimal\"_data_complexity"}, {"score": 0.004607205374689976, "phrase": "first-order_queries"}, {"score": 0.004553329756664763, "phrase": "bounded_degree"}, {"score": 0.004369656712097927, "phrase": "logical_or_combinatorial_problems"}, {"score": 0.003651722462180419, "phrase": "specific_linear_order"}, {"score": 0.0033332184113249444, "phrase": "rank_j"}, {"score": 0.003255619460113579, "phrase": "\"minimal\"_data_complexity"}, {"score": 0.0031057823670329193, "phrase": "structure_s"}, {"score": 0.0030156459374311856, "phrase": "random_element"}, {"score": 0.0027282473656358784, "phrase": "jth_element"}, {"score": 0.002564555834629261, "phrase": "lexicographical_order"}, {"score": 0.002482760588789182, "phrase": "fixed_formula"}, {"score": 0.0023132192903270233, "phrase": "average_constant_time"}, {"score": 0.002279379132030189, "phrase": "constant_time"}, {"score": 0.0022593125871715894, "phrase": "constant_delay"}, {"score": 0.0021362545732479987, "phrase": "complexity_results"}, {"score": 0.0021174453532942115, "phrase": "normalization_procedure"}, {"score": 0.0021049977753042253, "phrase": "first-order_formulas"}], "paper_keywords": ["complexity of enumeration", " first-order queries", " structures of bounded degree", " linear time", " constant time", " constant delay"], "paper_abstract": "We design algorithms of \"optimal\" data complexity for several natural problems about first-order queries on structures of bounded degree. For that purpose, we first introduce a framework to deal with logical or combinatorial problems R subset of I x O whose instances x is an element of I may admit of several solutions R(x) = {y is an element of O : (x, y) is an element of R}. One associates to such a problem several specific tasks: compute a random (for the uniform probability distribution) solution y. R(x); enumerate without repetition each solution y(j) in some specific linear order y(0) < y(1) <... < y(n-1) where R(x) = {y(0),..., y(n-1)}; compute the solution y(j) of rank j in the linear order <. Algorithms of \"minimal\" data complexity are presented for the following problems: given any first-order formula phi((v) over bar) and any structure S of bounded degree: (1) compute a random element of phi(S) = {(a) over bar : (S, (a) over bar) satisfies phi((v) over bar)}; (2) compute the jth element of phi(S) for some linear order of phi(S); (3) enumerate the elements of phi(S) in lexicographical order. More precisely, we prove that, for any fixed formula phi, the above problem (1) (resp. (2), (3)) can be computed within average constant time (resp. within constant time, with constant delay) after a linear (O(vertical bar S vertical bar)) precomputation. Our essential tool for deriving those complexity results is a normalization procedure of first-order formulas on bijective structures.", "paper_title": "Computing the jth solution of a first-order query", "paper_id": "WOS:000252463900011"}