{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "data_structure_knowledge"}, {"score": 0.04922237591220716, "phrase": "strong_atomicity"}, {"score": 0.03663614835271814, "phrase": "new_strategy"}, {"score": 0.030074948199064692, "phrase": "programmer-specified_fine-grained_locks"}, {"score": 0.004771672073078768, "phrase": "efficient_lock_generation"}, {"score": 0.004602395776895036, "phrase": "multicore_systems"}, {"score": 0.004561019117546361, "phrase": "shared-memory_parallel_languages"}, {"score": 0.00447937340641839, "phrase": "atomic_operations"}, {"score": 0.00441909542037375, "phrase": "commonly_used_and_studied_paradigms_for_atomicity_are_fine-grained_locking"}, {"score": 0.004055652445791872, "phrase": "substantial_overhead"}, {"score": 0.003947186611084043, "phrase": "atomicity_violations"}, {"score": 0.0037898820206470085, "phrase": "programmer-specified_atomic_sections"}, {"score": 0.003671865026158296, "phrase": "imprecise_pointer_analysis"}, {"score": 0.0036224139706218916, "phrase": "mere_possibility"}, {"score": 0.00357362651129581, "phrase": "conflicting_operation"}, {"score": 0.0034467039994594065, "phrase": "compiler-generated_locking"}, {"score": 0.0033242742850902295, "phrase": "lock_generation_analyses"}, {"score": 0.0032794890195334513, "phrase": "unnecessary_serialization"}, {"score": 0.003148709618042979, "phrase": "java_language"}, {"score": 0.0030644247579222333, "phrase": "eight-thread_speedups"}, {"score": 0.0029959082125682918, "phrase": "five_stamp_benchmarks"}, {"score": 0.002942196368747418, "phrase": "software_transactions"}, {"score": 0.002687702958515561, "phrase": "compiler_knowledge"}, {"score": 0.0026634937939104177, "phrase": "data_structures"}, {"score": 0.002603918128553617, "phrase": "compiler_analysis"}, {"score": 0.002568812627436125, "phrase": "eight-thread_performance"}, {"score": 0.002488724764295623, "phrase": "new_analysis"}, {"score": 0.002455168454109375, "phrase": "software_support"}, {"score": 0.0021049977753042253, "phrase": "static_analyses"}], "paper_keywords": ["Algorithms", " Performance", " Design", " Automatic lock generation", " transactional memory", " parallel programming"], "paper_abstract": "To achieve high-performance on multicore systems, shared-memory parallel languages must efficiently implement atomic operations. The commonly used and studied paradigms for atomicity are fine-grained locking, which is both difficult to program and error-prone; optimistic software transactions, which require substantial overhead to detect and recover from atomicity violations; and compiler-generation of locks from programmer-specified atomic sections, which leads to serialization whenever imprecise pointer analysis suggests the mere possibility of a conflicting operation. This paper presents a new strategy for compiler-generated locking that uses data structure knowledge to facilitate more precise alias and lock generation analyses and reduce unnecessary serialization. Implementing and evaluating these ideas in the Java language shows that the new strategy achieves eight-thread speedups of 0.83 to 5.9 for the five STAMP benchmarks studied, outperforming software transactions on all but one benchmark, and nearly matching programmer-specified fine-grained locks on all but one benchmark. The results also indicate that compiler knowledge of data structures improves the effectiveness of compiler analysis, boosting eight-thread performance by up to 300%. Further, the new analysis allows for software support of strong atomicity with less than 1% overhead for two benchmarks and less than 20% for three others. The strategy also nearly matches the performance of programmer-specified fine-grained locks for the SPECjbb2000 benchmark, which has traditionally not been amenable to static analyses.", "paper_title": "Using Data Structure Knowledge for Efficient Lock Generation and Strong Atomicity", "paper_id": "WOS:000280548100026"}