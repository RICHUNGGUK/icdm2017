{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "frequent_updates"}, {"score": 0.01490808758315563, "phrase": "proposed_approach"}, {"score": 0.008484303123268398, "phrase": "semibulk_loading"}, {"score": 0.004675768396728975, "phrase": "update-intensive_applications"}, {"score": 0.004409304640026443, "phrase": "location-aware_services"}, {"score": 0.00428179779071721, "phrase": "stream_databases"}, {"score": 0.004097389262726735, "phrase": "r-tree-based_index_structure"}, {"score": 0.003715425273229361, "phrase": "massive_moving_objects"}, {"score": 0.0035553221885904467, "phrase": "small_in-memory_buffer"}, {"score": 0.0032079813320482304, "phrase": "reasonable_memory_overhead"}, {"score": 0.0031457622320220364, "phrase": "whole_data"}, {"score": 0.0030101325901285537, "phrase": "previous_works"}, {"score": 0.0029229677574293725, "phrase": "query_performance"}, {"score": 0.002852256089630964, "phrase": "realistic_environment"}, {"score": 0.0027561164046279413, "phrase": "buffer_hit_ratio"}, {"score": 0.0026762874092443197, "phrase": "new_page-replacement_policy"}, {"score": 0.002598764579760562, "phrase": "buffered_node"}, {"score": 0.0024503741901918527, "phrase": "threshold_ratio"}, {"score": 0.002265586601922693, "phrase": "extensive_experimental_evaluation"}, {"score": 0.002157223877108711, "phrase": "previous_approaches"}], "paper_keywords": ["Indexing moving objects", " R-trees", " location-aware services", " update-intensive applications", " frequent updates"], "paper_abstract": "Managing frequent updates is greatly important in many update-intensive applications, such as location-aware services, sensor networks, and stream databases. In this paper, we present an R-tree-based index structure (called R-sb-tree, R-tree with semibulk loading) for efficiently managing frequent updates from massive moving objects. The concept of semibulk loading is exploiting a small in-memory buffer to defer, buffer, and group the incoming updates and bulk-insert these updates simultaneously. With a reasonable memory overhead (typically only 1 percent of the whole data set), the proposed approach far outperforms the previous works in terms of update and query performance as well in a realistic environment. In order to further increase buffer hit ratio for the proposed approach, a new page-replacement policy that exploits the level of buffered node is proposed. Furthermore, we introduce the concept of deferring threshold ratio (dtr) that simply enables deferring CPU-and I/O-intensive operations such as node splits and removals. Extensive experimental evaluation reveals that the proposed approach is far more efficient than previous approaches for managing frequent updates under various settings.", "paper_title": "Managing Frequent Updates in R-Trees for Update-Intensive Applications", "paper_id": "WOS:000269851800006"}