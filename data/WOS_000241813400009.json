{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "modular_linking"}, {"score": 0.00475070135279933, "phrase": "oo_languages"}, {"score": 0.004655924035639928, "phrase": "successful_assembly"}, {"score": 0.004593787100061613, "phrase": "large_programs"}, {"score": 0.004502126088469323, "phrase": "software_components"}, {"score": 0.004412285905508977, "phrase": "modular_reasoning"}, {"score": 0.004237925318473508, "phrase": "component_code"}, {"score": 0.0038314621564116192, "phrase": "binary_form"}, {"score": 0.0033947493433995977, "phrase": "java"}, {"score": 0.003216804708106142, "phrase": "intuitive_and_formal_framework"}, {"score": 0.0029473940028924748, "phrase": "specific_problem"}, {"score": 0.0028498718992429825, "phrase": "java_modular"}, {"score": 0.002507748938616919, "phrase": "language_features"}, {"score": 0.002344468886431959, "phrase": "java's_core_language_features"}, {"score": 0.0022215160785078797, "phrase": "high_degree"}, {"score": 0.0021049977753042253, "phrase": "cyclic_dependencies"}], "paper_keywords": [""], "paper_abstract": "The successful assembly of large programs out of software components depends on modular reasoning. When the linking of component code is modular, components can be compiled and type checked separately, deployed in binary form, and are easier to reuse. Unfortunately, linking is not modular in many mainstream OO languages such as Java. In this paper we propose an intuitive and formal framework for enhancing a language with modular linking, which is applied to the specific problem of making linking in Java modular. In our proposed framework, the degree to which components can be reasoned about modularly is adversely affected by language features that limit abstraction. We show that most of Java's core language features, such as inheritance, permit a high degree of modular linking even in the presence of cyclic dependencies.", "paper_title": "A framework for modular linking in OO languages", "paper_id": "WOS:000241813400009"}