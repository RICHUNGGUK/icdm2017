{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_programs"}, {"score": 0.004673709383305897, "phrase": "data_races"}, {"score": 0.0046046429665581555, "phrase": "java_programs"}, {"score": 0.004502943680955863, "phrase": "difficult_problem"}, {"score": 0.004403480614319231, "phrase": "best_static_techniques"}, {"score": 0.004179824713643488, "phrase": "best_dynamic_techniques"}, {"score": 0.0039088121438737924, "phrase": "new_technique"}, {"score": 0.0031963987773420068, "phrase": "concolic_execution"}, {"score": 0.00296675450822924, "phrase": "useful_inputs"}, {"score": 0.0027949428646076627, "phrase": "existing_technique"}, {"score": 0.002712794864739074, "phrase": "manageable_number"}, {"score": 0.0026726283357752585, "phrase": "race_candidates"}, {"score": 0.002443784721651744, "phrase": "best_existing_dynamic_techniques"}, {"score": 0.0021049977753042253, "phrase": "rare_and_hard-to-find_races"}], "paper_keywords": ["concurrency", " race detection"], "paper_abstract": "Detection of data races in Java programs remains a difficult problem. The best static techniques produce many false positives, and also the best dynamic techniques leave room for improvement. We present a new technique called race directed scheduling that for a given race candidate searches for an input and a schedule that lead to the race. The search iterates a combination of concolic execution and schedule improvement, and turns out to find useful inputs and schedules efficiently. We use an existing technique to produce a manageable number of race candidates. Our experiments on 23 Java programs found 72 real races that were missed by the best existing dynamic techniques. Among those 72 races, 31 races were found with schedules that have between 1 million and 108 million events, which suggests that they are rare and hard-to-find races.", "paper_title": "Race Directed Scheduling of Concurrent Programs", "paper_id": "WOS:000349142100026"}