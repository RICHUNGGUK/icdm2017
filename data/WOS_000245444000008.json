{"auto_keywords": [{"score": 0.03097848383348216, "phrase": "prime_intercode_decomposition"}, {"score": 0.00481495049065317, "phrase": "comma-free_codes"}, {"score": 0.004615202066192795, "phrase": "structural_properties"}, {"score": 0.004518442937844318, "phrase": "finite-state_automata"}, {"score": 0.004195418010131832, "phrase": "polynomial-time_algorithm"}, {"score": 0.002863921785266393, "phrase": "intercode_regular_languages"}, {"score": 0.002658863179011018, "phrase": "intercode_primality_test"}, {"score": 0.002468450551616404, "phrase": "finite-state_automaton"}, {"score": 0.0021501863832966966, "phrase": "intercode_regular_language"}, {"score": 0.0021049977753042253, "phrase": "polynomial_time"}], "paper_keywords": ["regular languages", " finite-state automata", " intercodes", " state-pair graphs", " prime decompositions"], "paper_abstract": "Intercodes are a generalization of comma-free codes. Using the structural properties of finite-state automata recognizing an intercode we develop a polynomial-time algorithm for determining whether or not a given regular language L is an intercode. If the answer is yes, our algorithm yields also the smallest index k such that L is a k-intercode. Furthermore, we examine the prime intercode decomposition of intercode regular languages and design an algorithm for the intercode primality test of an intercode recognized by a finite-state automaton. We also propose an algorithm that computes the prime intercode decomposition of an intercode regular language in polynomial time. Finally, we demonstrate that the prime intercode decomposition need not be unique.", "paper_title": "Intercode regular languages", "paper_id": "WOS:000245444000008"}