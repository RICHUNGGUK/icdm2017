{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "almost_compositional_functions"}, {"score": 0.02787080894154439, "phrase": "dependent_type_theory"}, {"score": 0.004563427013973105, "phrase": "recursive_data_types"}, {"score": 0.00441883624011048, "phrase": "mutually_recursive_data_types"}, {"score": 0.003947765701573287, "phrase": "limited_number"}, {"score": 0.0035457302646174148, "phrase": "function_oil"}, {"score": 0.003342280102112269, "phrase": "generic_part"}, {"score": 0.0032536902910768957, "phrase": "data_type"}, {"score": 0.0031845067058084583, "phrase": "data_types"}, {"score": 0.002890887778279196, "phrase": "predictable_compositional_cases"}, {"score": 0.0028293966058473476, "phrase": "interesting_work"}, {"score": 0.0027841357057119295, "phrase": "task-specific_part"}, {"score": 0.0025962029048520324, "phrase": "inductive_families"}, {"score": 0.002554693191167623, "phrase": "haskell"}, {"score": 0.0025273383208209922, "phrase": "generalized_algebraic_data_types"}, {"score": 0.0024341127226412793, "phrase": "java"}, {"score": 0.0023566987138026285, "phrase": "visitor_design_pattern"}, {"score": 0.0022818671653408278, "phrase": "\"scrap_your_boilerplate\"_approach"}, {"score": 0.0021975548867457606, "phrase": "general_tree_types"}], "paper_keywords": [""], "paper_abstract": "This paper introduce a pattern for almost compositional functions over recursive data types, and over families Of mutually recursive data types. Here \"almost compositional\" means that for all of the constructors in the type(s), except a limited number of them, the result of the function depends only oil the constructor and the results of calling the function oil the constructor's arguments. The pattern consists of a generic part constructed once for each data type or family of data types. and a task-specific part. The generic; part contains the code for the predictable compositional cases, leaving the interesting work to the task-specific part. Examples of the pattern are given, implemented in dependent type theory with inductive families. in Haskell with generalized algebraic data types and rank-2 polymorphism. and in Java using a variant of the Visitor design pattern. The relationships to the \"Scrap Your Boilerplate\" approach to generic programming. and to general tree types in dependent type theory. are investigated by reimplementing our operations using those frameworks.", "paper_title": "A pattern for almost compositional functions", "paper_id": "WOS:000261111700002"}