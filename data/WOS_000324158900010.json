{"auto_keywords": [{"score": 0.004739056045644449, "phrase": "conventional_wisdom"}, {"score": 0.004627441072541506, "phrase": "concurrent_data_structures"}, {"score": 0.003916098498242888, "phrase": "contended_hot_spots"}, {"score": 0.0037935066882208235, "phrase": "concurrent_fifo_queues"}, {"score": 0.003531474887552889, "phrase": "combining-based_concurrent_queues"}, {"score": 0.0033668870709083884, "phrase": "different_approach"}, {"score": 0.002548331088496964, "phrase": "linearizable_concurrent_fifo_queue"}, {"score": 0.002391067964886602, "phrase": "contended_hot_spot"}, {"score": 0.0023346234464901978, "phrase": "combining-based_implementations"}, {"score": 0.002190519728921395, "phrase": "concurrency_levels"}], "paper_keywords": ["concurrent queue", " nonblocking algorithm", " fetch-and-add"], "paper_abstract": "Conventional wisdom in designing concurrent data structures is to use the most powerful synchronization primitive, namely compare-and-swap (CAS), and to avoid contended hot spots. In building concurrent FIFO queues, this reasoning has led researchers to propose combining-based concurrent queues. This paper takes a different approach, showing how to rely on fetch-and-add (F&A), a less powerful primitive that is available on x86 processors, to construct a nonblocking (lock-free) linearizable concurrent FIFO queue which, despite the F&A being a contended hot spot, outperforms combining-based implementations by 1.5 x to 2.5 x in all concurrency levels on an x86 server with four multicore processors, in both single-processor and multi-processor executions.", "paper_title": "Fast Concurrent Queues for x86 Processors", "paper_id": "WOS:000324158900010"}