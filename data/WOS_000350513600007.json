{"auto_keywords": [{"score": 0.041996689288621714, "phrase": "software_engineering_and_software_engineering_research"}, {"score": 0.022238218545969846, "phrase": "software_engineering"}, {"score": 0.006911570586264287, "phrase": "theoretical_basis"}, {"score": 0.00481495049065317, "phrase": "unifying_theories"}, {"score": 0.004784565134881178, "phrase": "empirical_software_engineering"}, {"score": 0.004562676524864167, "phrase": "physical_and_behavioral_sciences"}, {"score": 0.004406496547539966, "phrase": "software_engineers"}, {"score": 0.004364833543615155, "phrase": "software_engineering_researchers"}, {"score": 0.004175533280178052, "phrase": "greater_rigor"}, {"score": 0.00393163747242631, "phrase": "simple_theory_modeling_language"}, {"score": 0.003857606273328462, "phrase": "informally_described_theories"}, {"score": 0.0037610536973798113, "phrase": "modeled_theories"}, {"score": 0.003643741834170836, "phrase": "general_theory"}, {"score": 0.0033983319323179495, "phrase": "unified_theoretical_foundation"}, {"score": 0.0031593653672862924, "phrase": "theory_d"}, {"score": 0.0030998304961483217, "phrase": "design_part"}, {"score": 0.0030704837930305745, "phrase": "theory_e"}, {"score": 0.003022186855664124, "phrase": "empirical_evaluation"}, {"score": 0.0026285439034014904, "phrase": "empirical_evaluations"}, {"score": 0.002570817338292482, "phrase": "logical_sense"}, {"score": 0.002538400273615248, "phrase": "atomic_and_composed_theories"}, {"score": 0.0022500695985527668, "phrase": "larger_more_complex_theories"}, {"score": 0.0022287497627555895, "phrase": "simpler_theories"}, {"score": 0.0021049977753042253, "phrase": "resulting_theoretical_models"}], "paper_keywords": ["Theories and models of software engineering and software engineering research", " Model calculus", " Model composition", " Framework evaluation"], "paper_abstract": "One of the reasons for the lack of rigor in software engineering compared to physical and behavioral sciences is that the theories that underpin our work, both as software engineers and as software engineering researchers, have not been given enough attention. To provide a step forward towards greater rigor, a framework has been created with which to explore theories of software engineering and software engineering research. This framework provides a simple theory modeling language and model calculus to explore informally described theories and to generate the results of composing modeled theories. To illustrate and evaluate this framework, a general theory about software engineering is presented and then two simple theories, D and E, are proposed as the basis for laying out a unified theoretical foundation for software engineering and software engineering research. Software Engineering consists of two logical parts: design, and empirical evaluation (both terms used in their broadest senses). Theory D is the theoretical basis for the design part, and theory E is the theoretical basis for empirical evaluation. These two theories are then composed in various ways to lay out a space (a taxonomy, or ontology if you will) for software engineering and software engineering research. Finally, it is claimed that software engineering and software engineering research (both fully integrated with empirical evaluations) are models (in the logical sense) for these atomic and composed theories. To further evaluate the framework, examples are provided of modeling (implicit) theories found in a number of software engineering (theory) papers. The results of this research are: 1) a scientific elegance in creating larger more complex theories out of simpler theories, 2) an elegant way of explaining the complexity of software engineering and software engineering research, and 3) a theory modeling language and model calculus for composing the resulting theoretical models. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "A framework for exploring unifying theories of empirical software engineering", "paper_id": "WOS:000350513600007"}