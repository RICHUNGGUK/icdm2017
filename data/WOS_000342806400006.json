{"auto_keywords": [{"score": 0.04703659461047988, "phrase": "resource_requirements"}, {"score": 0.03232836189716844, "phrase": "java"}, {"score": 0.027670406022567356, "phrase": "program_specialization"}, {"score": 0.00481495049065317, "phrase": "real-time_java_tool_chain"}, {"score": 0.00467905143301368, "phrase": "java_programming_language"}, {"score": 0.0045843245695654875, "phrase": "embedded_systems"}, {"score": 0.00447316895126645, "phrase": "previous_and_current_java_implementations"}, {"score": 0.004206879557938045, "phrase": "significant_class"}, {"score": 0.004138575034269399, "phrase": "embedded_platforms"}, {"score": 0.003908091457759849, "phrase": "java_execution_stack"}, {"score": 0.0037515397894103716, "phrase": "ram"}, {"score": 0.0037207397635410327, "phrase": "flash_memory"}, {"score": 0.0036304470230058413, "phrase": "presented_architecture"}, {"score": 0.003290591812800382, "phrase": "external_dependencies"}, {"score": 0.0032637448078885016, "phrase": "posix-like_libraries"}, {"score": 0.002994701080666466, "phrase": "hardware_objects"}, {"score": 0.002970260970134645, "phrase": "first_level"}, {"score": 0.0027817658627604653, "phrase": "safety-critical_java_profile_level"}, {"score": 0.0027253441561528495, "phrase": "hard_real-time_applications"}, {"score": 0.0024001337476063094, "phrase": "significant_impact"}, {"score": 0.002370794661629904, "phrase": "resulting_program_size"}, {"score": 0.0023131855385489764, "phrase": "presented_solution"}, {"score": 0.002275557501858879, "phrase": "minicdj_benchmark"}, {"score": 0.0021662983565317283, "phrase": "constrained_platforms"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["embedded systems", " Java", " real-time Java", " safety-critical Java", " virtual machine"], "paper_abstract": "The Java programming language was originally developed for embedded systems, but the resource requirements of previous and current Java implementations - especially memory consumption - tend to exclude them from being used on a significant class of resource constrained embedded platforms. The contribution of this paper is an architecture and implementation of a Java execution stack for resource constrained embedded platforms with a few kB of RAM and flash memory. The resource requirements of the presented architecture has been reduced significantly through all the layers of the architecture by integrating the following: (1) a lean virtual machine without any external dependencies on POSIX-like libraries or other OS functionalities; (2) a hardware abstraction layer, implemented almost entirely in Java through the use of hardware objects, first level interrupt handlers, and native variables; and (3) an implementation of the Safety-Critical Java profile Level 0 and 1 for hard real-time applications. All Java components of a given application are minimized through program specialization, and because (2) and (3) are written in Java, the program specialization has a significant impact on the resulting program size. An evaluation of the presented solution shows that the miniCDj benchmark gets reduced to a size where it can run on resource constrained platforms. Copyright (C) 2013 John Wiley & Sons, Ltd.", "paper_title": "A real-time Java tool chain for resource constrained platforms", "paper_id": "WOS:000342806400006"}