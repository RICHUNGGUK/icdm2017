{"auto_keywords": [{"score": 0.04898538732277988, "phrase": "piko"}, {"score": 0.00481495049065317, "phrase": "authoring_programmable_graphics_pipelines"}, {"score": 0.004364446928620496, "phrase": "graphics_pipelines"}, {"score": 0.004314285113050873, "phrase": "multiple_architectures"}, {"score": 0.004264697351852424, "phrase": "piko_programmers"}, {"score": 0.004191377834552202, "phrase": "graphics_pipeline"}, {"score": 0.003978866233891427, "phrase": "spatial_bins"}, {"score": 0.003887894704361635, "phrase": "scheduling_preference"}, {"score": 0.0037336526455789124, "phrase": "pikoc"}, {"score": 0.0035855066449812273, "phrase": "optimized_implementation"}, {"score": 0.003503497128638099, "phrase": "massively-parallel_gpu"}, {"score": 0.003443219062200627, "phrase": "multicore_cpu._piko"}, {"score": 0.0034036089823450385, "phrase": "work_granularity"}, {"score": 0.0033450437338616596, "phrase": "programmable_and_flexible_manner"}, {"score": 0.0032309093154028663, "phrase": "load-balanced_parallel_pipeline_implementations"}, {"score": 0.0031569846310720135, "phrase": "spatial_and_producer-consumer_locality"}, {"score": 0.002795671770303977, "phrase": "wide_range"}, {"score": 0.00268464761487228, "phrase": "reyes"}, {"score": 0.00265373679629359, "phrase": "ray_tracing"}, {"score": 0.0025780134737796085, "phrase": "deferred_rendering"}, {"score": 0.0024756080101497086, "phrase": "efficient_graphics_pipelines"}, {"score": 0.002447101794397243, "phrase": "relative_ease"}, {"score": 0.002377260665147444, "phrase": "design_alternatives"}, {"score": 0.0023228223366301226, "phrase": "spatial_binning_configurations"}, {"score": 0.0022960713730673494, "phrase": "scheduling_preferences"}, {"score": 0.0022696277881969896, "phrase": "individual_stages"}, {"score": 0.0022048406330100697, "phrase": "real-time_performance"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_rendering_systems"}], "paper_keywords": ["graphics pipelines", " parallel computing"], "paper_abstract": "We present Piko, a framework for designing, optimizing, and retargeting implementations of graphics pipelines on multiple architectures. Piko programmers express a graphics pipeline by organizing the computation within each stage into spatial bins and specifying a scheduling preference for these bins. Our compiler, Pikoc, compiles this input into an optimized implementation targeted to a massively-parallel GPU or a multicore CPU. Piko manages work granularity in a programmable and flexible manner, allowing programmers to build load-balanced parallel pipeline implementations, to exploit spatial and producer-consumer locality in a pipeline implementation, and to explore tradeoffs between these considerations. We demonstrate that Piko can implement a wide range of pipelines, including rasterization, Reyes, ray tracing, rasterization/ray tracing hybrid, and deferred rendering. Piko allows us to implement efficient graphics pipelines with relative ease and to quickly explore design alternatives by modifying the spatial binning configurations and scheduling preferences for individual stages, all while delivering real-time performance that is within a factor six of state-of-the-art rendering systems.", "paper_title": "Piko: A Framework for Authoring Programmable Graphics Pipelines", "paper_id": "WOS:000358786600113"}