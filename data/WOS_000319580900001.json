{"auto_keywords": [{"score": 0.0493588904307621, "phrase": "arithmetic_progressions"}, {"score": 0.00481495049065317, "phrase": "formal_languages"}, {"score": 0.004531637625717547, "phrase": "formal_language"}, {"score": 0.004396267325338022, "phrase": "sequence_s_maps_l"}, {"score": 0.002940487679224863, "phrase": "distinct_languages"}, {"score": 0.0028309318332306703, "phrase": "state_complexity"}, {"score": 0.002664097755818129, "phrase": "cfl"}, {"score": 0.0025843206540392184, "phrase": "infinitely_many_distinct_languages"}, {"score": 0.002169968849836984, "phrase": "square_length"}, {"score": 0.0021049977753042253, "phrase": "square_array"}], "paper_keywords": ["filtration", " arithmetic progression", " formal language", " regular language", " finite automaton", " state complexity", " context-free language", " diagonal", " regularity-preserving transformation"], "paper_abstract": "A filtration of a formal language L by a sequence s maps L to the set of words formed by taking the letters of words of L indexed only by s. We consider the languages resulting from filtering by all arithmetic progressions. If L is regular, it is easy to see that only finitely many distinct languages result; we give bounds on the number of distinct languages in terms of the state complexity of L. By contrast, there exist CFL's that give infinitely many distinct languages as a result. We use our technique to show that two related operations, including diag (which extracts the diagonal of words of square length arranged in a square array), preserve regularity but do not preserve context-freeness.", "paper_title": "Filtrations of Formal Languages by Arithmetic Progressions", "paper_id": "WOS:000319580900001"}