{"auto_keywords": [{"score": 0.03825634756854721, "phrase": "forest"}, {"score": 0.006033735575096624, "phrase": "file_systems"}, {"score": 0.00481495049065317, "phrase": "structured_collection"}, {"score": 0.004786620949516712, "phrase": "data_files"}, {"score": 0.004730458558634266, "phrase": "conventional_hierarchical_file_system"}, {"score": 0.004620093797504386, "phrase": "poor-man's_database"}, {"score": 0.004565876339189493, "phrase": "correct_execution"}, {"score": 0.00438105507792004, "phrase": "symbolic_links"}, {"score": 0.004278807087784626, "phrase": "precise_invariants"}, {"score": 0.004154332348800334, "phrase": "acceptable_ownership"}, {"score": 0.004093453936415085, "phrase": "timestamp_attributes"}, {"score": 0.004045391554481355, "phrase": "current_programming_languages"}, {"score": 0.003469426649835834, "phrase": "type-based_metaphor"}, {"score": 0.003428665921276366, "phrase": "expected_structure"}, {"score": 0.0031751093457955686, "phrase": "isomorphic_representation"}, {"score": 0.0029229166303837545, "phrase": "disk_conform"}, {"score": 0.0028715299874549245, "phrase": "error_detection"}, {"score": 0.0027878797103973313, "phrase": "rigorous_discipline"}, {"score": 0.0027714435547214183, "phrase": "typed_programming_languages"}, {"score": 0.0027469703311742647, "phrase": "untyped_world"}, {"score": 0.00266693888510356, "phrase": "embedded_domain-specific_language"}, {"score": 0.0026512243720630364, "phrase": "haskell"}, {"score": 0.0025212306068464452, "phrase": "type_class_instances"}, {"score": 0.0024695739265437823, "phrase": "generic_tools"}, {"score": 0.0024405312482831646, "phrase": "arbitrary_filestores"}, {"score": 0.0023554316787703137, "phrase": "file_system_visualizer"}, {"score": 0.0023346234464901978, "phrase": "file_access_checker"}, {"score": 0.0023139986108451967, "phrase": "generic_query_interface"}, {"score": 0.0023003498123420237, "phrase": "description-directed_variants"}, {"score": 0.002246553137021003, "phrase": "simple_forest_description_inference_engine"}, {"score": 0.0022005118194652704, "phrase": "core_fragment"}, {"score": 0.0021490449563443025, "phrase": "classical_tree_logics"}, {"score": 0.002130056082139311, "phrase": "round-tripping_laws"}, {"score": 0.0021049977753042253, "phrase": "loading_and_storing_functions"}], "paper_keywords": ["Languages", " Design", " Theory", " Data description languages", " file systems", " filestores", " domain-specific languages", " ad hoc data", " Haskell", " bidirectional transformations", " generic programming"], "paper_abstract": "A filestore is a structured collection of data files housed in a conventional hierarchical file system. Many applications use filestores as a poor-man's database, and the correct execution of these applications requires that the collection of files, directories, and symbolic links stored on disk satisfy a variety of precise invariants. Moreover, all of these structures must have acceptable ownership, permission, and timestamp attributes. Unfortunately, current programming languages do not provide support for documenting assumptions about filestores, detecting errors in them, or safely loading from and storing to them. This paper describes the design, implementation, and semantics of Forest, a new domain-specific language for describing filestores. The language uses a type-based metaphor to specify the expected structure, attributes, and invariants of filestores. Forest generates loading and storing functions that make it easy to connect data on disk to an isomorphic representation in memory that can be manipulated as if it were any other data structure. Forest also generates metadata that describes the degree to which the structures on the disk conform to the specification, making error detection easy. In a nutshell, Forest extends the rigorous discipline of typed programming languages to the untyped world of file systems. We have implemented Forest as an embedded domain-specific language in Haskell. In addition to generating infrastructure for reading, writing and checking file systems, our implementation generates type class instances that make it easy to build generic tools that operate over arbitrary filestores. We illustrate the utility of this infrastructure by building a file system visualizer, a file access checker, a generic query interface, description-directed variants of several standard UNIX shell tools and (circularly) a simple Forest description inference engine. Finally, we formalize a core fragment of Forest in a semantics inspired by classical tree logics and prove round-tripping laws showing that the loading and storing functions behave sensibly.", "paper_title": "Forest: A Language and Toolkit for Programming with Filestores", "paper_id": "WOS:000297632700028"}