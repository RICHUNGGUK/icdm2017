{"auto_keywords": [{"score": 0.04901879531534824, "phrase": "class_declarations"}, {"score": 0.035645265997705546, "phrase": "class_diagram"}, {"score": 0.015719716506582538, "phrase": "object-oriented_refinement"}, {"score": 0.015604074310845338, "phrase": "object-oriented_program"}, {"score": 0.015112558962221922, "phrase": "class_declaration_section"}, {"score": 0.014244876200403425, "phrase": "main_method"}, {"score": 0.012133992161670833, "phrase": "different_class_declaration_sections"}, {"score": 0.009569354579479397, "phrase": "structure_refinement"}, {"score": 0.008226793754584792, "phrase": "refinement_rules"}, {"score": 0.007561379753576368, "phrase": "normal_forms"}, {"score": 0.0041469500929423595, "phrase": "general_properties"}, {"score": 0.004014852730692438, "phrase": "application_task"}, {"score": 0.003906357144047631, "phrase": "different_main_methods"}, {"score": 0.003858011243099882, "phrase": "different_applications"}, {"score": 0.0038007823050962863, "phrase": "important_feature"}, {"score": 0.0037631002998184076, "phrase": "object-oriented_programming"}, {"score": 0.0036070601923916196, "phrase": "significant_difference"}, {"score": 0.0034747411008482637, "phrase": "uml-like_modeling_language"}, {"score": 0.0032893741115496496, "phrase": "object_diagrams"}, {"score": 0.0032486392192981944, "phrase": "state_space"}, {"score": 0.003113864994069992, "phrase": "labeled_graphs"}, {"score": 0.0030600032877646263, "phrase": "class_structure"}, {"score": 0.0027557911038816256, "phrase": "resulting_class_graph"}, {"score": 0.0026480044868438875, "phrase": "original_graph"}, {"score": 0.0025507767173300624, "phrase": "classical_theory"}, {"score": 0.00253808496152038, "phrase": "data_refinement"}, {"score": 0.0024387926103125158, "phrase": "object-oriented_software_design"}, {"score": 0.0022856406631396537, "phrase": "object-oriented_programs"}, {"score": 0.002268598551466928, "phrase": "completeness_results"}, {"score": 0.002234893735225432, "phrase": "simple_refinement_rules"}, {"score": 0.0021049977753042253, "phrase": "object-oriented_computation"}], "paper_keywords": ["Class graph", " Object graph", " Graph transformation", " Normal form", " Object-orientation", " Structure refinement"], "paper_abstract": "An object-oriented program consists of a section of class declarations and a main method. The class declaration section represents the structure of an object-oriented program, that is the data, the classes and relations among them. The execution of the main method realizes the application by invoking methods of objects of the classes defined in the class declarations. Class declarations define the general properties of objects and how they collaborate with each other in realizing the application task programmed as the main method. Note that for one class declaration section, different main methods can be programmed for different applications, and this is an important feature of reuse in object-oriented programming. On the other hand, different class declaration sections may support the same applications, but these different class declaration sections can make significant difference with regards to understanding, reuse and maintainability of the applications. With a UML-like modeling language, the class declaration section of a program is represented as a class diagram, and the instances of the class diagram are represented by object diagrams, that form the state space of the program. In this paper, we define a class diagram and its object diagrams as directed labeled graphs, and investigate what changes in the class structure maintain the capability of providing functionalities (or services). We formalize such a structure change by the notion of structure refinement. A structure refinement is a transformation from one graph to another that preserves the capability of providing services, that is, the resulting class graph should be able to provide at least as many, and as good, services (in terms of functional refinement) as the original graph. We then develop a calculus of object-oriented refinement, as an extension to the classical theory of data refinement, in which the refinement rules are classified into four categories according to their natures and uses in object-oriented software design. The soundness of the calculus is proved and the completeness of the refinement rules of each category is established with regard to normal forms defined for object-oriented programs. These completeness results show the power of the simple refinement rules. The normal forms and the completeness results together capture the essence of polymorphism, dynamic method binding and object sharing by references in object-oriented computation.", "paper_title": "Graph transformations for object-oriented refinement", "paper_id": "WOS:000263058800005"}