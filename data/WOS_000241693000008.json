{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "modular_exponentiation"}, {"score": 0.004720043307726269, "phrase": "fault_attacks"}, {"score": 0.0045357787854931894, "phrase": "efficient_methodology"}, {"score": 0.004272724011826495, "phrase": "embedded_devices"}, {"score": 0.0041469500929423595, "phrase": "proper_countermeasures"}, {"score": 0.00367967106192446, "phrase": "simple_method"}, {"score": 0.0035712919163869176, "phrase": "transient_fault_attacks"}, {"score": 0.0032975819773787985, "phrase": "secret_exponent"}, {"score": 0.0031686717525002935, "phrase": "considered_scenario"}, {"score": 0.0028394925080958205, "phrase": "secret_information"}, {"score": 0.0021049977753042253, "phrase": "exponentiation_algorithm"}], "paper_keywords": ["fault attacks", " safe errors", " countermeasures", " RSA", " embedded devices", " smartcards"], "paper_abstract": "Fault attacks have become an efficient methodology for extracting secrets stored in embedded devices, and proper countermeasures against such attacks are nowadays considered necessary. This paper describes a simple method for foiling transient fault attacks on devices that perform modular exponentiation with a secret exponent. In the considered scenario, acknowledging an error only at the end of the computations leaks out secret information, and should be avoided. To tackle this difficulty, we propose a scheme that checks, independently, each step (i.e., multiplication/squaring) of the exponentiation algorithm, and aborts the procedure as soon as an error is detected, without completing the computation.", "paper_title": "Data and computational fault detection mechanism for devices that perform modular exponentiation", "paper_id": "WOS:000241693000008"}