{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "compile-time_obfuscation"}, {"score": 0.04841960597199349, "phrase": "semantic-aware_malware_detection"}, {"score": 0.03234718088978204, "phrase": "side_effects"}, {"score": 0.0043533862892678864, "phrase": "syntactic_analysis"}, {"score": 0.004160319763461951, "phrase": "pregenerated_signatures"}, {"score": 0.004118587636081584, "phrase": "malware_samples"}, {"score": 0.003916098498242888, "phrase": "malware_sample"}, {"score": 0.0036491673002304326, "phrase": "specific_syntactic_implementation"}, {"score": 0.003487222504700868, "phrase": "underlying_machine"}, {"score": 0.003105168935158648, "phrase": "hidden_functionality"}, {"score": 0.0027788478707700274, "phrase": "comprehensive_analysis"}, {"score": 0.0026554236621262515, "phrase": "implementation_concept"}, {"score": 0.0025374674652885354, "phrase": "obfuscating_transformations"}, {"score": 0.0024493494346360415, "phrase": "compile_time"}, {"score": 0.0023170054862555896, "phrase": "prototype_implementation"}, {"score": 0.0021917966722180132, "phrase": "space_overhead"}, {"score": 0.0021697677572213086, "phrase": "actual_malware_samples"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Code obfuscation", " Side effect", " Code steganography", " Semantic-aware malware detection", " Compile-time obfuscation"], "paper_abstract": "Recently, the concept of semantic-aware malware detection has been proposed in the literature. Instead of relying on a syntactic analysis (i.e., comparison of a program to pregenerated signatures of malware samples), semantic-aware malware detection tries to model the effects a malware sample has on the machine. Thus, it does not depend on a specific syntactic implementation. For this purpose a model of the underlying machine is used. While it is possible to construct more and more precise models of hardware architectures, we show that there are ways to implement hidden functionality based on side effects in the microprocessor that are difficult to cover With a model. In this paper we give a comprehensive analysis of side effects in the x86 architecture and describe an implementation concept based on the idea of compile-time obfuscation, where obfuscating transformations are applied to the code at compile time. Finally, we provide an evaluation based on a prototype implementation to show the practicability of our approach and estimate complexity and space overhead using actual malware samples. (C) 2014 Elsevier Ltd. All rights reserved.", "paper_title": "Covert Computation Hiding code in code through compile-time obfuscation", "paper_id": "WOS:000335201000003"}