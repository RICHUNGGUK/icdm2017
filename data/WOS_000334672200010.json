{"auto_keywords": [{"score": 0.034963454087717186, "phrase": "qemu"}, {"score": 0.010440050437219952, "phrase": "dbt"}, {"score": 0.00604059528479096, "phrase": "hqemu"}, {"score": 0.005339339265136376, "phrase": "atomic_instructions"}, {"score": 0.00481495049065317, "phrase": "retargetable_dynamic_binary_translation"}, {"score": 0.004762377182821785, "phrase": "dynamic_binary_translation"}, {"score": 0.00468458651904683, "phrase": "core_technology"}, {"score": 0.004620727987405077, "phrase": "system_virtualization"}, {"score": 0.004595427853257205, "phrase": "dynamic_binary_instrumentation"}, {"score": 0.004083627932957977, "phrase": "guest_applications"}, {"score": 0.004061256614370055, "phrase": "different_instruction-set_architectures"}, {"score": 0.0039620866640334386, "phrase": "different_isas"}, {"score": 0.0037709251039071737, "phrase": "ubiquitous_multicore_platforms"}, {"score": 0.0037194747200740568, "phrase": "multithreaded_approach"}, {"score": 0.003688940992528033, "phrase": "dbt."}, {"score": 0.003618662721828278, "phrase": "dynamic_binary_optimizer"}, {"score": 0.0035988294152570154, "phrase": "different_cores"}, {"score": 0.0035791044213663884, "phrase": "different_threads"}, {"score": 0.0034440132840107677, "phrase": "target_applications"}, {"score": 0.003085398612129509, "phrase": "multithreaded_dbt_prototype"}, {"score": 0.0030600539712413804, "phrase": "hybrid-qemu"}, {"score": 0.0029852586450968537, "phrase": "qemu_performance"}, {"score": 0.002833289844823831, "phrase": "dynamic_translation"}, {"score": 0.002764021830539386, "phrase": "arm_codes"}, {"score": 0.002608893678760607, "phrase": "performance_scalability_issue"}, {"score": 0.0025945803418588233, "phrase": "multithreaded_applications"}, {"score": 0.002538105991854732, "phrase": "performance_scalability"}, {"score": 0.002496556366049961, "phrase": "coarse-grained_locks"}, {"score": 0.002469234247793194, "phrase": "shared_data_structures"}, {"score": 0.0023178219772486868, "phrase": "indirect_branch_translation"}, {"score": 0.002273605493468005, "phrase": "frequent_accesses"}, {"score": 0.002224101991430931, "phrase": "lightweight_memory_transactions"}, {"score": 0.0021577859945449704, "phrase": "multithread_applications"}, {"score": 0.0021049977753042253, "phrase": "parsec_benchmarks"}], "paper_keywords": ["Dynamic binary translation", " multicores", " feedback-directed optimization", " hardware performance monitoring", " traces"], "paper_abstract": "Dynamic binary translation (DBT) is a core technology to many important applications such as system virtualization, dynamic binary instrumentation, and security. However, there are several factors that often impede its performance: 1) emulation overhead before translation; 2) translation and optimization overhead; and 3) translated code quality. The issues also include its retargetability that supports guest applications from different instruction-set architectures (ISAs) to host machines also with different ISAs-an important feature to system virtualization. In this work, we take advantage of the ubiquitous multicore platforms, and use a multithreaded approach to implement DBT. By running the translator and the dynamic binary optimizer on different cores with different threads, it could off-load the overhead incurred by DBT on the target applications; thus, afford DBT of more sophisticated optimization techniques as well as its retargetability. Using QEMU (a popular retargetable DBT for system virtualization) and Low-Level Virtual Machine (LLVM) as our building blocks, we demonstrated in a multithreaded DBT prototype, called Hybrid-QEMU (HQEMU), that it could improve QEMU performance by a factor of 2.6x and 4.1x on the SPEC CPU2006 integer and floating point benchmarks, respectively, for dynamic translation of x86 code to run on x86-64 platforms. For ARM codes to x86-64 platforms, HQEMU can gain a factor of 2.5x speedup over QEMU for the SPEC CPU2006 integer benchmarks. We also address the performance scalability issue of multithreaded applications across ISAs. We identify two major impediments to performance scalability in QEMU: 1) coarse-grained locks used to protect shared data structures, and 2) inefficient emulation of atomic instructions across ISAs. We proposed two techniques to mitigate those problems: 1) using indirect branch translation caching (IBTC) to avoid frequent accesses to locks, and 2) using lightweight memory transactions to emulate atomic instructions across ISAs. Our experimental results show that for multithread applications, HQEMU achieves 25x speedups over QEMU for the PARSEC benchmarks.", "paper_title": "Efficient and Retargetable Dynamic Binary Translation on Multicores", "paper_id": "WOS:000334672200010"}