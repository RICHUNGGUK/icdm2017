{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "hoare"}, {"score": 0.0047555023078686386, "phrase": "behavioral_type"}, {"score": 0.004413846562278824, "phrase": "communication_protocols"}, {"score": 0.004359328949187473, "phrase": "dynamic_security_policies"}, {"score": 0.004252296935371162, "phrase": "race_conditions"}, {"score": 0.0039221899471111, "phrase": "specific_syntax"}, {"score": 0.0037087324991876727, "phrase": "ad_hoc_solver"}, {"score": 0.003506851152129303, "phrase": "first-order_logic_formulas"}, {"score": 0.003399466007862412, "phrase": "behavioral_type_systems"}, {"score": 0.003336614511719501, "phrase": "general_purpose"}, {"score": 0.0032143649757754595, "phrase": "effective_means"}, {"score": 0.0031746155143471725, "phrase": "checking_programs"}, {"score": 0.0029462012558267863, "phrase": "security-related_type_systems"}, {"score": 0.0028917056916949744, "phrase": "role-based_access_control"}, {"score": 0.0027512482368183596, "phrase": "history-based_access_control"}, {"score": 0.0026013505538490223, "phrase": "refined_state_monad"}, {"score": 0.002521623057264411, "phrase": "precise_comparison"}, {"score": 0.0022825131641434964, "phrase": "behavioral_type-checking"}, {"score": 0.0021715812867126884, "phrase": "unexpected_security_exceptions"}, {"score": 0.002131383155056741, "phrase": "common_problem"}, {"score": 0.0021049977753042253, "phrase": "code-based_access_control"}], "paper_keywords": [""], "paper_abstract": "Behavioral type and effect systems regulate properties such as adherence to object and communication protocols, dynamic security policies, avoidance of race conditions, and many others. Typically, each system is based on some specific syntax of constraints, and is checked with an ad hoc solver. Instead, we advocate types refined with first-order logic formulas as a basis for behavioral type systems, and general purpose automated theorem provers as an effective means of checking programs. To illustrate this approach, we define a triple of security-related type systems: for role-based access control, for stack inspection, and for history-based access control. The three are all instances of a refined state monad. Our semantics allows a precise comparison of the similarities and differences of these mechanisms. In our examples, the benefit of behavioral type-checking is to rule out the possibility of unexpected security exceptions, a common problem with code-based access control.", "paper_title": "Roles, stacks, histories: A triple for Hoare", "paper_id": "WOS:000289378800004"}