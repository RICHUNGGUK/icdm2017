{"auto_keywords": [{"score": 0.034484896568124125, "phrase": "data_structure"}, {"score": 0.00481495049065317, "phrase": "monotonic_interval_scheduling_problem"}, {"score": 0.004676173016967478, "phrase": "dynamic_algorithms"}, {"score": 0.004574709094672837, "phrase": "interval_scheduling_problem"}, {"score": 0.0035671997165370403, "phrase": "efficient_insertion"}, {"score": 0.0033890026927890058, "phrase": "first_dynamic_algorithm"}, {"score": 0.0027405092973494293, "phrase": "second_dynamic_algorithm"}, {"score": 0.0021996478802839316, "phrase": "theoretical_and_experimental_results"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Interval scheduling", " Dynamic algorithms", " Data structures"], "paper_abstract": "We investigate dynamic algorithms for the interval scheduling problem. We focus on the case when the set of intervals is monotonic. This is when no interval properly contains another interval. We provide two data structures for representing the intervals that allow efficient insertion, removal and various query operations. The first dynamic algorithm, based on the data structure called compatibility forest, runs in amortised time O (log(2) n) for insertion and removal and O (logn) for query. The second dynamic algorithm, based on the data structure called linearised tree, runs in time O (logn) for insertion, removal and query. We discuss differences and similarities of these two data structures through theoretical and experimental results. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Dynamic algorithms for monotonic interval scheduling problem", "paper_id": "WOS:000347602000017"}