{"auto_keywords": [{"score": 0.04776799319469095, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "real-time_garbage_collection"}, {"score": 0.004680851157467745, "phrase": "managed_languages"}, {"score": 0.004330941610682453, "phrase": "hard_real-time_applications"}, {"score": 0.004035500442527029, "phrase": "garbage_collection"}, {"score": 0.003923023699005215, "phrase": "key_enabler"}, {"score": 0.003578600071301459, "phrase": "real-time_execution_environments"}, {"score": 0.0034299649219748513, "phrase": "leading_approaches"}, {"score": 0.0033817999428800457, "phrase": "hard_real-time_garbage_collection"}, {"score": 0.0031732652552570644, "phrase": "real-time_garbage_collection_algorithm"}, {"score": 0.00310664242361199, "phrase": "time-based_garbage_collectors"}, {"score": 0.0027741761880779535, "phrase": "experimental_comparison"}, {"score": 0.002677744558540711, "phrase": "commercial_implementations"}, {"score": 0.002640114583897493, "phrase": "completely_different_proprietary_infrastructures"}, {"score": 0.0025664295665392203, "phrase": "minuteman"}, {"score": 0.0024423826953133844, "phrase": "real-time_collection_algorithms"}, {"score": 0.0023408288327263294, "phrase": "high-performance_execution_environment"}, {"score": 0.0023079225317714793, "phrase": "real-time_java"}, {"score": 0.0022276618873985445, "phrase": "first_comparison"}, {"score": 0.0021049977753042253, "phrase": "realistic_workloads"}], "paper_keywords": ["Design", " Reliability", " Joint scheduling", " real-time garbage collection"], "paper_abstract": "Managed languages such as Java and C# are increasingly being considered for hard real-time applications because of their productivity and software engineering advantages. Automatic memory management, or garbage collection, is a key enabler for robust, reusable libraries, yet remains a challenge for analysis and implementation of real-time execution environments. This article comprehensively compares leading approaches to hard real-time garbage collection. There are many design decisions involved in selecting a real-time garbage collection algorithm. For time-based garbage collectors on uniprocessors one must choose whether to use periodic, slack-based or hybrid scheduling. A significant impediment to valid experimental comparison of such choices is that commercial implementations use completely different proprietary infrastructures. We present Minuteman, a framework for experimenting with real-time collection algorithms in the context of a high-performance execution environment for real-time Java. We provide the first comparison of the approaches, both experimentally using realistic workloads, and analytically in terms of schedulability.", "paper_title": "Scheduling Real-Time Garbage Collection on Uniprocessors", "paper_id": "WOS:000295732300002"}