{"auto_keywords": [{"score": 0.046827692927246076, "phrase": "hls"}, {"score": 0.014981629141233996, "phrase": "high-level_synthesis"}, {"score": 0.00481495049065317, "phrase": "polyhedral_bubble"}, {"score": 0.004636340567075841, "phrase": "nested_loop_pipelining"}, {"score": 0.00427550604912774, "phrase": "behavioral_description"}, {"score": 0.004116823963855969, "phrase": "design_process"}, {"score": 0.004072573194988867, "phrase": "loop_pipelining"}, {"score": 0.004007083686875716, "phrase": "key_transformation"}, {"score": 0.0036553070575015344, "phrase": "small_hardware_overhead"}, {"score": 0.00355782527287734, "phrase": "small_loops"}, {"score": 0.00342568771304873, "phrase": "poor_hardware_utilization"}, {"score": 0.003352388337911934, "phrase": "pipeline_latency_overhead"}, {"score": 0.0032278559855285945, "phrase": "whole_loop_nest"}, {"score": 0.003124790943886441, "phrase": "innermost_loop"}, {"score": 0.0029602552900111407, "phrase": "currently_available_techniques"}, {"score": 0.0028968858148006823, "phrase": "perfectly_nested_loops"}, {"score": 0.002865710140187219, "phrase": "constant_bounds"}, {"score": 0.0028195727965553367, "phrase": "uniform_dependences"}, {"score": 0.0027443174539994925, "phrase": "polyhedral_model"}, {"score": 0.0026280534600940137, "phrase": "nested_loop"}, {"score": 0.0025440911575156755, "phrase": "new_legality_check"}, {"score": 0.0025031188149336257, "phrase": "new_loop_correction_technique"}, {"score": 0.002333044307949414, "phrase": "source-to-source_compiler"}, {"score": 0.002246292543825748, "phrase": "benchmark_kernels"}, {"score": 0.0022101055924375725, "phrase": "polyhedral_bubble_insertion"}, {"score": 0.0021049977753042253, "phrase": "loop_nests"}], "paper_keywords": ["High-level synthesis (HLS)", " loop coalescing", " nested loop pipelining", " polyhedral model", " source-to-source transformations"], "paper_abstract": "High-level synthesis (HLS) allows hardware to be directly produced from behavioral description in C/C++, thus accelerating the design process. Loop pipelining is a key transformation of HLS, as it improves the throughput of the design at the price of a small hardware overhead. However, for small loops, its use often results in a poor hardware utilization due to the pipeline latency overhead. Overlapping the iterations of the whole loop nest instead of only overlapping the innermost loop is a way to overcome this difficulty, but currently available techniques are restricted to perfectly nested loops with constant bounds, involving uniform dependences only. Using the polyhedral model, we extend the applicability of the nested loop pipelining transformation by proposing a new legality check and a new loop correction technique, called polyhedral bubble insertion. This method was implemented in a source-to-source compiler targeting HLS, and results on benchmark kernels show that polyhedral bubble insertion is effective in practice on a much larger class of loop nests.", "paper_title": "Polyhedral Bubble Insertion: A Method to Improve Nested Loop Pipelining for High-Level Synthesis", "paper_id": "WOS:000315481000002"}