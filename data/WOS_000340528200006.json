{"auto_keywords": [{"score": 0.049584128839210984, "phrase": "value_propagation"}, {"score": 0.00481495049065317, "phrase": "code_motion_techniques"}, {"score": 0.004691465925553365, "phrase": "equivalence_checking_method"}, {"score": 0.0046429592670444945, "phrase": "finite_state_machines"}, {"score": 0.004477083974172596, "phrase": "model_paths"}, {"score": 0.004317109072311102, "phrase": "code_motion_transformations"}, {"score": 0.004206338218873218, "phrase": "scheduling_phase"}, {"score": 0.004162826481635768, "phrase": "high-level_synthesis"}, {"score": 0.003931402465972151, "phrase": "code_motions"}, {"score": 0.0038907236419588255, "phrase": "loop_bodies"}, {"score": 0.0037516215763875225, "phrase": "variable_values"}, {"score": 0.0036363418376496484, "phrase": "subsequent_paths"}, {"score": 0.0034519997658752598, "phrase": "live_variable"}, {"score": 0.00331125524068286, "phrase": "final_path_segments"}, {"score": 0.003143341238802547, "phrase": "loop_invariance"}, {"score": 0.0029072537537959374, "phrase": "important_role"}, {"score": 0.002847339938387273, "phrase": "uniform_and_nonuniform_code_motions"}, {"score": 0.0027311809666295565, "phrase": "control_structure_modifications"}, {"score": 0.0026609940110902666, "phrase": "complexity_analysis"}, {"score": 0.002633425544817301, "phrase": "identical_worst_case_performance"}, {"score": 0.0025657442830956017, "phrase": "related_earlier_method"}, {"score": 0.00253916011199984, "phrase": "path_extension"}, {"score": 0.002473895542219933, "phrase": "code_motion"}, {"score": 0.0022642601698943687, "phrase": "basic_block-based_scheduler"}, {"score": 0.0021493248730171132, "phrase": "high-level_synthesis_tool"}, {"score": 0.0021049977753042253, "phrase": "benchmark_examples"}], "paper_keywords": ["Code motion validation", " equivalence checking", " finite state machines with datapath", " value propagation"], "paper_abstract": "An equivalence checking method of finite state machines with datapath based on value propagation over model paths is presented here for validation of code motion transformations commonly applied during the scheduling phase of high-level synthesis. Unlike many other reported techniques, the method is able to handle code motions across loop bodies. It consists in propagating the variable values over a path to the subsequent paths on discovery of mismatch in the values for some live variable, until the values match or the final path segments are accounted for without finding a match. Checking loop invariance of the values being propagated beyond the loops has been identified to play an important role. Along with uniform and nonuniform code motions, the method is capable of handling control structure modifications as well. The complexity analysis depicts identical worst case performance as that of a related earlier method of path extension which fails to handle code motion across loops. The method has been implemented and satisfactorily tested on the outputs of a basic block-based scheduler, a path-based scheduler, and the high-level synthesis tool SPARK for some benchmark examples.", "paper_title": "Verification of Code Motion Techniques Using Value Propagation", "paper_id": "WOS:000340528200006"}