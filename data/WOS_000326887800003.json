{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "lambda_terms"}, {"score": 0.00799431488606247, "phrase": "bound_variables"}, {"score": 0.00478557489890886, "phrase": "lambda_calculus"}, {"score": 0.004712913906047687, "phrase": "functional_programming"}, {"score": 0.004684157900507474, "phrase": "higher_order_proof_assistants"}, {"score": 0.00457086975394978, "phrase": "combinatorial_properties"}, {"score": 0.00443308765153716, "phrase": "random_generation"}, {"score": 0.004169806294929081, "phrase": "'typical'_structure"}, {"score": 0.0041316803676012155, "phrase": "simply_typable_term"}, {"score": 0.0037231102027070724, "phrase": "aforementioned_problems"}, {"score": 0.003417054482155433, "phrase": "complex_analysis"}, {"score": 0.003213920601037463, "phrase": "de_bruijn_indices"}, {"score": 0.003088384809415812, "phrase": "nameless_dummies"}, {"score": 0.0030414140732789186, "phrase": "automatic_formula_manipulation"}, {"score": 0.002782694908561637, "phrase": "closed_lambda_terms"}, {"score": 0.002673957615079041, "phrase": "interesting_combinatorial_interpretations"}, {"score": 0.0026171728120512037, "phrase": "counting_formulas"}, {"score": 0.002538131851615231, "phrase": "performed_tests"}, {"score": 0.0025071862539276283, "phrase": "experimental_data"}, {"score": 0.0024766170166319735, "phrase": "average_depth"}, {"score": 0.0024389277933858054, "phrase": "average_number"}, {"score": 0.002424012799998538, "phrase": "head_lambdas"}, {"score": 0.0023871221933990192, "phrase": "random_generators"}, {"score": 0.0022382002476510573, "phrase": "simply_typable_terms"}, {"score": 0.002157302200451323, "phrase": "simply_typable_lambda_terms"}, {"score": 0.0021049977753042253, "phrase": "typable_term"}], "paper_keywords": [""], "paper_abstract": "Lambda calculus is the basis of functional programming and higher order proof assistants. However, little is known about combinatorial properties of lambda terms, in particular, about their asymptotic distribution and random generation. This paper tries to answer questions like: How many terms of a given size are there? What is a 'typical' structure of a simply typable term? Despite their ostensible simplicity, these questions still remain unanswered, whereas solutions to such problems are essential for testing compilers and optimizing programs whose expected efficiency depends on the size of terms. Our approach toward the aforementioned problems may be later extended to any language with bound variables, i.e., with scopes and declarations. This paper presents two complementary approaches: one, theoretical, uses complex analysis and generating functions, the other, experimental, is based on a generator of lambda terms. Thanks to de Bruijn indices (de Bruijn, N. (1972) Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem. Indagat. Math. 34(5), 381-392), we provide three families of formulas for the number of closed lambda terms of a given size and we give four relations between these numbers which have interesting combinatorial interpretations. As a by-product of the counting formulas, we design an algorithm for generating lambda-terms. Performed tests provide us with experimental data, like the average depth of bound variables and the average number of head lambdas. We also create random generators for various sorts of terms. Thereafter, we conduct experiments that answer questions like: What is the ratio of simply typable terms among all terms? (Very small!) How are simply typable lambda terms distributed among all lambda terms? (A typable term almost always starts with an abstraction.) In this paper, abstractions and applications have size 1 and variables have size 0.", "paper_title": "Counting and generating lambda terms", "paper_id": "WOS:000326887800003"}