{"auto_keywords": [{"score": 0.04854250213020111, "phrase": "haskell"}, {"score": 0.047542352621877774, "phrase": "generative_type_abstractions"}, {"score": 0.00481495049065317, "phrase": "safe_zero-cost"}, {"score": 0.004762898856480975, "phrase": "coercions"}, {"score": 0.004272177493767496, "phrase": "ocaml"}, {"score": 0.004002242925856335, "phrase": "useful_concepts"}, {"score": 0.003831801113154043, "phrase": "programmer_errors"}, {"score": 0.003589602322126282, "phrase": "new_types"}, {"score": 0.003219368413618912, "phrase": "run-time_representation"}, {"score": 0.003115908199991072, "phrase": "base_type"}, {"score": 0.00295078850927459, "phrase": "new_mechanism"}, {"score": 0.0028249975318149468, "phrase": "zero-cost_conversions"}, {"score": 0.0023990982005125763, "phrase": "type_safety"}, {"score": 0.0021049977753042253, "phrase": "ghc."}], "paper_keywords": ["Haskell", " Coercion", " Type class", " Newtype deriving"], "paper_abstract": "Generative type abstractions - present in Haskell, OCaml, and other languages - are useful concepts to help prevent programmer errors. They serve to create new types that are distinct at compile time but share a run-time representation with some base type. We present a new mechanism that allows for zero-cost conversions between generative type abstractions and their representations, even when such types are deeply nested. We prove type safety in the presence of these conversions and have implemented our work in GHC.", "paper_title": "Safe Zero-cost Coercions for Haskell", "paper_id": "WOS:000349143000017"}