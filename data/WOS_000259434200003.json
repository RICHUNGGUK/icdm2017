{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "spanning_tree"}, {"score": 0.01095714826137374, "phrase": "dynamic_networks"}, {"score": 0.004546970518808189, "phrase": "significant_improvements"}, {"score": 0.004491506786670695, "phrase": "communication_complexity"}, {"score": 0.0044549056501745074, "phrase": "dynamic_network_protocols"}, {"score": 0.004364696693320128, "phrase": "communication_optimal_maintenance"}, {"score": 0.004258843584164121, "phrase": "dynamic_network"}, {"score": 0.004104838067758352, "phrase": "topological_changes"}, {"score": 0.0040713749949601915, "phrase": "message_complexity"}, {"score": 0.003797690272118125, "phrase": "message_size"}, {"score": 0.00357146811369898, "phrase": "name_space"}, {"score": 0.003250403288147613, "phrase": "topological_change"}, {"score": 0.0031845067058084583, "phrase": "re-_computation"}, {"score": 0.0030944828434567966, "phrase": "spanning_trees"}, {"score": 0.003069230909006614, "phrase": "essential_components"}, {"score": 0.002898127432512101, "phrase": "network_nodes"}, {"score": 0.0027817658627604653, "phrase": "static_algorithms"}, {"score": 0.0024298350266697905, "phrase": "novel_technique"}, {"score": 0.002266246304762945, "phrase": "present_information"}, {"score": 0.0021662983565317283, "phrase": "node's_neighbor"}], "paper_keywords": ["algorithms", " performance", " distributed algorithms", " spanning tree", " dynamic networks", " amortized complexity", " topological changes", " leader election", " optimal message complexity"], "paper_abstract": "In this article, we show that keeping track of history enables significant improvements in the communication complexity of dynamic network protocols. We present a communication optimal maintenance of a spanning tree in a dynamic network. The amortized ( on the number of topological changes) message complexity is O(V), where V is the number of nodes in the network. The message size used by the algorithm is O(log |ID|) where |ID| is the size of the name space of the nodes. Typically, log |ID| = O( log V). Previous algorithms that adapt to dynamic networks involved Omega( E) messages per topological change - inherently paying for re- computation of the tree from scratch. Spanning trees are essential components in many distributed algorithms. Some examples include broadcast ( dissemination of messages to all network nodes), multicast, reset ( general adaptation of static algorithms to dynamic networks), routing, termination detection, and more. Thus, our efficient maintenance of a spanning tree implies the improvement of algorithms for these tasks. Our results are obtained using a novel technique to save communication. A node uses information received in the past in order to deduce present information from the fact that certain messages were NOT sent by the node's neighbor. This technique is one of our main contributions.", "paper_title": "Optimal maintenance of a spanning tree", "paper_id": "WOS:000259434200003"}