{"auto_keywords": [{"score": 0.046448599314105624, "phrase": "real-time_collector"}, {"score": 0.00481495049065317, "phrase": "real-time_garbage_collector"}, {"score": 0.0047214222691129544, "phrase": "java"}, {"score": 0.004647442352794694, "phrase": "viable_platform"}, {"score": 0.004611013257082199, "phrase": "real-time_applications"}, {"score": 0.004556901872357751, "phrase": "new_challenges"}, {"score": 0.004503422625191897, "phrase": "garbage_collector"}, {"score": 0.003405109584265324, "phrase": "alternative_solution"}, {"score": 0.0033518704336033874, "phrase": "object_replication"}, {"score": 0.003260690513595527, "phrase": "special_handling"}, {"score": 0.002943147037670826, "phrase": "total_overhead"}, {"score": 0.002851790448644913, "phrase": "research_real-time_java_vm"}, {"score": 0.0028293966058473476, "phrase": "dacapo"}, {"score": 0.0027742013730924463, "phrase": "spec"}, {"score": 0.0026986685585382347, "phrase": "average_speed-up"}, {"score": 0.002594342451017822, "phrase": "existing_technique"}, {"score": 0.002573965014439041, "phrase": "parallel_systems"}, {"score": 0.002474447780553576, "phrase": "embedded_systems"}, {"score": 0.00241658945942583, "phrase": "simpler_and_more_predictable_mutator_barriers"}, {"score": 0.0023415390666563177, "phrase": "green_threading"}, {"score": 0.0022157533515146503, "phrase": "natural_behavior"}, {"score": 0.002181069180139225, "phrase": "unprotected_access"}, {"score": 0.002163930783583212, "phrase": "shared_variables"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["real-time garbage collection", " replication", " java"], "paper_abstract": "Real-time Java is becoming a viable platform for real-time applications, bringing new challenges to a garbage collector. A real-time collector has to be incremental as not to cause deadline misses by suspending an application for too long. In particular, if a real-time collector has to relocate objects in the heap, it must do so incrementally and transparently to the application. This is usually achieved via an indirection that has to be followed on every read and write to the heap. We present an alternative solution, based on object replication, which does not need any special handling for memory reads, but writes are more expensive: every value is written twice. As writes are less frequent than reads, the total overhead is reduced. With our implementation in a research real-time Java VM and DaCapo, pseudo-jbb, and SPEC JVM 98 benchmarks, we observe an average speed-up of 4% on a Linux/x86 platform. Compared with an existing technique for parallel systems, our technique targets uni-processor green-threading embedded systems, allowing us to design simpler and more predictable mutator barriers. Thanks to cheap synchronization provided by green threading, our technique features atomic writes to object replicas, providing programmers with the natural behavior in face of unprotected access to shared variables. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "Replicating real-time garbage collector", "paper_id": "WOS:000295292900004"}