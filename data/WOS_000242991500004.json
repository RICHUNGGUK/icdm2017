{"auto_keywords": [{"score": 0.04310271313476336, "phrase": "concurrent_programs"}, {"score": 0.03353032684383617, "phrase": "realizable_path"}, {"score": 0.013285502789143984, "phrase": "context-sensitive_algorithm"}, {"score": 0.00481495049065317, "phrase": "multithreaded_programs"}, {"score": 0.004751346954124746, "phrase": "java"}, {"score": 0.004672727518631859, "phrase": "well-known_program_reduction_technique"}, {"score": 0.004474645041899596, "phrase": "statement_p"}, {"score": 0.004386063799793622, "phrase": "program_slice"}, {"score": 0.004144452614362445, "phrase": "interprocedural_slicing"}, {"score": 0.004103212598803194, "phrase": "-a_context-insensitive_algorithm"}, {"score": 0.004021954624114115, "phrase": "context-insensitive_algorithm"}, {"score": 0.0038385317554884713, "phrase": "slicing_criterion"}, {"score": 0.003663443192307343, "phrase": "precise_slicing"}, {"score": 0.0034846700528752368, "phrase": "correct_and_reasonably_precise_slices"}, {"score": 0.003427032390942116, "phrase": "worst-case_exponential-time_complexity"}, {"score": 0.0027404283412788997, "phrase": "practical_solution"}, {"score": 0.0024958641143547856, "phrase": "long_call_chains"}, {"score": 0.002470987929071079, "phrase": "flow_graph"}, {"score": 0.002446359075737738, "phrase": "slicing_algorithms"}, {"score": 0.002397833600728684, "phrase": "shared_memory"}, {"score": 0.002381872778203302, "phrase": "interleaving_semantics"}, {"score": 0.0022806798371116698, "phrase": "simple_model"}, {"score": 0.002183776628088228, "phrase": "java_concurrency_model"}, {"score": 0.0021261972801049573, "phrase": "java_bytecode"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": ["algorithms", " design", " multithreading", " data dependence", " interference dependence", " context-sensitivity", " strongly connected regions", " program slicing"], "paper_abstract": "Slicing is a well-known program reduction technique where for a given program P and a variable of interest v at some statement p in the program, a program slice contains those set of statements belonging to P that affect v. This article presents two algorithms for interprocedural slicing of concurrent programs -a context-insensitive algorithm and a context-sensitive algorithm. The context-insensitive algorithm is efficient and correct ( it includes every statement that may affect the slicing criterion) but is imprecise since it may include certain extra statements that are unnecessary. Precise slicing has been shown to be undecidable for concurrent programs. However, the context-sensitive algorithm computes correct and reasonably precise slices, but has a worst-case exponential-time complexity. Our context-sensitive algorithm computes a closure of dependencies while ensuring that statements sliced in each thread belong to a realizable path in that thread. A realizable path in a thread with procedure calls is one that reflects the fact that when a procedure finishes, execution returns to the site of the most recently executed call in that thread. One of the novelties of this article is a practical solution to determine whether a given set of statements in a thread may belong to a realizable path. This solution is precise even in the presence of recursion and long call chains in the flow graph. The slicing algorithms are applicable to concurrent programs with shared memory, interleaving semantics, explicit wait/notify synchronization and monitors. We first give a solution for a simple model of concurrency and later show how to extend the solution to the Java concurrency model. We have implemented the algorithms for Java bytecode and give experimental results.", "paper_title": "Interprocedural slicing of multithreaded programs with applications to Java", "paper_id": "WOS:000242991500004"}