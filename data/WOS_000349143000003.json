{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrent"}, {"score": 0.0450410490027318, "phrase": "packet-processing_tables"}, {"score": 0.004672953146379813, "phrase": "software-defined_network"}, {"score": 0.004195418010131832, "phrase": "routing_policy"}, {"score": 0.004157889052612049, "phrase": "network_conditions"}, {"score": 0.0038810583785936505, "phrase": "sdn_landscape"}, {"score": 0.003744078745897841, "phrase": "rmt"}, {"score": 0.0035794251590584563, "phrase": "switch_programmers"}, {"score": 0.003526186748088922, "phrase": "packet-processing_rules"}, {"score": 0.003432338275868245, "phrase": "packet_fields"}, {"score": 0.003321008590273796, "phrase": "reconfigurable_switch_architectures"}, {"score": 0.0032912755695190163, "phrase": "richer_sdn_model"}, {"score": 0.0032520438684277885, "phrase": "switch_configuration_phase"}, {"score": 0.0032229262928681304, "phrase": "rule_population_phase"}, {"score": 0.0031559919178954644, "phrase": "configuration_phase"}, {"score": 0.0030081570462991776, "phrase": "packet_processing_tables"}, {"score": 0.00295451673215765, "phrase": "population_phase"}, {"score": 0.0027328817607818207, "phrase": "concurrent_netcore"}, {"score": 0.0025202582748972122, "phrase": "fine-grained_operational_model"}, {"score": 0.0024384399939984163, "phrase": "higher-level_denotational_model"}, {"score": 0.0023451553255837317, "phrase": "well-typed_programs"}, {"score": 0.0023241387549221408, "phrase": "strong_normalization"}, {"score": 0.002228519136218028, "phrase": "linguistic_models"}, {"score": 0.0022019274077124795, "phrase": "flexpipe"}, {"score": 0.00216263228969761, "phrase": "multi-pass_compilation_algorithm"}, {"score": 0.0021049977753042253, "phrase": "rmt_model"}], "paper_keywords": ["Design", " Languages", " Theory", " Software-defined networking", " network programming languages", " OpenFlow", " Frenetic"], "paper_abstract": "In a Software-Defined Network (SDN), a central, computationally powerful controller manages a set of distributed, computationally simple switches. The controller computes a policy describing how each switch should route packets and populates packet-processing tables on each switch with rules to enact the routing policy. As network conditions change, the controller continues to add and remove rules from switches to adjust the policy as needed. Recently, the SDN landscape has begun to change as several proposals for new, reconfigurable switching architectures, such as RMT [5] and FlexPipe [14] have emerged. These platforms provide switch programmers with many, flexible tables for storing packet-processing rules, and they offer programmers control over the packet fields that each table can analyze and act on. These reconfigurable switch architectures support a richer SDN model in which a switch configuration phase precedes the rule population phase [4]. In the configuration phase, the controller sends the switch a graph describing the layout and capabilities of the packet processing tables it will require during the population phase. Armed with this foreknowledge, the switch can allocate its hardware (or software) resources more efficiently. We present a new, typed language, called Concurrent NetCore, for specifying routing policies and graphs of packet-processing tables. Concurrent NetCore includes features for specifying sequential, conditional and concurrent control-flow between packet-processing tables. We develop a fine-grained operational model for the language and prove this model coincides with a higher-level denotational model when programs are well-typed. We also prove several additional properties of well-typed programs, including strong normalization and determinism. To illustrate the utility of the language, we develop linguistic models of both the RMT and FlexPipe architectures and we give a multi-pass compilation algorithm that translates graphs and routing policies to the RMT model.", "paper_title": "Concurrent NetCore: From Policies to Pipelines", "paper_id": "WOS:000349143000003"}