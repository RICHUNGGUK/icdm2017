{"auto_keywords": [{"score": 0.02881858386788793, "phrase": "step_complexity"}, {"score": 0.00481495049065317, "phrase": "polylogarithmic_step_complexity"}, {"score": 0.004590820632326585, "phrase": "novel_implementation"}, {"score": 0.0044826811976193485, "phrase": "snapshot_object"}, {"score": 0.004412000844879264, "phrase": "n_processes"}, {"score": 0.004042635935882651, "phrase": "update_operations"}, {"score": 0.0037935066882208235, "phrase": "scan_operations"}, {"score": 0.0032614317990293695, "phrase": "polynomially_many_updates"}, {"score": 0.0031342307827666675, "phrase": "exponential_improvement"}, {"score": 0.0030847461428168614, "phrase": "previous_snapshot_algorithms"}, {"score": 0.002988101395789399, "phrase": "linear_step_complexity"}, {"score": 0.0028715299874549245, "phrase": "existing_omega"}, {"score": 0.002279508335630797, "phrase": "new_object"}, {"score": 0.0021731423856364003, "phrase": "max_registers"}, {"score": 0.0021049977753042253, "phrase": "scan_operation"}], "paper_keywords": ["Theory", " Algorithms", " Concurrent objects", " restricted-use objects", " atomic snapshot", " generalized counters"], "paper_abstract": "This article presents a novel implementation of a snapshot object for n processes, with O(log(2) blog n) step complexity for update operations and O(log b) step complexity for scan operations, where b is the number of updates. The algorithm uses only reads and writes. For polynomially many updates, this is an exponential improvement on previous snapshot algorithms, which have linear step complexity. It overcomes the existing Omega (n) lower bound on step complexity by having the step complexity depend on the number of updates. The key to this implementation is the construction of a new object consisting of a pair of max registers that supports a scan operation.", "paper_title": "Limited-Use Atomic Snapshots with Polylogarithmic Step Complexity", "paper_id": "WOS:000350563000003"}