{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "computing_error-correcting_codes"}, {"score": 0.004781215097314411, "phrase": "bounded-depth_circuits"}, {"score": 0.004648609688625397, "phrase": "minimum_number"}, {"score": 0.004227515355865597, "phrase": "unbounded_fan-in_circuits"}, {"score": 0.004168448339217754, "phrase": "arbitrary_gates"}, {"score": 0.0025642664420937327, "phrase": "linear_map"}, {"score": 0.002537303919584199, "phrase": "upper_bounds"}, {"score": 0.002381365139274329, "phrase": "known_techniques"}, {"score": 0.0023151639346874883, "phrase": "pairwise-independent_hash_functions"}, {"score": 0.002242879896352752, "phrase": "superconcentrator-like_condition"}, {"score": 0.002188219483646592, "phrase": "good_codes"}, {"score": 0.002134888329742086, "phrase": "provably_intermediate"}], "paper_keywords": ["Bounded-depth circuits", " error-correcting codes", " hashing", " lower bounds", " superconcentrators"], "paper_abstract": "We bound the minimum number of wires needed to compute any (asymptotically good) error-correcting code C : {0, 1}(Omega(n)) -> {0, 1}(n) with minimum distance Omega(n), using unbounded fan-in circuits of depth with arbitrary gates. Our main results are: 1) if d = 2, then w = Theta(n(lg n/lg lg n)(2)); 2) if d = 3, then w = Theta(n lg lg n); 3) if d = 2k or d = 2k + 1 for some integer k >= 2, then w = Theta(n lambda(k)(n)), where lambda(1)(n) = inverted rightlg ninverted left perpendicular lambda(i+1)(n) = lambda(i)*(n), and the * operation gives how many times one has to iterate the function lambda(i) to reach a value at most 1 from the argument; and 4) if d = lg* n, then w = O(n). For depth d = 2, our Omega(n(lg n/lg lg n)(2)) lower bound gives the largest known lower bound for computing any linear map. The upper bounds imply that a (necessarily dense) generator matrix for our code can be written as the product of two sparse matrices. Using known techniques, we also obtain similar (but not tight) bounds for computing pairwise-independent hash functions. Our lower bounds are based on a superconcentrator-like condition that the graphs of circuits computing good codes must satisfy. This condition is provably intermediate between superconcentrators and their weakenings considered before.", "paper_title": "Tight Bounds on Computing Error-Correcting Codes by Bounded-Depth Circuits With Arbitrary Gates", "paper_id": "WOS:000324573500028"}