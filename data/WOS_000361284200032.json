{"auto_keywords": [{"score": 0.04423467024884347, "phrase": "undefined_behavior"}, {"score": 0.00481495049065317, "phrase": "\"negative\"_semantics"}, {"score": 0.004321952227344232, "phrase": "undefined_programs"}, {"score": 0.004050625770007516, "phrase": "special_considerations"}, {"score": 0.0034629341517018438, "phrase": "semantic_infrastructure"}, {"score": 0.003107935254560724, "phrase": "original_semantics"}, {"score": 0.002944284514509205, "phrase": "undefinedness_checker"}, {"score": 0.0027295084882654917, "phrase": "third-party_test_suite"}, {"score": 0.0025440911575156755, "phrase": "core_language_undefinedness"}, {"score": 0.0021049977753042253, "phrase": "c_language"}], "paper_keywords": ["Undefined behavior", " Programming language semantics", " C11", " K Framework"], "paper_abstract": "We present a \"negative\" semantics of the C11 language-a semantics that does not just give meaning to correct programs, but also rejects undefined programs. We investigate undefined behavior in C and discuss the techniques and special considerations needed for formally specifying it. We have used these techniques to modify and extend a semantics of C into one that captures undefined behavior. The amount of semantic infrastructure and effort required to achieve this was unexpectedly high, in the end nearly doubling the size of the original semantics. From our semantics, we have automatically extracted an undefinedness checker, which we evaluate against other popular analysis tools, using our own test suite in addition to a third-party test suite. Our checker is capable of detecting examples of all 77 categories of core language undefinedness appearing in the C11 standard, more than any other tool we considered. Based on this evaluation, we argue that our work is the most comprehensive and complete semantic treatment of undefined behavior in C, and thus of the C language itself.", "paper_title": "Defining the Undefinedness of C", "paper_id": "WOS:000361284200032"}