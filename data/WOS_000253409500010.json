{"auto_keywords": [{"score": 0.03891339646660018, "phrase": "ise"}, {"score": 0.031951239317836354, "phrase": "source-level_transformations"}, {"score": 0.00481495049065317, "phrase": "source-to-source_transformations"}, {"score": 0.0046544807197808095, "phrase": "automated_design-space_exploration"}, {"score": 0.004556901872357751, "phrase": "industry's_demand"}, {"score": 0.004518442937844318, "phrase": "flexible_embedded_solutions"}, {"score": 0.004480307124735185, "phrase": "high_performance"}, {"score": 0.0044424917428102445, "phrase": "short_time"}, {"score": 0.004240116703465252, "phrase": "configurable_and_extensible_processors"}, {"score": 0.004186534737631288, "phrase": "pre-verified_application-specific_processors"}, {"score": 0.003945266418163835, "phrase": "user-defined_instruction"}, {"score": 0.003829877278269543, "phrase": "functional_units"}, {"score": 0.00378145978325955, "phrase": "extended_micro-architecture"}, {"score": 0.0037336520904376687, "phrase": "traditional_design_flow"}, {"score": 0.003639835714755229, "phrase": "plain_c_sources"}, {"score": 0.003593812067062062, "phrase": "target_application"}, {"score": 0.0035183910023550246, "phrase": "ise_identification"}, {"score": 0.0034299649219748513, "phrase": "modified_source_file"}, {"score": 0.00337224813954299, "phrase": "explicit_handles"}, {"score": 0.0033295966773779174, "phrase": "new_machine_instructions"}, {"score": 0.003287482882222731, "phrase": "code_optimization"}, {"score": 0.0031110402375026016, "phrase": "novel_approach"}, {"score": 0.0029191527226078286, "phrase": "automated_code_transformation"}, {"score": 0.0028944757265206332, "phrase": "ise_generators"}, {"score": 0.0028457440091791226, "phrase": "potential_benefits"}, {"score": 0.0026363807171515255, "phrase": "resulting_code"}, {"score": 0.002603012037901889, "phrase": "resulting_performance"}, {"score": 0.0025160740422447837, "phrase": "snu-rt_and_utdsp_benchmarks"}, {"score": 0.0024527767211457046, "phrase": "instruction_extensions"}, {"score": 0.002421726275597666, "phrase": "automated_tools"}, {"score": 0.0023708445073819277, "phrase": "source_code_structure"}, {"score": 0.0022626276288355432, "phrase": "set_extensions"}, {"score": 0.0022339789476489877, "phrase": "average_performance_improvements"}, {"score": 0.002177762848946681, "phrase": "instruction_set_extensions"}, {"score": 0.0021049977753042253, "phrase": "extreme_cases"}], "paper_keywords": ["customizable processors", " ASIPs", " source-level transformations", " compilers", " instruction set extension", " design space exploration", " design", " performance"], "paper_abstract": "Industry's demand for flexible embedded solutions providing high performance and short time-to-market has led to the development of configurable and extensible processors. These pre-verified application-specific processors build on proven baseline cores while allowing for some degree of customization through user-defined instruction set extensions (ISE) implemented as functional units in an extended micro-architecture. The traditional design flow for ISE is based on plain C sources of the target application and, after some ISE identification and synthesis stages, a modified source file is produced with explicit handles to the new machine instructions. Further code optimization is left to the compiler. In this paper we develop a novel approach, namely the combined exploration of source-level transformations and ISE identification. We have combined automated code transformation and ISE generators to explore the potential benefits of such a combination. This applies up to 50 transformations from a selection of 70, and synthesizes ISEs for the resulting code. The resulting performance has been measured on 26 applications from the SNU-RT and UTDSP benchmarks. We show that the instruction extensions generated by automated tools are heavily influenced by source code structure. Our results demonstrate that a combination of source-level transformations and instruction set extensions can yield average performance improvements of 47%. This outperforms instruction set extensions when applied in isolation, and in extreme cases yields a speedup of 2.85.", "paper_title": "Combining source-to-source transformations and processor instruction set extensions for the automated design-space exploration of embedded systems", "paper_id": "WOS:000253409500010"}