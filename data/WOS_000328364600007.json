{"auto_keywords": [{"score": 0.04286666008487537, "phrase": "nonfunctional_properties"}, {"score": 0.00665395333543632, "phrase": "base_model"}, {"score": 0.006257897028621514, "phrase": "dsmls"}, {"score": 0.005589376665951985, "phrase": "demonstration-based_approach"}, {"score": 0.00481495049065317, "phrase": "nonfunctional_system_properties"}, {"score": 0.004791330993892003, "phrase": "demonstration-based_model_transformation"}, {"score": 0.004767826806287385, "phrase": "domain-specific_modeling_languages"}, {"score": 0.004686462184176846, "phrase": "increasingly_significant_role"}, {"score": 0.004663470026748641, "phrase": "software_development"}, {"score": 0.004494570360108983, "phrase": "specific_domain"}, {"score": 0.004439634831927606, "phrase": "core_essence"}, {"score": 0.004353125107531672, "phrase": "irrelevant_accidental_complexities"}, {"score": 0.004268293864953256, "phrase": "implementation_level"}, {"score": 0.00424734451992536, "phrase": "source_code"}, {"score": 0.004174824849669107, "phrase": "functional_aspects"}, {"score": 0.004033464035028803, "phrase": "service_constraints"}, {"score": 0.004013662619667083, "phrase": "timing_requirements"}, {"score": 0.003877737556673229, "phrase": "complete_specification"}, {"score": 0.0036553070575015344, "phrase": "functional_components"}, {"score": 0.003548905904860611, "phrase": "essential_modeling_task"}, {"score": 0.0034118234596993836, "phrase": "manual_model_editing"}, {"score": 0.003378385493203297, "phrase": "model_transformation_languages"}, {"score": 0.0032558762499901727, "phrase": "specific_details"}, {"score": 0.0032319109979344184, "phrase": "modeling_transformation_language"}, {"score": 0.0032081215771180664, "phrase": "underlying_metamodel"}, {"score": 0.0028715299874549245, "phrase": "concrete_model_instances"}, {"score": 0.002843372121209168, "phrase": "single_case"}, {"score": 0.002822434555587263, "phrase": "maintenance_process"}, {"score": 0.0027878797103973313, "phrase": "user's_operations"}, {"score": 0.0027673496368158545, "phrase": "inference_engine"}, {"score": 0.0027469703311742647, "phrase": "user's_intention"}, {"score": 0.002726740692380339, "phrase": "generic_model_transformation_patterns"}, {"score": 0.0026148807877309417, "phrase": "maintenance_task"}, {"score": 0.0025262061502713683, "phrase": "maintenance_tasks"}, {"score": 0.0025014259919355453, "phrase": "complex_model_transformation_language"}, {"score": 0.0024345237091263766, "phrase": "model_instances"}, {"score": 0.0023928819778638055, "phrase": "underlying_abstract_metamodel_definitions"}, {"score": 0.0023288759982072003, "phrase": "auto_scaling"}, {"score": 0.002317423416027688, "phrase": "model_layout"}, {"score": 0.0023003498123420237, "phrase": "specific_contribution"}, {"score": 0.002233301265743633, "phrase": "crosscutting_concerns_representative"}, {"score": 0.0022059431774071278, "phrase": "modeling_level"}, {"score": 0.0021735545290040522, "phrase": "multiple_modeling_languages"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["nonfunctional property maintenance", " model transformation by demonstration", " domain-specific modeling language"], "paper_abstract": "Domain-Specific Modeling Languages (DSMLs) are playing an increasingly significant role in software development. By raising the level of abstraction using notations that are representative of a specific domain, DSMLs allow the core essence of a problem to be separated from irrelevant accidental complexities, which are typically found at the implementation level in source code. In addition to modeling the functional aspects of a system, a number of nonfunctional properties (e.g., quality of service constraints and timing requirements) also need to be integrated into models in order to reach a complete specification of a system. This is particularly true for domains that have distributed real time and embedded needs. Given a base model with functional components, maintaining the nonfunctional properties that crosscut the base model has become an essential modeling task when using DSMLs. The task of maintaining nonfunctional properties in DSMLs is traditionally supported by manual model editing or by using model transformation languages. However, these approaches are challenging to use for those unfamiliar with the specific details of a modeling transformation language and the underlying metamodel of the domain, which presents a7 steep learning curve for many users. This paper presents a demonstration-based approach to automate the maintenance of nonfunctional properties in DSMLs. Instead of writing model transformation rules explicitly, users demonstrate how to apply the nonfunctional properties by directly editing the concrete model instances and simulating a single case of the maintenance process. By recording a user's operations, an inference engine analyzes the user's intention and generates generic model transformation patterns automatically, which can be refined by users and then reused to automate the same evolution and maintenance task in other models. Using this approach, users are able to automate the maintenance tasks without learning a complex model transformation language. In addition, because the demonstration is performed on model instances, users are isolated from the underlying abstract metamodel definitions. Our demonstration-based approach has been applied to several scenarios, such as auto scaling and model layout. The specific contribution in this paper is the application of the demonstration-based approach to capture crosscutting concerns representative of aspects at the modeling level. Several examples are presented across multiple modeling languages to demonstrate the benefits of our approach. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Automating the maintenance of nonfunctional system properties using demonstration-based model transformation", "paper_id": "WOS:000328364600007"}