{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multiple_indexes"}, {"score": 0.017371488428113962, "phrase": "index_interpolation"}, {"score": 0.010372983229429906, "phrase": "time-series_database"}, {"score": 0.009560794092486384, "phrase": "subsequence_matching"}, {"score": 0.006674021099522916, "phrase": "optimal_window_sizes"}, {"score": 0.006230715456358228, "phrase": "target_application"}, {"score": 0.004783483480147339, "phrase": "efficient_subsequence_matching"}, {"score": 0.004752221133109136, "phrase": "time-series_databases"}, {"score": 0.00462919213721188, "phrase": "data_sequences"}, {"score": 0.004154332348800334, "phrase": "query_sequence"}, {"score": 0.0040334640350288, "phrase": "performance_issue"}, {"score": 0.004007083686875716, "phrase": "time-series_subsequence_matching"}, {"score": 0.003903269701018361, "phrase": "performance_degradation"}, {"score": 0.003852371777780562, "phrase": "window_size_effect"}, {"score": 0.003703611021999795, "phrase": "single_index"}, {"score": 0.0036433294654548056, "phrase": "real_applications"}, {"score": 0.003548905904860611, "phrase": "fairly_effective_tool"}, {"score": 0.0029722900280316216, "phrase": "physical_database_design"}, {"score": 0.0028762499230524812, "phrase": "query_sequences"}, {"score": 0.0027741761880779535, "phrase": "window_sizes"}, {"score": 0.00266693888510356, "phrase": "overall_cost"}, {"score": 0.0024485643104830814, "phrase": "entire_subsequence_matchings"}, {"score": 0.0022480304016499605, "phrase": "extensive_experiments"}, {"score": 0.002146926767291475, "phrase": "synthetic_data_sets"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["time-series databases", " subsequence matching", " index interpolation", " physical database design"], "paper_abstract": "A time-series database is a set of data sequences, each of which is a list of changing values of an object in a given period of time. Subsequence matching is an operation that searches for such data subsequences whose changing patterns are similar to a query sequence in a time-series database. This paper addresses a performance issue of time-series subsequence matching. First, we quantitatively examine the performance degradation caused by the window size effect, and then show that the performance of subsequence matching with a single index is not satisfactory in real applications. We claim that index interpolation is a fairly effective tool to solve this problem. Index interpolation performs subsequence matching by selecting the most appropriate one from multiple indexes built on windows of their distinct sizes. For index interpolation, we need to decide the sizes of windows for multiple indexes to be built. In this paper, we solve the problem of selecting optimal window sizes from the perspective of physical database design. Given a set of pairs (length,ftequency) of query sequences to be performed in a target application and a set of window sizes for building multiple indexes, we devise a formula that estimates the overall cost of all the subsequence matchings performed in a target application. By using this formula, we propose an algorithm that determines the optimal window sizes for maximizing the performance of entire subsequence matchings. We formally prove the optimality as well as the effectiveness of the algorithm. Finally, we show the superiority of our approach by performing extensive experiments with a real-life stock data set and a large volume of synthetic data sets. (C) 2007 Elsevier Inc. All rights reserved.", "paper_title": "Using multiple indexes for efficient subsequence matching in time-series databases", "paper_id": "WOS:000250899400014"}