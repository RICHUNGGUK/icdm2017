{"auto_keywords": [{"score": 0.004665483918844599, "phrase": "lazy_programming"}, {"score": 0.004578030096508602, "phrase": "abstract_level"}, {"score": 0.0044079880067019765, "phrase": "concrete_program"}, {"score": 0.004244234872662471, "phrase": "significant_challenge"}, {"score": 0.003934681262271618, "phrase": "numerous_papers"}, {"score": 0.0036246643358397272, "phrase": "significant_amount"}, {"score": 0.003467940281748612, "phrase": "profiling-based_technique"}, {"score": 0.003235193484261443, "phrase": "laziness_annotations"}, {"score": 0.003194580334752371, "phrase": "strict_programs"}, {"score": 0.0029241700853970013, "phrase": "formal_semantics"}, {"score": 0.002560751416355291, "phrase": "dynamic_profiling_tool"}, {"score": 0.0022002633747977593, "phrase": "expert's_use"}, {"score": 0.0021049977753042253, "phrase": "real-world_applications"}], "paper_keywords": ["laziness", " profiling", " code refactoring"], "paper_abstract": "While many programmers appreciate the benefits of lazy programming at an abstract level, determining which parts of a concrete program to evaluate lazily poses a significant challenge for most of them. Over the past thirty years, experts have published numerous papers on the problem, but developing this level of expertise requires a significant amount of experience. We present a profiling-based technique that captures and automates this expertise for the insertion of laziness annotations into strict programs. To make this idea precise, we show how to equip a formal semantics with a metric that measures waste in an evaluation. Then we explain how to implement this metric as a dynamic profiling tool that suggests where to insert laziness into a program. Finally, we present evidence that our profiler's suggestions either match or improve on an expert's use of laziness in a range of real-world applications.", "paper_title": "Profiling for Laziness", "paper_id": "WOS:000331120500030"}