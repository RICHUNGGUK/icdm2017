{"auto_keywords": [{"score": 0.037205618779489656, "phrase": "deterministic_ordering"}, {"score": 0.00481495049065317, "phrase": "global_barriers"}, {"score": 0.004761132425263795, "phrase": "multithreaded_programs"}, {"score": 0.004655285779819366, "phrase": "conventional_architectures"}, {"score": 0.004603244077348199, "phrase": "operating_systems"}, {"score": 0.004327196832280818, "phrase": "deterministic_multithreading"}, {"score": 0.004278867491482497, "phrase": "dmt"}, {"score": 0.0041136473765874815, "phrase": "multithreaded_program"}, {"score": 0.00378080526397273, "phrase": "current_dmt_implementations"}, {"score": 0.0036966717141736355, "phrase": "common_inefficiency"}, {"score": 0.0036144035798673967, "phrase": "frequent_global_barriers"}, {"score": 0.0034944094552943, "phrase": "memory_accesses"}, {"score": 0.003266201217790818, "phrase": "execution_model"}, {"score": 0.0032115093493071366, "phrase": "deterministic_lazy_release_consistency"}, {"score": 0.003070086433952691, "phrase": "kendo_algorithm"}, {"score": 0.0028695095228791724, "phrase": "deterministic_version"}, {"score": 0.0028214413724451442, "phrase": "lazy_release_consistency_memory_model"}, {"score": 0.0025494354909453847, "phrase": "data_races"}, {"score": 0.0024786330057813225, "phrase": "dmt_system"}, {"score": 0.0022270182923887012, "phrase": "posix_threads"}, {"score": 0.0021651504858015364, "phrase": "rfdet"}, {"score": 0.0021049977753042253, "phrase": "dthreads-a"}], "paper_keywords": ["deterministic execution", " multithreading", " lazy release consistency"], "paper_abstract": "Multithreaded programs execute nondeterministically on conventional architectures and operating systems. This complicates many tasks, including debugging and testing. Deterministic multithreading (DMT) makes the output of a multithreaded program depend on its inputs only, which can totally solve the above problem. However, current DMT implementations suffer from a common inefficiency: they use frequent global barriers to enforce a deterministic ordering on memory accesses. In this paper, we eliminate that inefficiency using an execution model we call deterministic lazy release consistency (DLRC). Our execution model uses the Kendo algorithm to enforce a deterministic ordering on synchronization, and it uses a deterministic version of the lazy release consistency memory model to propagate memory updates across threads. Our approach guarantees that programs execute deterministically even when they contain data races, We implemented a DMT system based on these ideas (RFDet) and evaluated it using 17 parallel applications. Our implementation targets C/C++ programs that use POSIX threads. Results show that RFDet gains nearly 2x speedup compared with DThreads-a start-of-the-art DMT system.", "paper_title": "Efficient Deterministic Multithreading Without Global Barriers", "paper_id": "WOS:000349142100025"}