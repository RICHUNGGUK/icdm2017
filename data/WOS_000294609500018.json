{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "sc-preserving_compiler"}, {"score": 0.013738991691095052, "phrase": "sc_behavior"}, {"score": 0.008267696251896299, "phrase": "eager-load_optimizations"}, {"score": 0.0047357308775561255, "phrase": "shared-memory_multi-threaded_programming"}, {"score": 0.004581162468419365, "phrase": "current_concurrent_programming_languages"}, {"score": 0.0045357787854931894, "phrase": "relaxed_model"}, {"score": 0.004402295697276237, "phrase": "important_optimizations"}, {"score": 0.004160740888748725, "phrase": "compiler-generated_binary"}, {"score": 0.004078675940346967, "phrase": "source_program"}, {"score": 0.003998223112665124, "phrase": "performance_benefits"}, {"score": 0.003958591403140206, "phrase": "optimizing_compiler"}, {"score": 0.003919350990355722, "phrase": "key_observation"}, {"score": 0.0038676325043529524, "phrase": "large_class"}, {"score": 0.003477628306017313, "phrase": "optimization_phases"}, {"score": 0.00345460000664386, "phrase": "llvm"}, {"score": 0.003286642683771891, "phrase": "average_slowdown"}, {"score": 0.0032324864013225166, "phrase": "maximum_slowdown"}, {"score": 0.0024776238724770524, "phrase": "common-subexpression_elimination"}, {"score": 0.00239657981537094, "phrase": "common_cases"}, {"score": 0.0023806911724834024, "phrase": "loop-invariant_code_motion"}, {"score": 0.0023259039577313294, "phrase": "interference_checks"}, {"score": 0.0022648286660146314, "phrase": "sc._interference_checks"}, {"score": 0.0021403049512708494, "phrase": "particular_variable"}, {"score": 0.0021049977753042253, "phrase": "last_read"}], "paper_keywords": ["Languages", " Performance", " memory consistency models", " sequential consistency", " SC preservation", " interference checks"], "paper_abstract": "The most intuitive memory consistency model for shared-memory multi-threaded programming is sequential consistency (SC). However, current concurrent programming languages support a relaxed model, as such relaxations are deemed necessary for enabling important optimizations. This paper demonstrates that an SC-preserving compiler, one that ensures that every SC behavior of a compiler-generated binary is an SC behavior of the source program, retains most of the performance benefits of an optimizing compiler. The key observation is that a large class of optimizations crucial for performance are either already SC-preserving or can be modified to preserve SC while retaining much of their effectiveness. An SC-preserving compiler, obtained by restricting the optimization phases in LLVM, a state-of-the-art C/C++ compiler, incurs an average slowdown of 3.8% and a maximum slowdown of 34% on a set of 30 programs from the SPLASH-2, PARSEC, and SPEC CINT2006 benchmark suites. While the performance overhead of preserving SC in the compiler is much less than previously assumed, it might still be unacceptable for certain applications. We believe there are several avenues for improving performance without giving up SC-preservation. In this vein, we observe that the overhead of our SC-preserving compiler arises mainly from its inability to aggressively perform a class of optimizations we identify as eager-load optimizations. This class includes common-subexpression elimination, constant propagation, global value numbering, and common cases of loop-invariant code motion. We propose a notion of interference checks in order to enable eager-load optimizations while preserving SC. Interference checks expose to the compiler a commonly used hardware speculation mechanism that can efficiently detect whether a particular variable has changed its value since last read.", "paper_title": "A Case for an SC-Preserving Compiler", "paper_id": "WOS:000294609500018"}