{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrent_objects"}, {"score": 0.03398665802358191, "phrase": "refinement_violations"}, {"score": 0.004774324145784758, "phrase": "efficient_implementations"}, {"score": 0.004576253356889219, "phrase": "atomic_collections"}, {"score": 0.004499334809770281, "phrase": "modern_computing"}, {"score": 0.004276216827737399, "phrase": "synchronization_overhead"}, {"score": 0.004240116703465252, "phrase": "concurrent_object_invocations"}, {"score": 0.0040298010803060495, "phrase": "formal_terms"}, {"score": 0.003945266418163835, "phrase": "observational_refinement"}, {"score": 0.003813669883040509, "phrase": "single_execution"}, {"score": 0.0037336520904376687, "phrase": "existing_approaches"}, {"score": 0.0034886660821793576, "phrase": "refinement_checking"}, {"score": 0.00337224813954299, "phrase": "accuracy_k"}, {"score": 0.003071682293903262, "phrase": "k_increases"}, {"score": 0.002857849698346116, "phrase": "foundational_properties"}, {"score": 0.0028216858159564808, "phrase": "partial_orders"}, {"score": 0.0027274643070540733, "phrase": "object_invocations"}, {"score": 0.0026815368507715, "phrase": "interval_orders"}, {"score": 0.0026363807171515255, "phrase": "well_defined_measure"}, {"score": 0.0024527767211457046, "phrase": "possibly-weaker_interval_order"}, {"score": 0.0023408288327263316, "phrase": "bounded_number"}, {"score": 0.0023210293050850276, "phrase": "integer_counters"}, {"score": 0.0021049977753042253, "phrase": "existing_refinement-checking_approaches"}], "paper_keywords": ["Reliability", " Verification", " Concurrency", " Refinement", " Linearizability"], "paper_abstract": "Efficient implementations of concurrent objects such as semaphores, locks, and atomic collections are essential to modern computing. Yet programming such objects is error prone: in minimizing the synchronization overhead between concurrent object invocations, one risks the conformance to reference implementations - or in formal terms, one risks violating observational refinement. Testing this refinement even within a single execution is intractable, limiting existing approaches to executions with very few object invocations. We develop a polynomial-time (per execution) approximation to refinement checking. The approximation is parameterized by an accuracy k is an element of N representing the degree to which refinement violations are visible. In principle, more violations are detectable as k increases, and in the limit, all are detectable. Our insight for this approximation arises from foundational properties on the partial orders characterizing the happens-before relations between object invocations: they are interval orders, with a well defined measure of complexity, i.e., their length. Approximating the happens-before relation with a possibly-weaker interval order of bounded length can be efficiently implemented by maintaining a bounded number of integer counters. In practice, we find that refinement violations can be detected with very small values of k, and that our approach scales far beyond existing refinement-checking approaches.", "paper_title": "Tractable Refinement Checking for Concurrent Objects", "paper_id": "WOS:000354800500052"}