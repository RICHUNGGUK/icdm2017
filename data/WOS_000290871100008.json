{"auto_keywords": [{"score": 0.03712854373593969, "phrase": "arpa"}, {"score": 0.006859573468866079, "phrase": "overall_instruction_throughput"}, {"score": 0.0065009690861397495, "phrase": "icount"}, {"score": 0.006208459262757686, "phrase": "static_partitioning"}, {"score": 0.00481495049065317, "phrase": "power-performance_efficiency"}, {"score": 0.004723322467153553, "phrase": "simultaneous_multithreading"}, {"score": 0.004633429997452688, "phrase": "processor_throughput"}, {"score": 0.004580314008293946, "phrase": "parallel_execution"}, {"score": 0.004441616106463486, "phrase": "processor_resources"}, {"score": 0.004390689303780405, "phrase": "resource_monopolization"}, {"score": 0.004340343873304156, "phrase": "single_thread"}, {"score": 0.004241370886886689, "phrase": "overall_performance_degradation"}, {"score": 0.004208881856146758, "phrase": "static_resource"}, {"score": 0.004192730391924712, "phrase": "partitioning_techniques"}, {"score": 0.0040190868373730015, "phrase": "dynamic_ones"}, {"score": 0.003988293689448734, "phrase": "program_behavior"}, {"score": 0.003750260412839128, "phrase": "adaptive_resource_partitioning_algorithm"}, {"score": 0.0035536228914319354, "phrase": "thread_behavior"}, {"score": 0.003485913728272778, "phrase": "resource_usage_efficiency"}, {"score": 0.0031540120386134058, "phrase": "resource_utilization"}, {"score": 0.002954228277691572, "phrase": "traditional_fetch_policy"}, {"score": 0.0027458373015999916, "phrase": "current_best_dynamic_resource_allocation_technique"}, {"score": 0.002381169982803105, "phrase": "common_fairness_metric"}, {"score": 0.002326767693352058, "phrase": "energy_efficiency"}, {"score": 0.0022302306304023602, "phrase": "buffer_entries"}, {"score": 0.002213112756450354, "phrase": "arpa."}, {"score": 0.0021049977753042253, "phrase": "performance_loss"}], "paper_keywords": ["Simultaneous multithreading", " resource partitioning", " power-performance efficiency"], "paper_abstract": "Simultaneous multithreading (SMT) increases processor throughput by allowing parallel execution of several threads. However, fully sharing processor resources may cause resource monopolization by a single thread or other misallocations, resulting in overall performance degradation. Static resource partitioning techniques have been suggested, but are not as effective as dynamic ones since program behavior does change over the course of its execution. In this paper, we propose an Adaptive Resource Partitioning Algorithm (ARPA) that dynamically assigns resources to threads according to changes in thread behavior. ARPA analyzes the resource usage efficiency of each thread in a given time period and assigns more resources to threads which can use them more efficiently. Its purpose is to improve the efficiency of resource utilization, thereby improving overall instruction throughput. Our simulation results on a set of 42 multiprogramming workloads show that ARPA outperforms the traditional fetch policy ICOUNT by 55.8 percent with regard to overall instruction throughput and achieves a 33.8 percent improvement over Static Partitioning. It also outperforms the current best dynamic resource allocation technique, Hill-climbing, by 5.7 percent. Considering fairness accorded to each thread, ARPA attains 43.6, 18.5, and 9.2 percent improvements over ICOUNT, Static Partitioning, and Hill-climbing, respectively, using a common fairness metric. We also explore the energy efficiency of dynamically controlling the number of powered-on reorder buffer entries for ARPA. Compared with ARPA, our energy-aware resource partitioning algorithm achieves 10.6 percent energy savings, while the performance loss is negligible.", "paper_title": "Utilization-Based Resource Partitioning for Power-Performance Efficiency in SMT Processors", "paper_id": "WOS:000290871100008"}