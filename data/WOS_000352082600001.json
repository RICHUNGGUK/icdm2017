{"auto_keywords": [{"score": 0.04633740170112975, "phrase": "fault_tolerance"}, {"score": 0.03371704893045813, "phrase": "lbra"}, {"score": 0.01036134355653577, "phrase": "redundant_threads"}, {"score": 0.00481495049065317, "phrase": "decoupled_transactional_memory_threads"}, {"score": 0.0047013405841819025, "phrase": "hardware_errors"}, {"score": 0.004546755482549647, "phrase": "recent_and_future_microarchitecture_designs"}, {"score": 0.004272969980602508, "phrase": "low_performance_degradation"}, {"score": 0.004232331639807526, "phrase": "power_consumption"}, {"score": 0.00401560412621627, "phrase": "parallel_codes"}, {"score": 0.003828187766572941, "phrase": "non-realistic_environments"}, {"score": 0.0036494864560524735, "phrase": "highly_optimized_hardware_designs"}, {"score": 0.00349577373145384, "phrase": "multiple_challenge"}, {"score": 0.0034459835582278746, "phrase": "architectural_design"}, {"score": 0.003222814590544802, "phrase": "hardware_transactional_memory_architecture"}, {"score": 0.003087017178815267, "phrase": "pair-shared_virtual_memory_log"}, {"score": 0.0029147869733574844, "phrase": "smt_cores"}, {"score": 0.002845883666777154, "phrase": "performance_penalty"}, {"score": 0.002687070469080394, "phrase": "different_cores"}, {"score": 0.00263612191603326, "phrase": "inter-core_communication"}, {"score": 0.0025737890313763407, "phrase": "log_buffer"}, {"score": 0.002524982927936405, "phrase": "simple_prefetch_strategy"}, {"score": 0.002500927169609655, "phrase": "simulation_results"}, {"score": 0.0024417832296664698, "phrase": "scientific_and_multimedia_applications"}, {"score": 0.0023954743066925714, "phrase": "execution_time_overhead"}, {"score": 0.002316532084420729, "phrase": "base_case"}, {"score": 0.0021976915360493628, "phrase": "previous_proposals"}], "paper_keywords": ["Reliability", " Fault tolerance", " Soft-errors", " Hardware transactional memory"], "paper_abstract": "CMOS scaling exacerbates hardware errors making reliability a big concern for recent and future microarchitecture designs. Mechanisms to provide fault tolerance in architectures must accomplish several objectives such as low performance degradation, power consumption and area overhead. Several studies have already proposed fault tolerance for parallel codes. However, these proposals are usually implemented over non-realistic environments including the use of shared-buses among processors or modifying highly optimized hardware designs such as caches. Our attempt to face this multiple challenge is an architectural design called LBRA (Log-Based Redundant Architecture). Based on a Hardware Transactional Memory architecture, LBRA executes redundant threads which communicate through a pair-shared virtual memory log allocated in cache. Our initial version of LBRA executes these redundant threads in SMT cores. To avoid the performance penalty inherent to this architecture, we propose to decouple their execution in different cores, solving the inter-core communication by means of a log buffer empowered by a simple prefetch strategy. Simulation results using a variety of scientific and multimedia applications show that the execution time overhead of our best design is less than 7 % over a base case without fault tolerance. Additionally, we show that LBRA outperforms previous proposals that we have implemented and evaluated in the same framework.", "paper_title": "Soft-error mitigation by means of decoupled transactional memory threads", "paper_id": "WOS:000352082600001"}