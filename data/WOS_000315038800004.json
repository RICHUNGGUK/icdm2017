{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "priority_replacement_policies"}, {"score": 0.01145764972432688, "phrase": "min-tree_algorithm"}, {"score": 0.009535616849848825, "phrase": "opt"}, {"score": 0.004771169721351947, "phrase": "linear"}, {"score": 0.0043533862892678864, "phrase": "cache_sizes"}, {"score": 0.0037423521744765075, "phrase": "general_priority_policies"}, {"score": 0.0036186222999811802, "phrase": "nearly_static_priorities"}, {"score": 0.003452218803245602, "phrase": "nsp_policies"}, {"score": 0.003293442130869165, "phrase": "address_trace"}, {"score": 0.003260377175139591, "phrase": "suitable_probabilistic_assumptions"}, {"score": 0.003227643104496149, "phrase": "expected_time"}, {"score": 0.003131393466870228, "phrase": "experimental_evidence"}, {"score": 0.0029672941061574375, "phrase": "linear-scan"}, {"score": 0.002937493907103812, "phrase": "interesting_policies"}, {"score": 0.002709589081384597, "phrase": "min-tree"}, {"score": 0.002558909812664716, "phrase": "worst_case"}, {"score": 0.0024909230668523825, "phrase": "worst-case_time"}, {"score": 0.0023603090494738964, "phrase": "lfu"}, {"score": 0.0023365900988091947, "phrase": "least"}, {"score": 0.002259231376607264, "phrase": "best_previously_known_bound"}, {"score": 0.002214048743052355, "phrase": "random_replacement"}, {"score": 0.0021844290159501313, "phrase": "nsp_policy"}, {"score": 0.0021049977753042253, "phrase": "stack-distance_algorithm"}], "paper_keywords": ["Memory management", " Replacement policy", " Stack distance", " Efficient algorithms"], "paper_abstract": "The Linear-Scan algorithm (1970), applicable to priority replacement policies, computes stack distances and the number of misses incurred on a given address trace, for all cache sizes, in time O(V) per access. Here, V is the number of distinct (virtual) items referenced within the trace. While the time bound was subsequently lowered to O(log V) for the Least Recently Used policy, no improvements have been reported for general priority policies. This work introduces the class of policies with nearly static priorities (NSP), which encompasses several known policies. The Min-Tree algorithm is proposed for NSP policies, whose performance is quite sensitive to the policy as well as to the address trace. Under suitable probabilistic assumptions, the expected time per access is O(log(2) V). Experimental evidence collected on a mix of 30 benchmarks shows that the Min-Tree algorithm can be significantly faster than Linear-Scan, for interesting policies such as OPT (or Belady), Least Frequently Used (LFU), and Most Recently Used (MRU). Min-Tree can be parallelized to run in time O(log V) using O(V/log V) processors, in the worst case. A more sophisticated Lazy Min-Tree algorithm is also developed with worst-case time per access. This bound applies, in particular, to the policies OPT, LFU, and Least Recently/Frequently Used (LRFU), for which the best previously known bound was O(V). Although random replacement is not an NSP policy, the framework developed in this work leads to a stack-distance algorithm with O(log V) expected time per access.", "paper_title": "Efficient Stack Distance Computation for a Class of Priority Replacement Policies", "paper_id": "WOS:000315038800004"}