{"auto_keywords": [{"score": 0.048548170765263736, "phrase": "memory_consistency_models"}, {"score": 0.00481495049065317, "phrase": "hardware-assisted_selective_self-invalidations"}, {"score": 0.004575272950516775, "phrase": "hardware_caches"}, {"score": 0.0044702911400353535, "phrase": "well-known_cache_coherence_problem"}, {"score": 0.00432733352307636, "phrase": "coherence_protocols"}, {"score": 0.004169519409162853, "phrase": "design_complexity"}, {"score": 0.004017437417375057, "phrase": "interconnect_behavior"}, {"score": 0.00372965096877929, "phrase": "software_implementation"}, {"score": 0.0036951530348821116, "phrase": "synchronization_primitives"}, {"score": 0.003644001325962353, "phrase": "software_controlled_invalidations"}, {"score": 0.0035273744062641606, "phrase": "minimal_hardware_support"}, {"score": 0.003320561182494713, "phrase": "novel_hybrid_software-hardware_coherence_mechanism"}, {"score": 0.003140401552000472, "phrase": "coherence_actions-self-invalidations"}, {"score": 0.003068242064611088, "phrase": "appropriate_times"}, {"score": 0.003011706511096639, "phrase": "bloom_filters"}, {"score": 0.00290173234777844, "phrase": "proposed_scheme"}, {"score": 0.002769902370872543, "phrase": "alp"}, {"score": 0.0027188259793109264, "phrase": "experimental_results"}, {"score": 0.002656327554326748, "phrase": "software-only_coherence_scheme"}, {"score": 0.0024091057723923857, "phrase": "unnecessary_invalidations"}, {"score": 0.002375714262344562, "phrase": "worst-case_performance"}, {"score": 0.002267708463966758, "phrase": "hybrid_scheme"}, {"score": 0.0022467024793003812, "phrase": "five_percent"}, {"score": 0.0022258906408344973, "phrase": "full_hardware_coherence"}], "paper_keywords": ["Multiprocessors", " cache coherence"], "paper_abstract": "Implementing shared memory consistency models on top of hardware caches gives rise to the well-known cache coherence problem. The standard solution involves implementing coherence protocols in hardware, an approach with some design complexity, hardware costs, and restrictions on interconnect behavior. However, for some memory consistency models, an alternative is to enforce coherence in the software implementation of synchronization primitives, using software controlled invalidations and forced writebacks. This requires minimal hardware support but gives less selective enforcement, which affects performance. This paper proposes a novel hybrid software-hardware coherence mechanism. In this scheme, software is responsible for triggering the coherence actions-self-invalidations and writebacks-at appropriate times while hardware uses Bloom filters to perform more selective self-invalidations. We evaluate the proposed scheme on applications from two different domains: the SPLASH-2 scientific and ALP multimedia benchmarks. Experimental results show that while the software-only coherence scheme shows less performance degradation than expected, it still unacceptably degrades performance for some of the benchmarks. Filtering out unnecessary invalidations improves the worst-case performance by as much as 93 percent, and brings the performance of the hybrid scheme within five percent of full hardware coherence for 10 out of 13 benchmarks, on a 32-core CMP with a shared L2 cache.", "paper_title": "Software-Based Cache Coherence with Hardware-Assisted Selective Self-Invalidations Using Bloom Filters", "paper_id": "WOS:000287668100004"}