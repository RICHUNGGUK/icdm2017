{"auto_keywords": [{"score": 0.039597617578365135, "phrase": "top-down_analyses"}, {"score": 0.03670597721111169, "phrase": "bolt"}, {"score": 0.007417884117788165, "phrase": "call_graph"}, {"score": 0.0067186659460143254, "phrase": "software_model"}, {"score": 0.006255573980978493, "phrase": "mapreduce_style_parallelism"}, {"score": 0.005851128719226285, "phrase": "intraprocedural_analysis"}, {"score": 0.005639226432299224, "phrase": "query_tree"}, {"score": 0.00481495049065317, "phrase": "top-down_interprocedural_analyses"}, {"score": 0.004759712475914958, "phrase": "central_theme"}, {"score": 0.0047268728636719725, "phrase": "scalable_program_analysis"}, {"score": 0.004694258759471649, "phrase": "core_idea"}, {"score": 0.004661868629458321, "phrase": "modular_analysis"}, {"score": 0.004597754207658615, "phrase": "procedure_boundaries"}, {"score": 0.0043399244218920675, "phrase": "modular_program_analysis"}, {"score": 0.004172874316207784, "phrase": "bottom-up_analysis"}, {"score": 0.003970792331925788, "phrase": "sequential_analysis"}, {"score": 0.003938776381588229, "phrase": "top-down_analysis"}, {"score": 0.0036496814103475174, "phrase": "bottom-up_analyses"}, {"score": 0.0035010071030752883, "phrase": "generic_framework"}, {"score": 0.003177154457204775, "phrase": "reachability_query"}, {"score": 0.003126160332248846, "phrase": "procedure_p_results"}, {"score": 0.0030266069356789365, "phrase": "key_insight"}, {"score": 0.0029166963619404723, "phrase": "map_stage"}, {"score": 0.0028566300478906916, "phrase": "enabled_queries"}, {"score": 0.0028172726995962173, "phrase": "reduce_stage"}, {"score": 0.002640636493247601, "phrase": "unique_feature"}, {"score": 0.0024636239664210433, "phrase": "bolt."}, {"score": 0.0024352948008307795, "phrase": "bolt_framework"}, {"score": 0.002412865625735725, "phrase": "intraprocedural_parameter"}, {"score": 0.0023522423291484212, "phrase": "test_suite"}], "paper_keywords": ["Parallelism", " Testing", " Verification", " Abstraction refinement", " Interprocedural analysis", " Software model checking"], "paper_abstract": "Modularity is a central theme in any scalable program analysis. The core idea in a modular analysis is to build summaries at procedure boundaries, and use the summary of a procedure to analyze the effect of calling it at its calling context. There are two ways to perform a modular program analysis: (1) top-down and (2) bottom-up. A bottom-up analysis proceeds upwards from the leaves of the call graph, and analyzes each procedure in the most general calling context and builds its summary. In contrast, a top-down analysis starts from the root of the call graph, and proceeds downward, analyzing each procedure in its calling context. Top-down analyses have several applications in verification and software model checking. However, traditionally, bottom-up analyses have been easier to scale and parallelize than top-down analyses. In this paper, we propose a generic framework, BOLT, which uses MapReduce style parallelism to scale top-down analyses. In particular, we consider top-down analyses that are demand driven, such as the ones used for software model checking. In such analyses, each intraprocedural analysis happens in the context of a reachability query. A query Q over a procedure P results in query tree that consists of sub-queries over the procedures called by P. The key insight in BOLT is that the query tree can be explored in parallel using MapReduce style parallelism - the map stage can be used to run a set of enabled queries in parallel, and the reduce stage can be used to manage inter-dependencies between queries. Iterating the map and reduce stages alternately, we can exploit the parallelism inherent in top-down analyses. Another unique feature of BOLT is that it is parameterized by the algorithm used for intraprocedural analysis. Several kinds of analyses, including may-analyses, must-analyses, and may-must-analyses can be parallelized using BOLT. We have implemented the BOLT framework and instantiated the intraprocedural parameter with a may-must-analysis. We have run BOLT on a test suite consisting of 45 Microsoft Windows device drivers and 150 safety properties. Our results demonstrate [GRAPHICS] an average speedup of 3.71x and a maximum speedup of 7.4x (with 8 cores) over a sequential analysis. Moreover, in several checks where a sequential analysis fails, BOLT is able to successfully complete its analysis.", "paper_title": "Parallelizing Top-Down Interprocedural Analyses", "paper_id": "WOS:000307582100020"}