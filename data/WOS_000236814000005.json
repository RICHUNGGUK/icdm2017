{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "genetic_programming"}, {"score": 0.004741167616693272, "phrase": "standard_tree-based_genetic_programming"}, {"score": 0.004596960835906736, "phrase": "structural_difficulty_problem"}, {"score": 0.003702702337768558, "phrase": "tree_structure"}, {"score": 0.0035076666315744525, "phrase": "numerical_distribution"}, {"score": 0.0034538466642399976, "phrase": "tree_shapes"}, {"score": 0.003246672441842787, "phrase": "different_tree-based_representation"}, {"score": 0.003051887221639784, "phrase": "structural_modification_operators"}, {"score": 0.0025151755329660837, "phrase": "structural_difficulty"}, {"score": 0.002401053532270901, "phrase": "large_step_size"}, {"score": 0.0023099082804523044, "phrase": "standard_genetic_programming"}, {"score": 0.0021544587602892466, "phrase": "fixed-arity_property"}], "paper_keywords": ["deletion", " genetic programming (GP)", " insertion", " operator", " representation", " structural difficulty"], "paper_abstract": "Standard tree-based genetic programming suffers from a structural difficulty problem in that it is unable to search effectively for solutions requiring very full or very narrow trees. This deficiency has been variously explained as a consequence of restrictions imposed by the tree structure or as a result of the numerical distribution of tree shapes. We show that by using a different tree-based representation and local (insertion and deletion) structural modification operators, that this problem can be almost eliminated even with trivial (stochastic hill-climbing) search methods, thus eliminating the above explanations. We argue, instead, that structural difficulty is a consequence of the large step size of the operators in standard genetic programming, which is itself a consequence of the fixed-arity property embodied in its representation.", "paper_title": "Representation and structural difficulty in genetic programming", "paper_id": "WOS:000236814000005"}