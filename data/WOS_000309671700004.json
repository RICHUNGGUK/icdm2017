{"auto_keywords": [{"score": 0.027972749529883253, "phrase": "victim_cache"}, {"score": 0.00481495049065317, "phrase": "selective_random"}, {"score": 0.00472955160788118, "phrase": "last-level_caches"}, {"score": 0.004631823134072564, "phrase": "important_performance_bottleneck"}, {"score": 0.004604271739916253, "phrase": "current_microprocessors"}, {"score": 0.004337573851941615, "phrase": "common_solution"}, {"score": 0.004286109357236311, "phrase": "cache_hierarchies"}, {"score": 0.004235266728470516, "phrase": "llc"}, {"score": 0.004025732081831055, "phrase": "conflict_misses"}, {"score": 0.003930738245421039, "phrase": "lru_algorithm"}, {"score": 0.0038956940500396086, "phrase": "temporal_locality"}, {"score": 0.003637161400331984, "phrase": "strict_lru_algorithm"}, {"score": 0.00345712586265106, "phrase": "low-cost_replacement_strategies"}, {"score": 0.0032958023701245022, "phrase": "proposed_strategies"}, {"score": 0.0032664003336950243, "phrase": "accessing_order"}, {"score": 0.003086164320124724, "phrase": "poor_locality"}, {"score": 0.00301327406964098, "phrase": "random_policy"}, {"score": 0.0028726027956447885, "phrase": "lru_policy"}, {"score": 0.0028469653622421828, "phrase": "performance_degradation"}, {"score": 0.002746677144043828, "phrase": "small_victim_cache"}, {"score": 0.002722160504975204, "phrase": "large_llc._experimental_results"}, {"score": 0.0026737800197678884, "phrase": "best_version"}, {"score": 0.002618418957665835, "phrase": "mpki_reduction"}, {"score": 0.002351260304188475, "phrase": "speedup_improvements"}, {"score": 0.002288834183396012, "phrase": "lru."}, {"score": 0.002248137100864451, "phrase": "dynamic_energy"}, {"score": 0.0021559645899673664, "phrase": "studied_algorithms"}, {"score": 0.0021431085940929783, "phrase": "hardware_complexity"}, {"score": 0.0021049977753042253, "phrase": "baseline_algorithm"}], "paper_keywords": ["Design", " Performance", " Last-Level Cache", " MRU-Tour", " replacement algorithm"], "paper_abstract": "Memory latency has become an important performance bottleneck in current microprocessors. This problem aggravates as the number of cores sharing the same memory controller increases. To palliate this problem, a common solution is to implement cache hierarchies with large or huge Last-Level Cache (LLC) organizations. LLC memories are implemented with a high number of ways (e.g., 16) to reduce conflict misses. Typically, caches have implemented the LRU algorithm to exploit temporal locality, but its performance goes away from the optimal as the number of ways increases. In addition, the implementation of a strict LRU algorithm is costly in terms of area and power. This article focuses on a family of low-cost replacement strategies, whose implementation scales with the number of ways while maintaining the performance. The proposed strategies track the accessing order for just a few blocks, which cannot be replaced. The victim is randomly selected among those blocks exhibiting poor locality. Although, in general, the random policy helps improving the performance, in some applications the scheme fails with respect to the LRU policy leading to performance degradation. This drawback can be overcome by the addition of a small victim cache of the large LLC. Experimental results show that, using the best version of the family without victim cache, MPKI reduction falls in between 10% and 11% compared to a set of the most representative state-of-the-art algorithms, whereas the reduction grows up to 22% with respect to LRU. The proposal with victim cache achieves speedup improvements, on average, by 4% compared to LRU. In addition, it reduces dynamic energy, on average, up to 8%. Finally, compared to the studied algorithms, hardware complexity is largely reduced by the baseline algorithm of the family.", "paper_title": "Combining Recency of Information with Selective Random and a Victim Cache in Last-Level Caches", "paper_id": "WOS:000309671700004"}