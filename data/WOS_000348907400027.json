{"auto_keywords": [{"score": 0.04166379544500555, "phrase": "multithreaded_tests"}, {"score": 0.007631091147102739, "phrase": "dynamic_analysis"}, {"score": 0.00481495049065317, "phrase": "deadlock_detection"}, {"score": 0.004721602309430702, "phrase": "thread-safe_multithreaded_libraries"}, {"score": 0.004648222388468414, "phrase": "daunting_task"}, {"score": 0.0044002186469797476, "phrase": "concurrency_bugs"}, {"score": 0.004298006360831255, "phrase": "usual_practice"}, {"score": 0.00424779023663186, "phrase": "software_testing"}, {"score": 0.004052701031142039, "phrase": "well-designed_multithreaded_test_cases"}, {"score": 0.0038817197332605647, "phrase": "sequential_tests"}, {"score": 0.00385141330111392, "phrase": "obvious_reasons"}, {"score": 0.003561017335579207, "phrase": "key_insight"}, {"score": 0.0033314049082500794, "phrase": "concurrent_execution"}, {"score": 0.003241203549050267, "phrase": "single_threaded_execution"}, {"score": 0.002973261772253616, "phrase": "multithreaded_test"}, {"score": 0.002881403688962202, "phrase": "library_implementation"}, {"score": 0.002591774486940531, "phrase": "omen"}, {"score": 0.0024822751900485758, "phrase": "dynamic_deadlock_detector"}, {"score": 0.0024245061478930558, "phrase": "synthesized_tests_results"}, {"score": 0.0021049977753042253, "phrase": "third-party_programmers"}], "paper_keywords": ["Deadlock detection", " dynamic analysis", " concurrency"], "paper_abstract": "Designing and implementing thread-safe multithreaded libraries can be a daunting task as developers of these libraries need to ensure that their implementations are free from concurrency bugs, including deadlocks. The usual practice involves employing software testing and/or dynamic analysis to detect. deadlocks. Their effectiveness is dependent on well-designed multithreaded test cases. Unsurprisingly, developing multithreaded tests is significantly harder than developing sequential tests for obvious reasons. In this paper, we address the problem of automatically synthesizing multithreaded tests that can induce deadlocks. The key insight to our approach is that a subset of the properties observed when a deadlock manifests in a concurrent execution can also be observed in a single threaded execution. We design a novel, automatic, scalable and directed approach that identifies these properties and synthesizes a deadlock revealing multithreaded test. The input to our approach is the library implementation under consideration and the output is a set of deadlock revealing multithreaded tests. We have implemented our approach as part of a tool, named OMEN1. OMEN is able to synthesize multithreaded tests on many multithreaded Java libraries. Applying a dynamic deadlock detector on the execution of the synthesized tests results in the detection of a number of deadlocks, including 35 real deadlocks in classes documented as thread-safe. Moreover, our experimental results show that dynamic analysis on multithreaded tests that are either synthesized randomly or developed by third-party programmers are ineffective in detecting the deadlocks.", "paper_title": "Multithreaded Test Synthesis for Deadlock Detection", "paper_id": "WOS:000348907400027"}