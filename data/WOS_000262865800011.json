{"auto_keywords": [{"score": 0.049380514366470105, "phrase": "run-time_reuse"}, {"score": 0.010729239531937499, "phrase": "new_data_block"}, {"score": 0.007528863668174798, "phrase": "existing_scratch-pad_architectures"}, {"score": 0.00481495049065317, "phrase": "scratch-pad_memory"}, {"score": 0.004772668787820885, "phrase": "embedded_applications"}, {"score": 0.004716867446922295, "phrase": "current_embedded_systems"}, {"score": 0.0046480280613451, "phrase": "data-dominated_applications"}, {"score": 0.0045667395804097136, "phrase": "tight_energy"}, {"score": 0.0045399591300830456, "phrase": "time_budget"}, {"score": 0.004500081299720827, "phrase": "-pad_memories"}, {"score": 0.004473689992665426, "phrase": "completely_software-controlled_memories"}, {"score": 0.00440838389264585, "phrase": "good_performance"}, {"score": 0.004382527989407013, "phrase": "energy_characteristics"}, {"score": 0.004280605517385785, "phrase": "standard_feature"}, {"score": 0.004012327233842635, "phrase": "accessed_data"}, {"score": 0.00396538027397194, "phrase": "application's_input"}, {"score": 0.0038845358652982286, "phrase": "scratch-pad_content"}, {"score": 0.003727739723753632, "phrase": "runtime_input"}, {"score": 0.0033727064185569396, "phrase": "runtime_accessed_data_blocks"}, {"score": 0.0033039051001591724, "phrase": "art_techniques"}, {"score": 0.0029891170767715955, "phrase": "system_architecture"}, {"score": 0.0029367553751816237, "phrase": "system's_scratch-pad"}, {"score": 0.0029109184943351503, "phrase": "processor's_compiler"}, {"score": 0.002843122846060439, "phrase": "run-time_data_reuse"}, {"score": 0.0027687330263687126, "phrase": "valuable_information"}, {"score": 0.0027282473656358784, "phrase": "exact_data_contents"}, {"score": 0.0024974364179629507, "phrase": "rectangular_data_blocks"}, {"score": 0.002475454965767354, "phrase": "application_domain"}, {"score": 0.0024536665097561073, "phrase": "proposed_architecture"}, {"score": 0.0024392472592460004, "phrase": "multimedia_applications"}, {"score": 0.0023894423300616255, "phrase": "linked_lists"}, {"score": 0.00237539960152304, "phrase": "multi-threaded_applications"}, {"score": 0.002320047233050843, "phrase": "energy-efficient_manner"}, {"score": 0.0022726706036523487, "phrase": "authors'_scratch-pad_accelerator_engine"}, {"score": 0.0022197067349433897, "phrase": "lower_normalised_energy_consumption"}, {"score": 0.0021174453532942115, "phrase": "cache_architectures"}, {"score": 0.0021049977753042253, "phrase": "energy_decrease"}], "paper_keywords": [""], "paper_abstract": "Current embedded systems are usually designed for data-dominated applications, but they have a tight energy and time budget. Scratch-pad memories are completely software-controlled memories with predictable behaviour and good performance and energy characteristics, thus they tend to become a standard feature in many embedded systems. However, their predictability is not helping if the application accesses its data dynamically, when the addresses of the accessed data depend on the application's input. In such cases, predetermining the scratch-pad content at design-time is not always possible as the compiler cannot predict the runtime input. Moreover, in this case, both data reuse and data placement in the scratch-pad are inefficient because chunks of data already stored cannot be efficently reused and combined with the runtime accessed data blocks. State-of-the art techniques copy each new data block to the scratch-pad without considering whether portions of them are already in it. Such dynamic temporal locality cannot be predicted or exploited by the compiler. The authors here present a system architecture, strongly connected to the system's scratch-pad and the processor's compiler, which is able to efficiently exploit run-time data reuse in the scratch-pad by being capable of holding valuable information, such as the exact data contents of the scratch-pad at runtime, and using it to do all the necessary operations for placing each new data block in scratch-pad. It is. ne tuned for applications with run-time reuse between rectangular data blocks. The application domain of the proposed architecture is multimedia applications with run-time reuse, certain applications with linked lists and multi-threaded applications. It operates in a time and energy-efficient manner when compared with existing scratch-pad architectures without the authors' scratch-pad accelerator engine, showing its higher normalised performance and lower normalised energy consumption. Experimental results show up to 2.5 times performance increase compared with existing scratch-pad architectures and 5 times compared with cache architectures and energy decrease up to 1.9 and 3.9 times, respectively.", "paper_title": "Low-power architecture with scratch-pad memory for accelerating embedded applications with run-time reuse", "paper_id": "WOS:000262865800011"}