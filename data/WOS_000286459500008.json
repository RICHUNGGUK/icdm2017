{"auto_keywords": [{"score": 0.04454153022265076, "phrase": "cnc"}, {"score": 0.010612319448707701, "phrase": "concurrent_collections"}, {"score": 0.004174064076143015, "phrase": "flexible_combinations"}, {"score": 0.004007083686875716, "phrase": "data_parallelism"}, {"score": 0.0034733518170738517, "phrase": "high-level_operations"}, {"score": 0.0033685408148574846, "phrase": "semantic_ordering_constraints"}, {"score": 0.0032008144731234265, "phrase": "cnc_graph"}, {"score": 0.003010496595090984, "phrase": "execution_semantics"}, {"score": 0.0027459678326877744, "phrase": "deterministic_computation"}, {"score": 0.002556359086441866, "phrase": "cnc_implementations"}, {"score": 0.0021049977753042253, "phrase": "lower-level_parallel_programming_models"}], "paper_keywords": ["Concurrent Collections (CnC)", " programming model", " parallel programming"], "paper_abstract": "We introduce the Concurrent Collections (CnC) programming model. CnC supports flexible combinations of task and data parallelism while retaining determinism. CnC is implicitly parallel, with the user providing high-level operations along with semantic ordering constraints that together form a CnC graph. We formally describe the execution semantics of CnC and prove that the model guarantees deterministic computation. We evaluate the performance of CnC implementations on several applications and show that CnC offers performance and scalability equivalent to or better than that offered by lower-level parallel programming models.", "paper_title": "Concurrent Collections", "paper_id": "WOS:000286459500008"}