{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "loop_transformations"}, {"score": 0.004689321062844586, "phrase": "huge_amounts"}, {"score": 0.004658426838467567, "phrase": "memory_accesses"}, {"score": 0.00462773520532301, "phrase": "large_memory_footprints"}, {"score": 0.004447766706144458, "phrase": "memory_footprint"}, {"score": 0.004418456827500267, "phrase": "high-level_memory_exploration_and_optimization_techniques"}, {"score": 0.0042325743185503825, "phrase": "memory_hierarchy"}, {"score": 0.004190796368475121, "phrase": "important_step"}, {"score": 0.004149429072483132, "phrase": "optimization_techniques"}, {"score": 0.004014452814186653, "phrase": "crucial_effect"}, {"score": 0.003987986947650714, "phrase": "later_data_memory_footprint_optimization_steps"}, {"score": 0.0037450707321601963, "phrase": "individual_objectives"}, {"score": 0.003708086804757529, "phrase": "main_one"}, {"score": 0.0036112323484812675, "phrase": "data_accesses"}, {"score": 0.0035402494307399733, "phrase": "data_memory_footprint"}, {"score": 0.0034250209479036392, "phrase": "lt_step"}, {"score": 0.003379983027734299, "phrase": "successive_optimization_steps"}, {"score": 0.003216285378512588, "phrase": "target_platform"}, {"score": 0.003020232503089429, "phrase": "first_ones"}, {"score": 0.0029903851294825023, "phrase": "global_trade-offs"}, {"score": 0.002931569771634119, "phrase": "mostly_one_solution"}, {"score": 0.0028930017387859804, "phrase": "best_locality"}, {"score": 0.002771115819151223, "phrase": "two-dimensional_trade-offs"}, {"score": 0.0025935242726503964, "phrase": "minimal_footprint"}, {"score": 0.0024678216843278806, "phrase": "data_reuse"}, {"score": 0.0024353398669404334, "phrase": "energy_reduction"}, {"score": 0.002395336706478158, "phrase": "control-flow_complexity"}, {"score": 0.00234043119560776, "phrase": "real-life_application"}, {"score": 0.0023096222276192194, "phrase": "qsdpcm"}, {"score": 0.002154392046210367, "phrase": "two-layer_memory_subsystem"}, {"score": 0.0021049977753042253, "phrase": "arm_platform"}], "paper_keywords": ["Algorithms", " Design", " Data transfer and storage exploration", " optimization", " loop transformations", " cost components", " trade-offs"], "paper_abstract": "Nowadays, multimedia systems deal with huge amounts of memory accesses and large memory footprints. To alleviate the impact of these accesses and reduce the memory footprint, high-level memory exploration and optimization techniques have been proposed. These techniques try to more efficiently utilize the memory hierarchy. An important step in these optimization techniques are loop transformations (LT). They have a crucial effect on later data memory footprint optimization steps and code generation. However, the state-of-the-art work has focused only on individual objectives. The main one in literature involves improving the locality of data accesses, and thus reducing the data memory footprint. It does not consider the trade-offs in the LT step in relation to successive optimization steps. Therefore, it is not globally efficient in mapping the application on the target platform. In this article we will discuss several trade-offs during the loop transformations. To our knowledge, we are the first ones considering these global trade-offs. Previous work always gave mostly one solution, having the best locality and thus the optimized memory footprint, even though some research in two-dimensional trade-offs in this area exists as well. We start from this state-of-the-art solution with minimal footprint. We show that by sacrificing the footprint, we can obtain gains in data reuse (crucial for energy reduction) and reduce the control-flow complexity. We demonstrate our approach on a real-life application, namely the QSDPCM video coder. At the end, we show that considering trade-offs for this application leads to 16% energy reduction in a two-layer memory subsystem and 10% cycle reduction on the ARM platform.", "paper_title": "Trade-Offs in Loop Transformations", "paper_id": "WOS:000266014400004"}