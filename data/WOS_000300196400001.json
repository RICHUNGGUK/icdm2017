{"auto_keywords": [{"score": 0.02869632570078602, "phrase": "time_logic"}, {"score": 0.02438178173756232, "phrase": "bisimulation_vacuity"}, {"score": 0.00481495049065317, "phrase": "temporal_logic"}, {"score": 0.004735414083933722, "phrase": "growing_interest"}, {"score": 0.004626255242038005, "phrase": "logic_specification"}, {"score": 0.004103212598803194, "phrase": "vacuous_satisfaction"}, {"score": 0.0038900709793274484, "phrase": "serious_problem"}, {"score": 0.0035908627899097407, "phrase": "syntactic_perturbation"}, {"score": 0.003381607100127276, "phrase": "single_occurrence"}, {"score": 0.0033256684464109242, "phrase": "armoni_et_al"}, {"score": 0.003195149953590668, "phrase": "semantically_invariant_changes"}, {"score": 0.0031109870010753663, "phrase": "additional_atomic_propositions"}, {"score": 0.0030595112110658675, "phrase": "syntactic_vacuity"}, {"score": 0.002988868585379496, "phrase": "linear_temporal_logic"}, {"score": 0.0029394074636168435, "phrase": "alternative_definition"}, {"score": 0.0027587851842693725, "phrase": "trace_vacuity"}, {"score": 0.0024875444192203485, "phrase": "common_pitfalls"}, {"score": 0.002470987929071079, "phrase": "prior_definitions"}, {"score": 0.002397833600728684, "phrase": "proper_and_nontrivial_extension"}], "paper_keywords": ["Verification", " Vacuity detection"], "paper_abstract": "There is a growing interest in techniques for detecting whether a logic specification is satisfied too easily, or vacuously. For example, the specification \"every request is eventually followed by an acknowledgment\" is satisfied vacuously by a system that never generates any requests. Vacuous satisfaction misleads users of model-checking into thinking that a system is correct. It is a serious problem in practice. There are several existing definitions of vacuity. Originally, Beer et al. [1997] formalized vacuity as insensitivity to syntactic perturbation (syntactic vacuity). This formulation captures the intuition of \"vacuity\" when applied to a single occurrence of a subformula. Armoni et al. argued that vacuity must be robust; not affected by semantically invariant changes, such as extending a model with additional atomic propositions. They show that syntactic vacuity is not robust for subformulas of linear temporal logic, and propose an alternative definition; trace vacuity. In this article, we continue this line of research. We show that trace vacuity is not robust for branching time logic. We further refine the notion of vacuity so that it applies uniformly to linear and branching time logic and does not suffer from the common pitfalls of prior definitions. Our new definition, bisimulation vacuity, is a proper and nontrivial extension of both syntactic and trace vacuity. We discuss the complexity of detecting bisimulation vacuity, and identify several practically-relevant subsets of CTL* for which vacuity detection problem is reducible to model-checking. We believe that in most practical applications, bisimulation vacuity provides both the desired theoretical properties and is tractable computationally.", "paper_title": "Robust Vacuity for Branching Temporal Logic", "paper_id": "WOS:000300196400001"}