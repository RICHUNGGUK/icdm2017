{"auto_keywords": [{"score": 0.03387373349383425, "phrase": "basic_blocks"}, {"score": 0.015352775432382724, "phrase": "instruction_scheduling"}, {"score": 0.00481495049065317, "phrase": "multiple-issue_processors"}, {"score": 0.004460703838987562, "phrase": "object_code"}, {"score": 0.004313996835376177, "phrase": "fundamental_problem"}, {"score": 0.004132411680987228, "phrase": "minimum_length_schedule"}, {"score": 0.0040735909648053105, "phrase": "basic_block"}, {"score": 0.00401560412621627, "phrase": "straight-line_sequence"}, {"score": 0.003920780681351006, "phrase": "single_entry_point"}, {"score": 0.00386496062825374, "phrase": "single_exit_point_-_subject"}, {"score": 0.003598247775847619, "phrase": "np"}, {"score": 0.0032382660477699695, "phrase": "provably_optimal_schedules"}, {"score": 0.003146652729098066, "phrase": "constraint_programming"}, {"score": 0.002887028262617443, "phrase": "preprocessing_techniques"}, {"score": 0.00283229915062791, "phrase": "constraint_model"}, {"score": 0.002725937660922418, "phrase": "spec"}, {"score": 0.002598543802992702, "phrase": "benchmark_suite"}, {"score": 0.0025614999929672, "phrase": "optimal_scheduler"}, {"score": 0.002316532084420729, "phrase": "reasonable_time_limit"}, {"score": 0.0022509365210787993, "phrase": "largest_basic_blocks"}, {"score": 0.0021049977753042253, "phrase": "best_previous_exact_approaches"}], "paper_keywords": [""], "paper_abstract": "Instruction scheduling is one of the most important steps for improving the performance of object code produced by a compiler. A fundamental problem that arises in instruction scheduling is to find a minimum length schedule for a basic block - a straight-line sequence of code with a single entry point and a single exit point - subject to precedence, latency, and resource constraints. Solving the problem exactly is NP-complete, and heuristic approaches are currently used in most compilers. In contrast, we present a scheduler that finds provably optimal schedules for basic blocks using techniques from constraint programming. In developing our optimal scheduler, the key to scaling up to large, real problems was in the development of preprocessing techniques for improving the constraint model. We experimentally evaluated our optimal scheduler on the SPEC 2000 integer and floating point benchmarks. On this benchmark suite, the optimal scheduler was very robust - all but a handful of the hundreds of thousands of basic blocks in our benchmark suite were solved optimally within a reasonable time limit - and scaled to the largest basic blocks, including basic blocks with up to 2600 instructions. This compares favorably to the best previous exact approaches.", "paper_title": "Optimal basic block instruction scheduling for multiple-issue processors using constraint programming", "paper_id": "WOS:000253753000004"}