{"auto_keywords": [{"score": 0.03843856552198327, "phrase": "abstract_transactional_event"}, {"score": 0.030345860767323218, "phrase": "transactional_events"}, {"score": 0.029725760425679804, "phrase": "sequencing_combinator"}, {"score": 0.00481495049065317, "phrase": "concurrent_programs"}, {"score": 0.004764220976404241, "phrase": "high-level_abstractions"}, {"score": 0.004566567411073082, "phrase": "compositional_reasoning"}, {"score": 0.004353948887538618, "phrase": "novel_concurrency_abstraction"}, {"score": 0.0043080553835735825, "phrase": "dubbed_transactional_events"}, {"score": 0.004217708394188058, "phrase": "first-class_synchronous_message-passing_events"}, {"score": 0.003957833102043277, "phrase": "simple_solutions"}, {"score": 0.003916098498242888, "phrase": "interesting_problems"}, {"score": 0.0038748022659578865, "phrase": "concurrent_programming"}, {"score": 0.003773449694108617, "phrase": "guarded_synchronous_receive"}, {"score": 0.003150900886669123, "phrase": "first-class_events"}, {"score": 0.0028944757265206332, "phrase": "expressive_power"}, {"score": 0.002575526825728026, "phrase": "constituent_events"}, {"score": 0.002365815362517737, "phrase": "non-deterministic_choice_combinator"}, {"score": 0.0022916428586256723, "phrase": "compositional_structure"}, {"score": 0.0021501863832966966, "phrase": "formal_semantics"}, {"score": 0.0021049977753042253, "phrase": "preliminary_implementation"}], "paper_keywords": ["concurrency", " synchronous message passing", " first-class events", " transactions", " monads"], "paper_abstract": "Concurrent programs require high-level abstractions in order to manage complexity and enable compositional reasoning. In this paper, we introduce a novel concurrency abstraction, dubbed transactional events, which combines first-class synchronous message-passing events with all-or-nothing transactions. This combination enables simple solutions to interesting problems in concurrent programming. For example, guarded synchronous receive can be implemented as an abstract transactional event, whereas in other languages it requires a non-abstract, non-modular protocol. Likewise, three-way rendezvous can also be implemented as an abstract transactional event, which is impossible using first-class events alone. Both solutions are easy to code and easy to reason about. The expressive power of transactional events arises from a sequencing combinator whose semantics enforces an all-or-nothing transactional property - either both of the constituent events synchronize in sequence or neither of them synchronizes. This sequencing combinator, along with a non-deterministic choice combinator, gives transactional events the compositional structure of a monad-with-plus. We provide a formal semantics for and a preliminary implementation of transactional events.", "paper_title": "Transactional events", "paper_id": "WOS:000202972400013"}