{"auto_keywords": [{"score": 0.042389058155836386, "phrase": "shared_protection_trees"}, {"score": 0.015348533997859688, "phrase": "protection_trees"}, {"score": 0.00481495049065317, "phrase": "self-repairing_protection_trees"}, {"score": 0.004185289462328125, "phrase": "shared_self-repairing_trees"}, {"score": 0.004085333687668526, "phrase": "unicast_mesh_networks"}, {"score": 0.00393032656248792, "phrase": "relatively_simple_approach"}, {"score": 0.00376293585033711, "phrase": "sub-second_restoration_times"}, {"score": 0.0037267132967205136, "phrase": "sub-optimal_redundancy_requirement"}, {"score": 0.0036730297909962142, "phrase": "self-repairing_nature"}, {"score": 0.0034159525504642656, "phrase": "dynamic_changes"}, {"score": 0.0033830587647810132, "phrase": "network_topology"}, {"score": 0.0031922210879462513, "phrase": "heuristic_algorithms"}, {"score": 0.003131023880006021, "phrase": "self-repairing_protection_tree"}, {"score": 0.002997572637726648, "phrase": "restorability_performance"}, {"score": 0.002968695624366393, "phrase": "shared_trees"}, {"score": 0.002855934865505357, "phrase": "specific_topologies"}, {"score": 0.002760778494680823, "phrase": "node_chains"}, {"score": 0.002707829887747594, "phrase": "extensive_simulations"}, {"score": 0.002655894070657161, "phrase": "randomly_generated_network_graphs"}, {"score": 0.002579847272930948, "phrase": "average_backup_path_length"}, {"score": 0.002530359917257626, "phrase": "optimal_tree_designs"}, {"score": 0.0025059724686541263, "phrase": "non-tree_designs"}, {"score": 0.0023644936731468252, "phrase": "protection_tree"}, {"score": 0.0023303871145705954, "phrase": "pre-designed_fixed-capacity_network"}, {"score": 0.0021987994275190314, "phrase": "different_network_loads"}, {"score": 0.0021670777282518424, "phrase": "utilization_levels"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Network protection", " Shared backup trees", " Mesh network restoration"], "paper_abstract": "Protection trees have been used in the past for restoring multicast and unicast traffic in networks in various failure scenarios. In this paper we focus on shared self-repairing trees for link protection in unicast mesh networks. Shared protection trees have been proposed as a relatively simple approach that is easy to reconfigure and could provide sub-second restoration times with sub-optimal redundancy requirement. The self-repairing nature of this class of protection trees may make them an attractive option for cases where dynamic changes in network topology or demand may occur. In this paper, we present heuristic algorithms to design a self-repairing protection tree for a given network. We study the restorability performance of shared trees and examine the limitations of such schemes in specific topologies, such as cases where long node chains exist. Using extensive simulations with thousands of randomly generated network graphs. We compare redundancy and average backup path length of shared protection trees with optimal tree designs and non-tree designs. We also apply our algorithms to the problem of designing the protection tree in a pre-designed fixed-capacity network, and study the performance of shared protection trees in this scenario under different network loads and link utilization levels. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Heuristic algorithms for designing self-repairing protection trees in mesh networks", "paper_id": "WOS:000269293200011"}