{"auto_keywords": [{"score": 0.03630170722275636, "phrase": "simpson"}, {"score": 0.00481495049065317, "phrase": "concurrent_algorithms"}, {"score": 0.00457696724030363, "phrase": "intricate_concurrent_programs"}, {"score": 0.004395040468458808, "phrase": "understandable_explanations"}, {"score": 0.004306795240631196, "phrase": "subsequent_readers"}, {"score": 0.004198965651975536, "phrase": "key_tool"}, {"score": 0.004135562737140424, "phrase": "sequential_programs"}, {"score": 0.003717656912608012, "phrase": "concurrent_programs"}, {"score": 0.0035337158050484474, "phrase": "formal_development"}, {"score": 0.0034803228231621687, "phrase": "non-trivial_parallel_program"}, {"score": 0.0033759367489122716, "phrase": "asynchronous_communication_mechanisms"}, {"score": 0.003144345057121367, "phrase": "earlier_proofs"}, {"score": 0.0027414948679658816, "phrase": "wider_application"}, {"score": 0.002501955525421155, "phrase": "initial_steps"}, {"score": 0.0024392031587145728, "phrase": "rely-guarantee_approach"}, {"score": 0.002214734873559146, "phrase": "atomicity_assumptions"}, {"score": 0.002126502291103601, "phrase": "clever_choice"}, {"score": 0.0021049977753042253, "phrase": "data_representations"}], "paper_keywords": ["Formal methods", " Concurrency", " Program proof", " Rely/Guarantee conditions", " Asynchronous Communication Mechanisms", " Simpson's Algorithm"], "paper_abstract": "Arguing that intricate concurrent programs satisfy their specifications can be difficult; recording understandable explanations is important for subsequent readers. Abstraction is a key tool even for sequential programs. The purpose here is to explore some abstractions that help readers (and writers) understand the design of concurrent programs. As an illustration, the paper presents a formal development of a non-trivial parallel program: Simpson's implementation of asynchronous communication mechanisms. Although the correctness of this \"4-slot algorithm\" has been shown elsewhere, earlier proofs fail to offer much insight into the design. From an understandable (yet formal) design history of this one algorithm, the techniques employed in the explanation are teased out for wider application. Among these techniques is using a \"fiction of atomicity\" as an aid to understanding the initial steps of development. The rely-guarantee approach is, here, combined with notions of read/write frames and \"phased\" specifications; furthermore, the atomicity assumptions implied by the rely/guarantee conditions are achieved by clever choice of data representations.", "paper_title": "Elucidating concurrent algorithms via layers of abstraction and reification", "paper_id": "WOS:000289524500004"}