{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "garbage_collectors"}, {"score": 0.004722254884093624, "phrase": "garbage-collected_languages"}, {"score": 0.004654157138015622, "phrase": "java"}, {"score": 0.004390192910013225, "phrase": "high-end_software"}, {"score": 0.0043477114072437316, "phrase": "real-time_embedded_applications"}, {"score": 0.004222707054751191, "phrase": "gc_implementation"}, {"score": 0.0040222701316738295, "phrase": "large_portion"}, {"score": 0.003964007795174772, "phrase": "world's_mission-critical_software"}, {"score": 0.0034760655218366, "phrase": "new_uniform_approach"}, {"score": 0.003310951184365485, "phrase": "hoare-style_logic"}, {"score": 0.0029458777184930896, "phrase": "implementation-specific_details"}, {"score": 0.0026466064623118105, "phrase": "assembly_implementations"}, {"score": 0.00252083258466447, "phrase": "coq"}, {"score": 0.002286781334850213, "phrase": "fully-verified_garbage-collected_program"}, {"score": 0.0021780349459687622, "phrase": "complex_mutator-collector_interaction"}, {"score": 0.002135995282374723, "phrase": "important_advance"}, {"score": 0.0021049977753042253, "phrase": "fully_certified_production-quality_gcs"}], "paper_keywords": ["garbage collection", " abstract data type", " assembly code verification", " separation logic", " proof-carrying code"], "paper_abstract": "Garbage-collected languages such as Java and C# are becoming more and more widely used in both high-end software and real-time embedded applications. The correctness of the GC implementation is essential to the reliability and security of a large portion of the world's mission-critical software. Unfortunately, garbage collectors-especially incremental and concurrent ones-are extremely hard to implement correctly. In this paper, we present a new uniform approach to verifying the safety of both a mutator and its garbage collector in Hoare-style logic. We define a formal garbage collector interface general enough to reason about a variety of algorithms while allowing the mutator to ignore implementation-specific details of the collector. Our approach supports collectors that require read and write barriers. We have used our approach to mechanically verify assembly implementations of mark-sweep, copying and incremental copying GCs in Coq, as well as sample mutator programs that can be linked with any of the GCs to produce a fully-verified garbage-collected program. Our work provides a foundation for reasoning about complex mutator-collector interaction and makes an important advance toward building fully certified production-quality GCs.", "paper_title": "A general framework for certifying garbage collectors and their mutators", "paper_id": "WOS:000253409000046"}