{"auto_keywords": [{"score": 0.045915154498909476, "phrase": "client's_data"}, {"score": 0.03218820616066921, "phrase": "proof-of-retrievability_protocol"}, {"score": 0.0315956183918944, "phrase": "client's_query"}, {"score": 0.00481495049065317, "phrase": "proof-of-retrievability_system"}, {"score": 0.004334657104697421, "phrase": "central_challenge"}, {"score": 0.0037556843869894566, "phrase": "verification_check"}, {"score": 0.003597514862052876, "phrase": "first_proof"}, {"score": 0.0034790978593553794, "phrase": "full_proofs"}, {"score": 0.003413183361838603, "phrase": "arbitrary_adversaries"}, {"score": 0.0033645655483989746, "phrase": "strongest_model"}, {"score": 0.003300816231397084, "phrase": "juels"}, {"score": 0.003269391314952989, "phrase": "kaliski"}, {"score": 0.003176899769744057, "phrase": "bls_signatures"}, {"score": 0.0031018195951638882, "phrase": "random_oracle_model"}, {"score": 0.0029569247903654477, "phrase": "server's_response"}, {"score": 0.00283229915062791, "phrase": "public_verifiability"}, {"score": 0.0025737890313763407, "phrase": "pseudorandom_functions"}, {"score": 0.0024652715040303416, "phrase": "standard_model"}, {"score": 0.0023388183537341213, "phrase": "even_shorter_server's_response"}, {"score": 0.002166349705365602, "phrase": "homomorphic_properties"}], "paper_keywords": [""], "paper_abstract": "In a proof-of-retrievability system, a data storage center must prove to a verifier that he is actually storing all of a client's data. The central challenge is to build systems that are both efficient and provably secure-that is, it should be possible to extract the client's data from any prover that passes a verification check. In this paper, we give the first proof-of-retrievability schemes with full proofs of security against arbitrary adversaries in the strongest model, that of Juels and Kaliski. Our first scheme, built from BLS signatures and secure in the random oracle model, features a proof-of-retrievability protocol in which the client's query and server's response are both extremely short. This scheme allows public verifiability: anyone can act as a verifier, not just the file owner. Our second scheme, which builds on pseudorandom functions (PRFs) and is secure in the standard model, allows only private verification. It features a proof-of-retrievability protocol with an even shorter server's response than our first scheme, but the client's query is long. Both schemes rely on homomorphic properties to aggregate a proof into one small authenticator value.", "paper_title": "Compact Proofs of Retrievability", "paper_id": "WOS:000320001700002"}