{"auto_keywords": [{"score": 0.04911004508284347, "phrase": "dense_matrix_factorizations"}, {"score": 0.015530094326166996, "phrase": "fault_tolerance"}, {"score": 0.015036142365234663, "phrase": "lu"}, {"score": 0.0048229775052145655, "phrase": "algorithm"}, {"score": 0.004565620708901037, "phrase": "cholesky"}, {"score": 0.004528436868224519, "phrase": "qr"}, {"score": 0.004418601451254075, "phrase": "scientific_applications"}, {"score": 0.0043114466990006334, "phrase": "linear_equations"}, {"score": 0.004224130367280183, "phrase": "least_squares"}, {"score": 0.003924121879214595, "phrase": "mean_time"}, {"score": 0.0037667216301666196, "phrase": "new_hybrid_approach"}, {"score": 0.0037055370870874484, "phrase": "algorithm-based_fault_tolerance"}, {"score": 0.0036008372531664726, "phrase": "matrix_factorizations_algorithms"}, {"score": 0.00357146811369898, "phrase": "fail-stop_failures"}, {"score": 0.003513443975425428, "phrase": "extreme_conditions"}, {"score": 0.003400198866111204, "phrase": "reliable_component"}, {"score": 0.003237116128682586, "phrase": "single_failure"}, {"score": 0.003158522476399068, "phrase": "generic_solution"}, {"score": 0.003107186371289819, "phrase": "right_factor"}, {"score": 0.002933973181012572, "phrase": "left_factor"}, {"score": 0.0027931892160452513, "phrase": "scalable_checkpointing_algorithm"}, {"score": 0.0027365364488693656, "phrase": "high_degree"}, {"score": 0.0026482660253173075, "phrase": "checksum_storage_leftover"}, {"score": 0.0026159017392986595, "phrase": "right_factor_protection"}, {"score": 0.002583931950389087, "phrase": "fault-tolerant_algorithms"}, {"score": 0.002541910967437926, "phrase": "hybrid_solution"}, {"score": 0.0024903420152789135, "phrase": "wide_range"}, {"score": 0.0024398167078355224, "phrase": "minor_modifications"}, {"score": 0.00241989408309933, "phrase": "theoretical_analysis"}, {"score": 0.002275557501858879, "phrase": "computing_units"}, {"score": 0.0022477377970612847, "phrase": "problem_size"}, {"score": 0.002229380111189829, "phrase": "experimental_results"}, {"score": 0.00219311232069446, "phrase": "qr_factorization"}, {"score": 0.0021049977753042253, "phrase": "negligible_overhead"}], "paper_keywords": ["Algorithms", " ABFT", " Fault-tolerance", " Fail-stop failure", " LU", " QR"], "paper_abstract": "Dense matrix factorizations, such as LU, Cholesky and QR, are widely used for scientific applications that require solving systems of linear equations, eigenvalues and linear least squares problems. Such computations are normally carried out on supercomputers, whose ever-growing scale induces a fast decline of the Mean Time To Failure (MTTF). This paper proposes a new hybrid approach, based on Algorithm-Based Fault Tolerance (ABFT), to help matrix factorizations algorithms survive fail-stop failures. We consider extreme conditions, such as the absence of any reliable component and the possibility of loosing both data and checksum from a single failure. We will present a generic solution for protecting the right factor, where the updates are applied, of all above mentioned factorizations. For the left factor, where the panel has been applied, we propose a scalable checkpointing algorithm. This algorithm features high degree of checkpointing parallelism and cooperatively utilizes the checksum storage leftover from the right factor protection. The fault-tolerant algorithms derived from this hybrid solution is applicable to a wide range of dense matrix factorizations, with minor modifications. Theoretical analysis shows that the fault tolerance overhead sharply decreases with the scaling in the number of computing units and the problem size. Experimental results of LU and QR factorization on the Kraken (Cray XT5) supercomputer validate the theoretical evaluation and confirm negligible overhead, with-and without-errors.", "paper_title": "Algorithm-based Fault Tolerance for Dense Matrix Factorizations", "paper_id": "WOS:000309350200022"}