{"auto_keywords": [{"score": 0.04417757503221303, "phrase": "error_configuration"}, {"score": 0.043390686241499915, "phrase": "initial_configuration"}, {"score": 0.04274518365190484, "phrase": "clp_program"}, {"score": 0.015242307979733449, "phrase": "imperative_programs"}, {"score": 0.01105115366790326, "phrase": "imperative_program"}, {"score": 0.00481495049065317, "phrase": "iterated_specialization"}, {"score": 0.004537994679433309, "phrase": "constraint_logic_programs"}, {"score": 0.004371306014298804, "phrase": "integer_variables"}, {"score": 0.004290262018446916, "phrase": "safety_properties"}, {"score": 0.003931402465972151, "phrase": "predicate_unsafe_equivalent"}, {"score": 0.0038584826729133022, "phrase": "safety_property"}, {"score": 0.003546664687195951, "phrase": "new_clp_program"}, {"score": 0.0031205339598919606, "phrase": "isp"}, {"score": 0.0030245745670310835, "phrase": "specialization_process"}, {"score": 0.0028237205895435733, "phrase": "different_strategies"}, {"score": 0.00260342914245402, "phrase": "different_operators"}, {"score": 0.00253916011199984, "phrase": "convex_hull_operators"}, {"score": 0.002507621527279442, "phrase": "predicate_definitions"}, {"score": 0.0024842242921857705, "phrase": "specialization_step"}, {"score": 0.0023927929565329873, "phrase": "program_safety"}, {"score": 0.0023704645774716743, "phrase": "iterated_specialization_process"}, {"score": 0.0023191700719613685, "phrase": "experimental_evaluation"}, {"score": 0.002283210560032092, "phrase": "significant_set"}, {"score": 0.002171836484200008, "phrase": "program_verification"}, {"score": 0.0021448505687807796, "phrase": "state-of-the-art_software_model_checkers"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Software model checking", " Constraint logic programming", " Program specialization", " Program transformation"], "paper_abstract": "We present a method for verifying properties of imperative programs by using techniques based on the specialization of constraint logic programs (CLP). We consider a class of imperative programs with integer variables and we focus our attention on safety properties, stating that no error configuration can be reached from any initial configuration. We introduce a CLP program I that encodes the interpreter of the language and defines a predicate unsafe equivalent to the negation of the safety property to be verified. Then, we specialize the CLP program I with respect to the given imperative program and the given initial and error configurations, with the objective of deriving a new CLP program I-sp that either contains the fact unsafe (and in this case the imperative program is proved unsafe) or contains no clauses with head unsafe (and in this case the imperative program is proved safe). If Isp enjoys neither of these properties, we iterate the specialization process with the objective of deriving a CLP program where we can prove unsafety or safety. During the various specializations we may apply different strategies for propagating information (either propagating forward from an initial configuration to an error configuration, or propagating backward from an error configuration to an initial configuration) and different operators (such as the widening and the convex hull operators) for generalizing predicate definitions. Each specialization step is guaranteed to terminate, but due to the undecidability of program safety, the iterated specialization process may not terminate. By an experimental evaluation carried out on a significant set of examples taken from the literature, we show that our method improves the precision of program verification with respect to state-of-the-art software model checkers. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Program verification via iterated specialization", "paper_id": "WOS:000344578700002"}