{"auto_keywords": [{"score": 0.038198640349319045, "phrase": "concurrent_objects"}, {"score": 0.00481495049065317, "phrase": "refinement_calculus_techniques"}, {"score": 0.0046993598473345395, "phrase": "stepwise_refinement"}, {"score": 0.004520132822496416, "phrase": "high-level_program"}, {"score": 0.004305639197085793, "phrase": "successively_refined_programs"}, {"score": 0.004181839414007266, "phrase": "correctness_proof"}, {"score": 0.004101281992566145, "phrase": "different_mechanisms"}, {"score": 0.00386876598761639, "phrase": "multi-threaded_shared-variable_concurrent_programs"}, {"score": 0.0035100601949451028, "phrase": "unbounded_number"}, {"score": 0.0034760655218366, "phrase": "concurrent_threads"}, {"score": 0.003392507399258166, "phrase": "established_correctness_criterion"}, {"score": 0.003215659239270654, "phrase": "method_execution"}, {"score": 0.002711842889248926, "phrase": "refinement_relation"}, {"score": 0.0026209522797963447, "phrase": "local_transformations"}, {"score": 0.00259554612218815, "phrase": "method_bodies"}, {"score": 0.0025207920578878894, "phrase": "previous_techniques"}, {"score": 0.0024963543716522087, "phrase": "atomicity_refinement"}, {"score": 0.002424450174817922, "phrase": "absorption_rule"}, {"score": 0.002320449502337321, "phrase": "concurrent_algorithms"}, {"score": 0.002286781334850213, "phrase": "atomic_operations"}, {"score": 0.002199363362666037, "phrase": "refinement_rules"}, {"score": 0.0021464286727045623, "phrase": "treiber's_concurrent_stack_algorithm"}, {"score": 0.002125621995442263, "phrase": "michael"}, {"score": 0.002105050439297236, "phrase": "scott"}], "paper_keywords": ["Refinement calculus", " Multi-threading", " Formal verification", " Linearizability"], "paper_abstract": "Stepwise refinement is a method for systematically transforming a high-level program into an efficiently executable one. A sequence of successively refined programs can also serve as a correctness proof, which makes different mechanisms in the program explicit. We present rules for refinement of multi-threaded shared-variable concurrent programs. We apply our rules to the problem of verifying linearizability of concurrent objects, that are accessed by an unbounded number of concurrent threads. Linearizability is an established correctness criterion for concurrent objects, which states that the effect of each method execution can be considered to occur atomically at some point in time between its invocation and response. We show how linearizability can be expressed in terms of our refinement relation, and present rules for establishing this refinement relation between programs by a sequence of local transformations of method bodies. Contributions include strengthenings of previous techniques for atomicity refinement, as well as an absorption rule, which is particularly suitable for reasoning about concurrent algorithms that implement atomic operations. We illustrate the application of the refinement rules by proving linearizability of Treiber's concurrent stack algorithm and Michael and Scott's concurrent queue algorithm.", "paper_title": "Using refinement calculus techniques to prove linearizability", "paper_id": "WOS:000305830700008"}