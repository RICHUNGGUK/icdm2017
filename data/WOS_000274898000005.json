{"auto_keywords": [{"score": 0.03300977049985164, "phrase": "mpi"}, {"score": 0.007141774484460468, "phrase": "openmp"}, {"score": 0.00481495049065317, "phrase": "fine-grained_multithreading_support_for_hybrid"}, {"score": 0.0046993598473345395, "phrase": "high-end_computing_systems"}, {"score": 0.004542158659382197, "phrase": "recent_advances"}, {"score": 0.00443308765153716, "phrase": "many-core_architectures"}, {"score": 0.004141365648080381, "phrase": "physical_node"}, {"score": 0.003925633992809873, "phrase": "large_number"}, {"score": 0.0038876302202924644, "phrase": "scientific_applications"}, {"score": 0.003757480190200645, "phrase": "mpi-everywhere_model"}, {"score": 0.0037030390595465673, "phrase": "high-end_parallel_systems"}, {"score": 0.0035443861412929006, "phrase": "future_machines"}, {"score": 0.003359647377874098, "phrase": "processing_element"}, {"score": 0.0033271045779740683, "phrase": "shared_caches"}, {"score": 0.00323134923196813, "phrase": "application_and_computer_scientists"}, {"score": 0.0032135897228360954, "phrase": "pthreads"}, {"score": 0.0031845067058084583, "phrase": "alternative_programming_models"}, {"score": 0.003092842645798083, "phrase": "address_spaces"}, {"score": 0.002917331114260319, "phrase": "intel_tbb"}, {"score": 0.002861062731782219, "phrase": "address_space"}, {"score": 0.0028058765785670546, "phrase": "efficient_support"}, {"score": 0.0027651847105654363, "phrase": "mpi_implementation"}, {"score": 0.0027383842769094354, "phrase": "mpi_messages"}, {"score": 0.0026986685585382347, "phrase": "multiple_threads"}, {"score": 0.002424450174817922, "phrase": "fully_thread-safe_mpi_implementation"}, {"score": 0.0023546121947302877, "phrase": "critical-section_granularity"}, {"score": 0.002320449502337321, "phrase": "coarse-grain_locks"}, {"score": 0.002297949552105756, "phrase": "fine-grain_locks"}, {"score": 0.0022756672722130424, "phrase": "lock-free_operations"}, {"score": 0.002242647404307089, "phrase": "correspondingly_increasing_levels"}, {"score": 0.0021780349459687622, "phrase": "performance_results"}, {"score": 0.002135995282374723, "phrase": "performance_implications"}, {"score": 0.0021049977753042253, "phrase": "different_approaches"}], "paper_keywords": ["MPI", " threads", " hybrid programming", " fine-grained locks"], "paper_abstract": "As high-end computing systems continue to grow in scale, recent advances in multi-and many-core architectures have pushed such growth toward more dense architectures, that is, more processing elements per physical node, rather than more physical nodes themselves. Although a large number of scientific applications have relied so far on an MPI-everywhere model for programming high-end parallel systems; this model may not be sufficient for future machines, given their physical constraints such as decreasing amounts of memory per processing element and shared caches. As a result, application and computer scientists are exploring alternative programming models that involve using MPI between address spaces and some other threaded model, such as OpenMP, Pthreads, or Intel TBB, within an address space. Such hybrid models require efficient support from an MPI implementation for MPI messages sent from multiple threads simultaneously. In this paper, we explore the issues involved in designing such an implementation. We present four approaches to building a fully thread-safe MPI implementation, with decreasing levels of critical-section granularity (from coarse-grain locks to fine-grain locks to lock-free operations) and correspondingly increasing levels of complexity. We present performance results that demonstrate the performance implications of the different approaches.", "paper_title": "FINE-GRAINED MULTITHREADING SUPPORT FOR HYBRID THREADED MPI PROGRAMMING", "paper_id": "WOS:000274898000005"}