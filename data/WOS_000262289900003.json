{"auto_keywords": [{"score": 0.0393245085488517, "phrase": "reconfigurable_hardware"}, {"score": 0.03829237293886379, "phrase": "pram_algorithms"}, {"score": 0.023625291480741786, "phrase": "gca"}, {"score": 0.00481495049065317, "phrase": "hirschberg's_pram-algorithm"}, {"score": 0.004329630571352367, "phrase": "classical_ca_model"}, {"score": 0.004228577663320847, "phrase": "ca_model"}, {"score": 0.003970439654470374, "phrase": "gca_model"}, {"score": 0.0038930368103015467, "phrase": "wide_range"}, {"score": 0.0038624981944755813, "phrase": "parallel_algorithms"}, {"score": 0.0036697319652557363, "phrase": "gca_implementation"}, {"score": 0.003405109584265324, "phrase": "hirschberg_et_al"}, {"score": 0.0033255627814855163, "phrase": "connected_components"}, {"score": 0.00320970209394799, "phrase": "different_numbers"}, {"score": 0.003134705849154561, "phrase": "maximum_parallelism"}, {"score": 0.0030254743224136247, "phrase": "implementation_complexities"}, {"score": 0.002966438503447793, "phrase": "fpga_cells"}, {"score": 0.0028743610212291727, "phrase": "experimental_evidence"}, {"score": 0.0022509878391826867, "phrase": "efficient_mappings"}, {"score": 0.002172486677172826, "phrase": "pram"}, {"score": 0.002155412043665635, "phrase": "gca_optimality_criteria"}, {"score": 0.0021049977753042253, "phrase": "memory_consumption"}], "paper_keywords": [""], "paper_abstract": "The GCA (Global Cellular Automata) model consists of a collection of cells which change their states synchronously depending on the states of their neighbors like in the classical CA model. In differentiation to the CA model the neighbors are not fixed and local, they are variable and global. The GCA model is applicable to a wide range of parallel algorithms, and it can be implemented on reconfigurable hardware. We discuss the GCA implementation of PRAM algorithms on reconfigurable hardware (Field Programmable Gate Array, FPGA), exemplified by the algorithm of Hirschberg et al., which determines the connected components of a given undirected graph. We provide two implementations with different numbers of cells: one with maximum parallelism and a compact one. We compare the implementation complexities, i.e. number of FPGA cells of both implementations, and thus present experimental evidence of our claims. The GCA(N) algorithm uses 3n cells with time complexity O(n log n), whereas the GCA(N(2)) algorithm uses n(n + 1) cells with time complexity O(log(2)n). The GCA(N) algorithm is more economic with respect to resources (logic x execution time) whereas the GCA(N(2)) algorithm can produce the result faster with a speedup of O((n + m)/log n). Further insights are that efficient mappings of PRAM algorithms onto GCA exist, and that PRAM and GCA optimality criteria differ because the latter takes memory consumption into account. This makes the GCA a parallel computational model and an implementation platform, thus narrowing the gap between theory and practice.", "paper_title": "IMPLEMENTING HIRSCHBERG'S PRAM-ALGORITHM FOR CONNECTED COMPONENTS ON A GLOBAL CELLULAR AUTOMATION", "paper_id": "WOS:000262289900003"}