{"auto_keywords": [{"score": 0.01571990123565291, "phrase": "haskell"}, {"score": 0.015390405415585397, "phrase": "higher-order_encodings"}, {"score": 0.015131854129309933, "phrase": "adequate_encodings"}, {"score": 0.011386378617039755, "phrase": "programming_languages"}, {"score": 0.009603919831556998, "phrase": "previous_approaches"}, {"score": 0.004672808182229058, "phrase": "functional_programming_languages"}, {"score": 0.004573842508130535, "phrase": "powerful_programming_tool"}, {"score": 0.004496174406337201, "phrase": "whole_classes"}, {"score": 0.00445783412174435, "phrase": "program_bugs"}, {"score": 0.004270960586542813, "phrase": "ill-formed_data"}, {"score": 0.0037719988989298983, "phrase": "different_behaviors"}, {"score": 0.0037398106866046972, "phrase": "different_representations"}, {"score": 0.0033454448643854525, "phrase": "language_processing_tools"}, {"score": 0.0032465423581390625, "phrase": "model-checking_tools"}, {"score": 0.003031287195944274, "phrase": "key_problem"}, {"score": 0.002954287204671032, "phrase": "encoding_binding_constructs"}, {"score": 0.002904040426340639, "phrase": "serious_limitations"}, {"score": 0.0028181504086563967, "phrase": "correctness_guarantees"}, {"score": 0.0026882700311968025, "phrase": "new_library"}, {"score": 0.0024461474613359994, "phrase": "straightforward_recursion"}, {"score": 0.002254624822004988, "phrase": "medium-sized_example"}, {"score": 0.0021231452870210965, "phrase": "strong_correctness_guarantees"}, {"score": 0.0021049977753042253, "phrase": "compile_time"}], "paper_keywords": ["Languages", " Design", " Theory"], "paper_abstract": "Adequate encodings are a powerful programming tool, which eliminate whole classes of program bugs: they ensure that a program cannot generate ill-formed data, because such data is not part of the representation; and they also ensure that a program is well-defined, meaning that it cannot have different behaviors on different representations of the same piece of data. Unfortunately, it has proven difficult to define adequate encodings of programming languages themselves. Such encodings would be very useful in language processing tools such as interpreters, compilers, model-checking tools, etc., as these systems are often difficult to get correct. The key problem in representing programming languages is in encoding binding constructs; previous approaches have serious limitations in either the operations they allow or the correctness guarantees they make. In this paper, we introduce a new library for Haskell that allows the user to define and use higher-order encodings, a powerful technique for representing bindings. Our library allows straightforward recursion on bindings using pattern-matching, which is not possible in previous approaches. We then demonstrate our library on a medium-sized example, lambda-lifting, showing how our library can be used to make strong correctness guarantees at compile time.", "paper_title": "Hobbits for Haskell: A Library for Higher-Order Encodings in Functional Programming Languages", "paper_id": "WOS:000299326600004"}