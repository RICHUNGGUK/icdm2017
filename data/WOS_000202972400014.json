{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrent_functional_programs"}, {"score": 0.04967088836874542, "phrase": "transient_faults"}, {"score": 0.0046928556063004214, "phrase": "large-scale_software_systems"}, {"score": 0.004344755264641137, "phrase": "meaningful_semantics"}, {"score": 0.004307700591183651, "phrase": "safe_re-execution"}, {"score": 0.004270960586542813, "phrase": "multi-threaded_code"}, {"score": 0.003629291866667764, "phrase": "meaningful_earlier_state"}, {"score": 0.003522027550662857, "phrase": "data_inconsistencies"}, {"score": 0.003331134183901191, "phrase": "consistent_global_checkpoint"}, {"score": 0.0032604908177429493, "phrase": "thread_interactions"}, {"score": 0.003218823621926739, "phrase": "dynamic_property"}, {"score": 0.0030573959252626695, "phrase": "safe_and_efficient_checkpointing_mechanism"}, {"score": 0.003031287195944274, "phrase": "concurrent_ml"}, {"score": 0.0030054137191181693, "phrase": "cml"}, {"score": 0.0028302635493019867, "phrase": "new_linguistic_abstraction"}, {"score": 0.0027347937102326285, "phrase": "per-thread_monitors"}, {"score": 0.0026767629720554397, "phrase": "globally_consistent_checkpoints"}, {"score": 0.0026538960171433985, "phrase": "safe_global_states"}, {"score": 0.002608744950946475, "phrase": "lightweight_monitoring"}, {"score": 0.002586457551025025, "phrase": "communication_events"}, {"score": 0.0025315664299815537, "phrase": "message-passing_operations"}, {"score": 0.0024884913795612707, "phrase": "shared_variables"}, {"score": 0.0023839754995935184, "phrase": "server-style_cml_applications"}, {"score": 0.0023434058350520763, "phrase": "web_server"}, {"score": 0.0023134312557290043, "phrase": "win-dowing_toolkit"}, {"score": 0.002264321283759897, "phrase": "overheads_to_use"}, {"score": 0.0021322775033565805, "phrase": "viable_mechanism"}, {"score": 0.0021049977753042253, "phrase": "safe_checkpoints"}], "paper_keywords": ["concurrent programming", " error recovery", " checkpointing", " transactions", " Concurrent ML", " exception handling"], "paper_abstract": "Transient faults that arise in large-scale software systems can often be repaired by re-executing the code in which they occur. Ascribing a meaningful semantics for safe re-execution in multi-threaded code is not obvious, however. For a thread to correctly re-execute a region of code, it must ensure that all other threads which have witnessed its unwanted effects within that region are also reverted to a meaningful earlier state. If not done properly, data inconsistencies and other undesirable behavior may result. However, automatically determining what constitutes a consistent global checkpoint is not straightforward since thread interactions are a dynamic property of the program. In this paper, we present a safe and efficient checkpointing mechanism for Concurrent ML (CML) that can be used to recover from transient faults. We introduce a new linguistic abstraction called stabilizers that permits the specification of per-thread monitors and the restoration of globally consistent checkpoints. Safe global states are computed through lightweight monitoring of communication events among threads (e.g. message-passing operations or updates to shared variables). Our experimental results on several realistic, multithreaded, server-style CML applications, including a web server and a win-dowing toolkit, show that the overheads to use stabilizers are small, and lead us to conclude that they are a viable mechanism for defining safe checkpoints in concurrent functional programs.", "paper_title": "Stabilizers: A modular checkpointing abstraction for concurrent functional programs", "paper_id": "WOS:000202972400014"}