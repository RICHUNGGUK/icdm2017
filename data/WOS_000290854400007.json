{"auto_keywords": [{"score": 0.038959775584256603, "phrase": "rcdc"}, {"score": 0.00481495049065317, "phrase": "deterministic_execution"}, {"score": 0.004601606675066839, "phrase": "multithreaded_programs"}, {"score": 0.004569630374630379, "phrase": "recent_work"}, {"score": 0.004522080178250592, "phrase": "deterministic_multiprocessor_architectures"}, {"score": 0.004428452434981208, "phrase": "runtime_systems"}, {"score": 0.004351905364003354, "phrase": "current_hardware"}, {"score": 0.0042617859335771615, "phrase": "strong_memory-ordering_properties"}, {"score": 0.004202741104973709, "phrase": "memory_ordering"}, {"score": 0.004101366149219787, "phrase": "higher_performance"}, {"score": 0.004072851768196397, "phrase": "shared_memory_multiprocessors"}, {"score": 0.003933214459874487, "phrase": "strong_memory_ordering"}, {"score": 0.0038383157378810277, "phrase": "relaxed_memory_ordering"}, {"score": 0.0037719307016238998, "phrase": "faster_deterministic_execution"}, {"score": 0.0035795609511543023, "phrase": "relaxed_memory_orderings"}, {"score": 0.003542276457435362, "phrase": "high-performance_deterministic_execution"}, {"score": 0.003234934827553253, "phrase": "data-race-free-based_memory_models"}, {"score": 0.0031460008367642785, "phrase": "java"}, {"score": 0.0027645030021576926, "phrase": "precise_instruction_counting"}, {"score": 0.002678944072162297, "phrase": "runtime_system"}, {"score": 0.0026051114364288126, "phrase": "arbitrary_programs"}, {"score": 0.0025510720021028107, "phrase": "parsec_benchmarks"}, {"score": 0.0024292886883655693, "phrase": "nondeterministic_execution"}, {"score": 0.002297197290236013, "phrase": "tso"}, {"score": 0.0021646872269755067, "phrase": "extra_relaxation"}, {"score": 0.002119764367112061, "phrase": "software-only_implementation"}], "paper_keywords": ["Reliability", " Design", " Performance"], "paper_abstract": "Providing deterministic execution significantly simplifies the debugging, testing, replication, and deployment of multithreaded programs. Recent work has developed deterministic multiprocessor architectures as well as compiler and runtime systems that enforce determinism in current hardware. Such work has incidentally imposed strong memory-ordering properties. Historically, memory ordering has been relaxed in favor of higher performance in shared memory multiprocessors and, interestingly, determinism exacerbates the cost of strong memory ordering. Consequently, we argue that relaxed memory ordering is vital to achieving faster deterministic execution. This paper introduces RCDC, a deterministic multiprocessor architecture that takes advantage of relaxed memory orderings to provide high-performance deterministic execution with low hardware complexity. RCDC has two key innovations: a hybrid HW/SW approach to enforcing determinism; and a new deterministic execution strategy that leverages data-race-free-based memory models (e. g., the models for Java and C++) to improve performance and scalability without sacrificing determinism, even in the presence of races. In our hybrid HW/SW approach, the only hardware mechanisms required are software-controlled store buffering and support for precise instruction counting; we do not require speculation. A runtime system uses these mechanisms to enforce determinism for arbitrary programs. We evaluate RCDC using PARSEC benchmarks and show that relaxing memory ordering leads to performance and scalability close to nondeterministic execution without requiring any form of speculation. We also compare our new execution strategy to one based on TSO (total-store-ordering) and show that some applications benefit significantly from the extra relaxation. We also evaluate a software-only implementation of our new deterministic execution strategy.", "paper_title": "RCDC: A Relaxed Consistency Deterministic Computer", "paper_id": "WOS:000290854400007"}