{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "automated_distributed_implementation"}, {"score": 0.004780030485538593, "phrase": "component-based_models"}, {"score": 0.004728122501822142, "phrase": "distributed_systems"}, {"score": 0.004132237700479874, "phrase": "application_software"}, {"score": 0.004114812941968166, "phrase": "behavior"}, {"score": 0.003969967055648131, "phrase": "bip"}, {"score": 0.0039268117782861696, "phrase": "well-founded_component-based_framework"}, {"score": 0.003898307690037192, "phrase": "high-level_multi-party_interactions"}, {"score": 0.003704467870496114, "phrase": "arbitrary_bip_model"}, {"score": 0.0035849585026689573, "phrase": "distributed_execution_platforms"}, {"score": 0.003357343256340741, "phrase": "synchronous_multiparty_interactions"}, {"score": 0.003260860308644701, "phrase": "distributed_controllers"}, {"score": 0.003144134096095217, "phrase": "user-defined_partition"}, {"score": 0.0030315735229977958, "phrase": "distributed_algorithm"}, {"score": 0.0028286597212365504, "phrase": "functional_properties"}, {"score": 0.0027978827655799495, "phrase": "initial_bip_model"}, {"score": 0.0026105697442146357, "phrase": "distributed_executable_code"}, {"score": 0.002582159550634798, "phrase": "proposed_method"}, {"score": 0.0024268966855267153, "phrase": "tcp_sockets"}, {"score": 0.0024092539025697014, "phrase": "conventional_distributed_communication"}, {"score": 0.0023485057246680854, "phrase": "multi-processor_platforms"}, {"score": 0.002256117165288155, "phrase": "multi-core_platforms"}, {"score": 0.0021992217442375157, "phrase": "experimental_results"}, {"score": 0.002183230464873613, "phrase": "different_design_choices"}, {"score": 0.0021049977753042253, "phrase": "distributed_conflict_resolution"}], "paper_keywords": ["Component-based modeling", " Automated transformation", " Distributed systems", " BIP", " Correctness-by-construction", " Committee coordination", " Conflict resolution"], "paper_abstract": "Although distributed systems are widely used nowadays, their implementation and deployment are still time-consuming, error-prone, and hardly predictable tasks. In this paper, we propose a method for producing automatically efficient and correct-by-construction distributed implementations from a model of the application software in Behavior, Interaction, Priority (BIP). BIP is a well-founded component-based framework encompassing high-level multi-party interactions for synchronizing components (e.g., rendezvous and broadcast) and dynamic priorities for scheduling between interactions. Our method transforms an arbitrary BIP model into a Send/Receive BIP model that is directly implementable on distributed execution platforms. The transformation consists in (1) breaking the atomicity of actions in components by replacing synchronous multiparty interactions with asynchronous Send/Receive interactions; (2) inserting distributed controllers that coordinate the execution of interactions according to a user-defined partition of interactions, and (3) adding a distributed algorithm for handling conflicts between controllers. The obtained Send/Receive BIP model is proven observationally equivalent to its corresponding initial model. Hence, all functional properties of the initial BIP model are preserved by construction in the implementation. Moreover, the obtained Send/Receive BIP model can be used to automatically derive distributed executable code. The proposed method is fully implemented. Currently, it is possible to generate C++ implementations for (1) TCP sockets for conventional distributed communication, (2) MPI for multi-processor platforms, and (3) POSIX threads for deployment on multi-core platforms. We present four case studies and report experimental results for different design choices including partition of interactions and choice of algorithm for distributed conflict resolution.", "paper_title": "A framework for automated distributed implementation of component-based models", "paper_id": "WOS:000309212600004"}