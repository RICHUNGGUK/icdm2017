{"auto_keywords": [{"score": 0.01239486557211492, "phrase": "interpolation_step"}, {"score": 0.00481495049065317, "phrase": "considerable_relevance"}, {"score": 0.003916098498242888, "phrase": "table_lookup"}, {"score": 0.003614895644619489, "phrase": "combinational_logic"}, {"score": 0.0035197152758635344, "phrase": "field-programmable_gate_array"}, {"score": 0.003473119986636377, "phrase": "fpga"}, {"score": 0.002537880772794665, "phrase": "existing_methods"}, {"score": 0.002405853977978678, "phrase": "significantly_lower_memory_resource_utilization"}, {"score": 0.0021620042653528846, "phrase": "required_accuracy"}, {"score": 0.0021049977753042253, "phrase": "existing_techniques"}], "paper_keywords": ["Field-programmable gate arrays (FPGAs)", " floating point arithmetic", " logarithmic arithmetic", " VLSI"], "paper_abstract": "The realization or functions such as log() and antilog() in hardware is of considerable relevance, due to their importance in several computing applications. In this paper, we present an approach to compute log() and antilog() in hardware. Our approach is based on a table lookup, followed by an interpolation step. The interpolation step is implemented in combinational logic, in a field-programmable gate array (FPGA), resulting in an area-efficient, fast design. The novelty of our approach lies in the fact that we perform interpolation efficiently, without the need to perform multiplication or division, and our method performs both the logo and antilog() operation using the same hardware architecture. We compare our work with existing methods. and show that our approach results in significantly lower memory resource utilization, for the same approximation errors. Also our method scales very well with an increase in the required accuracy, compared to existing techniques.", "paper_title": "A Fast Hardware Approach for Approximate, Efficient Logarithm and Antilogarithm Computations", "paper_id": "WOS:000262778500010"}