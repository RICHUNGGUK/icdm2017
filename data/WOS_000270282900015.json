{"auto_keywords": [{"score": 0.044467014408216064, "phrase": "manual_debugging"}, {"score": 0.010281092050557328, "phrase": "naive_approach"}, {"score": 0.008487237288646306, "phrase": "robust_approach"}, {"score": 0.00481495049065317, "phrase": "interactive_fault_localization"}, {"score": 0.004773904938276846, "phrase": "test_information"}, {"score": 0.004672808182229058, "phrase": "time-consuming_task"}, {"score": 0.00385368199735867, "phrase": "interactive_fault-localization_framework"}, {"score": 0.0037558704408683905, "phrase": "automated_approaches"}, {"score": 0.003477029725200912, "phrase": "statements'_suspicions"}, {"score": 0.003359816816853762, "phrase": "execution_information"}, {"score": 0.003331134183901191, "phrase": "test_cases"}, {"score": 0.003288567185099276, "phrase": "feedback_information"}, {"score": 0.003218823621926739, "phrase": "earlier_checking_points"}, {"score": 0.0030705342386533083, "phrase": "initial_implementation"}, {"score": 0.0028181504086563967, "phrase": "faulty_statement"}, {"score": 0.0027583557819362034, "phrase": "checking_point"}, {"score": 0.002665305036900055, "phrase": "debugging_process"}, {"score": 0.0024356742694508662, "phrase": "fault-localization_process"}, {"score": 0.002264321283759897, "phrase": "existing_fault-localization_approaches"}, {"score": 0.0021322775033565805, "phrase": "wrong_estimation"}, {"score": 0.0021049977753042253, "phrase": "checking_points"}], "paper_keywords": ["debugging", " fault localization", " interactive approach"], "paper_abstract": "Debugging is a time-consuming task in software development. Although various automated approaches have been proposed, they are not erective enough. On the other hand, in manual debugging, developers have difficulty in choosing breakpoints. To address these problems and help developers locate faults erectively, we propose an interactive fault-localization framework, combining the benefits of automated approaches and manual debugging. Before the fault is found, this framework continuously recommends checking points based on statements' suspicions, which are calculated according to the execution information of test cases and the feedback information from the developer at earlier checking points. Then we propose a naive approach, which is an initial implementation of this framework. However, with this naive approach or manual debugging, developers' wrong estimation of whether the faulty statement is executed before the checking point (break point) may make the debugging process fail. So we propose another robust approach based on this framework, handling cases where developers make mistakes during the fault-localization process. We performed two experimental studies and the results show that the two interactive approaches are quite erective compared with existing fault-localization approaches. Moreover, the robust approach can help developers find faults when they make wrong estimation at some checking points.", "paper_title": "Interactive Fault Localization Using Test Information", "paper_id": "WOS:000270282900015"}