{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "backward_compatibility"}, {"score": 0.00476323161560059, "phrase": "class_libraries"}, {"score": 0.004561826854638056, "phrase": "old_version"}, {"score": 0.004321952227344232, "phrase": "new_version"}, {"score": 0.004252469672259375, "phrase": "existing_clients"}, {"score": 0.004206767038617782, "phrase": "formal_reasoning"}, {"score": 0.004094639048362357, "phrase": "adequate_semantic_model"}, {"score": 0.003879234831701853, "phrase": "object-oriented_setting"}, {"score": 0.0036553070575015344, "phrase": "complex_interface"}, {"score": 0.0036159990127332315, "phrase": "library_implementations"}, {"score": 0.003407214479510987, "phrase": "fully_abstract_trace-based_semantics"}, {"score": 0.0033163269450817716, "phrase": "object-oriented_languages"}, {"score": 0.003107935254560724, "phrase": "standard_operational_semantics"}, {"score": 0.0029126002350975634, "phrase": "client_context"}, {"score": 0.0028043588777213533, "phrase": "interaction_labels"}, {"score": 0.002613870237087035, "phrase": "data_representation"}, {"score": 0.0025440911575156755, "phrase": "support_class_hiding"}, {"score": 0.0024896081630179194, "phrase": "fully_abstract_package_denotations"}, {"score": 0.0023970487263732737, "phrase": "trace_semantics"}, {"score": 0.002345707314211983, "phrase": "specialized_simulation_relations"}, {"score": 0.0023079225317714815, "phrase": "enhanced_operational_semantics"}, {"score": 0.002270745003370529, "phrase": "simulation_relations"}, {"score": 0.002222102813520549, "phrase": "proof_method"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Full abstraction", " Class libraries", " Trace semantics", " Contextual preorder", " Backward compatibility"], "paper_abstract": "Backward compatibility is the property that an old version of a library can safely be replaced by a new version without breaking existing clients. Formal reasoning about backward compatibility requires an adequate semantic model to compare the behavior of two library implementations. In the object-oriented setting with inheritance and callbacks, such a model must account for the complex interface between library implementations and clients. In this paper, we develop a fully abstract trace-based semantics for class libraries in object-oriented languages, in particular for Java-like sealed packages. Our approach enhances a standard operational semantics such that the change of control between the library and the client context is made explicit in terms of interaction labels. By using traces over these labels, we abstract from the data representation in the heap, support class hiding, and provide fully abstract package denotations. Soundness and completeness of the trace semantics is proven using specialized simulation relations on the enhanced operational semantics. The simulation relations also provide a proof method for reasoning about backward compatibility. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "A fully abstract trace-based semantics for reasoning about backward compatibility of class libraries", "paper_id": "WOS:000338598100004"}