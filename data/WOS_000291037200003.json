{"auto_keywords": [{"score": 0.031098289909574556, "phrase": "cumulative_constraint"}, {"score": 0.00481495049065317, "phrase": "cumulative_propagator"}, {"score": 0.004748740786945996, "phrase": "global_cumulative_constraint"}, {"score": 0.004640398886726948, "phrase": "cumulative_resources"}, {"score": 0.004597754207658615, "phrase": "scheduling_problems"}, {"score": 0.004555499634179394, "phrase": "finite_domain"}, {"score": 0.004349955692802962, "phrase": "great_deal"}, {"score": 0.0042506731642425275, "phrase": "new_stronger_and_faster_filtering_techniques"}, {"score": 0.00398452530840582, "phrase": "limited_cases"}, {"score": 0.003822263046602146, "phrase": "\"lazy_clause_generation\"_hybrid"}, {"score": 0.0036665842836420223, "phrase": "finite_domain_propagation_engine"}, {"score": 0.0035663245542174224, "phrase": "advanced_sat_technology"}, {"score": 0.0034368818187904744, "phrase": "sat_model"}, {"score": 0.003389557201018519, "phrase": "fd_problem"}, {"score": 0.0031918759137610523, "phrase": "sat_explanation"}, {"score": 0.0031625006830124512, "phrase": "autonomous_search_capabilities"}, {"score": 0.002991823455621222, "phrase": "lazy_clause_generation"}, {"score": 0.0028698706191651155, "phrase": "highly_competitive_version"}, {"score": 0.0027784560880013886, "phrase": "component_parts"}, {"score": 0.002418453525649304, "phrase": "global_cumulative_constraints"}, {"score": 0.0022563011263787847, "phrase": "constrained_project_scheduling_problems"}, {"score": 0.002174303033371867, "phrase": "substantial_number"}, {"score": 0.002154272413276506, "phrase": "open_problems"}, {"score": 0.0021245712108461227, "phrase": "well-established_psplib_benchmark_library"}, {"score": 0.0021049977753042253, "phrase": "resource-constrained_project_scheduling_problems"}], "paper_keywords": ["Cumulative constraint", " Explanations", " Nogood learning", " Lazy clause generation", " Resource-constrained project scheduling problem"], "paper_abstract": "The global cumulative constraint was proposed for modelling cumulative resources in scheduling problems for finite domain (FD) propagation. Since that time a great deal of research has investigated new stronger and faster filtering techniques for cumulative, but still most of these techniques only pay off in limited cases or are not scalable. Recently, the \"lazy clause generation\" hybrid solving approach has been devised which allows a finite domain propagation engine possible to take advantage of advanced SAT technology, by \"lazily\" creating a SAT model of an FD problem as computation progresses. This allows the solver to make use of SAT explanation and autonomous search capabilities. In this article we show how, once we use lazy clause generation, modelling the cumulative constraint by decomposition creates a highly competitive version of cumulative. Using decomposition into component parts automatically makes the propagator incremental and able to explain itself. We then show how, using the insights from the behaviour of the decomposition, we can create global cumulative constraints that explain their propagation. We compare these approaches to explaining the cumulative constraint on resource constrained project scheduling problems. All our methods are able to close a substantial number of open problems from the well-established PSPlib benchmark library of resource-constrained project scheduling problems.", "paper_title": "Explaining the cumulative propagator", "paper_id": "WOS:000291037200003"}