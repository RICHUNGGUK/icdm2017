{"auto_keywords": [{"score": 0.04805787983294612, "phrase": "embedded_security_sublanguage"}, {"score": 0.00481495049065317, "phrase": "secure_information_flow"}, {"score": 0.004513450434595191, "phrase": "information-flow_policies"}, {"score": 0.00441718685609235, "phrase": "standard_haskell_programming_language"}, {"score": 0.004261268957001927, "phrase": "useful_information-flow_control_mechanisms"}, {"score": 0.004081385289516914, "phrase": "run-time_code_privileges"}, {"score": 0.0038810583785936505, "phrase": "base_language"}, {"score": 0.0037171648669537287, "phrase": "redundant_work"}, {"score": 0.003637822529522622, "phrase": "new_languages"}, {"score": 0.003459191419478298, "phrase": "security-typed_languages"}, {"score": 0.00333697550984782, "phrase": "great_flexibility"}, {"score": 0.0032190636347671675, "phrase": "security-policy_frameworks"}, {"score": 0.003038983069081333, "phrase": "standard_combinator_interface"}, {"score": 0.0028279422436488116, "phrase": "static_and_explicit_control-flow_components"}, {"score": 0.0026889720516076205, "phrase": "information-flow_control"}, {"score": 0.0026505322540093783, "phrase": "static-analysis_techniques"}, {"score": 0.0025202582748972122, "phrase": "strong_security_guarantees"}, {"score": 0.0024136908511423875, "phrase": "formal_proof"}, {"score": 0.0022950308685133224, "phrase": "concrete_haskell_implementation"}, {"score": 0.002245975340642921, "phrase": "example_application"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Information flow", " Security", " Haskell", " Arrows", " Type systems", " Combinators"], "paper_abstract": "This paper presents an embedded security sublanguage for enforcing information-flow policies in the standard Haskell programming language. The sublanguage provides useful information-flow control mechanisms including dynamic security lattices, run-time code privileges and declassification all without modifying the base language. This design avoids the redundant work of producing new languages, lowers the threshold for adopting security-typed languages, and also provides great flexibility and modularity for using security-policy frameworks. The embedded security sublanguage is designed using a standard combinator interface called arrows. Computations constructed in the sublanguage have static and explicit control-flow components, making it possible to implement information-flow control using static-analysis techniques at run time, while providing strong security guarantees. This paper presents a formal proof that our embedded sublanguage provides noninterference, a concrete Haskell implementation and an example application demonstrating the proposed techniques.(1) (c) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Arrows for secure information flow", "paper_id": "WOS:000276597100006"}