{"auto_keywords": [{"score": 0.0048149540663384284, "phrase": "data-structures"}, {"score": 0.00478579024367007, "phrase": "imperative_programs"}, {"score": 0.004685106586595599, "phrase": "automated_reasoning"}, {"score": 0.004656729019170898, "phrase": "dynamically_manipulated_data_structures"}, {"score": 0.004490020801780961, "phrase": "user-defined_recursive_rules"}, {"score": 0.004238134740341528, "phrase": "systematic_transformation_steps"}, {"score": 0.003951976017359017, "phrase": "final_formula"}, {"score": 0.0037529131348732715, "phrase": "fundamental_principle"}, {"score": 0.0036962894088549796, "phrase": "automated_process"}, {"score": 0.003618443379266972, "phrase": "proof_obligations"}, {"score": 0.0034887749053459584, "phrase": "induction_hypotheses"}, {"score": 0.0033230588808076267, "phrase": "induction_step"}, {"score": 0.0032828706086018133, "phrase": "new_proof_obligation"}, {"score": 0.003117405395602633, "phrase": "obvious_need"}, {"score": 0.003070340620983981, "phrase": "automated_method"}, {"score": 0.0029965060407413898, "phrase": "systematic_and_general_way"}, {"score": 0.002969276778056666, "phrase": "main_reason"}, {"score": 0.0028978654846251047, "phrase": "circular_reasoning"}, {"score": 0.0028367868542874737, "phrase": "novel_checking_condition"}, {"score": 0.0027685531038981847, "phrase": "proof_method"}, {"score": 0.0027101925966844117, "phrase": "automatic_formula"}, {"score": 0.002661146838358236, "phrase": "previously_encountered_obligations"}, {"score": 0.002636956926079255, "phrase": "proof_path"}, {"score": 0.0026209522797963447, "phrase": "possible_induction_hypotheses"}, {"score": 0.0025892330566358503, "phrase": "practical_evaluation_part"}, {"score": 0.002519257735651759, "phrase": "commonly_used_technique"}, {"score": 0.0024963543716522087, "phrase": "unproven_lemmas"}, {"score": 0.0024511688853030168, "phrase": "realistic_benchmarks"}, {"score": 0.002399482671479507, "phrase": "current_burden"}, {"score": 0.0023560464785206095, "phrase": "appropriate_lemmas"}, {"score": 0.002299349400076823, "phrase": "verification_process"}, {"score": 0.002278440725193305, "phrase": "lemma_applications"}, {"score": 0.0022168460543913787, "phrase": "large_search_space"}, {"score": 0.0021372966835847564, "phrase": "new_class"}, {"score": 0.0021049977753042253, "phrase": "practical_program_verification"}], "paper_keywords": ["Verification", " Data-structures", " Induction Proofs", " Separation"], "paper_abstract": "We consider the problem of automated reasoning about dynamically manipulated data structures. Essential properties are encoded as predicates whose definitions are formalized via user-defined recursive rules. Traditionally, proving relationships between such properties is limited to the unfold-and-match (U+M) paradigm which employs systematic transformation steps of folding/unfolding the rules. A proof, using U+M, succeeds when we find a sequence of transformations that produces a final formula which is obviously provable by simply matching terms. Our contribution here is the addition of the fundamental principle of induction to this automated process. We first show that some proof obligations that are dynamically generated in the process can be used as induction hypotheses in the future, and then we show how to use these hypotheses in an induction step which generates a new proof obligation aside from those obtained by using the fold/unfold operations. While the adding of induction is an obvious need in general, no automated method has managed to include this in a systematic and general way. The main reason for this is the problem of avoiding circular reasoning. We overcome this with a novel checking condition. In summary, our contribution is a proof method which - beyond U+M - performs automatic formula re-writing by treating previously encountered obligations in each proof path as possible induction hypotheses. In the practical evaluation part of this paper, we show how the commonly used technique of using unproven lemmas can be avoided, using realistic benchmarks. This not only removes the current burden of coming up with the appropriate lemmas, but also significantly boosts up the verification process, since lemma applications, coupled with unfolding, often induce a large search space. In the end, our method can automatically reason about a new class of formulas arising from practical program verification.", "paper_title": "Automatic Induction Proofs of Data-Structures in Imperative Programs", "paper_id": "WOS:000361284200043"}