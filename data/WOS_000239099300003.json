{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "software_flexibility"}, {"score": 0.03649194020608373, "phrase": "evolution_complexity"}, {"score": 0.004563028873351776, "phrase": "desirable_quality"}, {"score": 0.004412285905508977, "phrase": "earliest_days"}, {"score": 0.0043533862892678864, "phrase": "software_engineering"}, {"score": 0.004295269532032448, "phrase": "classic_and_contemporary_software_design_literature"}, {"score": 0.0038573081851680656, "phrase": "objective_criteria"}, {"score": 0.00363080961099728, "phrase": "precise_terms"}, {"score": 0.002927626967420519, "phrase": "procedural_programs"}, {"score": 0.002737110878696217, "phrase": "pipes"}, {"score": 0.0021335427588412077, "phrase": "experimental_results"}], "paper_keywords": [""], "paper_abstract": "Flexibility has been recognised as a desirable quality of software since the earliest days of software engineering. Classic and contemporary software design literature suggests that particular implementations are more flexible than others, but stops short of suggesting objective criteria for quantifying such claims. To measure software flexibility in precise terms, we introduce the notion of evolution complexity and demonstrate how it can be used to measure and compare the flexibility of (1) programming paradigms (Object-Oriented against Procedural programs), (2) architectural styles (Shared Data, Pipes and Filters, and Abstract Data Type) and (3) design patterns (Visitor and the Abstract Factory). We also demonstrate how evolution complexity can be used to choose the most flexible design policy. We conclude with experimental results corroborating our claims.", "paper_title": "Measuring software flexibility", "paper_id": "WOS:000239099300003"}