{"auto_keywords": [{"score": 0.034416553346190024, "phrase": "cartesian_tree"}, {"score": 0.00481495049065317, "phrase": "dynamic_cartesian_trees"}, {"score": 0.004758457292840376, "phrase": "cartesian_trees"}, {"score": 0.004674952036988355, "phrase": "numerous_applications"}, {"score": 0.004565876339189493, "phrase": "peculiar_rigid_structure"}, {"score": 0.0031845067058084583, "phrase": "weak_deletions"}, {"score": 0.003091767402370757, "phrase": "amortized_time"}, {"score": 0.0028630535573013686, "phrase": "amortized_cost"}, {"score": 0.0025436978068459565, "phrase": "entropy-related_measure"}, {"score": 0.002498961351132696, "phrase": "partial_order"}, {"score": 0.0024554948773535664, "phrase": "t."}, {"score": 0.0021049977753042253, "phrase": "poly-logaxithmic_update_bounds"}], "paper_keywords": [""], "paper_abstract": "Cartesian trees have found numerous applications due to a peculiar rigid structure whose properties can be exploited in various ways. This rigidness, however, is also an obstacle when updating the structure since it can lead to a very unbalanced shape and so up to now most applications either assumed a random distribution of the keys or considered only the static case. In this paper we present a framework for efficiently maintaining a Cartesian tree under insertions and weak deletions in O(log n) amortized time per operation, using O(n) space. We show that the amortized cost of updating a Cartesian tree is O(1 + H(T)/n) where H(T) = O(n log n) is an entropy-related measure for the partial order encoded by T. We also show how to exploit this property by implementing an algorithm which performs these updates in O(log n) time per operation. No poly-logaxithmic update bounds were previously known.", "paper_title": "Amortized rigidness in dynamic Cartesian trees", "paper_id": "WOS:000236464100005"}