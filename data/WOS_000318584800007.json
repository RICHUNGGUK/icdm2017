{"auto_keywords": [{"score": 0.041353891869186775, "phrase": "translation_functions"}, {"score": 0.017439842663321756, "phrase": "delphi"}, {"score": 0.013550304632335352, "phrase": "z_design-level_schema"}, {"score": 0.010612387000973441, "phrase": "z_specifications"}, {"score": 0.008944107166946078, "phrase": "specification-implementation_gap"}, {"score": 0.008486938117935253, "phrase": "database_applications"}, {"score": 0.0079865806066585, "phrase": "sql"}, {"score": 0.0062958016115650965, "phrase": "z_abstract_schema"}, {"score": 0.004788327412856401, "phrase": "executable_code"}, {"score": 0.004722408916485981, "phrase": "database_domain"}, {"score": 0.004702079788698397, "phrase": "context"}, {"score": 0.004555217356295278, "phrase": "formal_methods"}, {"score": 0.004517479191423587, "phrase": "software_development_process_results"}, {"score": 0.004492493482621552, "phrase": "high-quality_software_products"}, {"score": 0.004430629452265786, "phrase": "software_requirements"}, {"score": 0.004393918892662753, "phrase": "formal_notation"}, {"score": 0.0037825900830859476, "phrase": "formal_definition"}, {"score": 0.003519242552610694, "phrase": "mathematical_foundation"}, {"score": 0.0035011685385545966, "phrase": "z"}, {"score": 0.0032380061870515794, "phrase": "delphi_libraries"}, {"score": 0.003211145390854807, "phrase": "z_mathematical_structures"}, {"score": 0.002970914475538276, "phrase": "formal_relationship"}, {"score": 0.0026807346783271095, "phrase": "z_refinement_rules"}, {"score": 0.0026000466400112974, "phrase": "morgan_refinement_calculus"}, {"score": 0.0025008468316682036, "phrase": "proposed_approach"}, {"score": 0.0024526718637463574, "phrase": "correct_prototype"}, {"score": 0.0024323098907299027, "phrase": "database_application"}, {"score": 0.0023200701794273155, "phrase": "software_requirements_specification"}, {"score": 0.0023072099436781354, "phrase": "user_requirements"}, {"score": 0.0022191579011386553, "phrase": "overall_cost"}, {"score": 0.0021763973978248005, "phrase": "early_validation"}, {"score": 0.002164331818029166, "phrase": "requirement_errors"}, {"score": 0.002140400526572388, "phrase": "software_development_cycle"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Prototyping", " Database", " Formal methods", " Software development", " Graphical user interface"], "paper_abstract": "Context: It is well-known that the use of formal methods in the software development process results in high-quality software products. Having specified the software requirements in a formal notation, the question is how they can be transformed into an implementation. There is typically a mismatch between the specification and the implementation, known as the specification-implementation gap. Objective: This paper introduces a set of translation functions to fill the specification-implementation gap in the domain of database applications. We only present the formal definition, not the implementation, of the translation functions. Method: We chose Z, SQL and Delphi languages to illustrate our methodology. Because the mathematical foundation of Z has many properties in common with SQL, the translation functions from Z to SQL are derived easily. For the translation of Z to Delphi, we extend Delphi libraries to support Z mathematical structures such as sets and tuples. Then, based on these libraries, we derive the translation functions from Z to Delphi. Therefore, we establish a formal relationship between Z specifications and Delphi/SQL code. To prove the soundness of the translation from a Z abstract schema to the Delphi/SQL code, we define a Z design-level schema. We investigate the consistency of the Z abstract schema with the Z design-level schema by using Z refinement rules. Then, by the use of the laws of Morgan refinement calculus, we prove that the Delphi/SQL code refines the Z design-level schema. Results: The proposed approach can be used to build the correct prototype of a database application from its specification. This prototype can be evolved, or may be used to validate the software requirements specification against user requirements. Conclusion: Therefore, the work presented in this paper reduces the overall cost of the development of database applications because early validation reveals requirement errors sooner in the software development cycle. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Translation of Z specifications to executable code: Application to the database domain", "paper_id": "WOS:000318584800007"}