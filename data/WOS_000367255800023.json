{"auto_keywords": [{"score": 0.04895768616855953, "phrase": "evaluation_order"}, {"score": 0.009337393003611208, "phrase": "type_system"}, {"score": 0.005275908489751634, "phrase": "source_program"}, {"score": 0.00481495049065317, "phrase": "evaluation-order_polymorphism"}, {"score": 0.004750178261675602, "phrase": "programming_languages"}, {"score": 0.0039427304473829165, "phrase": "by-value_and_by-name_versions"}, {"score": 0.003837273003552065, "phrase": "intersection_type"}, {"score": 0.0037984549828326106, "phrase": "evaluation_orders"}, {"score": 0.0034428109010424175, "phrase": "code_duplication"}, {"score": 0.0033280337910399104, "phrase": "by-value_connectives"}, {"score": 0.0032170707904803125, "phrase": "by-value_and_by-name_connectives"}, {"score": 0.002975652654536407, "phrase": "straightforward_encoding"}, {"score": 0.0029455250501196286, "phrase": "impartial_type_system"}, {"score": 0.0028280256704977746, "phrase": "economical_language"}, {"score": 0.002799388549023265, "phrase": "call-by-value_semantics"}, {"score": 0.0027336881691956186, "phrase": "well-typed_source_program"}, {"score": 0.0026424892463535717, "phrase": "well-typed_target_program"}, {"score": 0.0025028412246758994, "phrase": "target_program"}, {"score": 0.002252880693912436, "phrase": "type_annotations"}, {"score": 0.0021049977753042253, "phrase": "run_time"}], "paper_keywords": ["evaluation order", " intersection types", " polymorphism"], "paper_abstract": "We classify programming languages according to evaluation order: each language fixes one evaluation order as the default, making it transparent to program in that evaluation order, and troublesome to program in the other. This paper develops a type system that is impartial with respect to evaluation order. Evaluation order is implicit in terms, and explicit in types, with by-value and by-name versions of type connectives. A form of intersection type quantifies over evaluation orders, describing code that is agnostic over (that is, polymorphic in) evaluation order. By allowing such generic code, programs can express the by-value and by-name versions of a computation without code duplication. We also formulate a type system that only has by-value connectives, plus a type that generalizes the difference between by-value and by-name connectives: it is either a suspension (by name) or a \"no-op\" (by value). We show a straightforward encoding of the impartial type system into the more economical one. Then we define an elaboration from the economical language to a call-by-value semantics, and prove that elaborating a well-typed source program, where evaluation order is implicit, produces a well-typed target program where evaluation order is explicit. We also prove a simulation between evaluation of the target program and reductions (either by-value or by-name) in the source program. Finally, we prove that typing, elaboration, and evaluation are faithful to the type annotations given in the source program: if the programmer only writes by-value types, no by-name reductions can occur at run time.", "paper_title": "Elaborating Evaluation-Order Polymorphism", "paper_id": "WOS:000367255800023"}