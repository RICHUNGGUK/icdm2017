{"auto_keywords": [{"score": 0.0475341023543958, "phrase": "mapreduce"}, {"score": 0.004914466054007247, "phrase": "multi-cores"}, {"score": 0.00481495049065317, "phrase": "garbage_collection_auto-tuning"}, {"score": 0.004317109072311102, "phrase": "simple_programming_pattern"}, {"score": 0.003625716543591661, "phrase": "mrj"}, {"score": 0.0036080776793146843, "phrase": "different_computational_scenarios"}, {"score": 0.0033372020049592726, "phrase": "mapreduce_java"}, {"score": 0.0032599633778910516, "phrase": "multi-core_architectures"}, {"score": 0.0029453365339797933, "phrase": "standard_mapreduce_benchmarks"}, {"score": 0.0028325548627901004, "phrase": "significant_impact"}, {"score": 0.0027886573969044042, "phrase": "java_runtime_garbage_collection"}, {"score": 0.002619748321217153, "phrase": "mrj."}, {"score": 0.002499798127196099, "phrase": "memory_management_auto-tuning_techniques"}, {"score": 0.0022407927161620855, "phrase": "mrj_performance"}], "paper_keywords": ["Experimentation", " Performance", " mapreduce", " garbage collection", " machine learning", " Java"], "paper_abstract": "MapReduce has been widely accepted as a simple programming pattern that can form the basis for efficient, large-scale, distributed data processing. The success of the MapReduce pattern has led to a variety of implementations for different computational scenarios. In this paper we present MRJ, a MapReduce Java framework for multi-core architectures. We evaluate its scalability on a four-core, hyperthreaded Intel Core i7 processor, using a set of standard MapReduce benchmarks. We investigate the significant impact that Java runtime garbage collection has on the performance and scalability of MRJ. We propose the use of memory management auto-tuning techniques based on machine learning. With our auto-tuning approach, we are able to achieve MRJ performance within 10% of optimal on 75% of our benchmark tests.", "paper_title": "Garbage Collection Auto-Tuning for Java MapReduce on Multi-Cores", "paper_id": "WOS:000298295400011"}