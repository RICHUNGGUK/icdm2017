{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "efficient_performance_evaluation_of_memory_hierarchy"}, {"score": 0.004782587436296574, "phrase": "highly_multithreaded_graphics_processors"}, {"score": 0.004686791459644141, "phrase": "highly_multithreaded_architectures"}, {"score": 0.004655285779819366, "phrase": "performance_monitoring_techniques"}, {"score": 0.004623990904432388, "phrase": "new_challenges"}, {"score": 0.004531357177195719, "phrase": "performance_discrepancies"}, {"score": 0.004485735417293941, "phrase": "program_source_code"}, {"score": 0.004395859169800476, "phrase": "state-of-the-art_performance"}, {"score": 0.004109023004472115, "phrase": "program_execution"}, {"score": 0.003986103192038901, "phrase": "fine-grained_sampling"}, {"score": 0.0038930368103015467, "phrase": "actual_program_behavior"}, {"score": 0.0038278890186559276, "phrase": "sampled_values"}, {"score": 0.0036759314172445934, "phrase": "high_resolution_performance_information"}, {"score": 0.0036511960413423542, "phrase": "low_sampling_rates"}, {"score": 0.0035659209800190847, "phrase": "concurrently_running_threads"}, {"score": 0.003459191419478298, "phrase": "novel_software-based_approach"}, {"score": 0.003412783661090541, "phrase": "memory_hierarchy_performance"}, {"score": 0.0033898129842622536, "phrase": "highly_multithreaded_general-purpose_graphics_processors"}, {"score": 0.003299460925313939, "phrase": "memory_traces"}, {"score": 0.0032332756920184177, "phrase": "application_execution"}, {"score": 0.0032006810120751524, "phrase": "trace-based_memory_hierarchy_model"}, {"score": 0.003168413874902081, "phrase": "monte_carlo_experimental_methodology"}, {"score": 0.003115354317501177, "phrase": "performance_measures"}, {"score": 0.00305285084207725, "phrase": "exact_inter-thread"}, {"score": 0.0030220695120265974, "phrase": "individual_events"}, {"score": 0.0029414903557512663, "phrase": "overall_system"}, {"score": 0.0029118285733827406, "phrase": "statistical_approach"}, {"score": 0.0028824650336365465, "phrase": "classical_problem"}, {"score": 0.002815093247670994, "phrase": "fine-grained_instrumentation"}, {"score": 0.002721562843196732, "phrase": "efficient_parallel_trace_collection_technique"}, {"score": 0.002685024286204448, "phrase": "trace_generation_overhead"}, {"score": 0.0026579417954765137, "phrase": "simple_memory_hierarchy_model"}, {"score": 0.0026222551419772867, "phrase": "simulation_time"}, {"score": 0.0025958041241829254, "phrase": "proposed_scheme"}, {"score": 0.002552309172078995, "phrase": "individual_memory_operations"}, {"score": 0.00252656192077797, "phrase": "source_code"}, {"score": 0.002450864311898833, "phrase": "memory_system"}, {"score": 0.0023935561037315375, "phrase": "close_agreement"}, {"score": 0.0023375847850353355, "phrase": "hardware_performance_counters"}, {"score": 0.0022829193139224636, "phrase": "high_resolution_profile_data"}, {"score": 0.0022370795358896784, "phrase": "memory_accesses"}, {"score": 0.0022145052062614514, "phrase": "sparse_matrix_vector_multiply_kernel"}, {"score": 0.0021049977753042253, "phrase": "input_matrices"}], "paper_keywords": ["Design", " Measurement", " Performance", " GPU", " Memory hierarchy", " Performance evaluation"], "paper_abstract": "With the emergence of highly multithreaded architectures, performance monitoring techniques face new challenges in efficiently locating sources of performance discrepancies in the program source code. For example, the state-of-the-art performance counters in highly multithreaded graphics processing units (GPUs) report only the overall occurrences of microarchitecture events at the end of program execution. Furthermore, even if supported, any fine-grained sampling of performance counters will distort the actual program behavior and will make the sampled values inaccurate. On the other hand, it is difficult to achieve high resolution performance information at low sampling rates in the presence of thousands of concurrently running threads. In this paper, we present a novel software-based approach for monitoring the memory hierarchy performance in highly multithreaded general-purpose graphics processors. The proposed analysis is based on memory traces collected for snapshots of an application execution. A trace-based memory hierarchy model with a Monte Carlo experimental methodology generates statistical bounds of performance measures without being concerned about the exact inter-thread ordering of individual events but rather studying the behavior of the overall system. The statistical approach overcomes the classical problem of disturbed execution timing due to fine-grained instrumentation. The approach scales well as we deploy an efficient parallel trace collection technique to reduce the trace generation overhead and a simple memory hierarchy model to reduce the simulation time. The proposed scheme also keeps track of individual memory operations in the source code and can quantify their efficiency with respect to the memory system. A cross-validation of our results shows close agreement with the values read from the hardware performance counters on an NVIDIA Tesla C2050 GPU. Based on the high resolution profile data produced by our model we optimized memory accesses in the sparse matrix vector multiply kernel and achieved speedups ranging from 2.4 to 14.8 depending on the characteristics of the input matrices.", "paper_title": "Efficient Performance Evaluation of Memory Hierarchy for Highly Multithreaded Graphics Processors", "paper_id": "WOS:000309350200003"}