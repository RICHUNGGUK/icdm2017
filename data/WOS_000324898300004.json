{"auto_keywords": [{"score": 0.040068893161497504, "phrase": "common_cache"}, {"score": 0.00481495049065317, "phrase": "object-oriented_software"}, {"score": 0.004674952036988355, "phrase": "processor_technology"}, {"score": 0.004606479650820579, "phrase": "multicore_processors"}, {"score": 0.004539005582217309, "phrase": "multiple_processing_units"}, {"score": 0.004439634831927606, "phrase": "single_package"}, {"score": 0.004263046902817659, "phrase": "higher_level_cache_memory"}, {"score": 0.004139028737420222, "phrase": "multi-level_cache_hierarchy"}, {"score": 0.0040186038781533946, "phrase": "cache_utilization_problem"}, {"score": 0.003974349782102708, "phrase": "parallel-running_software_components"}, {"score": 0.0039016690475620185, "phrase": "processor_cores"}, {"score": 0.003623949225126944, "phrase": "novel_approach"}, {"score": 0.003584025547693836, "phrase": "model-based_information"}, {"score": 0.003531474887552889, "phrase": "os_scheduler"}, {"score": 0.0034925663938977715, "phrase": "appropriate_core_affinities"}, {"score": 0.003466865016432561, "phrase": "software_objects"}, {"score": 0.003390886284555397, "phrase": "graph_models"}, {"score": 0.0033411580268394732, "phrase": "cache_hierarchies"}, {"score": 0.003267925215811654, "phrase": "graph_matcher_algorithm"}, {"score": 0.0030576885787607796, "phrase": "software_object"}, {"score": 0.0027878797103973313, "phrase": "common_data"}, {"score": 0.0026277995163948263, "phrase": "object_dispatcher_algorithm"}, {"score": 0.0025796799784169196, "phrase": "object_affiliations"}, {"score": 0.0024677487011556427, "phrase": "compile-time_graph_matcher"}, {"score": 0.0024136132575631273, "phrase": "design_pattern_implementations"}, {"score": 0.0023519508354777215, "phrase": "cfs_scheduling"}, {"score": 0.002233301265743633, "phrase": "software_model"}, {"score": 0.0021522261505574035, "phrase": "cfs'_scheduling_performance"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Model-based scheduling", " Object-oriented design for multicore systems", " Cache-aware object dispatching"], "paper_abstract": "In recent years, processor technology has evolved towards multicore processors, which include multiple processing units (cores) in a single package. Those cores, having their own private caches, often share a higher level cache memory dedicated to each processor die. This multi-level cache hierarchy in multicore processors raises the importance of cache utilization problem. Assigning parallel-running software components with common data to processor cores that do not share a common cache increases the number of cache misses. In this paper we present a novel approach that uses model-based information to guide the OS scheduler in assigning appropriate core affinities to software objects at run-time. We build graph models of software and cache hierarchies of processors and devise a graph matcher algorithm that provides mapping between these two graphs. Using this mapping we obtain candidate core sets that each software object can be affiliated with at run-time. These affiliations are determined based on the idea that software components that have the potential to share common data at run-time should run on cores that share a common cache. We also develop an object dispatcher algorithm that keeps track of object affiliations at run-time and dispatches objects by using the information from the compile-time graph matcher. We apply our approach on design pattern implementations and two different application program running on servers using CFS scheduling. Our results show that cache-aware dispatching based on information obtained from software model, decreases number of cache misses significantly and improves CFS' scheduling performance. (C) 2013 Elsevier Inc. All rights reserved.", "paper_title": "Model-based cache-aware dispatching of object-oriented software for multicore systems", "paper_id": "WOS:000324898300004"}