{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "priority_r-tree"}, {"score": 0.004543708337879809, "phrase": "first_r-tree_variant"}, {"score": 0.004381962669035583, "phrase": "window_query"}, {"score": 0.0036553070575015344, "phrase": "disk_block_size"}, {"score": 0.0034995881411519925, "phrase": "output_size"}, {"score": 0.0027341763737751467, "phrase": "extensive_experimental_study"}, {"score": 0.002675252546913683, "phrase": "practical_performance"}, {"score": 0.0025242409510332527, "phrase": "synthetic_data"}, {"score": 0.0023135183406982414, "phrase": "best-known_r-tree_variants"}, {"score": 0.0022148335975074904, "phrase": "relatively_nicely_distributed_data"}], "paper_keywords": ["R-trees"], "paper_abstract": "We present the priority R-tree, or PR-tree, which is the first R-tree variant that always answers a window query using O((N/B)1-1/d + T/B) I/Os, where N is the number of d-dimensional (hyper-) rectangles stored in the R-tree, B is the disk block size, and T is the output size. This is provably asymptotically optimal and significantly better than other R-tree variants, where a query may visit all N/B leaves in the tree even when T = 0. We also present an extensive experimental study of the practical performance of the PR-tree using both real-life and synthetic data. This study shows that the PR-tree performs similarly to the best-known R-tree variants on real-life and relatively nicely distributed data, but outperforms them significantly on more extreme data.", "paper_title": "The Priority R-Tree: A Practically Efficient and Worst-Case Optimal R-Tree", "paper_id": "WOS:000265816600009"}