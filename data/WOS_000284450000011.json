{"auto_keywords": [{"score": 0.04259391291134381, "phrase": "multi-core_architectures"}, {"score": 0.00481495049065317, "phrase": "multi-core_computing"}, {"score": 0.004698086429418318, "phrase": "feasible_though_arduous_task"}, {"score": 0.0046407174174471644, "phrase": "substantial_intellectual_effort"}, {"score": 0.004555968736680118, "phrase": "second_system"}, {"score": 0.004445362365289235, "phrase": "sequential_computing_algorithms_textbooks"}, {"score": 0.0043374295116776675, "phrase": "software_systems"}, {"score": 0.004206175629459691, "phrase": "hardware_platforms"}, {"score": 0.0039920586058503705, "phrase": "high_performance"}, {"score": 0.003955416337187053, "phrase": "comparable_opportunity"}, {"score": 0.0038950888505884687, "phrase": "intellectual_efforts"}, {"score": 0.0037424924896976093, "phrase": "bridging_model"}, {"score": 0.0035958527554878655, "phrase": "considerable_intellectual_effort"}, {"score": 0.003551895245595481, "phrase": "efficient_algorithms"}, {"score": 0.0034443299902626834, "phrase": "portable_algorithms"}, {"score": 0.0032991709808491147, "phrase": "efficient_designs"}, {"score": 0.003268867709471835, "phrase": "reasonable_combinations"}, {"score": 0.0032388418727065144, "phrase": "basic_resource_parameters"}, {"score": 0.003218977531454772, "phrase": "input_sizes"}, {"score": 0.003102316064687607, "phrase": "particular_machines"}, {"score": 0.0030549600434918215, "phrase": "multi-level_model"}, {"score": 0.0030268930660241563, "phrase": "explicit_parameters"}, {"score": 0.0030083247178199434, "phrase": "processor_numbers"}, {"score": 0.002971528026470718, "phrase": "communication_costs"}, {"score": 0.0029442253041602044, "phrase": "synchronization_costs"}, {"score": 0.0029171727082441244, "phrase": "lowest_level"}, {"score": 0.002855014613775394, "phrase": "pram"}, {"score": 0.0026435894486890594, "phrase": "parameter-aware_portable_algorithms"}, {"score": 0.0025952171827648665, "phrase": "relevant_architectures"}, {"score": 0.002455333662233046, "phrase": "parameter-free_notion"}, {"score": 0.0023735785441690097, "phrase": "standard_matrix_multiplication"}, {"score": 0.002301614895279686, "phrase": "optimal_portable_algorithms"}, {"score": 0.0022387107945750044, "phrase": "machine_parameters"}, {"score": 0.00221130685073215, "phrase": "algorithmic_generality"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Parallel algorithms", " Multi-core", " Bridging model", " Bulk synchronous"], "paper_abstract": "Writing software for one parallel system is a feasible though arduous task. Reusing the substantial intellectual effort so expended for programming a second system has proved much more challenging. In sequential computing algorithms textbooks and portable software are resources that enable software systems to be written that are efficiently portable across changing hardware platforms. These resources are currently lacking in the area of multi-core architectures, where a programmer seeking high performance has no comparable opportunity to build on the intellectual efforts of others. In order to address this problem we propose a bridging model aimed at capturing the most basic resource parameters of multi-core architectures. We suggest that the considerable intellectual effort needed for designing efficient algorithms for such architectures may be most fruitfully expended in designing portable algorithms, once and for all, for such a bridging model. Portable algorithms would contain efficient designs for all reasonable combinations of the basic resource parameters and input sizes, and would form the basis for implementation or compilation for particular machines. Our Multi-BSP model is a multi-level model that has explicit parameters for processor numbers, memory/cache sizes, communication costs, and synchronization costs. The lowest level corresponds to shared memory or the PRAM, acknowledging the relevance of that model for whatever limitations on memory and processor numbers it may be efficacious to emulate it. We propose parameter-aware portable algorithms that run efficiently on all relevant architectures with any number of levels and any combination of parameters. For these algorithms we define a parameter-free notion of optimality. We show that for several fundamental problems, including standard matrix multiplication, the Fast Fourier Transform, and comparison sorting, there exist optimal portable algorithms in that sense, for all combinations of machine parameters. Thus some algorithmic generality and elegance can be found in this many parameter setting. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "A bridging model for multi-core computing", "paper_id": "WOS:000284450000011"}