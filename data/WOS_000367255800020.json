{"auto_keywords": [{"score": 0.04762443660575816, "phrase": "scalable"}, {"score": 0.0185833675394357, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "adaptive_lock-free"}, {"score": 0.004466519142879166, "phrase": "functional_data_structures"}, {"score": 0.004334280585565239, "phrase": "mutable_variable"}, {"score": 0.004237666411136617, "phrase": "excellent_concurrent_data_structure"}, {"score": 0.003356675879109443, "phrase": "pure-in-a-box_data_structures"}, {"score": 0.002953711377604328, "phrase": "pure_and_lock-free_container_types"}, {"score": 0.002502995662011305, "phrase": "glasgow_haskell_compiler"}, {"score": 0.002355474461044353, "phrase": "ghc"}, {"score": 0.002252602622785975, "phrase": "lock-free_data_structures"}, {"score": 0.0021857667493036786, "phrase": "new_approach"}, {"score": 0.0021530945641993152, "phrase": "safe_cas"}, {"score": 0.0021049977753042253, "phrase": "lazy_language"}], "paper_keywords": ["Languages", " Performance", " Lock-free algorithms", " Concurrent data structures"], "paper_abstract": "Purely functional data structures stored inside a mutable variable provide an excellent concurrent data structure-obviously correct, cheap to create, and supporting snapshots. They are not, however, scalable. We provide a way to retain the benefits of these pure-in-a-box data structures while dynamically converting to a more scalable lock-free data structure under contention. Our solution scales to any pair of pure and lock-free container types with key/value set semantics, while retaining lock-freedom. We demonstrate the principle in action on two very different platforms: first in the Glasgow Haskell Compiler and second in Java. To this end we extend GHC to support lock-free data structures and introduce a new approach for safe CAS in a lazy language.", "paper_title": "Adaptive Lock-Free Maps: Purely-Functional to Scalable", "paper_id": "WOS:000367255800020"}