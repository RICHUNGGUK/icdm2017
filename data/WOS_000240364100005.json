{"auto_keywords": [{"score": 0.035523075015928884, "phrase": "weiss"}, {"score": 0.004658426838467567, "phrase": "language_l"}, {"score": 0.004418456827500267, "phrase": "exactly_the_bits"}, {"score": 0.003896717568943166, "phrase": "agafonoff"}, {"score": 0.0036285436103726605, "phrase": "kamae"}, {"score": 0.0035285548582081627, "phrase": "regular_language"}, {"score": 0.002602127996667857, "phrase": "regular_ones"}, {"score": 0.002451527111936163, "phrase": "deterministic_one-counter_languages"}, {"score": 0.002147265537489893, "phrase": "constant_sequence"}, {"score": 0.0021049977753042253, "phrase": "normal_one"}], "paper_keywords": [""], "paper_abstract": "The sequence selected from a sequence R(0)R(1)... by a language L is the subsequence of R that contains exactly the bits R(n+1) such that the prefix R(0)... R(n) is in L. By a result of Agafonoff, a sequence is normal if and only if any subsequence selected by a regular language is again normal. Kamae and Weiss and others have raised the question of how complex a language must be such that selecting according to the language does not preserve normality. We show that there are such languages that are only slightly more complicated than regular ones, namely, normality is preserved neither by deterministic one-counter languages nor by linear languages. In fact, for both types of languages it is possible to select a constant sequence from a normal one.", "paper_title": "Selection functions that do not preserve normality", "paper_id": "WOS:000240364100005"}