{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "haskell"}, {"score": 0.048230060146916456, "phrase": "denotational_semantics"}, {"score": 0.004539005582217309, "phrase": "even_well-typed_programs"}, {"score": 0.004321118442104989, "phrase": "modern_functional_languages"}, {"score": 0.0041136473765874815, "phrase": "pattern-match_failure"}, {"score": 0.003877737556673229, "phrase": "wrong_answer"}, {"score": 0.00376488621224566, "phrase": "increasingly-popular_response"}, {"score": 0.0034118234596993836, "phrase": "semantic_properties"}, {"score": 0.0031845067058084613, "phrase": "useful_post-condition"}, {"score": 0.0030314419455512013, "phrase": "static_verification"}, {"score": 0.0028293966058473476, "phrase": "novel_translation"}, {"score": 0.0027741761880779535, "phrase": "first-order_logic"}, {"score": 0.0026933542552712033, "phrase": "haskell_programs"}, {"score": 0.0021049977753042253, "phrase": "off-the-shelf_first-order_logic_theorem_prover"}], "paper_keywords": ["verification", " languages", " static contract checking", " first-order logic"], "paper_abstract": "Even well-typed programs can go wrong in modern functional languages, by encountering a pattern-match failure, or simply returning the wrong answer. An increasingly-popular response is to allow programmers to write contracts that express semantic properties, such as crash-freedom or some useful post-condition. We study the static verification of such contracts. Our main contribution is a novel translation to first-order logic of both Haskell programs, and contracts written in Haskell, all justified by denotational semantics. This translation enables us to prove that functions satisfy their contracts using an off-the-shelf first-order logic theorem prover.", "paper_title": "HALO: Haskell to Logic through Denotational Semantics", "paper_id": "WOS:000318629900037"}