{"auto_keywords": [{"score": 0.041040679407137085, "phrase": "multicore_technology"}, {"score": 0.02967868207510048, "phrase": "modelled_cores"}, {"score": 0.00481495049065317, "phrase": "concurrent_multi-stealing_scheduler_model"}, {"score": 0.004723322467153553, "phrase": "problems._multicore_architecture"}, {"score": 0.004633429997452688, "phrase": "general_direction"}, {"score": 0.004597951649247307, "phrase": "software_development"}, {"score": 0.004545240514015278, "phrase": "personal_computers"}, {"score": 0.004390689303780405, "phrase": "software_designers"}, {"score": 0.00429057323623293, "phrase": "evolving_challenges"}, {"score": 0.004208881856146758, "phrase": "hardware_side"}, {"score": 0.004081385289516914, "phrase": "multicore_architecture"}, {"score": 0.0037215192436590772, "phrase": "well-known_techniques"}, {"score": 0.003622642432563435, "phrase": "natural_adaptation"}, {"score": 0.0034063576796640603, "phrase": "new_environment"}, {"score": 0.003290403747743492, "phrase": "new_concurrent_multithreaded_colored_petri_nets_model"}, {"score": 0.003190714859193454, "phrase": "divide"}, {"score": 0.003166174817955658, "phrase": "conquer_problems"}, {"score": 0.0031298260299218684, "phrase": "multicore_environment"}, {"score": 0.0027670864777787655, "phrase": "mss"}, {"score": 0.0026218430041123164, "phrase": "conquer_problem"}, {"score": 0.0025917270871556475, "phrase": "second_scheduler"}, {"score": 0.0025619562094446884, "phrase": "local_threads_scheduler"}, {"score": 0.002474674704809152, "phrase": "threads_creation"}, {"score": 0.002427473263013356, "phrase": "modelled_core"}, {"score": 0.0023720293770177025, "phrase": "lts"}, {"score": 0.002344762593995099, "phrase": "new_recursive_method"}, {"score": 0.002308910575113746, "phrase": "necessary_information"}, {"score": 0.0021049977753042253, "phrase": "high_level"}], "paper_keywords": [""], "paper_abstract": "Multicore architecture has dramatically changed the general direction of software development dedicated for personal computers. As such, it is important for software designers to keep pace with the evolving challenges that happen in the hardware side, for example in this context of multicore architecture, so that they can leverage on the advantages of multicore technology as much as possible while developing software. As one of the well-known techniques, Divide and Conquer has a natural adaptation with the multicore technology. The technique needs to be further developed to fit into this new environment. In this paper, we present a new concurrent multithreaded Colored Petri Nets model that provides a new approach for scheduling Divide and Conquer problems on a multicore environment. Two new schedulers have been developed to control the actions of the model. The Multi Stealing Scheduler (MSS) has been designed to redistribute threads among the modelled cores. The MSS is general, scalable and it can be used for any Divide and Conquer problem. The second scheduler is the Local Threads Scheduler (LTS) that has the duty of threads creation and division inside each modelled core. In addition, the LTS introduces a new recursive method to provide the necessary information to multiply two matrices. Two main things have been achieved: First, workload among the modelled cores becomes well balanced; second, the technique produces a high level of concurrency between the elements of the model, which greatly minimise the execution time.", "paper_title": "A CONCURRENT MULTI-STEALING SCHEDULER MODEL FOR DIVIDE AND CONQUER PROBLEMS", "paper_id": "WOS:000312345300002"}