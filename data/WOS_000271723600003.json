{"auto_keywords": [{"score": 0.024078734408397192, "phrase": "metropolis"}, {"score": 0.00481495049065317, "phrase": "system_level_design"}, {"score": 0.004266501496765747, "phrase": "important_issue"}, {"score": 0.0038573081851680656, "phrase": "synchronization_dependencies"}, {"score": 0.003780286517897356, "phrase": "system-level_designs"}, {"score": 0.003594369823549604, "phrase": "data_structure"}, {"score": 0.0030895394261534776, "phrase": "concurrent_processes"}, {"score": 0.0029973957125353306, "phrase": "loop-detection_algorithm"}, {"score": 0.0026023381988430666, "phrase": "modeling_errors"}, {"score": 0.0024993218789131437, "phrase": "deadlock_problems"}, {"score": 0.002474417860581341, "phrase": "systemc"}, {"score": 0.0021049977753042253, "phrase": "complex_system-level_functional_models"}], "paper_keywords": ["Deadlock detection", " System-level design", " SystemC", " Metropolis"], "paper_abstract": "In the design of highly complex, heterogeneous and concurrent systems, deadlock detection remains an important issue. In this paper, we systematically analyze the synchronization dependencies in system-level designs. We propose a data structure called the dynamic synchronization dependency graph, which captures the runtime blocking dependencies among concurrent processes. A loop-detection algorithm is then used to detect deadlocks and help designers quickly isolate and identify modeling errors that cause the deadlock problems. We demonstrate our approach through two publicly available system-level modeling languages, SystemC and Metropolis, and two real world design examples, which are complex system-level functional models for video processing.", "paper_title": "Runtime deadlock analysis for system level design", "paper_id": "WOS:000271723600003"}