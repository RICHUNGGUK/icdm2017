{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "approximate_string_matching"}, {"score": 0.003449972561293443, "phrase": "space_efficient_indexes"}, {"score": 0.0029394074636168435, "phrase": "previously_best_solution"}, {"score": 0.002881130228859848, "phrase": "time_complexity"}, {"score": 0.0026771333996253783, "phrase": "new_index"}, {"score": 0.00255488432062653, "phrase": "existing_indexes"}, {"score": 0.002520990102833368, "phrase": "ka_parts"}, {"score": 0.002235433376874495, "phrase": "k-error_matching"}], "paper_keywords": ["Compressed index", " Approximate string matching"], "paper_abstract": "We revisit the problem of indexing a string S[1..n] to support finding all substrings in S that match a given pattern P[1..m] with at most k errors. Previous solutions either require an index of size exponential in k or need Omega(m (k) ) time for searching. Motivated by the indexing of DNA, we investigate space efficient indexes that occupy only O(n) space. For k=1, we give an index to support matching in O(m+occ+log nlog log n) time. The previously best solution achieving this time complexity requires an index of O(nlog n) space. This new index can also be used to improve existing indexes for ka parts per thousand yen2 errors. Among others, it can support 2-error matching in O(mlog nlog log n+occ) time, and k-error matching, for any k > 2, in O(m (k-1)log nlog log n+occ) time.", "paper_title": "Compressed Indexes for Approximate String Matching", "paper_id": "WOS:000279681700003"}