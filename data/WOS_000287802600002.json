{"auto_keywords": [{"score": 0.04845690845326017, "phrase": "cloud_computing"}, {"score": 0.03875817480881966, "phrase": "vm_cloning"}, {"score": 0.03796201124021819, "phrase": "vm"}, {"score": 0.00481495049065317, "phrase": "virtual_machine_cloning"}, {"score": 0.004753194996637899, "phrase": "first-class_cloud_primitive"}, {"score": 0.004692227830462433, "phrase": "basic_building_block"}, {"score": 0.0045726187330434025, "phrase": "virtual_machines"}, {"score": 0.004456044928556639, "phrase": "user's_computing_environment"}, {"score": 0.0041773934798743405, "phrase": "large_entities"}, {"score": 0.004106063237069123, "phrase": "clear_apis"}, {"score": 0.0036395944934310524, "phrase": "first-class_cloud_abstraction"}, {"score": 0.003441352119167824, "phrase": "unix_fork"}, {"score": 0.003382547312072468, "phrase": "multiple_usage_models"}, {"score": 0.003170811465728631, "phrase": "existing_toolchains"}, {"score": 0.003076630145189401, "phrase": "api"}, {"score": 0.003037047249598515, "phrase": "parallel_programming_framework"}, {"score": 0.0029467742734417255, "phrase": "load-balance_and_self-scale_clustered_servers"}, {"score": 0.0027503564589458837, "phrase": "vm_state"}, {"score": 0.0024586427394152196, "phrase": "multiple_vm_clones"}, {"score": 0.0022651818270925704, "phrase": "detailed_microbenchmark_results"}, {"score": 0.0021232402128269906, "phrase": "different_usage_models"}, {"score": 0.0021049977753042253, "phrase": "snowflock"}], "paper_keywords": ["Design", " Experimentation", " Measurement", " Performance", " Virtualization", " cloud computing"], "paper_abstract": "A basic building block of cloud computing is virtualization. Virtual machines (VMs) encapsulate a user's computing environment and efficiently isolate it from that of other users. VMs, however, are large entities, and no clear APIs exist yet to provide users with programatic, fine-grained control on short time scales. We present SnowFlock, a paradigm and system for cloud computing that introduces VM cloning as a first-class cloud abstraction. VM cloning exploits the well-understood and effective semantics of UNIX fork. We demonstrate multiple usage models of VM cloning: users can incorporate the primitive in their code, can wrap around existing toolchains via scripting, can encapsulate the API within a parallel programming framework, or can use it to load-balance and self-scale clustered servers. VM cloning needs to be efficient to be usable. It must efficiently transmit VM state in order to avoid cloud I/O bottlenecks. We demonstrate how the semantics of cloning aid us in realizing its efficiency: state is propagated in parallel to multiple VM clones, and is transmitted during runtime, allowing for optimizations that substantially reduce the I/O load. We show detailed microbenchmark results highlighting the efficiency of our optimizations, and macrobenchmark numbers demonstrating the effectiveness of the different usage models of SnowFlock.", "paper_title": "SnowFlock: Virtual Machine Cloning as a First-Class Cloud Primitive", "paper_id": "WOS:000287802600002"}