{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "cryptographic_operations"}, {"score": 0.004637478829869904, "phrase": "information_flow"}, {"score": 0.004383406949799696, "phrase": "information-flow_definitions"}, {"score": 0.004241648852523704, "phrase": "public_data"}, {"score": 0.0039716833701918365, "phrase": "encrypted_output"}, {"score": 0.003916098498242888, "phrase": "secret_inputs"}, {"score": 0.0035648266669315943, "phrase": "secret_keys"}, {"score": 0.0034984340449789745, "phrase": "underlying_cryptographic_algorithm"}, {"score": 0.003306559295382181, "phrase": "noninterference_definition"}, {"score": 0.0032602525602322832, "phrase": "safe_encryption"}, {"score": 0.0031845067058084583, "phrase": "key_generation"}, {"score": 0.0028446460307503343, "phrase": "small_imperative_language"}, {"score": 0.002818013056816282, "phrase": "primitive_cryptographic_operations"}, {"score": 0.002778529097886437, "phrase": "type_system"}, {"score": 0.002752513434446804, "phrase": "dangerous_program_behavior"}, {"score": 0.0026633568650501873, "phrase": "secret_key_or_confusing_keys"}, {"score": 0.0025290375256888883, "phrase": "secure_implementations"}, {"score": 0.0025053520095236694, "phrase": "cryptographic_protocols"}, {"score": 0.0024014759148123736, "phrase": "standard_noninterference_property"}, {"score": 0.0023127544795063263, "phrase": "natural_extensions"}, {"score": 0.0022378101636842296, "phrase": "public-key_cryptography"}, {"score": 0.0021049977753042253, "phrase": "chosen-ciphertext_attacks"}], "paper_keywords": [""], "paper_abstract": "Cryptographic operations are essential for many security-critical systems. Reasoning about information flow in such systems is challenging because typical (noninterference-based) information-flow definitions allow no flow from secret to public data. Unfortunately, this implies that programs with encryption are ruled out because encrypted output depends on secret inputs: the plaintext and the key. However, it is desirable to allow flows arising from encryption with secret keys provided that the underlying cryptographic algorithm is strong enough. In this paper we conservatively extend the noninterference definition to allow safe encryption, decryption, and key generation. To illustrate the usefulness of this approach, we propose (and implement) a type system that guarantees noninterference for a small imperative language with primitive cryptographic operations. The type system prevents dangerous program behavior (e.g., giving away a secret key or confusing keys and non-keys), which we exemplify with secure implementations of cryptographic protocols. Because the model is based on a standard noninterference property, it allows us to develop some natural extensions. In particular, we consider public-key cryptography and integrity, which accommodate reasoning about primitives that are vulnerable to chosen-ciphertext attacks.", "paper_title": "Cryptographically-masked flows", "paper_id": "WOS:000240590200023"}