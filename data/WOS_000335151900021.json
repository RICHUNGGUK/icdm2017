{"auto_keywords": [{"score": 0.041723255926009284, "phrase": "single_erasure"}, {"score": 0.026699092039806232, "phrase": "parity_nodes"}, {"score": 0.00481495049065317, "phrase": "minimum_storage_regenerating_codes"}, {"score": 0.0047804843375940835, "phrase": "distributed_storage_systems"}, {"score": 0.004628400269774981, "phrase": "multiple_storage_disks"}, {"score": 0.004369824355829779, "phrase": "k_symbols"}, {"score": 0.004338530593157634, "phrase": "n_disks"}, {"score": 0.004276610897002087, "phrase": "overall_system"}, {"score": 0.003923144245133288, "phrase": "repair_bandwidth"}, {"score": 0.0038950367927745267, "phrase": "array_codes"}, {"score": 0.0038256426589560774, "phrase": "stored_symbols"}, {"score": 0.00374399358035391, "phrase": "length_l._the_mds_array_codes"}, {"score": 0.003521961918342562, "phrase": "remaining_disks"}, {"score": 0.0034716556902775037, "phrase": "new_methods"}, {"score": 0.00333697550984782, "phrase": "storage_system_problem"}, {"score": 0.0033011569787033297, "phrase": "geometric_problem"}, {"score": 0.0029740732099993706, "phrase": "minimum_vector-length"}, {"score": 0.0028792911886505526, "phrase": "optimal_fraction"}, {"score": 0.00284837132359445, "phrase": "exact_recovery"}, {"score": 0.0028279422436488116, "phrase": "systematic_disks"}, {"score": 0.002797572252783356, "phrase": "mds_code"}, {"score": 0.0027775064989253575, "phrase": "low_redundancy"}, {"score": 0.0026889720516076205, "phrase": "best_known_explicit_codes"}, {"score": 0.0026600905156986317, "phrase": "subpacketization_factor_l"}, {"score": 0.002529347938294228, "phrase": "fixed_number"}, {"score": 0.002328326982534932, "phrase": "new_log-squared_converse"}, {"score": 0.0021049977753042253, "phrase": "arbitrary_number"}], "paper_keywords": ["distributed storage", " error correction codes", " interference alignment", " sub-packetization"], "paper_abstract": "Distributed storage systems employ codes to provide resilience to failure of multiple storage disks. In particular, an (n, k) maximum distance separable (MDS) code stores k symbols in n disks such that the overall system is tolerant to a failure of up to n - k disks. However, access to at least k disks is still required to repair a single erasure. To reduce repair bandwidth, array codes are used where the stored symbols or packets are vectors of length l. The MDS array codes have the potential to repair a single erasure using a fraction 1/(n - k) of data stored in the remaining disks. We introduce new methods of analysis, which capitalize on the translation of the storage system problem into a geometric problem on a set of operators and subspaces. In particular, we ask the following question: for a given (n, k), what is the minimum vector-length or subpacketization factor l required to achieve this optimal fraction? For exact recovery of systematic disks in an MDS code of low redundancy, i.e., k/n > 1/2, the best known explicit codes have a subpacketization factor l, which is exponential in k. It has been conjectured that for a fixed number of parity nodes, it is in fact necessary for l to be exponential in k. In this paper, we provide a new log-squared converse bound on k for a given l, and prove that k <= 2 log(2) l (log(delta) l + 1), for an arbitrary number of parity nodes r = n - k, where delta = r/(r - 1).", "paper_title": "An Improved Sub-Packetization Bound for Minimum Storage Regenerating Codes", "paper_id": "WOS:000335151900021"}