{"auto_keywords": [{"score": 0.03171809470416634, "phrase": "api_functions"}, {"score": 0.00481495049065317, "phrase": "fine-grained_program_structure"}, {"score": 0.00476527679607755, "phrase": "scriptable_api-usage_protocol-finding_process"}, {"score": 0.004401011982385274, "phrase": "tool_developer"}, {"score": 0.0043106348117582915, "phrase": "possible_specifications"}, {"score": 0.0041211075804202905, "phrase": "probable_specifications"}, {"score": 0.004078562617505643, "phrase": "common_characteristics"}, {"score": 0.003912712778141845, "phrase": "function_calls"}, {"score": 0.0038456073694665, "phrase": "observed_high_rate"}, {"score": 0.0038190873308414333, "phrase": "false_positives"}, {"score": 0.003551392586900308, "phrase": "false_negatives"}, {"score": 0.0035025644647418983, "phrase": "rarely_used_functions"}, {"score": 0.0033951334049808733, "phrase": "alternate_approach"}, {"score": 0.0033717094055177995, "phrase": "specification_inference"}, {"score": 0.00327961310338175, "phrase": "inference_process"}, {"score": 0.003190024306903021, "phrase": "user's_understanding"}, {"score": 0.003102875178186416, "phrase": "targeted_software_project"}, {"score": 0.0030180996912267683, "phrase": "correct_usage"}, {"score": 0.0029254845664637204, "phrase": "api_protocols"}, {"score": 0.002865320947289691, "phrase": "coccinelle_program"}, {"score": 0.0028554143163813947, "phrase": "matching_and_transformation_tool"}, {"score": 0.0026185499482623, "phrase": "source_code"}, {"score": 0.0025914765323897604, "phrase": "linux_kernel"}, {"score": 0.0025119200240696824, "phrase": "varying_properties"}, {"score": 0.002494602536909459, "phrase": "linux"}, {"score": 0.00246877952076635, "phrase": "critical_software"}, {"score": 0.002426378123762607, "phrase": "even_bugs"}, {"score": 0.0024096216848276094, "phrase": "rarely_used_protocols"}, {"score": 0.002271773887265199, "phrase": "estimated_false_positive_rate"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Linux", " bug finding", " program analysis"], "paper_abstract": "Bug-finding tools rely on specifications of what is correct or incorrect code. As it is difficult for a tool developer or user to anticipate all possible specifications, strategies for inferring specifications have been proposed. These strategies obtain probable specifications by observing common characteristics of code or execution traces, typically focusing on sequences of function calls. To counter the observed high rate of false positives, heuristics have been proposed for ranking or pruning the results. These heuristics, however, can result in false negatives, especially for rarely used functions. In this paper, we propose an alternate approach to specification inference, in which the user guides the inference process using patterns of code that reflect the user's understanding of the conventions and design of the targeted software project. We focus on specifications describing the correct usage of API functions, which we refer to as API protocols. Our approach builds on the Coccinelle program matching and transformation tool, which allows a user to construct patterns that reflect the structure of the code to be matched. We evaluate our approach on the source code of the Linux kernel, which defines a very large number of API functions with varying properties. Linux is also critical software, implying that fixing even bugs involving rarely used protocols is essential. In our experiments, we use our approach to find over 3000 potential API protocols, with an estimated false positive rate of under 15% and use these protocols to find over 360 bugs in the use of API functions. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "WYSIWIB: exploiting fine-grained program structure in a scriptable API-usage protocol-finding process", "paper_id": "WOS:000312653300003"}