{"auto_keywords": [{"score": 0.043472116430377704, "phrase": "parallel_programs"}, {"score": 0.00481495049065317, "phrase": "automatic_task_granularity_control"}, {"score": 0.0046834372388970405, "phrase": "programming_technique"}, {"score": 0.004472146692254812, "phrase": "wide_variety"}, {"score": 0.004431041346291019, "phrase": "problem_domains"}, {"score": 0.004370087541308677, "phrase": "central_parameter"}, {"score": 0.004211594861013822, "phrase": "efficient_execution"}, {"score": 0.0037006243674469657, "phrase": "combined_compiler"}, {"score": 0.0036665842836420223, "phrase": "runtime_approach"}, {"score": 0.003616108223034427, "phrase": "automatic_granularity_control"}, {"score": 0.003468796799802612, "phrase": "multiple_versions"}, {"score": 0.0032215231177304513, "phrase": "parallelism-aware_optimizing_transformation"}, {"score": 0.003177154457204775, "phrase": "superfluous_task_synchronization_primitives"}, {"score": 0.0031333949463567554, "phrase": "generated_versions"}, {"score": 0.00309023627455429, "phrase": "runtime_system"}, {"score": 0.0030196181347744372, "phrase": "task_versions"}, {"score": 0.002991823455621222, "phrase": "varying_granularity"}, {"score": 0.002936997013291548, "phrase": "task_demand"}, {"score": 0.0027913353347879507, "phrase": "work-stealing_scheduler"}, {"score": 0.0026775328564629577, "phrase": "fine-grained_tasks"}, {"score": 0.0025922289692173997, "phrase": "execution_time"}, {"score": 0.002266765479420981, "phrase": "generated_code_versions"}, {"score": 0.0022355167967736326, "phrase": "task_queue_length"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler", " runtime system", " parallel computing", " task parallelism", " multiversioning", " recursion"], "paper_abstract": "Task parallelism is a programming technique that has been shown to be applicable in a wide variety of problem domains. A central parameter that needs to be controlled to ensure efficient execution of task parallel programs is the granularity of tasks. When they are too coarse grained, scalability and load balance suffer, while very fine-grained tasks introduce execution overheads. We present a combined compiler and runtime approach that enables automatic granularity control. Starting from recursive, task parallel programs, our compiler generates multiple versions of each task, increasing granularity by task unrolling. Subsequently, we apply a parallelism-aware optimizing transformation to remove superfluous task synchronization primitives in all generated versions. A runtime system then selects among these task versions of varying granularity by locally tracking task demand. Benchmarking on a set of task parallel programs using a work-stealing scheduler demonstrates that our approach is generally effective. For fine-grained tasks, we can achieve reductions in execution time exceeding a factor of 6, compared with state-of-the-art implementations. Additionally, we evaluate the impact of two crucial algorithmic parameters, the number of generated code versions and the task queue length, on the performance of our method. Copyright (C) 2014 John Wiley & Sons, Ltd.", "paper_title": "Compiler multiversioning for automatic task granularity control", "paper_id": "WOS:000342806400003"}