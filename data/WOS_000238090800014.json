{"auto_keywords": [{"score": 0.023379810212876606, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "functional_programming"}, {"score": 0.0046993598473345395, "phrase": "robust_software_component"}, {"score": 0.003964007795174772, "phrase": "object-oriented_community"}, {"score": 0.00386876598761639, "phrase": "design-by-contract_approach"}, {"score": 0.0037150687722055727, "phrase": "language_extensions"}, {"score": 0.003567455727660992, "phrase": "higher-order_functional_programming"}, {"score": 0.0032629585038738856, "phrase": "embedded_domain-specific_language"}, {"score": 0.0027295084882654917, "phrase": "first_steps"}, {"score": 0.002436289099444074, "phrase": "generic_contract"}, {"score": 0.0023776656246300063, "phrase": "arbitrary_algebraic_data_types"}, {"score": 0.002320449502337321, "phrase": "contract_language"}, {"score": 0.0021049977753042253, "phrase": "generalised_algebraic_data_types"}], "paper_keywords": [""], "paper_abstract": "A robust software component fulfills a contract: it expects data satisfying a certain property and promises to return data satisfying another property. The object-oriented community uses the design-by-contract approach extensively. Proposals for language extensions that add contracts to higher-order functional programming have appeared recently. In this paper we propose an embedded domain-specific language for typed, higher-order and first-class contracts, which is both more expressive than previous proposals, and allows for a more informative blame assignment. We take some first steps towards an algebra of contracts, and we show how to define a generic contract combinator for arbitrary algebraic data types. The contract language is implemented as a library in Haskell using the concept of generalised algebraic data types.", "paper_title": "Typed contracts for functional programming", "paper_id": "WOS:000238090800014"}