{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "driven_architectural_adaptation"}, {"score": 0.004593787100061613, "phrase": "general_frameworks"}, {"score": 0.0045324756541157574, "phrase": "reference_architectures"}, {"score": 0.004382737590042589, "phrase": "application_architecture"}, {"score": 0.004237925318473508, "phrase": "concrete_concepts"}, {"score": 0.004016072233242585, "phrase": "software_architecture"}, {"score": 0.0038314621564116192, "phrase": "high-end_embedded_component_based_applications"}, {"score": 0.0036064757492752703, "phrase": "music_application"}, {"score": 0.003195236629209403, "phrase": "separate_constructs"}, {"score": 0.0030688220103201836, "phrase": "adaptation_decision_logic"}, {"score": 0.002907992115184249, "phrase": "independent_specification"}, {"score": 0.002628747284714371, "phrase": "important_constraints"}, {"score": 0.002507748938616919, "phrase": "reusable_run-time_counterparts"}, {"score": 0.0023287359930308864, "phrase": "component_middleware"}, {"score": 0.002251637552201872, "phrase": "architectural_specification"}, {"score": 0.0021049977753042253, "phrase": "additional_self-adaptation_code"}], "paper_keywords": [""], "paper_abstract": "Self-adaptation is currently addressed in general frameworks and reference architectures but not in the application architecture. This paper defines concrete concepts to specify timing driven self-adaptation in the software architecture. This self-adaptation is aimed at high-end embedded component based applications. We create an architectural view of a music application describing this kind of adaptation and discuss its implementation. The novelty of our approach is the definition of separate constructs for the monitoring, the adaptation decision logic and the adaptation itself. This allows independent specification of policy and mechanisms and the possibility to adapt other applications in order to satisfy important constraints. The implementation itself consists of reusable run-time counterparts of the constructs. These counterparts are managed by the component middleware and configured by the architectural specification. This way one does not need to write additional self-adaptation code.", "paper_title": "Timing driven architectural adaptation", "paper_id": "WOS:000239059700019"}