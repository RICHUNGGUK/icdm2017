{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "communication_procedures"}, {"score": 0.004783852487938866, "phrase": "real-time_synchronous_reactive_models"}, {"score": 0.004752954376588157, "phrase": "model-based_design_methodologies"}, {"score": 0.004661446705304497, "phrase": "industrial_community"}, {"score": 0.004571692719970733, "phrase": "early_and_efficient_functional_validation"}, {"score": 0.004469151810727749, "phrase": "high_levels"}, {"score": 0.004312622975366676, "phrase": "high-level_models"}, {"score": 0.004081385289516914, "phrase": "higher_abstraction_levels"}, {"score": 0.00397688190820577, "phrase": "lower_levels"}, {"score": 0.0038375280115736958, "phrase": "design_time"}, {"score": 0.0038127186374325582, "phrase": "automatic_synthesis"}, {"score": 0.0037392451233558234, "phrase": "refinement_process"}, {"score": 0.0037150687722055727, "phrase": "register_transfer_languages"}, {"score": 0.0036553070575015344, "phrase": "logic_gates"}, {"score": 0.003631671435460452, "phrase": "digital_circuit_design"}, {"score": 0.003527181559366122, "phrase": "synthesis_algorithms"}, {"score": 0.0034145918296403874, "phrase": "rtl_description"}, {"score": 0.0033163269450817716, "phrase": "logic_circuit"}, {"score": 0.003294875957676514, "phrase": "automatic_code_generation"}, {"score": 0.0031793439438669176, "phrase": "software_implementation"}, {"score": 0.0031485421129798996, "phrase": "abstract_model"}, {"score": 0.003118037760163957, "phrase": "efficient_use"}, {"score": 0.0030878280304339587, "phrase": "platform_resources"}, {"score": 0.002998938434207771, "phrase": "code_generation_algorithms"}, {"score": 0.002922069655177295, "phrase": "synchronous_reactive_model"}, {"score": 0.0029031614127920232, "phrase": "buffering_and_access_procedures"}, {"score": 0.002875027551180213, "phrase": "kernel_level"}, {"score": 0.0028471655497661528, "phrase": "previous_work"}, {"score": 0.0028104345972072534, "phrase": "tight_bounds"}, {"score": 0.0027651847105654363, "phrase": "communication_buffers"}, {"score": 0.0027383842769094354, "phrase": "semantic_equivalence"}, {"score": 0.002711842889248926, "phrase": "real-time_systems"}, {"score": 0.00265090644169702, "phrase": "longer_execution_times"}, {"score": 0.0026337482179592422, "phrase": "access_procedures"}, {"score": 0.002591335708291347, "phrase": "minimum_buffer_size"}, {"score": 0.0024521640882380477, "phrase": "mixed_integer_linear_programming"}, {"score": 0.002389276641014013, "phrase": "minimum_memory_implementation"}, {"score": 0.0023507916951658455, "phrase": "communication_channels"}, {"score": 0.002312925203110055, "phrase": "task_deadline_constraints"}, {"score": 0.002195794209219447, "phrase": "actual_runtime_overheads"}, {"score": 0.002125612498781805, "phrase": "task_graphs"}, {"score": 0.0021049977753042253, "phrase": "automotive_case_study"}], "paper_keywords": ["Design optimization", " model-based design", " OSEK", " real-time"], "paper_abstract": "Model-based design methodologies are gaining attention in the industrial community because of the possibility of early and efficient functional validation and formal verification of properties at high levels of abstraction. The advantages of validating the design using high-level models can be lost entirely if errors and modifications that are not back-annotated to the higher abstraction levels are introduced when refining the design to lower levels of abstraction. To overcome this problem and to reduce design time, automatic synthesis has been used for the refinement process from Register Transfer Languages (RTLs) to logic gates for digital circuit design. This approach guarantees (assuming that the synthesis algorithms are correctly implemented) that the semantic of the RTL description is semantically equivalent to the semantic of the logic circuit. Automatic code generation is similar in intent and applicability. However, the software implementation of the abstract model must make efficient use of the platform resources that may not reflect all the assumptions of the code generation algorithms. The implementation of communication in a synchronous reactive model requires buffering and access procedures at the kernel level. In previous work, we obtained tight bounds on the size of communication buffers to maintain semantic equivalence. In real-time systems, however, because of the longer execution times of access procedures, an implementation with minimum buffer size may lead to the violation of deadlines. To solve this problem, we propose a Mixed Integer Linear Programming (MILP)-based optimization approach that provides the minimum memory implementation of a set of communication channels while guaranteeing that the task deadline constraints are met. The analysis is validated by an OSEK/VDX-compliant implementation that provides an estimate of actual runtime overheads. The approach is applied to a set of task graphs and an automotive case study.", "paper_title": "Optimal Synthesis of Communication Procedures in Real-Time Synchronous Reactive Models", "paper_id": "WOS:000283984900022"}