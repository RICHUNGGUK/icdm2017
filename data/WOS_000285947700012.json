{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "recursive_aggregates"}, {"score": 0.04133861832131945, "phrase": "answer_sets"}, {"score": 0.041055133152731224, "phrase": "aggregate-free_case"}, {"score": 0.004580111085682869, "phrase": "set_programming"}, {"score": 0.004558443815564089, "phrase": "asp"}, {"score": 0.004493678442621812, "phrase": "modelling_power"}, {"score": 0.00442992128941259, "phrase": "natural_and_concise_problem_representations"}, {"score": 0.004315363208893499, "phrase": "non-recursive_aggregates"}, {"score": 0.004017706312136239, "phrase": "desirable_criteria"}, {"score": 0.0038034297106928384, "phrase": "arbitrary_aggregates"}, {"score": 0.003687392947724945, "phrase": "full_asp_language"}, {"score": 0.003515725227424245, "phrase": "genuine_generalization"}, {"score": 0.003457553759574519, "phrase": "dlp"}, {"score": 0.003400319264221666, "phrase": "natural_variant"}, {"score": 0.003376084893512277, "phrase": "gelfond-lifschitz_transformation"}, {"score": 0.003344039961676564, "phrase": "aggregate_and_non-aggregate_literals"}, {"score": 0.0032886890742735778, "phrase": "novel_transformation"}, {"score": 0.0031655778592193247, "phrase": "original_transformation"}, {"score": 0.003105756008031797, "phrase": "positive_and_negative_literals"}, {"score": 0.0029329686356429113, "phrase": "standard_answer_set_semantics"}, {"score": 0.0029190098927559514, "phrase": "aggregate-free_programs"}, {"score": 0.0028638341999370344, "phrase": "in-depth_study"}, {"score": 0.0028434124957766446, "phrase": "computational_complexity"}, {"score": 0.002789661761685155, "phrase": "particular_attention"}, {"score": 0.0027565833296749674, "phrase": "syntactical_restrictions"}, {"score": 0.0027109296352617208, "phrase": "limited_use"}, {"score": 0.002578443684503779, "phrase": "full_dlp_language"}, {"score": 0.0024582760561790186, "phrase": "asp_programs"}, {"score": 0.002434921446474405, "phrase": "second_level"}, {"score": 0.00241755085920605, "phrase": "polynomial_hierarchy"}, {"score": 0.002366177336806313, "phrase": "large_classes"}, {"score": 0.0023048642674654875, "phrase": "complexity_gap"}, {"score": 0.002288419372085304, "phrase": "normal_programs"}, {"score": 0.0022505017689986835, "phrase": "arbitrary_monotone"}, {"score": 0.0022397837630257654, "phrase": "arbitrary_antimonotone"}, {"score": 0.0021765368728946283, "phrase": "useful_indications"}, {"score": 0.0021353654932854127, "phrase": "existing_reasoning_engines"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Nonmonotonic reasoning", " Answer set programming", " Aggregates", " Computational complexity"], "paper_abstract": "The addition of aggregates has been one of the most relevant enhancements to the language of answer set programming (ASP). They strengthen the modelling power of ASP in terms of natural and concise problem representations. Previous semantic definitions typically agree in the case of non-recursive aggregates, but the picture is less clear for aggregates involved in recursion. Some proposals explicitly avoid recursive aggregates, most others differ, and many of them do not satisfy desirable criteria, such as minimality or coincidence with answer sets in the aggregate-free case. In this paper we define a semantics for programs with arbitrary aggregates (including monotone, antimonotone, and nonmonotone aggregates) in the full ASP language allowing also for disjunction in the head (disjunctive logic programming - DLP). This semantics is a genuine generalization of the answer set semantics for DLP, it is defined by a natural variant of the Gelfond-Lifschitz transformation, and treats aggregate and non-aggregate literals in a uniform way. This novel transformation is interesting per se also in the aggregate-free case, since it is simpler than the original transformation and does not need to differentiate between positive and negative literals. We prove that our semantics guarantees the minimality (and therefore the incomparability) of answer sets, and we demonstrate that it coincides with the standard answer set semantics on aggregate-free programs. Moreover, we carry out an in-depth study of the computational complexity of the language. The analysis pays particular attention to the impact of syntactical restrictions on programs in the form of limited use of aggregates, disjunction, and negation. While the addition of aggregates does not affect the complexity of the full DLP language, it turns out that their presence does increase the complexity of normal (i.e., non-disjunctive) ASP programs up to the second level of the polynomial hierarchy. However, we show that there are large classes of aggregates the addition of which does not cause any complexity gap even for normal programs, including the fragment allowing for arbitrary monotone, arbitrary antimonotone, and stratified (i.e., non-recursive) nonmonotone aggregates. The analysis provides some useful indications on the possibility to implement aggregates in existing reasoning engines. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Semantics and complexity of recursive aggregates in answer set programming", "paper_id": "WOS:000285947700012"}