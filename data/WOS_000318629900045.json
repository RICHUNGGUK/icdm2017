{"auto_keywords": [{"score": 0.03571085515932045, "phrase": "base_theory"}, {"score": 0.00481495049065317, "phrase": "craig_interpolation"}, {"score": 0.004727837281331949, "phrase": "valuable_tool"}, {"score": 0.0046848707075530256, "phrase": "formal_methods"}, {"score": 0.004642292792558686, "phrase": "interesting_applications"}, {"score": 0.004600100053651545, "phrase": "program_analysis"}, {"score": 0.004516856326107826, "phrase": "modern_smt_solvers"}, {"score": 0.004475798524102238, "phrase": "interpolation_procedures"}, {"score": 0.003956558420993431, "phrase": "interpolation-based_techniques"}, {"score": 0.0037798652680135106, "phrase": "generic_framework"}, {"score": 0.0037284065559949064, "phrase": "new_interpolation_procedures"}, {"score": 0.003660879039645457, "phrase": "existing_interpolation_procedures"}, {"score": 0.0035294580355761506, "phrase": "application-specific_theory"}, {"score": 0.003356396922662246, "phrase": "additional_symbols"}, {"score": 0.003265591844292821, "phrase": "finite_instantiation"}, {"score": 0.003221111762383486, "phrase": "extension_axioms"}, {"score": 0.0031627430133087616, "phrase": "interpolation_problem"}, {"score": 0.003119659433566212, "phrase": "theory_extension"}, {"score": 0.0029802289354540507, "phrase": "model-theoretic_criterion"}, {"score": 0.002782647772219627, "phrase": "specific_theories"}, {"score": 0.0027197343489967322, "phrase": "program_verification"}, {"score": 0.0025744696954056404, "phrase": "complete_interpolation_procedures"}, {"score": 0.0025047659706737215, "phrase": "linked_lists"}, {"score": 0.00243694486220507, "phrase": "first_complete_interpolation_procedure"}, {"score": 0.002349357968054713, "phrase": "complex_shape_properties"}, {"score": 0.002327956449278255, "phrase": "heap-allocated_data_structures"}, {"score": 0.002193509835371438, "phrase": "existing_smt_solvers"}, {"score": 0.0021243539405631866, "phrase": "loop_invariants"}, {"score": 0.0021049977753042253, "phrase": "list-manipulating_programs"}], "paper_keywords": ["Algorithms", " Theory", " Reliability", " Verification", " Craig Interpolants", " Decision Procedures", " Satisfiability Module Theories", " Program Analysis", " Data Structures"], "paper_abstract": "Craig interpolation has been a valuable tool for formal methods with interesting applications in program analysis and verification. Modern SMT solvers implement interpolation procedures for the theories that are most commonly used in these applications. However, many application-specific theories remain unsupported, which limits the class of problems to which interpolation-based techniques apply. In this paper, we present a generic framework to build new interpolation procedures via reduction to existing interpolation procedures. We consider the case where an application-specific theory can be formalized as an extension of a base theory with additional symbols and axioms. Our technique uses finite instantiation of the extension axioms to reduce an interpolation problem in the theory extension to one in the base theory. We identify a model-theoretic criterion that allows us to detect the cases where our technique is complete. We discuss specific theories that are relevant in program verification and that satisfy this criterion. In particular, we obtain complete interpolation procedures for theories of arrays and linked lists. The latter is the first complete interpolation procedure for a theory that supports reasoning about complex shape properties of heap-allocated data structures. We have implemented this procedure in a prototype on top of existing SMT solvers and used it to automatically infer loop invariants of list-manipulating programs.", "paper_title": "Complete Instantiation-Based Interpolation", "paper_id": "WOS:000318629900045"}