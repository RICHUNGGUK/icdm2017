{"auto_keywords": [{"score": 0.02628533816143664, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "multithreaded_java"}, {"score": 0.004773476989344654, "phrase": "security_monitor_inlining"}, {"score": 0.004671342094877447, "phrase": "security_policy_enforcement"}, {"score": 0.004631099806015235, "phrase": "monitor_functionality"}, {"score": 0.004551647527068771, "phrase": "application_code"}, {"score": 0.004454237726525018, "phrase": "aspect-oriented_programming"}, {"score": 0.0043213410601860985, "phrase": "injected_code"}, {"score": 0.0037299231609021783, "phrase": "sequential_java-like_languages"}, {"score": 0.003510507340837656, "phrase": "multithreaded_java_one_difficulty"}, {"score": 0.003405671497507337, "phrase": "shared_monitor_state"}, {"score": 0.0032896745636186824, "phrase": "fundamental_limitations"}, {"score": 0.0032191849045822415, "phrase": "security_policies"}, {"score": 0.0030560920414081645, "phrase": "race-free_policies"}, {"score": 0.0029647862293448895, "phrase": "inlineable_policies"}, {"score": 0.0026835045963349647, "phrase": "concrete_inliner"}, {"score": 0.0023974563359295043, "phrase": "practical_application_security_policies"}, {"score": 0.0022758994740331258, "phrase": "proof-carrying_code"}, {"score": 0.002227083991228041, "phrase": "inlined_programs"}, {"score": 0.0021604924928015283, "phrase": "potentially_complex_verification_problem"}, {"score": 0.0021418339161425994, "phrase": "multithreaded_java_bytecode"}, {"score": 0.0021233361369222344, "phrase": "sequential_verification"}], "paper_keywords": [""], "paper_abstract": "Security monitor inlining is a technique for security policy enforcement whereby monitor functionality is injected into application code in the style of aspect-oriented programming. The intention is that the injected code enforces compliance with the policy (security), and otherwise interferes with the application as little as possible (conservativity and transparency). Such inliners are said to be correct. For sequential Java-like languages, inlining is well understood, and several provably correct inliners have been proposed. For multithreaded Java one difficulty is the need to maintain a shared monitor state. We show that this problem introduces fundamental limitations in the type of security policies that can be correctly enforced by inlining. A class of race-free policies is identified that precisely characterizes the inlineable policies by showing that inlining of a policy outside this class is either not secure or not transparent, and by exhibiting a concrete inliner for policies inside the class which is secure, conservative and transparent. The inliner is implemented for Java and applied to a number of practical application security policies. Finally, we discuss how certification in the style of proof-carrying code could be supported for inlined programs by using annotations to reduce a potentially complex verification problem for multithreaded Java bytecode to sequential verification of just the inlined code snippets.", "paper_title": "Security monitor inlining and certification for multithreaded Java", "paper_id": "WOS:000348369900003"}