{"auto_keywords": [{"score": 0.03654234973952578, "phrase": "neighboring_rows"}, {"score": 0.014545315295587561, "phrase": "lower_technology_nodes"}, {"score": 0.013092987836821867, "phrase": "row_hammering"}, {"score": 0.01256447977771882, "phrase": "data_loss"}, {"score": 0.011676416208225947, "phrase": "row_activations"}, {"score": 0.00481495049065317, "phrase": "architectural_support_for_mitigating_row_hammering"}, {"score": 0.0047707093928203, "phrase": "dram_memories"}, {"score": 0.0047268728636719725, "phrase": "dram_scaling"}, {"score": 0.004640398886726948, "phrase": "prime_driver"}, {"score": 0.004534517530868195, "phrase": "main_memory_systems"}, {"score": 0.004390312150344245, "phrase": "cell_reliability"}, {"score": 0.0042506731642425275, "phrase": "adjacent_dram_cells"}, {"score": 0.004172874316207784, "phrase": "different_failure_modes"}, {"score": 0.004058826900076531, "phrase": "reliability_problem"}, {"score": 0.003947884118204803, "phrase": "frequent_activations"}, {"score": 0.003405410366562619, "phrase": "row"}, {"score": 0.003358368814209542, "phrase": "challenging_problem"}, {"score": 0.0033274664434575136, "phrase": "future_dram_chips"}, {"score": 0.0030618067835788292, "phrase": "cra"}, {"score": 0.002702415623060517, "phrase": "dummy_activation"}, {"score": 0.0025447065763362984, "phrase": "probabilistic_row_activation"}, {"score": 0.0024636239664210433, "phrase": "storage_overhead"}, {"score": 0.0023851187337905412, "phrase": "memory_controller"}, {"score": 0.002363150587804677, "phrase": "proactively_issue"}, {"score": 0.0022878396720586044, "phrase": "small_probability"}, {"score": 0.0022563011263787847, "phrase": "memory_access"}, {"score": 0.0021049977753042253, "phrase": "negligible_performance_loss"}], "paper_keywords": ["Dynamic random access memory", " row hammering", " data retention", " data errors"], "paper_abstract": "DRAM scaling has been the prime driver of increasing capacity of main memory systems. Unfortunately, lower technology nodes worsen the cell reliability as it increases the coupling between adjacent DRAM cells, thereby exacerbating different failure modes. This paper investigates the reliability problem due to Row Hammering, whereby frequent activations of a given row can cause data loss for its neighboring rows. As DRAM scales to lower technology nodes, the threshold for the number of row activations that causes data loss for the neighboring rows reduces, making Row Hammering a challenging problem for future DRAM chips. To overcome Row Hammering, we propose two architectural solutions: First, Counter-Based Row Activation (CRA), which uses a counter with each row to count the number of row activations. If the count exceeds the row hammering threshold, a dummy activation is sent to neighboring rows proactively to refresh the data. Second, Probabilistic Row Activation (PRA), which obviates storage overhead of tracking and simply allows the memory controller to proactively issue dummy activations to neighboring rows with a small probability for all memory access. Our evaluations show that these solutions are effective at mitigating Row hammering while causing negligible performance loss (< 1 percent).", "paper_title": "Architectural Support for Mitigating Row Hammering in DRAM Memories", "paper_id": "WOS:000356718700003"}