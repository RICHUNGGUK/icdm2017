{"auto_keywords": [{"score": 0.04952003448686007, "phrase": "memory_sharing_overheads"}, {"score": 0.041821166199646924, "phrase": "lazy_home_allocation"}, {"score": 0.00481495049065317, "phrase": "runtime_techniques"}, {"score": 0.004721602309430702, "phrase": "distributed_java_implementations"}, {"score": 0.00468476935399643, "phrase": "distributed_java"}, {"score": 0.00454027551702508, "phrase": "concurrent_java_applications"}, {"score": 0.004417487764326481, "phrase": "commodity_computers"}, {"score": 0.004298006360831255, "phrase": "java's_shared-memory_model"}, {"score": 0.004181743040532619, "phrase": "cluster's_computer_nodes"}, {"score": 0.004021065055449586, "phrase": "selective_dynatnic_diffing"}, {"score": 0.003806395038279074, "phrase": "memory_sharing"}, {"score": 0.003561017335579207, "phrase": "message_traffic"}, {"score": 0.0035332058983966424, "phrase": "extra_memory_space"}, {"score": 0.003491894048789576, "phrase": "high_latency"}, {"score": 0.0034646205853140558, "phrase": "remote_memory"}, {"score": 0.003203294948113915, "phrase": "performance-related_benefits"}, {"score": 0.003056029284235528, "phrase": "cooperative_jvm"}, {"score": 0.002915514089373717, "phrase": "previous_work"}, {"score": 0.002881403688962202, "phrase": "subsequent_work"}, {"score": 0.002825435048559866, "phrase": "performance_comparisons"}, {"score": 0.002792375587031108, "phrase": "basic_cojvm"}, {"score": 0.0027597018725736165, "phrase": "cojvm"}, {"score": 0.002727409429089543, "phrase": "five_representative_concurrent_lava_applications"}, {"score": 0.002653526649031019, "phrase": "radix"}, {"score": 0.0026236236532445165, "phrase": "fourier"}, {"score": 0.002501835053002899, "phrase": "dynamic_doffing"}, {"score": 0.002472552537325604, "phrase": "home_allocation"}, {"score": 0.00238674051726235, "phrase": "considerable_gains"}, {"score": 0.0023680783509308525, "phrase": "cojvm_system's_performance"}, {"score": 0.002259123228671651, "phrase": "five_applications"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Java", " JVM", " distributed shared memory", " cluster computing", " concurrent Java applications", " high performance computing"], "paper_abstract": "Distributed Java virtual machine (dJVM) systems enable concurrent Java applications to transparently run on clusters of commodity computers. This is achieved by supporting Java's shared-memory model over multiple JVMs distributed across the cluster's computer nodes. In this work, we describe and evaluate selective dynatnic diffing and lazy home allocation, two new runtime techniques that enable dJVMs to efficiently support memory sharing across the cluster. Specifically, the two proposed techniques can contribute to reduce the overheads due to message traffic, extra memory space, and high latency of remote memory accesses that such dJVM systems require for implementing their memory-coherence protocol either in isolation or in combination. In order to evaluate the performance-related benefits of dynamic diffing and lazy home allocation, we implemented both techniques in Cooperative JVM (CoJVM), it basic dJVM system we developed in previous work. In subsequent work, we carried out performance comparisons between the basic CoJVM and modified CoJVM versions for five representative concurrent lava applications (matrix multiply, LU, Radix, fast Fourier transform, and SOR) using our proposed techniques. Our experimental results showed that dynamic doffing and lazy home allocation significantly reduced memory sharing overheads. The reduction resulted in considerable gains in CoJVM system's performance, ranging front 9% tip to 20%, in four out of the five applications, with resulting speedups varying front 6.5 tip to 8.1 for in 8-node cluster of computers. Copyright (C) 2007 John Wiley & Sons, Ltd.", "paper_title": "On the effectiveness of runtime techniques to reduce memory sharing overheads in distributed Java implementations", "paper_id": "WOS:000258740600002"}