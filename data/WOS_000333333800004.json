{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "linear_programs"}, {"score": 0.015496930491878622, "phrase": "predicate_abstraction_refinement"}, {"score": 0.01468882623894948, "phrase": "input_program"}, {"score": 0.010681557158007782, "phrase": "array_elements"}, {"score": 0.004661116930794176, "phrase": "leading_approaches"}, {"score": 0.0046276016230633495, "phrase": "software_verification"}, {"score": 0.004577777897335174, "phrase": "key_idea"}, {"score": 0.004447509888681154, "phrase": "boolean_program"}, {"score": 0.004305364955542171, "phrase": "boolean_values"}, {"score": 0.004228359613476549, "phrase": "truth_values"}, {"score": 0.0041079938275505575, "phrase": "program_state"}, {"score": 0.004005476499933792, "phrase": "new_predicates"}, {"score": 0.0038775347191095967, "phrase": "boolean"}, {"score": 0.0036072171658966348, "phrase": "tight_interplay"}, {"score": 0.0034293295415901807, "phrase": "novel_counterexample_guided_abstraction_refinement_procedure"}, {"score": 0.0033076455392068095, "phrase": "c_programming_language"}, {"score": 0.0032134045046357876, "phrase": "numeric_domain"}, {"score": 0.0031672925196105663, "phrase": "linear_combinations"}, {"score": 0.0029571101238632783, "phrase": "array_indices"}, {"score": 0.0028936710552719806, "phrase": "linear_program"}, {"score": 0.002790940765338191, "phrase": "new_array_indices"}, {"score": 0.0026532001044943096, "phrase": "boolean_programs"}, {"score": 0.0025868936783877035, "phrase": "complex_correlations"}, {"score": 0.002468107263634476, "phrase": "predicate_abstraction"}, {"score": 0.0023804491500749106, "phrase": "important_feature"}, {"score": 0.0022876085523721324, "phrase": "precise_account"}, {"score": 0.0022466111771668406, "phrase": "model_checking"}, {"score": 0.00216680270402079, "phrase": "eureka_tool"}, {"score": 0.002127965733093433, "phrase": "detailed_analysis"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": [""], "paper_abstract": "Predicate abstraction refinement is one of the leading approaches to software verification. The key idea is to abstract the input program into a Boolean Program (i.e. a program whose variables range over the Boolean values only and model the truth values of predicates corresponding to properties of the program state), and refinement searches for new predicates in order to build a new, more refined abstraction. Thus Boolean programs are commonly employed as a simple, yet useful abstraction. However, the effectiveness of predicate abstraction refinement on programs that involve a tight interplay between data-flow and control-flow is still to be ascertained. We present a novel counterexample guided abstraction refinement procedure for Linear Programs with arrays, a fragment of the C programming language where variables and array elements range over a numeric domain and expressions involve linear combinations of variables and array elements. In our procedure the input program is abstracted w.r.t. a family of sets of array indices, the abstraction is a Linear Program (without arrays), and refinement searches for new array indices. We use Linear Programs as the target of the abstraction (instead of Boolean programs) as they allow to express complex correlations between data and control. Thus, unlike the approaches based on predicate abstraction, our approach treats arrays precisely. This is an important feature as arrays are ubiquitous in programming. We provide a precise account of the abstraction, Model Checking, and refinement processes, discuss their implementation in the EUREKA tool, and present a detailed analysis of the experimental results confirming the effectiveness of our approach on a number of programs of interest.", "paper_title": "Counterexample-guided abstraction refinement for linear programs with arrays", "paper_id": "WOS:000333333800004"}