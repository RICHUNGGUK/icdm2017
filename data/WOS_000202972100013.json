{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "weakly_typed_languages"}, {"score": 0.014807019003566596, "phrase": "possible_memory_errors"}, {"score": 0.013535010661734768, "phrase": "call_graph"}, {"score": 0.004782718554230406, "phrase": "static_analysis"}, {"score": 0.0044870272550540415, "phrase": "dangling_pointer_references"}, {"score": 0.004456980650437417, "phrase": "uninitialized_pointers"}, {"score": 0.004412285905508977, "phrase": "array_bounds"}, {"score": 0.00432423070113186, "phrase": "compilation_strategy"}, {"score": 0.004295269532032448, "phrase": "standard_c_programs"}, {"score": 0.004237925318473508, "phrase": "aggressive_interprocedural_pointer_analysis"}, {"score": 0.0038314621564116192, "phrase": "new_type_system"}, {"score": 0.0037930162319613856, "phrase": "necessary_run-time_checks"}, {"score": 0.003487222504700868, "phrase": "c_programs"}, {"score": 0.003360578019762703, "phrase": "previously_published_transformation"}, {"score": 0.00333804919565419, "phrase": "automatic_pool_allocation"}, {"score": 0.003058515297281172, "phrase": "key_insight"}, {"score": 0.00300749708357049, "phrase": "pool_allocation"}, {"score": 0.002937493907103812, "phrase": "run-time_partitioning"}, {"score": 0.002878785759716458, "phrase": "compile-time_memory"}, {"score": 0.002783527398566117, "phrase": "efficient_checks"}, {"score": 0.0027187231747900814, "phrase": "run-time_partitions"}, {"score": 0.002646501671714952, "phrase": "sound_analysis_information"}, {"score": 0.002628747284714371, "phrase": "static_checking_techniques"}, {"score": 0.0025503112711036994, "phrase": "source_code_changes"}, {"score": 0.0024084679931209514, "phrase": "individual_tag_bits"}, {"score": 0.0023523750536537102, "phrase": "system_codes"}, {"score": 0.002297585503415527, "phrase": "run-time_overheads"}, {"score": 0.002251637552201872, "phrase": "nearly_all_cases"}, {"score": 0.002214048743052355, "phrase": "worst_case"}, {"score": 0.0021263705039915198, "phrase": "static_analyses"}, {"score": 0.0021049977753042253, "phrase": "run-time_checks"}], "paper_keywords": ["reliability", " security", " languages", " compilers", " programming languages", " alias analysis", " region management", " automatic pool allocation"], "paper_abstract": "Static analysis of programs in weakly typed languages such as C and C++ is generally not sound because of possible memory errors due to dangling pointer references, uninitialized pointers, and array bounds overflow. We describe a compilation strategy for standard C programs that guarantees that aggressive interprocedural pointer analysis (or less precise ones), a call graph, and type information for a subset of memory, are never invalidated by any possible memory errors. We formalize our approach as a new type system with the necessary run-time checks in operational semantics and prove the correctness of our approach for a subset of C. Our semantics provide the foundation for other sophisticated static analyses to be applied to C programs with a guarantee of soundness. Our work builds on a previously published transformation called Automatic Pool Allocation to ensure that hard-to-detect memory errors (dangling pointer references and certain array bounds errors) cannot invalidate the call graph, points-to information or type information. The key insight behind our approach is that pool allocation can be used to create a run-time partitioning of memory that matches the compile-time memory partitioning in a points-to graph, and efficient checks can be used to isolate the run-time partitions. Furthermore, we show that the sound analysis information enables static checking techniques that eliminate many run-time checks. Our approach requires no source code changes, allows memory to be managed explicitly, and does not use meta-data on pointers or individual tag bits for memory. Using several benchmarks and system codes, we show experimentally that the run-time overheads are low (less than 10% in nearly all cases and 30% in the worst case we have seen). We also show the effectiveness of static analyses in eliminating run-time checks.", "paper_title": "SAFECode: Enforcing alias analysis for weakly typed languages", "paper_id": "WOS:000202972100013"}