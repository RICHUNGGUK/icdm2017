{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "recursive_function_definitions"}, {"score": 0.004645057834614705, "phrase": "strictness_information"}, {"score": 0.004401342842183475, "phrase": "appropriate_strictness_information"}, {"score": 0.003951453722517865, "phrase": "uniform_treatment"}, {"score": 0.0038119123317396954, "phrase": "lazy_and_eager_evaluation_strategies"}, {"score": 0.0034841647157189985, "phrase": "first-order_functions"}, {"score": 0.003071965703296204, "phrase": "pure_stack_implementation"}, {"score": 0.002708399936381754, "phrase": "lazy_arguments"}, {"score": 0.0025202582748972122, "phrase": "algebraic_definitions"}, {"score": 0.0021049977753042253, "phrase": "structural_induction"}], "paper_keywords": ["functional languages", " evaluation strategies", " compiler correctness", " formal semantics", " stack implementation"], "paper_abstract": "Adding appropriate strictness information to recursive function definitions we achieve a uniform treatment of lazy and eager evaluation strategies. By restriction to first-order functions over basic types we develop a pure stack implementation that avoids a heap even for lazy arguments. We present algebraic definitions of denotational, operational, and stack-machine semantics and prove their equivalence by means of structural induction.", "paper_title": "Algebraic correctness proofs for compiling recursive function definitions with strictness information", "paper_id": "WOS:000238316700001"}