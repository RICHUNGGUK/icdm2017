{"auto_keywords": [{"score": 0.028047692795849073, "phrase": "skeletonization_process"}, {"score": 0.00481495049065317, "phrase": "code_skeletonization"}, {"score": 0.004741845603430361, "phrase": "optimization_hints"}, {"score": 0.004712913906047687, "phrase": "program_developers"}, {"score": 0.004669845451682529, "phrase": "severe_obstacles"}, {"score": 0.00458488025289647, "phrase": "meaningful_guidance"}, {"score": 0.004515252649226697, "phrase": "real-life_applications"}, {"score": 0.004473982381245469, "phrase": "main_reason"}, {"score": 0.004406031457123015, "phrase": "high_code_complexity"}, {"score": 0.004339108074589304, "phrase": "commercially_valuable_code"}, {"score": 0.004221186370364584, "phrase": "heavily_nested_conditional_statements"}, {"score": 0.004195418010131832, "phrase": "nested_while-based_loops"}, {"score": 0.004068907083697369, "phrase": "existing_compiler_analysis"}, {"score": 0.0040193730627071135, "phrase": "full_parallelization_potential"}, {"score": 0.003958299299658418, "phrase": "new_paradigm"}, {"score": 0.0036777702949712457, "phrase": "existing_tools"}, {"score": 0.0036553070575015344, "phrase": "source-level_automatic_parallelization"}, {"score": 0.003555902292752528, "phrase": "possible_parallelization_patterns"}, {"score": 0.0035233696341819437, "phrase": "skeleton_code"}, {"score": 0.00346980631146264, "phrase": "parallelized_version"}, {"score": 0.003334309053314909, "phrase": "integrated_development_environment"}, {"score": 0.0032635467579751423, "phrase": "proposed_skeletonization_algorithm"}, {"score": 0.0032237852885388563, "phrase": "integer_indexes"}, {"score": 0.0032040860021574193, "phrase": "c-struct_references"}, {"score": 0.003165046673308291, "phrase": "multi-dimensional_arrays"}, {"score": 0.0027572166867780275, "phrase": "avalss"}, {"score": 0.0027069560455629917, "phrase": "original_list"}, {"score": 0.002665770884424872, "phrase": "main_goal"}, {"score": 0.0026091594819333654, "phrase": "pointer-based_data_structures"}, {"score": 0.0025615908073796027, "phrase": "skeletonized_code"}, {"score": 0.0025071862539276283, "phrase": "original_code"}, {"score": 0.002469032978674379, "phrase": "possible_parallelization_pattern"}, {"score": 0.002446419585138653, "phrase": "selected_code_segment"}, {"score": 0.0023944552329463035, "phrase": "effective_parallelization_hint"}, {"score": 0.002315012841166354, "phrase": "spec_cpu_benchmarks"}, {"score": 0.002197379785587054, "phrase": "performance_gain"}, {"score": 0.0021049977753042253, "phrase": "generated_skeleton_code"}], "paper_keywords": ["Program skeletons", " parallelization", " parallel programming"], "paper_abstract": "Tools that provide optimization hints for program developers are facing severe obstacles and often unable to provide meaningful guidance on how to parallelize real-life applications. The main reason is due to the high code complexity and its large size when considering commercially valuable code. Such code is often rich with pointers, heavily nested conditional statements, nested while-based loops, function calls, etc. These constructs prevent existing compiler analysis from extracting the full parallelization potential. We propose a new paradigm to overcome this issue by automatically transforming the code' into a much simpler skeleton-like form that is more conductive for auto-parallelization. We then apply existing tools of source-level automatic parallelization on the skeletonized code in order to expose possible parallelization patterns. The skeleton code, along with the parallelized version, are then provided to the programmer in the form of an Integrated Development Environment (IDE) recommendation. The proposed skeletonization algorithm replaces pointers by integer indexes and C-struct references by references to multi-dimensional arrays. For example, the loop while(p not equal NULL){p -> val + +; p = p -> next;} will be skeletonized to: for (Ip = 0; Ip < N; Ip + +){Aval[Ip] + +;} where AvalSS holds the embedding of the original list. Consequently, the main goal of the skeletonization process is to embed pointer-based data structures into arrays. Though the skeletonized code is not semantically equivalent to the original code, it suggests a possible parallelization pattern for the selected code segment and can be used as an effective parallelization hint to the programmer. We applied the method on the SPEC CPU benchmarks and the skeletonization process detected 27 percent additional loops that can be parallelized/vectorized on top of the compiler auto-parallelizer/vectorizer. A performance gain of up to 45 percent was measured for benchmarks that were manually parallelized based on the generated skeleton code.", "paper_title": "Parallelization Hints via Code Skeletonization", "paper_id": "WOS:000362792200016"}