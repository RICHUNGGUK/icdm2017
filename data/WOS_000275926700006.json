{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "runtime_system"}, {"score": 0.0047784273577245505, "phrase": "deterministic_multithreaded_execution"}, {"score": 0.004670504053818028, "phrase": "multithreaded_program"}, {"score": 0.004198082549566806, "phrase": "multithreaded_programs"}, {"score": 0.003995226376780718, "phrase": "automatic_replication"}, {"score": 0.0036183419672924095, "phrase": "trivial_non-performant_approach"}, {"score": 0.003391290302481397, "phrase": "runtime_infrastructure"}, {"score": 0.0032396224508754387, "phrase": "interthread_communication"}, {"score": 0.003013191092393344, "phrase": "static_compiler_optimizations"}, {"score": 0.002956272941199248, "phrase": "ownership-based_approach"}, {"score": 0.0028893844749296863, "phrase": "evolving_table"}, {"score": 0.0028347983387988847, "phrase": "memory_regions"}, {"score": 0.002760101069870307, "phrase": "buffering_approach"}, {"score": 0.002739121808942775, "phrase": "versioned_memory"}, {"score": 0.0026976391682197133, "phrase": "deterministic_commit_protocol"}, {"score": 0.0025867643733794724, "phrase": "larger_single-threaded_overhead"}, {"score": 0.0024335561337016174, "phrase": "hybrid_system"}, {"score": 0.0022894012453842064, "phrase": "llvm_compiler_infrastructure"}, {"score": 0.0022375675189464715, "phrase": "special_hardware"}, {"score": 0.0021953641459770403, "phrase": "parsec"}, {"score": 0.0021049977753042253, "phrase": "nondeterministic_execution"}], "paper_keywords": ["Reliabity", " Design", " Performance"], "paper_abstract": "The behavior of a multithreaded program does not depend only on its inputs. Scheduling, memory reordering, timing, and low-level hardware effects all introduce nondeterminism in the execution of multithreaded programs. This severely complicates many tasks, including debugging, testing, and automatic replication. In this work, we avoid these complications by eliminating their root cause: we develop a compiler and runtime system that runs arbitrary multithreaded C/C++ POSIX Threads programs deterministically. A trivial non-performant approach to providing determinism is simply deterministically serializing execution. Instead, we present a compiler and runtime infrastructure that ensures determinism but resorts to serialization rarely, for handling interthread communication and synchronization. We develop two basic approaches, both of which are largely dynamic with performance improved by some static compiler optimizations. First, an ownership-based approach detects interthread communication via an evolving table that tracks ownership of memory regions by threads. Second, a buffering approach uses versioned memory and employs a deterministic commit protocol to make changes visible to other threads. While buffering has larger single-threaded overhead than ownership, it tends to scale better (serializing less often). A hybrid system sometimes performs and scales better than either approach individually. Our implementation is based on the LLVM compiler infrastructure. It needs neither programmer annotations nor special hardware. Our empirical evaluation uses the PARSEC and SPLASH2 benchmarks and shows that our approach scales comparably to nondeterministic execution.", "paper_title": "CoreDet: A Compiler and Runtime System for Deterministic Multithreaded Execution", "paper_id": "WOS:000275926700006"}