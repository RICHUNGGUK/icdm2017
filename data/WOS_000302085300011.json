{"auto_keywords": [{"score": 0.04564717793584703, "phrase": "arithmetic_coding"}, {"score": 0.014894909179667787, "phrase": "simple_context_model"}, {"score": 0.011335242461085776, "phrase": "spiht"}, {"score": 0.011267285256765108, "phrase": "lists_algorithm"}, {"score": 0.00481495049065317, "phrase": "vlsi_architecture_of"}, {"score": 0.004800401739132256, "phrase": "arithmetic_coder"}, {"score": 0.0047283116134926645, "phrase": "high-throughput_memory-efficient_arithmetic_coder_architecture"}, {"score": 0.004397000006837371, "phrase": "different_levels"}, {"score": 0.004344073762982718, "phrase": "higher_algorithm_abstraction"}, {"score": 0.004317848984770719, "phrase": "lower_circuits'_implementations"}, {"score": 0.004252974635533396, "phrase": "complex_context_model"}, {"score": 0.004064117897000019, "phrase": "brother_nodes'_states"}, {"score": 0.0040273609512482, "phrase": "coding_zerotree"}, {"score": 0.003966833706820594, "phrase": "context_symbols"}, {"score": 0.0038953958723049287, "phrase": "simple_context_model_results"}, {"score": 0.003860158978186175, "phrase": "regular_access_pattern"}, {"score": 0.003711098637056057, "phrase": "hardware_implementation"}, {"score": 0.0036332251283046997, "phrase": "slight_performance_loss"}, {"score": 0.0034717929086014636, "phrase": "breadth_first_search"}, {"score": 0.0033175095965171674, "phrase": "coding_bit-planes"}, {"score": 0.003287482882222731, "phrase": "zero_tree"}, {"score": 0.0031129269142224194, "phrase": "context_symbol"}, {"score": 0.0030847461428168614, "phrase": "idle_arithmetic_coding_core"}, {"score": 0.003056819704624705, "phrase": "different_order"}, {"score": 0.0029565620771207003, "phrase": "input_rate"}, {"score": 0.002929792688461903, "phrase": "wavelet_coefficients"}, {"score": 0.0029120808249746533, "phrase": "eight_arithmetic_coders"}, {"score": 0.0028682668647074397, "phrase": "compression_system"}, {"score": 0.0027741761880779535, "phrase": "different_contexts"}, {"score": 0.0026347821012634586, "phrase": "common_bit_detection"}, {"score": 0.0025560719383290356, "phrase": "renormalization_stage"}, {"score": 0.002509976179108431, "phrase": "carry_look-ahead_adder"}, {"score": 0.002494796866102175, "phrase": "cla"}, {"score": 0.0024721971183379867, "phrase": "fast_multiplier-divider"}, {"score": 0.0024202575033591867, "phrase": "critical_path"}, {"score": 0.0023622296334998324, "phrase": "adaptive_clock_switch_mechanism"}, {"score": 0.002333738303480471, "phrase": "invalid_bit-planes'_clock"}, {"score": 0.002270880088524628, "phrase": "input_images"}, {"score": 0.0022571426190350157, "phrase": "experimental_results"}, {"score": 0.002229915931723092, "phrase": "proposed_architecture"}, {"score": 0.0021371774747471033, "phrase": "power_consumption"}, {"score": 0.002124247104243502, "phrase": "full_bit-planes_coding_scheme"}, {"score": 0.0021049977753042253, "phrase": "field-programmable_gate_arrays"}], "paper_keywords": ["Arithmetic coding", " common bit detection (CBD) circuit", " context model", " out-of-order execution", " set partitioning in hierarchical trees (SPIHT)", " VLSI arithmetic coder architecture"], "paper_abstract": "A high-throughput memory-efficient arithmetic coder architecture for the set partitioning in hierarchical trees (SPIHT) image compression is proposed based on a simple context model in this paper. The architecture benefits from various optimizations performed at different levels of arithmetic coding from higher algorithm abstraction to lower circuits' implementations. First, the complex context model used by software is mitigated by designing a simple context model, which just uses the brother nodes' states in the coding zerotree of SPIHT to form context symbols for the arithmetic coding. The simple context model results in a regular access pattern during reading the wavelet transform coefficients, which is convenient to the hardware implementation, but at a cost of slight performance loss. Second, in order to avoid rescanning the wavelet transform coefficients, a breadth first search SPIHT without lists algorithm is used instead of SPIHT with lists algorithm. Especially, the coding bit-planes of each zero tree are processed in parallel. Third, an out-of-order execution mechanism for different types of context is proposed that can allocate the context symbol to the idle arithmetic coding core with a different order that of the input. For the balance of the input rate of the wavelet coefficients, eight arithmetic coders are replicated in the compression system. And in one arithmetic coder, there exists four cores to process different contexts. Fourth, several dedicated circuits are designed to further improve the throughput of the architecture. The common bit detection (CBD) circuit is used for unrolling the renormalization stage of the arithmetic coding. The carry look-ahead adder (CLA) and fast multiplier-divider are also employed to shorten the critical path in the architecture. Moreover, an adaptive clock switch mechanism can stop some invalid bit-planes' clock for the power saving purpose according to the input images. Experimental results demonstrate that the proposed architecture attains a throughput of 902.464 Mb/s at its maximum and achieves savings of 20.08% in power consumption over full bit-planes coding scheme based on field-programmable gate arrays (FPGAs).", "paper_title": "VLSI Architecture of Arithmetic Coder Used in SPIHT", "paper_id": "WOS:000302085300011"}