{"auto_keywords": [{"score": 0.049631680892871025, "phrase": "ndp"}, {"score": 0.030563630386976088, "phrase": "lazy_binary_splitting"}, {"score": 0.00481495049065317, "phrase": "nested_data-parallelism"}, {"score": 0.004681226806682058, "phrase": "declarative_style"}, {"score": 0.00461575768501871, "phrase": "irregular_parallel_applications"}, {"score": 0.0045726187330434025, "phrase": "ndp_languages"}, {"score": 0.004529881123652277, "phrase": "language_features"}, {"score": 0.004466519142879166, "phrase": "ndp_style"}, {"score": 0.004362870617347183, "phrase": "ndp_programs"}, {"score": 0.004143196873246147, "phrase": "sum-like_reductions"}, {"score": 0.003897742942358768, "phrase": "parallel_ml"}, {"score": 0.00375395061615019, "phrase": "manticore_project"}, {"score": 0.003684048704119722, "phrase": "parallel_decomposition"}, {"score": 0.0035648266669315943, "phrase": "main_challenges"}, {"score": 0.00351491577968631, "phrase": "ndp."}, {"score": 0.0028312983170567948, "phrase": "dynamic_parallel_decomposition"}, {"score": 0.002778529097886437, "phrase": "flat_arrays"}, {"score": 0.0027395968397212053, "phrase": "promising_results"}, {"score": 0.002626034130205569, "phrase": "binary_trees"}, {"score": 0.0025409639091476363, "phrase": "parallel_arrays"}, {"score": 0.0025171688527954993, "phrase": "pml."}, {"score": 0.0023566987138026285, "phrase": "per-program_tuning"}, {"score": 0.002291089893848235, "phrase": "good_performance"}, {"score": 0.0022696277881969896, "phrase": "varying_platforms"}, {"score": 0.0022273034991008326, "phrase": "lts-based_implementations"}, {"score": 0.0022064376000055764, "phrase": "standard_ndp_operations"}, {"score": 0.0021551222226685648, "phrase": "experimental_data"}, {"score": 0.0021050100014336167, "phrase": "lts"}], "paper_keywords": ["Languages", " Performance", " nested-data-parallel languages", " scheduling", " compilers", " run-time systems"], "paper_abstract": "Nested data-parallelism (NDP) is a declarative style for programming irregular parallel applications. NDP languages provide language features favoring the NDP style, efficient compilation of NDP programs, and various common NDP operations like parallel maps, filters, and sum-like reductions. In this paper, we describe the implementation of NDP in Parallel ML (PML), part of the Manticore project. Managing the parallel decomposition of work is one of the main challenges of implementing NDP. If the decomposition creates too many small chunks of work, performance will be eroded by too much parallel overhead. If, on the other hand, there are too few large chunks of work, there will be too much sequential processing and processors will sit idle. Recently the technique of Lazy Binary Splitting was proposed for dynamic parallel decomposition of work on flat arrays, with promising results. We adapt Lazy Binary Splitting to parallel processing of binary trees, which we use to represent parallel arrays in PML. We call our technique Lazy Tree Splitting (LTS). One of its main advantages is its performance robustness: per-program tuning is not required to achieve good performance across varying platforms. We describe LTS-based implementations of standard NDP operations, and we present experimental data demonstrating the scalability of LTS across a range of benchmarks.", "paper_title": "Lazy Tree Splitting", "paper_id": "WOS:000286594300010"}