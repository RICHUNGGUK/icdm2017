{"auto_keywords": [{"score": 0.04385441933770478, "phrase": "flash_memory"}, {"score": 0.004815340879031441, "phrase": "adaptive"}, {"score": 0.004565007074039171, "phrase": "multichannel_solid-state_disks"}, {"score": 0.00451659023910662, "phrase": "multilevel_flash_memory_cells"}, {"score": 0.00439777299939725, "phrase": "storage_density"}, {"score": 0.004327981760540394, "phrase": "affordable_solid-state_disks"}, {"score": 0.003995226376780718, "phrase": "wear-leveling_methods"}, {"score": 0.0037474693720823643, "phrase": "modern_solid-state_disks"}, {"score": 0.003687960013746783, "phrase": "wear_evenness_at_both_block_and_channel_levels"}, {"score": 0.0035527409334589317, "phrase": "block-level_wear-leveling_method"}, {"score": 0.00335016692413066, "phrase": "proposed_method"}, {"score": 0.003244567402785763, "phrase": "flash-translation_layers"}, {"score": 0.0031255543155487234, "phrase": "new_data_structures"}, {"score": 0.0029630461161780203, "phrase": "block-level_wear_leveling"}, {"score": 0.002900426826591769, "phrase": "runtime_write_pattern"}, {"score": 0.002794001681064862, "phrase": "new_channel-level_wear-leveling_strategy"}, {"score": 0.002578880352208335, "phrase": "realistic_workloads"}, {"score": 0.002418742283474052, "phrase": "logical_blocks"}, {"score": 0.0023424328921363585, "phrase": "eventually-even_state"}, {"score": 0.0022444104439449737, "phrase": "trace-driven_simulations"}, {"score": 0.0021276181317652163, "phrase": "wear_evenness"}, {"score": 0.0021049977753042253, "phrase": "overhead_reduction"}], "paper_keywords": ["Design", " Performance", " Algorithm", " Flash memory", " wear leveling", " solid-state disks"], "paper_abstract": "Multilevel flash memory cells double or even triple storage density, producing affordable solid-state disks for end users. As flash memory endures only limited program-erase cycles, solid-state disks employ wear-leveling methods to prevent any portions of flash memory from being retired prematurely. Modern solid-state disks must consider wear evenness at both block and channel levels. This study first presents a block-level wear-leveling method whose design has two new ideas. First, the proposed method reuses the intelligence available in flash-translation layers so it does not require any new data structures. Second, it adaptively tunes the threshold of block-level wear leveling according to the runtime write pattern. This study further introduces a new channel-level wear-leveling strategy, because block-level wear leveling is confined to a channel, but realistic workloads do not evenly write all channels. The proposed method swaps logical blocks among channels for achieving an eventually-even state of channel lifetimes. A series of trace-driven simulations show that our wear-leveling method outperforms existing approaches in terms of wear evenness and overhead reduction.", "paper_title": "An Adaptive, Low-Cost Wear-Leveling Algorithm for Multichannel Solid-State Disks", "paper_id": "WOS:000329136000015"}