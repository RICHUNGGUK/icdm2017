{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "microarchitectural_details"}, {"score": 0.04825391523084192, "phrase": "many-core_architectures"}, {"score": 0.02544639538414303, "phrase": "measured_data"}, {"score": 0.004478105342825352, "phrase": "latency_and_bandwidth_gap"}, {"score": 0.004208120996604837, "phrase": "high-speed_network"}, {"score": 0.004089856113955833, "phrase": "hardware_and_software_prefetching"}, {"score": 0.003995560429492594, "phrase": "memory_latency"}, {"score": 0.003944112858235306, "phrase": "many-core_systems"}, {"score": 0.0038531644281313056, "phrase": "performance_tuning_techniques"}, {"score": 0.0037545589276659504, "phrase": "target_memory_system"}, {"score": 0.0036301208383081513, "phrase": "newly_released_processors"}, {"score": 0.0035463870612369645, "phrase": "novel_microbenchmarking_methodology"}, {"score": 0.0035189057079817285, "phrase": "short_elapsed-time_events"}, {"score": 0.003464578003997119, "phrase": "comprehensive_memory_microarchitectural_details"}, {"score": 0.0033497184946413754, "phrase": "detailed_analysis"}, {"score": 0.0033323878473928317, "phrase": "potential_interfering_factors"}, {"score": 0.003289451206583327, "phrase": "intended_behavior"}, {"score": 0.0032302647179383915, "phrase": "effective_guidelines"}, {"score": 0.0031803790636361273, "phrase": "interfering_factors"}, {"score": 0.003131326600349745, "phrase": "smt"}, {"score": 0.002965229277927781, "phrase": "software_and_hardware_prefetching_units"}, {"score": 0.0029346139193189716, "phrase": "previous_studies"}, {"score": 0.002904313736969863, "phrase": "newly_released_intel_xeon_phi_many-core_processor"}, {"score": 0.0025575061994743127, "phrase": "well-documented_intel_sandy_bridge_multicore_processor"}, {"score": 0.002537668280298673, "phrase": "out-of-order_cores"}, {"score": 0.002359759876402679, "phrase": "multistage_coordinated_data_prefetching_case_study"}, {"score": 0.0023414522240150287, "phrase": "xeon_phi"}, {"score": 0.0023293259149436323, "phrase": "sandy_bridge"}, {"score": 0.0022057215755768556, "phrase": "state-of-the-art_intel_icc_compiler"}, {"score": 0.002154772490492128, "phrase": "useful_insights"}, {"score": 0.0021436109126950487, "phrase": "memory_optimization"}], "paper_keywords": ["Measurement", " Performance", " Microbenchmarking", " memory microarchitecture", " prefetching", " many-core", " multicore"], "paper_abstract": "As multicore and many-core architectures evolve, their memory systems are becoming increasingly more complex. To bridge the latency and bandwidth gap between the processor and memory, they often use a mix of multilevel private/shared caches that are either blocking or nonblocking and are connected by high-speed network-on-chip. Moreover, they also incorporate hardware and software prefetching and simultaneous multithreading (SMT) to hide memory latency. On such multi- and many-core systems, to incorporate various memory optimization schemes using compiler optimizations and performance tuning techniques, it is crucial to have microarchitectural details of the target memory system. Unfortunately, such details are often unavailable from vendors, especially for newly released processors. In this article, we propose a novel microbenchmarking methodology based on short elapsed-time events (SETEs) to obtain comprehensive memory microarchitectural details in multi-and many-core processors. This approach requires detailed analysis of potential interfering factors that could affect the intended behavior of such memory systems. We lay out effective guidelines to control and mitigate those interfering factors. Taking the impact of SMT into consideration, our proposed methodology not only can measure traditional cache/memory latency and off-chip bandwidth but also can uncover the details of software and hardware prefetching units not attempted in previous studies. Using the newly released Intel Xeon Phi many-core processor (with in-order cores) as an example, we show how we can use a set of microbenchmarks to determine various microarchitectural features of its memory system (many are undocumented from vendors). To demonstrate the portability and validate the correctness of such a methodology, we use the well-documented Intel Sandy Bridge multicore processor (with out-of-order cores) as another example, where most data are available and can be validated. Moreover, to illustrate the usefulness of the measured data, we do a multistage coordinated data prefetching case study on both Xeon Phi and Sandy Bridge and show that by using the measured data, we can achieve 1.3X and 1.08X performance speedup, respectively, compared to the state-of-the-art Intel ICC compiler. We believe that these measurements also provide useful insights into memory optimization, analysis, and modeling of such multicore and many-core architectures.", "paper_title": "Measuring Microarchitectural Details of Multi- and Many-Core Memory Systems through Microbenchmarking", "paper_id": "WOS:000348232000021"}