{"auto_keywords": [{"score": 0.0369185808568817, "phrase": "vord"}, {"score": 0.014354522408900176, "phrase": "data_races"}, {"score": 0.009724522649698546, "phrase": "ecps"}, {"score": 0.00481495049065317, "phrase": "openmp_programs"}, {"score": 0.004774937143916685, "phrase": "shared-memory_based_parallel_programming"}, {"score": 0.004735254735115024, "phrase": "openmp_and_posix-thread_apis"}, {"score": 0.0045607070754363245, "phrase": "multiprocessor_computing_environments"}, {"score": 0.004466519142879166, "phrase": "critical_risks"}, {"score": 0.004429388453288922, "phrase": "multithreaded_programming"}, {"score": 0.00421297029755273, "phrase": "parallel_applications"}, {"score": 0.0040916230716372265, "phrase": "ample_effort"}, {"score": 0.003990385737207714, "phrase": "specialized_data_race_detection_techniques"}, {"score": 0.00390792986752692, "phrase": "art_tools"}, {"score": 0.0034332736827447654, "phrase": "empirically_optimal_set"}, {"score": 0.003404703106153948, "phrase": "race_engines"}, {"score": 0.0033622909109253616, "phrase": "classification_and_adaptation_mechanisms"}, {"score": 0.0031579997262619758, "phrase": "adequate_engines"}, {"score": 0.0029909851863915283, "phrase": "engine_code_property_selector"}, {"score": 0.0029169007179202164, "phrase": "rdc_table"}, {"score": 0.0028805474861014722, "phrase": "optimal_engines"}, {"score": 0.0027858007467896338, "phrase": "rdc"}, {"score": 0.002682917193736698, "phrase": "openmp_parser"}, {"score": 0.0026494723416072316, "phrase": "source_instrumentor"}, {"score": 0.002447101794397243, "phrase": "openmp_based_kernel_programs"}, {"score": 0.00241658945942583, "phrase": "experimental_results"}, {"score": 0.0023079225317714793, "phrase": "nested_thread"}, {"score": 0.0021049977753042253, "phrase": "large_parallel_programs"}], "paper_keywords": ["Parallel programs", " OpenMP", " On-the-fly race detection", " Intel thread checker", " RDC", " ECPS"], "paper_abstract": "Shared-memory based parallel programming with OpenMP and Posix-thread APIs becomes more common to fully take advantage of multiprocessor computing environments. One of the critical risks in multithreaded programming is data races that are hard to debug and greatly damaging to parallel applications if they are uncaught. Although ample effort has been made in building specialized data race detection techniques, the state of art tools such as the Intel Thread Checker still have various functionality and performance problems. In this paper, we present a Versatile On-the-fly Race Detection (VORD) tool that provides an agile, efficient, and scalable race detection environment for various parallel programming models. VORD can automatically construct an empirically optimal set of race engines by utilizing classification and adaptation mechanisms. A Race-Detection Classification (RDC) table is created to categorize adequate engines in the aspect of labeling, detecting, and filtering. An Engine Code Property Selector (ECPS) uses the RDC table to adapt optimal engines for the given target programming models. In addition to RDC and ECPS, we have also implemented an OpenMP parser and a source instrumentor. The functionality and efficiency of VORD were compared with those of the Intel Thread Checker by using a set of OpenMP based kernel programs. The experimental results show that VORD can detect data races in more challenging programming models such as nested thread and synchronization models, and can achieve a couple of orders of a magnitude faster processing time than the Intel Thread Checker in the large parallel programs.", "paper_title": "VORD: A Versatile On-the-fly Race Detection Tool in OpenMP Programs", "paper_id": "WOS:000341498400002"}