{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "data_structures"}, {"score": 0.004767546015485477, "phrase": "graphical_processing_units"}, {"score": 0.004697308822154191, "phrase": "finite_element_method"}, {"score": 0.004404658750724105, "phrase": "partial_differential_equations"}, {"score": 0.004361276005140776, "phrase": "unstructured_meshes"}, {"score": 0.00419195822011581, "phrase": "solution_phases"}, {"score": 0.004089475312474684, "phrase": "special_attention"}, {"score": 0.00395017798595193, "phrase": "data_movement"}, {"score": 0.003853583126988071, "phrase": "gpu_assembly_algorithm"}, {"score": 0.003778004256546193, "phrase": "arbitrary_degree_polynomials"}, {"score": 0.0037222908218253054, "phrase": "basis_functions"}, {"score": 0.0036133077234252633, "phrase": "redundant_computations"}, {"score": 0.003455765987713262, "phrase": "stiffness_matrix"}, {"score": 0.0031609252620168446, "phrase": "csr_and_ellpack_matrix_formats"}, {"score": 0.0031297538950335233, "phrase": "matrix-free_algorithms"}, {"score": 0.0029784342137867776, "phrase": "indexing_data"}, {"score": 0.0029490571526071016, "phrase": "stiffness_data"}, {"score": 0.0028484940955893134, "phrase": "different_approaches"}, {"score": 0.0027787638791664663, "phrase": "implicit_caches"}, {"score": 0.0027513507830537165, "phrase": "fermi_gpus"}, {"score": 0.002467038647952607, "phrase": "solution_phase"}, {"score": 0.0023476849595393872, "phrase": "conjugate_gradient_iteration"}, {"score": 0.0022901862321082407, "phrase": "matrix-free_approach"}, {"score": 0.0021902063413831545, "phrase": "global_assembly_approaches"}, {"score": 0.0021049977753042253, "phrase": "nvidia's_cusparse_library"}], "paper_keywords": ["Graphical processing unit", " Finite element method", " Performance analysis", " Sparse matrix-vector multiplication", " Preconditioned conjugate gradient method"], "paper_abstract": "The finite element method (FEM) is one of the most commonly used techniques for the solution of partial differential equations on unstructured meshes. This paper discusses both the assembly and the solution phases of the FEM with special attention to the balance of computation and data movement. We present a GPU assembly algorithm that scales to arbitrary degree polynomials used as basis functions, at the expense of redundant computations. We show how the storage of the stiffness matrix affects the performance of both the assembly and the solution. We investigate two approaches: global assembly into the CSR and ELLPACK matrix formats and matrix-free algorithms, and show the trade-off between the amount of indexing data and stiffness data. We discuss the performance of different approaches in light of the implicit caches on Fermi GPUs and show a speedup over a two-socket 12-core CPU of up to 10 times in the assembly and up to 6 times in the solution phase. We present our sparse matrix-vector multiplication algorithms that are part of a conjugate gradient iteration and show that a matrix-free approach may be up to two times faster than global assembly approaches and up to 4 times faster than NVIDIA's cuSPARSE library, depending on the preconditioner used.", "paper_title": "Finite Element Algorithms and Data Structures on Graphical Processing Units", "paper_id": "WOS:000349887300003"}