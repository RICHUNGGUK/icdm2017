{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "electronic_level"}, {"score": 0.004725886853744007, "phrase": "service_providers"}, {"score": 0.0040890178236849825, "phrase": "final_leg"}, {"score": 0.0038301525703886585, "phrase": "service-oriented_architectures"}, {"score": 0.0033919477901198716, "phrase": "business_idea"}, {"score": 0.00329813918116714, "phrase": "one's_business_partners"}, {"score": 0.0032370412139943808, "phrase": "technical_level"}, {"score": 0.003003726508522467, "phrase": "final_application"}, {"score": 0.002948066398723126, "phrase": "middleware_technology"}, {"score": 0.002550165781755603, "phrase": "component_lookup"}, {"score": 0.0024912073108138613, "phrase": "generic_model"}, {"score": 0.0023662411481713704, "phrase": "tagged_sets"}, {"score": 0.002344201345813952, "phrase": "classic_white_pages"}, {"score": 0.002311525062244175, "phrase": "even_method_dispatch"}, {"score": 0.002195552442011313, "phrase": "existing_lookup_schemes"}, {"score": 0.0021049977753042253, "phrase": "common_distinction"}], "paper_keywords": [""], "paper_abstract": "The possibilities currently offered to conduct business at an electronic level are immense. Service providers offer access to their attendances through components placed on the Internet; such components can be combined to build applications, which can themselves be used as components by further business units. The final leg of the way to this paradigm has been paved by the advent of service-oriented architectures in general, and Web Services in particular. With protocols existing for any parties to communicate, the most critical ingredient to the success of a business idea remains the task of choosing one's business partners. At a technical level, this translates to the issue of identifying which components represent the most adequate services to build a final application.. While each middleware technology and system proposed in the past has been described with its scheme for \"looking up\" components, this paper chooses the more difficult approach of trying to distill the fundamentals of component lookup. We propose a generic model of component lookup-applicable to settings as diverse as tagged sets, classic white pages, or even method dispatch-and its implementation. We illustrate our model through various examples of existing lookup schemes. It turns out that in our generic context the common distinction between name-based and type-based lookup becomes rather artificial.", "paper_title": "Generic component lookup", "paper_id": "WOS:000239520500013"}