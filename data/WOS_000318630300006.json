{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "loop-aware_optimizations"}, {"score": 0.004746263721902201, "phrase": "pypy's_tracing_jit."}, {"score": 0.0046118021635786315, "phrase": "nice_properties"}, {"score": 0.004481132747216135, "phrase": "just-in-time_compiler"}, {"score": 0.003798231095121328, "phrase": "loop-invariant_code_motion"}, {"score": 0.0035858673522839407, "phrase": "tight_kernels"}, {"score": 0.0034841647157189985, "phrase": "dynamic_languages"}, {"score": 0.003385336776758738, "phrase": "quite_a_lot"}, {"score": 0.00333697550984782, "phrase": "loop_invariant_type_checking"}, {"score": 0.0032893028281789287, "phrase": "boxed_value_unwrapping_and_virtual_method_lookups"}, {"score": 0.002952745241052452, "phrase": "luajit_project"}, {"score": 0.002727967804120323, "phrase": "simple_pre-processing_step"}, {"score": 0.0024311346712789553, "phrase": "rpython's_tracing_jit_compiler"}, {"score": 0.002396371892825691, "phrase": "pypy's_python_jit"}, {"score": 0.002362105010110277, "phrase": "simple_numerical_kernels"}, {"score": 0.0021049977753042253, "phrase": "static_language_compilers"}], "paper_keywords": ["Languages", " Performance", " Experimentation", " Tracing JIT", " Optimization", " Loop-Invariant Code Motion"], "paper_abstract": "One of the nice properties of a tracing just-in-time compiler (JIT) is that many of its optimizations are simple, requiring one forward pass only. This is not true for loop-invariant code motion which is a very important optimization for code with tight kernels. Especially for dynamic languages that typically perform quite a lot of loop invariant type checking, boxed value unwrapping and virtual method lookups. In this paper we explain a scheme pioneered within the context of the LuaJIT project for making basic optimizations loop-aware by using a simple pre-processing step on the trace without changing the optimizations themselves. We have implemented the scheme in RPython's tracing JIT compiler. PyPy's Python JIT executing simple numerical kernels can become up to two times faster, bringing the performance into the ballpark of static language compilers.", "paper_title": "Loop-Aware Optimizations in PyPy's Tracing JIT", "paper_id": "WOS:000318630300006"}