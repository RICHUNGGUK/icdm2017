{"auto_keywords": [{"score": 0.04880833597060665, "phrase": "zhang"}, {"score": 0.0048317902820788836, "phrase": "malik"}, {"score": 0.00481495049065317, "phrase": "unsatisfiability_proof"}, {"score": 0.004778088905211055, "phrase": "core_generation"}, {"score": 0.0047415081747150065, "phrase": "sat_solvers"}, {"score": 0.004390689303780405, "phrase": "modern_dpll-based_sat_solvers"}, {"score": 0.004034572092608487, "phrase": "resolution_proof"}, {"score": 0.0036646935906338414, "phrase": "input_clauses"}, {"score": 0.0035399770257915466, "phrase": "new_algorithmic_approach"}, {"score": 0.0033802431627410223, "phrase": "depth-first_traversal"}, {"score": 0.003290403747743492, "phrase": "memory_usage"}, {"score": 0.0031906408161077792, "phrase": "sat_solver"}, {"score": 0.0031058249097051555, "phrase": "second_part"}, {"score": 0.003034916887102753, "phrase": "in-memory_algorithms"}, {"score": 0.003000070450638434, "phrase": "sat_proofs"}, {"score": 0.0027564303939865476, "phrase": "current_sat"}, {"score": 0.0026421139329830755, "phrase": "long_sat_runs"}, {"score": 0.0025619562094446884, "phrase": "-memory_algorithms"}, {"score": 0.002522791642460087, "phrase": "carefully_designed_experiments"}, {"score": 0.00236289633510808, "phrase": "trace-based_one"}, {"score": 0.002308910575113746, "phrase": "new_in-memory_algorithm"}, {"score": 0.0022302306304023602, "phrase": "unnecessary_information"}, {"score": 0.0021625417261202603, "phrase": "significantly_more_instances"}, {"score": 0.0021376902861998865, "phrase": "previously_existing_algorithms"}, {"score": 0.0021049977753042253, "phrase": "negligible_expense"}], "paper_keywords": ["SAT", " SAT proofs", " unsatisfiable cores", " DPLL", " SAT solvers"], "paper_abstract": "Since Zhang and Malik's work in 2003 [19], it is well-known that modern DPLL-based SAT solvers with learning can be instrumented to write a trace on disk from which, if the input is unsatisfiable, a resolution proof can be extracted (and checked), and hence also an unsatisfiable core: a (frequently small) unsatisfiable subset of the input clauses. In this article we first give a new algorithmic approach for processing these (frequently huge) traces. It achieves the efficiency of a depth-first traversal, while preserving the property that memory usage remains upper bounded by that of the SAT solver that generated the trace. The second part of this article is about in-memory algorithms for generating SAT proofs and cores, without writing traces to disk. We discuss advantages and disadvantages of this approach and investigate why the current SAT solvers with this feature still run out of memory on long SAT runs. We analyze several of these in-memory algorithms, based on carefully designed experiments with our implementation of each one of them, as well as with (our implementation of) a trace-based one. Then we describe a new in-memory algorithm which saves space by doing more bookkeeping to discard unnecessary information, and show that it can handle significantly more instances than the previously existing algorithms, at a negligible expense in time.", "paper_title": "Practical algorithms for unsatisfiability proof and core generation in SAT solvers", "paper_id": "WOS:000275821600006"}