{"auto_keywords": [{"score": 0.04964156968469261, "phrase": "imperative_programming_languages"}, {"score": 0.04408580801729791, "phrase": "domain-specific_static_program_analyses"}, {"score": 0.03759528653367177, "phrase": "symbolic_domain"}, {"score": 0.00481495049065317, "phrase": "static_analysis"}, {"score": 0.004662705558154439, "phrase": "generic_symbolic_analysis_framework"}, {"score": 0.004453488286477661, "phrase": "valid_variable_bindings"}, {"score": 0.004081385289516914, "phrase": "program_parallelization"}, {"score": 0.003970439654470374, "phrase": "superfluous_bound_checks"}, {"score": 0.0039341294012600085, "phrase": "variable_aliases"}, {"score": 0.0038981499110532307, "phrase": "task_deadlocks"}, {"score": 0.0038271712887391015, "phrase": "path_expression_algebra"}, {"score": 0.0036385493850693983, "phrase": "homomorphism_maps_path"}, {"score": 0.0034118234596993836, "phrase": "compact_algebraic_structure"}, {"score": 0.0032886455096627324, "phrase": "complete_control"}, {"score": 0.0029181203386806683, "phrase": "novel_representation"}, {"score": 0.0028914057633212045, "phrase": "program_semantics"}, {"score": 0.002825681384008326, "phrase": "program_analysis"}, {"score": 0.002799810685137358, "phrase": "computer_algebra_systems"}, {"score": 0.002723607240517261, "phrase": "ideal_symbolic_intermediate_representation"}, {"score": 0.0025892330566358503, "phrase": "existing_methods"}, {"score": 0.002427732996314194, "phrase": "reducible_and_irreducible_control_flow_graphs"}, {"score": 0.0022450768409733807, "phrase": "real-world_applications"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Static program analysis", " Symbolic analysis", " Path expression algebra", " Programming language semantics"], "paper_abstract": "We present a generic symbolic analysis framework for imperative programming languages. Our framework is capable of computing all valid variable bindings of a program at given program points. This information is invaluable for domain-specific static program analyses such as memory leak detection, program parallelization, and the detection of superfluous bound checks, variable aliases and task deadlocks. We employ path expression algebra to model the control flow information of programs. A homomorphism maps path expressions into the symbolic domain. At the center of the symbolic domain is a compact algebraic structure called supercontext. A supercontext contains the complete control and data flow analysis information valid at a given program point. Our approach to compute supercontexts is based purely on algebra and is fully automated. This novel representation of program semantics closes the gap between program analysis and computer algebra systems, which makes supercontexts an ideal symbolic intermediate representation for all domain-specific static program analyses. Our approach is more general than existing methods because it can derive solutions for arbitrary (even intra-loop and nested loop) nodes of reducible and irreducible control flow graphs. We prove the correctness of our symbolic analysis method. Our experimental results show that the problem sizes arising from real-world applications such as the SPEC95 benchmark suite are tractable for our symbolic analysis framework. (C) 2011 Elsevier Inc. All rights reserved.", "paper_title": "A symbolic analysis framework for static analysis of imperative programming languages", "paper_id": "WOS:000303626300016"}