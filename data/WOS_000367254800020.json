{"auto_keywords": [{"score": 0.004814951205791257, "phrase": "cache-oblivious"}, {"score": 0.004701015188740582, "phrase": "recursive_dynamic_programming_algorithms"}, {"score": 0.004645057834614705, "phrase": "cache-efficiency"}, {"score": 0.004608121749000898, "phrase": "state-of-the-art_cache-oblivious_parallel_algorithms"}, {"score": 0.004517293788140256, "phrase": "dp"}, {"score": 0.0044277810648955624, "phrase": "asymptotically_optimal_cache_performance"}, {"score": 0.004340263267055143, "phrase": "cache_parameters"}, {"score": 0.004187049198138107, "phrase": "theoretically_best_parallelism"}, {"score": 0.003684634192576662, "phrase": "defining_recurrence_equations"}, {"score": 0.003611751858608048, "phrase": "artificial_dependency"}, {"score": 0.0033077610063168093, "phrase": "dac_strategy"}, {"score": 0.003190878119415192, "phrase": "widely_known_dynamic_programming_problems"}, {"score": 0.0031402604946939743, "phrase": "floyd-warshall's_all-pairs_shortest_paths"}, {"score": 0.0031152665535543553, "phrase": "stencil"}, {"score": 0.0030781126453776723, "phrase": "lcs._theoretical"}, {"score": 0.0029339151044984134, "phrase": "n_node_graph"}, {"score": 0.0028762498907438463, "phrase": "theta"}, {"score": 0.0028076592725295646, "phrase": "d-dimensional_hypercubic_grid"}, {"score": 0.002741091312632307, "phrase": "time_steps"}, {"score": 0.002581525174000061, "phrase": "lcs"}, {"score": 0.0023545567809591804, "phrase": "total_work"}, {"score": 0.0022803854904010347, "phrase": "experimental_measurements"}, {"score": 0.0021734768728417977, "phrase": "burdened_span"}, {"score": 0.0021561514733516676, "phrase": "cilkview"}, {"score": 0.0021049980887993046, "phrase": "papi."}], "paper_keywords": ["Algorithms", " Scheduling", " Performance", " cache-oblivious parallel algorithm", " cache-oblivious wavefront", " dynamic programming", " multi-core", " nested parallel computation", " Cilk"], "paper_abstract": "State-of-the-art cache-oblivious parallel algorithms for dynamic programming (DP) problems usually guarantee asymptotically optimal cache performance without any tuning of cache parameters, but they often fail to exploit the theoretically best parallelism at the same time. While these algorithms achieve cache-optimality through the use of a recursive divide-and-conquer (DAC) strategy, scheduling tasks at the granularity of task dependency introduces artificial dependencies in addition to those arising from the defining recurrence equations. We removed the artificial dependency by scheduling tasks ready for execution as soon as all its real dependency constraints are satisfied, while preserving the cache-optimality by inheriting the DAC strategy. We applied our approach to a set of widely known dynamic programming problems, such as Floyd-Warshall's All-Pairs Shortest Paths, Stencil, and LCS. Theoretical analyses show that our techniques improve the span of 2-way DAC-based Floyd Warshall's algorithm on an n node graph from Q nlog(2) n Theta to Q (n), stencil computations on a d-dimensional hypercubic grid of width w for h time steps from Q (d(2)h)(wlog(d + 2)-1)) to Q (h), and LCS on two sequences of length n each from Q nlog(2) 3) to Q (n). In each case, the total work and cache complexity remain asymptotically optimal. Experimental measurements exhibit a 3-5 times improvement in absolute running time, 10-20 times improvement in burdened span by Cilkview, and approximately the same L1/L2 cache misses by PAPI.", "paper_title": "Cache-Oblivious Wavefront: Improving Parallelism of Recursive Dynamic Programming Algorithms without Losing Cache-Efficiency", "paper_id": "WOS:000367254800020"}