{"auto_keywords": [{"score": 0.03491093349899493, "phrase": "constraint_graph"}, {"score": 0.009834960206917199, "phrase": "pointer_analysis"}, {"score": 0.007976048746834954, "phrase": "complex_constraints"}, {"score": 0.00481495049065317, "phrase": "pull_constraint_graph"}, {"score": 0.004778258911940497, "phrase": "efficient_points"}, {"score": 0.004616560363089716, "phrase": "efficient_computation"}, {"score": 0.004494570360108983, "phrase": "c_programs"}, {"score": 0.004409404470207072, "phrase": "important_phase"}, {"score": 0.004359078118356132, "phrase": "compilation_process"}, {"score": 0.004309323675697185, "phrase": "computed_points"}, {"score": 0.004211504818267892, "phrase": "alias_information"}, {"score": 0.004147523799581407, "phrase": "client_analyses"}, {"score": 0.00411589720697736, "phrase": "varied_domains"}, {"score": 0.004068907083697369, "phrase": "bug_finding"}, {"score": 0.004037877545494505, "phrase": "data-flow_analysis"}, {"score": 0.003991774582021095, "phrase": "security_vulnerabilities"}, {"score": 0.0038418515481939463, "phrase": "former_research"}, {"score": 0.0037402558657576124, "phrase": "main_bottleneck"}, {"score": 0.0034512514926836667, "phrase": "q_constraints"}, {"score": 0.0032710562699144814, "phrase": "unpredictable_manner"}, {"score": 0.0031723302551782324, "phrase": "large_amounts"}, {"score": 0.003018196463874475, "phrase": "root_cause"}, {"score": 0.002938317647182056, "phrase": "homogeneous_structure"}, {"score": 0.0028496055358577512, "phrase": "existing_analyses"}, {"score": 0.0027741761880779535, "phrase": "uniform_manner"}, {"score": 0.002579326836642461, "phrase": "non-homogeneous_manner"}, {"score": 0.0025110337774260773, "phrase": "different_ways"}, {"score": 0.0024633601573822114, "phrase": "push-pull_model"}, {"score": 0.002444544487772349, "phrase": "non-uniform_propagation"}, {"score": 0.0023889533502525527, "phrase": "lazy_propagation"}, {"score": 0.0022296340517805125, "phrase": "six_large_open-source_programs"}, {"score": 0.0021705796895687864, "phrase": "analysis_time"}, {"score": 0.002145750895912557, "phrase": "state-of-the-art_bdd-based_analysis"}, {"score": 0.0021049977753042253, "phrase": "deep_propagation"}], "paper_keywords": ["Algorithms", " Languages", " constraint graph", " points-to analysis", " push-pull", " lazy propagation", " propagation patterns"], "paper_abstract": "We present techniques for efficient computation of points-to information for C programs. Pointer analysis is an important phase in the compilation process. The computed points-to information and the alias information is useful for client analyses from varied domains such as bug finding, data-flow analysis, identifying security vulnerabilities, and parallelization, to name a few. Former research on pointer analysis has indicated that the main bottleneck towards scalability is manifested by the presence of complex constraints (load p = *q and store *p = q constraints) in the program. Complex constraints add edges to the constraint graph in an unpredictable manner and are responsible for initiating propagation of large amounts of points-to information across edges. We identify that the root cause to this issue is in the homogeneous structure in the constraint graph, due to which existing analyses treat loads and stores in a uniform manner. To address these issues, we present two techniques. First, we represent a constraint graph in a non-homogeneous manner, treat loads and stores in different ways, and employ a push-pull model for non-uniform propagation. Second, we propose lazy propagation which propagates information in the constraint graph only when necessary. We illustrate the effectiveness of our techniques using six large open-source programs and show that they improve the analysis time over a state-of-the-art BDD-based analysis by 33% and over Deep Propagation by 21%.", "paper_title": "Push-Pull Constraint Graph for Efficient Points-to Analysis", "paper_id": "WOS:000358310800003"}