{"auto_keywords": [{"score": 0.03644451033122438, "phrase": "spear"}, {"score": 0.014334433875949985, "phrase": "issue_queue"}, {"score": 0.013179908988824438, "phrase": "large_issue_queue"}, {"score": 0.00481495049065317, "phrase": "speculative_pre-execution"}, {"score": 0.004774324145784758, "phrase": "current_superscalar_architectures"}, {"score": 0.00467424463996457, "phrase": "instruction_issue"}, {"score": 0.00459568664065473, "phrase": "multiple_instruction_issue"}, {"score": 0.004480307124735185, "phrase": "order_execution"}, {"score": 0.004330941610682453, "phrase": "centralized_structure"}, {"score": 0.003945266418163835, "phrase": "low_clock_rate"}, {"score": 0.0038789122930433305, "phrase": "high_circuit_complexity"}, {"score": 0.00378145978325955, "phrase": "increasing_demands"}, {"score": 0.0037336520904376687, "phrase": "larger_issue_queue"}, {"score": 0.003670843919846253, "phrase": "significant_burden"}, {"score": 0.0036090884921108086, "phrase": "higher_clock_speed"}, {"score": 0.0031110402375026016, "phrase": "window_size"}, {"score": 0.0029565620771207003, "phrase": "long_memory_latency"}, {"score": 0.0028457440091791252, "phrase": "large_window"}, {"score": 0.002762423953243486, "phrase": "early_execution"}, {"score": 0.0027274643070540733, "phrase": "miss-causing_load_instructions"}, {"score": 0.0025810006125483835, "phrase": "miss-causing_instructions"}, {"score": 0.0025375331660958665, "phrase": "additional_prefetching_thread"}, {"score": 0.0024632148715152393, "phrase": "spear_design"}, {"score": 0.0023210293050850276, "phrase": "superscalar_architectures"}, {"score": 0.002215081186105616, "phrase": "smaller_issue_queues"}, {"score": 0.0021501863832966966, "phrase": "low_hardware_complexity"}, {"score": 0.0021319959284827896, "phrase": "high_clock_speed"}], "paper_keywords": ["Speculative execution", " Data-prefetching", " Superscalar", " Multithreading", " Instruction Level Parallelism"], "paper_abstract": "Current superscalar architectures strongly depend on an instruction issue queue to achieve multiple instruction issue and out-of-order execution. However, the issue queue requires a centralized structure and mainly causes globally broadcasting operations to wakeup and select the instructions. Therefore, a large issue queue ultimately results in a low clock rate along with a high circuit complexity. In other words, the increasing demands for a larger issue queue correspondingly impose a significant burden on achieving a higher clock speed. This paper discusses our Speculative Pre-Execution Assisted by compileR (SPEAR), a low-complexity issue queue design. SPEAR is designed to manage (he small window superscalar architecture more efficiently Without increasing the window size. To this end, we have first recognized that the long memory latency is one of the factors that demand a large window, and we aim at achieving early execution of the miss-causing load instructions using another hierarchy of an issue queue. We pre-execute those miss-causing instructions speculatively as an additional prefetching thread. Simulation results Show that the SPEAR design achieves performance comparable to or even better than what would be obtained in superscalar architectures with a large issue queue. However, SPEAR is designed with smaller issue queues which consequently call be implemented with low hardware complexity and high clock speed. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "A low-complexity microprocessor design with speculative pre-execution", "paper_id": "WOS:000261307000003"}