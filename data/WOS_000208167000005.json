{"auto_keywords": [{"score": 0.05007733695753263, "phrase": "memory_constraints"}, {"score": 0.04674794990628249, "phrase": "hls"}, {"score": 0.03855402656900035, "phrase": "resource_and_delay_constraints"}, {"score": 0.033130809748474196, "phrase": "memory_ports"}, {"score": 0.03273026241886464, "phrase": "ms_synthesis"}, {"score": 0.026597023579822066, "phrase": "parallel_memory_references"}, {"score": 0.004784909348794283, "phrase": "modulo_scheduling_synthesis"}, {"score": 0.004710620078577185, "phrase": "high-level_synthesis"}, {"score": 0.004551199992546761, "phrase": "small_and_fast_circuits"}, {"score": 0.004508661664944657, "phrase": "main_advantage"}, {"score": 0.004452558960552103, "phrase": "software_execution"}, {"score": 0.004424768776701965, "phrase": "modulo_scheduling"}, {"score": 0.00422177384286051, "phrase": "different_parts"}, {"score": 0.004195418010131832, "phrase": "successive_iterations"}, {"score": 0.004015458740397976, "phrase": "loop_acceleration"}, {"score": 0.003759835076089236, "phrase": "current_ms_scheduling_techniques"}, {"score": 0.0036324746826127997, "phrase": "\"ideal\"_execution_times"}, {"score": 0.003265365666305185, "phrase": "resource_constraints"}, {"score": 0.0032246835734680377, "phrase": "ideal_execution_time"}, {"score": 0.003028727936200845, "phrase": "crucial_resource"}, {"score": 0.0030097993702266354, "phrase": "hls."}, {"score": 0.0028715299874549245, "phrase": "ms_techniques"}, {"score": 0.0028091907694771613, "phrase": "interactive_synthesis_times"}, {"score": 0.0027916287357898544, "phrase": "repeated_applications"}, {"score": 0.0027395968397212053, "phrase": "different_possibilities"}, {"score": 0.002688532127821979, "phrase": "current_solutions"}, {"score": 0.0025892330566358503, "phrase": "interactive_synthesis"}, {"score": 0.002431797888365548, "phrase": "novel_combinatorial_setting"}, {"score": 0.002409020863483571, "phrase": "proposed_technique"}, {"score": 0.002371531125700046, "phrase": "dummy_operations"}, {"score": 0.002298288831092204, "phrase": "modulo-shift_operations"}, {"score": 0.0022696277881969896, "phrase": "maximal_number"}, {"score": 0.0022064376000055764, "phrase": "experimental_results"}, {"score": 0.002158505888557746, "phrase": "synthesized_circuit"}, {"score": 0.0021049977753042253, "phrase": "large-size_loops"}], "paper_keywords": ["Algorithms", " Design", " FPGA", " high-level synthesis", " memory optimizations", " modulo-scheduling"], "paper_abstract": "In High-Level Synthesis (HLS), extracting parallelism in order to create small and fast circuits is the main advantage of HLS over software execution. Modulo Scheduling (MS) is a technique in which a loop is parallelized by overlapping different parts of successive iterations. This ability to extract parallelism makes MS an attractive synthesis technique for loop acceleration. In this work we consider two problems involved in the use of MS which are central when targeting FPGAs. Current MS scheduling techniques sacrifice execution times in order to meet resource and delay constraints. Let \"ideal\" execution times be the ones that could have been obtained by MS had we ignored resource and delay constraints. Here we pose the opposite problem, which is more suitable for HLS, namely, how to reduce resource constraints without sacrificing the ideal execution time. We focus on reducing the number of memory ports used by the MS synthesis, which we believe is a crucial resource for HLS. In addition to reducing the number of memory ports we consider the need to develop MS techniques that are fast enough to allow interactive synthesis times and repeated applications of the MS to explore different possibilities of synthesizing the circuits. Current solutions for MS synthesis that can handle memory constraints are too slow to support interactive synthesis. We formalize the problem of reducing the number of parallel memory references in every row of the kernel by a novel combinatorial setting. The proposed technique is based on inserting dummy operations in the kernel and by doing so, performing modulo-shift operations such that the maximal number of parallel memory references in a row is reduced. Experimental results suggest improved execution times for the synthesized circuit. The synthesis takes only a few seconds even for large-size loops.", "paper_title": "Reducing Memory Constraints in Modulo Scheduling Synthesis for FPGAs", "paper_id": "WOS:000208167000005"}