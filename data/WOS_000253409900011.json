{"auto_keywords": [{"score": 0.022847487863909523, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "effectful_data_types"}, {"score": 0.004536244367689415, "phrase": "reasoning_principles"}, {"score": 0.004310173770196077, "phrase": "rigid_induction"}, {"score": 0.004060566667226606, "phrase": "proper_generalizations"}, {"score": 0.003991932110277654, "phrase": "lazy-datatype_induction"}, {"score": 0.003423969509052361, "phrase": "logical-relations_arguments"}, {"score": 0.0032531496610470377, "phrase": "particular_instance"}, {"score": 0.0031981188104809994, "phrase": "general_and_principled_proof"}, {"score": 0.0027194778713860715, "phrase": "monadic_model"}, {"score": 0.0026734504926268442, "phrase": "general_search_trees"}, {"score": 0.00235213013487844, "phrase": "lazy_and_eager_languages"}, {"score": 0.002168654318330797, "phrase": "sml."}], "paper_keywords": ["languages", " theory", " monads", " recursive types", " equational reasoning", " logical relations", " abstract effects", " streams", " backtracking"], "paper_abstract": "We present a pair of reasoning principles, definition and proof by rigid induction, which can be seen as proper generalizations of lazy-datatype induction to monadic effects other than partiality. We further show how these principles can be integrated into logical-relations arguments, and obtain as a particular instance a general and principled proof that the success-stream and failure-continuation models of backtracking are equivalent. As another application, we present a monadic model of general search trees, not necessarily traversed depth-first. The results are applicable to both lazy and eager languages, and we emphasize this by presenting most examples in both Haskell and SML.", "paper_title": "Inductive reasoning about effectful data types", "paper_id": "WOS:000253409900011"}