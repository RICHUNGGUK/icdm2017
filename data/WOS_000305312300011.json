{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "sequential_prediction_problems"}, {"score": 0.004225950334493496, "phrase": "\"loss\"_vector"}, {"score": 0.004010960493946656, "phrase": "inner_product"}, {"score": 0.0037249113156851013, "phrase": "long_run"}, {"score": 0.00367658459781873, "phrase": "accumulated_loss"}, {"score": 0.003535320700255283, "phrase": "best_possible_element"}, {"score": 0.0032263862712733934, "phrase": "chosen_vectors"}, {"score": 0.0031568884810273226, "phrase": "entire_loss_vectors"}, {"score": 0.002831158147480665, "phrase": "concrete_choices"}, {"score": 0.0027581067089091434, "phrase": "order_root_nd_ln_vertical_bar_s_vertical_bar"}, {"score": 0.0025500402081330394, "phrase": "previously_known_bounds"}, {"score": 0.0022967713922705, "phrase": "combinatorial_structure"}, {"score": 0.0021987994275190314, "phrase": "regret_bounds"}, {"score": 0.0021420294823879292, "phrase": "computationally_efficient_implementations"}], "paper_keywords": ["Online prediction", " Adversarial bandit problems", " Online linear optimization"], "paper_abstract": "We study sequential prediction problems in which, at each time instance, the forecaster chooses a vector from a given finite set S subset of R-d. At the same time, the opponent chooses a \"loss\" vector in R-d and the forecaster suffers a loss that is the inner product of the two vectors. The goal of the forecaster is to achieve that, in the long run, the accumulated loss is not much larger than that of the best possible element in S. We consider the \"bandit\" setting in which the forecaster only has access to the losses of the chosen vectors (i.e., the entire loss vectors are not observed). We introduce a variant of a strategy by Dani, Hayes and Kakade achieving a regret bound that, for a variety of concrete choices of S, is of order root nd ln vertical bar S vertical bar where n is the time horizon. This is not improvable in general and is better than previously known bounds. The examples we consider are all such that S subset of {0. 1}(d), and we show how the combinatorial structure of these classes can be exploited to improve the regret bounds. We also point out computationally efficient implementations for various interesting choices of S. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "Combinatorial bandits", "paper_id": "WOS:000305312300011"}