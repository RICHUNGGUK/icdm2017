{"auto_keywords": [{"score": 0.04964156968469263, "phrase": "parametric_properties"}, {"score": 0.011642569864543257, "phrase": "monitor_instances"}, {"score": 0.009969762971430216, "phrase": "unnecessary_monitor_instances"}, {"score": 0.00481495049065317, "phrase": "monitoring_parametric_properties"}, {"score": 0.0047273577269638725, "phrase": "behavioral_properties"}, {"score": 0.004684157900507474, "phrase": "program_events"}, {"score": 0.004473982381245469, "phrase": "concrete_data"}, {"score": 0.004214729542986473, "phrase": "multi-object_relationships"}, {"score": 0.004044064541716598, "phrase": "employed_formalism"}, {"score": 0.004007083686875716, "phrase": "slicing_traces_with_respect_to_parameter_instances_and_sending_these_slices_to_appropriate_non-parametric_monitor_instances"}, {"score": 0.003427540517249369, "phrase": "runtime_verification"}, {"score": 0.00338060449446278, "phrase": "previous_formalism-independent_approach"}, {"score": 0.0031991799574455555, "phrase": "collect_monitor_instances"}, {"score": 0.0030695103543472908, "phrase": "pathological_behaviors"}, {"score": 0.0029722900280316216, "phrase": "entire_length"}, {"score": 0.002851790448644913, "phrase": "new_approach"}, {"score": 0.002825681384008326, "phrase": "garbage_collecting"}, {"score": 0.0026986685585382347, "phrase": "undue_overhead"}, {"score": 0.0026616868981501006, "phrase": "lazy_collection"}, {"score": 0.0026011706232569316, "phrase": "careful_engineering"}, {"score": 0.0023725232579531273, "phrase": "average_overhead"}, {"score": 0.002318566141177149, "phrase": "dacapo_benchmark"}, {"score": 0.0021940118003312397, "phrase": "javamop"}, {"score": 0.0021049977753042253, "phrase": "tracematches"}], "paper_keywords": ["Languages", " Performance", " Reliability", " Verification", " runtime verification", " runtime monitoring", " testing", " debugging", " aspect-oriented programming", " garbage collection"], "paper_abstract": "Parametric properties are behavioral properties over program events that depend on one or more parameters. Parameters are bound to concrete data or objects at runtime, which makes parametric properties particularly suitable for stating multi-object relationships or protocols. Monitoring parametric properties independently of the employed formalism involves slicing traces with respect to parameter instances and sending these slices to appropriate non-parametric monitor instances. The number of such instances is theoretically unbounded and tends to be enormous in practice, to an extent that how to efficiently manage monitor instances has become one of the most challenging problems in runtime verification. The previous formalism-independent approach was only able to do the obvious, namely to garbage collect monitor instances when all bound parameter objects were garbage collected. This led to pathological behaviors where unnecessary monitor instances were kept for the entire length of a program. This paper proposes a new approach to garbage collecting monitor instances. Unnecessary monitor instances are collected lazily to avoid creating undue overhead. This lazy collection, along with some careful engineering, has resulted in RV, the most efficient parametric monitoring system to date. Our evaluation shows that the average overhead of RV in the DaCapo benchmark is 15%, which is two times lower than that of JavaMOP and orders of magnitude lower than that of Tracematches.", "paper_title": "Garbage Collection for Monitoring Parametric Properties", "paper_id": "WOS:000294609500036"}