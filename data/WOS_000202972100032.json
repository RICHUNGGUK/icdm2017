{"auto_keywords": [{"score": 0.047752442308727626, "phrase": "garbage_collection"}, {"score": 0.00481495049065317, "phrase": "automatic_individual_object_reclamation"}, {"score": 0.004160740888748725, "phrase": "significant_cost"}, {"score": 0.004038249989123055, "phrase": "dead_objects"}, {"score": 0.00397175830521626, "phrase": "explicit_memory_management"}, {"score": 0.003945467978172845, "phrase": "prompt_low_cost_reclamation"}, {"score": 0.003854809457075099, "phrase": "programmer_effort"}, {"score": 0.00367967106192446, "phrase": "novel_compiler"}, {"score": 0.0036553070575015344, "phrase": "runtime_support"}, {"score": 0.0035712919163869176, "phrase": "garbage-collected_system"}, {"score": 0.0035358770665604657, "phrase": "compiler's_free-me_analysis"}, {"score": 0.0033639840192975835, "phrase": "lightweight_pointer_analysis"}, {"score": 0.003341703245432554, "phrase": "liveness_information"}, {"score": 0.0032975819773787985, "phrase": "short-lived_objects"}, {"score": 0.0032110737733503807, "phrase": "region_allocation"}, {"score": 0.003004572722189157, "phrase": "program_scope"}, {"score": 0.002925728709297618, "phrase": "allocation-site_lifetime_homogeneity"}, {"score": 0.0027649684074145028, "phrase": "common_patterns"}, {"score": 0.002656823796937945, "phrase": "factory_methods"}, {"score": 0.002587081502365341, "phrase": "free-list_and_bump-pointer_allocators"}, {"score": 0.002485877135880137, "phrase": "collection_load"}, {"score": 0.0024286751532861476, "phrase": "free-me_cuts"}, {"score": 0.002234893735225432, "phrase": "software_engineering_benefits"}, {"score": 0.0021980296285911915, "phrase": "space_efficiency"}, {"score": 0.002183454435945014, "phrase": "improving_performance"}, {"score": 0.0021049977753042253, "phrase": "constrained_systems"}], "paper_keywords": ["adaptive", " generational", " compiler-assisted", " liveness", " pointer analysis", " locality", " mark-sweep", " copying"], "paper_abstract": "Garbage collection has proven benefits, including fewer memory-related errors and reduced programmer effort. Garbage collection, however, trades space for time. It reclaims memory only when it is invoked: invoking it more frequently reclaims memory quickly, but incurs a significant cost; invoking it less frequently fills memory with dead objects. In contrast, explicit memory management provides prompt low cost reclamation, but at the expense of programmer effort. This work comes closer to the best of both worlds by adding novel compiler and runtime support for compiler inserted frees to a garbage-collected system. The compiler's free-me analysis identifies when objects become unreachable and inserts calls to free. It combines a lightweight pointer analysis with liveness information that detects when short-lived objects die. Our approach differs from stack and region allocation in two crucial ways. First, it frees objects incrementally exactly when they become unreachable, instead of based on program scope. Second, our system does not require allocation-site lifetime homogeneity, and thus frees objects on some paths and not on others. It also handles common patterns: it can free objects in loops and objects created by factory methods. We evaluate free() variations for free-list and bump-pointer allocators. Explicit freeing improves performance by promptly reclaiming objects and reducing collection load. Compared to mark-sweep alone, free-me cuts total time by 22% on average, collector time by 50% to 70%, and allows programs to run in 17% less memory. This combination retains the software engineering benefits of garbage collection while increasing space efficiency and improving performance, and thus is especially appealing for real-time and space constrained systems.", "paper_title": "Free-me: A static analysis for automatic individual object reclamation", "paper_id": "WOS:000202972100032"}