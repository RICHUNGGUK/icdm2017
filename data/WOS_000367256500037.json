{"auto_keywords": [{"score": 0.03556129328808398, "phrase": "numerical_analysts"}, {"score": 0.015719716506582538, "phrase": "numerical_code"}, {"score": 0.013950627873892838, "phrase": "forward_error_analysis"}, {"score": 0.013784901194103166, "phrase": "backward_error_analysis"}, {"score": 0.004700193486903964, "phrase": "floating-point_arithmetic"}, {"score": 0.004560568143816105, "phrase": "roundoff_and_truncation_errors"}, {"score": 0.004116012194714212, "phrase": "error_analysis"}, {"score": 0.0037825134619339537, "phrase": "programming_languages"}, {"score": 0.0034759420565135253, "phrase": "numerical_stability"}, {"score": 0.003174903873774882, "phrase": "pl_community"}, {"score": 0.0029707940194245216, "phrase": "automated_backward_error_analysis"}, {"score": 0.002813566267090177, "phrase": "application_developers"}, {"score": 0.002680789041160613, "phrase": "computed_backward_error_results"}, {"score": 0.002616762777413686, "phrase": "condition_number"}, {"score": 0.002448446849997207, "phrase": "function's_sensitivity"}, {"score": 0.0023470051993423483, "phrase": "finite_precision_arithmetic"}, {"score": 0.002318799760022913, "phrase": "experimental_results"}, {"score": 0.0022633993976138387, "phrase": "widely-used_gnu_c_library_functions"}, {"score": 0.0021049977753042253, "phrase": "floating-point_programs"}], "paper_keywords": ["Reliability", " Algorithm", " Floating point", " backward error", " condition number", " mathematical optimization"], "paper_abstract": "Numerical code uses floating-point arithmetic and necessarily suffers from roundoff and truncation errors. Error analysis is the process to quantify such uncertainty. Forward error analysis and backward error analysis are two popular paradigms of error analysis. Forward error analysis is intuitive, and has been explored and automated by the programming languages (PL) community. In contrast, although backward error analysis is fundamental for numerical stability and is preferred by numerical analysts, it is less known and unexplored by the PL community. To fill this gap, this paper presents an automated backward error analysis for numerical code to empower both numerical analysts and application developers. In addition, we use the computed backward error results to compute the condition number, an important quantity recognized by numerical analysts for measuring a function's sensitivity to errors in the input and finite precision arithmetic. Experimental results on Intel x87 FPU instructions and widely-used GNU C Library functions demonstrate that our analysis is effective at analyzing the accuracy of floating-point programs.", "paper_title": "Automated Backward Error Analysis for Numerical Code", "paper_id": "WOS:000367256500037"}