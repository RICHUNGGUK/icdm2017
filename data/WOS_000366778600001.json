{"auto_keywords": [{"score": 0.041469740173514034, "phrase": "jvm"}, {"score": 0.00481495049065317, "phrase": "six_different_python"}, {"score": 0.004278807087784626, "phrase": "c_interpreters"}, {"score": 0.003752550907120244, "phrase": "metatracing_interpreters"}, {"score": 0.003468287913322255, "phrase": "c_interpreter"}, {"score": 0.003334309053314909, "phrase": "meta-tracing_interpreter"}, {"score": 0.002962543869356265, "phrase": "language_barrier"}, {"score": 0.002737960968372391, "phrase": "meta-tracing_composition"}, {"score": 0.002497319603143104, "phrase": "significantly_lower_overhead"}, {"score": 0.0024325244760735566, "phrase": "composed_programs"}, {"score": 0.0023384629381463054, "phrase": "mono-language_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Language composition", " Virtual machines"], "paper_abstract": "In this paper, we compose six different Python and Prolog VMs into 4 pairwise compositions: one using C interpreters, one running on the JVM, one using metatracing interpreters, and one using a C interpreter and a meta-tracing interpreter. We show that programs that cross the language barrier frequently execute faster in a meta-tracing composition, and that meta-tracing imposes a significantly lower overhead on composed programs relative to mono-language programs. (C) 2015 Published by Elsevier Ltd.", "paper_title": "Approaches to interpreter composition", "paper_id": "WOS:000366778600001"}