{"auto_keywords": [{"score": 0.04949240338189186, "phrase": "grammatical_evolution"}, {"score": 0.03424838397119819, "phrase": "custom_dynamic_memory_managers"}, {"score": 0.0300157551882993, "phrase": "memory_usage"}, {"score": 0.00481495049065317, "phrase": "dynamic_memory_managers"}, {"score": 0.004697655699119423, "phrase": "modern_consumer_devices"}, {"score": 0.004611554879923759, "phrase": "multimedia_applications"}, {"score": 0.004527024978801684, "phrase": "high_resource_utilization"}, {"score": 0.004230068512904886, "phrase": "dynamic_memory_subsystem"}, {"score": 0.00405127920820053, "phrase": "complex_task"}, {"score": 0.003832423454781517, "phrase": "application_source_code"}, {"score": 0.0037621210719690594, "phrase": "custom_dynamic_memory_management_mechanisms"}, {"score": 0.0036477941360224435, "phrase": "first_approach"}, {"score": 0.0033457659530207306, "phrase": "second_approach"}, {"score": 0.0033047037762521984, "phrase": "software_engineers"}, {"score": 0.0031068064097811844, "phrase": "difficult_and_error-prone_work"}, {"score": 0.0029937855454238507, "phrase": "novel_way"}, {"score": 0.002779894844207706, "phrase": "target_application"}, {"score": 0.002728847267539957, "phrase": "design_space"}, {"score": 0.0025972447844047515, "phrase": "best_dynamic_memory_manager_implementation"}, {"score": 0.002471973283582411, "phrase": "important_improvements"}, {"score": 0.0021845387990972543, "phrase": "five_different_general-purpose_dynamic_memory_managers"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Genetic programming", " Dynamic memory manager", " Multi-objective optimization"], "paper_abstract": "Modern consumer devices must execute multimedia applications that exhibit high resource utilization. In order to efficiently execute these applications, the dynamic memory subsystem needs to be optimized. This complex task can be tackled in two complementary ways: optimizing the application source code or designing custom dynamic memory management mechanisms. Currently, the first approach has been well established, and several automatic methodologies have been proposed. Regarding the second approach, software engineers often write custom dynamic memory managers from scratch, which is a difficult and error-prone work. This paper presents a novel way to automatically generate custom dynamic memory managers optimizing both performance and memory usage of the target application. The design space is pruned using grammatical evolution converging to the best dynamic memory manager implementation for the target application. Our methodology achieves important improvements (62.55% and 30.62% better on average in performance and memory usage, respectively) when its results are compared to five different general-purpose dynamic memory managers. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "A methodology to automatically optimize dynamic memory managers applying grammatical evolution", "paper_id": "WOS:000334001600008"}