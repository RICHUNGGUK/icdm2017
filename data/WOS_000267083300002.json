{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "type_analysis"}, {"score": 0.004623608221548592, "phrase": "language-independent_collection"}, {"score": 0.00457696724030363, "phrase": "standard_computational_roles"}, {"score": 0.004507882471601552, "phrase": "'typed_identifier_use"}, {"score": 0.004395040468458808, "phrase": "variable_name"}, {"score": 0.003991305899593133, "phrase": "type_analyzer"}, {"score": 0.0039310261964323545, "phrase": "specific_language"}, {"score": 0.0036801209922064817, "phrase": "computational_roles"}, {"score": 0.003551694229680741, "phrase": "general_process"}, {"score": 0.003341839487905525, "phrase": "particular_problems"}, {"score": 0.0031926001871260524, "phrase": "grammar_modules"}, {"score": 0.0030038988468808845, "phrase": "language-independent_roles"}, {"score": 0.002943502888225748, "phrase": "general_type_analysis_problem"}, {"score": 0.002840708910768261, "phrase": "compiler_designer"}, {"score": 0.002797757576619329, "phrase": "appropriate_modules"}, {"score": 0.0027414948679658816, "phrase": "relevant_source-language_constructs"}, {"score": 0.0027000395818027366, "phrase": "attribute_grammar_processor"}, {"score": 0.0026457367614424756, "phrase": "necessary_computations"}, {"score": 0.0026057256900479026, "phrase": "compiler's_semantic_analyzer"}, {"score": 0.002540377258232509, "phrase": "precise_definition"}, {"score": 0.002271725588755076, "phrase": "type_analysis_process"}, {"score": 0.002181227522730908, "phrase": "hand-coded_semantic_analyzer"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compilers", " type analysis", " attribute grammars", " reuse"], "paper_abstract": "Type analysis can be characterized by a language-independent collection of standard computational roles such as 'typed identifier use' (e.g. a variable name appearing in an expression) and 'dyadic expression' (e.g. addition of two values). A type analyzer for a specific language is then defined by stating which language construct(s) play each role. The computational roles provide a framework for understanding the general process and a vocabulary for applying that understanding to the solution of particular problems. We have captured this knowledge in attribute grammar modules that are carefully designed to be combinable and adaptable, exporting language-independent roles that define the general type analysis problem. From this collection, the compiler designer instantiates the appropriate modules and identifies the relevant source-language constructs; an attribute grammar processor then weaves the necessary computations into the compiler's semantic analyzer. Our attribute grammar modules provide a precise definition of the actions constituting the various roles and the dependences among them. They can therefore also be used to describe the type analysis process to students, or to specify a hand-coded semantic analyzer. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Reusable specification modules for type analysis", "paper_id": "WOS:000267083300002"}