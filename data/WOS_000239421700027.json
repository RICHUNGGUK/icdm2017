{"auto_keywords": [{"score": 0.049090663946911924, "phrase": "sadakane"}, {"score": 0.00481495049065317, "phrase": "succinct_data_structures"}, {"score": 0.004755054742217193, "phrase": "recent_work"}, {"score": 0.004676345706416371, "phrase": "grossi"}, {"score": 0.004466519142879166, "phrase": "sequence_s"}, {"score": 0.004266067096140677, "phrase": "size_sigma"}, {"score": 0.003795335309109018, "phrase": "k-th_order_empirical_entropy"}, {"score": 0.0035499650812710806, "phrase": "constant_time"}, {"score": 0.003404703106153948, "phrase": "ram_model"}, {"score": 0.0032517484445814334, "phrase": "succinct_data_structure"}, {"score": 0.002728166176898539, "phrase": "ziv-lempel_compression"}, {"score": 0.0025623050508233078, "phrase": "compressed_full-text_indexes"}, {"score": 0.00241658945942583, "phrase": "time_complexities"}, {"score": 0.0023864566654035924, "phrase": "simpler_scheme"}, {"score": 0.0023566987138026285, "phrase": "statistical_encoding"}, {"score": 0.0022507188208913394, "phrase": "constant_amortized_time"}, {"score": 0.0021049977753042253, "phrase": "full-text_self-indexing"}], "paper_keywords": [""], "paper_abstract": "In recent work, Sadakane and Grossi [SODA 2006] introduced a scheme to represent any sequence S = s(1)s(2)...s(n), over an alphabet of size sigma, using nH(k)(S) + O(log(sigma)n/n (k log sigma + log log n)) bits of space, log, n where H-k(S) is the k-th order empirical entropy of S. The representation permits extracting any substring of size Theta(log(sigma) n) in constant time, and thus it completely replaces S under the RAM model. This is extremely important because it permits converting any succinct data structure requiring o(vertical bar S vertical bar) = o(n log sigma) bits in addition to S, into another requiring nH(k)(S) + o(n log sigma) (overall) for any k = o(log(sigma) n). They achieve this result by using Ziv-Lempel compression, and. conjecture that the result can in particular be useful to implement compressed full-text indexes. In this paper we extend their result, by obtaining the same space and time complexities using a simpler scheme based on statistical encoding. We show that the scheme supports appending symbols in constant amortized time. In addition, we prove some results on the applicability of the scheme for full-text self-indexing.", "paper_title": "Statistical encoding of succinct data structures", "paper_id": "WOS:000239421700027"}