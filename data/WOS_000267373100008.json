{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "software_transactional_memory"}, {"score": 0.004596561972944185, "phrase": "promising_programming_model"}, {"score": 0.00415019999222481, "phrase": "concurrent_accesses"}, {"score": 0.00396206173537859, "phrase": "ram"}, {"score": 0.003644001325962353, "phrase": "revertible_operations"}, {"score": 0.0035110198699787013, "phrase": "memory_allocation"}, {"score": 0.0033515736929172644, "phrase": "software_libraries"}, {"score": 0.0031697368057340895, "phrase": "software_memory_transactional_contexts"}, {"score": 0.0028615323526689582, "phrase": "transaction_life_cycle_state_diagram"}, {"score": 0.0026317312518257803, "phrase": "user-defined_handlers"}, {"score": 0.0025592969422491476, "phrase": "proposed_approach"}, {"score": 0.002267708463966758, "phrase": "use_case_study_and_performance_tests"}], "paper_keywords": ["Transactions", " Software Transactional Memory", " Compensation Actions", " Revertible Operations"], "paper_abstract": "Software transactional memory is a promising programming model that adapts many concepts borrowed from the databases world to control concurrent accesses to main memory (RAM). This paper discusses how to support revertible operations, such as memory allocation and release, within software libraries that will be used in software memory transactional contexts. The proposal is based in the extension of the transaction life cycle state diagram with new states associated to the execution of user-defined handlers. The proposed approach is evaluated in terms of functionality and performance by way of a use case study and performance tests. Results demonstrate that the proposal and its current implementation are flexible, generic and efficient.", "paper_title": "Developing Libraries Using Software Transactional Memory", "paper_id": "WOS:000267373100008"}