{"auto_keywords": [{"score": 0.04625630397808137, "phrase": "considerable_effort"}, {"score": 0.00481495049065317, "phrase": "meta-theory_a"}, {"score": 0.004628320711601916, "phrase": "programming_languages"}, {"score": 0.0045557008859819234, "phrase": "proof_assistant"}, {"score": 0.0043790755286923794, "phrase": "mechanizing_proofs"}, {"score": 0.004276390289178831, "phrase": "standard_practice"}, {"score": 0.004078157608867258, "phrase": "existing_mechanized_formalizations"}, {"score": 0.003982500388997765, "phrase": "new_language"}, {"score": 0.0037679023889496885, "phrase": "inductive_definitions"}, {"score": 0.0035648266669315943, "phrase": "language_designers"}, {"score": 0.0034949740315415043, "phrase": "existing_definitions"}, {"score": 0.0034264854489231148, "phrase": "ad-hoc_manner"}, {"score": 0.0032675209435107273, "phrase": "key_contribution"}, {"score": 0.003153140905312787, "phrase": "induction_technique"}, {"score": 0.003128270147867462, "phrase": "extensible_church_encodings"}, {"score": 0.0030913302090179967, "phrase": "novel_reinterpretation"}, {"score": 0.003054825135908205, "phrase": "universal_property"}, {"score": 0.0028786929852224756, "phrase": "coq"}, {"score": 0.0028334016912935165, "phrase": "type_classes"}, {"score": 0.0027450280220853137, "phrase": "modular_components"}, {"score": 0.002627985415362773, "phrase": "meta-theory_formalizations"}, {"score": 0.002576442680766742, "phrase": "modular_inductive_definitions"}, {"score": 0.002486193594641237, "phrase": "general_recursion"}, {"score": 0.0023520340492933383, "phrase": "fully_mechanized_definitions"}, {"score": 0.002164216680934624, "phrase": "non-inductive_semantic_functions"}, {"score": 0.002138636271204459, "phrase": "mediating_type_classes"}, {"score": 0.00212175050242788, "phrase": "proof_adaptation"}], "paper_keywords": ["Modular Mechanized Meta-Theory", " Extensible Church Encodings", " Coq"], "paper_abstract": "Formalizing meta-theory, or proofs about programming languages, in a proof assistant has many well-known benefits. Unfortunately, the considerable effort involved in mechanizing proofs has prevented it from becoming standard practice. This cost can be amortized by reusing as much of existing mechanized formalizations as possible when building a new language or extending an existing one. One important challenge in achieving reuse is that the inductive definitions and proofs used in these formalizations are closed to extension. This forces language designers to cut and paste existing definitions and proofs in an ad-hoc manner and to expend considerable effort to patch up the results. The key contribution of this paper is the development of an induction technique for extensible Church encodings using a novel reinterpretation of the universal property of folds. These encodings provide the foundation for a framework, formalized in Coq, which uses type classes to automate the composition of proofs from modular components. This framework enables a more structured approach to the reuse of meta-theory formalizations through the composition of modular inductive definitions and proofs. Several interesting language features, including binders and general recursion, illustrate the capabilities of our framework. We reuse these features to build fully mechanized definitions and proofs for a number of languages, including a version of mini-ML. Bounded induction enables proofs of properties for non-inductive semantic functions, and mediating type classes enable proof adaptation for more feature-rich languages.", "paper_title": "Meta-Theory a la Carte", "paper_id": "WOS:000318629900018"}