{"auto_keywords": [{"score": 0.04278739897749829, "phrase": "equivalent_mutants"}, {"score": 0.00481495049065317, "phrase": "javascript_web_applications"}, {"score": 0.004765788394931875, "phrase": "mutation_testing"}, {"score": 0.004692980391580608, "phrase": "effective_test_adequacy_assessment_technique"}, {"score": 0.004527371799277529, "phrase": "high_computational_cost"}, {"score": 0.004435363840720883, "phrase": "test_suite"}, {"score": 0.004367581653370531, "phrase": "potentially_large_pool"}, {"score": 0.004322967486451877, "phrase": "generated_mutants"}, {"score": 0.0040438338011467845, "phrase": "prior_work"}, {"score": 0.003861175855298779, "phrase": "mutation_generation_phase"}, {"score": 0.0037057255600764475, "phrase": "limited_efficiency"}, {"score": 0.003343841875107018, "phrase": "function_rank"}, {"score": 0.003176333519010176, "phrase": "application's_behaviour_point"}, {"score": 0.0030171910207671205, "phrase": "static_and_dynamic_analysis"}, {"score": 0.002955782731675529, "phrase": "mutation_generation_process"}, {"score": 0.0027646829399573434, "phrase": "program's_output"}, {"score": 0.0026532596852754525, "phrase": "javascript_language"}, {"score": 0.002559444836360178, "phrase": "mutation_operators"}, {"score": 0.0025202582748972122, "phrase": "specific_to_web_applications"}, {"score": 0.0024062532032402533, "phrase": "mutandis."}, {"score": 0.0021821915946356168, "phrase": "surviving_non-equivalent_mutants"}, {"score": 0.0021049977753042253, "phrase": "ranked_functions"}], "paper_keywords": ["Mutation testing", " JavaScript", " equivalent mutants", " guided mutation generation", " web applications"], "paper_abstract": "Mutation testing is an effective test adequacy assessment technique. However, there is a high computational cost in executing the test suite against a potentially large pool of generated mutants. Moreover, there is much effort involved in filtering out equivalent mutants. Prior work has mainly focused on detecting equivalent mutants after the mutation generation phase, which is computationally expensive and has limited efficiency. We propose an algorithm to select variables and branches for mutation as well as a metric, called Function Rank, to rank functions according to their relative importance from the application's behaviour point of view. We present a technique that leverages static and dynamic analysis to guide the mutation generation process towards parts of the code that are more likely to influence the program's output. Further, we focus on the JavaScript language, and propose a set of mutation operators that are specific to web applications. We implement our approach in a tool called MUTANDIS. The results of our empirical evaluation show that (1) more than 93 percent of generated mutants are non-equivalent, and (2) more than 75 percent of the surviving non-equivalent mutants are in the top 30 percent of the ranked functions.", "paper_title": "Guided Mutation Testing for JavaScript Web Applications", "paper_id": "WOS:000354475400001"}