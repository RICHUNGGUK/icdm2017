{"auto_keywords": [{"score": 0.03381695746854279, "phrase": "single_inheritance"}, {"score": 0.00481495049065317, "phrase": "partial_type_graph"}, {"score": 0.004635187610736025, "phrase": "class_hierarchy_complementation"}, {"score": 0.004535481695403089, "phrase": "partially_known_hierarchy"}, {"score": 0.004413846562278824, "phrase": "subtyping_constraints"}, {"score": 0.004225950334493496, "phrase": "transitive_subtype"}, {"score": 0.003831801113154043, "phrase": "immediate_practical_application"}, {"score": 0.003728966994353039, "phrase": "partial_programs-e.g"}, {"score": 0.003512308265830794, "phrase": "sound_handling"}, {"score": 0.0034742854447532678, "phrase": "\"phantom_classes"}, {"score": 0.003399466007862412, "phrase": "soot_program_analysis_framework"}, {"score": 0.0032546105164772995, "phrase": "hierarchy_complementation_problem"}, {"score": 0.003167217223469026, "phrase": "multiple_inheritance_settings"}, {"score": 0.002950951388129134, "phrase": "java"}, {"score": 0.0028715299874549245, "phrase": "multiple_subtyping"}, {"score": 0.0028404241985421096, "phrase": "distinguished_class"}, {"score": 0.0028096544129939277, "phrase": "interface_types"}, {"score": 0.002719325177422626, "phrase": "separate_single-_and_multiple-subtyping_instances"}, {"score": 0.002575167114383286, "phrase": "jphantom"}, {"score": 0.00251966141432339, "phrase": "partial_java_bytecode_programs"}, {"score": 0.002386062690026682, "phrase": "java_verifier_requirements"}, {"score": 0.0022718774783143203, "phrase": "mere_seconds"}, {"score": 0.002235040467016128, "phrase": "large_input_applications"}, {"score": 0.002210814150677161, "phrase": "complex_constraints"}], "paper_keywords": ["type hierarchy", " Java", " single inheritance", " multiple inheritance", " JPhantom", " bytecode engineering"], "paper_abstract": "We present the problem of class hierarchy complementation: given a partially known hierarchy of classes together with subtyping constraints (\"A has to be a transitive subtype of B\") complete the hierarchy so that it satisfies all constraints. The problem has immediate practical application to the analysis of partial programs-e.g., it arises in the process of providing a sound handling of \"phantom classes\" in the Soot program analysis framework. We provide algorithms to solve the hierarchy complementation problem in the single inheritance and multiple inheritance settings. We also show that the problem in a language such as Java, with single inheritance but multiple subtyping and distinguished class vs. interface types, can be decomposed into separate single- and multiple-subtyping instances. We implement our algorithms in a tool, JPhantom, which complements partial Java bytecode programs so that the result is guaranteed to satisfy the Java verifier requirements. JPhantom is highly scalable and runs in mere seconds even for large input applications and complex constraints (with a maximum of 14s for a 19MB binary).", "paper_title": "Class Hierarchy Complementation: Soundly Completing a Partial Type Graph", "paper_id": "WOS:000327697300029"}