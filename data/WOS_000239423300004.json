{"auto_keywords": [{"score": 0.0464485993141056, "phrase": "common_case"}, {"score": 0.012686989134378913, "phrase": "communication_steps"}, {"score": 0.00481495049065317, "phrase": "first_protocol"}, {"score": 0.004674952036988355, "phrase": "asynchronous_byzantine_consensus"}, {"score": 0.0036553070575015344, "phrase": "two-step_consensus"}, {"score": 0.003312486229143855, "phrase": "replicated_state_machine"}, {"score": 0.0028574164693918433, "phrase": "parameterized_version"}, {"score": 0.002640781900605126, "phrase": "f_byzantine_failures"}, {"score": 0.0024405312482831646, "phrase": "two-step_execution"}, {"score": 0.0023694065215394593, "phrase": "number_t"}], "paper_keywords": ["distributed systems", " Byzantine fault tolerance", " consensus"], "paper_abstract": "We present the first protocol that reaches asynchronous Byzantine consensus in two communication steps in the common case. We prove that our protocol is optimal in terms of both number of communication steps and number of processes for two-step consensus. The protocol can be used to build a replicated state machine that requires only three communication steps per request in the common case. Further, we show a parameterized version of the protocol that is safe despite f Byzantine failures and, in the common case, guarantees two-step execution despite some number t of failures (t <= f). We show that this parameterized two-step consensus protocol is also optimal in terms of both number of communication steps and number of processes.", "paper_title": "Fast Byzantine consensus", "paper_id": "WOS:000239423300004"}