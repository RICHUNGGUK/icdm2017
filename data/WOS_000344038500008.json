{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "alloy"}, {"score": 0.004668510065740584, "phrase": "bounded_analysis"}, {"score": 0.004596960835906736, "phrase": "arithmetic_operators"}, {"score": 0.004388796812234033, "phrase": "different_semantics"}, {"score": 0.00415777266387528, "phrase": "programming_languages"}, {"score": 0.003534889186471058, "phrase": "unexpected_counterexamples"}, {"score": 0.0032216622984027558, "phrase": "unbounded_setting"}, {"score": 0.003075583447856341, "phrase": "new_approach"}, {"score": 0.0029589086332593674, "phrase": "latest_version"}, {"score": 0.0025942468561537682, "phrase": "spurious_counterexamples"}, {"score": 0.0024957862318504753, "phrase": "key_idea"}, {"score": 0.002364172626241202, "phrase": "bound_variables"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Arithmetic overflows", " Partial functions", " Logic", " First order", " Alloy"], "paper_abstract": "In a bounded analysis, arithmetic operators become partial, and a different semantics becomes necessary. One approach, mimicking programming languages, is for overflow to result in wrap-around. Although easy to implement, wrap-around produces unexpected counterexamples that do not correspond to cases that would arise in the unbounded setting. This paper describes a new approach, implemented in the latest version of the Alloy Analyzer, in which instances that would involve overflow are suppressed, and consequently, spurious counterexamples are eliminated. The key idea is to interpret quantifiers so that bound variables range only over values that do not cause overflow. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Preventing arithmetic overflows in Alloy", "paper_id": "WOS:000344038500008"}