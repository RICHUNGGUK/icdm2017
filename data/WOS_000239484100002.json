{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "long-lived_safe_agreement"}, {"score": 0.004503959683578956, "phrase": "step_complexity"}, {"score": 0.004283913685201902, "phrase": "point_contention"}, {"score": 0.004108742905942481, "phrase": "simultaneously_active_processes"}, {"score": 0.00390792986752692, "phrase": "distributed_systems"}, {"score": 0.0038431888954930083, "phrase": "varying_degree"}, {"score": 0.003685972800046028, "phrase": "shared-memory_algorithms"}, {"score": 0.0031712256091350316, "phrase": "challenging_task"}, {"score": 0.0030160945545795468, "phrase": "long-lived_safe_agreement_object"}, {"score": 0.0028685304140180137, "phrase": "borowsky_et_al"}, {"score": 0.0021766418372878835, "phrase": "information_collection"}, {"score": 0.0021049977753042253, "phrase": "adaptive_manner"}], "paper_keywords": [""], "paper_abstract": "Algorithms with step complexity that depends only on the point contention-the number of simultaneously active processes-are very attractive for distributed systems with varying degree of concurrency. Designing shared-memory algorithms that adapt to point contention, using only read and write operations, is however, a challenging task. The paper specifies the long-lived safe agreement object, extending an object of Borowsky et al. [1], and describes an implementation whose step complexity is adaptive to point contention. Then, we illustrate how this object is used to solve other problems, like renaming and information collection, in an adaptive manner.", "paper_title": "Adapting to point contention with long-lived safe agreement (Extended abstract)", "paper_id": "WOS:000239484100002"}