{"auto_keywords": [{"score": 0.04881318091486501, "phrase": "concurrent_programs"}, {"score": 0.00481495049065317, "phrase": "multicore_dumps"}, {"score": 0.004750873844061641, "phrase": "concurrency_bug_reproduction"}, {"score": 0.004502943680955863, "phrase": "inherent_non-determinism"}, {"score": 0.004403480614319231, "phrase": "scheduler_interleavings"}, {"score": 0.004027031316965272, "phrase": "multi-core_environments"}, {"score": 0.003955679223407243, "phrase": "multiple_schedulers"}, {"score": 0.0037157201349604222, "phrase": "reproduction_technique"}, {"score": 0.0036173729405604674, "phrase": "multi-core_platforms"}, {"score": 0.0035216195857272403, "phrase": "lightweight_analysis"}, {"score": 0.003397866151093552, "phrase": "multi-core_environment"}, {"score": 0.003149094460617212, "phrase": "single-core_system"}, {"score": 0.0030520148188164084, "phrase": "deterministic_scheduler"}, {"score": 0.002931569771634119, "phrase": "execution_point"}, {"score": 0.0028284924551705516, "phrase": "failure_point"}, {"score": 0.002574788013427524, "phrase": "related_point"}, {"score": 0.0024842242921857705, "phrase": "core_dump"}, {"score": 0.0022816681646340518, "phrase": "search_algorithm"}, {"score": 0.0021049977753042253, "phrase": "reasonable_overhead"}], "paper_keywords": ["Algorithms", " Verification", " concurrency bugs", " reproduction", " execution indexing", " multi-core"], "paper_abstract": "Debugging concurrent programs is difficult. This is primarily because the inherent non-determinism that arises because of scheduler interleavings makes it hard to easily reproduce bugs that may manifest only under certain interleavings. The problem is exacerbated in multi-core environments where there are multiple schedulers, one for each core. In this paper, we propose a reproduction technique for concurrent programs that execute on multi-core platforms. Our technique performs a lightweight analysis of a failing execution that occurs in a multi-core environment, and uses the result of the analysis to enable reproduction of the bug in a single-core system, under the control of a deterministic scheduler. More specifically, our approach automatically identifies the execution point in the re-execution that corresponds to the failure point. It does so by analyzing the failure core dump and leveraging a technique called execution indexing that identifies a related point in the re-execution. By generating a core dump at this point, and comparing the differences betwen the two dumps, we are able to guide a search algorithm to efficiently generate a failure inducing schedule. Our experiments show that our technique is highly effective and has reasonable overhead.", "paper_title": "Analyzing Multicore Dumps to Facilitate Concurrency Bug Reproduction", "paper_id": "WOS:000275926700014"}