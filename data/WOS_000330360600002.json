{"auto_keywords": [{"score": 0.050078515420922086, "phrase": "mercury_programs"}, {"score": 0.049450454172374314, "phrase": "rbmm"}, {"score": 0.039098491310119936, "phrase": "program_analyses"}, {"score": 0.004783232571029632, "phrase": "region-based_memory_management"}, {"score": 0.004658426838467567, "phrase": "compile_time_memory_management"}, {"score": 0.0045218909699308385, "phrase": "functional_programming"}, {"score": 0.004331675965350876, "phrase": "logic_programming_language_mercury"}, {"score": 0.0042749949901383835, "phrase": "mercury"}, {"score": 0.004176961840039024, "phrase": "strong_type"}, {"score": 0.0041084684278314305, "phrase": "determinism_systems"}, {"score": 0.004014452814186653, "phrase": "mercury_programmers"}, {"score": 0.003935575440750755, "phrase": "self-documenting_code"}, {"score": 0.0039096275435779124, "phrase": "clear_program_logic"}, {"score": 0.003807529003314843, "phrase": "large_amount"}, {"score": 0.0033576858946833587, "phrase": "necessary_region_operations"}, {"score": 0.003216285378512588, "phrase": "annotated_programs"}, {"score": 0.0031634950012560384, "phrase": "runtime_support"}, {"score": 0.0029903851294825023, "phrase": "forward_execution"}, {"score": 0.002476009439388887, "phrase": "benchmark_programs"}, {"score": 0.0024434201175883674, "phrase": "well-known_difficult_cases"}, {"score": 0.002427286633577638, "phrase": "rbmm."}, {"score": 0.002395336706478158, "phrase": "difficult_cases"}, {"score": 0.002279217896185919, "phrase": "base_mercury_system"}, {"score": 0.002234358539133758, "phrase": "average_runtime_speedup"}, {"score": 0.002168715943767454, "phrase": "memory_requirements"}, {"score": 0.0021049977753042253, "phrase": "optimal_memory_consumption"}], "paper_keywords": ["region-based memory management", " region analysis", " runtime support", " backtracking", " logic programming", " Mercury"], "paper_abstract": "Region-based memory management (RBMM) is a form of compile time memory management, well-known from the world of functional programming. In this paper we describe our work on implementing RBMM for the logic programming language Mercury. One interesting point about Mercury is that it is designed with strong type, mode, and determinism systems. These systems not only provide Mercury programmers with several direct software engineering benefits, such as self-documenting code and clear program logic, but also give language implementors a large amount of information that is useful for program analyses. In this work, we make use of this information to develop program analyses that determine the distribution of data into regions and transform Mercury programs by inserting into them the necessary region operations. We prove the correctness of our program analyses and transformation. To execute annotated programs, we have implemented runtime support that tackles the two main challenges posed by backtracking. First, backtracking can require regions removed during forward execution to be \"resurrected\"; and second, any memory allocated during computation that has been backtracked over must be recovered promptly without waiting for the regions involved to come to the end of their life. We describe in detail our solution of both these problems. We study in detail how our RBMM system performs on a selection of benchmark programs, including some well-known difficult cases for RBMM. Even with these difficult cases, our RBMM-enabled Mercury system obtains clearly faster runtimes for 15 out of 18 benchmarks compared to the base Mercury system with its Boehm runtime garbage collector, with an average runtime speedup of 24%, and an average reduction in memory requirements of 95%. In fact, our system achieves optimal memory consumption in some programs.", "paper_title": "Region-based memory management for Mercury programs", "paper_id": "WOS:000330360600002"}