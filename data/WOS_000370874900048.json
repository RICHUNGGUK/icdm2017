{"auto_keywords": [{"score": 0.0426945148777153, "phrase": "dynamic_linking"}, {"score": 0.005647679618402723, "phrase": "memory_load"}, {"score": 0.00481495049065317, "phrase": "architectural_support_for_dynamic_linking"}, {"score": 0.004640079189342692, "phrase": "standard_libraries"}, {"score": 0.004565848982590092, "phrase": "library_call_trampolines"}, {"score": 0.0041653307620376535, "phrase": "symbol_addresses"}, {"score": 0.0035478628449322866, "phrase": "numerous_other_benefits"}, {"score": 0.003314921989697641, "phrase": "dynamically_linked_library"}, {"score": 0.0032240802202623316, "phrase": "function_address"}, {"score": 0.003194354458513131, "phrase": "lookup_table"}, {"score": 0.0030309961956273028, "phrase": "performance_penalty"}, {"score": 0.0029027394930867902, "phrase": "predominant_choice"}, {"score": 0.0028582571226324293, "phrase": "performance_cost"}, {"score": 0.002779894844207706, "phrase": "speculative_hardware_mechanism"}, {"score": 0.0026953359825383624, "phrase": "library_function_calls"}, {"score": 0.0026052812376885504, "phrase": "static_linking"}, {"score": 0.002456744238900652, "phrase": "executed_instructions"}, {"score": 0.0024340759772801847, "phrase": "additional_performance"}, {"score": 0.002331018915674993, "phrase": "branch_predictors"}, {"score": 0.0023023818355050237, "phrase": "indirect_targets"}, {"score": 0.0022531089868518235, "phrase": "program_execution"}, {"score": 0.0021710766932077972, "phrase": "real_hardware"}, {"score": 0.002157697367447098, "phrase": "production_software"}, {"score": 0.0021049977753042253, "phrase": "on-chip_storage"}], "paper_keywords": ["Dynamic Linking", " Hardware Memoization", " Instruction Elision", " Branch Prediction"], "paper_abstract": "All software in use today relies on libraries, including standard libraries (e.g., C, C++) and application-specific libraries (e.g., libxml, libpng). Most libraries are loaded in memory and dynamically linked when programs are launched, resolving symbol addresses across the applications and libraries. Dynamic linking has many benefits: It allows code to be reused between applications, conserves memory (because only one copy of a library is kept in memory for all the applications that share it), and allows libraries to be patched and updated without modifying programs, among numerous other benefits. However, these benefits come at the cost of performance. For every call made to a function in a dynamically linked library, a trampoline is used to read the function address from a lookup table and branch to the function, incurring memory load and branch operations. Static linking avoids this performance penalty, but loses all the benefits of dynamic linking. Given its myriad benefits, dynamic linking is the predominant choice today, despite the performance cost. In this work, we propose a speculative hardware mechanism to optimize dynamic linking by avoiding executing the trampolines for library function calls, providing the benefits of dynamic linking with the performance of static linking. Speculatively skipping the memory load and branch operations of the library call trampolines improves performance by reducing the number of executed instructions and gains additional performance by reducing pressure on the instruction and data caches, TLBs, and branch predictors. Because the indirect targets of library call trampolines do not change during program execution, our speculative mechanism never misspeculates in practice. We evaluate our technique on real hardware with production software and observe up to 4% speedup using only 1.5KB of on-chip storage.", "paper_title": "Architectural Support for Dynamic Linking", "paper_id": "WOS:000370874900048"}