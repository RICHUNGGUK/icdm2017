{"auto_keywords": [{"score": 0.042389058155836386, "phrase": "small_rules"}, {"score": 0.04188522322034607, "phrase": "large_rules"}, {"score": 0.036598248434623164, "phrase": "small_and_large_rules"}, {"score": 0.004815959035805122, "phrase": "throughput"}, {"score": 0.0047851345246117455, "phrase": "packet_classification"}, {"score": 0.00474075475474847, "phrase": "key_functionality"}, {"score": 0.00469678464293492, "phrase": "modern_routers"}, {"score": 0.0046676969718111765, "phrase": "previous_decision-tree_algorithms"}, {"score": 0.0046100598144232985, "phrase": "hypercuts"}, {"score": 0.004553128404612054, "phrase": "multi-dimensional_rule_space"}, {"score": 0.0044968982227349625, "phrase": "classifier's_rules"}, {"score": 0.004386503433248535, "phrase": "considerable_memory_overhead"}, {"score": 0.004239103253656808, "phrase": "classifier_overlap"}, {"score": 0.004199766284749713, "phrase": "overlapping_rules"}, {"score": 0.004096635798793164, "phrase": "algorithms'_fine_cuts"}, {"score": 0.003910016472705627, "phrase": "classifier's_rule-space_density"}, {"score": 0.0037668375812212654, "phrase": "sparse_parts"}, {"score": 0.00316475494774005, "phrase": "distinct_tree"}, {"score": 0.0028293966058473476, "phrase": "multiple_trees'_extra_accesses"}, {"score": 0.002759823989317719, "phrase": "separable_trees"}, {"score": 0.002577171858769087, "phrase": "unequal_cuts"}, {"score": 0.0025452819305349416, "phrase": "node's_rules"}, {"score": 0.0024904187737391807, "phrase": "ineffectual_nodes"}, {"score": 0.002444333100610621, "phrase": "small_processing_overhead"}, {"score": 0.0024216102875733027, "phrase": "tree_traversal"}, {"score": 0.002384206251320424, "phrase": "node_co-location"}, {"score": 0.002212535878761148, "phrase": "classbench"}, {"score": 0.0021648294450401133, "phrase": "throughput_efficuts"}], "paper_keywords": ["Algorithms", " Design", " Performance", " Packet Classification", " Decision-Tree Algorithm", " Rule Replication"], "paper_abstract": "Packet Classification is a key functionality provided by modern routers. Previous decision-tree algorithms, HiCuts and HyperCuts, cut the multi-dimensional rule space to separate a classifier's rules. Despite their optimizations, the algorithms incur considerable memory overhead due to two issues: (1) Many rules in a classifier overlap and the overlapping rules vary vastly in size, causing the algorithms' fine cuts for separating the small rules to replicate the large rules. (2) Because a classifier's rule-space density varies significantly, the algorithms' equi-sized cuts for separating the dense parts needlessly partition the sparse parts, resulting in many ineffectual nodes that hold only a few rules. We propose EffiCuts which employs four novel ideas: (1) Separable trees: To eliminate overlap among small and large rules, we separate all small and large rules. We define a subset of rules to be separable if all the rules are either small or large in each dimension. We build a distinct tree for each such subset where each dimension can be cut coarsely to separate the large rules, or finely to separate the small rules without incurring replication. (2) Selective tree merging: To reduce the multiple trees' extra accesses which degrade throughput, we selectively merge separable trees mixing rules that may be small or large in at most one dimension. (3) Equi-dense cuts: We employ unequal cuts which distribute a node's rules evenly among the children, avoiding ineffectual nodes at the cost of a small processing overhead in the tree traversal. (4) Node Co-location: To achieve fewer accesses per node than HiCuts and HyperCuts, we co-locate parts of a node and its children. Using ClassBench, we show that for similar throughput EffiCuts needs factors of 57 less memory than HyperCuts and of 4-8 less power than TCAM.", "paper_title": "EffiCuts: Optimizing Packet Classification for Memory and Throughput", "paper_id": "WOS:000284879800019"}