{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "union_types"}, {"score": 0.04653478165971171, "phrase": "session_types"}, {"score": 0.004602395776895036, "phrase": "network_application_respect"}, {"score": 0.004499647408293102, "phrase": "crucial_issue"}, {"score": 0.004300951511110487, "phrase": "structured_communication_sequences"}, {"score": 0.004204904449336037, "phrase": "object-oriented_programming"}, {"score": 0.00414830454375092, "phrase": "established_paradigm"}, {"score": 0.004110993414942228, "phrase": "large_scale_applications"}, {"score": 0.003965061486705487, "phrase": "least_common_supertypes"}, {"score": 0.003772793879444995, "phrase": "unrelated_classes"}, {"score": 0.003738847528809348, "phrase": "similar_interfaces"}, {"score": 0.0037052054802048707, "phrase": "additional_programming"}, {"score": 0.0034780071331554003, "phrase": "class-based_core_language"}, {"score": 0.0033544692489307676, "phrase": "successfully_amalgamated_sessions"}, {"score": 0.0031773149810690494, "phrase": "communication_protocols"}, {"score": 0.0030783143919343972, "phrase": "first_aim"}, {"score": 0.002915701586760994, "phrase": "full_proof"}, {"score": 0.0028764048059439205, "phrase": "type_safety_property"}, {"score": 0.0028376361457661415, "phrase": "core_language"}, {"score": 0.0024774888010414206, "phrase": "communication_deadlock"}, {"score": 0.0024440836179156593, "phrase": "second_aim"}, {"score": 0.002389403849342894, "phrase": "constraint-based_type_system"}, {"score": 0.0023465400668244386, "phrase": "appropriate_session_types"}, {"score": 0.0023253967212081626, "phrase": "session_declarations"}, {"score": 0.002162951519368368, "phrase": "programming_work"}, {"score": 0.0021049977753042253, "phrase": "abstract_view"}], "paper_keywords": [""], "paper_abstract": "Guaranteeing that the parties of a network application respect a given protocol is a crucial issue. Session types offer a method for abstracting and validating structured communication sequences (sessions). Object-oriented programming is an established paradigm for large scale applications. Union types, which behave as the least common supertypes of a set of classes, allow the implementation of unrelated classes with similar interfaces without additional programming. We have previously developed an integration of the features above into a class-based core language for building network applications, and this successfully amalgamated sessions and methods so that data can be exchanged flexibly according to communication protocols (session types). The first aim of the work reported in this paper is to provide a full proof of the type safety property for that core language by renewing syntax, typing and semantics. In this way, static typechecking guarantees that after a session has started, computation cannot get stuck on a communication deadlock. The second aim is to define a constraint-based type system that reconstructs the appropriate session types of session declarations instead of assuming that session types are explicitly given by the programmer. Such an algorithm can save programming work, and automatically presents an abstract view of the communications of the sessions.", "paper_title": "Deriving session and union types for objects", "paper_id": "WOS:000326438200002"}