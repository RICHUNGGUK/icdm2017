{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "mercury"}, {"score": 0.005151389906047362, "phrase": "mercury_implementation"}, {"score": 0.004620093797504386, "phrase": "lp_system"}, {"score": 0.003936389070602614, "phrase": "special_challenges"}, {"score": 0.0036427494871085243, "phrase": "prolog"}, {"score": 0.0035497797026638033, "phrase": "tabled_predicates"}, {"score": 0.0033883824438527316, "phrase": "prolog_system"}, {"score": 0.003071274938566466, "phrase": "stratified_programs"}, {"score": 0.002670884656785558, "phrase": "mercury's_language"}, {"score": 0.0024971164119047358, "phrase": "wam"}, {"score": 0.002298649369775623, "phrase": "significant_impact"}, {"score": 0.0021049977753042253, "phrase": "copying_approach"}], "paper_keywords": [""], "paper_abstract": "For any LP system, tabling can be quite handy in a variety of tasks, especially if it is efficiently implemented and fully integrated in the language. Implementing tabling in Mercury poses special challenges for several reasons. First, Mercury is both semantically and culturally quite different from Prolog. While decreeing that tabled predicates must not include cuts is acceptable in a Prolog system, it is not acceptable in Mercury, since if-then-elses and existential quantification have sound semantics for stratified programs and are used very frequently both by programmers and by the compiler. The Mercury implementation thus has no option but to handle interactions of tabling with Mercury's language features safely. Second, the Mercury implementation is vastly different from the WAM, and many of the differences (e.g. the absence of a trail) have significant impact on the implementation of tabling. In this paper, we describe how we adapted the copying approach to tabling to implement tabling in Mercury.", "paper_title": "Tabling in Mercury: Design and implementation", "paper_id": "WOS:000235801500011"}