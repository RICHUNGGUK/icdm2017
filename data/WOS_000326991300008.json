{"auto_keywords": [{"score": 0.0366645640625735, "phrase": "treerepair"}, {"score": 0.00481495049065317, "phrase": "xml_tree_structures"}, {"score": 0.004688321299229397, "phrase": "ordered_unranked_trees"}, {"score": 0.004544770921520536, "phrase": "xml_markup"}, {"score": 0.004386063799793622, "phrase": "dictionary-based_methods"}, {"score": 0.004308791766002289, "phrase": "minimal_directed_acyclic_graphs"}, {"score": 0.003977505904363489, "phrase": "minimal_slcf_tree_grammars"}, {"score": 0.0038728151007982378, "phrase": "minimal_dags"}, {"score": 0.003737485125097945, "phrase": "polynomial_time"}, {"score": 0.003574929398913029, "phrase": "new_linear_time_algorithm"}, {"score": 0.003527550673371394, "phrase": "small_slcf_tree_grammars"}, {"score": 0.0033442114331500407, "phrase": "best_known_previous_algorithm"}, {"score": 0.0032129675521135616, "phrase": "larsson_and_moffat's_repair_string_compression_algorithm"}, {"score": 0.0031845071795606034, "phrase": "slcf"}, {"score": 0.0030868583963299698, "phrase": "efficient_memory_representations"}, {"score": 0.0029133627624098064, "phrase": "smallest_queryable_memory_representation"}, {"score": 0.0027495914857929584, "phrase": "large_corpus"}, {"score": 0.0027252240573281163, "phrase": "commonly_used_xml_documents"}, {"score": 0.002689076130099546, "phrase": "tree_traversals"}, {"score": 0.0026652435674846095, "phrase": "treerepair_grammars"}, {"score": 0.00258347644721642, "phrase": "pointer_structures"}, {"score": 0.0025042115651986332, "phrase": "succinct_trees"}, {"score": 0.002470987929071079, "phrase": "memory_consumption"}, {"score": 0.002250415129116109, "phrase": "huffman-based_coding"}, {"score": 0.002200861826643147, "phrase": "compression_ratios"}, {"score": 0.0021620042653528846, "phrase": "best_known_xml_file_compressors"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["XML", " Tree structure compression", " Memory representation"], "paper_abstract": "XML tree structures can conveniently be represented using ordered unranked trees. Due to the repetitiveness of XML markup these trees can be compressed effectively using dictionary-based methods, such as minimal directed acyclic graphs (DAGs) or straight-line context-free (SLCF) tree grammars. While minimal SLCF tree grammars are in general smaller than minimal DAGs, they cannot be computed in polynomial time unless P = NP. Here, we present a new linear time algorithm for computing small SLCF tree grammars, called TreeRePair, and show that it greatly outperforms the best known previous algorithm BPLEX. TreeRePair is a generalization to trees of Larsson and Moffat's RePair string compression algorithm. SLCF tree grammars can be used as efficient memory representations of trees. Using TreeRePair, we are able to produce the smallest queryable memory representation of ordered trees that we are aware of. Our investigations over a large corpus of commonly used XML documents show that tree traversals over TreeRePair grammars are 14 times slower than over pointer structures and 5 times slower than over succinct trees, while memory consumption is only 1/43 and 1/6, respectively. With respect to file compression we are able to show that a Huffman-based coding of TreeRePair grammars gives compression ratios comparable to the best known XML file compressors. (C) 2013 Elsevier Ltd. All rights reserved.", "paper_title": "XML tree structure compression using RePair", "paper_id": "WOS:000326991300008"}