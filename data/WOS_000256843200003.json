{"auto_keywords": [{"score": 0.048799520930917564, "phrase": "source_code"}, {"score": 0.00481495049065317, "phrase": "state_transitions"}, {"score": 0.004623224002010226, "phrase": "finite-state_machine_specifications"}, {"score": 0.0043793594257092805, "phrase": "rigorous_state-based_testing_techniques"}, {"score": 0.004204904449336037, "phrase": "program_behaviour"}, {"score": 0.003983016985197904, "phrase": "software_development"}, {"score": 0.0031629800646754505, "phrase": "symbolic_execution"}, {"score": 0.0030992666061123533, "phrase": "-engineer_state_transitions"}, {"score": 0.002975652654536407, "phrase": "particularly_novel_aspect"}, {"score": 0.0027429789393362703, "phrase": "state_transition"}, {"score": 0.0022074592164608134, "phrase": "real_software_systems"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["symbolic execution", " finite-state machines", " reverse engineering", " model checking"], "paper_abstract": "Finite-state machine specifications form the basis for a number of rigorous state-based testing techniques and can help to understand program behaviour. Unfortunately they are rarely maintained during software development, which means that these benefits can rarely be fully exploited. This paper describes a technique that, given a set of states that are of interest to a developer, uses symbolic execution to reverse-engineer state transitions from source code. A particularly novel aspect of our approach is that, besides determining whether or not a state transition can take place, it also identifies the paths through the source code that govern a transition. The technique has been implemented as a prototype, enabling its preliminary evaluation with respect to real software systems. Copyright (c) 2007 John Wiley & Sons, Ltd.", "paper_title": "Automated discovery of state transitions and their functions in source code", "paper_id": "WOS:000256843200003"}