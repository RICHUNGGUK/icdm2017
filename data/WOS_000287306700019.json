{"auto_keywords": [{"score": 0.043510309299986456, "phrase": "residual_program"}, {"score": 0.023732918863615077, "phrase": "meta_computation"}, {"score": 0.008462635593691275, "phrase": "type-reflective_metaprogramming"}, {"score": 0.00481495049065317, "phrase": "type-reflective_metaprograms"}, {"score": 0.004774746932947534, "phrase": "garcia"}, {"score": 0.0038711548651825917, "phrase": "type_system"}, {"score": 0.003245270848972794, "phrase": "metaml_guarantee"}, {"score": 0.002909482525367989, "phrase": "code_fragments"}, {"score": 0.002766415324343602, "phrase": "incremental_type_system"}, {"score": 0.0026975346834867313, "phrase": "gradual_type_system"}, {"score": 0.00267495669519805, "phrase": "siek"}, {"score": 0.0026525675737188417, "phrase": "taha"}, {"score": 0.002586513876943306, "phrase": "type_variables"}, {"score": 0.0025541050375256992, "phrase": "type_expressions"}, {"score": 0.0024284701569889113, "phrase": "existential_types"}, {"score": 0.0023980368333253147, "phrase": "residual_code_fragments"}, {"score": 0.002367983991444061, "phrase": "type_error"}, {"score": 0.002338306897057454, "phrase": "code_fragment"}, {"score": 0.002289667393538803, "phrase": "run-time_error"}, {"score": 0.002204646157481869, "phrase": "incremental_type_checker"}, {"score": 0.0021049977753042253, "phrase": "well-typed_metaprogram"}], "paper_keywords": ["Languages", " metaprogramming", " type systems", " type reflection", " gradual typing"], "paper_abstract": "Garcia introduces a calculus for type-reflective metaprogramming that provides much of the power and flexibility of C++ templates and solves many of its problems. However, one of the problems that remains is that the residual program is not type checked until after meta computation is complete. Ideally, one would like the type system of the metaprogram to also guarantee that the residual program will type check, as is the case in MetaML. However, in a language with type-reflective metaprogramming, type expressions in the residual program may be the result of meta computation, making the MetaML guarantee next to impossible to achieve. In this paper we offer an approach to detecting errors earlier without sacrificing flexibility: we incrementally type check code fragments as they are created and spliced together during meta computation. The incremental type system is a variant of the gradual type system of Siek and Taha, in which we use type variables to represent type expressions that are not yet normalized and a new dynamic variation on existential types to represent residual code fragments. A type error in a code fragment is treated as a run-time error of the meta computation. We show that the incremental type checker can be implemented efficiently and we prove that if a well-typed metaprogram generates a residual program, then the residual program is also well-typed.", "paper_title": "Incremental Type-Checking for Type-Reflective Metaprograms", "paper_id": "WOS:000287306700019"}