{"auto_keywords": [{"score": 0.04832350902760217, "phrase": "efficient_processing"}, {"score": 0.00481495049065317, "phrase": "extreme_moving-object_update"}, {"score": 0.004703878334423852, "phrase": "main_memory"}, {"score": 0.00453144352814823, "phrase": "moving-object_updates"}, {"score": 0.004324723240308028, "phrase": "conflicting_needs"}, {"score": 0.004205226397573506, "phrase": "query-efficient_data_structures"}, {"score": 0.004146716743362567, "phrase": "increasing_parallel_capabilities"}, {"score": 0.004108161406159407, "phrase": "multi-core_processors"}, {"score": 0.003994624397219346, "phrase": "concurrency_anomalies"}, {"score": 0.003920674807745575, "phrase": "correct_system_behavior"}, {"score": 0.003604421041893448, "phrase": "key_concern"}, {"score": 0.0034398445347109396, "phrase": "processing_cores"}, {"score": 0.0032827577713351336, "phrase": "concurrency_degrees"}, {"score": 0.0032522091171602557, "phrase": "traditional_transaction_processing"}, {"score": 0.0031328221096543823, "phrase": "new_semantics"}, {"score": 0.0030747771905143273, "phrase": "high_degree"}, {"score": 0.003003726508522467, "phrase": "up-to-date_query_results"}, {"score": 0.0028664985822266344, "phrase": "-nearest_neighbor_queries"}, {"score": 0.0027741761880779535, "phrase": "main-memory_indexing_technique"}, {"score": 0.002684819249720834, "phrase": "proposed_semantics"}, {"score": 0.0026105159490849364, "phrase": "different_semantics"}, {"score": 0.0024912073108138613, "phrase": "different_degrees"}, {"score": 0.0023662411481713704, "phrase": "alternative_time-partitioning_approach"}, {"score": 0.002226592967032469, "phrase": "modern_processors"}, {"score": 0.0021049977753042253, "phrase": "hardware_threads"}], "paper_keywords": ["Spatio-temporal indexing", " Concurrency", " Thread-level parallelism"], "paper_abstract": "The efficient processing of workloads that interleave moving-object updates and queries is challenging. In addition to the conflicting needs for update-efficient versus query-efficient data structures, the increasing parallel capabilities of multi-core processors yield challenges. To prevent concurrency anomalies and to ensure correct system behavior, conflicting update and query operations must be serialized. In this setting, it is a key concern to avoid that operations are blocked, which leaves processing cores idle. To enable efficient processing, we first examine concurrency degrees from traditional transaction processing in the context of our target domain and propose new semantics that enable a high degree of parallelism and ensure up-to-date query results. We define the new semantics for range and -nearest neighbor queries. Then, we present a main-memory indexing technique called parallel grid that implements the proposed semantics as well as two other variants supporting different semantics. This enables us to quantify the effects that different degrees of consistency have on performance. We also present an alternative time-partitioning approach. Empirical studies with the above and three existing proposals conducted on modern processors show that our proposals scale near-linearly with the number of hardware threads and thus are able to benefit from increasing on-chip parallelism.", "paper_title": "Processing of extreme moving-object update and query workloads in main memory", "paper_id": "WOS:000342339400007"}