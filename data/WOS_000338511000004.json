{"auto_keywords": [{"score": 0.033909870203194574, "phrase": "small-value_loads"}, {"score": 0.00481495049065317, "phrase": "small-value_memory_instructions"}, {"score": 0.004620093797504386, "phrase": "small-value_locality"}, {"score": 0.004396600680348434, "phrase": "memory_instructions"}, {"score": 0.0039813976794342, "phrase": "small-value_operands"}, {"score": 0.0034306925765832633, "phrase": "media_domains"}, {"score": 0.003264547032549398, "phrase": "relative_occurrences"}, {"score": 0.0030554300179552415, "phrase": "program_execution"}, {"score": 0.0026543514413663893, "phrase": "input_data"}, {"score": 0.0024842242921857705, "phrase": "small-value_caches"}, {"score": 0.002344311033783139, "phrase": "small-value_memory_words"}, {"score": 0.0022122603123901114, "phrase": "significant_speedup"}, {"score": 0.0021401625519713577, "phrase": "overall_energy_dissipation"}, {"score": 0.0021049977753042253, "phrase": "negligible_chip-area_overhead"}], "paper_keywords": ["Small-value locality", " small-value load", " small-value cache (SVC)", " silent store"], "paper_abstract": "This paper exploits small-value locality to accelerate the execution of memory instructions. We find that small-value loads-loads with small-value operands of 8 bits or less-are common across 52 applications from the desktop, embedded, and media domains. We show that the relative occurrences of small-value loads remain fairly stable during the program execution. Moreover, we establish that the frequency of small-value loads are almost independent of compiler and input data. We then introduce the concept of small-value caches (SVC) to compactly store small-value memory words. We show that SVCs provide significant speedup and reduce the overall energy dissipation with negligible chip-area overhead.", "paper_title": "Characterizing and Exploiting Small-Value Memory Instructions", "paper_id": "WOS:000338511000004"}