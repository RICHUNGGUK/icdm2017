{"auto_keywords": [{"score": 0.030533325982598135, "phrase": "amac"}, {"score": 0.015719716506582538, "phrase": "asynchronous_memory_access_chaining"}, {"score": 0.011785646805776167, "phrase": "inter-lookup_parallelism"}, {"score": 0.00469079145638866, "phrase": "pointer-intensive_data_structures"}, {"score": 0.004554917803750564, "phrase": "single_lookup_operation"}, {"score": 0.004379828513102091, "phrase": "dependent_pointer_dereferences"}, {"score": 0.004322967486451877, "phrase": "memory_latency"}, {"score": 0.004280804599325052, "phrase": "additional_memory_accesses"}, {"score": 0.004211441113293312, "phrase": "effective_way"}, {"score": 0.004143196873246147, "phrase": "pointer-chasing_codes"}, {"score": 0.0037932682371685433, "phrase": "order_cores"}, {"score": 0.00374399358035391, "phrase": "limited_size"}, {"score": 0.0036712747276274617, "phrase": "recent_work"}, {"score": 0.003635444740897197, "phrase": "software_prefetching_techniques"}, {"score": 0.0035300318844877286, "phrase": "independent_lookups"}, {"score": 0.0033831234599419435, "phrase": "synchronized_fashion"}, {"score": 0.003295763459241421, "phrase": "highly_regular_access_patterns"}, {"score": 0.0031379788088249576, "phrase": "variable-length_pointer_chains"}, {"score": 0.0029682413050825677, "phrase": "new_approach"}, {"score": 0.002901039092967117, "phrase": "memory_access_latency"}, {"score": 0.0028633212043378564, "phrase": "high_dynamism"}, {"score": 0.0026212045623658932, "phrase": "new_lookup"}, {"score": 0.00247935055073462, "phrase": "static_arrangement"}, {"score": 0.0023451553255837317, "phrase": "amac_matches"}, {"score": 0.0023222375006409675, "phrase": "state-of-the-art_prefetching_techniques"}, {"score": 0.002232779081720735, "phrase": "irregular_data_structure_lookups"}, {"score": 0.002189347748410919, "phrase": "available_microarchitectural_resources"}, {"score": 0.002160862869106241, "phrase": "maximum_number"}, {"score": 0.0021467594103960585, "phrase": "memory_accesses"}, {"score": 0.0021049977753042253, "phrase": "single-and_multi-threaded_execution_modes"}], "paper_keywords": [""], "paper_abstract": "In-memory databases rely on pointer-intensive data structures to quickly locate data in memory. A single lookup operation in such data structures often exhibits long-latency memory stalls due to dependent pointer dereferences. Hiding the memory latency by launching additional memory accesses for other lookups is an effective way of improving performance of pointer-chasing codes (e.g., hash table probes, tree traversals). The ability to exploit such inter-lookup parallelism is beyond the reach of modern out-of-order cores due to the limited size of their instruction window. Instead, recent work has proposed software prefetching techniques that exploit inter-lookup parallelism by arranging a set of independent lookups into a group or a pipeline, and navigate their respective pointer chains in a synchronized fashion. While these techniques work well for highly regular access patterns, they break down in the face of irregularity across lookups. Such irregularity includes variable-length pointer chains, early exit, and read/write dependencies. This work introduces Asynchronous Memory Access Chaining (AMAC), a new approach for exploiting inter-lookup parallelism to hide the memory access latency. AMAC achieves high dynamism in dealing with irregularity across lookups by maintaining the state of each lookup separately from that of other lookups. This feature enables AMAC to initiate a new lookup as soon as any of the in-flight lookups complete. In contrast, the static arrangement of lookups into a group or pipeline in existing techniques precludes such adaptivity. Our results show that AMAC matches or outperforms state-of-the-art prefetching techniques on regular access patterns, while delivering up to 2.3x higher performance under irregular data structure lookups. AMAC fully utilizes the available microarchitectural resources, generating the maximum number of memory accesses allowed by hardware in both single-and multi-threaded execution modes.", "paper_title": "Asynchronous Memory Access Chaining", "paper_id": "WOS:000386426200003"}