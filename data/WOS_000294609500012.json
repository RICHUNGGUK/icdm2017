{"auto_keywords": [{"score": 0.04483027936171083, "phrase": "domain-specific_languages"}, {"score": 0.00481495049065317, "phrase": "language_design_benefits"}, {"score": 0.004601045179623499, "phrase": "host_language"}, {"score": 0.0045443671106012405, "phrase": "c's_string-based_macros"}, {"score": 0.0044514440242754815, "phrase": "notational_shorthands"}, {"score": 0.004396600680348434, "phrase": "parser-level_macros"}, {"score": 0.004236074477264561, "phrase": "scheme_programming_language"}, {"score": 0.004183883358848203, "phrase": "lisp"}, {"score": 0.004098291340525772, "phrase": "lexical_scope"}, {"score": 0.004014452814186653, "phrase": "racket-a_descendant"}, {"score": 0.003820144626025562, "phrase": "full-fledged_interface"}, {"score": 0.003773049633656302, "phrase": "static_semantics"}, {"score": 0.003680587852807675, "phrase": "racket_extension_programmer"}, {"score": 0.0035461111918923117, "phrase": "\"native\"_notation"}, {"score": 0.0033465923623290034, "phrase": "compiler_backend"}, {"score": 0.0032510690712452147, "phrase": "language_design"}, {"score": 0.0030808211830129304, "phrase": "first-class_classes"}, {"score": 0.003030247482854539, "phrase": "numerous_languages"}, {"score": 0.0029805015010906013, "phrase": "racket_system"}, {"score": 0.0028953973490895746, "phrase": "complete_and_fully_integrated_typed_sister_language"}, {"score": 0.002871533406049498, "phrase": "racket"}, {"score": 0.0027665315772006575, "phrase": "racket's_language_extension_api"}, {"score": 0.0026986685585382347, "phrase": "small_typed_sister_language"}, {"score": 0.002665362204725326, "phrase": "new_language"}, {"score": 0.0026324658253309673, "phrase": "rich_type_system"}, {"score": 0.0025678829712650437, "phrase": "untyped_racket"}, {"score": 0.002494531100339247, "phrase": "typed_language"}, {"score": 0.0024333239726872604, "phrase": "untyped_modules"}, {"score": 0.0023249757987087055, "phrase": "type-based_optimizer"}, {"score": 0.0022962708568492734, "phrase": "promising_speedups"}, {"score": 0.0021049977753042253, "phrase": "racket_implementation"}], "paper_keywords": ["Languages", " Design"], "paper_abstract": "Programming language design benefits from constructs for extending the syntax and semantics of a host language. While C's string-based macros empower programmers to introduce notational shorthands, the parser-level macros of Lisp encourage experimentation with domain-specific languages. The Scheme programming language improves on Lisp with macros that respect lexical scope. The design of Racket-a descendant of Scheme-goes even further with the introduction of a full-fledged interface to the static semantics of the language. A Racket extension programmer can thus add constructs that are indistinguishable from \"native\" notation, large and complex embedded domain-specific languages, and even optimizing transformations for the compiler backend. This power to experiment with language design has been used to create a series of sub-languages for programming with first-class classes and modules, numerous languages for implementing the Racket system, and the creation of a complete and fully integrated typed sister language to Racket's untyped base language. This paper explains Racket's language extension API via an implementation of a small typed sister language. The new language provides a rich type system that accommodates the idioms of untyped Racket. Furthermore, modules in this typed language can safely exchange values with untyped modules. Last but not least, the implementation includes a type-based optimizer that achieves promising speedups. Although these extensions are complex, their Racket implementation is just a library, like any other library, requiring no changes to the Racket implementation.", "paper_title": "Languages as Libraries", "paper_id": "WOS:000294609500012"}