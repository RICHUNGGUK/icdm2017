{"auto_keywords": [{"score": 0.03567043071500334, "phrase": "equivalence_representations"}, {"score": 0.00481495049065317, "phrase": "linear_time"}, {"score": 0.004118587636081584, "phrase": "structural_recursion"}, {"score": 0.003995876175614403, "phrase": "equivalence_relations"}, {"score": 0.0038964032225585117, "phrase": "asymptotic_performance"}, {"score": 0.0038573081851680656, "phrase": "generic_comparison-based_sorting"}, {"score": 0.003594369823549604, "phrase": "underlying_ordering"}, {"score": 0.003452218803245602, "phrase": "large_class"}, {"score": 0.0033156708990372047, "phrase": "standard_orders"}, {"score": 0.003282383509542342, "phrase": "regular_recursive_first-order_types"}, {"score": 0.0031684791285366315, "phrase": "worst-case_linear_time"}, {"score": 0.003012560489169148, "phrase": "list_comprehensions"}, {"score": 0.0028933521924166287, "phrase": "generalized_algebraic_data_types"}, {"score": 0.0026959452932289797, "phrase": "most-significant_digit"}, {"score": 0.0025892330566358503, "phrase": "associative-commutative_operator"}, {"score": 0.0025503112711036994, "phrase": "database_joins"}, {"score": 0.002524688179363081, "phrase": "source_code"}, {"score": 0.0024493786060528276, "phrase": "haskell"}, {"score": 0.0023642842046859274, "phrase": "built-in_primitive_types"}, {"score": 0.0022365262201954643, "phrase": "efficient_discriminators"}, {"score": 0.0021049977753042253, "phrase": "abstract_types"}], "paper_keywords": [""], "paper_abstract": "We introduce the notion of discrimination as a generalization of both sorting and partitioning, and show that discriminators (discrimination functions) can be defined generically, by structural recursion on representations of ordering and equivalence relations. Discriminators improve the asymptotic performance of generic comparison-based sorting and partitioning, and can be implemented not to expose more information than the underlying ordering, respectively equivalence relation. For a large class of order and equivalence representations, including all standard orders for regular recursive first-order types, the discriminators execute in the worst-case linear time. The generic discriminators can be coded compactly using list comprehensions, with order and equivalence representations specified using Generalized Algebraic Data Types. We give some examples of the uses of discriminators, including the most-significant digit lexicographic sorting, type isomorphism with an associative-commutative operator, and database joins. Source code of discriminators and their applications in Haskell is included. We argue that built-in primitive types, notably pointers (references), should come with efficient discriminators, not just equality tests, since they facilitate the construction of discriminators for abstract types that are both highly efficient and representation-independent.", "paper_title": "Generic top-down discrimination for sorting and partitioning in linear time", "paper_id": "WOS:000306533300004"}