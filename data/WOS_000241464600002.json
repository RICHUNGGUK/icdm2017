{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "task-level_parallelism"}, {"score": 0.0153463762989802, "phrase": "data-level_parallelism"}, {"score": 0.014625693390165716, "phrase": "embedded_systems"}, {"score": 0.010639052319622646, "phrase": "data-level_parallel_hardware"}, {"score": 0.004586531354697466, "phrase": "energy_efficiency"}, {"score": 0.0043477114072437316, "phrase": "higher_instruction-level"}, {"score": 0.004222707054751191, "phrase": "individual_applications"}, {"score": 0.004141365648080381, "phrase": "sufficient_parallelism"}, {"score": 0.003925633992809873, "phrase": "multiple_tasks"}, {"score": 0.0035616743422949766, "phrase": "high-performance_systems"}, {"score": 0.003376037544631762, "phrase": "tight_energy_budgets"}, {"score": 0.0031383410838018984, "phrase": "available_information"}, {"score": 0.0026466064623118105, "phrase": "simultaneous_compilation"}, {"score": 0.0026209522797963447, "phrase": "multiple_threads"}, {"score": 0.0025207920578878894, "phrase": "run-time_selection"}, {"score": 0.0022536005664642294, "phrase": "different_ilp"}, {"score": 0.002231747358665628, "phrase": "dlp_architectures"}, {"score": 0.0021464286727045623, "phrase": "sw-smt_increase"}, {"score": 0.002125612498781805, "phrase": "simd_datapath_size"}, {"score": 0.0021049977753042253, "phrase": "vliw_issue"}], "paper_keywords": [""], "paper_abstract": "The search for energy efficiency in the design of embedded systems is leading toward CPUs with higher instruction-level and data-level parallelism. Unfortunately, individual applications do not have sufficient parallelism to keep all these CPU resources busy. Since embedded systems often consist of multiple tasks, task-level parallelism can be used for the purpose. Simultaneous multi-threading (SMT) proved a valuable technique to do so in high-performance systems, but it cannot be afforded in system with tight energy budgets. Moreover, it does not exploit data-level parallel hardware, and does not exploit the available information on threads. We propose software-SMT (SW-SMT), a technique to exploit task-level parallelism to improve the utilization of both instruction-level and data-level parallel hardware, thereby improving performance. The technique performs simultaneous compilation of multiple threads at design-time, and it includes a run-time selection of the most efficient mixes. We have applied the technique to two major blocks of a SDR (software-defined radio) application, achieving energy gains up to 46% on different ILP and DLP architectures. We show that the potentials of SW-SMT increase with SIMD datapath size and VLIW issue width.", "paper_title": "Software simultaneous multi-threading, a technique to exploit task-level parallelism to improve instruction- and data-level parallelism", "paper_id": "WOS:000241464600002"}