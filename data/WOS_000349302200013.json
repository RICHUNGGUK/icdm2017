{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "interactive_trace-based_analysis_toolset"}, {"score": 0.004763895422211728, "phrase": "manual_parallelization"}, {"score": 0.004713379149462482, "phrase": "c_programs"}, {"score": 0.004663396040465122, "phrase": "massive_amounts"}, {"score": 0.00439777299939725, "phrase": "better_use"}, {"score": 0.0043511221096418475, "phrase": "modern_multiprocessor_architectures"}, {"score": 0.004236639288852276, "phrase": "parallel_programs"}, {"score": 0.004147216579100177, "phrase": "difficult_task"}, {"score": 0.004103212598803194, "phrase": "automated_parallelization_methods"}, {"score": 0.003952828685048176, "phrase": "statement_and_loop_levels"}, {"score": 0.0038079353103469865, "phrase": "task_level"}, {"score": 0.0035527409334589317, "phrase": "application_domains"}, {"score": 0.003404244237372396, "phrase": "innovative_toolset"}, {"score": 0.0032969458013463807, "phrase": "manual_code_analysis"}, {"score": 0.003108911488613549, "phrase": "program_profile"}, {"score": 0.0030758904011907533, "phrase": "data_dependencies"}, {"score": 0.0030270132320276096, "phrase": "interactive_graphical_format"}, {"score": 0.002900426826591769, "phrase": "manual_parallelization_opportunities"}, {"score": 0.0027791193706247267, "phrase": "arbitrary_sequential_c_programs"}, {"score": 0.002537880772794665, "phrase": "static_code_analysis"}, {"score": 0.002220551141101661, "phrase": "parallelization_decisions"}, {"score": 0.0021276181317652163, "phrase": "significant_improvement"}], "paper_keywords": ["Legacy C program parallelization", " source annotation", " execution profiling", " data dependency analysis", " graph analysis", " graph abstraction"], "paper_abstract": "Massive amounts of legacy sequential code need to be parallelized to make better use of modern multiprocessor architectures. Nevertheless, writing parallel programs is still a difficult task. Automated parallelization methods can be effective both at the statement and loop levels and, recently, at the task level, but they are still restricted to specific source code constructs or application domains. We present in this article an innovative toolset that supports developers when performing manual code analysis and parallelization decisions. It automatically collects and represents the program profile and data dependencies in an interactive graphical format that facilitates the analysis and discovery of manual parallelization opportunities. The toolset can be used for arbitrary sequential C programs and parallelization patterns. Also, its program-scope data dependency tracing at runtime can complement the tools based on static code analysis and can also benefit from it at the same time. We also tested the effectiveness of the toolset in terms of time to reach parallelization decisions and of their quality. We measured a significant improvement for several real-world representative applications.", "paper_title": "Interactive Trace-Based Analysis Toolset for Manual Parallelization of C Programs", "paper_id": "WOS:000349302200013"}