{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "object_layout"}, {"score": 0.03984476613651677, "phrase": "multiple_inheritance"}, {"score": 0.003737934295442975, "phrase": "c_compatibility"}, {"score": 0.0036826452656927877, "phrase": "separate_compilation"}, {"score": 0.003293142761521425, "phrase": "operational_semantics"}, {"score": 0.0031963987773420068, "phrase": "wasserrab_et_al"}, {"score": 0.00296675450822924, "phrase": "space-saving_techniques"}, {"score": 0.002901124599876666, "phrase": "empty_base_class_optimization"}, {"score": 0.0028581775908203683, "phrase": "tail-padding_optimization"}, {"score": 0.0026726283357752585, "phrase": "first_formal_correctness_proofs"}, {"score": 0.0023021895404322767, "phrase": "new_layout_optimizations"}, {"score": 0.0022013916728990564, "phrase": "first_step"}], "paper_keywords": ["Languages", " Verification"], "paper_abstract": "Object layout - the concrete in-memory representation of objects - raises many delicate issues in the case of the C++ language, owing in particular to multiple inheritance, C compatibility and separate compilation. This paper formalizes a family of C++ object layout schemes and mechanically proves their correctness against the operational semantics for multiple inheritance of Wasserrab et al. This formalization is flexible enough to account for space-saving techniques such as empty base class optimization and tail-padding optimization. As an application, we obtain the first formal correctness proofs for realistic, optimized object layout algorithms, including one based on the popular \"common vendor\" Itanium C++ application binary interface. This work provides semantic foundations to discover and justify new layout optimizations; it is also a first step towards the verification of a C++ compiler front-end.", "paper_title": "Formal Verification of Object Layout for C plus plus Multiple Inheritance", "paper_id": "WOS:000286472700007"}