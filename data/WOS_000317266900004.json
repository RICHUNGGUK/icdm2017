{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "synchronizable_places"}, {"score": 0.0453665111651286, "phrase": "weak_termination"}, {"score": 0.0316727896939775, "phrase": "multi-workflow_net"}, {"score": 0.004775335634705251, "phrase": "multi-workflow_nets"}, {"score": 0.004658426838467567, "phrase": "well-known_strategy"}, {"score": 0.0045443671106012405, "phrase": "refinement_rules"}, {"score": 0.004488384083300084, "phrase": "essential_behavioral_properties"}, {"score": 0.004414806639101985, "phrase": "deadlock_freedom"}, {"score": 0.00428892403807229, "phrase": "well-known_example"}, {"score": 0.004236074477264561, "phrase": "refinement_rule"}, {"score": 0.0041666157975446564, "phrase": "safe_place"}, {"score": 0.004115267130977749, "phrase": "petri_net"}, {"score": 0.004064548693812535, "phrase": "sound_workflow_net"}, {"score": 0.003916098498242888, "phrase": "refined_place"}, {"score": 0.0037419747525425586, "phrase": "refining_workflow_net"}, {"score": 0.0036352070472201086, "phrase": "component-based_systems"}, {"score": 0.003473529187092258, "phrase": "refinement_iterations"}, {"score": 0.0034024277222012597, "phrase": "different_components_places"}, {"score": 0.0028596699752849682, "phrase": "behaviorally_correct_multi-workflow_nets"}, {"score": 0.0027665315772006575, "phrase": "weak_termination_requirement"}, {"score": 0.0026107601878587816, "phrase": "selected_places"}, {"score": 0.0025892330566358503, "phrase": "different_components"}, {"score": 0.002504880563070155, "phrase": "weak_termination_property"}, {"score": 0.0022122603123901114, "phrase": "refined_places"}], "paper_keywords": [""], "paper_abstract": "Stepwise refinement is a well-known strategy in system modeling. The refinement rules should preserve essential behavioral properties, such as deadlock freedom, boundedness and weak termination. A well-known example is the refinement rule that replaces a safe place of a Petri net with a sound workflow net. In this case a token on the refined place undergoes a procedure that is modeled in detail by the refining workflow net. We generalize this rule to component-based systems, where in the first, high-level, refinement iterations we often encounter in different components places that represent in fact the counterparts of the same procedure \"simultaneously\" executed by the components. The procedure involves communication between these components. We model such a procedure as a multi-workflow net, which is actually a composition of communicating workflows. Behaviorally correct multi-workflow nets have the weak termination property. The weak termination requirement is also applied to the system being refined. We want to refine selected places in different components with a multi-workflow net in such a way that the weak termination property is preserved through refinements. We introduce the notion of synchronizable places and show that weak termination is preserved under the refinement of places with multiworks if and only if the refined places are synchronizable. We give a method to decide if a given set of places is synchronizable.", "paper_title": "Refinement of Synchronizable Places with Multi-workflow Nets", "paper_id": "WOS:000317266900004"}