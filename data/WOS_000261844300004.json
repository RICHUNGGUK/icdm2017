{"auto_keywords": [{"score": 0.043817926168544324, "phrase": "procedure_returns"}, {"score": 0.033924790499089585, "phrase": "ras"}, {"score": 0.00481495049065317, "phrase": "branch_prediction"}, {"score": 0.004764859786310636, "phrase": "speculative_execution_processor_core"}, {"score": 0.004698878021540436, "phrase": "branch_mispredictions"}, {"score": 0.0046176782475198085, "phrase": "negative_effects"}, {"score": 0.004553725265085244, "phrase": "energy_consumption"}, {"score": 0.004459445258869177, "phrase": "highly_accurate_conditional_branch_predictors"}, {"score": 0.004144510906908392, "phrase": "modern_processors"}, {"score": 0.004044534825749132, "phrase": "return_address_stack"}, {"score": 0.00396075511616602, "phrase": "overwhelming_majority"}, {"score": 0.003919515745050147, "phrase": "return_mispredictions"}, {"score": 0.003798346343693706, "phrase": "top_entries"}, {"score": 0.0037196472104696157, "phrase": "mispredicted_path"}, {"score": 0.0036046342610557497, "phrase": "previously_proposed_speculative_return_address"}, {"score": 0.0035670895401691536, "phrase": "jourdan_et_al"}, {"score": 0.0035176353680157367, "phrase": "skadron"}, {"score": 0.0033969686698961713, "phrase": "remaining_misprediction_rate"}, {"score": 0.0033615796302502547, "phrase": "ras_designs"}, {"score": 0.003280427617955518, "phrase": "state-of-the-art_conditional_predictors"}, {"score": 0.002823050755743821, "phrase": "branch_target_buffer"}, {"score": 0.0027071661844502992, "phrase": "free_backup_predictor"}, {"score": 0.002506894277338543, "phrase": "previously_proposed_speculative_rass"}, {"score": 0.00244632460902489, "phrase": "specific_management"}, {"score": 0.002420815160284086, "phrase": "speculative_states"}], "paper_keywords": ["Algorithms", " Experimentation", " Performance", " Return address prediction", " corruption detection", " back-up predictor"], "paper_abstract": "Branch prediction feeds a speculative execution processor core with instructions. Branch mispredictions are inevitable and have negative effects on performance and energy consumption. With the advent of highly accurate conditional branch predictors, nonconditional branch instructions are gaining importance. In this article, we address the prediction of procedure returns. On modern processors, procedure returns are predicted through a return address stack (RAS). The overwhelming majority of the return mispredictions are due to RAS overflows and/or overwriting the top entries of the RAS on a mispredicted path. These sources of misprediction were addressed by previously proposed speculative return address stacks [Jourdan et al. 1996; Skadron et al. 1998]. However, the remaining misprediction rate of these RAS designs is still significant when compared to state-of-the-art conditional predictors. We present two low-cost corruption detectors for RAS predictors. They detect RAS overflows and wrong path corruption with 100% coverage. As a consequence, when such a corruption is detected, another source can be used for predicting the return. On processors featuring a branch target buffer (BTB), this BTB can be used as a free backup predictor for predicting returns when corruption is detected. Our experiments show that our proposal can be used to improve the behavior of all previously proposed speculative RASs. For instance, without any specific management of the speculative states on the RAS, an 8-entry BTB-backed up RAS achieves the same performance level as a state-of-the-art, but complex, 64-entry self-checkpointing RAS [Jourdan et al. 1996]. Therefore, our proposal can be used either to improve the performance of the processor or to reduce its hardware complexity.", "paper_title": "Speculative Return Address Stack Management Revisited", "paper_id": "WOS:000261844300004"}