{"auto_keywords": [{"score": 0.04969466339476691, "phrase": "executable_programs"}, {"score": 0.044605401042099674, "phrase": "formal_model"}, {"score": 0.044090548582325764, "phrase": "memory_accesses"}, {"score": 0.00481495049065317, "phrase": "memory_access_patterns"}, {"score": 0.00464343008299973, "phrase": "binary_analysis"}, {"score": 0.004131063310728304, "phrase": "control_flow_graph"}, {"score": 0.0040485975929323, "phrase": "well-known_techniques"}, {"score": 0.00363080961099728, "phrase": "complete_data-flow_analysis"}, {"score": 0.003473178781851477, "phrase": "static_single_assignment"}, {"score": 0.0033492947290751996, "phrase": "ssa_form"}, {"score": 0.0031020367403802773, "phrase": "loop_structures"}, {"score": 0.003040050100579337, "phrase": "loop_indices"}, {"score": 0.00301560261110296, "phrase": "trip_counts"}, {"score": 0.002907992115184249, "phrase": "whole_process"}, {"score": 0.0027929100418926725, "phrase": "linear_expressions"}, {"score": 0.0027704444816096484, "phrase": "loop_counters"}, {"score": 0.002682370021834353, "phrase": "quantitative_evaluation"}, {"score": 0.0025866199378466754, "phrase": "spec_benchmark_programs"}, {"score": 0.0025554669315362424, "phrase": "static_analysis"}, {"score": 0.002504374718975704, "phrase": "input_data"}, {"score": 0.0024247382451294255, "phrase": "lightweight_instrumentation_strategy"}, {"score": 0.002357131515622894, "phrase": "exact_trace"}, {"score": 0.002174155795026218, "phrase": "automatic_parallelization"}, {"score": 0.0021566565951738658, "phrase": "binary_code"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Memory accesses", " Binary analysis", " Decompilation", " Static single assignment", " Memory tracing", " Program skeletonization", " Automatic parallelization"], "paper_abstract": "This paper deals with the binary analysis of executable programs, with the goal of understanding how they access memory. It explains how to statically build a formal model of all memory accesses. Starting with a control flow graph of each procedure, well-known techniques are used to structure this graph into a hierarchy of loops in all cases. The paper shows that much more information can be extracted by performing a complete data-flow analysis over machine registers after the program has been put in static single assignment (SSA) form. By using the SSA form, registers used in addressing memory can be symbolically expressed in terms of other previously set registers. By including the loop structures in the analysis, loop indices and trip counts can also often be expressed symbolically. The whole process produces a formal model made of loops where memory accesses are linear expressions of loop counters and registers. The paper provides a quantitative evaluation of the results when applied to several dozens of SPEC benchmark programs. Because static analysis has no access to input data, the paper ends by describing a lightweight instrumentation strategy that collects at run time enough information to rebuild an exact trace. The section on applications also describes how the techniques developed in this paper can be used to perform automatic parallelization of binary code. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Recovering memory access patterns of executable programs", "paper_id": "WOS:000329887100010"}