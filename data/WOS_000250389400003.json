{"auto_keywords": [{"score": 0.04160367592541749, "phrase": "component_framework"}, {"score": 0.031551134265730016, "phrase": "framework_developers"}, {"score": 0.00481503701860275, "phrase": "api"}, {"score": 0.004710306419574744, "phrase": "diff-catchup"}, {"score": 0.0046079260641779755, "phrase": "reusable_component_frameworks"}, {"score": 0.004238682850598745, "phrase": "specific_requirements"}, {"score": 0.004201571673071299, "phrase": "desired_qualities"}, {"score": 0.004146510711518748, "phrase": "application's_stakeholders"}, {"score": 0.0038141000450978746, "phrase": "framework_functionality"}, {"score": 0.003142732162296465, "phrase": "client_applications"}, {"score": 0.0031151864044353245, "phrase": "newer_versions"}, {"score": 0.0029548937818509656, "phrase": "additional_work"}, {"score": 0.0028652153774536967, "phrase": "application_developers"}, {"score": 0.002646880721119838, "phrase": "api-evolution_problem"}, {"score": 0.0025892330566358503, "phrase": "reuse-based_software_development"}, {"score": 0.0025217065652145443, "phrase": "api_changes"}, {"score": 0.002488604965680912, "phrase": "reused_framework"}, {"score": 0.0024559368099486647, "phrase": "plausible_replacements"}, {"score": 0.0024236964502593254, "phrase": "\"obsolete\"_api"}, {"score": 0.0023918783117166326, "phrase": "working_examples"}, {"score": 0.0023604768913655463, "phrase": "framework_code_base"}, {"score": 0.0022687189700002254, "phrase": "diff-catchup_tool"}], "paper_keywords": ["software reuse", " API evolution", " model differencing", " software migration"], "paper_abstract": "Applications built on reusable component frameworks are subject to two independent, and potentially conflicting, evolution processes. The application evolves in response to the specific requirements and desired qualities of the application's stakeholders. On the other hand, the evolution of the component framework is driven by the need to improve the framework functionality and quality while maintaining its generality. Thus, changes to the component framework frequently change its API on which its client applications rely and, as a result, these applications break. To date, there has been some work aimed at supporting the migration of client applications to newer versions of their underlying frameworks, but it usually requires that the framework developers do additional work for that purpose or that the application developers use the same tools as the framework developers. In this paper, we discuss our approach to tackle the API-evolution problem in the context of reuse-based software development, which automatically recognizes the API changes of the reused framework and proposes plausible replacements to the \"obsolete\" API based on working examples of the framework code base. This approach has been implemented in the Diff-CatchUp tool. We report on two case studies that we have conducted to evaluate the effectiveness of our approach with its Diff-CatchUp prototype.", "paper_title": "API-evolution support with Diff-CatchUp", "paper_id": "WOS:000250389400003"}