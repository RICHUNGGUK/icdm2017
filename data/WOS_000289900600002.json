{"auto_keywords": [{"score": 0.030008161744448727, "phrase": "g-pea"}, {"score": 0.004318881178805575, "phrase": "algorithmic_design"}, {"score": 0.00428146713705618, "phrase": "genetic_programming"}, {"score": 0.004081385289516914, "phrase": "novel_approach"}, {"score": 0.003976203286249396, "phrase": "evolved_solution_trees"}, {"score": 0.0038737214010638745, "phrase": "list_search"}, {"score": 0.003806866174028117, "phrase": "iterative_algorithms"}, {"score": 0.0035662378173267647, "phrase": "correct_linear-time"}, {"score": 0.003535320700255283, "phrase": "far_more_efficient_logarithmic-time_algorithms"}, {"score": 0.0034441627435203804, "phrase": "darwinian_means"}, {"score": 0.0032123700725641283, "phrase": "gp."}, {"score": 0.0031568884810273226, "phrase": "all-too-familiar_conundrum"}, {"score": 0.003115908199991072, "phrase": "convoluted-and_usually_bloated-gp-evolved_trees"}, {"score": 0.002806595775343074, "phrase": "gp_post-evolutionary_analysis"}, {"score": 0.002663620639539737, "phrase": "functionality-based_similarity_score"}, {"score": 0.0025059724686541263, "phrase": "similar_semantic_tasks"}, {"score": 0.0023679315987170857, "phrase": "hard-to-read_gp_trees"}, {"score": 0.0022967713922705, "phrase": "important_parts"}, {"score": 0.00226693109377084, "phrase": "evolved_solutions"}, {"score": 0.0022277448907881306, "phrase": "crucial_step"}, {"score": 0.00212343307513777, "phrase": "code_simplification"}, {"score": 0.0021049977753042253, "phrase": "bloat_control"}], "paper_keywords": ["Genetic programming", " Search algorithms", " Post-evolutionary analysis", " Edit distance", " Reasoning", " Building blocks"], "paper_abstract": "This paper focuses on two issues, first perusing the idea of algorithmic design through genetic programming (GP), and, second, introducing a novel approach for analyzing and understanding the evolved solution trees. Considering the problem of list search, we evolve iterative algorithms for searching for a given key in an array of integers, showing that both correct linear-time and far more efficient logarithmic-time algorithms can be repeatedly designed by Darwinian means. Next, we turn to the (evolved) dish of spaghetti (code) served by GP. Faced with the all-too-familiar conundrum of understanding convoluted-and usually bloated-GP-evolved trees, we present a novel analysis approach, based on ideas borrowed from the field of bioinformatics. Our system, dubbed G-PEA (GP Post-Evolutionary Analysis), consists of two parts: (1) Defining a functionality-based similarity score between expressions, G-PEA uses this score to find subtrees that carry out similar semantic tasks; (2) Clustering similar sub-expressions from a number of independently evolved fit solutions, thus identifying important semantic building blocks ensconced within the hard-to-read GP trees. These blocks help identify the important parts of the evolved solutions and are a crucial step in understanding how they work. Other related GP aspects, such as code simplification, bloat control, and building-block preserving crossover, may be extended by applying the concepts we present.", "paper_title": "Have your spaghetti and eat it too: evolutionary algorithmics and post-evolutionary analysis", "paper_id": "WOS:000289900600002"}