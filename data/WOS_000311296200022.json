{"auto_keywords": [{"score": 0.046804789812858856, "phrase": "efficient_parallel_code"}, {"score": 0.00481495049065317, "phrase": "concurrent_graph_programs"}, {"score": 0.004743806810821005, "phrase": "new_application_areas"}, {"score": 0.00470862827326028, "phrase": "machine_learning"}, {"score": 0.004673709383305897, "phrase": "network_analysis_use"}, {"score": 0.00465634671242413, "phrase": "\"irregular\"_data_structures"}, {"score": 0.00443638953122199, "phrase": "problem_domains"}, {"score": 0.0039674831861175935, "phrase": "best_choice"}, {"score": 0.0037658881407605445, "phrase": "parallel_platform"}, {"score": 0.0036689507925299885, "phrase": "input_data"}, {"score": 0.0034824716857663114, "phrase": "application_programmer"}, {"score": 0.0034309482755326016, "phrase": "different_algorithms"}, {"score": 0.003256526411907174, "phrase": "best_variant"}, {"score": 0.003102488033561956, "phrase": "efficient_parallel_implementations"}, {"score": 0.0030794433253250476, "phrase": "high-level_specifications"}, {"score": 0.002933756577145939, "phrase": "first_step"}, {"score": 0.002901124599876666, "phrase": "ambitious_goal"}, {"score": 0.0028795712616923462, "phrase": "application_programmers"}, {"score": 0.002603758927691463, "phrase": "sophisticated_inference_techniques"}, {"score": 0.0025178072071268534, "phrase": "elixir"}, {"score": 0.002268088741853586, "phrase": "best_generated_variants"}, {"score": 0.0022261705957258506, "phrase": "handwritten_code"}, {"score": 0.0021049977753042253, "phrase": "handwritten_versions"}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Verification", " Synthesis", " Compiler Optimization", " Concurrency", " Parallelism", " Amorphous Data-parallelism", " Irregular Programs", " Optimistic Parallelization"], "paper_abstract": "Algorithms in new application areas like machine learning and network analysis use \"irregular\" data structures such as graphs, trees and sets. Writing efficient parallel code in these problem domains is very challenging because it requires the programmer to make many choices: a given problem can usually be solved by several algorithms, each algorithm may have many implementations, and the best choice of algorithm and implementation can depend not only on the characteristics of the parallel platform but also on properties of the input data such as the structure of the graph. One solution is to permit the application programmer to experiment with different algorithms and implementations without writing every variant from scratch. Auto-tuning to find the best variant is a more ambitious solution. These solutions require a system for automatically producing efficient parallel implementations from high-level specifications. Elixir, the system described in this paper, is the first step towards this ambitious goal. Application programmers write specifications that consist of an operator, which describes the computations to be performed, and a schedule for performing these computations. Elixir uses sophisticated inference techniques to produce efficient parallel code from such specifications. We used Elixir to automatically generate many parallel implementations for three irregular problems: breadth-first search, single source shortest path, and betweenness-centrality computation. Our experiments show that the best generated variants can be competitive with handwritten code for these problems from other research groups; for some inputs, they even outperform the handwritten versions.", "paper_title": "Elixir: A System for Synthesizing Concurrent Graph Programs", "paper_id": "WOS:000311296200022"}