{"auto_keywords": [{"score": 0.043999910135637234, "phrase": "arbitrary_version"}, {"score": 0.03399185419186568, "phrase": "data_structure"}, {"score": 0.02807075907922643, "phrase": "data_structures"}, {"score": 0.027487368651044765, "phrase": "stronger_property"}, {"score": 0.00481495049065317, "phrase": "confluently_persistent"}, {"score": 0.00477079124890959, "phrase": "efficient_version_control"}, {"score": 0.004698086429418318, "phrase": "data-structural_problem"}, {"score": 0.004654993966953098, "phrase": "version_control"}, {"score": 0.004612294931699583, "phrase": "hierarchical_directory_structure"}, {"score": 0.004091432545219401, "phrase": "confluently_persistent_trie"}, {"score": 0.004053881856507032, "phrase": "internal_nodes"}, {"score": 0.003943276844539606, "phrase": "edge_labels"}, {"score": 0.003919109076818856, "phrase": "path_names"}, {"score": 0.003765575242370161, "phrase": "new_child"}, {"score": 0.0037310040297385346, "phrase": "existing_node"}, {"score": 0.003674086624699676, "phrase": "existing_subtree"}, {"score": 0.0035848128208966403, "phrase": "n-node_degree-delta_trie"}, {"score": 0.0034549387883559, "phrase": "finger_movement"}, {"score": 0.003340011311961488, "phrase": "subtree_copy"}, {"score": 0.003179612431869043, "phrase": "locality-sensitive_version"}, {"score": 0.002726216258692662, "phrase": "deep_updates"}, {"score": 0.0025713631281616763, "phrase": "confluent_persistence"}, {"score": 0.002315831335278694, "phrase": "general_technique"}, {"score": 0.002301614895279686, "phrase": "global_rebuilding"}, {"score": 0.002287485527155396, "phrase": "fully_persistent_data_structures"}, {"score": 0.002144252482711611, "phrase": "best_previous_result"}, {"score": 0.0021310870821926917, "phrase": "fully_persistent_arrays"}, {"score": 0.0021049977753042253, "phrase": "first_efficient_fully_persistent_hash_table"}], "paper_keywords": [""], "paper_abstract": "We consider a data-structural problem motivated by version control of a hierarchical directory structure in a system like Subversion. The model is that directories and files can be moved and copied between two arbitrary versions in addition to being added or removed in an arbitrary version. Equivalently, we wish to maintain a confluently persistent trie (where internal nodes represent directories, leaves represent files, and edge labels represent path names), subject to copying a subtree between two arbitrary versions, adding a new child to an existing node, and deleting an existing subtree in an arbitrary version. Our first data structure represents an n-node degree-Delta trie with O(1) \"fingers\" in each version while supporting finger movement (navigation) and modifications near the fingers (including subtree copy) in O(lg Delta) time and space per operation. This data structure is essentially a locality-sensitive version of the standard practice-path copying-costing O(dlg Delta) time and space for modification of a node at depth d, which is expensive when performing many deep but nearby updates. Our second data structure supporting finger movement in O(lg Delta) time and no space, while modifications take O(lg n) time and space. This data structure is substantially faster for deep updates, i.e., unbalanced tries. Both of these data structures are functional, which is a stronger property than confluent persistence. Without this stronger property, we show how both data structures can be sped up to support movement in O(lg lg Delta), which is essentially optimal. Along the way, we present a general technique for global rebuilding of fully persistent data structures, which is nontrivial because amortization and persistence do not usually mix. In particular, this technique improves the best previous result for fully persistent arrays and obtains the first efficient fully persistent hash table.", "paper_title": "Confluently Persistent Tries for Efficient Version Control", "paper_id": "WOS:000276265300003"}