{"auto_keywords": [{"score": 0.04959124618297068, "phrase": "hash_table"}, {"score": 0.04660802533264657, "phrase": "truly_random_hash_function"}, {"score": 0.00481495049065317, "phrase": "cache-oblivious_hashing"}, {"score": 0.004346139434813299, "phrase": "standard_external_hash_table"}, {"score": 0.004316552692395911, "phrase": "block_size_b"}, {"score": 0.004243460284890507, "phrase": "particular_key"}, {"score": 0.004200197763119297, "phrase": "expected_average_t"}, {"score": 0.004073027900718392, "phrase": "disk_accesses"}, {"score": 0.004031495920060339, "phrase": "load_factor_alpha"}, {"score": 0.003528458369404996, "phrase": "cache-oblivious_hash_table"}, {"score": 0.003317883538640966, "phrase": "memory_hierarchy"}, {"score": 0.00325051332556486, "phrase": "hardware-specific_tuning"}, {"score": 0.0031845067058084583, "phrase": "autonomous_databases"}, {"score": 0.003025277245730244, "phrase": "hash_tables"}, {"score": 0.002246443296542436, "phrase": "memory_address"}, {"score": 0.0022234951091677085, "phrase": "b._note"}, {"score": 0.002170854875902186, "phrase": "real_machine"}, {"score": 0.0021049977753042253, "phrase": "cache-oblivious_model"}], "paper_keywords": ["Cache-oblivious algorithms", " Hashing"], "paper_abstract": "The hash table, especially its external memory version, is one of the most important index structures in large databases. Assuming a truly random hash function, it is known that in a standard external hash table with block size b, searching for a particular key only takes expected average t (q) =1+1/2 (Omega(b)) disk accesses for any load factor alpha bounded away from 1. However, such near-perfect performance is achieved only when b is known and the hash table is particularly tuned for working with such a blocking. In this paper we study if it is possible to build a cache-oblivious hash table that works well with any blocking. Such a hash table will automatically perform well across all levels of the memory hierarchy and does not need any hardware-specific tuning, an important feature in autonomous databases. We first show that linear probing, a classical collision resolution strategy for hash tables, can be easily made cache-oblivious but it only achieves t (q) =1+I similar to(alpha/b) even if a truly random hash function is used. Then we demonstrate that the block probing algorithm (Pagh et al. in SIAM Rev. 53(3):547-558, 2011) achieves t (q) =1+1/2 (Omega(b)), thus matching the cache-aware bound, if the following two conditions hold: (a) b is a power of 2; and (b) every block starts at a memory address divisible by b. Note that the two conditions hold on a real machine, although they are not stated in the cache-oblivious model. Interestingly, we also show that neither condition is dispensable: if either of them is removed, the best obtainable bound is t (q) =1+O(alpha/b), which is exactly what linear probing achieves.", "paper_title": "Cache-Oblivious Hashing", "paper_id": "WOS:000336426000004"}