{"auto_keywords": [{"score": 0.045171522171843934, "phrase": "session_types"}, {"score": 0.013335197465812163, "phrase": "session_type"}, {"score": 0.007462096455682802, "phrase": "expected_features"}, {"score": 0.00481495049065317, "phrase": "modular_session_types"}, {"score": 0.00477190623242136, "phrase": "objects._session_types"}, {"score": 0.0047292449487169345, "phrase": "communication_protocols"}, {"score": 0.004541918674719973, "phrase": "protocol_implementations"}, {"score": 0.004441059405327222, "phrase": "static_type_checking"}, {"score": 0.0043619799095455415, "phrase": "previous_work"}, {"score": 0.004284302478991387, "phrase": "distributed_object-oriented_languages"}, {"score": 0.004023120753104693, "phrase": "class_definition"}, {"score": 0.003933736547198066, "phrase": "possible_sequences"}, {"score": 0.0038985392250620483, "phrase": "method_calls"}, {"score": 0.003563370084662192, "phrase": "separately-callable_methods"}, {"score": 0.0034529760173586583, "phrase": "session-typed_communication_channels"}, {"score": 0.0032132782979796895, "phrase": "elegant_unification"}, {"score": 0.0031845067058084583, "phrase": "communication_channels"}, {"score": 0.0031277316566463978, "phrase": "distributed_object-oriented_programming"}, {"score": 0.0030171910207671205, "phrase": "non-uniform_objects"}, {"score": 0.0028844769395018595, "phrase": "available_methods"}, {"score": 0.0028076592725295646, "phrase": "operational_semantics"}, {"score": 0.00277001889871322, "phrase": "sound_type_system"}, {"score": 0.0026962411675196213, "phrase": "complete_type_checking_algorithm"}, {"score": 0.0026600905156986317, "phrase": "small_distributed_class-based_object-oriented_language"}, {"score": 0.002366361492754389, "phrase": "type-theoretic_specifications"}, {"score": 0.00216263228969761, "phrase": "object-oriented_programming"}, {"score": 0.0021049977753042253, "phrase": "local_state"}], "paper_keywords": ["typestate", " session types", " object-oriented calculus", " Non-uniform method availability"], "paper_abstract": "Session types allow communication protocols to be specified type-theoretically so that protocol implementations can be verified by static type checking. We extend previous work on session types for distributed object-oriented languages in three ways. (1) We attach a session type to a class definition, to specify the possible sequences of method calls. (2) We allow a session type (protocol) implementation to be modularized, i.e. partitioned into separately-callable methods. (3) We treat session-typed communication channels as objects, integrating their session types with the session types of classes. The result is an elegant unification of communication channels and their session types, distributed object-oriented programming, and a form of typestate supporting non-uniform objects, i.e. objects that dynamically change the set of available methods. We define syntax, operational semantics, a sound type system, and a sound and complete type checking algorithm for a small distributed class-based object-oriented language with structural subtyping. Static typing guarantees that both sequences of messages on channels, and sequences of method calls on objects, conform to type-theoretic specifications, thus ensuring type-safety. The language includes expected features of session types, such as delegation, and expected features of object-oriented programming, such as encapsulation of local state.", "paper_title": "MODULAR SESSION TYPES FOR OBJECTS", "paper_id": "WOS:000373922900012"}