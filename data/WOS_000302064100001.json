{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "subproblem_dominance"}, {"score": 0.0047468516620285525, "phrase": "constraint_programming"}, {"score": 0.004613516457919661, "phrase": "large_amounts"}, {"score": 0.0039723268236794935, "phrase": "different_partial_assignments"}, {"score": 0.0029441472095672397, "phrase": "current_subproblem"}, {"score": 0.0024630345285372958, "phrase": "arbitrary_constraint_problems"}, {"score": 0.0024281181691350085, "phrase": "constraint_projection"}, {"score": 0.002309754152767196, "phrase": "search_problems"}, {"score": 0.002212892265364764, "phrase": "constraint_programming_solver"}, {"score": 0.0021049977753042253, "phrase": "problems_orders"}], "paper_keywords": ["Caching", " Dominance", " Search"], "paper_abstract": "Many search problems contain large amounts of redundancy in the search. In this paper we examine how to automatically exploit subproblem dominance, which arises when different partial assignments lead to subproblems that dominate (or are dominated by) other subproblems. Subproblem dominance is exploited by caching subproblems that have already been explored by the search, using keys that characterise the subproblems, and failing the search when the current subproblem is dominated by a subproblem already in the cache. In this paper we show how we can automatically and efficiently define keys for arbitrary constraint problems using constraint projection. We show how, for search problems where subproblem dominance arises, a constraint programming solver with this capability can solve these problems orders of magnitude faster than solvers without caching. The system is fully automatic, i.e., subproblem dominance is detected and exploited without any effort from the problem modeller.", "paper_title": "Exploiting subproblem dominance in constraint programming", "paper_id": "WOS:000302064100001"}