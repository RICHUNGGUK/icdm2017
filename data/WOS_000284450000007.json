{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "np"}, {"score": 0.011840057588354403, "phrase": "deterministic_polynomial_time_algorithm"}, {"score": 0.004741167616693272, "phrase": "deterministic_algorithms"}, {"score": 0.00456159659731398, "phrase": "average-case_hardness"}, {"score": 0.00445712058827745, "phrase": "class_np"}, {"score": 0.0030994630902300133, "phrase": "language_l"}, {"score": 0.0025942468561537682, "phrase": "theoretic_terms"}, {"score": 0.0024385083712241988, "phrase": "monotone_code"}, {"score": 0.002205079358459154, "phrase": "deterministic_local_decoder"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Average-case hardness", " Hardness amplification", " Error-correcting codes", " NP", " P", " Monotone functions", " Expander graphs", " Noise sensitivity"], "paper_abstract": "We study the average-case hardness of the class NP against algorithms in P. We prove that there exists some constant mu > 0 such that if there is some language in NP for which no deterministic polynomial time algorithm can decide L correctly on a 1 - (logn)(-mu) fraction of inputs of length n, then there is a language L' in NP for which no deterministic polynomial time algorithm can decide L' correctly on a 3/4 + (log n)(-mu) fraction of inputs of length n. In coding theoretic terms, we give a construction of a monotone code that can be uniquely decoded up to error rate 1/4 by a deterministic local decoder. (C) 2010 Elsevier Inc. All rights reserved.", "paper_title": "Hardness amplification within NP against deterministic algorithms", "paper_id": "WOS:000284450000007"}