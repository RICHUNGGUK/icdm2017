{"auto_keywords": [{"score": 0.04759132288543124, "phrase": "general_purpose_applications"}, {"score": 0.04560873528240427, "phrase": "scratchpad_memory"}, {"score": 0.0366645640625735, "phrase": "cache_access"}, {"score": 0.03603920618897153, "phrase": "global_load_instructions"}, {"score": 0.00481495049065317, "phrase": "cache_bypassing"}, {"score": 0.004730158389701481, "phrase": "graphics_processing_units"}, {"score": 0.004327981760540394, "phrase": "on-chip_memory"}, {"score": 0.0040309035566691645, "phrase": "irregular_memory_accesses"}, {"score": 0.003959863717046575, "phrase": "gpu_vendors"}, {"score": 0.00378767277402891, "phrase": "recent_generations"}, {"score": 0.003374094774912924, "phrase": "highly_configurable_feature"}, {"score": 0.0033442114331500407, "phrase": "gpu_caches"}, {"score": 0.0032272929113113203, "phrase": "cache_performance"}, {"score": 0.0031006232333900055, "phrase": "efficient_compiler_framework"}, {"score": 0.0029263562233195423, "phrase": "configurable_cache"}, {"score": 0.002874726518572154, "phrase": "overall_performance"}, {"score": 0.0028492532869274743, "phrase": "general_purpose_gpu_applications"}, {"score": 0.0027010719929751, "phrase": "gpu_cache_utilization"}, {"score": 0.0026652435674846095, "phrase": "performance_metrics"}, {"score": 0.0026182085765020548, "phrase": "cache_reuses"}, {"score": 0.0025950024597986366, "phrase": "memory_traffic"}, {"score": 0.0025266078302900036, "phrase": "efficient_algorithms"}, {"score": 0.00233202607446404, "phrase": "unified_cache"}, {"score": 0.0023010815714140467, "phrase": "memory_design_space"}, {"score": 0.0022304616068189575, "phrase": "automatic_compiler_framework"}, {"score": 0.002200861826643147, "phrase": "parallel_thread_execution_instruction_set_architecture"}, {"score": 0.002123831297790248, "phrase": "experiments_evaluation"}], "paper_keywords": ["Cache bypassing", " compiler", " graphics processing unit (GPU)", " performance"], "paper_abstract": "Graphics processing units (GPUs) have become ubiquitous for general purpose applications due to their tremendous computing power. Initially, GPUs only employ scratchpad memory as on-chip memory. Though scratchpad memory benefits many applications, it is not ideal for those general purpose applications with irregular memory accesses. Hence, GPU vendors have introduced caches in conjunction with scratchpad memory in the recent generations of GPUs. The caches on GPUs are highly configurable. The programmer or compiler can explicitly control cache access or bypass for global load instructions. This highly configurable feature of GPU caches opens up the opportunities for optimizing the cache performance. In this paper, we propose an efficient compiler framework for cache bypassing on GPUs. Our objective is to efficiently utilize the configurable cache and improve the overall performance for general purpose GPU applications. In order to achieve this goal, we first characterize GPU cache utilization and develop performance metrics to estimate the cache reuses and memory traffic. Next, we present efficient algorithms that judiciously select global load instructions for cache access or bypass. Finally, we present techniques to explore the unified cache and shared memory design space. We integrate our techniques into an automatic compiler framework that leverages parallel thread execution instruction set architecture to enable cache bypassing for GPUs. Experiments evaluation on NVIDIA GTX680 using a variety of applications demonstrates that compared to cache-all and bypass-all solutions, our techniques improve the performance from 4.6% to 13.1% for 16 KB L1 cache.", "paper_title": "An Efficient Compiler Framework for Cache Bypassing on GPUs", "paper_id": "WOS:000361683200012"}