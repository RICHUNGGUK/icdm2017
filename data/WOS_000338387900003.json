{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "component_repositories"}, {"score": 0.004739056045644449, "phrase": "important_aspect"}, {"score": 0.004664352260912174, "phrase": "quality_assurance"}, {"score": 0.004615202066192795, "phrase": "large_component_repositories"}, {"score": 0.004494570360108983, "phrase": "logical_coherence"}, {"score": 0.004447201233380302, "phrase": "component_metadata"}, {"score": 0.004064117897000019, "phrase": "relevant_classes"}, {"score": 0.003813669883040509, "phrase": "future_repositories"}, {"score": 0.0037336520904376687, "phrase": "current_repository"}, {"score": 0.0035408501923902477, "phrase": "possible_future_repositories"}, {"score": 0.0034118234596993836, "phrase": "finite_representation"}, {"score": 0.0033579708256295847, "phrase": "infinite_set"}, {"score": 0.003304965389155549, "phrase": "potential_futures"}, {"score": 0.0029565620771207003, "phrase": "practical_usefulness"}, {"score": 0.002744888626958772, "phrase": "\"forced_upgrades"}, {"score": 0.00267301171407926, "phrase": "new_versions"}, {"score": 0.0026447893350441502, "phrase": "existing_components"}, {"score": 0.002508073621696602, "phrase": "outdated_components"}, {"score": 0.002219790619936024, "phrase": "experience_reports"}, {"score": 0.0021731423856364003, "phrase": "debian_free_software_distribution"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Component repository", " Quality assurance", " Software evolution", " Speculative analysis", " Open source"], "paper_abstract": "An important aspect of the quality assurance of large component repositories is to ensure the logical coherence of component metadata, and to this end one needs to identify incoherences as early as possible. Some relevant classes of problems can be formulated in term of properties of the future repositories into which the current repository may evolve. However, checking such properties on all possible future repositories requires a way to construct a finite representation of the infinite set of all potential futures. A class of properties for which this can be done is presented in this work. We illustrate the practical usefulness of the approach with two quality assurance applications: (i) establishing the amount of \"forced upgrades\" induced by introducing new versions of existing components in a repository, and (ii) identifying outdated components that are currently not installable and need to be upgraded in order to become installable again. For both applications we provide experience reports obtained on the Debian free software distribution. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Learning from the future of component repositories", "paper_id": "WOS:000338387900003"}