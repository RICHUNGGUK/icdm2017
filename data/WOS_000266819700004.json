{"auto_keywords": [{"score": 0.041765365816587144, "phrase": "hughes"}, {"score": 0.00481495049065317, "phrase": "smallcheck"}, {"score": 0.004652016085325825, "phrase": "automatic_exhaustive_testing"}, {"score": 0.0045726187330434025, "phrase": "small_values"}, {"score": 0.004305203085016233, "phrase": "property-based_testing"}, {"score": 0.004053362743156545, "phrase": "claessen"}, {"score": 0.003816197777388722, "phrase": "testing_libraries"}, {"score": 0.003592859432554987, "phrase": "type-based_generators"}, {"score": 0.003441352119167824, "phrase": "finite_values"}, {"score": 0.0028963961037320805, "phrase": "randomly_generated_values"}, {"score": 0.0026570998719084153, "phrase": "limiting_depth"}, {"score": 0.002386294023107193, "phrase": "quickcheck"}], "paper_keywords": ["Languages", " Verification", " Embedded Language", " Property-based Testing", " Exhaustive Search", " Lazy Evaluation", " Type Classes"], "paper_abstract": "This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck (Claessen and Hughes 2000), these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.", "paper_title": "SmallCheck and Lazy SmallCheck automatic exhaustive testing for small values", "paper_id": "WOS:000266819700004"}