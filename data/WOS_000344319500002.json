{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multithreaded_programs"}, {"score": 0.0403859758180314, "phrase": "pattern-based_verification"}, {"score": 0.02867523550360307, "phrase": "maximal_number"}, {"score": 0.027986265370311895, "phrase": "longest_simple_path"}, {"score": 0.004619134710069517, "phrase": "program_executions"}, {"score": 0.004486800020569973, "phrase": "regular_expression"}, {"score": 0.004394592555435104, "phrase": "program_transitions"}, {"score": 0.00396110232316167, "phrase": "shared_storage"}, {"score": 0.003768426876815755, "phrase": "shared_counters"}, {"score": 0.003737234606207431, "phrase": "finite_variables"}, {"score": 0.003690927840780375, "phrase": "unrestricted_verification"}, {"score": 0.003630073540438812, "phrase": "abstracted_multithreaded_programs"}, {"score": 0.003600022318864217, "phrase": "recursive_procedures"}, {"score": 0.003570336307865807, "phrase": "pspace"}, {"score": 0.0035113478590679133, "phrase": "abstracted_multithreaded_while-programs"}, {"score": 0.003341837528601981, "phrase": "np"}, {"score": 0.0030995835539697893, "phrase": "multiparameter_analysis"}, {"score": 0.0027246145918972025, "phrase": "thread_structure"}, {"score": 0.0024452510143564057, "phrase": "pattern_size"}, {"score": 0.0024149139610228887, "phrase": "verification_problem"}, {"score": 0.0022877332844249065, "phrase": "maximal_size"}, {"score": 0.0021049977753042253, "phrase": "procedure_calls"}], "paper_keywords": ["Algorithms", " Languages", " Verification", " Reliability", " Concurrent programming", " context-free languages", " multithreaded programs", " safety", " underapproximation"], "paper_abstract": "Pattern-based verification checks the correctness of program executions that follow a given pattern, a regular expression over the alphabet of program transitions of the form w(1)* ... w(n)*. For multithreaded programs, the alphabet of the pattern is given by the reads and writes to the shared storage. We study the complexity of pattern-based verification for multithreaded programs with shared counters and finite variables. While unrestricted verification is undecidable for abstracted multithreaded programs with recursive procedures and PSPACE-complete for abstracted multithreaded while-programs (even without counters), we show that pattern-based verification is NP-complete for both classes, even in the presence of counters. We then conduct a multiparameter analysis to study the complexity of the problem on its three natural parameters (number of threads+counters+variables, maximal size of a thread, size of the pattern) and on two parameters related to thread structure (maximal number of procedures per thread and longest simple path of procedure calls). We present an algorithm that for a fixed number of threads, counters, variables, and pattern size solves the verification problem in st(O(lsp+[log(pr+1)])) time, where st is the maximal size of a thread, pr is the maximal number of procedures per thread, and lsp is the longest simple path of procedure calls.", "paper_title": "Pattern-Based Verification for Multithreaded Programs", "paper_id": "WOS:000344319500002"}