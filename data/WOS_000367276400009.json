{"auto_keywords": [{"score": 0.04246301635594336, "phrase": "dna_strands"}, {"score": 0.00481495049065317, "phrase": "dna_code"}, {"score": 0.004791330993892003, "phrase": "words_properties"}, {"score": 0.004744437370338926, "phrase": "regular_languages"}, {"score": 0.004652016085325825, "phrase": "dna_computing"}, {"score": 0.004516733575701128, "phrase": "dna_molecules"}, {"score": 0.004428728205625129, "phrase": "\"complicated\"_computational_problems"}, {"score": 0.004278807087784626, "phrase": "dna_code_word_design_problem"}, {"score": 0.004013662619667083, "phrase": "biochemical_processes"}, {"score": 0.003954837422946628, "phrase": "final_computation"}, {"score": 0.0038397509389856625, "phrase": "input_dna_strands"}, {"score": 0.0034118234596993836, "phrase": "initial_set"}, {"score": 0.002943147037670826, "phrase": "undesirable_ways"}, {"score": 0.0028857130140890787, "phrase": "new_interest"}, {"score": 0.0028154895878702633, "phrase": "efficient_algorithms"}, {"score": 0.0024405312482831646, "phrase": "finite_set"}, {"score": 0.0022890371899188466, "phrase": "infinite_but_regular_set"}, {"score": 0.0021896891011033105, "phrase": "dna_properties"}, {"score": 0.0021682027434117095, "phrase": "unwanted_intermolecular_and_intramolecular_hybridizations"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["DNA computing", " Formal languages", " Regular languages", " Automata theory"], "paper_abstract": "One aspect of DNA Computing is the possibility of using DNA molecules for solving some \"complicated\" computational problems. In this context, the DNA code word design problem assumes a fundamental role: given a problem encoded in DNA strands and biochemical processes, the final computation is a concatenation of the input DNA strands that must allow us to recover the solution of the given problem in terms of the input (unique decipherability). Thus the initial set of DNA strands must be a code. In addition, it should satisfy some restrictions, called here DNA properties, in order to prevent them from interacting in undesirable ways. So a new interest towards the design of efficient algorithms for testing whether a language X is a code, has arisen from (wet) DNA Computing, but, as far as we know, only when X is a finite set. In this paper we provide an algorithm for testing whether an infinite but regular set of words is a code that avoids some DNA properties among unwanted intermolecular and intramolecular hybridizations. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Testing DNA code words properties of regular languages", "paper_id": "WOS:000367276400009"}