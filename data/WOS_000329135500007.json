{"auto_keywords": [{"score": 0.0406233213360681, "phrase": "composite"}, {"score": 0.00481495049065317, "phrase": "configurable_component-based"}, {"score": 0.0047517225918491226, "phrase": "composite_os."}, {"score": 0.004643055780443262, "phrase": "user-level_scheduling_hierarchies"}, {"score": 0.004597244847332915, "phrase": "composite_component-based_system"}, {"score": 0.004176961840039024, "phrase": "specific_applications"}, {"score": 0.004149429072483132, "phrase": "untrusted_application_developers"}, {"score": 0.003987986947650714, "phrase": "protection_domains"}, {"score": 0.003845500924733243, "phrase": "timing_control"}, {"score": 0.003820144626025562, "phrase": "user-space_services"}, {"score": 0.0036836332308340923, "phrase": "asynchronous_events"}, {"score": 0.0035637545647574853, "phrase": "timely_manner"}, {"score": 0.0033576858946833587, "phrase": "user-defined_scheduling_policies"}, {"score": 0.003216285378512588, "phrase": "asignificant_challenge"}, {"score": 0.0031218852898830755, "phrase": "shared_data_structures"}, {"score": 0.003020232503089429, "phrase": "untrusted_code"}, {"score": 0.002951045605925464, "phrase": "efficient_upcall_mechanisms"}, {"score": 0.00290259605431505, "phrase": "asynchronous_event_notifications"}, {"score": 0.0028644081075973877, "phrase": "policy-specific_priorities"}, {"score": 0.0028360962841331634, "phrase": "undue_recourse"}, {"score": 0.002671990515821213, "phrase": "scheduling_polices"}, {"score": 0.0024842242921857705, "phrase": "guaranteed_differentiated_services"}, {"score": 0.00240328454980006, "phrase": "network_device"}, {"score": 0.002294369814584028, "phrase": "user-level_schedulers"}, {"score": 0.0021050136572267415, "phrase": "linux"}], "paper_keywords": ["Performance", " Reliability", " Scheduling", " component-based operating systems"], "paper_abstract": "This article presents the design of user-level scheduling hierarchies in the COMPOSITE component-based system. The motivation for this is centered around the design of a system that is both dependable and predictable, and which is configurable to the needs of specific applications. Untrusted application developers can safely develop services and policies, that are isolated in protection domains outside the kernel. To ensure predictability, COMPOSITE enforces timing control over user-space services. Moreover, it must provide a means by which asynchronous events, such as interrupts, are handled in a timely manner without jeopardizing the system. Towards this end, we describe the features of COMPOSITE that allow user-defined scheduling policies to be composed for the purposes of combined interrupt and taskmanagement. Asignificant challenge arises from the need to synchronize access to shared data structures (e.g., scheduling queues), without allowing untrusted code to disable interrupts. Additionally, efficient upcall mechanisms are needed to deliver asynchronous event notifications in accordance with policy-specific priorities, without undue recourse to schedulers. We show how these issues are addressed in COMPOSITE, by comparing several hierarchies of scheduling polices, to manage both tasks and the interrupts on which they depend. Studies show how it is possible to implement guaranteed differentiated services as part of the handling of I/O requests from a network device while diminishing livelock. Microbenchmarks indicate that the costs of implementing and invoking user-level schedulers in COMPOSITE are on par with, or less than, those in other systems, with thread switches more than twice as fast as in Linux.", "paper_title": "Predictable and Configurable Component-Based Scheduling in the COMPOSITE OS", "paper_id": "WOS:000329135500007"}