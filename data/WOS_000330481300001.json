{"auto_keywords": [{"score": 0.049763552914073306, "phrase": "transaction_processing"}, {"score": 0.0451155135875916, "phrase": "transaction_processing_systems"}, {"score": 0.02967423477277482, "phrase": "unbounded_communication"}, {"score": 0.00481495049065317, "phrase": "unscalable_communication"}, {"score": 0.004704844560325455, "phrase": "software_parallelism"}, {"score": 0.0046738485441681485, "phrase": "transaction_processing_workloads"}, {"score": 0.00462773520532301, "phrase": "high_concurrency"}, {"score": 0.0045218909699308385, "phrase": "ample_opportunities"}, {"score": 0.004492094831481931, "phrase": "parallel_execution"}, {"score": 0.004218602458288531, "phrase": "independent_agents"}, {"score": 0.00409490456027741, "phrase": "high_performing_transaction_processing_systems"}, {"score": 0.0037699306119313154, "phrase": "transaction_processing_system_designers"}, {"score": 0.0032916702592724217, "phrase": "fundamental_threat"}, {"score": 0.0031115683920520773, "phrase": "single-thread_performance"}, {"score": 0.003060491505805715, "phrase": "proper_analysis"}, {"score": 0.0030402955706518068, "phrase": "communication_patterns"}, {"score": 0.003010250522930773, "phrase": "software_system"}, {"score": 0.0029805015010906013, "phrase": "powerful_tool"}, {"score": 0.0029412916164128925, "phrase": "system's_scalability"}, {"score": 0.002845502417672334, "phrase": "common_framework_techniques"}, {"score": 0.0028173769301594745, "phrase": "significant_sources"}, {"score": 0.0026455755027979533, "phrase": "fundamental_services"}, {"score": 0.0026194209399161184, "phrase": "transaction_processing_engine"}, {"score": 0.0025509294021449254, "phrase": "physical_page_accesses"}, {"score": 0.0025257081555100556, "phrase": "buffer_pool_frame_accesses"}, {"score": 0.0024192592458651204, "phrase": "less-threatening_type"}, {"score": 0.002363806685815014, "phrase": "system_design"}, {"score": 0.0023172863267744703, "phrase": "later_technique"}, {"score": 0.002286781334850213, "phrase": "transaction_processing_architecture"}, {"score": 0.0021903801614787423, "phrase": "roughly_an_order"}, {"score": 0.002118993962770973, "phrase": "better_scalability"}, {"score": 0.0021049977753042253, "phrase": "multicore_machines"}], "paper_keywords": ["Scalable OLTP", " Communication patterns", " Shore-MT", " SLI", " Aether", " DORA", " PLP", " Overlay Bufferpools"], "paper_abstract": "Multicore hardware demands software parallelism. Transaction processing workloads typically exhibit high concurrency, and, thus, provide ample opportunities for parallel execution. Unfortunately, because of the characteristics of the application, transaction processing systems must moderate and coordinate communication between independent agents; since it is notoriously difficult to implement high performing transaction processing systems that incur no communication whatsoever. As a result, transaction processing systems cannot always convert abundant, even embarrassing, request-level parallelism into execution parallelism due to communication bottlenecks. Transaction processing system designers must therefore find ways to achieve scalability while still allowing communication to occur. To this end, we identify three forms of communication in the system-unbounded, fixed, and cooperative-and argue that only the first type poses a fundamental threat to scalability. The other two types tend not impose obstacles to scalability, though they may reduce single-thread performance. We argue that proper analysis of communication patterns in any software system is a powerful tool for improving the system's scalability. Then, we present and evaluate under a common framework techniques that attack significant sources of unbounded communication during transaction processing and sketch a solution for those that remain. The solutions we present affect fundamental services of any transaction processing engine, such as locking, logging, physical page accesses, and buffer pool frame accesses. They either reduce such communication through caching, downgrade it to a less-threatening type, or eliminate it completely through system design. We find that the later technique, revisiting the transaction processing architecture, is the most effective. The final design cuts unbounded communication by roughly an order of magnitude compared with the baseline, while exhibiting better scalability on multicore machines.", "paper_title": "Eliminating unscalable communication in transaction processing", "paper_id": "WOS:000330481300001"}