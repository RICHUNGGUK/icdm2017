{"auto_keywords": [{"score": 0.038092533468863946, "phrase": "c-decompiler"}, {"score": 0.007853874737698508, "phrase": "boomerang"}, {"score": 0.00481495049065317, "phrase": "c_code"}, {"score": 0.004776484866276242, "phrase": "high_readability"}, {"score": 0.004700468701207975, "phrase": "key_part"}, {"score": 0.004662913362513954, "phrase": "reverse_engineering"}, {"score": 0.004533806239310673, "phrase": "software_security"}, {"score": 0.004303404058571052, "phrase": "ida_hex_rays"}, {"score": 0.0041842092128678105, "phrase": "executable_programs"}, {"score": 0.004150761431291174, "phrase": "source_code"}, {"score": 0.004101088357088207, "phrase": "relatively_high-level_language"}, {"score": 0.003987474771008829, "phrase": "low_accuracy"}, {"score": 0.0038614646772981848, "phrase": "composite_structures"}, {"score": 0.0037999551521987426, "phrase": "poor_readability"}, {"score": 0.0036504182609411852, "phrase": "practical_decompiler"}, {"score": 0.003592258384936271, "phrase": "windows_c_programs"}, {"score": 0.0034926916198124484, "phrase": "shadow_stack"}, {"score": 0.0034508665218929745, "phrase": "refined_data_flow_analysis"}, {"score": 0.003368707839819003, "phrase": "inter-basic-block_register_propagation"}, {"score": 0.0031845067058084583, "phrase": "standard_template_library"}, {"score": 0.0030468495296763617, "phrase": "decompilation_quality"}, {"score": 0.002615381301695394, "phrase": "highest_total_percentage_reduction"}, {"score": 0.0025736694380861604, "phrase": "lowest_variable_expansion_rate"}, {"score": 0.002327594516681507, "phrase": "lower_false_positive_and_false_negative_rate"}, {"score": 0.0022630008787375435, "phrase": "case_study"}, {"score": 0.002191366809047192, "phrase": "practical_tool"}, {"score": 0.002165091261117016, "phrase": "highly_readable_c-style_code"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["reverse engineering", " decompilation", " C language"], "paper_abstract": "As a key part of reverse engineering, decompilation plays a very important role in software security and maintenance. A number of tools, such as Boomerang and IDA Hex_rays, have been developed to translate executable programs into source code in a relatively high-level language. Unfortunately, most existing decompilation tools suffer from low accuracy in identifying variables, functions, and composite structures, resulting in poor readability. To address these limitations, we present a practical decompiler called C-Decompiler for Windows C programs that (i) uses a shadow stack to perform refined data flow analysis, (ii) adopts inter-basic-block register propagation to reduce redundant variables, and (iii) recognizes library (i.e., Standard Template Library) functions by signatures. We evaluate and compare the decompilation quality of C-Decompiler with two existing tools, Boomerang and IDA Hex_rays, considering four aspects: function analysis, variable expansion rate, total percentage reduction, and cyclomatic complexity. Our experimental results show that on average, C-Decompiler has the highest total percentage reduction of 55.91%, lowest variable expansion rate of 55.79%, and the same cyclomatic complexityastheoriginal source code for each considered application. Furthermore, in our experiments, C-Decompiler is able to recognize functions with a lower false positive and false negative rate than the other decompilers. A case study and our evaluation results confirm that C-Decompiler is a practical tool to produce highly readable C-style code. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "A refined decompiler to generate C code with high readability", "paper_id": "WOS:000325561000006"}