{"auto_keywords": [{"score": 0.027197814714766472, "phrase": "false_alarms"}, {"score": 0.00481495049065317, "phrase": "safety_properties"}, {"score": 0.004770461993586338, "phrase": "hierarchical_cache_coherence_protocols"}, {"score": 0.004554082077300675, "phrase": "sequential_processing_hardware"}, {"score": 0.004388035083357706, "phrase": "memory_system"}, {"score": 0.004347473906950474, "phrase": "multicore_processors"}, {"score": 0.00428733103049275, "phrase": "huge_bottleneck"}, {"score": 0.004073809704022463, "phrase": "aggressively_optimized_cache_coherence_protocols"}, {"score": 0.00398028819691605, "phrase": "design_correctness_problem"}, {"score": 0.003943481134959376, "phrase": "advanced_cache_coherence_protocols"}, {"score": 0.003817306032290766, "phrase": "scalable_designs"}, {"score": 0.00372965096877929, "phrase": "monolithic_formal_verification"}, {"score": 0.003644001325962353, "phrase": "hierarchical_designs"}, {"score": 0.003320561182494713, "phrase": "compositional_techniques"}, {"score": 0.003140401552000472, "phrase": "compositional_approaches"}, {"score": 0.0030825404960282713, "phrase": "assume-guarantee_reasoning"}, {"score": 0.0030257422786589723, "phrase": "verification_complexity"}, {"score": 0.0028350413546400703, "phrase": "multiple_chip-multiprocessors"}, {"score": 0.0025355968118803956, "phrase": "designer_time"}, {"score": 0.0024658019116387845, "phrase": "error_trace_justification_method"}, {"score": 0.0022889103976458437, "phrase": "special_tool_support"}, {"score": 0.002195033004022173, "phrase": "widely_used_murphi_model_checker"}, {"score": 0.0021049977753042253, "phrase": "trace_justification"}], "paper_keywords": ["Explicit state model checking", " Hierarchical cache coherence protocols", " Abstraction/refinement", " Assume-guarantee reasoning"], "paper_abstract": "Multicore architectures are considered inevitable, given that sequential processing hardware has hit various limits. Unfortunately, the memory system of multicore processors is a huge bottleneck. To combat this problem, one needs to design aggressively optimized cache coherence protocols. This introduces the design correctness problem for advanced cache coherence protocols which will be hierarchically organized for scalable designs. Experiences show that monolithic formal verification will not scale to hierarchical designs. Hence, one needs to handle the complexity of several coherence protocols running concurrently, i.e. hierarchical protocols, using compositional techniques. To solve the problem, we develop a family of compositional approaches all based on assume-guarantee reasoning to reducing the verification complexity. We show that for the three hierarchical protocols with certain realistic features that we developed for multiple chip-multiprocessors, more than a 20-fold improvement in terms of the number of states visited can be achieved. Also, to avoid false alarms wasting designer time, we have developed an error trace justification method to eliminate false alarms using heuristics that also capitalize on our assume-guarantee approaches. Our techniques need no special tool support. They can be carried out using the widely used Murphi model checker along with support tools for abstraction and error trace justification that we have built.", "paper_title": "Efficient methods for formally verifying safety properties of hierarchical cache coherence protocols", "paper_id": "WOS:000276264900002"}