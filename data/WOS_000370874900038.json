{"auto_keywords": [{"score": 0.04173052379689657, "phrase": "denovo"}, {"score": 0.015719714774698124, "phrase": "arbitrary_synchronization"}, {"score": 0.011778499569500708, "phrase": "denovosync"}, {"score": 0.004758053266234474, "phrase": "writer-initiated_invalidations"}, {"score": 0.004701825207431857, "phrase": "current_shared-memory_hardware"}, {"score": 0.004430452655732319, "phrase": "denovo_coherence_protocol"}, {"score": 0.004326321719714357, "phrase": "shared-memory_programming_models"}, {"score": 0.004100851549096203, "phrase": "energy-efficient_hardware"}, {"score": 0.004028326293950714, "phrase": "state-of-the-art_mesi_protocol"}, {"score": 0.003369778677878286, "phrase": "key_challenge"}, {"score": 0.003213070385558666, "phrase": "reader-initiated_local_self-invalidations"}, {"score": 0.002921114512115261, "phrase": "synchronization_accesses"}, {"score": 0.002639845784408318, "phrase": "novel_combination"}, {"score": 0.0025020469669826497, "phrase": "judicious_hardware_backoff"}, {"score": 0.0024577274522206436, "phrase": "unnecessary_registrations"}, {"score": 0.002399850604120431, "phrase": "wide_variety"}, {"score": 0.002371424085814217, "phrase": "synchronization_constructs"}, {"score": 0.0022881443200668886, "phrase": "mesi"}, {"score": 0.002142970278347126, "phrase": "denovo's_advantages"}], "paper_keywords": [""], "paper_abstract": "Current shared-memory hardware is complex and inefficient. Prior work on the DeNovo coherence protocol showed that disciplined shared-memory programming models can enable more complexity-, performance-, and energy-efficient hardware than the state-of-the-art MESI protocol. DeNovo, however, severely restricted the synchronization constructs an application can support. This paper proposes DeNovoSync, a technique to support arbitrary synchronization in DeNovo. The key challenge is that DeNovo exploits race-freedom to use reader-initiated local self-invalidations (instead of conventional writer-initiated remote cache invalidations) to ensure coherence. Synchronization accesses are inherently racy and not directly amenable to self-invalidations. DeNovoSync addresses this challenge using a novel combination of registration of all synchronization reads with a judicious hardware backoff to limit unnecessary registrations. For a wide variety of synchronization constructs and applications, compared to MESI, DeNovoSync shows comparable or up to 22% lower execution time and up to 58% lower network traffic, enabling DeNovo's advantages for a much broader class of software than previously possible.", "paper_title": "DeNovoSync: Efficient Support for Arbitrary Synchronization without Writer-Initiated Invalidations", "paper_id": "WOS:000370874900038"}