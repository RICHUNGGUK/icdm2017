{"auto_keywords": [{"score": 0.049180518370399884, "phrase": "logical_time"}, {"score": 0.04100375147158351, "phrase": "performance_analysis"}, {"score": 0.03593976593369695, "phrase": "event_history"}, {"score": 0.004760518730536645, "phrase": "parallel_execution_traces"}, {"score": 0.004653485665080485, "phrase": "continuous_rise"}, {"score": 0.004583464412234181, "phrase": "modern_supercomputers"}, {"score": 0.004480394224548146, "phrase": "large-scale_parallel_programs"}, {"score": 0.00421668332357505, "phrase": "even_minor_inefficiencies"}, {"score": 0.0041374874583908535, "phrase": "compute_hours"}, {"score": 0.004075198669927074, "phrase": "power_consumption"}, {"score": 0.0039986494357811715, "phrase": "avoidable_mistakes"}, {"score": 0.0039684322717435045, "phrase": "sub-optimal_algorithms"}, {"score": 0.003879138659123195, "phrase": "optimization_critical_elements"}, {"score": 0.0038352452380298464, "phrase": "software_development_process"}, {"score": 0.0036784938661226104, "phrase": "execution_traces"}, {"score": 0.0035820833812158005, "phrase": "per-process_events"}, {"score": 0.0035550029054401016, "phrase": "inter-process_messages"}, {"score": 0.0035147642199945387, "phrase": "parallel_application"}, {"score": 0.0034881908940439213, "phrase": "trace_visualizations"}, {"score": 0.003320277992107974, "phrase": "observed_performance_behavior"}, {"score": 0.0032702516771609957, "phrase": "current_visualizations"}, {"score": 0.0031845067058084583, "phrase": "small_process_counts"}, {"score": 0.0030775481952376987, "phrase": "organizing_events"}, {"score": 0.0030082398041055003, "phrase": "virtually_unintelligible_conglomerate"}, {"score": 0.002985484575498061, "phrase": "interleaved_events"}, {"score": 0.002907184330345933, "phrase": "even_the_largest_display"}, {"score": 0.0028095140358025, "phrase": "new_trace_visualization_approach"}, {"score": 0.002613935123129054, "phrase": "code's_structural_behavior"}, {"score": 0.0025260919226344305, "phrase": "application_developer"}, {"score": 0.002497470177389344, "phrase": "original_timing_data"}, {"score": 0.002305974875400655, "phrase": "discrete_nature"}, {"score": 0.002288519595829552, "phrase": "logical_timelines"}, {"score": 0.002203200914130907, "phrase": "scalable_visualization"}, {"score": 0.0021865218861454256, "phrase": "even_long_traces"}, {"score": 0.002169968849836984, "phrase": "large_process_counts"}, {"score": 0.0021049977753042253, "phrase": "large-scale_parallel_codes"}], "paper_keywords": ["Information visualization", " software visualization. timelines", " traces", " performance analysis"], "paper_abstract": "With the continuous rise in complexity of modern supercomputers, optimizing the performance of large-scale parallel programs is becoming increasingly challenging. Simultaneously, the growth in scale magnifies the impact of even minor inefficiencies - potentially millions of compute hours and megawatts in power consumption can be wasted on avoidable mistakes or sub-optimal algorithms. This makes performance analysis and optimization critical elements in the software development process. One of the most common forms of performance analysis is to study execution traces, which record a history of per-process events and inter-process messages in a parallel application. Trace visualizations allow users to browse this event history and search for insights into the observed performance behavior. However, current visualizations are difficult to understand even for small process counts and do not scale gracefully beyond a few hundred processes. Organizing events in time leads to a virtually unintelligible conglomerate of interleaved events and moderately high process counts overtax even the largest display. As an alternative, we present a new trace visualization approach based on transforming the event history into logical time inferred directly from happened-before relationships. This emphasizes the code's structural behavior, which is much more familiar to the application developer. The original timing data, or other information, is then encoded through color, leading to a more intuitive visualization. Furthermore, we use the discrete nature of logical timelines to cluster processes according to their local behavior leading to a scalable visualization of even long traces on large process counts. We demonstrate our system using two case studies on large-scale parallel codes.", "paper_title": "Combing the Communication Hairball: Visualizing Parallel Execution Traces using Logical Time", "paper_id": "WOS:000344991700080"}