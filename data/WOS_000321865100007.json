{"auto_keywords": [{"score": 0.025276982812645482, "phrase": "sdm"}, {"score": 0.00481495049065317, "phrase": "variable-length_decompression_algorithms"}, {"score": 0.0047689174754929195, "phrase": "variable-length_coding"}, {"score": 0.004655742198075387, "phrase": "efficient_data_compression"}, {"score": 0.004480196733208298, "phrase": "original_data"}, {"score": 0.004311241567238011, "phrase": "variable-length_codes"}, {"score": 0.004229158339021651, "phrase": "variable-length_compressed_blocks"}, {"score": 0.004069631519385246, "phrase": "ample_block-level_parallelism"}, {"score": 0.0037864980290391354, "phrase": "block_boundary"}, {"score": 0.0036261282565554507, "phrase": "previous_block"}, {"score": 0.0035060903664150115, "phrase": "novel_algorithms"}, {"score": 0.0034392837410790293, "phrase": "block_boundaries"}, {"score": 0.0033900126423990823, "phrase": "runtime_system"}, {"score": 0.00334144503360907, "phrase": "efficient_block-level_parallel_decompression"}, {"score": 0.003293570937654716, "phrase": "sdm."}, {"score": 0.003262035294895737, "phrase": "sdm_execution_model"}, {"score": 0.003108814986752103, "phrase": "scanner_stage"}, {"score": 0.0030642636185693054, "phrase": "high-confidence_prediction_algorithm"}, {"score": 0.0030203487665054806, "phrase": "compressed_block_boundaries"}, {"score": 0.0029627701619228527, "phrase": "individual_blocks"}, {"score": 0.002850875630787708, "phrase": "parallel_decompressor_stage"}, {"score": 0.0028100102841877835, "phrase": "multiple_blocks"}, {"score": 0.002716915166374506, "phrase": "decompressed_blocks"}, {"score": 0.0026268961477241026, "phrase": "merger_stage"}, {"score": 0.0025767987652419054, "phrase": "final_output"}, {"score": 0.0025398521156505425, "phrase": "sdm_runtime"}, {"score": 0.0024088451312725924, "phrase": "resource-constrained_embedded_platforms"}, {"score": 0.0021771713131746636, "phrase": "geometric_mean_speedups"}], "paper_keywords": ["Design", " Performance", " Parallelization", " runtime", " speculation", " compression", " multicores", " embedded systems"], "paper_abstract": "Variable-length coding is widely used for efficient data compression. Typically, the compressor splits the original data into blocks and compresses each block with variable-length codes, hence producing variable-length compressed blocks. Although the compressor can easily exploit ample block-level parallelism, it is much more difficult to extract such coarse-grain parallelism from the decompressor because a block boundary cannot be located until decompression of the previous block is completed. This paper presents novel algorithms to efficiently predict block boundaries and a runtime system that enables efficient block-level parallel decompression, called SDM. The SDM execution model features speculative pipelining with three stages: Scanner, Decompressor, and Merger. The scanner stage employs a high-confidence prediction algorithm that finds compressed block boundaries without fully decompressing individual blocks. This information is communicated to the parallel decompressor stage in which multiple blocks are decompressed in parallel. The decompressed blocks are merged in order by the merger stage to produce the final output. The SDM runtime is specialized to execute this pipeline correctly and efficiently on resource-constrained embedded platforms. With SDM we effectively parallelize three production-grade variable-length decompression algorithms-zlib, bzip2, and H.264-with maximum speedups of 2.50x and 8.53x (and geometric mean speedups of 1.96x and 4.04x) on 4-core and 36-core embedded platforms, respectively.", "paper_title": "Practical Speculative Parallelization of Variable-Length Decompression Algorithms", "paper_id": "WOS:000321865100007"}