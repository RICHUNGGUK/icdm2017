{"auto_keywords": [{"score": 0.047037746158112057, "phrase": "dynamic_languages"}, {"score": 0.03200367144985528, "phrase": "finite_state_machine"}, {"score": 0.030870703107657882, "phrase": "control_stack"}, {"score": 0.02896066703343443, "phrase": "pushdown_systems"}, {"score": 0.028244896027967897, "phrase": "automata_theory"}, {"score": 0.00481495049065317, "phrase": "abstracting_abstract_control"}, {"score": 0.004733347359490221, "phrase": "dynamic_language"}, {"score": 0.004600389726895716, "phrase": "compile-time_predictability"}, {"score": 0.0043208252177835815, "phrase": "static_types"}, {"score": 0.004247560712327667, "phrase": "compiler_writers"}, {"score": 0.004223415145617665, "phrase": "tool_developers"}, {"score": 0.004187452827599427, "phrase": "verification_engineers"}, {"score": 0.004069766428492073, "phrase": "statically_reasoning"}, {"score": 0.003966667994579941, "phrase": "static_analyses"}, {"score": 0.0034395119150793787, "phrase": "computable_approximation"}, {"score": 0.003419943984098415, "phrase": "program_behavior"}, {"score": 0.0033811403330431897, "phrase": "abstract_machine_semantics"}, {"score": 0.0033142868401478953, "phrase": "viable_approach"}, {"score": 0.0032954289787083713, "phrase": "dynamic_language_analysis"}, {"score": 0.0032210609849058483, "phrase": "machine_description"}, {"score": 0.003166384930533443, "phrase": "aam_recipe"}, {"score": 0.0031215289677725693, "phrase": "finite_state_abstractions"}, {"score": 0.0028006988338192375, "phrase": "recent_advances"}, {"score": 0.0027689017918347755, "phrase": "higher-order_programs"}, {"score": 0.0026152363154073707, "phrase": "significant_engineering"}, {"score": 0.002386869729952315, "phrase": "dynamic_language_features"}, {"score": 0.0023530305476484807, "phrase": "abstracting_abstract_machines_technique"}, {"score": 0.002326304140277375, "phrase": "stronger_computational_model"}, {"score": 0.0021352776064254195, "phrase": "garbage_collection"}, {"score": 0.0021049977753042253, "phrase": "first-class_composable_continuations"}], "paper_keywords": [""], "paper_abstract": "The strength of a dynamic language is also its weakness: run-time flexibility comes at the cost of compile-time predictability. Many of the hallmarks of dynamic languages such as closures, continuations, various forms of reflection, and a lack of static types make many programmers rejoice, while compiler writers, tool developers, and verification engineers lament. The dynamism of these features simply confounds statically reasoning about programs that use them. Consequently, static analyses for dynamic languages are few, far between, and seldom sound. The \"abstracting abstract machines\" (AAM) approach to constructing static analyses has recently been proposed as a method to ameliorate the difficulty of designing analyses for such language features. The approach, so called because it derives a function for the sound and computable approximation of program behavior starting from the abstract machine semantics of a language, provides a viable approach to dynamic language analysis since all that is required is a machine description of the interpreter. The AAM recipe as originally described produces finite state abstractions: the behavior of a program is approximated as a finite state machine. Such a model is inherently imprecise when it comes to reasoning about the control stack of the interpreter: a finite state machine cannot faithfully represent a stack. Recent advances have shown that higher-order programs can be approximated with pushdown systems. However, such models, founded in automata theory, either breakdown or require significant engineering in the face of dynamic language features that inspect or modify the control stack. In this paper, we tackle the problem of bringing pushdown flow analysis to the domain of dynamic language features. We revise the abstracting abstract machines technique to target the stronger computational model of pushdown systems. In place of automata theory, we use only abstract machines and memoization. As case studies, we show the technique applies to a language with closures, garbage collection, stack-inspection, and first-class composable continuations.", "paper_title": "Abstracting Abstract Control", "paper_id": "WOS:000357123600003"}