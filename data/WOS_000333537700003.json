{"auto_keywords": [{"score": 0.04969652007027205, "phrase": "concurrent_program_transformations"}, {"score": 0.044459030584439334, "phrase": "refinement_relation"}, {"score": 0.04228586663215738, "phrase": "parallel_compositions"}, {"score": 0.00481495049065317, "phrase": "compositional_verification"}, {"score": 0.004719359108879602, "phrase": "program_transformations"}, {"score": 0.004607139608615063, "phrase": "resulting_program"}, {"score": 0.00440825801245188, "phrase": "original_one"}, {"score": 0.004217925382695912, "phrase": "individual_sequential_threads"}, {"score": 0.003908246778916674, "phrase": "different_granularities"}, {"score": 0.003876996400581697, "phrase": "atomic_operations"}, {"score": 0.0036212219870826725, "phrase": "fully_abstract_semantics"}, {"score": 0.003592258384936271, "phrase": "concurrent_programs"}, {"score": 0.0035635256137029592, "phrase": "arbitrary_parallel_environments"}, {"score": 0.003022465992278672, "phrase": "target_programs"}, {"score": 0.0027778947555117243, "phrase": "sequential_programs"}, {"score": 0.0025736694380861604, "phrase": "rgsim"}, {"score": 0.0025326211341475903, "phrase": "semantics_preservation"}, {"score": 0.0023940274498526213, "phrase": "specific_program_transformations"}, {"score": 0.0022268964676199292, "phrase": "concurrent_objects"}, {"score": 0.0021738146596180404, "phrase": "general_garbage_collector_verification_framework"}, {"score": 0.0021049977753042253, "phrase": "boehm_et_al"}], "paper_keywords": ["Theory", " Verification", " Concurrency", " program transformation", " rely-guarantee reasoning", " simulation"], "paper_abstract": "Verifying program transformations usually requires proving that the resulting program (the target) refines or is equivalent to the original one (the source). However, the refinement relation between individual sequential threads cannot be preserved in general with the presence of parallel compositions, due to instruction reordering and the different granularities of atomic operations at the source and the target. On the other hand, the refinement relation defined based on fully abstract semantics of concurrent programs assumes arbitrary parallel environments, which is too strong and cannot be satisfied by many well-known transformations. In this article, we propose a Rely-Guarantee-based Simulation (RGSim) to verify concurrent program transformations. The relation is parametrized with constraints of the environments that the source and the target programs may compose with. It considers the interference between threads and their environments, thus is less permissive than relations over sequential programs. It is compositional with respect to parallel compositions as long as the constraints are satisfied. Also, RGSim does not require semantics preservation under all environments, and can incorporate the assumptions about environments made by specific program transformations in the form of rely/guarantee conditions. We use RGSim to reason about optimizations and prove atomicity of concurrent objects. We also propose a general garbage collector verification framework based on RGSim, and verify the Boehm et al. concurrent mark-sweep GC.", "paper_title": "Rely-Guarantee-Based Simulation for Compositional Verification of Concurrent Program Transformations", "paper_id": "WOS:000333537700003"}