{"auto_keywords": [{"score": 0.05007564759062611, "phrase": "memory_faults"}, {"score": 0.004600596158672458, "phrase": "reliable_computation"}, {"score": 0.004012885020428863, "phrase": "optimal_time"}, {"score": 0.0039097293657870584, "phrase": "largest_possible_number"}, {"score": 0.0035923719610602214, "phrase": "time_sorting_algorithm"}, {"score": 0.0032792555200980783, "phrase": "special_case"}, {"score": 0.003236802914194731, "phrase": "integer_sorting"}, {"score": 0.0030924870122337905, "phrase": "linear_expected_running_time"}, {"score": 0.0028973794653974327, "phrase": "randomized_searching_algorithm"}, {"score": 0.002351813899450668, "phrase": "small_positive_constant_epsilon"}, {"score": 0.00214659338413584, "phrase": "previous_bounds"}], "paper_keywords": ["Combinatorial algorithms", " Sorting", " Searching", " Memory faults", " Memory models", " Computing with unreliable information"], "paper_abstract": "We investigate the problem of reliable computation in the presence of faults that may arbitrarily corrupt memory locations. In this framework, we consider the problems of sorting and searching in optimal time while tolerating the largest possible number of memory faults. In particular, we design an O(n log n) time sorting algorithm that can optimally tolerate up to O(root n log n) memory faults. In the special case of integer sorting, we present an algorithm with linear expected running time that can tolerate O(root n) faults. We also present a randomized searching algorithm that can optimally tolerate up to O(log n) memory faults in O(log n) expected time, and an almost optimal deterministic searching algorithm that can tolerate O((log n)(1-epsilon)) faults, for any small positive constant epsilon, in O(log n) worst-case time. All these results improve over previous bounds. (c) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Optimal resilient sorting and searching in the presence of memory faults", "paper_id": "WOS:000270688400004"}