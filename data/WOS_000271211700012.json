{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "logical_relations"}, {"score": 0.004616859702338596, "phrase": "denotational_semantics"}, {"score": 0.004426882270402403, "phrase": "simply_typed_functional_language"}, {"score": 0.004127394241838696, "phrase": "operational_behaviour"}, {"score": 0.0040133278382101885, "phrase": "low-level_programs"}, {"score": 0.003848088904418221, "phrase": "variant_secd_machine"}, {"score": 0.002866498582226632, "phrase": "low-level_code"}, {"score": 0.002388487669097511, "phrase": "simple_compiler"}, {"score": 0.0021049977753042253, "phrase": "coq_proof_assistant"}], "paper_keywords": ["Languages", " theory", " verification", " Compiler verification", " denotational semantics", " biorthogonality", " step-indexing", " proof assistants"], "paper_abstract": "We define logical relations between the denotational semantics of a simply typed functional language with recursion and the operational behaviour of low-level programs in a variant SECD machine. The relations, which are defined using biorthogonality and step-indexing, capture what it means for a piece of low-level code to implement a mathematical, domain-theoretic function and are used to prove correctness of a simple compiler. The results have been formalized in the Coq proof assistant.", "paper_title": "Biorthogonality, Step-Indexing and Compiler Correctness", "paper_id": "WOS:000271211700012"}