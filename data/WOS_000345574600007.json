{"auto_keywords": [{"score": 0.03618042519491516, "phrase": "find_operations"}, {"score": 0.01301174856604182, "phrase": "find_operation"}, {"score": 0.01159923009258581, "phrase": "total_number"}, {"score": 0.00481495049065317, "phrase": "constant_time_deletions"}, {"score": 0.004769958800452922, "phrase": "union-find_data_structure"}, {"score": 0.004695900553353526, "phrase": "disjoint_sets"}, {"score": 0.004652016085325825, "phrase": "operations_makeset"}, {"score": 0.004551227037446433, "phrase": "kaplan"}, {"score": 0.004522797955813169, "phrase": "shafrir"}, {"score": 0.004424768776701965, "phrase": "data_structures"}, {"score": 0.004342430078306461, "phrase": "union-find_problem"}, {"score": 0.004130243047687995, "phrase": "delete_operation"}, {"score": 0.0035204268675160257, "phrase": "makeset_operations"}, {"score": 0.003306559295382181, "phrase": "functional_inverse"}, {"score": 0.0032858981413454802, "phrase": "ackermann's_function"}, {"score": 0.00320453237792, "phrase": "delete_operations"}, {"score": 0.002962986184540317, "phrase": "open_problem"}, {"score": 0.0029260602766930065, "phrase": "relatively_simple_modification"}, {"score": 0.0028986672783671147, "phrase": "classical_union-find_data_structure"}, {"score": 0.0027741761880779535, "phrase": "constant_worst-case_time"}, {"score": 0.002431797888365548, "phrase": "standard_union-find_data_structure"}, {"score": 0.002283913454238574, "phrase": "previous_potential-based_analyses"}, {"score": 0.0021450029487459403, "phrase": "one-path_variants"}, {"score": 0.0021249064184347658, "phrase": "path_compression_technique"}, {"score": 0.0021049977753042253, "phrase": "path_splitting"}], "paper_keywords": ["Union-find", " disjoint sets"], "paper_abstract": "A union-find data structure maintains a collection of disjoint sets under the operations makeset, union, and find. Kaplan, Shafrir, and Tarjan [SODA 2002] designed data structures for an extension of the union-find problem in which items of the sets maintained may be deleted. The cost of a delete operation in their implementations is essentially the same as the cost of a find operation; namely, O(log n) worst-case and O(alpha([M/N]) (n)) amortized, where n is the number of items in the set returned by the find operation, N is the total number of makeset operations performed, M is the total number of find operations performed, and alpha([M/N]) (n) is a functional inverse of Ackermann's function. They left open the question whether delete operations can be implemented more efficiently than find operations, for example, in o(log n) worst-case time. We resolve this open problem by presenting a relatively simple modification of the classical union-find data structure that supports delete, as well as makeset and union operations, in constant worst-case time, while still supporting find operations in O(log n) worst-case time and O(alpha([M/N]) (n)) amortized time. Our analysis supplies, in particular, a very concise potential-based amortized analysis of the standard union-find data structure that yields an O(alpha([M/N]) (n)) amortized bound on the cost of find operations. All previous potential-based analyses yielded the weaker amortized bound of O(alpha([M/N]) (N)). Furthermore, our tighter analysis extends to one-path variants of the path compression technique such as path splitting.", "paper_title": "Union-Find with Constant Time Deletions", "paper_id": "WOS:000345574600007"}