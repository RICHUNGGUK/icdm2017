{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "recursive_functions"}, {"score": 0.004666228956744244, "phrase": "algebraic_datatypes"}, {"score": 0.004382364826200616, "phrase": "proof-theoretic_techniques"}, {"score": 0.004202741104973709, "phrase": "type_information"}, {"score": 0.004115697805448384, "phrase": "input-output_examples"}, {"score": 0.003946960862020283, "phrase": "search_space"}, {"score": 0.0037456980766939836, "phrase": "refinement_trees"}, {"score": 0.0032689949867583633, "phrase": "generated_code"}, {"score": 0.002974886152979993, "phrase": "prototype_implementation"}, {"score": 0.002218299213266519, "phrase": "synthesis_time"}, {"score": 0.002172266188075892, "phrase": "attainable_size"}, {"score": 0.0021049977753042253, "phrase": "generated_programs"}], "paper_keywords": ["Languages", " Theory", " Functional Programming", " Proof Search", " Program Synthesis", " Type Theory"], "paper_abstract": "This paper presents an algorithm for synthesizing recursive functions that process algebraic datatypes. It is founded on proof-theoretic techniques that exploit both type information and input-output examples to prune the search space. The algorithm uses refinement trees, a data structure that succinctly represents constraints on the shape of generated code. We evaluate the algorithm by using a prototype implementation to synthesize more than 40 benchmarks and several non-trivial larger examples. Our results demonstrate that the approach meets or outperforms the state-of-the-art for this domain, in terms of synthesis time or attainable size of the generated programs.", "paper_title": "Type-and-Example-Directed Program Synthesis", "paper_id": "WOS:000361284200058"}