{"auto_keywords": [{"score": 0.04629809807747921, "phrase": "quantitative_resources"}, {"score": 0.00481495049065317, "phrase": "quantitative_resource_usage"}, {"score": 0.004762550320451225, "phrase": "higher-order_programs"}, {"score": 0.0046340196745259694, "phrase": "new_automatic_static_analysis"}, {"score": 0.004558564684763264, "phrase": "upper-bound_functions"}, {"score": 0.004063547375196532, "phrase": "tarjan's_manual_amortised_cost_analysis_technique"}, {"score": 0.003953806321226277, "phrase": "type-based_approach"}, {"score": 0.0037226570791514184, "phrase": "new_emphasis"}, {"score": 0.0035630518377071916, "phrase": "data_object"}, {"score": 0.0031411751440831165, "phrase": "specific_inputs"}, {"score": 0.0030899524399043863, "phrase": "overall_cost_behaviour"}, {"score": 0.0030395624703152212, "phrase": "key_novel_aspect"}, {"score": 0.0028932554846476718, "phrase": "polymorphic_higher-order_functions"}, {"score": 0.0028460640294160383, "phrase": "source-level_transformations"}, {"score": 0.0027843339377323878, "phrase": "resource_usage"}, {"score": 0.002709045632654716, "phrase": "safe_and_accurate_compile-time_bounds"}, {"score": 0.0023749823753904204, "phrase": "stack_usage"}, {"score": 0.0021994343316143125, "phrase": "real_implementation"}, {"score": 0.002163535133532765, "phrase": "simple_micro-controller_platform"}, {"score": 0.0021049977753042253, "phrase": "safety-critical_automotive_applications"}], "paper_keywords": ["Languages", " Reliability", " Performance", " Theory", " Functional Programming", " Resource Analysis", " Types"], "paper_abstract": "We describe a new automatic static analysis for determining upper-bound functions on the use of quantitative resources for strict, higher-order, polymorphic, recursive programs dealing with possibly-aliased data. Our analysis is a variant of Tarjan's manual amortised cost analysis technique. We use a type-based approach, exploiting linearity to allow inference, and place a new emphasis on the number of references to a data object. The bounds we infer depend on the sizes of the various inputs to a program. They thus expose the impact of specific inputs on the overall cost behaviour. The key novel aspect of our work is that it deals directly with polymorphic higher-order functions without requiring source-level transformations that could alter resource usage. We thus obtain safe and accurate compile-time bounds. Our work is generic in that it deals with a variety of quantitative resources. We illustrate our approach with reference to dynamic memory allocations/deallocations, stack usage, and worst-case execution time, using metrics taken from a real implementation on a simple micro-controller platform that is used in safety-critical automotive applications.", "paper_title": "Static Determination of Quantitative Resource Usage for Higher-Order Programs", "paper_id": "WOS:000274028100021"}