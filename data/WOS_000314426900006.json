{"auto_keywords": [{"score": 0.04905481275957967, "phrase": "concurrent_code"}, {"score": 0.00481495049065317, "phrase": "critical_section_refactoring_opportunities"}, {"score": 0.004671342094877447, "phrase": "trustworthy_software"}, {"score": 0.004532247150981741, "phrase": "java"}, {"score": 0.004473552224535518, "phrase": "simple_but_often_over-used_synchronization_mechanism"}, {"score": 0.0043213410601860985, "phrase": "big_synchronized_section"}, {"score": 0.004247180402119585, "phrase": "large_block"}, {"score": 0.00374610869916551, "phrase": "multi-core_environment"}, {"score": 0.003261295948815592, "phrase": "source-code_level_refactoring_approach"}, {"score": 0.0032191849045822415, "phrase": "coarse-gained_synchronizations"}, {"score": 0.0030693625816617044, "phrase": "shrinkable_critical_sections"}, {"score": 0.002990592465417758, "phrase": "smaller_ones"}, {"score": 0.0028267701593809877, "phrase": "better_quality"}, {"score": 0.0026718978608934077, "phrase": "new_escape_analysis"}, {"score": 0.0024288443150616056, "phrase": "escape_states"}, {"score": 0.0023767561522363367, "phrase": "program_site"}, {"score": 0.0021325650133686516, "phrase": "proposed_approach"}, {"score": 0.0021049977753042253, "phrase": "effective_refactoring_suggestions"}], "paper_keywords": ["concurrent", " synchronization", " refactoring", " dependence", " escape analysis"], "paper_abstract": "With the keyword synchronized, Java provides a simple but often over-used synchronization mechanism. Many programmers tend to use a big synchronized section to protect a large block of statements even if many of them are unnecessarily synchronized. Such coarse-gained synchronizations may increase lock contention and thereby decrease the performance of a program, especially in a multi-core environment. The decrease in performance may affect the quality of service provided by the software and hence make the software less trustworthy. To ensure trustworthiness, this paper proposes a source-code level refactoring approach to optimize coarse-gained synchronizations. It exploits dependence and escape information to search for shrinkable critical sections and can transform them into smaller ones automatically. The approach can be used to gradually evolve concurrent code for better quality. In the approach, to achieve more optimizations, we develop a new escape analysis, named escape state analysis, which can not only tell us whether an object finally escapes but also determine the escape states of objects at each program site. With such an analysis, more refactoring opportunities can be found. We build a tool and test our refactoring approach on several benchmark programs. The results show that the proposed approach does make effective refactoring suggestions for the users.", "paper_title": "Finding shrink critical section refactoring opportunities for the evolution of concurrent code in trustworthy software", "paper_id": "WOS:000314426900006"}