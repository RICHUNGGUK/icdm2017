{"auto_keywords": [{"score": 0.04844894171082023, "phrase": "rtsj"}, {"score": 0.00481495049065317, "phrase": "memory_management"}, {"score": 0.004744018246633455, "phrase": "real-time_specification"}, {"score": 0.004697438235280413, "phrase": "java"}, {"score": 0.004448471107649881, "phrase": "explicit_memory_management"}, {"score": 0.004296998284839309, "phrase": "fine_control"}, {"score": 0.004254671386496732, "phrase": "memory_use"}, {"score": 0.00419195822011581, "phrase": "linear_allocation"}, {"score": 0.004150661689086371, "phrase": "constant-time_deallocation"}, {"score": 0.004029187256595917, "phrase": "dynamic_runtime_checks"}, {"score": 0.003853583126988071, "phrase": "critical_applications"}, {"score": 0.003472927015404464, "phrase": "first_class_constructs"}, {"score": 0.0034386894664467003, "phrase": "scopes_reify_allocation_contexts"}, {"score": 0.003371220210416809, "phrase": "safe_alternative"}, {"score": 0.0033379819706003885, "phrase": "automatic_memory_management"}, {"score": 0.003192406091820197, "phrase": "ownership_type_system"}, {"score": 0.0030988889679192965, "phrase": "run-time_patterns"}, {"score": 0.003038066486989815, "phrase": "scopej's_type_system"}, {"score": 0.0029637093924781825, "phrase": "ownership_annotations"}, {"score": 0.002670719148310961, "phrase": "implicit_ownership"}, {"score": 0.002579622880371082, "phrase": "pluggable_type_systems"}, {"score": 0.002504011301105577, "phrase": "different_type_constraints"}, {"score": 0.0024793019587009035, "phrase": "different_components"}, {"score": 0.0023476849595393872, "phrase": "source_language"}, {"score": 0.0023130151703068444, "phrase": "related_work"}, {"score": 0.0021793698531006197, "phrase": "highly-responsive_systems"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["real-time Java", " RTSJ", " type systems", " memory management", " ownership types"], "paper_abstract": "The Real-time Specification for Java (RTSJ) introduced a range of language features for explicit memory management. While the RTSJ gives programmers fine control over memory use and allows linear allocation and constant-time deallocation, the RTSJ relies upon dynamic runtime checks for safety, making it unsuitable for safety critical applications. We introduce ScopeJ, a statically-typed, multi-threaded, object calculus in which scopes are first class constructs. Scopes reify allocation contexts and provide a safe alternative to automatic memory management. Safety follows from the use of an ownership type system that enforces a topology on run-time patterns of references. ScopeJ's type system is novel in that ownership annotations are implicit. This substantially reduces the burden for developers and increases the likelihood of adoption. The notion of implicit ownership is particularly appealing when combined with pluggable type systems, as one can apply different type constraints to different components of an application depending on the requirements without changing the source language. In related work we have demonstrated the usefulness of our approach in the context of highly-responsive systems and stream processing. Published by Elsevier B.V.", "paper_title": "Implicit ownership types for memory management", "paper_id": "WOS:000257402500003"}