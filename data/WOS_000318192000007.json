{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "perfect_shuffling"}, {"score": 0.0038827100184187805, "phrase": "simultaneous_swaps"}, {"score": 0.003287482882222731, "phrase": "first_method"}, {"score": 0.0028662606272282926, "phrase": "second_method"}, {"score": 0.0028106505443369545, "phrase": "general_case"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Algorithms", " Analysis of algorithms", " Combinatorial problems", " Parallel algorithms", " Perfect shuffle", " Permutation", " Involution"], "paper_abstract": "Every permutation of {1, 2, ... , N} can be written as the product of two involutions. As a consequence, any permutation of the elements of an array can be performed in-place using simultaneous swaps in two rounds of swaps. In the case where the permutation is the k-way perfect shuffle, we develop two methods for efficiently computing the pair of involutions that accomplishes these swaps. The first method works whenever N is a power of k; in this case the time is O(N) and space O (log(2) N). The second method applies to the general case where N is a multiple of k; here the time is O (N log N) and the space is O (log(2) N). If k = 2 the space usage of the first method can be reduced to O (log N) on a machine that has a SADD (population count) instruction. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "In-place permuting and perfect shuffling using involutions", "paper_id": "WOS:000318192000007"}