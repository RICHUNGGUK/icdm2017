{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "initial_specification"}, {"score": 0.041562269310917936, "phrase": "dataflow_model"}, {"score": 0.0317853051857015, "phrase": "proposed_technique"}, {"score": 0.03133755014744724, "phrase": "generated_code"}, {"score": 0.004768378525561471, "phrase": "mpsoc_system"}, {"score": 0.0046993598473345395, "phrase": "popular_programming_languages"}, {"score": 0.004498213310668266, "phrase": "sequential_execution"}, {"score": 0.004326624385772596, "phrase": "design_framework"}, {"score": 0.004121275290411653, "phrase": "system_behavior"}, {"score": 0.0040027552011993005, "phrase": "top_level"}, {"score": 0.0037942165191367366, "phrase": "mapping_process"}, {"score": 0.0037030390595465673, "phrase": "architecture_candidate"}, {"score": 0.0036493838225192883, "phrase": "target_code"}, {"score": 0.0035443861412929006, "phrase": "design-space_exploration"}, {"score": 0.003510090471102832, "phrase": "dse"}, {"score": 0.003459191419478298, "phrase": "final_implementation"}, {"score": 0.003310951184365485, "phrase": "parallel_code_generation"}, {"score": 0.003278881936376565, "phrase": "mpsoc"}, {"score": 0.0031231012822640672, "phrase": "functional_and_data_parallelism"}, {"score": 0.0030628762739398855, "phrase": "partition_and_mapping_decision"}, {"score": 0.002917331114260319, "phrase": "multiple_tasks"}, {"score": 0.0028333356794133053, "phrase": "functional_parallelism"}, {"score": 0.002725081358527507, "phrase": "openmp_directives"}, {"score": 0.002685558057339722, "phrase": "data_parallelism"}, {"score": 0.0025578967205807843, "phrase": "code_serialization_technique"}, {"score": 0.0025085435314540837, "phrase": "multitasking_application"}, {"score": 0.0024842242921857705, "phrase": "os_scheduler"}, {"score": 0.0024126686412257407, "phrase": "highly_portable_code"}, {"score": 0.0023546121947302877, "phrase": "efficient_dse_process"}, {"score": 0.002297949552105756, "phrase": "previous_code_serialization_techniques"}, {"score": 0.002220900173110114, "phrase": "formal_properties"}, {"score": 0.0021674482571326283, "phrase": "efficient_code_generation"}], "paper_keywords": ["Design", " Experimentation", " Embedded software", " multiprocessor system on chip", " software generation", " design-space exploration", " parallel programming"], "paper_abstract": "The models of computations that express concurrency naturally are preferred for initial specification of MPSoC system, since popular programming languages such as C and C++ are designed for sequential execution. In our previous work, we proposed a design framework where two models are used for the initial specification of the system behavior; task model at the top level and dataflow model inside each task. After the partition and mapping process is performed with each architecture candidate, the target code is automatically generated for both Design-Space Exploration (DSE) and final implementation. In this article, we focus on parallel code generation for MPSoC, proposing two main techniques. The first is to express functional and data parallelism differently following the partition and mapping decision. In the proposed technique, the generated code consists of multiple tasks running concurrently, which achieves functional parallelism. On the other hand, we use OpenMP directives to express data parallelism inside a task. Second is to adopt the code serialization technique to execute a multitasking application without OS scheduler, aiming to generate the highly portable code on various platforms for an efficient DSE process. We extend the previous code serialization techniques to multiprocessor systems and utilize the formal properties of the dataflow model for efficient code generation. The experiments including H. 263 codec example show the viability of the proposed technique and the efficiency of the generated code.", "paper_title": "Serialized Parallel Code Generation Framework for MPSoC", "paper_id": "WOS:000275118500003"}