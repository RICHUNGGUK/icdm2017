{"auto_keywords": [{"score": 0.02753591178091155, "phrase": "least_memory_footprint"}, {"score": 0.00481495049065317, "phrase": "dynamic_analysis"}, {"score": 0.00477513738640734, "phrase": "scoped_memory_consumption"}, {"score": 0.004599994523941615, "phrase": "real-time_specification"}, {"score": 0.0042864307215634756, "phrase": "garbage_collection_techniques"}, {"score": 0.004198323646273642, "phrase": "scoped_memory_model"}, {"score": 0.004163587877500036, "phrase": "new_challenges"}, {"score": 0.003895810929926511, "phrase": "application's_memory_model"}, {"score": 0.003784120134537663, "phrase": "abstract_model"}, {"score": 0.0037527984559873745, "phrase": "scoped_memory"}, {"score": 0.003660374693346876, "phrase": "different_applications"}, {"score": 0.0035554096354423756, "phrase": "appropriate_number"}, {"score": 0.003340475943517995, "phrase": "straightforward_tasks"}, {"score": 0.003151572886432253, "phrase": "railway_control_system"}, {"score": 0.003010651173285521, "phrase": "critical_safety_real-time_applications"}, {"score": 0.0029858772162019505, "phrase": "java"}, {"score": 0.0028760125558659907, "phrase": "possible_scoped_memory_design_models"}, {"score": 0.002805121439110729, "phrase": "multi-threaded_environments"}, {"score": 0.002528021281333922, "phrase": "memory_design_model"}, {"score": 0.002496659907186784, "phrase": "higher_number"}, {"score": 0.002297274552621268, "phrase": "satisfactory_memory_footprint"}, {"score": 0.0021853532419450887, "phrase": "important_factor"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Real-time simulation", " RTSJ scoped memory", " Immortal memory", " Memory consumption", " Railway control system", " Real-time Java"], "paper_abstract": "For critical, real-time applications, scoped memory management in Real-Time Specification for Java (RTSJ) achieves a level of predictability not found in applications that use garbage collection techniques. However, a scoped memory model creates new challenges for developers. First, the reference rules between scopes constrain the design of the application's memory model. Second, there is no abstract model for scoped memory that can be applied to different applications. Third, deciding on the appropriate number of scopes and which objects or threads should be allocated into those scopes are not straightforward tasks and require tools to assist. This paper presents a simulation of a railway control system executed on the Sun RTS2.2 virtual machine: it illustrates how simulation of critical safety real-time applications in Java can be used to investigate the implementation of possible scoped memory design models and their memory consumption in multi-threaded environments. The simulation demonstrates that a developer is able to compare and choose the most appropriate scoped memory design model that achieves the least memory footprint. Results showed that the memory design model with a higher number of scopes achieved the least memory footprint. However, the number of scopes per se does not always indicate a satisfactory memory footprint: choosing the right objects/threads to be allocated into scopes is an important factor to be considered. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Simulation of safety-critical, real-time Java: A case study of dynamic analysis of scoped memory consumption", "paper_id": "WOS:000305100600012"}