{"auto_keywords": [{"score": 0.047019075018547234, "phrase": "formal_equivalence_verification"}, {"score": 0.00481495049065317, "phrase": "auto-correction_mechanism"}, {"score": 0.004777755475470599, "phrase": "rtl"}, {"score": 0.004336115760817672, "phrase": "lower_level_methods"}, {"score": 0.004252793268613575, "phrase": "sat_solvers"}, {"score": 0.0042035670399069485, "phrase": "space_and_time_explosion_problems"}, {"score": 0.004122781047853192, "phrase": "industrial_designs"}, {"score": 0.003904713104101532, "phrase": "datapath_intensive_designs"}, {"score": 0.003844545552246988, "phrase": "canonical_decision_diagram"}, {"score": 0.0038148090091532933, "phrase": "homer_expansion_diagram"}, {"score": 0.0035989687070420977, "phrase": "different_levels"}, {"score": 0.0033170847930578473, "phrase": "equivalence_checking_problem"}, {"score": 0.003253279945540651, "phrase": "exponential_path_enumeration_problem"}, {"score": 0.0032031180198375283, "phrase": "internal_equivalent_conditional_expressions"}, {"score": 0.0031537270875516108, "phrase": "suitable_merge_points"}, {"score": 0.003033546013625887, "phrase": "buggy_implementation"}, {"score": 0.002817639725689939, "phrase": "simple_heuristic"}, {"score": 0.0027102313244646934, "phrase": "multiple_errors"}, {"score": 0.002536926192232391, "phrase": "due_to_merge-point_detection"}, {"score": 0.0024118962715000197, "phrase": "smt_solvers"}, {"score": 0.002383927474257582, "phrase": "equivalent_conditions"}, {"score": 0.0023289568500915207, "phrase": "proposed_debugging_technique"}, {"score": 0.00227525089435209, "phrase": "unnecessary_mutants"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Equivalence checking", " Formal verification", " Debugging", " RTL designs"], "paper_abstract": "By increasing the complexity of system on chip (SoC) designs formal equivalence verification and debugging have become more and more important. Lower level methods such as BDDs and SAT solvers suffer from space and time explosion problems to match sizes of industrial designs in formal equivalence verification and debugging. This paper proposes techniques to verify and debug datapath intensive designs based on a canonical decision diagram called Homer Expansion Diagram (HED). It allows us to check the equivalence between two models in different levels of abstraction, e.g., a Register Transfer Level (RTL) implementation and a non-cycle-accurate specification. In order to reduce the complexity of equivalence checking problem, we tackle the exponential path enumeration problem by automatically identifying internal equivalent conditional expressions as well as suitable merge points. Our debugging technique is based on introducing mutations into the buggy implementation and then observing if the specification is capable of detecting these changes. We make use of a simple heuristic to reduce the number of mutants when dealing with multiple errors. We report the results of deploying our equivalence verification technique on several industrial designs which show 16.8x average memory usage reduction and 8.0x speedup due to merge-point detection. Furthermore, our debugging technique shows 13.7x average memory usage reduction and 4.6x speedup due to using SMT solvers to find equivalent conditions. In addition, the proposed debugging technique can avoid the computation of unnecessary mutants so that the results show 2.9x average reduction of the number of mutants to be processed. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Formal equivalence verification and debugging techniques with auto-correction mechanism for RTL designs", "paper_id": "WOS:000329417200002"}