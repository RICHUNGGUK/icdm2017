{"auto_keywords": [{"score": 0.04317179544664411, "phrase": "arithmetic_operations"}, {"score": 0.00481495049065317, "phrase": "bit-level_delay_calculations"}, {"score": 0.004753194996637899, "phrase": "read-after-write_dependences"}, {"score": 0.0037348894128879082, "phrase": "presynthesis_optimization_algorithm"}, {"score": 0.003686935223424015, "phrase": "raw_dependences"}, {"score": 0.003426556090707852, "phrase": "logic_operations"}, {"score": 0.003382547312072468, "phrase": "presented_preprocessor"}, {"score": 0.0033391018638565715, "phrase": "critical_path"}, {"score": 0.003310447652300423, "phrase": "bit_granularity"}, {"score": 0.0032259472087775138, "phrase": "subword_fragments"}, {"score": 0.0031032109441552287, "phrase": "regular_hls_tool"}, {"score": 0.003050166508545763, "phrase": "circuit_execution_times"}, {"score": 0.0029980260560551982, "phrase": "different_cycles"}, {"score": 0.0025230952890994236, "phrase": "selected_cycle"}, {"score": 0.0024799423362011582, "phrase": "previous_one"}, {"score": 0.002375253757224999, "phrase": "posterior_cycle"}, {"score": 0.0023447155524245655, "phrase": "experimental_results"}, {"score": 0.002236055625099805, "phrase": "optimized_specification"}, {"score": 0.0021049977753042253, "phrase": "data_path_area"}], "paper_keywords": ["allocation", " circuit synthesis", " design automation", " scheduling"], "paper_abstract": "Conventional high-level synthesis (HLS) algorithms are very conservative when dealing with read-after-write (RAW) dependences, the execution of one operation is allowed once all its predecessors have been calculated. However, in the execution of arithmetic operations, some bits are required later than others, and some bits are produced earlier than others. This paper proposes a presynthesis optimization algorithm that relaxes RAW dependences, taking advantage of this feature for a more efficient HLS of data How graphs formed by additions, multiplications, and logic operations. The presented preprocessor analyzes the critical path at bit granularity and splits the arithmetic operations into subword fragments. These fragments become the input to any regular HLS tool to speed up circuit execution times through scheduling in different cycles of the fragments obtained from the same original operation. This way, the execution of one operation may begin before the calculus of its predecessors has been completed. This becomes feasible when the execution of the predecessor has begun in the selected cycle or in a previous one, and even if it will finish in a posterior cycle. The experimental results that were carried out show that implementations obtained from the optimized specification are, on the average, 70% faster, with only slight variations in the data path area.", "paper_title": "Exploiting bit-level delay calculations to soften read-after-write dependences in behavioral synthesis", "paper_id": "WOS:000249309200005"}