{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "operation_and_data_mapping"}, {"score": 0.0047152877145889656, "phrase": "multi-bank_memory"}, {"score": 0.004666228956744244, "phrase": "coarse_grain_reconfigurable_architectures"}, {"score": 0.004545793387330536, "phrase": "high_performance"}, {"score": 0.004498490110526062, "phrase": "high_power_efficiency"}, {"score": 0.0040942189695983185, "phrase": "application_mapping"}, {"score": 0.003926359151817743, "phrase": "data_mapping"}, {"score": 0.0037066895459425824, "phrase": "multi-bank_local_memory"}, {"score": 0.003554661425339528, "phrase": "memory_access"}, {"score": 0.003320756562046789, "phrase": "memory_bank"}, {"score": 0.003234934827553253, "phrase": "hardware_arbiter"}, {"score": 0.0031845067058084583, "phrase": "memory_requests"}, {"score": 0.0030220049006970317, "phrase": "local_memory"}, {"score": 0.0029438813080245544, "phrase": "fundamental_restriction"}, {"score": 0.0026096659285441384, "phrase": "application_operations"}, {"score": 0.0025288869172313674, "phrase": "memory_banks"}, {"score": 0.002374735066990346, "phrase": "multimedia_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "memory-unaware_scheduler"}], "paper_keywords": ["Coarse-grained Reconfigurable Architecture", " Compilation", " Multi-bank Memory", " Bank conflict", " Arbiter"], "paper_abstract": "Coarse Grain Reconfigurable Architectures (CGRAs) promise high performance at high power efficiency. They fulfil this promise by keeping the hardware extremely simple, and moving the complexity to application mapping. One major challenge comes in the form of data mapping. For reasons of power-efficiency and complexity, CGRAs use multi-bank local memory, and a row of PEs share memory access. In order for each row of the PEs to access any memory bank, there is a hardware arbiter between the memory requests generated by the PEs and the banks of the local memory. However, a fundamental restriction remains that a bank cannot be accessed by two different PEs at the same time. We propose to meet this challenge by mapping application operations onto PEs and data into memory banks in a way that avoids such conflicts. Our experimental results on kernels from multimedia benchmarks demonstrate that our local memory-aware compilation approach can generate mappings that are up to 40% better in performance (17.3% on average) compared to a memory-unaware scheduler.", "paper_title": "Operation and Data Mapping for CGRAs with Multi-bank Memory", "paper_id": "WOS:000277056500003"}