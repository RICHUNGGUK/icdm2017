{"auto_keywords": [{"score": 0.02822567831132137, "phrase": "xml_projection"}, {"score": 0.00481495049065317, "phrase": "xlynx-an_fpga-based_xml_filter"}, {"score": 0.004772818068176176, "phrase": "hybrid_xquery_processing"}, {"score": 0.004689650818647484, "phrase": "unique_performance"}, {"score": 0.004648609688625397, "phrase": "energy-saving_advantages"}, {"score": 0.004547564208690591, "phrase": "field-programmable_gate_arrays"}, {"score": 0.004448705308279165, "phrase": "database_acceleration"}, {"score": 0.00439041997682389, "phrase": "major_concessions"}, {"score": 0.0043519860930099795, "phrase": "system_designers"}, {"score": 0.00427612041204006, "phrase": "programmable_chips"}, {"score": 0.004074212307838049, "phrase": "rigid_class"}, {"score": 0.003539363169127793, "phrase": "fpga"}, {"score": 0.003492840830999027, "phrase": "xml_filter-we"}, {"score": 0.003372019835750424, "phrase": "design_principle"}, {"score": 0.003342471131048328, "phrase": "data-intensive_hardware_circuits"}, {"score": 0.003255364511414329, "phrase": "quick_reconfiguration"}, {"score": 0.0031289290660162145, "phrase": "generic_implementation"}, {"score": 0.0030608148631528767, "phrase": "finite-state_automata"}, {"score": 0.0029548937818509656, "phrase": "particular_automaton_instance"}, {"score": 0.002753891109273246, "phrase": "complete_recompilation"}, {"score": 0.002693919110230191, "phrase": "skeleton_automata"}, {"score": 0.0026352524271600806, "phrase": "marian"}, {"score": 0.002248816575548875, "phrase": "performance_improvements"}, {"score": 0.0021709339252206825, "phrase": "back-end_xml_processor"}, {"score": 0.0021049977753042253, "phrase": "saxon_engine"}], "paper_keywords": ["Design", " Performance", " FPGA", " XML", " XQuery", " projection", " skeleton automaton"], "paper_abstract": "While offering unique performance and energy-saving advantages, the use of Field-Programmable Gate Arrays (FPGAs) for database acceleration has demanded major concessions from system designers. Either the programmable chips have been used for very basic application tasks (such as implementing a rigid class of selection predicates) or their circuit definition had to be completely recompiled at runtime-a very CPU-intensive and time-consuming effort. This work eliminates the need for such concessions. As part of our XLynx implementation-an FPGA-based XML filter-we present skeleton automata, which is a design principle for data-intensive hardware circuits that offers high expressiveness and quick reconfiguration at the same time. Skeleton automata provide a generic implementation for a class of finite-state automata. They can be parameterized to any particular automaton instance in a matter of microseconds or less (as opposed to minutes or hours for complete recompilation). We showcase skeleton automata based on XML projection [Marian and Simeon 2003], a filtering technique that illustrates the feasibility of our strategy for a real-world and challenging task. By performing XML projection in hardware and filtering data in the network, we report on performance improvements of several factors while remaining nonintrusive to the back-end XML processor (we evaluate XLynx using the Saxon engine).", "paper_title": "XLynx-An FPGA-Based XML Filter for Hybrid XQuery Processing", "paper_id": "WOS:000329123100004"}