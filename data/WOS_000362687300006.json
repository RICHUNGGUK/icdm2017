{"auto_keywords": [{"score": 0.03859868948574288, "phrase": "verification_systems"}, {"score": 0.00481495049065317, "phrase": "authors'_experience"}, {"score": 0.004513957235071457, "phrase": "software_verification_competition"}, {"score": 0.003143770356470388, "phrase": "java"}, {"score": 0.0027622407190589326, "phrase": "key_system"}, {"score": 0.002304606411453748, "phrase": "real-world_programming_languages"}, {"score": 0.0022168460543913787, "phrase": "powerful_abstraction_capabilities"}, {"score": 0.0021049977753042253, "phrase": "key_tool"}], "paper_keywords": ["Formal verification", " Benchmark", " Java Modeling Language", " Theorem prover"], "paper_abstract": "We give an account on the authors' experience and results from the software verification competition held at the Formal Methods 2012 conference. Competitions like this are meant to provide a benchmark for verification systems. It consisted of three algorithms which the authors have implemented in Java, specified with the Java Modeling Language, and verified using the KeY system. Building on our solutions, we argue that verification systems which target implementations in real-world programming languages better have powerful abstraction capabilities. Regarding the KeY tool, we explain features which, driven by the competition, have been freshly implemented to accommodate for these demands.", "paper_title": "Implementation-level verification of algorithms with KeY", "paper_id": "WOS:000362687300006"}