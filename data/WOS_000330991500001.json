{"auto_keywords": [{"score": 0.03559401317904641, "phrase": "ccds_problem"}, {"score": 0.010137540151407068, "phrase": "ccds"}, {"score": 0.009199933600668592, "phrase": "international_symposium"}, {"score": 0.009101224159819928, "phrase": "distributed_computing"}, {"score": 0.006389105478315291, "phrase": "message_size"}, {"score": 0.005907063471010221, "phrase": "link_detector"}, {"score": 0.00481495049065317, "phrase": "unreliable_radio_networks"}, {"score": 0.004451142490911742, "phrase": "communication_backbone"}, {"score": 0.004403158130041613, "phrase": "dual_graph_radio_network_model"}, {"score": 0.00437936051025218, "phrase": "clementi"}, {"score": 0.004320421465896323, "phrase": "j_parallel_distrib_comput"}, {"score": 0.004239232828870618, "phrase": "kuhn_et_al"}, {"score": 0.00420516885834521, "phrase": "proceedings"}, {"score": 0.004092463367307375, "phrase": "distrib_comput"}, {"score": 0.003642114262258148, "phrase": "real_networks"}, {"score": 0.003602819853062483, "phrase": "differing_quality"}, {"score": 0.00357362651129581, "phrase": "low-layer_detection_protocols"}, {"score": 0.003525493807130663, "phrase": "reliable_links"}, {"score": 0.0033484084676428257, "phrase": "dual_graph_model"}, {"score": 0.003249966782844541, "phrase": "local_link_detector"}, {"score": 0.0031629800646754505, "phrase": "reliable_link"}, {"score": 0.003069973098301674, "phrase": "high_probability"}, {"score": 0.0030286034168878835, "phrase": "maximum_degree"}, {"score": 0.0030040488740349664, "phrase": "reliable_link_graph"}, {"score": 0.0029716179574996626, "phrase": "network_size"}, {"score": 0.002931569771634119, "phrase": "upper_bound"}, {"score": 0.002845347968246455, "phrase": "first_building"}, {"score": 0.0028222888314932536, "phrase": "mis"}, {"score": 0.0027541694378728004, "phrase": "local_topology_knowledge"}, {"score": 0.002724428781940696, "phrase": "nearby_mis_processes"}, {"score": 0.0027023336645699897, "phrase": "natural_follow-up_question"}, {"score": 0.002497750121448195, "phrase": "polylog_time"}, {"score": 0.0024640724199520877, "phrase": "unreliable_links"}, {"score": 0.0023211909152089606, "phrase": "possible_inclusion"}, {"score": 0.002289888334496528, "phrase": "process's_local_link_detector"}, {"score": 0.0021049977753042253, "phrase": "reliable_and_unreliable_links"}], "paper_keywords": ["Radio networks", " Maximal independent set", " Connected dominating set", " Link detector"], "paper_abstract": "In this paper we study the problem of building a constant-degree connected dominating set (CCDS), a network structure that can be used as a communication backbone, in the dual graph radio network model (Clementi et al. in J Parallel Distrib Comput 64:89-96, 2004; Kuhn et al. in Proceedings of the international symposium on principles of distributed computing 2009, Distrib Comput 24(3-4):187-206 2011, Proceedings of the international symposium on principles of distributed computing 2010). This model includes two types of links: reliable, which always deliver messages, and unreliable, which sometimes fail to deliver messages. Real networks compensate for this differing quality by deploying low-layer detection protocols to filter unreliable from reliable links. With this in mind, we begin by presenting an algorithm that solves the CCDS problem in the dual graph model under the assumption that every process is provided with a local link detector set consisting of every neighbor connected to by a reliable link. The algorithm solves the CCDS problem in rounds, with high probability, where is the maximum degree in the reliable link graph, is the network size, and is an upper bound in bits on the message size. The algorithm works by first building a Maximal Independent Set (MIS) in time, and then leveraging the local topology knowledge to efficiently connect nearby MIS processes. A natural follow-up question is whether the link detector must be perfectly reliable to solve the CCDS problem. With this in mind, we first describe an algorithm that builds a CCDS in polylog time under the assumption of unreliable links included in each link detector set. We then prove this algorithm to be (almost) tight by showing that the possible inclusion of only a single unreliable link in each process's local link detector set is sufficient to require rounds to solve the CCDS problem, regardless of message size. We conclude by discussing how to apply our algorithm in the setting where the topology of reliable and unreliable links can change over time.", "paper_title": "Structuring unreliable radio networks", "paper_id": "WOS:000330991500001"}