{"auto_keywords": [{"score": 0.03328384181526809, "phrase": "mix"}, {"score": 0.00481495049065317, "phrase": "static_analysis_designers"}, {"score": 0.004223032986655664, "phrase": "coding_idioms"}, {"score": 0.0038692638652494697, "phrase": "tool's_implementation"}, {"score": 0.003607630811220324, "phrase": "tool's_results"}, {"score": 0.003545024951402821, "phrase": "software_systems"}, {"score": 0.003408091901859624, "phrase": "significant_algorithmic_engineering"}, {"score": 0.0032621183241997777, "phrase": "particular_software_domain"}, {"score": 0.0030547611342112693, "phrase": "type_checking"}, {"score": 0.0030281251520610604, "phrase": "symbolic_execution"}, {"score": 0.0029886047149545025, "phrase": "key_aspect"}, {"score": 0.0028480459059007468, "phrase": "disjoint_parts"}, {"score": 0.0027620516806198354, "phrase": "off-the-shelf_manner"}, {"score": 0.002690406375639144, "phrase": "nested_type"}, {"score": 0.0025750928944698673, "phrase": "special_mix_rules"}, {"score": 0.002508284945907166, "phrase": "off-the-shelf_systems"}, {"score": 0.0024325244760735566, "phrase": "provably_sound_analysis"}, {"score": 0.002297831085501592, "phrase": "exclusive_symbolic_execution"}, {"score": 0.002208966376185464, "phrase": "prototype_implementation"}, {"score": 0.0021896891011033105, "phrase": "mixy"}, {"score": 0.0021610874773389096, "phrase": "c._mixy_checks"}, {"score": 0.0021422271362195734, "phrase": "potential_null_dereferences"}], "paper_keywords": ["Languages", " Verification", " Mix", " mixed off-the-shelf analysis", " symbolic execution", " type checking", " mix rules", " false alarms", " precision"], "paper_abstract": "Static analysis designers must carefully balance precision and efficiency. In our experience, many static analysis tools are built around an elegant, core algorithm, but that algorithm is then extensively tweaked to add just enough precision for the coding idioms seen in practice, without sacrificing too much efficiency. There are several downsides to adding precision in this way: the tool's implementation becomes much more complicated; it can be hard for an end-user to interpret the tool's results; and as software systems vary tremendously in their coding styles, it may require significant algorithmic engineering to enhance a tool to perform well in a particular software domain. In this paper, we present MIX, a novel system that mixes type checking and symbolic execution. The key aspect of our approach is that these analyses are applied independently on disjoint parts of the program, in an off-the-shelf manner. At the boundaries between nested type checked and symbolically executed code regions, we use special mix rules to communicate information between the off-the-shelf systems. The resulting mixture is a provably sound analysis that is more precise than type checking alone and more efficient than exclusive symbolic execution. In addition, we also describe a prototype implementation, MIXY, for C. MIXY checks for potential null dereferences by mixing a null/non-null type qualifier inference system with a symbolic executor.", "paper_title": "Mixing Type Checking and Symbolic Execution", "paper_id": "WOS:000279357500037"}