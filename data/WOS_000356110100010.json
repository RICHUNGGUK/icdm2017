{"auto_keywords": [{"score": 0.041819278160957776, "phrase": "source_code"}, {"score": 0.00481495049065317, "phrase": "query-based_techniques"}, {"score": 0.004767546015485477, "phrase": "anti-pattern_detection"}, {"score": 0.0046741260449047976, "phrase": "program_queries"}, {"score": 0.004605258779434384, "phrase": "important_role"}, {"score": 0.004448471107649881, "phrase": "impact_analysis"}, {"score": 0.004361276005140776, "phrase": "automated_identification"}, {"score": 0.00427578268550103, "phrase": "complex_refactoring_operations"}, {"score": 0.004212759658511567, "phrase": "central_artifact"}, {"score": 0.004089475312474684, "phrase": "reverse_engineered_program_model"}, {"score": 0.003911253966141701, "phrase": "abstract_semantic_graph"}, {"score": 0.0034386894664467003, "phrase": "popular_industrial_eclipse_modeling_framework"}, {"score": 0.0033379819706003885, "phrase": "underlying_representation"}, {"score": 0.0033050703534275717, "phrase": "program_models"}, {"score": 0.003192582264877623, "phrase": "java"}, {"score": 0.0031453010852936334, "phrase": "ocl_evaluation"}, {"score": 0.0028484940955893134, "phrase": "anti-pattern_queries"}, {"score": 0.002806449337145999, "phrase": "refactoring_operations"}, {"score": 0.0027787638791664663, "phrase": "different_usage_profiles"}, {"score": 0.0026839922027139967, "phrase": "general_purpose_model_queries"}, {"score": 0.0026443691099806003, "phrase": "hand-coded_queries"}, {"score": 0.0024793019587009035, "phrase": "memory_consumption"}, {"score": 0.002454835845644037, "phrase": "model_load_time"}, {"score": 0.0023130151703068444, "phrase": "measurement_results"}, {"score": 0.0022901862321082407, "phrase": "usage_profiles"}, {"score": 0.0021902063413831545, "phrase": "appropriate_query_technologies"}, {"score": 0.002168586864007222, "phrase": "concrete_scenarios"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Anti-patterns", " Refactoring", " Performance measurements", " Columbus", " EMF-IncQuery", " OCL"], "paper_abstract": "Context: Program queries play an important role in several software evolution tasks like program comprehension, impact analysis, or the automated identification of anti-patterns for complex refactoring operations. A central artifact of these tasks is the reverse engineered program model built up from the source code (usually an Abstract Semantic Graph, ASG), which is traditionally post-processed by dedicated, hand-coded queries. Objective: Our paper investigates the costs and benefits of using the popular industrial Eclipse Modeling Framework (EMF) as an underlying representation of program models processed by four different general-purpose model query techniques based on native Java code, OCL evaluation and (incremental) graph pattern matching. Method: We provide in-depth comparison of these techniques on the source code of 28 Java projects using anti-pattern queries taken from refactoring operations in different usage profiles. Results: Our results show that general purpose model queries can outperform hand-coded queries by 2-3 orders of magnitude, with the trade-off of an increased in memory consumption and model load time of up to an order of magnitude. Conclusion: The measurement results of usage profiles can be used as guidelines for selecting the appropriate query technologies in concrete scenarios. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Performance comparison of query-based techniques for anti-pattern detection", "paper_id": "WOS:000356110100010"}