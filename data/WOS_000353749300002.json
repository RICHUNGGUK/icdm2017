{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "divergent_applications"}, {"score": 0.010442007369047508, "phrase": "neural_networks"}, {"score": 0.004775918707955445, "phrase": "simd_architectures"}, {"score": 0.004529776351030488, "phrase": "neural-network-based_solution"}, {"score": 0.0044747919503484055, "phrase": "well-known_problem"}, {"score": 0.004384623928442369, "phrase": "single_instruction_multiple_data"}, {"score": 0.004226856126282259, "phrase": "existing_techniques"}, {"score": 0.00399260264462941, "phrase": "costly_hardware_modifications"}, {"score": 0.003960210592458847, "phrase": "low-utilization_masking_techniques"}, {"score": 0.003912112659326054, "phrase": "static_prediction_methods"}, {"score": 0.003725470458263889, "phrase": "data-dependent_control_flow"}, {"score": 0.0036207206487324506, "phrase": "code_regions"}, {"score": 0.003447932289587852, "phrase": "branch_divergence"}, {"score": 0.003217124533918232, "phrase": "nn_computations"}, {"score": 0.0029773436815290215, "phrase": "nondivergent_computation"}, {"score": 0.0028467558213723697, "phrase": "application_source_code"}, {"score": 0.00278930116312699, "phrase": "inherently_platform_agnostic"}, {"score": 0.0026452734009203764, "phrase": "data-parallel_architectures"}, {"score": 0.0025499307228648883, "phrase": "neuralizer"}, {"score": 0.0024781515864648242, "phrase": "kernel_identification"}, {"score": 0.0024580159789774516, "phrase": "nn_training"}, {"score": 0.0024281181691350085, "phrase": "nn_integration"}, {"score": 0.002379092507901856, "phrase": "supplementary_user-controlled_optimization_techniques"}, {"score": 0.0022561982694417116, "phrase": "graphics_processing_unit"}, {"score": 0.0022379189035387943, "phrase": "gpu"}, {"score": 0.0021748483128942687, "phrase": "performance_gains"}, {"score": 0.0021396386320044172, "phrase": "energy_savings"}], "paper_keywords": ["Design", " Performance"], "paper_abstract": "The purpose of this research is to find a neural-network-based solution to the well-known problem of branch divergence in Single Instruction Multiple Data (SIMD) architectures. Our approach differs from existing techniques that handle branch (or control-flow) divergence, which use costly hardware modifications, low-utilization masking techniques, or static prediction methods. As we examine divergent applications, we characterize the degree of data-dependent control flow seen in each and isolate the code regions (or \"kernels\") that cause the most performance degradation due to branch divergence. We then train neural networks (NNs) offline to approximate these kernels and inject the NN computations directly into the applications as substitutes for the kernels they approximate. This essentially translates control flow into nondivergent computation, trading off precision for performance. As our methodology manipulates application source code directly, it is inherently platform agnostic and can be adopted as a general means for accelerating divergent applications on data-parallel architectures. In this article, we present the Neuralizer, an automated software flow for kernel identification, NN training, and NN integration, as well as supplementary user-controlled optimization techniques. Evaluating our approach on a variety of divergent applications run on a Graphics Processing Unit (GPU), we on average achieve performance gains of 13.6x and energy savings of 14.8x with 96% accuracy.", "paper_title": "Accelerating Divergent Applications on SIMD Architectures Using Neural Networks", "paper_id": "WOS:000353749300002"}