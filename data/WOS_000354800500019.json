{"auto_keywords": [{"score": 0.03442030305452377, "phrase": "ts_stack"}, {"score": 0.00481495049065317, "phrase": "concurrent_data-structures"}, {"score": 0.0045591142048535165, "phrase": "total_order"}, {"score": 0.004177631185971939, "phrase": "insert_methods"}, {"score": 0.004057670872363875, "phrase": "new_approach"}, {"score": 0.003969957613513855, "phrase": "unnecessary_ordering"}, {"score": 0.0036775717816768133, "phrase": "eventual_removal"}, {"score": 0.0035849585026689573, "phrase": "new_non-blocking_data-structure"}, {"score": 0.0035460209934762192, "phrase": "ts"}, {"score": 0.003381905288924267, "phrase": "corresponding_queue"}, {"score": 0.003357343256340741, "phrase": "deque_data-structures"}, {"score": 0.0030986183831544487, "phrase": "elimination-backoff_stack"}, {"score": 0.0029230308228548807, "phrase": "less-contended_removal"}, {"score": 0.0026976845075643314, "phrase": "weak_internal_ordering"}, {"score": 0.002591595184168144, "phrase": "standard_techniques"}, {"score": 0.0025633909553815534, "phrase": "linearization_points"}, {"score": 0.0024987660207458555, "phrase": "total_internal_order"}, {"score": 0.002453602802736223, "phrase": "new_stack_theorem"}, {"score": 0.0024180630823331427, "phrase": "isabelle"}, {"score": 0.002339953069296797, "phrase": "stack_semantics"}, {"score": 0.0021049977753042253, "phrase": "future_weakly_ordered_data-structure_designs"}], "paper_keywords": ["concurrent stack", " linearizability", " timestamps", " verification"], "paper_abstract": "Concurrent data-structures, such as stacks, queues, and deques, often implicitly enforce a total order over elements in their underlying memory layout. However, much of this order is unnecessary: linearizability only requires that elements are ordered if the insert methods ran in sequence. We propose a new approach which uses timestamping to avoid unnecessary ordering. Pairs of elements can be left unordered if their associated insert operations ran concurrently, and order imposed as necessary at the eventual removal. We realise our approach in a new non-blocking data-structure, the TS (timestamped) stack. Using the same approach, we can define corresponding queue and deque data-structures. In experiments on x86, the TS stack outperforms and outscales all its competitors - for example, it outperforms the elimination-backoff stack by factor of two. In our approach, more concurrency translates into less ordering, giving less-contended removal and thus higher performance and scalability. Despite this, the TS stack is linearizable with respect to stack semantics. The weak internal ordering in the TS stack presents a challenge when establishing linearizability: standard techniques such as linearization points work well when there exists a total internal order. We present a new stack theorem, mechanised in Isabelle, which characterises the orderings sufficient to establish stack semantics. By applying our stack theorem, we show that the TS stack is indeed linearizable. Our theorem constitutes a new, generic proof technique for concurrent stacks, and it paves the way for future weakly ordered data-structure designs.", "paper_title": "A Scalable, Correct Time-Stamped Stack", "paper_id": "WOS:000354800500019"}