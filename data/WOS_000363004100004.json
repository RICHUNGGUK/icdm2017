{"auto_keywords": [{"score": 0.049850756629456816, "phrase": "memory_consistency_model_emulation"}, {"score": 0.016476409627057827, "phrase": "memory_fences"}, {"score": 0.01628313681381079, "phrase": "translated_code"}, {"score": 0.010612387000973441, "phrase": "transactional_execution"}, {"score": 0.009977016705923871, "phrase": "system_emulation"}, {"score": 0.009650643740091253, "phrase": "cross-isa_emulation"}, {"score": 0.006610198859829224, "phrase": "host_machine"}, {"score": 0.005607340046320333, "phrase": "transaction_overhead"}, {"score": 0.0047013405841819025, "phrase": "today's_computer_systems"}, {"score": 0.0046455401533064804, "phrase": "new_opportunities"}, {"score": 0.004623405003209069, "phrase": "resource_sharing"}, {"score": 0.004568525347438891, "phrase": "system_security"}, {"score": 0.004503525064934708, "phrase": "different_instruction"}, {"score": 0.004492781547269096, "phrase": "set_architectures"}, {"score": 0.004345024152234371, "phrase": "workload_consolidation"}, {"score": 0.004313996835376177, "phrase": "wide_range"}, {"score": 0.004242455001883514, "phrase": "seamless_deployment"}, {"score": 0.004222232331707683, "phrase": "new_processor_architectures"}, {"score": 0.004192078165260057, "phrase": "multicore_and_manycore_processors"}, {"score": 0.004006019898805405, "phrase": "key_challenge"}, {"score": 0.0038465304237380125, "phrase": "host_memory_consistency_models"}, {"score": 0.0036757520959883865, "phrase": "significant_performance_degradation"}, {"score": 0.0036582208257729923, "phrase": "recently_proposed_parallel_emulators"}, {"score": 0.003606125297580155, "phrase": "performance_limitation"}, {"score": 0.003554768997914028, "phrase": "limited_support"}, {"score": 0.003504141512080878, "phrase": "host_system"}, {"score": 0.0034790978593553794, "phrase": "weaker_memory_consistency_model"}, {"score": 0.0034459835582278746, "phrase": "guest_system"}, {"score": 0.0033806943112103397, "phrase": "appropriate_locations"}, {"score": 0.00332457836509422, "phrase": "guest_memory_ordering_constraints"}, {"score": 0.003222814590544802, "phrase": "transactional_execution_support"}, {"score": 0.003176899769744057, "phrase": "alternative_approach"}, {"score": 0.0031241559930784914, "phrase": "sequential_consistency"}, {"score": 0.0030796423997279335, "phrase": "coarse-grained_transaction_level"}, {"score": 0.003021272984126523, "phrase": "memory_accesses"}, {"score": 0.0029711108655469634, "phrase": "sc."}, {"score": 0.0029078224462409795, "phrase": "emulated_execution"}, {"score": 0.0028663823531914594, "phrase": "guest_memory_model"}, {"score": 0.0027194107909039957, "phrase": "intel_haswell_processor"}, {"score": 0.002661474607275484, "phrase": "state-of-the-art_parallel_emulator"}, {"score": 0.002648768009464535, "phrase": "coremu"}, {"score": 0.002579955584976383, "phrase": "transaction_sizes"}, {"score": 0.0025189474369510857, "phrase": "transaction_conflict_rate"}, {"score": 0.002406968743305622, "phrase": "hybrid_implementation"}, {"score": 0.0022889719606488898, "phrase": "parsec_benchmark_suites"}, {"score": 0.0022617389804167943, "phrase": "proposed_hybrid_approach"}, {"score": 0.0022294857939412073, "phrase": "fence_insertion_mechanism"}, {"score": 0.002171542198410875, "phrase": "two-thread_applications"}, {"score": 0.0021049977753042253, "phrase": "four-threaded_execution"}], "paper_keywords": ["Reliability", " Experimentation", " Performance", " Parallel emulators", " memory consistency models", " transactional memory"], "paper_abstract": "System emulation is widely used in today's computer systems. This technology opens new opportunities for resource sharing as well as enhancing system security and reliability. System emulation across different instruction set architectures (ISA) can enable further opportunities. For example, cross-ISA emulation can enable workload consolidation over a wide range of microprocessors and potentially facilitate the seamless deployment of new processor architectures. As multicore and manycore processors become pervasive, it is important to address the challenges toward supporting system emulation on these platforms. A key challenge in cross-ISA emulation on multicore systems is ensuring the correctness of emulation when the guest and the host memory consistency models differ. Many existing cross-ISA system emulators are sequential, thus they are able to avoid this problem at the cost of significant performance degradation. Recently proposed parallel emulators are able to address the performance limitation; however, they provide limited support for memory consistency model emulation. When the host system has a weaker memory consistency model compared to the guest system, the emulator can insert memory fences at appropriate locations in the translated code to enforce the guest memory ordering constraints. These memory fences can significantly degrade the performance of the translated code. Transactional execution support available on certain recent microprocessors provides an alternative approach. Transactional execution of the translated code enforces sequential consistency (SC) at the coarse-grained transaction level, which in turn ensures that all memory accesses made on the host machine conform to SC. Enforcing SC on the host machine guarantees that the emulated execution will be correct for any guest memory model. In this article, we compare and evaluate the overheads associated with using transactions and fences for memory consistency model emulation on the Intel Haswell processor. Our experience of implementing these two approaches on a state-of-the-art parallel emulator, COREMU, demonstrates that memory consistency model emulation using transactions performs better when the transaction sizes are large enough to amortize the transaction overhead and the transaction conflict rate is low, whereas inserting memory fences is better for applications in which the transaction overhead is high. A hybrid implementation that dynamically determines which approach to invoke can outperform both approaches. Our results, based on the SPLASH-2 and the PARSEC benchmark suites, demonstrate that the proposed hybrid approach is able to outperform the fence insertion mechanism by 4.9% and the transactional execution approach by 24.9% for two-thread applications, and outperform them by 4.5% and 44.7%, respectively, for four-threaded execution.", "paper_title": "Leveraging Transactional Execution for Memory Consistency Model Emulation", "paper_id": "WOS:000363004100004"}