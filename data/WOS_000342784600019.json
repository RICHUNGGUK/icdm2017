{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "program_loop_nesting_structures"}, {"score": 0.0047026237903774895, "phrase": "machine_code"}, {"score": 0.004459334186889869, "phrase": "dynamic_loop_and_procedure_nesting"}, {"score": 0.00438105507792004, "phrase": "actual_program_execution"}, {"score": 0.004081385289516914, "phrase": "better_strategies"}, {"score": 0.0040334640350288, "phrase": "performance_tuning"}, {"score": 0.0038930368103015467, "phrase": "pre-compiled_application_executable_machine_code"}, {"score": 0.0036914757355166966, "phrase": "simple_but_precise_markers"}, {"score": 0.003626626504149897, "phrase": "loop_entries"}, {"score": 0.003584025547693836, "phrase": "loop_exits"}, {"score": 0.0035210572541244664, "phrase": "dynamically_monitors"}, {"score": 0.003378385493203297, "phrase": "actual_execution"}, {"score": 0.0033190180867511605, "phrase": "call_context_tree"}, {"score": 0.0032414759269196493, "phrase": "precise_loop_structures"}, {"score": 0.003091767402370757, "phrase": "indirect_jumps"}, {"score": 0.0030195184114140063, "phrase": "loop_regions"}, {"score": 0.002914288956035066, "phrase": "irregular_function_call_transfers"}, {"score": 0.0028127163745564777, "phrase": "novel_representation"}, {"score": 0.0027796495180095657, "phrase": "loop-call_context_graph"}, {"score": 0.0026827569390113822, "phrase": "inter-procedural_loop_nests"}, {"score": 0.0023834640793589435, "phrase": "precise_inter-procedural_loop_nest_structures"}, {"score": 0.002286781334850213, "phrase": "particular_compiler_support"}, {"score": 0.002155412043665635, "phrase": "run-time_loop_detection_overheads"}, {"score": 0.0021049977753042253, "phrase": "existing_loop_profiling_method"}], "paper_keywords": ["dynamic loop nests", " loop-call context tree", " on-the-fly loop detection"], "paper_abstract": "This paper presents a mechanism for detecting dynamic loop and procedure nesting during the actual program execution on-the-fly. This mechanism aims primarily at making better strategies for performance tuning or parallelization. Using a pre-compiled application executable machine code as an input, our mechanism statically generates simple but precise markers that indicate loop entries and loop exits, and dynamically monitors loop nesting that appears during the actual execution together with call context tree. To keep precise loop structures all the time, we monitor the indirect jumps that enter the loop regions and the setjmp/longjmp functions that cause irregular function call transfers. We also present a novel representation called Loop-Call Context Graph that can keep track of inter-procedural loop nests. We implement our mechanism and evaluate it using SPEC CPU2006 benchmark suite. The results confirm that our mechanism can successfully reveal the precise inter-procedural loop nest structures from all of SPEC CPU2006 benchmark executions without any particular compiler support. The results also show that it can reduce run-time loop detection overheads compared with the existing loop profiling method.", "paper_title": "Identifying Program Loop Nesting Structures during Execution of Machine Code", "paper_id": "WOS:000342784600019"}