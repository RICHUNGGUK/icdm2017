{"auto_keywords": [{"score": 0.049320924338933134, "phrase": "software_engineering"}, {"score": 0.03712654330339069, "phrase": "characteristic_strategy"}, {"score": 0.028629244789919357, "phrase": "sample-based_strategies"}, {"score": 0.00481495049065317, "phrase": "software_engineering_theories"}, {"score": 0.004776669953449352, "phrase": "general_theories"}, {"score": 0.004645057834614705, "phrase": "full_understanding"}, {"score": 0.004589763483242731, "phrase": "single_case"}, {"score": 0.004535124351828787, "phrase": "partial_understanding"}, {"score": 0.0041703614123283165, "phrase": "sufficient_understanding"}, {"score": 0.004120694410890683, "phrase": "sufficiently_large_class"}, {"score": 0.0038965930422333035, "phrase": "six_strategies"}, {"score": 0.0038043055953253047, "phrase": "middle_range"}, {"score": 0.003758981686762617, "phrase": "lab-to-lab_strategies"}, {"score": 0.0034981163169818803, "phrase": "basic_science"}, {"score": 0.0032423089921154503, "phrase": "idealized_laboratory_conditions"}, {"score": 0.0030904433394138963, "phrase": "uncontrolled_field_conditions"}, {"score": 0.0029931603112397084, "phrase": "engineering_sciences"}, {"score": 0.002957471572421436, "phrase": "case-based_strategies"}, {"score": 0.0028758391869611374, "phrase": "real-world_cases"}, {"score": 0.0026336242881032645, "phrase": "aggregate_behavior"}, {"score": 0.0024901940672239784, "phrase": "case_level"}, {"score": 0.0023171750718791713, "phrase": "generalization_strategies"}, {"score": 0.0021909411820497707, "phrase": "related_work"}, {"score": 0.0021561514733516676, "phrase": "empirical_software_engineering_research"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Generalization", " External validity", " Scaling up", " Architectural mechanisms", " Statistical inference"], "paper_abstract": "General theories of software engineering must balance between providing full understanding of a single case and providing partial understanding of many cases. In this paper we argue that for theories to be useful in practice, they should give sufficient understanding of a sufficiently large class of cases, without having to be universal or complete. We provide six strategies for developing such theories of the middle range. In lab-to-lab strategies, theories of laboratory phenomena are developed and generalized to other laboratory phenomena. This is a characteristic strategy for basic science. In lab-to-field strategies, theories are developed of artifacts that first operate under idealized laboratory conditions, which are then scaled up until they can operate under uncontrolled field conditions. This is the characteristic strategy for the engineering sciences. In case-based strategies, we generalize about components of real-world cases, that are supposed to exhibit less variation than the cases as a whole. In sample-based strategies, we generalize about the aggregate behavior of samples of cases, which can exhibit patterns not visible at the case level. We discuss three examples of sample-based strategies. Throughout the paper, we use examples of theories and generalization strategies from software engineering to illustrate our analysis. The paper concludes with a discussion of related work and implications for empirical software engineering research. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Six strategies for generalizing software engineering theories", "paper_id": "WOS:000350513600009"}