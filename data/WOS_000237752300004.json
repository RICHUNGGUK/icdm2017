{"auto_keywords": [{"score": 0.04075292987843501, "phrase": "relaxed_problem"}, {"score": 0.015719716506582538, "phrase": "iterative_search_strategy"}, {"score": 0.015617292002548383, "phrase": "combinatorial_optimization_problems"}, {"score": 0.011034732500233303, "phrase": "incumbent_solution"}, {"score": 0.004658426838467567, "phrase": "branch-and-cut_use_search_trees"}, {"score": 0.004081385289516914, "phrase": "traditional_tree_search"}, {"score": 0.003922580121023413, "phrase": "search_path"}, {"score": 0.003845500924733243, "phrase": "sparse_problem"}, {"score": 0.0036836332308340923, "phrase": "sparse_problems"}, {"score": 0.0036593403276183245, "phrase": "incumbent_solutions"}, {"score": 0.0034477636809450312, "phrase": "incumbent_solution_value"}, {"score": 0.003205657519784272, "phrase": "anytime_algorithm"}, {"score": 0.0031218852898830755, "phrase": "root_node"}, {"score": 0.0028739078688746374, "phrase": "\"wrong\"_subtrees"}, {"score": 0.002602127996667857, "phrase": "depth-first_or_best-first_search_tree_methods"}, {"score": 0.0025257081555100556, "phrase": "cut-and-solve_strategy"}, {"score": 0.0024434201175883674, "phrase": "asymmetric_traveling_salesman_problem"}, {"score": 0.0023249757987087055, "phrase": "five_out_of_seven_real-world_problem_classes"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["search strategies", " branch-and-bound", " branch-and-cut", " anytime algorithms", " linear programming", " traveling salesman problem"], "paper_abstract": "Branch-and-bound and branch-and-cut use search trees to identify optimal solutions to combinatorial optimization problems. In this paper, we introduce an iterative search strategy which we refer to as cut-and-solve and prove optimality and termination for this method. This search is different from traditional tree search as there is no branching. At each node in the search path, a relaxed problem and a sparse problem are solved and a constraint is added to the relaxed problem. The sparse problems provide incumbent solutions. When the constraining of the relaxed problem becomes tight enough, its solution value becomes no better than the incumbent solution value. At this point, the incumbent solution is declared to be optimal. This strategy is easily adapted to be an anytime algorithm as an incumbent solution is found at the root node and continuously updated during the search. Cut-and-solve enjoys two favorable properties. Since there is no branching, there are no \"wrong\" subtrees in which the search may get lost. Furthermore, its memory requirement is negligible. For these reasons, it has potential for problems that are difficult to solve using depth-first or best-first search tree methods. In this paper, we demonstrate the cut-and-solve strategy by implementing a generic version of it for the Asymmetric Traveling Salesman Problem (ATSP). Our unoptimized implementation outperformed state-of-the-art solvers for five out of seven real-world problem classes of the ATSP. For four of these classes, cut-and-solve was able to solve larger (sometimes substantially larger) problems. Our code is available at our websites. (c) 2006 Published by Elsevier B.V.", "paper_title": "Cut-and-solve: An iterative search strategy for combinatorial optimization problems", "paper_id": "WOS:000237752300004"}