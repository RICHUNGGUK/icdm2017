{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "acceptability_properties"}, {"score": 0.03273779344060277, "phrase": "proof_rules"}, {"score": 0.008968933421847944, "phrase": "original_and_relaxed_programs"}, {"score": 0.008148628195726535, "phrase": "original_program"}, {"score": 0.007495080745992701, "phrase": "dynamic_semantics"}, {"score": 0.0047851345246117455, "phrase": "relaxed_nondeterministic_approximate_programs"}, {"score": 0.0047555023078686386, "phrase": "approximate_program_transformations"}, {"score": 0.004610058444728656, "phrase": "loop_perforation"}, {"score": 0.0037318666008429014, "phrase": "underlying_performance"}, {"score": 0.0037087324991876727, "phrase": "accuracy_tradeoff_space"}, {"score": 0.0036742989715836745, "phrase": "transformed_programs"}, {"score": 0.003561804646511146, "phrase": "increased_performance"}, {"score": 0.0033262524445013303, "phrase": "additional_nondeterminism"}, {"score": 0.0032647501331200023, "phrase": "greater_flexibility"}, {"score": 0.003145125312514813, "phrase": "relaxed_programs"}, {"score": 0.002803104254950008, "phrase": "desired_relationships"}, {"score": 0.0025691622090542325, "phrase": "staged_reasoning_approach"}, {"score": 0.0025137856138000014, "phrase": "reasoning_effort"}, {"score": 0.0024519545383399773, "phrase": "common_structure"}, {"score": 0.0024065789359533772, "phrase": "relational_reasoning_transfers"}, {"score": 0.002325554982412043, "phrase": "relaxed_program"}, {"score": 0.002233319223239275, "phrase": "coq"}, {"score": 0.0021049977753042253, "phrase": "fully_machine-checked_verifications"}], "paper_keywords": ["Languages", " Performance", " Theory", " Verification", " Coq", " Acceptability", " Relaxed Programs", " Relational Hoare Logic"], "paper_abstract": "Approximate program transformations such as skipping tasks [29, 30], loop perforation [21, 22, 35], reduction sampling [38], multiple selectable implementations [3, 4, 16, 38], dynamic knobs [16], synchronization elimination [20, 32], approximate function memoization [11], and approximate data types [34] produce programs that can execute at a variety of points in an underlying performance versus accuracy tradeoff space. These transformed programs have the ability to trade accuracy of their results for increased performance by dynamically and nondeterministically modifying variables that control their execution. We call such transformed programs relaxed programs because they have been extended with additional nondeterminism to relax their semantics and enable greater flexibility in their execution. We present language constructs for developing and specifying relaxed programs. We also present proof rules for reasoning about acceptability properties [28], which the program must satisfy to be acceptable. Our proof rules work with two kinds of acceptability properties: relational acceptability properties, which characterize desired relationships between the values of variables in the original and relaxed programs, and unary acceptability properties, which involve values only from a single (original or relaxed) program. The proof rules support a staged reasoning approach in which the majority of the reasoning effort works with the original program. Exploiting the common structure that the original and relaxed programs share, relational reasoning transfers reasoning effort from the original program to prove properties of the relaxed program. We have formalized the dynamic semantics of our target programming language and the proof rules in Coq and verified that the proof rules are sound with respect to the dynamic semantics. Our Coq implementation enables developers to obtain fully machine-checked verifications of their relaxed programs.", "paper_title": "Proving Acceptability Properties of Relaxed Nondeterministic Approximate Programs", "paper_id": "WOS:000307582100016"}