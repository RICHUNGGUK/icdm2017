{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "wake-up_spatial_locality"}, {"score": 0.0047323590206695305, "phrase": "high-performance_superscalar_processor"}, {"score": 0.00457138247462329, "phrase": "poor_scalability"}, {"score": 0.004531997388646422, "phrase": "high_complexity"}, {"score": 0.004454237726525018, "phrase": "expensive_wake-up_operation"}, {"score": 0.004396790930873782, "phrase": "detailed_simulation-based_analyses"}, {"score": 0.004247180402119585, "phrase": "wake-up_distances"}, {"score": 0.00374610869916551, "phrase": "conventional_cam-based_and_matrix-based_wakeup_logic"}, {"score": 0.003634262647873338, "phrase": "wake-up_coverage"}, {"score": 0.0033471722682967046, "phrase": "proposed_wake-up_designs"}, {"score": 0.0033039560332995136, "phrase": "wake-up_operation"}, {"score": 0.003109519872758431, "phrase": "experimental_results"}, {"score": 0.003029722317983915, "phrase": "issue_window"}, {"score": 0.002863762666256937, "phrase": "proposed_cam-based_wake-up_locality_design"}, {"score": 0.0027068691342344545, "phrase": "power_consumption"}, {"score": 0.0025474814283429213, "phrase": "wake-up_latency"}, {"score": 0.0025036862991477437, "phrase": "conventional_cam-based_design"}, {"score": 0.0024820711838337713, "phrase": "almost_no_performance_loss"}, {"score": 0.0024393978073660757, "phrase": "matrix-based_wake-up_logic"}, {"score": 0.0023056996845692355, "phrase": "area_cost"}, {"score": 0.0022857899334246946, "phrase": "extensive_simulation_results"}, {"score": 0.002236762786982225, "phrase": "previous_works"}, {"score": 0.0021049977753042253, "phrase": "future_sophisticated_instruction_schedulers"}], "paper_keywords": ["CAM-based wake-up logic", " issue logic", " low power", " matrix-based wake-up logic", " scalable instruction scheduler", " wake-up spatial locality"], "paper_abstract": "In a high-performance superscalar processor, the instruction scheduler often comes with poor scalability and high complexity due to the expensive wake-up operation. From detailed simulation-based analyses, we find that 95 percent of the wake-up distances between two dependent instructions are short, in the range of 16 instructions, and 99 percent are in the range of 31 instructions. We apply this wake-up spatial locality to the design of conventional CAM-based and matrix-based wakeup logic, respectively. By limiting the wake-up coverage to i + 16 instructions, where 0 <= i <= 15 for 16-entry segments, the proposed wake-up designs confine the wake-up operation to two matrix-based or three CAM-based 16-entry segments no matter how large the issue window size is. The experimental results show that, for an issue window of 128 entries (IW128) or 256 entries (IW256), the proposed CAM-based wake-up locality design saves 65 percent (IW128) and 76 percent (IW256) of the power consumption and reduces 44 percent (IW128) and 78 percent (IW256) in the wake-up latency compared to the conventional CAM-based design with almost no performance loss. For the matrix-based wake-up logic, applying wake-up locality to the design drastically reduces the area cost. Extensive simulation results, including comparisons with previous works, show that the wake-up spatial locality is the key element to achieving scalability for future sophisticated instruction schedulers.", "paper_title": "Scalable dynamic instruction scheduler through wake-up spatial locality", "paper_id": "WOS:000249594900008"}