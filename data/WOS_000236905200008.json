{"auto_keywords": [{"score": 0.039748006326436616, "phrase": "uniform_approach"}, {"score": 0.00481495049065317, "phrase": "pure_pattern_calculus"}, {"score": 0.004721893473387288, "phrase": "pure_lambda-calculus"}, {"score": 0.003569050665799723, "phrase": "data_structures"}, {"score": 0.0034099718632933027, "phrase": "path_polymorphism"}, {"score": 0.003194898129853895, "phrase": "arbitrary_data_structure"}, {"score": 0.0031535341431377837, "phrase": "pattern_polymorphism"}, {"score": 0.0030924870122337905, "phrase": "dynamic_creation"}, {"score": 0.002804478352027886, "phrase": "new_information"}, {"score": 0.002543224008253855, "phrase": "natural_account"}, {"score": 0.0024297565926197505, "phrase": "xml_paths"}, {"score": 0.0021049977753042253, "phrase": "binding_variables"}], "paper_keywords": [""], "paper_abstract": "The pure pattern calculus generalises the pure lambda-calculus by basing computation on pattern-matching instead of beta-reduction. The simplicity and power of the calculus derive from allowing any term to be a pattern. As well as supporting a uniform approach to functions, it supports a uniform approach to data structures which underpins two new forms of polymorphism. Path polymorphism supports searches or queries along all paths through an arbitrary data structure. Pattern polymorphism supports the dynamic creation and evaluation of patterns, so that queries can be customised in reaction to new information about the structures to be encountered. In combination, these features provide a natural account of tasks such as programming with XML paths. As the variables used in matching can now be eliminated by reduction it is necessary to separate them from the binding variables used to control scope. Then standard techniques suffice to ensure that reduction progresses and to establish confluence of reduction.", "paper_title": "Pure pattern calculus", "paper_id": "WOS:000236905200008"}