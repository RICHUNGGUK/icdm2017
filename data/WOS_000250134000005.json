{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "best_hyperplane"}, {"score": 0.004753512932910936, "phrase": "simple_budget"}, {"score": 0.004632968695963776, "phrase": "on-line_classification_algorithms"}, {"score": 0.004307700591183651, "phrase": "changing_classifiers"}, {"score": 0.004234532601573088, "phrase": "shifting_bounds"}, {"score": 0.0041984140090404985, "phrase": "kernel-based_classifiers"}, {"score": 0.003988055287053139, "phrase": "support_vectors"}, {"score": 0.00385368199735867, "phrase": "eviction_policy"}, {"score": 0.0032604908177429493, "phrase": "shifting_perceptron_algorithm"}, {"score": 0.003218823621926739, "phrase": "best_known_shifting_bounds"}, {"score": 0.0031640918630415566, "phrase": "unlimited_budget"}, {"score": 0.0030183163057929687, "phrase": "perceptron_algorithm"}, {"score": 0.0029925402963843282, "phrase": "simplest_possible_eviction_policy"}, {"score": 0.002929056388593134, "phrase": "random_support_vector"}, {"score": 0.002879237498994052, "phrase": "new_one"}, {"score": 0.0026767629720554397, "phrase": "budget_restrictions"}, {"score": 0.002553382046204689, "phrase": "optimal_trade-off_u"}, {"score": 0.0024884913795612707, "phrase": "budget_b"}, {"score": 0.0024566655761509276, "phrase": "u_of"}, {"score": 0.0024356742694508662, "phrase": "largest_classifier"}, {"score": 0.002404522326122611, "phrase": "comparison_sequence"}, {"score": 0.0023035249767734286, "phrase": "textual_datasets"}, {"score": 0.002178529882942255, "phrase": "randomized_budget_algorithms"}, {"score": 0.0021322775033565805, "phrase": "deterministic_ones"}, {"score": 0.0021049977753042253, "phrase": "shifting_target_data_streams"}], "paper_keywords": ["pattern classification", " mistake bounds", " perceptron algorithm", " budget algorithms"], "paper_abstract": "Shifting bounds for on-line classification algorithms ensure good performance on any sequence of examples that is well predicted by a sequence of changing classifiers. When proving shifting bounds for kernel-based classifiers, one also faces the problem of storing a number of support vectors that can grow unboundedly, unless an eviction policy is used to keep this number under control. In this paper, we show that shifting and on-line learning on a budget can be combined surprisingly well. First, we introduce and analyze a shifting Perceptron algorithm achieving the best known shifting bounds while using an unlimited budget. Second, we show that by applying to the Perceptron algorithm the simplest possible eviction policy, which discards a random support vector each time a new one comes in, we achieve a shifting bound close to the one we obtained with no budget restrictions. More importantly, we show that our randomized algorithm strikes the optimal trade-off U = Theta(root B) between budget B and norm U of the largest classifier in the comparison sequence. Experiments are presented comparing several linear-threshold algorithms on chronologically- ordered textual datasets. These experiments support our theoretical findings in that they show to what extent randomized budget algorithms are more robust than deterministic ones when learning shifting target data streams.", "paper_title": "Tracking the best hyperplane with a simple budget Perceptron", "paper_id": "WOS:000250134000005"}