{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "prolog"}, {"score": 0.004623224002010226, "phrase": "succinct_sat_solver"}, {"score": 0.004092463367307375, "phrase": "delay_declarations"}, {"score": 0.003929391999210588, "phrase": "watched_literals"}, {"score": 0.0038242899532391914, "phrase": "unit_propagation"}, {"score": 0.003249966782844541, "phrase": "prolog_constructs"}, {"score": 0.003036832649117453, "phrase": "programming_pearl"}, {"score": 0.0028376361457661415, "phrase": "sat_solver"}, {"score": 0.0026157259734105, "phrase": "smt_framework"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["SAT solving", " SMT solving", " Prolog", " Constraint logic programming"], "paper_abstract": "A succinct SAT solver is presented that exploits the control provided by delay declarations to implement watched literals and unit propagation. Despite its brevity the solver is surprisingly powerful and its elegant use of Prolog constructs is presented as a programming pearl. Furthermore, the SAT solver can be integrated into an SMT framework which exploits the constraint solvers that are available in many Prolog systems. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "A pearl on SAT and SMT solving in Prolog", "paper_id": "WOS:000304024100004"}