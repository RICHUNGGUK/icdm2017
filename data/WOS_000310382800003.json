{"auto_keywords": [{"score": 0.049465088868450455, "phrase": "transactional_worklist_applications"}, {"score": 0.041078685670043524, "phrase": "performance_optimizations"}, {"score": 0.029297125190865764, "phrase": "performance_improvements"}, {"score": 0.00481495049065317, "phrase": "skeleton-driven_optimizations"}, {"score": 0.004632039024076267, "phrase": "pattern-based_programming"}, {"score": 0.004398872331144531, "phrase": "specialized_instances"}, {"score": 0.004342430078306461, "phrase": "generic_communication"}, {"score": 0.004286708921931472, "phrase": "computation_patterns"}, {"score": 0.00409723267214392, "phrase": "programming_task"}, {"score": 0.003865826699096508, "phrase": "code_generation"}, {"score": 0.0035543706594585076, "phrase": "new_skeleton_framework"}, {"score": 0.003289117944111902, "phrase": "novel_hierarchical_autotuning_mechanism"}, {"score": 0.0028530201960995896, "phrase": "stamp_benchmark_suite_show"}, {"score": 0.002555950807368337, "phrase": "baseline_version"}, {"score": 0.0021462652605453163, "phrase": "static_exhaustive_search"}, {"score": 0.0021049977753042253, "phrase": "optimization_space"}], "paper_keywords": ["Concurrent programming", " transactional memory", " parallel patterns and application-transparent adaptation"], "paper_abstract": "Skeleton or pattern-based programming allows parallel programs to be expressed as specialized instances of generic communication and computation patterns. In addition to simplifying the programming task, such well structured programs are also amenable to performance optimizations during code generation and also at runtime. In this paper, we present a new skeleton framework that transparently selects and applies performance optimizations in transactional worklist applications. Using a novel hierarchical autotuning mechanism, it dynamically selects the most suitable set of optimizations for each application and adjusts them accordingly. Our experimental results on the STAMP benchmark suite show that our skeleton autotuning framework can achieve performance improvements of up to 88 percent, with an average of 46 percent, over a baseline version for a 16-core system and up to 115 percent, with an average of 56 percent, for a 32-core system. These performance improvements match or even exceed those obtained by a static exhaustive search of the optimization space.", "paper_title": "Autotuning Skeleton-Driven Optimizations for Transactional Worklist Applications", "paper_id": "WOS:000310382800003"}