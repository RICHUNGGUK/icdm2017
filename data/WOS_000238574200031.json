{"auto_keywords": [{"score": 0.03544978542550594, "phrase": "general_case"}, {"score": 0.004814952636065877, "phrase": "paillier"}, {"score": 0.004650519511749445, "phrase": "secure_n-party_computation"}, {"score": 0.004596960835906736, "phrase": "threshold_homomorphic_cryptosystems"}, {"score": 0.004509091546283768, "phrase": "cramer"}, {"score": 0.004474367005715472, "phrase": "damgard"}, {"score": 0.004422827355213055, "phrase": "nielsen_at"}, {"score": 0.0043215158337835706, "phrase": "paillier's_cryptosystem"}, {"score": 0.004222515162635615, "phrase": "efficient_secure_evaluation"}, {"score": 0.004173865018011237, "phrase": "arithmetic_circuit"}, {"score": 0.004015693806064219, "phrase": "rsa_modulus"}, {"score": 0.0039694170761766226, "phrase": "underlying_paillier_cryptosystem"}, {"score": 0.0035076666315744525, "phrase": "paillier_encryptions"}, {"score": 0.0030637124954859657, "phrase": "restricted_case"}, {"score": 0.002947486683884831, "phrase": "security_parameter_k."}, {"score": 0.002913483929932102, "phrase": "latter_case"}, {"score": 0.00282470997972535, "phrase": "l_least_significant_bits"}, {"score": 0.0027706013216537042, "phrase": "encrypted_form"}, {"score": 0.0025347150832077175, "phrase": "intermediate_computations"}, {"score": 0.002486147565139633, "phrase": "essential_way"}, {"score": 0.0024574537875026634, "phrase": "binary_representations"}, {"score": 0.002364172626241202, "phrase": "entire_computation"}, {"score": 0.0023188652648490874, "phrase": "typical_examples"}, {"score": 0.002292097733181405, "phrase": "relational_operators"}, {"score": 0.0022222152430170254, "phrase": "specific_scenario"}, {"score": 0.0021049977753042253, "phrase": "bit_strings"}], "paper_keywords": [""], "paper_abstract": "We consider the framework of secure n-party computation based on threshold homomorphic cryptosystems as put forth by Cramer, Damgard, and Nielsen at Eurocrypt 2001. When used with Paillier's cryptosystem, this framework allows for efficient secure evaluation of any arithmetic circuit defined over Z(N), where N is the RSA modulus of the underlying Paillier cryptosystem. In this paper, we extend the scope of the framework by considering the problem of converting a given Paillier encryption of a value X is an element of Z(N) into Paillier encryptions of the bits of x. We present solutions for the general case in which x can be any integer in {0, 1,..., N - 1}, and for the restricted case in which x < N/(n2(k)) for a security parameter K. In the latter case, we show how to extract the l least significant bits of x (in encrypted form) in time proportional to e, typically saving a factor of log(2) N/l compared to the general case. Thus, intermediate computations that rely in an essential way on the binary representations of their input values can be handled without enforcing that the entire computation is done bitwise. Typical examples involve the relational operators such as < and =. As a specific scenario we will consider the setting for (approximate) matching of biometric templates, given as bit strings.", "paper_title": "Efficient binary conversion for Paillier encrypted values", "paper_id": "WOS:000238574200031"}