{"auto_keywords": [{"score": 0.038661520814563984, "phrase": "pozzi"}, {"score": 0.00481495049065317, "phrase": "computing_convex_subgraphs"}, {"score": 0.00477190623242136, "phrase": "custom_instruction"}, {"score": 0.0046659637258752535, "phrase": "custom_instruction_processors"}, {"score": 0.0046242451772036145, "phrase": "high-level_application_descriptions"}, {"score": 0.004521566043596533, "phrase": "data-flow_subgraphs"}, {"score": 0.004481132747216135, "phrase": "custom_instruction_candidates"}, {"score": 0.004421156723819163, "phrase": "subgraph_s"}, {"score": 0.0043619799095455415, "phrase": "graph_d"}, {"score": 0.0038810583785936505, "phrase": "convex_subgraphs"}, {"score": 0.0038290829316346654, "phrase": "directed_acyclic_graph"}, {"score": 0.0036443694410100507, "phrase": "atasu"}, {"score": 0.003595552309967789, "phrase": "ienne"}, {"score": 0.0027950561494657633, "phrase": "polynomial_complexity"}, {"score": 0.0027328817607818207, "phrase": "convex_subgraph_s"}, {"score": 0.0026962411675196213, "phrase": "maximal_convex_subgraph"}, {"score": 0.002624423288947767, "phrase": "proper_subgraph"}, {"score": 0.00249767641333441, "phrase": "forbidden_vertex_constraints"}, {"score": 0.0024641814990854463, "phrase": "largest_maximal_convex_subgraph"}, {"score": 0.0023557346035701096, "phrase": "popular_algorithms"}, {"score": 0.0023346234464901978, "phrase": "enumerate_maximal_convex_subgraphs"}, {"score": 0.002282667669149476, "phrase": "exponential_worst-case_time_complexity"}, {"score": 0.0022019274077124795, "phrase": "polynomial-time_maximal_convex_subgraph_enumeration_algorithm"}, {"score": 0.0021529183360603434, "phrase": "related_maximum_convex_subgraph_problem"}, {"score": 0.0021049977753042253, "phrase": "polynomial_time"}], "paper_keywords": ["Complexity", " subgraph enumeration"], "paper_abstract": "Synthesis of custom instruction processors from high-level application descriptions involves automated evaluation of data-flow subgraphs as custom instruction candidates. A subgraph S of a graph D is convex if no two vertices of S are connected by a path in D that is not also in S. An algorithm for enumerating all convex subgraphs of a directed acyclic graph (DAG) under input, output, and forbidden vertex constraints was given by Pozzi, Atasu, and Ienne. We show that this algorithm makes no more than O(vertical bar V(D)vertical bar(Nin+Nout+1)) recursive calls, where vertical bar V(D)vertical bar is the number of vertices in D, and N-in and N-out are input and output constraints, respectively. Therefore, when N-in and N-out are constants, the algorithm is of polynomial complexity. Furthermore, a convex subgraph S is a maximal convex subgraph if it is not a proper subgraph of some other convex subgraph, assuming that both are valid under forbidden vertex constraints. The largest maximal convex subgraph is called the maximum convex subgraph. There exist popular algorithms that enumerate maximal convex subgraphs, which all have exponential worst-case time complexity. This work shows that although no polynomial-time maximal convex subgraph enumeration algorithm can exist, the related maximum convex subgraph problem can be solved in polynomial time.", "paper_title": "Complexity of Computing Convex Subgraphs in Custom Instruction Synthesis", "paper_id": "WOS:000307443700017"}