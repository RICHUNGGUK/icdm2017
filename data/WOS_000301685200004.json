{"auto_keywords": [{"score": 0.049233068058238634, "phrase": "gpu"}, {"score": 0.0069100647118756275, "phrase": "gpu."}, {"score": 0.006893410716697456, "phrase": "cuda"}, {"score": 0.005177574998430758, "phrase": "gpgpu"}, {"score": 0.0049034042661787805, "phrase": "opencl"}, {"score": 0.00481495049065317, "phrase": "monte_carlo"}, {"score": 0.004678311094840897, "phrase": "general-purpose"}, {"score": 0.0045370785151713396, "phrase": "recent_interest"}, {"score": 0.004326321719714357, "phrase": "graphics_processing_unit"}, {"score": 0.003933609372601274, "phrase": "new_languages"}, {"score": 0.003795677450778112, "phrase": "gpu_programming"}, {"score": 0.0034922880300145283, "phrase": "direct_implementation"}, {"score": 0.0033898953358387075, "phrase": "straightforward_implementation"}, {"score": 0.003329901594166227, "phrase": "monte_carlo_radiosity_algorithm"}, {"score": 0.0031750418391373035, "phrase": "expected_performance"}, {"score": 0.0030454408569868347, "phrase": "different_strategies"}, {"score": 0.0030105196838874715, "phrase": "cpu."}, {"score": 0.0028354207806133153, "phrase": "additional_simplified_version"}, {"score": 0.002719644855867468, "phrase": "computational_requirements"}, {"score": 0.0025623821393275146, "phrase": "data_locality"}, {"score": 0.0025020469669826497, "phrase": "efficient_thread"}, {"score": 0.0023018188296933923, "phrase": "previous_solutions"}, {"score": 0.0022209780222461587, "phrase": "significant_improvement"}, {"score": 0.002181626277903721, "phrase": "execution_time"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Radiosity method", " Monte Carlo algorithms", " Graphics processing unit", " CUDA", " Data partitioning"], "paper_abstract": "The recent interest in GPGPU, (General-Purpose computation on Graphics Processing Unit), has stimulated improvements in the programmability of the GPU. Although the utilization of new languages like OpenCL and CUDA facilitate GPU programming, different challenges have to be overcome to optimize the results of a direct implementation. Specifically, a straightforward implementation of the Monte Carlo radiosity algorithm on the CPU does not produce the expected performance. In this paper we develop different strategies to increase the performance of the implementation: utilization of an additional simplified version of the mesh to reduce the computational requirements, data partitioning of the scene to increase the data locality, and an efficient thread scheduling to exploit the characteristics of the CPU. Our approach increases the flexibility of previous solutions and the results show a significant improvement of the execution time. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "High-performance Monte Carlo radiosity on GPU based on scene partitioning", "paper_id": "WOS:000301685200004"}