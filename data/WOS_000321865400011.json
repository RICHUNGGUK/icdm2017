{"auto_keywords": [{"score": 0.034790544355724276, "phrase": "terra"}, {"score": 0.01150002932336049, "phrase": "lua"}, {"score": 0.00481495049065317, "phrase": "multi-stage_language"}, {"score": 0.004754600386388821, "phrase": "high-performance_computing"}, {"score": 0.00469500313566324, "phrase": "high-performance_computing_applications"}, {"score": 0.00452063603944825, "phrase": "domain-specific_languages"}, {"score": 0.0044079880067019765, "phrase": "generative_programming_techniques"}, {"score": 0.004325339932975582, "phrase": "high_performance"}, {"score": 0.004009894739765119, "phrase": "multiple_disparate_languages"}, {"score": 0.003934681262271618, "phrase": "code_generation"}, {"score": 0.0038608730929994696, "phrase": "separate_process"}, {"score": 0.0038124354878360032, "phrase": "program_execution"}, {"score": 0.00355665081072721, "phrase": "popular_scripting_language"}, {"score": 0.003338992028053874, "phrase": "novel_low-level_language"}, {"score": 0.0031346115554600003, "phrase": "high-level_language"}, {"score": 0.00305639530600272, "phrase": "built-in_constructs"}, {"score": 0.0029613556844064713, "phrase": "high-performance_terra_code"}, {"score": 0.002626317051411829, "phrase": "terra_code"}, {"score": 0.002544616720630384, "phrase": "lua's_runtime"}, {"score": 0.002434477906829832, "phrase": "existing_multi-language_systems"}, {"score": 0.0023291001355504586, "phrase": "blas"}, {"score": 0.002242657147401505, "phrase": "atlas"}, {"score": 0.0021726139494880653, "phrase": "stencil_computations"}, {"score": 0.0021049977753042253, "phrase": "hand-written_c."}], "paper_keywords": ["Design", " Performance", " Lua", " Staged computation", " DSL"], "paper_abstract": "High-performance computing applications, such as auto-tuners and domain-specific languages, rely on generative programming techniques to achieve high performance and portability. However, these systems are often implemented in multiple disparate languages and perform code generation in a separate process from program execution, making certain optimizations difficult to engineer. We leverage a popular scripting language, Lua, to stage the execution of a novel low-level language, Terra. Users can implement optimizations in the high-level language, and use built-in constructs to generate and execute high-performance Terra code. To simplify meta-programming, Lua and Terra share the same lexical environment, but, to ensure performance, Terra code can execute independently of Lua's runtime. We evaluate our design by reimplementing existing multi-language systems entirely in Terra. Our Terra-based auto-tuner for BLAS routines performs within 20% of ATLAS, and our DSL for stencil computations runs 2.3x faster than hand-written C.", "paper_title": "Terra: A Multi-Stage Language for High-Performance Computing", "paper_id": "WOS:000321865400011"}