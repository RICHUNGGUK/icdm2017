{"auto_keywords": [{"score": 0.04692742270242531, "phrase": "java"}, {"score": 0.01439528966963169, "phrase": "current_refactoring_tools"}, {"score": 0.00481495049065317, "phrase": "refactoring_java_programs"}, {"score": 0.004764859786310636, "phrase": "automated_tool_support"}, {"score": 0.004569630374630379, "phrase": "mainstream_programming_languages"}, {"score": 0.004137288854115515, "phrase": "program_behavior"}, {"score": 0.003905864553426306, "phrase": "source_code"}, {"score": 0.0037261429556468217, "phrase": "program_analysis"}, {"score": 0.0036489343475053187, "phrase": "intricate_name_lookup_and_access_control_rules"}, {"score": 0.003303412571939192, "phrase": "java_programs"}, {"score": 0.0027645030021576926, "phrase": "accessibility_issues"}, {"score": 0.0024377918036784336, "phrase": "jastaddj_compiler_framework"}, {"score": 0.0023133055945761235, "phrase": "extensive_suite"}, {"score": 0.002289180040240783, "phrase": "real-world_java_applications"}, {"score": 0.0021049977753042253, "phrase": "complex_rules"}], "paper_keywords": ["Restructuring", " reverse engineering", " and reengineering", " object-oriented languages", " Java"], "paper_abstract": "Automated tool support for refactoring is now widely available for mainstream programming languages such as Java. However, current refactoring tools are still quite fragile in practice and often fail to preserve program behavior or compilability. This is mainly because analyzing and transforming source code requires consideration of many language features that complicate program analysis, in particular intricate name lookup and access control rules. This paper introduces J(L), a lookup-free, access control-free representation of Java programs. We present algorithms for translating Java programs into J(L) and vice versa, thereby making it possible to formulate refactorings entirely at the level of J(L) and to rely on the translations to take care of naming and accessibility issues. We demonstrate how complex refactorings become more robust and powerful when lifted to J(L). Our approach has been implemented using the JastAddJ compiler framework, and evaluated by systematically performing two commonly used refactorings on an extensive suite of real-world Java applications. The evaluation shows that our tool correctly handles many cases where current refactoring tools fail to handle the complex rules for name binding and accessibility in Java.", "paper_title": "A Comprehensive Approach to Naming and Accessibility in Refactoring Java Programs", "paper_id": "WOS:000311556100001"}