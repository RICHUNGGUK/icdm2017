{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "mandatory_security"}, {"score": 0.022444673612760053, "phrase": "mtags"}, {"score": 0.006871254613777833, "phrase": "usable_mandatory_integrity_protection"}, {"score": 0.004569293780076254, "phrase": "efficient_mechanism"}, {"score": 0.004490212943845175, "phrase": "inter-thread_messages"}, {"score": 0.004236321075918639, "phrase": "case_study"}, {"score": 0.0036411406244705557, "phrase": "thread-based_system"}, {"score": 0.003435092524339692, "phrase": "posix-compliant_qnx_neutrino"}, {"score": 0.0029867619862229853, "phrase": "recent_research"}, {"score": 0.002435453488008121, "phrase": "well-established_benchmarks"}, {"score": 0.0021927323694667694, "phrase": "realistic_systems"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["security", " research", " microkernels"], "paper_abstract": "mTags is an efficient mechanism that augments inter-thread messages with lightweight metadata. We introduce and discuss a case study that we have conducted in the use of mTags for realizing a kind of mandatory security. Although mTags can be implemented for any message passing thread-based system, we consider an implementation of it in the POSIX-compliant QNX Neutrino, a commercial microkernel-based system. The approach to mandatory security that we adopt is Usable Mandatory Integrity Protection, which has been proposed in recent research. We call our adaptation of Usable Mandatory Integrity Protection using mTags, MIP. We discuss the challenges we faced, and our design and implementation that overcomes these challenges. We discuss the performance of our implementation for well-established benchmarks. We conclude with the observation that mTags can be useful and practical to realize mandatory security in realistic systems. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "The use of mTags for mandatory security: a case study", "paper_id": "WOS:000344733600005"}