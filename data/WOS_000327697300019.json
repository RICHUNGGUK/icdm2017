{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "synthesis"}, {"score": 0.004932974939224223, "phrase": "refactoring"}, {"score": 0.004716924994370903, "phrase": "integral_part"}, {"score": 0.0046846932351254636, "phrase": "modern_software_development"}, {"score": 0.004636756166068091, "phrase": "wide_support"}, {"score": 0.004605069682942661, "phrase": "popular_integrated_development_environments"}, {"score": 0.004526793300190607, "phrase": "modern_ides"}, {"score": 0.0044804647007342865, "phrase": "fixed_set"}, {"score": 0.0044498415012873965, "phrase": "supported_refactorings"}, {"score": 0.004374192072307276, "phrase": "refactoring_menu"}, {"score": 0.0037742798298349145, "phrase": "slightly_different_code_transformation"}, {"score": 0.0034402448248944434, "phrase": "novel_synthesis_system"}, {"score": 0.003335581163845351, "phrase": "recently_proposed_refactoring_interface"}, {"score": 0.0031249312057114237, "phrase": "code_refactoring_phase"}, {"score": 0.0030402538087882015, "phrase": "desired_code"}, {"score": 0.0028580007147015734, "phrase": "initial_and_modified_programs"}, {"score": 0.002733187900351625, "phrase": "starting_program"}, {"score": 0.002705165729333657, "phrase": "modified_version"}, {"score": 0.0025255346035867564, "phrase": "local_refactorings"}, {"score": 0.002457059241474629, "phrase": "refactoring_sequence"}, {"score": 0.002440231768165477, "phrase": "small_program_fragments"}, {"score": 0.002382235844852208, "phrase": "full_refactoring_sequence"}, {"score": 0.002325615071949044, "phrase": "eclipse_plug-in"}, {"score": 0.002247049536955399, "phrase": "new_refactorings"}, {"score": 0.0022240004131756095, "phrase": "experimental_results"}, {"score": 0.0021195184368629017, "phrase": "complex_refactoring_sequences"}], "paper_keywords": ["Refactoring", " Synthesis"], "paper_abstract": "Refactoring has become an integral part of modern software development, with wide support in popular integrated development environments (IDEs). Modern IDEs provide a fixed set of supported refactorings, listed in a refactoring menu. But with IDEs supporting more and more refactorings, it is becoming increasingly difficult for programmers to discover and memorize all their names and meanings. Also, since the set of refactorings is hard-coded, if a programmer wants to achieve a slightly different code transformation, she has to either apply a (possibly non-obvious) sequence of several built-in refactorings, or just perform the transformation by hand. We propose a novel synthesis system which addresses these limitations. Our system employs a recently proposed refactoring interface, in which a refactoring is achieved via three simple steps: the programmer first indicates the start of a code refactoring phase; then she performs some of the desired code changes manually; and finally, she asks the tool to complete the refactoring. Given the initial and modified programs, our synthesis system completes the refactoring by first extracting the difference between the starting program and the modified version, and then synthesizing a sequence of refactorings that achieves (at least) the desired changes. To enable scalable synthesis, we introduce local refactorings, which allow for first discovering a refactoring sequence on small program fragments and then extrapolating it to a full refactoring sequence. We implemented our approach as an Eclipse plug-in, with an architecture that is easily extendable with new refactorings. The experimental results are encouraging: with only minimal user input, the synthesizer was able to quickly discover complex refactoring sequences for several challenging realistic examples.", "paper_title": "Refactoring with Synthesis", "paper_id": "WOS:000327697300019"}