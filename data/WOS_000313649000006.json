{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "longest_prefix_queries"}, {"score": 0.004586531354697466, "phrase": "efficient_data_structure"}, {"score": 0.004411588377842043, "phrase": "longest_prefix"}, {"score": 0.004284755353695709, "phrase": "query_string"}, {"score": 0.004121275290411653, "phrase": "dynamic_database"}, {"score": 0.0038876302202924644, "phrase": "database_strings"}, {"score": 0.0035616743422949766, "phrase": "ip-lookup_problem"}, {"score": 0.0027922467043592597, "phrase": "disk_block"}, {"score": 0.0022756672722130424, "phrase": "data_structure"}, {"score": 0.0021049977753042253, "phrase": "running_time"}], "paper_keywords": ["Algorithms", " Data structures", " Longest prefix", " I/O model", " Segment tree", " String B-tree"], "paper_abstract": "We present an efficient data structure for finding the longest prefix of a query string q in a dynamic database of strings. When the database strings are prefixes of IP-addresses then this is the IP-lookup problem. Our data structure is I/O efficient. It supports a query with a string q using I/O operations, where B is the size of a disk block. It also supports an insertion and a deletion of a string q with the same number of I/Os. The data structure requires O(n/B) blocks, and the running time for each operation is O(Blog (B) (n)+|q|).", "paper_title": "I/O Efficient Dynamic Data Structures for Longest Prefix Queries", "paper_id": "WOS:000313649000006"}