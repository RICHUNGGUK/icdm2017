{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "new_notion"}, {"score": 0.0047747348769918, "phrase": "conditional_oblivious_cast"}, {"score": 0.00444612502361583, "phrase": "b._receivers_a"}, {"score": 0.004157446556371582, "phrase": "message_m."}, {"score": 0.004105435059094976, "phrase": "coc_scheme"}, {"score": 0.004054071599735255, "phrase": "predicate_q"}, {"score": 0.003790751492305239, "phrase": "masked_form"}, {"score": 0.0031982923263972896, "phrase": "coc"}, {"score": 0.002318728604587962, "phrase": "fundamental_schemes"}, {"score": 0.0021861845339709533, "phrase": "homomorphic_encryption_schemes"}, {"score": 0.0021049977753042253, "phrase": "encryption_schemes"}], "paper_keywords": ["oblivious cast", " conditional oblivious transfer", " secure computation"], "paper_abstract": "We introduce a new notion of conditional oblivious cast (COC), which involves three parties: a sender S and two receivers A and B. Receivers A and B own their secrets x and y, respectively, and the sender S holds the message m. In a COC scheme for the predicate Q (Q-COC), A and B send x and y in a masked form to S, and then S sends m to A and B such that they get m if and only if Q(x, y) = 1. Besides, the secrets x and y can not be revealed to another receiver nor the sender. We also extend COC to 1-out-of-2 COC (COC(2)/(1)) in which S holds two messages m(0) and m(1), and A and B get m(1) if Q(x, y) = 1 and m(0) otherwise. We give the definitions for COC and COC(2)/(1), and propose several COC and COC(2)/(1) schemes for \"equality\", \"inequality\", and \"greater than\" predicates. These are fundamental schemes that are useful in constructing more complex secure interactive protocols. Our schemes are efficiently constructed via homomorphic encryption schemes and proved secure under the security of these encryption schemes.", "paper_title": "Conditional oblivious cast", "paper_id": "WOS:000238186800029"}