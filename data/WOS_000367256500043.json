{"auto_keywords": [{"score": 0.033794403110393854, "phrase": "nominal_adapton"}, {"score": 0.00481495049065317, "phrase": "significant_progress"}, {"score": 0.004275904315753662, "phrase": "key_design_challenge"}, {"score": 0.004136044939878838, "phrase": "efficient_incremental_support"}, {"score": 0.004077508669922702, "phrase": "broad_range"}, {"score": 0.0038698476651328898, "phrase": "first-class_names"}, {"score": 0.003815064377019477, "phrase": "critical_linguistic_feature"}, {"score": 0.0037789720824759503, "phrase": "efficient_incremental_computation"}, {"score": 0.0036207206487324506, "phrase": "differing_runs"}, {"score": 0.003485605409687907, "phrase": "first_class"}, {"score": 0.003419943984098415, "phrase": "high_level"}, {"score": 0.0030802351224657673, "phrase": "incremental_computation"}, {"score": 0.002632716358833918, "phrase": "nominal_adapton's_implementation"}, {"score": 0.002522344964242888, "phrase": "core_calculus"}, {"score": 0.0024397017438101726, "phrase": "scratch_consistent"}, {"score": 0.0021763278640166707, "phrase": "large_speedups"}, {"score": 0.0021251363422701446, "phrase": "scratch_computation"}, {"score": 0.00210499793205176, "phrase": "adapton"}], "paper_keywords": ["laziness", " thunks", " call-by-push-value (CBPV)", " demanded computation graph (DCG)", " incremental computation", " self-adjusting computation", " memoization", " nominal matching", " structural matching"], "paper_abstract": "Over the past thirty years, there has been significant progress in developing general-purpose, language-based approaches to incremental computation, which aims to efficiently update the result of a computation when an input is changed. A key design challenge in such approaches is how to provide efficient incremental support for a broad range of programs. In this paper, we argue that first-class names are a critical linguistic feature for efficient incremental computation. Names identify computations to be reused across differing runs of a program, and making them first class gives programmers a high level of control over reuse. We demonstrate the benefits of names by presenting NOMINAL ADAPTON, an ML-like language for incremental computation with names. We describe how to use NOMINAL ADAPTON to efficiently incrementalize several standard programming patterns-including maps, folds, and unfolds-and show how to build efficient, incremental probabilistic trees and tries. Since NOMINAL ADAPTON's implementation is subtle, we formalize it as a core calculus and prove it is from-scratch consistent, meaning it always produces the same answer as simply re-running the computation. Finally, we demonstrate that NOMINAL ADAPTON can provide large speedups over both from-scratch computation and ADAPTON, a previous state-of-the-art incremental computation system.", "paper_title": "Incremental Computation with Names", "paper_id": "WOS:000367256500043"}