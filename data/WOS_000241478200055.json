{"auto_keywords": [{"score": 0.035494937700658244, "phrase": "kinetic_algorithms"}, {"score": 0.004815330156136918, "phrase": "kinetic"}, {"score": 0.004693476992528682, "phrase": "self-adjusting_computation"}, {"score": 0.004536244367689415, "phrase": "static_algorithm"}, {"score": 0.004273601449537163, "phrase": "combinatorial_property"}, {"score": 0.003423969509052361, "phrase": "static_algorithms"}, {"score": 0.0028623555849897632, "phrase": "dynamic_and_kinetic_changes"}, {"score": 0.0026734504926268442, "phrase": "fixed-precision_floating-point_arithmetic"}, {"score": 0.0021049977753042253, "phrase": "experimental_evaluation"}], "paper_keywords": [""], "paper_abstract": "Define a static algorithm as an algorithm that computes some combinatorial property of its input consisting of static, i.e., non-moving, objects. In this paper, we describe a technique for syntactically transforming static algorithms into kinetic algorithms, which compute properties of moving objects. The technique offers capabilities for composing kinetic algorithms, for integrating dynamic and kinetic changes, and for ensuring robustness even with fixed-precision floating-point arithmetic. To evaluate the effectiveness of the approach, we implement a library for performing the transformation, transform a number of algorithms, and give an experimental evaluation. The results show that the technique performs well in practice.", "paper_title": "Kinetic algorithms via self-adjusting computation", "paper_id": "WOS:000241478200055"}