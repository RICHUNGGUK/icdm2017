{"auto_keywords": [{"score": 0.03874388704349604, "phrase": "memory_fences"}, {"score": 0.012704487900510996, "phrase": "minimal_set"}, {"score": 0.01262730467245758, "phrase": "memory_access_pairs"}, {"score": 0.008594335061135341, "phrase": "centralized_active_table"}, {"score": 0.00481495049065317, "phrase": "conditional_fences"}, {"score": 0.004472760779811399, "phrase": "processor_designers"}, {"score": 0.004404577716425371, "phrase": "relaxed_memory_consistency_models"}, {"score": 0.004364165612189736, "phrase": "weaker_ordering_constraints"}, {"score": 0.004206175629459691, "phrase": "higher_performance"}, {"score": 0.004116658579367809, "phrase": "weaker_consistency_models"}, {"score": 0.0038004763029270373, "phrase": "sc."}, {"score": 0.003423209685399778, "phrase": "memory_accesses"}, {"score": 0.003278937848591921, "phrase": "normal_course"}, {"score": 0.0032588283962316817, "phrase": "program_execution"}, {"score": 0.0030927866759789045, "phrase": "executed_instances"}, {"score": 0.002935180093286085, "phrase": "conditional_fence_mechanism"}, {"score": 0.0028726347068397887, "phrase": "compiler_information"}, {"score": 0.0026435894486890594, "phrase": "c-fences"}, {"score": 0.0024857542101349808, "phrase": "normal_fence_instructions"}, {"score": 0.002231828204535298, "phrase": "increasing_number"}, {"score": 0.002177522137110944, "phrase": "distributed_active_table"}, {"score": 0.0021245346610409715, "phrase": "c-fence"}, {"score": 0.0021049977753042253, "phrase": "larger_number"}], "paper_keywords": ["Memory consistency", " Sequential consistency", " Interprocessor delay", " Associates", " Conditional fences", " Active table"], "paper_abstract": "Among the various memory consistency models, the sequential consistency (SC) model is the most intuitive and enables programmers to reason about their parallel programs the best. Nevertheless, processor designers often choose to support relaxed memory consistency models because the weaker ordering constraints imposed by such models allow for more instructions to be reordered and enable higher performance. Programs running on machines supporting weaker consistency models can be transformed into ones in which SC is enforced. The compiler does this by computing a minimal set of memory access pairs whose ordering automatically guarantees SC. To ensure that these memory access pairs are not reordered, memory fences are inserted. Unfortunately, insertion of such memory fences can significantly slowdown the program. We observe that the ordering of the minimal set of memory accesses that the compiler strives to enforce, is typically already enforced in the normal course of program execution. A study we conducted on programs with compiler inserted memory fences shows that only 8% of the executed instances of the memory fences are really necessary to ensure SC. Motivated by this study we propose the conditional fence mechanism, known as C-Fence that utilizes compiler information to decide dynamically if there is a need to stall at each fence, only stalling when necessary. Our experiments with SPLASH-2 benchmarks show that, with C-Fences and a centralized active table, programs can be transformed to enforce SC incurring only 12% slowdown, as opposed to 43% slowdown using normal fence instructions. Our approach requires very little hardware support (< 350 bytes of on-chip-storage) and it avoids the use of speculation and its associated costs. Furthermore, to ameliorate the contention in the centralized active table arising from the increasing number of processors, we also design a distributed active table, which further improves the performance of C-Fence for a larger number of processors.", "paper_title": "Efficient Sequential Consistency Using Conditional Fences", "paper_id": "WOS:000299006000005"}