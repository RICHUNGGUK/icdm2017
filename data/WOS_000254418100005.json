{"auto_keywords": [{"score": 0.03833105225751244, "phrase": "imported_traits"}, {"score": 0.00481495049065317, "phrase": "featherweight_java"}, {"score": 0.004491313367627919, "phrase": "trait_composition"}, {"score": 0.004153041453795458, "phrase": "incomplete_stateless_class"}, {"score": 0.0037903327482565097, "phrase": "state_variables"}, {"score": 0.003757480190200645, "phrase": "additional_methods"}, {"score": 0.0037087324991876727, "phrase": "conflicting_names"}, {"score": 0.003581797255879607, "phrase": "feathertrait_java"}, {"score": 0.0034291991359158827, "phrase": "simple_lightweight_class-based_calculus"}, {"score": 0.0033262524445013303, "phrase": "statically_typed_traits"}, {"score": 0.003283082317661543, "phrase": "ftj"}, {"score": 0.0031568884810273226, "phrase": "basic_behavioral_bricks"}, {"score": 0.003129509028432954, "phrase": "method_conflicts"}, {"score": 0.002906138793910919, "phrase": "method_names"}, {"score": 0.0027581067089091434, "phrase": "conflicting_methods"}, {"score": 0.0026175952455594277, "phrase": "operational_semantics"}, {"score": 0.002583597507349819, "phrase": "lookup_algorithm"}, {"score": 0.0024519545383399773, "phrase": "well-typed_expression"}, {"score": 0.0024095777415804346, "phrase": "message-_not-understood_runtime_error"}, {"score": 0.002286781334850213, "phrase": "increased_expressive_power"}, {"score": 0.002257070536352418, "phrase": "trait-based_inheritance_model"}, {"score": 0.0021702292394814144, "phrase": "good_starting_point"}, {"score": 0.0021420294823879292, "phrase": "rigorous_mathematical_analysis"}, {"score": 0.002123433075137768, "phrase": "typed_class-based_languages"}, {"score": 0.0021049977753042253, "phrase": "trait-based_inheritance"}], "paper_keywords": ["design", " languages", " theory", " Java", " inheritance", " language design", " language semantics"], "paper_abstract": "In the context of statically typed, class-based languages, we investigate classes that can be extended with trait composition. A trait is a collection of methods without state; it can be viewed as an incomplete stateless class. Traits can be composed in any order, but only make sense when imported by a class that provides state variables and additional methods to disambiguate conflicting names arising between the imported traits. We introduce FeatherTrait Java (FTJ), a conservative extension of the simple lightweight class-based calculus Featherweight Java (FJ) with statically typed traits. In FTJ, classes can be built using traits as basic behavioral bricks; method conflicts between imported traits must be resolved explicitly by the user either by (i) aliasing or excluding method names in traits, or by (ii) overriding explicitly the conflicting methods in the class or in the trait itself We present an operational semantics with a lookup algorithm, and a sound type system that guarantees that evaluating a well-typed expression never yields a message- not-understood runtime error nor gets the interpreter stuck. We give examples of the increased expressive power of the trait-based inheritance model. The resulting calculus appears to be a good starting point for a rigorous mathematical analysis of typed class-based languages featuring trait-based inheritance.", "paper_title": "FeatherTrait: A modest extension of Featherweight Java", "paper_id": "WOS:000254418100005"}