{"auto_keywords": [{"score": 0.029318943085933878, "phrase": "shared_memory"}, {"score": 0.022653347708486368, "phrase": "eventual_leader"}, {"score": 0.005979733696090779, "phrase": "bounded_domain"}, {"score": 0.005622905892129288, "phrase": "second_protocol"}, {"score": 0.00481495049065317, "phrase": "eventual_leader_service"}, {"score": 0.004794542276973129, "phrase": "asynchronous_shared_memory_systems"}, {"score": 0.004663971224237778, "phrase": "asynchronous_shared_memory_system"}, {"score": 0.004546587993454305, "phrase": "message-passing_systems"}, {"score": 0.004469971027498137, "phrase": "shared_memory_systems"}, {"score": 0.004366717164250744, "phrase": "pure_asynchronous_system"}, {"score": 0.0042477474580295705, "phrase": "asynchronous_system_model"}, {"score": 0.004220754501637625, "phrase": "additional_assumption"}, {"score": 0.0038685241112362974, "phrase": "shared_variables"}, {"score": 0.0036760909236807503, "phrase": "maximal_number"}, {"score": 0.0035987531472238474, "phrase": "actual_number"}, {"score": 0.003583481235876914, "phrase": "process_crashes"}, {"score": 0.0035305363123217678, "phrase": "asymptotically_well-behaved_timer_notion"}, {"score": 0.003456250098004831, "phrase": "traditional_notion"}, {"score": 0.003270315493693848, "phrase": "arbitrary_times"}, {"score": 0.0031141643006047386, "phrase": "t-resilient_awb-based_eventual_leader_protocols"}, {"score": 0.0029654468400831407, "phrase": "wait-free_protocols"}, {"score": 0.0028906880658354918, "phrase": "process_failures"}, {"score": 0.0023068308410432643, "phrase": "bounded_shared_memory_model"}, {"score": 0.0021686974717293308, "phrase": "inherent_tradeoff"}], "paper_keywords": ["Asynchronous system", " Atomic register", " Eventual leader", " Fault-tolerance", " Omega", " Process crash", " Shared memory", " System model", " Timer property", " Timing assumptions", " t-resilient protocol"], "paper_abstract": "This paper considers the problem of electing an eventual leader in an asynchronous shared memory system. While this problem has received a lot of attention in message-passing systems, very few solutions have been proposed for shared memory systems. As an eventual leader cannot be elected in a pure asynchronous system prone to process crashes, the paper first proposes to enrich the asynchronous system model with an additional assumption. That assumption (denoted AWB) is particularly weak. It is made up of two complementary parts. More precisely, it requires that, after some time, (1) there is a process whose write accesses to some shared variables be timely, and (2) the timers of (t-f) other processes be asymptotically well-behaved (t denotes the maximal number of processes that may crash, and f the actual number of process crashes in a run). The asymptotically well-behaved timer notion is a new notion that generalizes and weakens the traditional notion of timers whose durations are required to monotonically increase when the values they are set to increase (a timer works incorrectly when it expires at arbitrary times, i.e., independently of the value it has been set to). The paper then focuses on the design of t-resilient AWB-based eventual leader protocols. \"t-resilient\" means that each protocol can cope with up to t process crashes (taking t=n-1 provides wait-free protocols, i.e., protocols that can cope with any number of process failures). Two protocols are presented. The first enjoys the following noteworthy properties: after some time only the elected leader has to write the shared memory, and all but one shared variables have a bounded domain, be the execution finite or infinite. This protocol is consequently optimal with respect to the number of processes that have to write the shared memory. The second protocol guarantees that all the shared variables have a bounded domain. This is obtained at the following additional price: t+1 processes are required to forever write the shared memory. A theorem is proved which states that this price has to be paid by any protocol that elects an eventual leader in a bounded shared memory model. This second protocol is consequently optimal with respect to the number of processes that have to write in such a constrained memory model. In a very interesting way, these protocols show an inherent tradeoff relating the number of processes that have to write the shared memory and the bounded/unbounded attribute of that memory.", "paper_title": "A Timing Assumption and Two t-Resilient Protocols for Implementing an Eventual Leader Service in Asynchronous Shared Memory Systems", "paper_id": "WOS:000273587100009"}