{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "loop_fusion"}, {"score": 0.04310416641082635, "phrase": "polyhedral_compiler_framework"}, {"score": 0.014610885098352344, "phrase": "traditional_compilers"}, {"score": 0.00475254914916922, "phrase": "polyhedral_framework"}, {"score": 0.004650330504968421, "phrase": "important_compiler"}, {"score": 0.00457013354092966, "phrase": "memory_hierarchy_performance"}, {"score": 0.0045108906244892165, "phrase": "data_reuse"}, {"score": 0.004028452405970376, "phrase": "complex_transformations"}, {"score": 0.0038737214010638745, "phrase": "loop_optimizations"}, {"score": 0.0038401488612789963, "phrase": "small_programs"}, {"score": 0.0037411604449359794, "phrase": "large_programs"}, {"score": 0.0037087324991876727, "phrase": "state-of-the-art_polyhedral_compiler_frameworks"}, {"score": 0.003384695931421288, "phrase": "effective_cost_model"}, {"score": 0.0033262524445013303, "phrase": "good_fusion"}, {"score": 0.00326881479036966, "phrase": "possible_choices"}, {"score": 0.0031431690368229443, "phrase": "program_statements"}, {"score": 0.0030223381739019894, "phrase": "fusion_algorithm"}, {"score": 0.0029830992938695007, "phrase": "good_fusion_partitions"}, {"score": 0.002918826667294298, "phrase": "good_data_reuse"}, {"score": 0.002831158147480665, "phrase": "source_code"}, {"score": 0.0027341763737751467, "phrase": "previous_work"}, {"score": 0.002675252546913683, "phrase": "new_challenges"}, {"score": 0.002357632753637638, "phrase": "proposed_objectives"}, {"score": 0.0023371689326096476, "phrase": "experimental_results"}, {"score": 0.0022472527731744974, "phrase": "existing_polyhedral_compilers"}, {"score": 0.0022277448907881306, "phrase": "small_kernel_programs"}, {"score": 0.0021607883988873492, "phrase": "large_benchmark_programs"}, {"score": 0.0021049977753042253, "phrase": "spec_benchmark_suite"}], "paper_keywords": ["Loop fusion", " Polyhedral framework", " Data reuse", " Coarse-grained parallelism"], "paper_abstract": "Loop fusion is an important compiler optimization for improving memory hierarchy performance through enabling data reuse. Traditional compilers have approached loop fusion in a manner decoupled from other high-level loop optimizations, missing several interesting solutions. Recently, the polyhedral compiler framework with its ability to compose complex transformations, has proved to be promising in performing loop optimizations for small programs. However, our experiments with large programs using state-of-the-art polyhedral compiler frameworks reveal suboptimal fusion partitions in the transformed code. We trace the reason for this to be lack of an effective cost model to choose a good fusion partitioning among the possible choices, which increase exponentially with the number of program statements. In this paper, we propose a fusion algorithm to choose good fusion partitions with two objective functions - achieving good data reuse and preserving parallelism inherent in the source code. These objectives, although targeted by previous work in traditional compilers, pose new challenges within the polyhedral compiler framework and have thus not been addressed. In our algorithm, we propose several heuristics that work effectively within the polyhedral compiler framework and allow us to achieve the proposed objectives. Experimental results show that our fusion algorithm achieves performance comparable to the existing polyhedral compilers for small kernel programs, and significantly outperforms them for large benchmark programs such as those in the SPEC benchmark suite.", "paper_title": "Revisiting Loop Fusion in the Polyhedral Framework", "paper_id": "WOS:000349142100021"}