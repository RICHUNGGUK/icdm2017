{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "revision_history"}, {"score": 0.0046141941030386525, "phrase": "project_revisions"}, {"score": 0.004575053987970206, "phrase": "helpful_information"}, {"score": 0.0044786435725543685, "phrase": "existing_studies"}, {"score": 0.004328576620172575, "phrase": "bug_patterns"}, {"score": 0.004148014765950199, "phrase": "code_hunk"}, {"score": 0.003991932110277654, "phrase": "original_and_copied_hunks"}, {"score": 0.003760685138103153, "phrase": "normal_state"}, {"score": 0.0036037265181631324, "phrase": "specific_revision"}, {"score": 0.003557924423642353, "phrase": "partial_change"}, {"score": 0.0034977560416755726, "phrase": "duplicated_hunks"}, {"score": 0.003409399407390298, "phrase": "suspicious_hunks"}, {"score": 0.003309124298009635, "phrase": "suspicious_cases"}, {"score": 0.0032255172568437965, "phrase": "project's_developers"}, {"score": 0.0030645676308053444, "phrase": "practical_approach"}, {"score": 0.0029617414861784525, "phrase": "code_hunk_tracking"}, {"score": 0.002886885861509621, "phrase": "suspicious_change_patterns"}, {"score": 0.002825949329865926, "phrase": "potential_bugs"}, {"score": 0.0027781249331615813, "phrase": "partial_death"}, {"score": 0.0026734504926268442, "phrase": "backward_or_late_change"}, {"score": 0.002617007341172262, "phrase": "change_smells"}, {"score": 0.002413153346716919, "phrase": "automated_tool"}, {"score": 0.0022634699331607615, "phrase": "proposed_technique"}, {"score": 0.0021968238865548812, "phrase": "large-scale_open_projects"}, {"score": 0.002159623311924437, "phrase": "study_results"}, {"score": 0.0021049977753042253, "phrase": "proposed_approach"}], "paper_keywords": ["change", " bug", " refactoring", " code hunk", " revision history"], "paper_abstract": "Change history in project revisions provides helpful information on handling bugs. Existing studies on predicting bugs mainly focus on resulting bug patterns,, not these change patterns. When a code hunk is copied onto several files, the set of original and copied hunks often need to be consistently maintained. We assume that it is a normal state when all of hunks survive or die in a specific revision. When partial change occurs on some duplicated hunks, they are regarded as suspicious hunks. Based on these assumptions, suspicious cases can be predicted and the project's developers can be alerted. In this paper, we propose a practical approach to detect various change smells based on revision history and code hunk tracking. The change smells are suspicious change patterns that can result in potential bugs, such as partial death of hunks, missed refactoring or fix, backward or late change. To detect these change smells, three kinds of hunks - add, delete, and modify - are tracked and analyzed by an automated tool. Several visualized graphs for each type have been suggested to improve the applicability of the proposed technique. We also conducted experiments on large-scale open projects. The case study results show the applicability of the proposed approach.", "paper_title": "Detecting and Visualizing Change Smells Based on Revision History and Code Hunk's Lifecycle", "paper_id": "WOS:000293664700006"}