{"auto_keywords": [{"score": 0.03321325200261326, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "high_road"}, {"score": 0.004721162131188487, "phrase": "low_level"}, {"score": 0.004479855062309818, "phrase": "high-level_language"}, {"score": 0.0041136473765874815, "phrase": "resulting_low-level_operations"}, {"score": 0.003777261911983744, "phrase": "low-level_ir"}, {"score": 0.0031845067058084583, "phrase": "graal_compiler"}, {"score": 0.0030414140732789186, "phrase": "different_approach"}, {"score": 0.0029238768315330305, "phrase": "java_code"}, {"score": 0.002764262033356339, "phrase": "graal"}, {"score": 0.002218668420806254, "phrase": "machine_code"}, {"score": 0.0021049977753042253, "phrase": "java_hotspot_vm."}], "paper_keywords": ["Algorithms", " Languages", " Performance", " Java", " Graal", " snippet", " compiler", " dynamic compilation", " just-in-time compilation"], "paper_abstract": "When building a compiler for a high-level language, certain intrinsic features of the language must be expressed in terms of the resulting low-level operations. Complex features are often expressed by explicitly weaving together bits of low-level IR, a process that is tedious, error prone, difficult to read, difficult to reason about, and machine dependent. In the Graal compiler for Java, we take a different approach: we use snippets of Java code to express semantics in a high-level, architecture-independent way. Two important restrictions make snippets feasible in practice: they are compiler specific, and they are explicitly prepared and specialized. Snippets make Graal simpler and more portable while still capable of generating machine code that can compete with other compilers of the Java HotSpot VM.", "paper_title": "Snippets: Taking the High Road to a Low Level", "paper_id": "WOS:000357952000012"}