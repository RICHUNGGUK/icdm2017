{"auto_keywords": [{"score": 0.03836231360872607, "phrase": "opencl_applications"}, {"score": 0.00481495049065317, "phrase": "opencl_performance_evaluation_on"}, {"score": 0.004785356349906913, "phrase": "modern_multicore_cpus"}, {"score": 0.004697655699119423, "phrase": "heterogeneous_platforms"}, {"score": 0.004527024978801684, "phrase": "general_trend"}, {"score": 0.004416713079266374, "phrase": "portability_issue"}, {"score": 0.00405127920820053, "phrase": "portable_execution"}, {"score": 0.004001593118269276, "phrase": "heterogeneous_architectures"}, {"score": 0.0039040344230094164, "phrase": "unpredictable_performance_variation"}, {"score": 0.0038561471948364723, "phrase": "different_platforms"}, {"score": 0.0034935290662899488, "phrase": "conventional_multicore_cpus"}, {"score": 0.0033664873319204027, "phrase": "general_opencl_applications"}, {"score": 0.0033251716926666437, "phrase": "cpus_lags"}, {"score": 0.003145417398038261, "phrase": "conventional_parallel_programming_model"}, {"score": 0.0028670988845838296, "phrase": "out-of-order_multicore_cpus"}, {"score": 0.0026458529352300446, "phrase": "api"}, {"score": 0.0025495426598675583, "phrase": "instruction-level_parallelism"}, {"score": 0.002456744238900652, "phrase": "data_locality"}, {"score": 0.0023382335380460304, "phrase": "conventional_parallel_programming_models"}, {"score": 0.0022531089868518235, "phrase": "unique_performance_characteristics"}, {"score": 0.0021311850321045767, "phrase": "optimization_metrics"}, {"score": 0.0021049977753042253, "phrase": "better_performance"}], "paper_keywords": [""], "paper_abstract": "Utilizing heterogeneous platforms for computation has become a general trend, making the portability issue important. OpenCL (Open Computing Language) serves this purpose by enabling portable execution on heterogeneous architectures. However, unpredictable performance variation on different platforms has become a burden for programmers who write OpenCL applications. This is especially true for conventional multicore CPUs, since the performance of general OpenCL applications on CPUs lags behind the performance of their counterparts written in the conventional parallel programming model for CPUs. In this paper, we evaluate the performance of OpenCL applications on out-of-order multicore CPUs from the architectural perspective. We evaluate OpenCL applications on various aspects, including API overhead, scheduling overhead, instruction-level parallelism, address space, data location, data locality, and vectorization, comparing OpenCL to conventional parallel programming models for CPUs. Our evaluation indicates unique performance characteristics of OpenCL applications and also provides insight into the optimization metrics for better performance on CPUs.", "paper_title": "OpenCL Performance Evaluation on Modern Multicore CPUs", "paper_id": "WOS:000362773700001"}