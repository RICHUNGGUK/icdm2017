{"auto_keywords": [{"score": 0.04890702046127256, "phrase": "soft_errors"}, {"score": 0.011658501178121049, "phrase": "restore_architecture"}, {"score": 0.00481495049065317, "phrase": "large-scale_integration"}, {"score": 0.004736045157669388, "phrase": "growing_concerns"}, {"score": 0.0043966173385891925, "phrase": "ecc"}, {"score": 0.004271234971981848, "phrase": "regular_sram_structures"}, {"score": 0.004149429072483132, "phrase": "growing_soft_error_tide"}, {"score": 0.0038838500580958744, "phrase": "best_way"}, {"score": 0.003502382624110703, "phrase": "existing_performance"}, {"score": 0.003473529187092258, "phrase": "checkpointing_hardware"}, {"score": 0.0034165310204389682, "phrase": "soft_error_events"}, {"score": 0.0033743949483348626, "phrase": "low_cost_fashion"}, {"score": 0.0033465923623290034, "phrase": "error_detection"}, {"score": 0.0030935955379958395, "phrase": "previous_checkpoint"}, {"score": 0.0030680994147125364, "phrase": "example_symptoms"}, {"score": 0.0030177339185643226, "phrase": "control_flow_misspeculations"}, {"score": 0.0029437270961011077, "phrase": "look-aside_buffer_misses"}, {"score": 0.0028953973490895746, "phrase": "conventional_soft_error_detection"}, {"score": 0.0028243822059448266, "phrase": "restore_framework"}, {"score": 0.0027211030647461324, "phrase": "error_coverage"}, {"score": 0.0023834640793589414, "phrase": "example_restore_implementation"}, {"score": 0.0023346243155212263, "phrase": "mtbf"}, {"score": 0.0022492129111567824, "phrase": "standard_pipeline"}, {"score": 0.0022306602656266545, "phrase": "minimal_hardware_and_performance_overheads"}, {"score": 0.0021579652707793833, "phrase": "restore"}], "paper_keywords": ["simulation", " fault tolerance", " fault injection", " redundant design"], "paper_abstract": "Device scaling and large-scale integration have led to growing concerns about soft errors in microprocessors. To date, in all but the most demanding applications, implementing parity and ECC for caches and other large, regular SRAM structures have been sufficient to stem the growing soft error tide. This will not be the case for long and questions remain as to the best way to detect and recover from soft errors in the remainder of the processor-in particular, the less structured execution core. In this work, we propose the ReStore architecture, which leverages existing performance enhancing checkpointing hardware to recover from soft error events in a low cost fashion. Error detection in the ReStore architecture is novel: symptoms that hint at the presence of soft errors trigger restoration of a previous checkpoint. Example symptoms include exceptions, control flow misspeculations, and cache or translation look-aside buffer misses. Compared to conventional soft error detection via full replication, the ReStore framework incurs little overhead, but sacrifices some amount of error coverage. These attributes make it an ideal means to provide very cost effective error coverage for processor applications that can tolerate a nonzero, but small, soft error failure rate. Our evaluation of an example ReStore implementation exhibits a 2x increase in MTBF (mean time between failures) over a standard pipeline with minimal hardware and performance overheads. The MTBF increases by 20x if ReStore is coupled with protection for certain particularly vulnerable pipeline structures.", "paper_title": "ReStore: Symptom-based soft error detection in microprocessors", "paper_id": "WOS:000239423300003"}