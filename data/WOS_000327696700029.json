{"auto_keywords": [{"score": 0.04965786117733892, "phrase": "structural_recursion"}, {"score": 0.02887598296840458, "phrase": "ordered_graphs"}, {"score": 0.00481495049065317, "phrase": "structural_recursion_for_querying_ordered_graphs"}, {"score": 0.004446823283475876, "phrase": "algebraic_data_structures"}, {"score": 0.004330450801016359, "phrase": "important_role"}, {"score": 0.004292337783332826, "phrase": "functional_programming"}, {"score": 0.004198510172614725, "phrase": "systematic_way"}, {"score": 0.004106725110985659, "phrase": "functional_programs"}, {"score": 0.003946519058822334, "phrase": "structural_recursions"}, {"score": 0.003911771812701971, "phrase": "graph_data_structures"}, {"score": 0.003410565849262162, "phrase": "initial_algebra"}, {"score": 0.0032342101452939977, "phrase": "database_community"}, {"score": 0.003080548510001051, "phrase": "infinite_unordered_regular_trees"}, {"score": 0.002999823428906084, "phrase": "finiteness_property"}, {"score": 0.002908306074124806, "phrase": "desirable_properties"}, {"score": 0.0028826733506942554, "phrase": "query_languages"}, {"score": 0.0028195727965553367, "phrase": "new_graph_transformation_language"}, {"score": 0.002661883310629088, "phrase": "well-defined_bisimulation_relation"}, {"score": 0.0026036031415940563, "phrase": "special_epsilon-edges"}, {"score": 0.0025241429061867633, "phrase": "higher_order_graph_transformation_language"}, {"score": 0.0024798279465139688, "phrase": "simply_typed_lambda_calculus"}, {"score": 0.0023307492812556204, "phrase": "sibling_dimension"}, {"score": 0.0022595974985992664, "phrase": "general_framework"}, {"score": 0.0021049977753042253, "phrase": "open_problem"}], "paper_keywords": ["Structural Recursion", " Ordered Graphs", " Graph Query Language", " Bisimulation", " Optimization"], "paper_abstract": "Structural recursion, in the form of, for example, folds on lists and catamorphisms on algebraic data structures including trees, plays an important role in functional programming, by providing a systematic way for constructing and manipulating functional programs. It is, however, a challenge to define structural recursions for graph data structures, the most ubiquitous sort of data in computing. This is because unlike lists and trees, graphs are essentially not inductive and cannot be formalized as an initial algebra in general. In this paper, we borrow from the database community the idea of structural recursion on how to restrict recursions on infinite unordered regular trees so that they preserve the finiteness property and become terminating, which are desirable properties for query languages. We propose a new graph transformation language called lambda(FG) for transforming and querying ordered graphs, based on the well-defined bisimulation relation on ordered graphs with special epsilon-edges. The language lambda(FG) is a higher order graph transformation language that extends the simply typed lambda calculus with graph constructors and more powerful structural recursions, which is extended for transformations on the sibling dimension. It not only gives a general framework for manipulating graphs and reasoning about them, but also provides a solution to the open problem of how to define a structural recursion on ordered graphs, with the help of the bisimilarity for ordered graphs with epsilon-edges.", "paper_title": "Structural Recursion for Querying Ordered Graphs", "paper_id": "WOS:000327696700029"}