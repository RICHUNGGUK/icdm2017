{"auto_keywords": [{"score": 0.04775965888944303, "phrase": "data_locality"}, {"score": 0.04445141657725912, "phrase": "proposed_methodology"}, {"score": 0.042802955730421255, "phrase": "atlas"}, {"score": 0.03787491023995228, "phrase": "standard_mmm_algorithm"}, {"score": 0.033973814538635336, "phrase": "proc"}, {"score": 0.02433806111726009, "phrase": "better_performance"}, {"score": 0.00481495049065317, "phrase": "matrix-matrix_multiplication_algorithm"}, {"score": 0.004792465829413183, "phrase": "matrix-matrix_multiplication"}, {"score": 0.0047700969967003565, "phrase": "mmm"}, {"score": 0.004725636892256725, "phrase": "highly_important_kernel"}, {"score": 0.0047035673328271405, "phrase": "linear_algebra_algorithms"}, {"score": 0.004605516991658309, "phrase": "memory_utilization"}, {"score": 0.00454128308228393, "phrase": "mmm_algorithms"}, {"score": 0.004477941023634039, "phrase": "strassen-winograd_variant"}, {"score": 0.004135265657095481, "phrase": "self-tuning_libraries"}, {"score": 0.004068024800132232, "phrase": "mmm_algorithm"}, {"score": 0.003918392469564327, "phrase": "extremely_complex_empirical_tuning_step"}, {"score": 0.0038366467523757433, "phrase": "large_number"}, {"score": 0.0038187130044220288, "phrase": "compiler_options"}, {"score": 0.0036268693010639485, "phrase": "new_methodology"}, {"score": 0.0035595148635032704, "phrase": "improved_performance"}, {"score": 0.0033885809814835697, "phrase": "optimum_memory_management"}, {"score": 0.003333440836347026, "phrase": "ieee_trans"}, {"score": 0.0032492713612505535, "phrase": "li"}, {"score": 0.0032333994320541126, "phrase": "garzaran"}, {"score": 0.0031957666018657105, "phrase": "lang"}, {"score": 0.003180776394700745, "phrase": "compil"}, {"score": 0.003121681767513035, "phrase": "bilmes"}, {"score": 0.0029786851234338027, "phrase": "aberdeen"}, {"score": 0.0029648548003721803, "phrase": "baxter"}, {"score": 0.002950879546611178, "phrase": "concurr"}, {"score": 0.0027828640985339726, "phrase": "tile_level"}, {"score": 0.0027504236480281412, "phrase": "element_level"}, {"score": 0.0027183603320329462, "phrase": "better_data_locality"}, {"score": 0.0026740969828102715, "phrase": "memory_hierarchy"}, {"score": 0.002451803174880539, "phrase": "best_tile_size"}, {"score": 0.0024346086986678636, "phrase": "cache_level"}, {"score": 0.00241753451494621, "phrase": "software_tool"}, {"score": 0.002339421072433804, "phrase": "hardware_model"}, {"score": 0.0023230128956667436, "phrase": "matrix_sizes"}, {"score": 0.0022585203909344918, "phrase": "wide_range"}, {"score": 0.0022217279833754277, "phrase": "best_existing_related_work"}, {"score": 0.0021398708035702137, "phrase": "strassen"}, {"score": 0.0021049977753042253, "phrase": "recursive_data_array_layouts"}], "paper_keywords": ["Compilers", " Memory management", " Data locality", " Data reuse", " Recursive array layouts", " Scheduling", " Strassen's algorithm", " Matrix-matrix multiplication"], "paper_abstract": "Matrix-Matrix Multiplication (MMM) is a highly important kernel in linear algebra algorithms and the performance of its implementations depends on the memory utilization and data locality. There are MMM algorithms, such as standard, Strassen-Winograd variant, and many recursive array layouts, such as Z-Morton or U-Morton. However, their data locality is lower than that of the proposed methodology. Moreover, several SOA (state of the art) self-tuning libraries exist, such as ATLAS for MMM algorithm, which tests many MMM implementations. During the installation of ATLAS, on the one hand an extremely complex empirical tuning step is required, and on the other hand a large number of compiler options are used, both of which are not included in the scope of this paper. In this paper, a new methodology using the standard MMM algorithm is presented, achieving improved performance by focusing on data locality (both temporal and spatial). This methodology finds the scheduling which conforms with the optimum memory management. Compared with (Chatterjee et al. in IEEE Trans. Parallel Distrib. Syst. 13:1105, 2002; Li and Garzaran in Proc. of Lang. Compil. Parallel Comput., 2005; Bilmes et al. in Proc. of the 11th ACM Int. Conf. Super-comput., 1997; Aberdeen and Baxter in Concurr. Comput. Pract. Exp. 13:103, 2001), the proposed methodology has two major advantages. Firstly, the scheduling used for the tile level is different from the element level's one, having better data locality, suited to the sizes of memory hierarchy. Secondly, its exploration time is short, because it searches only for the number of the level of tiling used, and between (1, 2) (Sect. 4) for finding the best tile size for each cache level. A software tool (C-code) implementing the above methodology was developed, having the hardware model and the matrix sizes as input. This methodology has better performance against others at a wide range of architectures. Compared with the best existing related work, which we implemented, better performance up to 55% than the Standard MMM algorithm and up to 35% than Strassen's is observed, both under recursive data array layouts.", "paper_title": "A data locality methodology for matrix-matrix multiplication algorithm", "paper_id": "WOS:000298297000013"}