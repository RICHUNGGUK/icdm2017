{"auto_keywords": [{"score": 0.0496213341565463, "phrase": "codecharts"}, {"score": 0.010612387000973441, "phrase": "object-oriented_programs"}, {"score": 0.010411588556015887, "phrase": "software_design"}, {"score": 0.004501774379030109, "phrase": "design_decisions"}, {"score": 0.004437349839203418, "phrase": "implemented_programs"}, {"score": 0.004188702178897384, "phrase": "common_design_notations"}, {"score": 0.0041287394089001405, "phrase": "theoretical_concerns"}, {"score": 0.003992129945230457, "phrase": "practical_concerns"}, {"score": 0.003878625406105021, "phrase": "automated_verifiability"}, {"score": 0.0035914198812657897, "phrase": "visual_specifications"}, {"score": 0.0035399770257915466, "phrase": "automatically-verifiable_statements"}, {"score": 0.0032463805170627686, "phrase": "object-oriented_design"}, {"score": 0.0031845067058084583, "phrase": "inheritance_class_hierarchies"}, {"score": 0.003123808471618783, "phrase": "dynamically-bound_methods"}, {"score": 0.002948547333717581, "phrase": "pragmatic_concerns"}, {"score": 0.0028784478769295204, "phrase": "class_libraries"}, {"score": 0.002850875630787708, "phrase": "design_patterns"}, {"score": 0.0026268961477241026, "phrase": "design_verification"}, {"score": 0.0025034338848015166, "phrase": "java_program"}, {"score": 0.0023857603808363527, "phrase": "codechart"}, {"score": 0.0021563019696857768, "phrase": "fully-automated_design_verification_tool"}, {"score": 0.0021049977753042253, "phrase": "empirical_results"}], "paper_keywords": ["Design notations and documentation", " Object-oriented programming", " Patterns", " Design concepts"], "paper_abstract": "Software design, development and evolution commonly require programmers to model design decisions, visualize implemented programs, and detect conflicts between design and implementation. However, common design notations rarely reconcile theoretical concerns for rigor and minimality with the practical concerns for abstraction, scalability and automated verifiability. The language of Codecharts was designed to overcome these challenges by narrowing its scope to visual specifications that articulate automatically-verifiable statements about the structure and organization of object-oriented programs. The tokens in its visual vocabulary stand for the building-blocks of object-oriented design, such as inheritance class hierarchies, sets of dynamically-bound methods, and their correlations. The formalism was tailored for those pragmatic concerns which arise from modeling class libraries and design patterns, and for visualizing programs of any size at any level of abstraction. We describe design verification, a process of proving or refuting that a Java program (i.e. its native code) conforms to the Codechart specifying it. We also describe a toolkit which supports modeling and visualization with Codecharts, as well as a fully-automated design verification tool. We conclude with empirical results which suggest gains in both speed and accuracy when using Codecharts in software design, development and evolution.", "paper_title": "Modeling and visualizing object-oriented programs with Codecharts", "paper_id": "WOS:000321223500001"}