{"auto_keywords": [{"score": 0.04192102071091637, "phrase": "binary_strings"}, {"score": 0.00481495049065317, "phrase": "generate_binary_strings"}, {"score": 0.004750440867604888, "phrase": "binary_string"}, {"score": 0.0032115093493071366, "phrase": "cool-lex'_order"}, {"score": 0.0031898897009493467, "phrase": "ruskey"}, {"score": 0.0031684452967064387, "phrase": "williams"}, {"score": 0.003073545175760353, "phrase": "discrete_mathematics"}, {"score": 0.002931569771634119, "phrase": "loopless_algorithm"}, {"score": 0.002872742947035998, "phrase": "weight_range"}, {"score": 0.002843772431469196, "phrase": "successive_strings"}, {"score": 0.0027492917990724467, "phrase": "de_bruijn_sequences"}, {"score": 0.0021773853011112882, "phrase": "recursive_structure"}, {"score": 0.0021049977753042253, "phrase": "lexicographic_order"}], "paper_keywords": ["Cool-lex order", " Gray code", " Binary strings", " Combinatorics on words", " Necklace prefix algorithm", " FKM algorithm", " De Bruijn sequence", " Universal cycle", " Hamming distance", " Levenshtein distance"], "paper_abstract": "Pick a binary string of length n and remove its first bit b. Now insert b after the first remaining 10, or insert at the end if there is no remaining 10. Do it again. And again. Keep going! Eventually, you will cycle through all 2 (n) of the binary strings of length n. For example, are the binary strings of length n=4, where and . And if you only want strings with weight (number of 1s) between a\"\" and u? Just insert b instead of when the result would have too many 1s or too few 1s. For example, are the strings with n=4, a\"\"=0 and u=2. This generalizes 'cool-lex' order by Ruskey and Williams (The coolest way to generate combinations, Discrete Mathematics) and we present two applications of our 'cooler' order. First, we give a loopless algorithm for generating binary strings with any weight range in which successive strings have Levenshtein distance two. Second, we construct de Bruijn sequences for (i) a\"\"=0 and any u (maximum specified weight), (ii) any a\"\" and u=n (minimum specified weight), and (iii) odd u-a\"\" (even size weight range). For example, all binary strings with n=6, a\"\"=1, and u=4 appear once (cyclically) in . We also investigate the recursive structure of our order and show that it shares certain sublist properties with lexicographic order.", "paper_title": "The Coolest Way to Generate Binary Strings", "paper_id": "WOS:000334413600003"}