{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "partial_designs"}, {"score": 0.014851701578360988, "phrase": "incremental_fashion"}, {"score": 0.014561033199650394, "phrase": "bmc"}, {"score": 0.011034513549166626, "phrase": "qbf_formulas"}, {"score": 0.00934371253842668, "phrase": "reduced_solving_time"}, {"score": 0.004790975089388177, "phrase": "incremental_qbf._sat"}, {"score": 0.004743380135084562, "phrase": "indispensable_core_component"}, {"score": 0.0047197594186799054, "phrase": "numerous_formal_verification_tools"}, {"score": 0.004672868619910998, "phrase": "widespread_use"}, {"score": 0.004478701211579145, "phrase": "bounded_model_checking"}, {"score": 0.004346498210492316, "phrase": "sat_formulas"}, {"score": 0.004239302250446477, "phrase": "quantified_boolean_formulas"}, {"score": 0.004218187018485054, "phrase": "qbf"}, {"score": 0.004022683855673372, "phrase": "incremental_sat"}, {"score": 0.003923442530716965, "phrase": "qbf_problems"}, {"score": 0.0038075670544062724, "phrase": "core_component"}, {"score": 0.0037322171585537746, "phrase": "incremental_qbf_solver"}, {"score": 0.0036951011644192748, "phrase": "state-of-the-art_qbf_solver"}, {"score": 0.003585945274168956, "phrase": "previous_iterations"}, {"score": 0.0035591620927676463, "phrase": "search_space"}, {"score": 0.003335235224891481, "phrase": "solving_phase"}, {"score": 0.0032124925725216303, "phrase": "non-predictable_elimination"}, {"score": 0.003164665716798173, "phrase": "incremental_steps"}, {"score": 0.0031175486694208156, "phrase": "incremental_qbf_preprocessing"}, {"score": 0.003025402277791397, "phrase": "qbf_formula"}, {"score": 0.0029140286967542913, "phrase": "significant_size_reduction"}, {"score": 0.0027857639008498506, "phrase": "high_preprocessing_time"}, {"score": 0.0027305795652361685, "phrase": "incremental_preprocessing"}, {"score": 0.0024892011202241886, "phrase": "so-called_blackboxes"}, {"score": 0.0024705891356454524, "phrase": "unknown_parts"}, {"score": 0.0023736447757404487, "phrase": "unsafe_state"}, {"score": 0.00224089851484905, "phrase": "single_procedure"}, {"score": 0.0021368444454600093, "phrase": "partial_design_benchmarks"}, {"score": 0.002120861462413281, "phrase": "incremental_qbf_methods"}, {"score": 0.0021155603555266453, "phrase": "significant_performance_gains"}, {"score": 0.0021049977753042253, "phrase": "non_incremental_bmc"}], "paper_keywords": ["Incremental QBF", " BMC", " partial design verification", " blackbox"], "paper_abstract": "SAT solving is an indispensable core component of numerous formal verification tools and has found widespread use in industry, in particular when using it in an incremental fashion, e. g., in Bounded Model Checking (BMC). On the other hand, for some applications SAT formulas are not expressive enough, whereas a description via Quantified Boolean Formulas (QBF) is much more adequate, for instance when dealing with partial designs. Motivated by the success of incremental SAT, in this paper we explore various approaches to solve QBF problems in an incremental fashion and thereby make this technology usable as a core component of BMC. Firstly, we realized an incremental QBF solver based on the state-of-the-art QBF solver QuBE: Taking profit from the reuse of some information from previous iterations, the search space can be pruned, in some cases, to even less than a quarter. However, the need for preprocessing QBF formulas prior to the solving phase, that in general cannot be paired with incremental solving because of the non-predictable elimination of variables in the future incremental steps, posed the question of incremental QBF preprocessing. In this context we present an approach for retaining the QBF formula being preprocessed while extending its clauses and prefix incrementally. This procedure results in a significant size reduction of the QBF formulas, hence leading to a reduced solving time. As this may come together with a high preprocessing time, we analyze various heuristics to dynamically disable incremental preprocessing when its overhead raises over a certain threshold and is not compensated by the reduced solving time anymore. For proving the efficacy of our methods experimentally, as an application we consider BMC for partial designs (i.e., designs containing so-called blackboxes which represent unknown parts). Here, we disprove realizability, that is, we prove that an unsafe state is reachable no matter how the blackboxes are implemented. We examine all these incremental approaches from both the point of view of the effectiveness of the single procedure and the benefits that a range of QBF solvers can take from it. On a domain of partial design benchmarks, engaging incremental QBF methods significant performance gains over non incremental BMC can be achieved.", "paper_title": "Verification of partial designs using incremental QBF", "paper_id": "WOS:000349156700008"}