{"auto_keywords": [{"score": 0.03252422696923042, "phrase": "k_failures"}, {"score": 0.03232541789808835, "phrase": "p_processes"}, {"score": 0.00481495049065317, "phrase": "scalable_self-healing"}, {"score": 0.004769616966550469, "phrase": "high_performance_scientific_computing"}, {"score": 0.004650793657308996, "phrase": "today's_high-performance_computers"}, {"score": 0.004366469287481091, "phrase": "execution_time"}, {"score": 0.004177805391358892, "phrase": "node_failures"}, {"score": 0.0041384457437123635, "phrase": "complete_system_failure"}, {"score": 0.00408654006336477, "phrase": "today's_high-performance_computing_applications"}, {"score": 0.00389760315371842, "phrase": "surviving_processes"}, {"score": 0.0038730779753083787, "phrase": "surviving_nodes"}, {"score": 0.003776504983530801, "phrase": "whole_application"}, {"score": 0.0035904971126313316, "phrase": "self-healing_high-performance_numerical_computing_applications"}, {"score": 0.003349552702131293, "phrase": "diskless_checkpointing"}, {"score": 0.0032866843679612134, "phrase": "weighted_checksum_schemes"}, {"score": 0.003235193484261443, "phrase": "reed-solomon_erasure_codes"}, {"score": 0.0032148229832850215, "phrase": "floating-point_numbers"}, {"score": 0.003144527847739642, "phrase": "existing_diskless_checkpointing"}, {"score": 0.0028421959620622355, "phrase": "network_bandwidth"}, {"score": 0.0026850589169993143, "phrase": "local_checkpoint"}, {"score": 0.00264296841319955, "phrase": "additional_checkpoint_processors"}, {"score": 0.0024654516678953658, "phrase": "total_number"}, {"score": 0.002449915958738505, "phrase": "computational_processors"}, {"score": 0.002426795311298483, "phrase": "introduced_self-healing_algorithms"}, {"score": 0.002285335999629823, "phrase": "number_of_processes_p_increases"}, {"score": 0.0022494973475924024, "phrase": "performance_overhead"}, {"score": 0.0022072304165576405, "phrase": "preconditioned_conjugate_gradient_equation_solver"}, {"score": 0.0021726139494880653, "phrase": "experimental_results"}, {"score": 0.0021317885325570604, "phrase": "multiple_simultaneous_process_failures"}, {"score": 0.0021183508914633478, "phrase": "low-performance_overhead"}], "paper_keywords": ["Self-healing", " diskless checkpointing", " fault tolerance", " pipeline", " parallel and distributed systems", " high-performance computing", " Message Passing Interface"], "paper_abstract": "As the number of processors in today's high-performance computers continues to grow, the mean-time-to-failure of these computers is becoming significantly shorter than the execution time of many current high-performance computing applications. Although today's architectures are usually robust enough to survive node failures without suffering complete system failure, most of today's high-performance computing applications cannot survive node failures. Therefore, whenever a node fails, all surviving processes on surviving nodes usually have to be aborted and the whole application has to be restarted. In this paper, we present a framework for building self-healing high-performance numerical computing applications so that they can adapt to node or link failures without aborting themselves. The framework is based on FT-MPI and diskless checkpointing. Our diskless checkpointing uses weighted checksum schemes, a variation of Reed-Solomon erasure codes over floating-point numbers. We introduce several scalable encoding strategies into the existing diskless checkpointing and reduce the overhead to survive k failures in p processes from 2[log p].k((beta + 2 gamma)m + alpha) to (1 + O(root p/root m))(2).k(beta + 2 gamma)m, where alpha is the communication latency, 1/beta is the network bandwidth between processes, 1/gamma is the rate to perform calculations, and m is the size of local checkpoint per process. When additional checkpoint processors are used, the overhead can be reduced to (1 + O(root 1/m)).k(beta + 2 gamma)m, which is independent of the total number of computational processors. The introduced self-healing algorithms are scalable in the sense that the overhead to survive k failures in p processes does not increase as the number of processes p increases. We evaluate the performance overhead of our self-healing approach by using a preconditioned conjugate gradient equation solver as an example. Experimental results demonstrate that our self-healing scheme can survive multiple simultaneous process failures with low-performance overhead and little numerical impact.", "paper_title": "Highly Scalable Self-Healing Algorithms for High Performance Scientific Computing", "paper_id": "WOS:000270031000007"}