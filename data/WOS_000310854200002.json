{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "logic_programs"}, {"score": 0.04976229174017985, "phrase": "logic_programming"}, {"score": 0.0465541849746151, "phrase": "classical_negation"}, {"score": 0.03369319882976999, "phrase": "chosen_set"}, {"score": 0.027934813421901208, "phrase": "hypothetical_reasoning"}, {"score": 0.004704407458864224, "phrase": "rich_field"}, {"score": 0.0046269981365987915, "phrase": "logical_substratum"}, {"score": 0.004565984572487962, "phrase": "nonclassical_form"}, {"score": 0.004286931271697226, "phrase": "alternative_semantics"}, {"score": 0.004244449986839909, "phrase": "kripke-kleene_semantics"}, {"score": 0.004202387892988509, "phrase": "well-founded_semantics"}, {"score": 0.004160740888748725, "phrase": "stable_model_semantics"}, {"score": 0.004105850229681625, "phrase": "answer-set_semantics"}, {"score": 0.003945467978172845, "phrase": "aforementioned_semantics"}, {"score": 0.003919350990355722, "phrase": "particular_cases"}, {"score": 0.003880498041409292, "phrase": "generic_semantics"}, {"score": 0.0037662262006579023, "phrase": "unique_form"}, {"score": 0.003408990700300338, "phrase": "particular_semantics"}, {"score": 0.003341703245432554, "phrase": "particular_marking_scheme"}, {"score": 0.0032975819773787985, "phrase": "particular_set"}, {"score": 0.002527556628744957, "phrase": "global_assumptions"}, {"score": 0.002287542098172185, "phrase": "unified_view"}, {"score": 0.0021049977753042253, "phrase": "rule-based_systems"}], "paper_keywords": ["Kripke-Kleene semantics", " answer-set semantics", " stable model semantics", " well-founded semantics", " classical negation", " contextual hypotheses", " hypothetical reasoning"], "paper_abstract": "Logic programming has developed as a rich field, built over a logical substratum whose main constituent is a nonclassical form of negation, sometimes coexisting with classical negation. The field has seen the advent of a number of alternative semantics, with Kripke-Kleene semantics, the well-founded semantics, the stable model semantics, and the answer-set semantics standing out as the most successful. We show that all aforementioned semantics are particular cases of a generic semantics, in a framework where classical negation is the unique form of negation and where the literals in the bodies of the rules can be 'marked' to indicate that they can be the targets of hypotheses. A particular semantics then amounts to choosing a particular marking scheme and choosing a particular set of hypotheses. When a literal belongs to the chosen set of hypotheses, all marked occurrences of that literal in the body of a rule are assumed to be true, whereas the occurrences of that literal that have not been marked in the body of the rule are to be derived in order to contribute to the firing of the rule. Hence the notion of hypothetical reasoning that is presented in this framework is not based on making global assumptions, but more subtly on making local, contextual assumptions, taking effect as indicated by the chosen marking scheme on the basis of the chosen set of hypotheses. Our approach offers a unified view on the various semantics proposed in logic programming, classical in that only classical negation is used, and links the semantics of logic programs to mechanisms that endow rule-based systems with the power to harness hypothetical reasoning.", "paper_title": "Contextual hypotheses and semantics of logic programs", "paper_id": "WOS:000310854200002"}