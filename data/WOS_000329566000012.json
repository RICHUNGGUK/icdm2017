{"auto_keywords": [{"score": 0.04576637822440421, "phrase": "countable_nondeterminism"}, {"score": 0.00481495049065317, "phrase": "step-indexed_relational_reasoning"}, {"score": 0.0047152877145889656, "phrase": "countable_nondeterminism._programming_languages"}, {"score": 0.0046176782475198085, "phrase": "countable_nondeterministic_choice"}, {"score": 0.004115697805448384, "phrase": "concurrent_systems"}, {"score": 0.003988487841970088, "phrase": "countable_choice"}, {"score": 0.003905864553426306, "phrase": "non-continuous_behaviour"}, {"score": 0.003554661425339528, "phrase": "semantic_models"}, {"score": 0.003480993634130542, "phrase": "programming_languages"}, {"score": 0.0031678720736808574, "phrase": "step-indexed_logical_relations_model"}, {"score": 0.003069867656852932, "phrase": "higher-order_functional_programming_language"}, {"score": 0.002387214876538434, "phrase": "earlier_step-indexed_models"}, {"score": 0.0021049977753042253, "phrase": "step-indexed_relations"}], "paper_keywords": ["Countable choice", " lambda calculus", " program equivalence"], "paper_abstract": "Programming languages with countable nondeterministic choice are computationally interesting since countable nondeterminism arises when modeling fairness for concurrent systems. Because countable choice introduces non-continuous behaviour, it is well-known that developing semantic models for programming languages with countable nondeterminism is challenging. We present a step-indexed logical relations model of a higher-order functional programming language with countable nondeterminism and demonstrate how it can be used to reason about contextually defined may-and must-equivalence. In earlier step-indexed models, the indices have been drawn from omega. Here the step-indexed relations for must-equivalence are indexed over an ordinal greater than omega.", "paper_title": "STEP-INDEXED RELATIONAL REASONING FOR COUNTABLE NONDETERMINISM", "paper_id": "WOS:000329566000012"}