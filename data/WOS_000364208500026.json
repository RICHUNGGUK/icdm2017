{"auto_keywords": [{"score": 0.04958515830542698, "phrase": "polar_codes"}, {"score": 0.04215223424019578, "phrase": "scl_decoders"}, {"score": 0.010818821875171443, "phrase": "intermediate_decoding"}, {"score": 0.006962851673498928, "phrase": "coded_throughput"}, {"score": 0.006914983752271393, "phrase": "list_size"}, {"score": 0.00481495049065317, "phrase": "polar_codes_with"}, {"score": 0.00479833559982062, "phrase": "multibit_decision"}, {"score": 0.004699837689671504, "phrase": "first_provable_capacity-achieving_error-correcting_codes"}, {"score": 0.0045088388224419, "phrase": "decoding_performance"}, {"score": 0.0044469055125323466, "phrase": "traditional_successive-cancellation"}, {"score": 0.0042809216371527785, "phrase": "low-density_parity-check"}, {"score": 0.004251430406527723, "phrase": "turbo"}, {"score": 0.0041211075804202905, "phrase": "error-correcting_performance"}, {"score": 0.003899199029692063, "phrase": "practical_applications"}, {"score": 0.0038190873308414333, "phrase": "prior_latency_reduction"}, {"score": 0.0037796484923665855, "phrase": "sc_decoders"}, {"score": 0.0036764506727132253, "phrase": "list_decoders"}, {"score": 0.0036259093827331725, "phrase": "long-latency_bottleneck"}, {"score": 0.0035147084172295123, "phrase": "multibit-decision_approach"}, {"score": 0.0033484464719654105, "phrase": "reformulated_scl_algorithm"}, {"score": 0.003234509549830177, "phrase": "proposed_approach"}, {"score": 0.0030708096989903945, "phrase": "scl_decoder"}, {"score": 0.002865320947289691, "phrase": "general_case"}, {"score": 0.0028161281608563267, "phrase": "general_decoding_scheme"}, {"score": 0.002692132776447632, "phrase": "general_approach"}, {"score": 0.002538164420139397, "phrase": "overall_decoding_latency"}, {"score": 0.0023929806873862055, "phrase": "proposed_algorithms"}, {"score": 0.0022639147412879487, "phrase": "prior_scl_decoder"}], "paper_keywords": ["Algorithm reformulation", " list decoding", " multibit decision", " polar codes", " successive cancellation (SC)"], "paper_abstract": "Polar codes, as the first provable capacity-achieving error-correcting codes, have received much attention in recent years. However, the decoding performance of polar codes with traditional successive-cancellation (SC) algorithm cannot match that of the low-density parity-check or Turbo codes. Because SC list (SCL) decoding algorithm can significantly improve the error-correcting performance of polar codes, design of SCL decoders is important for polar codes to be deployed in practical applications. However, because the prior latency reduction approaches for SC decoders are not applicable for SCL decoders, these list decoders suffer from the long-latency bottleneck. In this paper, we propose a multibit-decision approach that can significantly reduce latency of SCL decoders. First, we present a reformulated SCL algorithm that can perform intermediate decoding of 2 b together. The proposed approach, referred as 2-bit reformulated SCL (2b-rSCL) algorithm, can reduce the latency of SCL decoder from (3n - 2) to (2n - 2) clock cycles without any performance loss. Then, we extend the idea of 2-b-decision to general case, and propose a general decoding scheme that can perform intermediate decoding of any 2(K) bits simultaneously. This general approach, referred as 2(K) -bit reformulated SCL (2(K) b-rSCL) algorithm, can reduce the overall decoding latency to as short as n/2(K-2) - 2 cycles. Furthermore, on the basis of the proposed algorithms, very large-scale integration architectures for 2b-rSCL and 4b-rSCL decoders are synthesized. Compared with a prior SCL decoder, the proposed (1024, 512) 2b-rSCL and 4b-rSCL decoders can achieve 21% and 60% reduction in latency, 1.66 and 2.77 times increase in coded throughput with list size 2, and 2.11 and 3.23 times increase in coded throughput with list size 4, respectively.", "paper_title": "Low-Latency Successive-Cancellation List Decoders for Polar Codes With Multibit Decision", "paper_id": "WOS:000364208500026"}