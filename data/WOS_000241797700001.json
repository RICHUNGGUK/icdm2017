{"auto_keywords": [{"score": 0.049655608595442394, "phrase": "domain_analysis"}, {"score": 0.019876248858286226, "phrase": "software_reuse"}, {"score": 0.005380968814552997, "phrase": "software_analogy"}, {"score": 0.004667541072056214, "phrase": "conventional_requirements_analysis"}, {"score": 0.004565007074039171, "phrase": "effective_software_reuse"}, {"score": 0.004308791766002289, "phrase": "particular_application_area"}, {"score": 0.004270665568018583, "phrase": "analogical_approaches"}, {"score": 0.0040309035566691645, "phrase": "analogical_problem"}, {"score": 0.0038556354709511818, "phrase": "well-understood_base_domain"}, {"score": 0.003804550737731054, "phrase": "new_target_problem_area"}, {"score": 0.003687960013746783, "phrase": "poorly_understood_problems"}, {"score": 0.0036553070575015344, "phrase": "new_application_areas"}, {"score": 0.0035908627899097407, "phrase": "similar_concepts"}, {"score": 0.0035118972210075633, "phrase": "analogy_theories"}, {"score": 0.003374094774912924, "phrase": "current_research"}, {"score": 0.0032129675521135616, "phrase": "base_domain"}, {"score": 0.003128336741911927, "phrase": "critical_aspects"}, {"score": 0.0031006232333900055, "phrase": "analogy_concepts"}, {"score": 0.003005539334280134, "phrase": "high_quality_artifacts"}, {"score": 0.0027989800906333784, "phrase": "analogy_methods"}, {"score": 0.0026771333996253783, "phrase": "complementary_roles"}, {"score": 0.002537880772794665, "phrase": "necessary_information"}, {"score": 0.002515384834484012, "phrase": "analogical_transfer"}, {"score": 0.002427372728532664, "phrase": "similar_problems"}, {"score": 0.0023739321566540682, "phrase": "previous_domain_analysis_knowledge"}, {"score": 0.002321665383971456, "phrase": "new_domain"}, {"score": 0.0022705467477443417, "phrase": "case_studies"}], "paper_keywords": ["requirements engineering", " domain analysis", " software analogy", " software reuse"], "paper_abstract": "Domain analysis is an expansion of conventional requirements analysis. Domain analysis can support effective software reuse. However, domain analysis is time consuming and is limited to a particular application area. Analogical approaches to software reuse, on the other hand, often occur across domains. Analogical problem solving is a process of transferring knowledge from a well-understood base domain to a new target problem area. Analogy can facilitate software reuse for poorly understood problems or new application areas. Analogy shares similar concepts with reuse and some analogy theories have been applied to software reuse. However, current research on software analogy often overlooks the importance of analysis for the base domain and does not consider some critical aspects of analogy concepts. Reuse must be based on high quality artifacts, especially reuse across domains. This paper presents an approach to integrate domain analysis and analogy methods. In our view, domain analysis and software analogy have complementary roles. Domain analysis is regarded as a process to identify and supply necessary information for analogical transfer. Software analogy can provide the analyst with similar problems and solutions to reuse previous domain analysis knowledge or artifacts for a new domain. This paper presents case studies to demonstrate the increase of efficiency in applying the approach. Evaluation of the approach from various perspectives is also reported.", "paper_title": "Analogy-based domain analysis approach to software reuse", "paper_id": "WOS:000241797700001"}