{"auto_keywords": [{"score": 0.04706226145554155, "phrase": "library_methods"}, {"score": 0.03274112472005228, "phrase": "client_code"}, {"score": 0.00481495049065317, "phrase": "object-oriented_concurrent_libraries"}, {"score": 0.004748371393578422, "phrase": "internal_synchronization_details"}, {"score": 0.004617949594931096, "phrase": "information_hiding"}, {"score": 0.0044495843279816075, "phrase": "thread_safety_violations"}, {"score": 0.00432733352307636, "phrase": "unsafe_manner"}, {"score": 0.004092774981286263, "phrase": "concurrent_library"}, {"score": 0.003943481134959376, "phrase": "interface_contracts"}, {"score": 0.003888905257972882, "phrase": "permissible_concurrent_method_calls"}, {"score": 0.0037820003983334476, "phrase": "method_arguments"}, {"score": 0.0035603115570447467, "phrase": "deadlock-free_execution"}, {"score": 0.003367188029221534, "phrase": "client_developers"}, {"score": 0.003320561182494713, "phrase": "required_assumptions"}, {"score": 0.003054009753601139, "phrase": "potential_deadlocks"}, {"score": 0.002956209594959227, "phrase": "static_analysis"}, {"score": 0.0029152570900178956, "phrase": "symbolic_encoding_scheme"}, {"score": 0.002874870266177579, "phrase": "lock_dependencies"}, {"score": 0.0027570267191549774, "phrase": "smt_solver"}, {"score": 0.0024543571925896073, "phrase": "cooperative_synchronization"}, {"score": 0.0023867931451842087, "phrase": "million_lines"}, {"score": 0.002331909406363425, "phrase": "widely-used_java_libraries"}, {"score": 0.0021049977753042253, "phrase": "real_deadlocks"}], "paper_keywords": ["Deadlock prediction", " Static analysis", " Concurrent libraries"], "paper_abstract": "Methods in object-oriented concurrent libraries often encapsulate internal synchronization details. As a result of information hiding, clients calling the library methods may cause thread safety violations by invoking methods in an unsafe manner. This is frequently a cause of deadlocks. Given a concurrent library, we present a technique for inferring interface contracts that specify permissible concurrent method calls and patterns of aliasing among method arguments. In this work, we focus on deriving contracts that guarantee deadlock-free execution for the methods in the library. The contracts also help client developers by documenting required assumptions about the library methods. Alternatively, the contracts can be statically enforced in the client code to detect potential deadlocks in the client. Our technique combines static analysis with a symbolic encoding scheme for tracking lock dependencies, allowing us to synthesize contracts using a SMT solver. Additionally, we investigate extensions of our technique to reason about deadlocks in libraries that employ signaling primitives such as wait-notify for cooperative synchronization. Our prototype tool analyzes over a million lines of code for some widely-used Java libraries within an hour, thus demonstrating its scalability and efficiency. Furthermore, the contracts inferred by our approach have been able to pinpoint real deadlocks in clients, i.e. deadlocks that have been a part of bug-reports filed by users and developers of client code.", "paper_title": "Symbolic modular deadlock analysis", "paper_id": "WOS:000292556500005"}