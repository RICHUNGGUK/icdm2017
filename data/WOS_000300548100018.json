{"auto_keywords": [{"score": 0.04468830753491191, "phrase": "higher-order_functions"}, {"score": 0.034182875683624124, "phrase": "refinement_logic"}, {"score": 0.00481495049065317, "phrase": "duck_typing"}, {"score": 0.004658426838467567, "phrase": "dynamic_languages"}, {"score": 0.004597244847332915, "phrase": "heavy_use"}, {"score": 0.004477270137801732, "phrase": "run-time_type_tests"}, {"score": 0.004418456827500267, "phrase": "value-indexed_dictionaries"}, {"score": 0.004054479957160662, "phrase": "type_systems"}, {"score": 0.0035052810710060893, "phrase": "single_powerful_mechanism"}, {"score": 0.003459191419478298, "phrase": "nested_refinement_types"}, {"score": 0.0033911868693238894, "phrase": "typing_relation"}, {"score": 0.0031950646670695546, "phrase": "system_d"}, {"score": 0.003153041030690117, "phrase": "smt-based_logical_implication"}, {"score": 0.003010250522930773, "phrase": "sophisticated_dynamic_language_programs"}, {"score": 0.002931569771634119, "phrase": "nested_refinements"}, {"score": 0.0028930017387859804, "phrase": "mccarthy's_theory"}, {"score": 0.0028549396580672417, "phrase": "finite_maps"}, {"score": 0.0028173769301594745, "phrase": "system_d_can_precisely_reason"}, {"score": 0.0025509294021449254, "phrase": "type_predicates"}, {"score": 0.002387415084371473, "phrase": "unique_technical_challenges"}, {"score": 0.002234358539133758, "phrase": "novel_stratification_approach"}, {"score": 0.0021049977753042253, "phrase": "system_d."}], "paper_keywords": ["Languages", " Verification", " Refinement Types", " Dynamic Languages"], "paper_abstract": "Programs written in dynamic languages make heavy use of features - run-time type tests, value-indexed dictionaries, polymorphism, and higher-order functions-that are beyond the reach of type systems that employ either purely syntactic or purely semantic reasoning. We present a core calculus, System D, that merges these two modes of reasoning into a single powerful mechanism of nested refinement types wherein the typing relation is itself a predicate in the refinement logic. System D coordinates SMT-based logical implication and syntactic subtyping to automatically typecheck sophisticated dynamic language programs. By coupling nested refinements with McCarthy's theory of finite maps, System D can precisely reason about the interaction of higher-order functions, polymorphism, and dictionaries. The addition of type predicates to the refinement logic creates a circularity that leads to unique technical challenges in the metatheory, which we solve with a novel stratification approach that we use to prove the soundness of System D.", "paper_title": "Nested Refinements: A Logic for Duck Typing", "paper_id": "WOS:000300548100018"}