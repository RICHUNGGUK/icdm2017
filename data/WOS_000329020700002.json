{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cyclic_scheduling_problems"}, {"score": 0.030089500316017936, "phrase": "period_value"}, {"score": 0.004531997388646422, "phrase": "periodic_fashion"}, {"score": 0.004454237726525018, "phrase": "precedence_and_resource_constraints"}, {"score": 0.004192392802008709, "phrase": "compiler_design"}, {"score": 0.003997458586709491, "phrase": "constraint_programming_approach"}, {"score": 0.003894963476923956, "phrase": "modular_arithmetic"}, {"score": 0.0037623642073222547, "phrase": "modular_precedence_constraint"}, {"score": 0.0037138072936226, "phrase": "global_cumulative_constraint"}, {"score": 0.0034677324741788254, "phrase": "cross"}, {"score": 0.003405671497507337, "phrase": "pure_cyclic_scheduling_problem"}, {"score": 0.0032896745636186824, "phrase": "second_formulation"}, {"score": 0.0031502008922533894, "phrase": "restrictive_assumption"}, {"score": 0.0030693625816617044, "phrase": "classical_resources_constraints"}, {"score": 0.0029647862293448895, "phrase": "solution_quality"}, {"score": 0.002888692115811987, "phrase": "cyclic_scheduling_operate"}, {"score": 0.0027781870000242004, "phrase": "linear_problem"}, {"score": 0.0027422968723193057, "phrase": "generate-and-test_fashion"}, {"score": 0.0026259694526633037, "phrase": "non-linear_model"}, {"score": 0.0024606422183102382, "phrase": "scheduling_decisions"}, {"score": 0.0023562342764987254, "phrase": "non-trivial_synthetic_instances"}, {"score": 0.0022957232752482196, "phrase": "realistic_industrial_instances"}, {"score": 0.002207851585508636, "phrase": "high_quality_solutions"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Cyclic scheduling problem", " Cumulative constraint", " Filtering algorithm", " Constraint programming"], "paper_abstract": "Cyclic scheduling problems consist in ordering a set of activities executed indefinitely over time in a periodic fashion, subject to precedence and resource constraints. This class of problems has many applications in manufacturing, embedded systems and compiler design, production and chemical systems. This paper proposes a Constraint Programming approach for cyclic scheduling problems, based on modular arithmetic: in particular, we introduce a modular precedence constraint and a global cumulative constraint along with their filtering algorithms. We discuss two possible formulations. The first one (referred to as CROSS) models a pure cyclic scheduling problem and makes use of both our novel constraints. The second formulation (referred to as CROSS*) introduces a restrictive assumption to enable the use of classical resources constraints, but may incur a loss of solution quality. Many traditional approaches to cyclic scheduling operate by fixing the period value and then solving a linear problem in a generate-and-test fashion. Conversely, our technique is based on a non-linear model and tackles the problem as a whole: the period value is inferred from the scheduling decisions. Our approach has been tested on a number of non-trivial synthetic instances and on a set of realistic industrial instances. The method proved to effective in finding high quality solutions in a very short amount of time. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "CROSS cyclic resource-constrained scheduling solver", "paper_id": "WOS:000329020700002"}