{"auto_keywords": [{"score": 0.049288933902850315, "phrase": "superperfect_graphs"}, {"score": 0.03211275498458335, "phrase": "interference_graph"}, {"score": 0.03096724777039757, "phrase": "spm"}, {"score": 0.00481495049065317, "phrase": "scratchpad_memory_allocation_for_data_aggregates"}, {"score": 0.00477513738640734, "phrase": "interval_coloring"}, {"score": 0.004696491408936132, "phrase": "existing_methods"}, {"score": 0.004580933283492972, "phrase": "scratchpad_memory"}, {"score": 0.004376378707877484, "phrase": "integer_programming"}, {"score": 0.004268663239979243, "phrase": "graph-coloring_problem"}, {"score": 0.004146327465630697, "phrase": "spm_allocation_problem"}, {"score": 0.00402748353567517, "phrase": "interval_coloring_problem"}, {"score": 0.003977594755967813, "phrase": "key_observation"}, {"score": 0.0038796562792487, "phrase": "c_programs"}, {"score": 0.003600022318864217, "phrase": "good_accuracy"}, {"score": 0.0034967818541774844, "phrase": "array_interference_graphs"}, {"score": 0.003439117493141663, "phrase": "special_class"}, {"score": 0.003354393040689453, "phrase": "comparability_graphs"}, {"score": 0.0031125001790084936, "phrase": "spm_allocation_algorithm"}, {"score": 0.0028521858876446654, "phrase": "clique_number"}, {"score": 0.002591927716261631, "phrase": "containment-motivated_heuristics"}, {"score": 0.002528021281333922, "phrase": "live_ranges"}, {"score": 0.002496659907186784, "phrase": "resulting_graph"}, {"score": 0.002316476356455289, "phrase": "embedded_c_benchmarks"}, {"score": 0.0022972752367397126, "phrase": "mediabench"}, {"score": 0.002278231892709908, "phrase": "mibench"}, {"score": 0.002231310272815607, "phrase": "graph-coloring_algorithm"}, {"score": 0.0022036216160494925, "phrase": "optimal_ilp_algorithm"}, {"score": 0.0021049977753042253, "phrase": "close-to-optimal_results"}], "paper_keywords": ["Algorithms", " Languages", " Experimentation", " Performance", " Scratchpad memory", " SPM allocation", " interference graph", " interval coloring", " superperfect graph"], "paper_abstract": "Existing methods place data or code in scratchpad memory (SPM) by relying on heuristics or resorting to integer programming or mapping it to a graph-coloring problem. In this article, the SPM allocation problem for arrays is formulated as an interval coloring problem. The key observation is that in many embedded C programs, two arrays can bemodeled such that either their live ranges do not interfere or one contains the other (with good accuracy). As a result, array interference graphs often form a special class of superperfect graphs (known as comparability graphs), and their optimal interval colorings become efficiently solvable. This insight has led to the development of an SPM allocation algorithm that places arrays in an interference graph in SPM by examining its maximal cliques. If the SPM is no smaller than the clique number of an interference graph, then all arrays in the graph can be placed in SPM optimally. Otherwise, we rely on containment-motivated heuristics to split or spill array live ranges until the resulting graph is optimally colorable. We have implemented our algorithm in SUIF/machSUIF and evaluated it using a set of embedded C benchmarks from MediaBench and MiBench. Compared to a graph-coloring algorithm and an optimal ILP algorithm (when it runs to completion), our algorithm achieves close-to-optimal results and is superior to graph coloring for the benchmarks tested.", "paper_title": "Scratchpad Memory Allocation for Data Aggregates via Interval Coloring in Superperfect Graphs", "paper_id": "WOS:000285875500014"}