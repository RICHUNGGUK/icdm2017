{"auto_keywords": [{"score": 0.04124584638960657, "phrase": "static_type_analysis"}, {"score": 0.00481495049065317, "phrase": "object_oriented_programs"}, {"score": 0.004694700982410345, "phrase": "precise_static_type_analysis"}, {"score": 0.004500891637057374, "phrase": "available_dynamic_aspects"}, {"score": 0.004425616928975799, "phrase": "object-oriented_programs"}, {"score": 0.0034944094552943, "phrase": "spurious_possible_types"}, {"score": 0.003407026489727146, "phrase": "particular_dynamic_dispatch"}, {"score": 0.003027178161479457, "phrase": "symbolic_execution"}, {"score": 0.002450864311898833, "phrase": "test_cases"}, {"score": 0.0024097920845706795, "phrase": "different_class_hierarchies"}, {"score": 0.002349467661235186, "phrase": "proposed_technique"}, {"score": 0.002233301265743633, "phrase": "target_method"}, {"score": 0.0021408862709571615, "phrase": "dynamic_dispatches"}, {"score": 0.0021049977753042253, "phrase": "reduced_computational_cost"}], "paper_keywords": ["object-oriented programming", " message dispatch", " program analysis", " type system", " type analysis"], "paper_abstract": "A precise static type analysis is important to make available dynamic aspects of object-oriented programs (OOPs) approximately known at compile-time. Many techniques have been proposed for static type analysis depending upon the tradeoff of cost and precision; the techniques may generate spurious possible types for a particular dynamic dispatch which makes the static type analysis imprecise. In this paper, we propose a symbolic execution based type analysis technique that analyzes the dynamic type inter-procedurally by keeping the flow of the program in consideration. We analyze test cases with different class hierarchies. The proposed technique was capable to resolve the target method for most of the dynamic dispatches at reduced computational cost.", "paper_title": "Precise static type analysis for object oriented programs", "paper_id": "WOS:000253407900002"}