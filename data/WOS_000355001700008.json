{"auto_keywords": [{"score": 0.04908067956118528, "phrase": "performance_penalties"}, {"score": 0.00481495049065317, "phrase": "self-caring_mapreduce"}, {"score": 0.004635701867952543, "phrase": "self-caring_it_systems"}, {"score": 0.004500891637057374, "phrase": "system_failures"}, {"score": 0.004102096151528319, "phrase": "mapreduce_job"}, {"score": 0.003982741546775355, "phrase": "service-level_agreement"}, {"score": 0.003883194688426525, "phrase": "existing_fault-tolerance_capability"}, {"score": 0.003834445828428953, "phrase": "mapreduce"}, {"score": 0.0037702406223879778, "phrase": "hadoop"}, {"score": 0.0036296886647898094, "phrase": "handling_faults"}, {"score": 0.0035539019235553897, "phrase": "excessive_job_execution_times"}, {"score": 0.0033078284621762817, "phrase": "different_job_and_framework_parameters"}, {"score": 0.0031979796189858206, "phrase": "execution_time"}, {"score": 0.0031577303835881964, "phrase": "node_faults"}, {"score": 0.003117986133774198, "phrase": "mrperf_simulator"}, {"score": 0.0030399874838260886, "phrase": "empirical_study"}, {"score": 0.0029764767329116875, "phrase": "virtualized_testbed"}, {"score": 0.002939007076062123, "phrase": "xen_domains"}, {"score": 0.0029020077365708966, "phrase": "varying_system_characteristics"}, {"score": 0.0027009493171069763, "phrase": "empirical_results"}, {"score": 0.0026445028886931837, "phrase": "job-completion-time_service-level_agreement_violations"}, {"score": 0.002461241017147324, "phrase": "virtualized_environment"}, {"score": 0.002419995316129757, "phrase": "execution_time_penalties"}, {"score": 0.0023594160789762227, "phrase": "potential_job_failure"}, {"score": 0.002195866991284673, "phrase": "no-fault_execution_time"}, {"score": 0.0021682027434117095, "phrase": "minimal_additional_cost"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["fault-tolerance", " autonomic computing", " fault management", " MapReduce"], "paper_abstract": "Self-caring IT systems are those that can proactively avoid system failures rather than reactively handle failures after they have occurred. In this paper, we focus on failures in which a MapReduce job is unable to execute within an service-level agreement based completion time. The existing fault-tolerance capability provided by MapReduce frameworks such as Hadoop, is simple and the penalty associated with handling faults could potentially lead to excessive job execution times. Our goal in this paper is to bring out the severity of this penalty for different job and framework parameters. We quantitatively evaluate the penalty in execution time associated with node faults using the MRPerf simulator. We then perform an empirical study of penalties on a virtualized testbed consisting of Xen domains, by varying system characteristics along four dimensions: hardware, application, dataset, and fault types. Through simulation and empirical results, we show that job-completion-time service-level agreement violations can be reduced using dynamic resource scaling. Scaling leverages, the elastic properties of a virtualized environment, to mitigate execution time penalties and hence proactively avoids a potential job failure. We show that using resource scaling, performance penalties can be decreased to less than 5% of the no-fault execution time, at minimal additional cost. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Towards self-caring MapReduce: a study of performance penalties under faults", "paper_id": "WOS:000355001700008"}