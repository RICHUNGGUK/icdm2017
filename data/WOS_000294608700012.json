{"auto_keywords": [{"score": 0.04451613018545648, "phrase": "data_dependency_chain"}, {"score": 0.0368809700554325, "phrase": "minimum_number"}, {"score": 0.00481495049065317, "phrase": "software_debugging"}, {"score": 0.004751011171658849, "phrase": "abstract_diagnosis_theory"}, {"score": 0.004527747831940216, "phrase": "software_testing"}, {"score": 0.0032317564571381656, "phrase": "source_code"}, {"score": 0.0031379455926018795, "phrase": "well-known_abstract_diagnosis_problem"}, {"score": 0.0030468495296763617, "phrase": "faulty_components"}, {"score": 0.003022465992278672, "phrase": "digital_circuit"}, {"score": 0.002990256977544061, "phrase": "system_description"}, {"score": 0.0029046198640329643, "phrase": "np"}, {"score": 0.0028418763133526257, "phrase": "data_dependencies"}, {"score": 0.002751968796076333, "phrase": "inevitable_exponential_complexity"}, {"score": 0.002693611989967953, "phrase": "general_problem"}, {"score": 0.002650655766450421, "phrase": "data_dependency_chains"}, {"score": 0.0026014029631519545, "phrase": "integer_linear_programming"}, {"score": 0.0025462308249913643, "phrase": "tool_chain"}, {"score": 0.0025326211341475903, "phrase": "misra-c_compliant_source_codes"}, {"score": 0.0024524733595572084, "phrase": "significant_number"}, {"score": 0.002439363579997196, "phrase": "debugging_points"}, {"score": 0.0023182554418193927, "phrase": "embedded_software"}, {"score": 0.002244876254113051, "phrase": "timing_constraints"}, {"score": 0.002232873707973742, "phrase": "resource_consumption"}, {"score": 0.002214989839524726, "phrase": "interesting_application"}, {"score": 0.00218550043626348, "phrase": "data_logging"}, {"score": 0.0021334032621986043, "phrase": "axillary_data_storage_devices"}, {"score": 0.0021049977753042253, "phrase": "limited_size"}], "paper_keywords": ["Algorithms", " Performance", " Theory", " Software debugging", " Testing", " Diagnosis", " Logging"], "paper_abstract": "In this paper, we present a notion of observability and controllability in the context of software testing and debugging. Our view of observability is based on the ability of developers, testers, and debuggers to trace back a data dependency chain and observe the value of a variable by starting from a set of variables that are naturally observable (e. g., input/output variables). Likewise, our view of controllability enables one to modify and control the value of a variable through a data dependency chain by starting from a set of variables that can be modified (e. g., input variables). Consequently, the problem that we study in this paper is to identify the minimum number of variables that have to be made observable/controllable in order for a tester or debugger to observe/control the value of another set of variables of interest, given the source code. We show that our problem is an instance of the well-known abstract diagnosis problem, where the objective is to find the minimum number of faulty components in a digital circuit, given the system description and value of input/output variables. We show that our problem is NP-complete even if the length of data dependencies is at most 2. In order to cope with the inevitable exponential complexity, we propose a mapping from the general problem, where the length of data dependency chains is unknown a priori, to integer linear programming. Our method is fully implemented in a tool chain for MISRA-C compliant source codes. Our experiments with several real-world applications show that in average, a significant number of debugging points can be reduced using our methods. This result is our motivation to apply our approach in debugging and instrumentation of embedded software, where changes must be minimal as they can perturb the timing constraints and resource consumption. Another interesting application of our results is in data logging of non-terminating embedded systems, where axillary data storage devices are slow and have limited size.", "paper_title": "Software Debugging and Testing using the Abstract Diagnosis Theory", "paper_id": "WOS:000294608700012"}