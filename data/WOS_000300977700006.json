{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "vliw_dsp_processors"}, {"score": 0.02305898603448663, "phrase": "simd_intrinsics"}, {"score": 0.009858484133448203, "phrase": "subword_instructions"}, {"score": 0.009571991167495837, "phrase": "functional_units"}, {"score": 0.007203683738506042, "phrase": "distributed_register_files"}, {"score": 0.0047090997998449095, "phrase": "growing_multimedia_workload"}, {"score": 0.004588546689323362, "phrase": "dsp"}, {"score": 0.004421601997620278, "phrase": "signal_processing"}, {"score": 0.004244955499652296, "phrase": "dsp_processors"}, {"score": 0.004136221184894985, "phrase": "multiple_data_streams"}, {"score": 0.003784049616066444, "phrase": "wire_connection"}, {"score": 0.0037421829222825964, "phrase": "register_files"}, {"score": 0.0036193316508938795, "phrase": "distributed_design"}, {"score": 0.003592581806180854, "phrase": "great_challenges"}, {"score": 0.003335683866508191, "phrase": "simd_parallelism"}, {"score": 0.0032141856243404618, "phrase": "industrial_practices"}, {"score": 0.0031086137705026483, "phrase": "hardware_resources"}, {"score": 0.0030628094110419697, "phrase": "hand-coded_assembly"}, {"score": 0.002951220859491642, "phrase": "open_issue"}, {"score": 0.0027299058905736456, "phrase": "highly_optimized_codes"}, {"score": 0.0026401983633087267, "phrase": "enhanced_register_allocation_scheme"}, {"score": 0.002553431170229379, "phrase": "efficient_code_generation"}, {"score": 0.0025064622665903645, "phrase": "dspstone_benchmark"}, {"score": 0.0024061422012437344, "phrase": "proposed_programming"}, {"score": 0.002388337333984138, "phrase": "optimization_schemes"}, {"score": 0.002301265368019983, "phrase": "compiler_optimizations"}, {"score": 0.002242206465278159, "phrase": "remarkable_performance_improvements"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["SIMD intrinsics", " compiler optimizations", " VLIW DSP processors", " distributed register files"], "paper_abstract": "To sustain growing multimedia workload, modern digital signal processing (DSP) processors are commonly equipped with subword instructions to accelerate signal processing. Besides subword, functional units of very long instruction word (VLIW) DSP processors can also be employed to process multiple data streams in parallel. However, because of power and area concerns, many embedded VLIW DSP processors adopt distributed register files to reduce read/write ports and wire connection by privatizing register files for clusters and even for functional units. The distributed design presents great challenges to compilers in distributing single instruction, multiple data (SIMD) workload to functional units. In this paper, we address the issue in supporting SIMD parallelism on VLIW DSP processors with subword instructions and distributed register files. Currently, industrial practices have adopted intrinsics that enable developers to utilize hardware resources and compete with hand-coded assembly in performance. However, it is still an open issue to provide such a solution for VLIW DSP processors with distributed register files. In this work, we provide SIMD intrinsics to allow programmers to write highly optimized codes by following given programming guides. In addition, an enhanced register allocation scheme and data replication optimizations are devised to enable efficient code generation. In our experiments, DSPstone benchmark and a set of H. 264 kernels are used to evaluate the proposed programming and optimization schemes. The result shows that by combining SIMD intrinsics and compiler optimizations, one is able to obtain remarkable performance improvements, speedups of 2.9 and 3.5 for DSPstone and H. 264 kernels, respectively. Copyright (C) 2011 John Wiley & Sons, Ltd.", "paper_title": "Compiler supports for VLIW DSP processors with SIMD intrinsics", "paper_id": "WOS:000300977700006"}