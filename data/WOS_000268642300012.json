{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "reachability_using_first-order_logic_with_applications"}, {"score": 0.004374593906165761, "phrase": "existing_theorem_provers"}, {"score": 0.004310501708408856, "phrase": "first-order_logic"}, {"score": 0.004185108816866677, "phrase": "safety_properties"}, {"score": 0.004123781267600542, "phrase": "imperative_programs"}, {"score": 0.0040334640350288, "phrase": "dynamic_storage_allocation"}, {"score": 0.003974349782102708, "phrase": "destructive_updating"}, {"score": 0.003916098498242888, "phrase": "pointer-valued_structure_fields"}, {"score": 0.003774164192882704, "phrase": "main_obstacles"}, {"score": 0.003531474887552889, "phrase": "reachability_properties"}, {"score": 0.003479692058963528, "phrase": "dynamically_allocated_cells"}, {"score": 0.0034034331737042363, "phrase": "main_technical_contributions"}, {"score": 0.0032081215771180664, "phrase": "conservative_way"}, {"score": 0.003161065111494053, "phrase": "first-order_formulas"}, {"score": 0.002914288956035066, "phrase": "program_states"}, {"score": 0.002726740692380339, "phrase": "precise_way"}, {"score": 0.0025324393547676623, "phrase": "semiautomatic_program_verification"}, {"score": 0.0024405312482831646, "phrase": "programmer-supplied_loop_invariants"}, {"score": 0.0022498783454674254, "phrase": "garbage_collection"}, {"score": 0.0022168460543913787, "phrase": "destructive_reversal"}, {"score": 0.0021682027434117095, "phrase": "singly_linked_list"}, {"score": 0.0021049977753042253, "phrase": "mark-and-sweep_example"}], "paper_keywords": ["First Order Logic", " Transitive Closure", " Approximation", " Program Verification", " Program Analysis"], "paper_abstract": "This paper shows how to harness existing theorem provers for first-order logic to automatically verify safety properties of imperative programs that perform dynamic storage allocation and destructive updating of pointer-valued structure fields. One of the main obstacles is specifying and proving the (absence) of reachability properties among dynamically allocated cells. The main technical contributions are methods for simulating reachability in a conservative way using first-order formulas-the formulas describe a superset of the set of program states that would be specified if one had a precise way to express reachability. These methods are employed for semiautomatic program verification (i.e., using programmer-supplied loop invariants) on programs such as mark-and-sweep garbage collection and destructive reversal of a singly linked list. (The mark-and-sweep example has been previously reported as being beyond the capabilities of ESC/Java.)", "paper_title": "SIMULATING REACHABILITY USING FIRST-ORDER LOGIC WITH APPLICATIONS TO VERIFICATION OF LINKED DATA STRUCTURES", "paper_id": "WOS:000268642300012"}