{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multi-core_systems"}, {"score": 0.041741505471269987, "phrase": "monitored_program"}, {"score": 0.004784565134881178, "phrase": "dynamic_program_execution_monitors"}, {"score": 0.004577145044601205, "phrase": "instrumentation-based_dynamic_program_monitors"}, {"score": 0.004434491600123024, "phrase": "special_hardware_supports"}, {"score": 0.004202067185873954, "phrase": "specific_monitoring_requirements"}, {"score": 0.003906804492585634, "phrase": "separate_cores"}, {"score": 0.003845403454927292, "phrase": "attractive_option"}, {"score": 0.0037610536973798113, "phrase": "large_amount"}, {"score": 0.0036553070575015344, "phrase": "dynamic_monitoring"}, {"score": 0.0035864603175592854, "phrase": "significant_performance_overhead"}, {"score": 0.0035412818367359378, "phrase": "special-purpose_hardware_support"}, {"score": 0.003441693005357189, "phrase": "novel_dynamic_execution"}, {"score": 0.0033875770020590796, "phrase": "multi-core_architecture"}, {"score": 0.0028726685746632654, "phrase": "dynamic_execution_monitoring_system"}, {"score": 0.0027305272327742642, "phrase": "optimization_techniques"}, {"score": 0.002522344964242888, "phrase": "total_execution_time"}, {"score": 0.0024435751724545193, "phrase": "performance_impact"}, {"score": 0.0024204262825429095, "phrase": "proposed_dynamic_program_monitoring_system"}, {"score": 0.0022715929119140194, "phrase": "instrumentation-based_monitors"}, {"score": 0.0022500695985527668, "phrase": "proposed_techniques"}, {"score": 0.0022076314894741394, "phrase": "performance_overhead"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Multi-core", " Program monitoring", " Compiler optimisation"], "paper_abstract": "Dynamic program execution monitors allow programmers to observe and verify an application while it is running. Instrumentation-based dynamic program monitors often incur significant performance overhead due to instrumentation. Special hardware supports have been proposed to reduce this overhead. However, most of these supports often target specific monitoring requirements, and thus have limited applicability. Recently, with multi-core systems becoming mainstream, executing the monitored program and the monitor simultaneously on separate cores has emerged as an attractive option. However, due to the large amount of information forwarded to the monitor, existing approaches of dynamic monitoring on multi-core still suffers from significant performance overhead, unless adapt special-purpose hardware support. In this paper, we present a novel dynamic execution monitoring model on the multi-core architecture. This model is based on two observations: (1) a monitor only requires specific information from the monitored program: (2) some information can be easily computed by the monitor from information that have already been communicated. Based on these observations, we propose hardware and software support to build a dynamic execution monitoring system that only communicates information that is relevant to monitoring purposes. Furthermore, we developed optimization techniques that decide the set of data to forward to the monitor and the data set to compute by the monitor, so that the total execution time of the monitor is minimized. We evaluate the performance impact of the proposed dynamic program monitoring system with SPEC2006 integer benchmarks for two intensive monitoring tasks: taint-propagation and memory-bug-detection. Compared with instrumentation-based monitors, the proposed techniques is able to reduce the performance overhead of the two monitors by 3.7x and 2.2x, respectively. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Efficient dynamic program monitoring on multi-core systems", "paper_id": "WOS:000287331600010"}