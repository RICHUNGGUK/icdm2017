{"auto_keywords": [{"score": 0.04580340075872882, "phrase": "first-class_code_pointers"}, {"score": 0.03437198070337076, "phrase": "separation_logic"}, {"score": 0.00481495049065317, "phrase": "low-level_programs"}, {"score": 0.004772367030970874, "phrase": "computational_separation_logic"}, {"score": 0.004585332915477379, "phrase": "low-level_systems_software"}, {"score": 0.004484596684703308, "phrase": "automated_theorem-proving"}, {"score": 0.00378767277402891, "phrase": "bedrock_framework"}, {"score": 0.0037209035703970705, "phrase": "mostly-automated_proofs"}, {"score": 0.0036390887584943723, "phrase": "full_range"}, {"score": 0.0033442114331500407, "phrase": "mostly-automated_discharge"}, {"score": 0.003073154478201771, "phrase": "function_specifications"}, {"score": 0.0029789104204803137, "phrase": "reference_implementations"}, {"score": 0.0029394074636168435, "phrase": "purely_functional_language"}, {"score": 0.0027741761880779535, "phrase": "functional_programs"}, {"score": 0.0027131212233443137, "phrase": "expressive_language"}, {"score": 0.0026771333996253783, "phrase": "coq_proof_assistant"}, {"score": 0.0024930878032164757, "phrase": "dramatic_improvements"}, {"score": 0.002427372728532664, "phrase": "classical_verification"}, {"score": 0.00233202607446404, "phrase": "data_structures"}, {"score": 0.0023113506171584157, "phrase": "binary_search_trees"}, {"score": 0.002290858045013009, "phrase": "hash_tables"}, {"score": 0.0022404162042797262, "phrase": "verified_programming"}, {"score": 0.002220551141101661, "phrase": "code_pointers"}, {"score": 0.0021333110194180997, "phrase": "function_memoization"}, {"score": 0.0021049977753042253, "phrase": "cooperative_threading_library"}], "paper_keywords": ["Languages", " Verification", " interactive proof assistants", " separation logic", " low-level programming languages", " functional programming"], "paper_abstract": "Several recent projects have shown the feasibility of verifying low-level systems software. Verifications based on automated theorem-proving have omitted reasoning about first-class code pointers, which is critical for tasks like certifying implementations of threads and processes. Conversely, verifications that deal with first-class code pointers have featured long, complex, manual proofs. In this paper, we introduce the Bedrock framework, which supports mostly-automated proofs about programs with the full range of features needed to implement, e.g., language runtime systems. The heart of our approach is in mostly-automated discharge of verification conditions inspired by separation logic. Our take on separation logic is computational, in the sense that function specifications are usually written in terms of reference implementations in a purely functional language. Logical quantifiers are the most challenging feature for most automated verifiers; by relying on functional programs (written in the expressive language of the Coq proof assistant), we are able to avoid quantifiers almost entirely. This leads to some dramatic improvements compared to both past work in classical verification, which we compare against with implementations of data structures like binary search trees and hash tables; and past work in verified programming with code pointers, which we compare against with examples like function memoization and a cooperative threading library.", "paper_title": "Mostly-Automated Verification of Low-Level Programs in Computational Separation Logic", "paper_id": "WOS:000294609500021"}