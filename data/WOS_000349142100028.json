{"auto_keywords": [{"score": 0.015158942505109286, "phrase": "binary_search_tree"}, {"score": 0.00481495049065317, "phrase": "new_lock-free_algorithm"}, {"score": 0.004556901872357751, "phrase": "asynchronous_shared_memory_system"}, {"score": 0.00341707506477955, "phrase": "intel"}, {"score": 0.003253560798692431, "phrase": "existing_lock-free_algorithms"}, {"score": 0.0026091594819333654, "phrase": "smaller_portion"}, {"score": 0.0021049977753042253, "phrase": "concurrent_binary_search_tree"}], "paper_keywords": ["Concurrent Data Structure", " Lock-Free Algorithm", " Binary Search Tree"], "paper_abstract": "We present a new lock-free algorithm for concurrent manipulation of a binary search tree in an asynchronous shared memory system that supports search, insert and delete operations. In addition to read and write instructions, our algorithm uses (single-word) compare-and-swap (CAS) and bit-test-and-set (BTS) atomic instructions, both of which are commonly supported by many modern processors including Intel 64 and AMD64. In contrast to existing lock-free algorithms for a binary search tree, our algorithm is based on marking edges rather than nodes. As a result, when compared to other lock-free algorithms, modify (insert and delete) operations in our algorithm (a) work on a smaller portion of the tree, thereby reducing conflicts, and (b) execute fewer atomic instructions (one for insert and three for delete). Our experiments indicate that our lock-free algorithm significantly outperforms all other algorithms for a concurrent binary search tree in many cases, especially when contention is high, by as much as 100%.", "paper_title": "Fast Concurrent Lock-Free Binary Search Trees", "paper_id": "WOS:000349142100028"}