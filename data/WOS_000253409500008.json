{"auto_keywords": [{"score": 0.04516516866425676, "phrase": "machine_code"}, {"score": 0.013526737583260739, "phrase": "aotc"}, {"score": 0.007566667724355085, "phrase": "client_device"}, {"score": 0.007316426361232449, "phrase": "jitc"}, {"score": 0.004815016809464284, "phrase": "java"}, {"score": 0.004671012181488876, "phrase": "embedded_systems"}, {"score": 0.004592905436175987, "phrase": "embedded_java_virtual_machine"}, {"score": 0.004455575231721042, "phrase": "time_compiler"}, {"score": 0.004067635935640407, "phrase": "just-in-time_compiler"}, {"score": 0.003945949295597681, "phrase": "translation_overhead"}, {"score": 0.00384083110935486, "phrase": "dynamically_downloaded_classes"}, {"score": 0.0035779805381654438, "phrase": "jitc_module"}, {"score": 0.0033330581836898032, "phrase": "persistent_memory"}, {"score": 0.0031791333962016507, "phrase": "later_run"}, {"score": 0.003032295420569351, "phrase": "translation_and_interpretation_overhead"}, {"score": 0.0029915976131073825, "phrase": "major_issues"}, {"score": 0.002843772431469196, "phrase": "cached_machine_code"}, {"score": 0.002721562843196732, "phrase": "different_run"}, {"score": 0.002552309172078995, "phrase": "relocation_problem"}, {"score": 0.0024591621759745648, "phrase": "sun's_cdc_vm_reference_implementation"}, {"score": 0.0021921581733031514, "phrase": "c-aotc_methods"}, {"score": 0.002148136905808445, "phrase": "persistent_space"}, {"score": 0.0021049977753042253, "phrase": "graceful_degradation"}], "paper_keywords": ["Java ahead-of-time compiler", " just-in-time compiler", " relocation", " early binding", " Java virtual machine", " J2ME CDC", " performance", " experimentation", " languages"], "paper_abstract": "The performance of embedded Java virtual machine can be improved by ahead-of-time compiler ( AOTC), which translates bytecode into machine code in the server and installs the machine code on the client device. Although AOTC is more advantageous than just-in-time compiler (JITC) due to its absence of the translation overhead, AOTC cannot be applicable to dynamically downloaded classes at runtime. This paper proposes client-AOTC (c-AOTC) which performs AOTC on the client device using the JITC module installed on the device, complementing the server-AOTC. The machine code of a method translated by JITC is cached on a persistent memory of the device, and when the method is invoked again in a later run of the program, the machine code is loaded and executed directly without the translation and interpretation overhead. One of major issues in c-AOTC is relocation because some of the addresses used by the cached machine code are not correct when the machine code is loaded and used in a different run; those addresses should be corrected before they are used. Constant pool resolution and inlining complicate the relocation problem and we propose our solutions. We developed a c-AOTC on Sun's CDC VM reference implementation ( RI) and our evaluation results indicate that cAOTC can improve the performance significantly, as much as an average of 12%. We also experiment with the issue of reducing the number of c-AOTC methods to be cached when the persistent space is tight, with a graceful degradation of performance.", "paper_title": "Java client ahead-of-time compiler for embedded systems", "paper_id": "WOS:000253409500008"}