{"auto_keywords": [{"score": 0.041460605561250176, "phrase": "g."}, {"score": 0.00481495049065317, "phrase": "triangle_listing"}, {"score": 0.004589124394375718, "phrase": "triangle_listing_problem"}, {"score": 0.004523455475492876, "phrase": "triangle_counting_problem"}, {"score": 0.004437349839203418, "phrase": "basic_operators"}, {"score": 0.004270003565426343, "phrase": "former_problem"}, {"score": 0.004188702178897384, "phrase": "undirected_graph"}, {"score": 0.0038973170902076707, "phrase": "latter_problem"}, {"score": 0.0034892684482068347, "phrase": "internal_memory"}, {"score": 0.0033900126423990823, "phrase": "difficult_challenges"}, {"score": 0.003049555059533735, "phrase": "previous_research"}, {"score": 0.0027564303939865476, "phrase": "crippling_assumptions"}, {"score": 0.002716915166374506, "phrase": "good_performance"}, {"score": 0.002601727192945944, "phrase": "new_algorithm"}, {"score": 0.0023972750359328235, "phrase": "input_g"}, {"score": 0.002219516542316085, "phrase": "existing_competitors"}], "paper_keywords": ["Algorithms", " Theory", " Performance", " Triangle listing", " triangle counting", " graphs", " I/O-efficient algorithms"], "paper_abstract": "This article studies I/O-efficient algorithms for the triangle listing problem and the triangle counting problem, whose solutions are basic operators in dealing with many other graph problems. In the former problem, given an undirected graph G, the objective is to find all the cliques involving 3 vertices in G. In the latter problem, the objective is to report just the number of such cliques without having to enumerate them. Both problems have been well studied in internal memory, but still remain as difficult challenges when G does not fit in memory, thus making it crucial to minimize the number of disk I/Os performed. Although previous research has attempted to tackle these challenges, the state-of-the-art solutions rely on a set of crippling assumptions to guarantee good performance. Motivated by this, we develop a new algorithm that is provably I/O and CPU efficient at the same time, without making any assumption on the input G at all. The algorithm uses ideas drastically different from all the previous approaches, and outperforms the existing competitors by a factor of over an order of magnitude in our extensive experimentation.", "paper_title": "I/O-Efficient Algorithms on Triangle Listing and Counting", "paper_id": "WOS:000347799000002"}