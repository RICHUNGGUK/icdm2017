{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "constraint_handling_rules"}, {"score": 0.004342430078306461, "phrase": "committed-choice_rule-based_language"}, {"score": 0.003967021436047945, "phrase": "constraint_solvers"}, {"score": 0.003267925215811654, "phrase": "classic_union-find_algorithm"}, {"score": 0.003103215561096187, "phrase": "chr."}, {"score": 0.002622947550220266, "phrase": "time_complexity"}, {"score": 0.0023958326775913165, "phrase": "almost-linear_complexity"}, {"score": 0.002304606411453748, "phrase": "best_known_imperative_implementations"}, {"score": 0.0021049977753042253, "phrase": "experimental_results"}], "paper_keywords": ["declarative algorithms", " time complexity analysis", " disjoint-set problem", " union-find algorithm", " constraint handling rules"], "paper_abstract": "Constraint Handling Rules (CHR) is a committed-choice rule-based language that was originally intended for writing constraint solvers. In this paper we show that it is also possible to write the classic union-find algorithm and variants in CHR. The programs neither compromise in declarativeness nor efficiency. We study the time complexity of our programs: they match the almost-linear complexity of the best known imperative implementations. This fact is illustrated with experimental results.", "paper_title": "Optimal union-find in Constraint Handling Rules", "paper_id": "WOS:000235299500006"}