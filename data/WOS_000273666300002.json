{"auto_keywords": [{"score": 0.03980713684810354, "phrase": "model_checking"}, {"score": 0.00481495049065317, "phrase": "formal_methods"}, {"score": 0.004762893197005439, "phrase": "high-performance_computing_software_design"}, {"score": 0.004660453113061494, "phrase": "mpi_one-sided_communication-based_locking"}, {"score": 0.00442987501427177, "phrase": "numerous_concurrent_protocols"}, {"score": 0.004366106816225457, "phrase": "high-performance_computing_software"}, {"score": 0.004272164161788242, "phrase": "verification_consist"}, {"score": 0.004225950334493496, "phrase": "detailed_implementations"}, {"score": 0.003916098498242888, "phrase": "serious_bugs"}, {"score": 0.0038596974575361574, "phrase": "deployed_software"}, {"score": 0.003589602322126282, "phrase": "software_life_cycle"}, {"score": 0.003461702544605219, "phrase": "simplified_formal_protocol_models"}, {"score": 0.0033021988455635403, "phrase": "high-performance_computing"}, {"score": 0.0032310733124059567, "phrase": "case_study"}, {"score": 0.0031960852616842207, "phrase": "concurrent_protocol"}, {"score": 0.002897710777957041, "phrase": "protocol_models"}, {"score": 0.0027641218567092665, "phrase": "recent_work"}, {"score": 0.0027143926774929957, "phrase": "even_this_tedium"}, {"score": 0.00269475174341129, "phrase": "model_creation"}, {"score": 0.0026366753045215558, "phrase": "dynamic_source-code-level_analysis_methods"}, {"score": 0.0025611773887867255, "phrase": "important_domain"}, {"score": 0.0023817332409567403, "phrase": "structural_integrity"}, {"score": 0.0023644936731468252, "phrase": "combustion_chambers"}, {"score": 0.002198809686727344, "phrase": "hpc"}, {"score": 0.0021592189144729775, "phrase": "similar_success_stories"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["concurrent programming", " formal verification", " model checking", " race condition", " SPIN", " dynamic analysis", " high-performance computing (HPC)", " Message Passing Interface (MPI)", " one-sided communication"], "paper_abstract": "There is a growing need to address the complexity of verifying the numerous concurrent protocols employed in the high-performance Computing software. Today's approaches for verification consist of testing detailed implementations of these protocols. Unfortunately, this approach can seldom show the absence of bugs, and often results in serious bugs escaping into the deployed software. An approach called Model Checking has been demonstrated to be eminently helpful in debugging these protocols early in the software life cycle by offering the ability to represent and exhaustively analyze simplified formal protocol models. The effectiveness of model checking has yet to be adequately demonstrated in high-performance computing. This paper presents a case study of a concurrent protocol that was thought to be sufficiently well tested, but proved to contain two very non-obvious deadlocks in them. These bugs were automatically detected through model checking. The protocol models in which these bugs were detected were also easy to create. Recent work in Our group demonstrates that even this tedium of model creation can be eliminated by employing dynamic source-code-level analysis methods. Our case study comes from the important domain of Message Passing Interface (MPI)-based programming, which is universally employed for simulating and predicting anything from the structural integrity of combustion chambers to the path of hurricanes. We argue that model checking must be taught as well as used widely within HPC, given this and similar success stories. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Formal methods applied to high-performance computing software design: a case study of MPI one-sided communication-based locking", "paper_id": "WOS:000273666300002"}