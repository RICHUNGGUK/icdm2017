{"auto_keywords": [{"score": 0.04499627765590419, "phrase": "extracted_method"}, {"score": 0.00481495049065317, "phrase": "method_extraction"}, {"score": 0.004770295517830214, "phrase": "common_refactoring_feature"}, {"score": 0.004653220443592979, "phrase": "user-selected_piece"}, {"score": 0.004539005582217309, "phrase": "automatically_generated_method"}, {"score": 0.004239103253656808, "phrase": "inferred_contract"}, {"score": 0.003946650265907885, "phrase": "programmer_assertions"}, {"score": 0.003837761943551127, "phrase": "opportune_precondition"}, {"score": 0.00365152042769837, "phrase": "original_code"}, {"score": 0.003606384575869449, "phrase": "new_method"}, {"score": 0.003347008750837722, "phrase": "trivial_solutions"}, {"score": 0.00288272132056405, "phrase": "second_one"}, {"score": 0.0027172101552870973, "phrase": "reasonable_assumptions"}, {"score": 0.002633941112839883, "phrase": "second_solution"}, {"score": 0.0025137897302079716, "phrase": "hoare"}, {"score": 0.002429161048032688, "phrase": "hoare_logic"}, {"score": 0.0023916406628316593, "phrase": "surprisingly_unsound_inference_rules"}, {"score": 0.002347378595930709, "phrase": "new_algorithms"}, {"score": 0.0022754302456605667, "phrase": "microsoft"}, {"score": 0.0021446993452098597, "phrase": "interactive_environment"}, {"score": 0.0021049977753042253, "phrase": "good_annotations"}], "paper_keywords": ["Design", " Documentation", " Experimentation", " Human Factors", " Languages", " Reliability", " Verification", " Abstract interpretation", " Design by contract", " Method extraction", " Program transformation", " Refactoring", " Static analysis"], "paper_abstract": "Method extraction is a common refactoring feature provided by most modern IDEs. It replaces a user-selected piece of code with a call to an automatically generated method. We address the problem of automatically inferring contracts (precondition, postcondition) for the extracted method. We require the inferred contract: (a) to be valid for the extracted method (validity); (b) to guard the language and programmer assertions in the body of the extracted method by an opportune precondition (safety); (c) to preserve the proof of correctness of the original code when analyzing the new method separately (completeness); and (d) to be the most general possible (generality). These requirements rule out trivial solutions (e. g., inlining, projection, etc). We propose two theoretical solutions to the problem. The first one is simple and optimal. It is valid, safe, complete and general but unfortunately not effectively computable (except for unrealistic finiteness/decidability hypotheses). The second one is based on an iterative forward/backward method. We show it to be valid, safe, and, under reasonable assumptions, complete and general. We prove that the second solution subsumes the first. All justifications are provided with respect to a new, set-theoretic version of Hoare logic (hence without logic), and abstractions of Hoare logic, revisited to avoid surprisingly unsound inference rules. We have implemented the new algorithms on the top of two industrial-strength tools (CCCheck and the Microsoft Roslyn CTP). Our experience shows that the analysis is both fast enough to be used in an interactive environment and precise enough to generate good annotations.", "paper_title": "An Abstract Interpretation Framework for Refactoring with Application to Extract Methods with Contracts", "paper_id": "WOS:000311296200013"}