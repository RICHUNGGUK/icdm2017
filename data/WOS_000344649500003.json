{"auto_keywords": [{"score": 0.03350563390008005, "phrase": "hash_functions"}, {"score": 0.00481495049065317, "phrase": "universal_string_hashing"}, {"score": 0.004546970518808189, "phrase": "strongly_universal_string_hashing_families"}, {"score": 0.0036453427552753533, "phrase": "large_buffer"}, {"score": 0.0035861227263414537, "phrase": "random_numbers"}, {"score": 0.003414153126809511, "phrase": "popular_hash_functions"}, {"score": 0.00335867620389808, "phrase": "weaker_theoretical_guarantees"}, {"score": 0.003250403288147613, "phrase": "conventional_wisdom"}, {"score": 0.002626645763725465, "phrase": "experimental_results"}, {"score": 0.002541910967437926, "phrase": "low-power_processors"}, {"score": 0.002322689143237591, "phrase": "carry-less_multiplication_instruction_set"}, {"score": 0.00219311232069446, "phrase": "accessible_proofs"}, {"score": 0.0021398115287338693, "phrase": "strong_universality"}], "paper_keywords": ["string hashing", " Barrett reduction", " Carry-less Multiplications", " Binary finite fields", " non-cryptographic hash functions"], "paper_abstract": "We present fast strongly universal string hashing families: they can process data at a rate of 0.2 CPU cycle per byte. Maybe surprisingly, we find that these families-though they require a large buffer of random numbers-are often faster than popular hash functions with weaker theoretical guarantees. Moreover, conventional wisdom is that hash functions with fewer multiplications are faster. Yet we find that they may fail to be faster due to operation pipelining. We present experimental results on several processors including low-power processors. Our tests include hash functions designed for processors with the carry-less multiplication instruction set. We also prove, using accessible proofs, the strong universality of our families.", "paper_title": "Strongly Universal String Hashing is Fast", "paper_id": "WOS:000344649500003"}