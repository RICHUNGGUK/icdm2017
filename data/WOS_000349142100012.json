{"auto_keywords": [{"score": 0.049596205816074275, "phrase": "ruby"}, {"score": 0.008539538821215385, "phrase": "hardware_transactional_memory"}, {"score": 0.00481495049065317, "phrase": "global_interpreter_locks"}, {"score": 0.004600228893803583, "phrase": "global_interpreter_lock"}, {"score": 0.0044398358177815305, "phrase": "internal_designs"}, {"score": 0.004177724522109952, "phrase": "multi-thread_performance"}, {"score": 0.004135562737140424, "phrase": "multi-core_machines"}, {"score": 0.0037365789119629873, "phrase": "intel"}, {"score": 0.003642962673467835, "phrase": "prior_prototypes"}, {"score": 0.0034803228231621687, "phrase": "realistic_programs"}, {"score": 0.0030811340338342454, "phrase": "new_technique"}, {"score": 0.0030038988468808845, "phrase": "transaction_lengths"}, {"score": 0.0029584874121320165, "phrase": "per-bytecode_basis"}, {"score": 0.0027554538693034163, "phrase": "relative_overhead"}, {"score": 0.002566321199130789, "phrase": "htm"}, {"score": 0.0024766636161181544, "phrase": "npb_programs"}, {"score": 0.002342048999008582, "phrase": "webrick"}, {"score": 0.002237357942660354, "phrase": "dynamic_transaction-length_adjustment"}, {"score": 0.002203509076886664, "phrase": "best_transaction_lengths"}, {"score": 0.0021049977753042253, "phrase": "sufficiently_long_running_times"}], "paper_keywords": ["Global interpreter lock", " hardware transactional memory", " scripting language", " lock elision"], "paper_abstract": "Many scripting languages use a Global Interpreter Lock (GIL) to simplify the internal designs of their interpreters, but this kind of lock severely lowers the multi-thread performance on multi-core machines. This paper presents our first results eliminating the GIL in Ruby using Hardware Transactional Memory (HTM) in the IBM zEnterprise EC12 and Intel 4th Generation Core processors. Though prior prototypes replaced a GIL with HTM, we tested realistic programs, the Ruby NAS Parallel Benchmarks (NPB), the WEBrick HTTP server, and Ruby on Rails. We devised a new technique to dynamically adjust the transaction lengths on a per-bytecode basis, so that we can optimize the likelihood of transaction aborts against the relative overhead of the instructions to begin and end the transactions. Our results show that HTM achieved 1.9- to 4.4-fold speed-ups in the NPB programs over the GIL with 12 threads, and 1.6- and 1.2-fold speedups in WEBrick and Ruby on Rails, respectively. The dynamic transaction-length adjustment chose the best transaction lengths for any number of threads and applications with sufficiently long running times.", "paper_title": "Eliminating Global Interpreter Locks in Ruby through Hardware Transactional Memory", "paper_id": "WOS:000349142100012"}