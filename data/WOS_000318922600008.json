{"auto_keywords": [{"score": 0.03999007166030321, "phrase": "gpu"}, {"score": 0.005384337333869486, "phrase": "gpu."}, {"score": 0.00481495049065317, "phrase": "lossless_stages"}, {"score": 0.0047597635659244655, "phrase": "gpu-based_mpeg_encoder"}, {"score": 0.004651271219032404, "phrase": "parallel_computations"}, {"score": 0.004545240514015278, "phrase": "interesting_target"}, {"score": 0.004493130934067195, "phrase": "matrix_transformations"}, {"score": 0.004424585031348387, "phrase": "dct"}, {"score": 0.004323690117778359, "phrase": "mpeg_video_coding_algorithms"}, {"score": 0.004208881856146758, "phrase": "synthetic_video"}, {"score": 0.0040828649039147576, "phrase": "transfer_time"}, {"score": 0.0037072310568610723, "phrase": "raw_video"}, {"score": 0.0035536228914319354, "phrase": "raw_frame"}, {"score": 0.0034063576796640603, "phrase": "resulting_coefficients"}, {"score": 0.003265175268104804, "phrase": "resulting_mpeg_bitstream"}, {"score": 0.00322769360059123, "phrase": "last_steps"}, {"score": 0.003105824909705158, "phrase": "cpu-based_implementations"}, {"score": 0.0030583717270715556, "phrase": "different_approaches"}, {"score": 0.0029090845459992737, "phrase": "better_usage"}, {"score": 0.002875678729214611, "phrase": "memory_bus"}, {"score": 0.0028317319086202217, "phrase": "suboptimal_use"}, {"score": 0.002662541169311738, "phrase": "zigzag_scan"}, {"score": 0.0026421168168425237, "phrase": "huffman"}, {"score": 0.002532526438148958, "phrase": "actual_output_bitstream"}, {"score": 0.002484244752605477, "phrase": "cpu"}, {"score": 0.0023178219772486868, "phrase": "last_sequential_compression_steps"}, {"score": 0.0022474806085983536, "phrase": "parallel_fast_scan_implementation"}, {"score": 0.0021876814398268775, "phrase": "overall_performance"}, {"score": 0.0021049977753042253, "phrase": "extra_cost"}], "paper_keywords": ["Zigzag scan", " Huffman coding", " GPU", " Video compression", " MPEG", " Entropy coding"], "paper_abstract": "Modern GPUs excel in parallel computations, so they are an interesting target to perform matrix transformations such as the DCT, a fundamental part of MPEG video coding algorithms. Considering a system to encode synthetic video (e.g., computer-generated frames), this approach becomes even more appealing, since the images to encode are already in the GPU, eliminating the costs of transferring raw video from the CPU to the GPU. However, after a raw frame has been transformed and quantized by the GPU, the resulting coefficients must be reordered, entropy encoded and framed into the resulting MPEG bitstream. These last steps are essentially sequential and their straightforward GPU implementation is inefficient compared to CPU-based implementations. We present different approaches to implement part of these steps in GPU, aiming for a better usage of the memory bus, compensating the suboptimal use of the GPU with the gains in transfer time. We analyze three approaches to perform the zigzag scan and Huffman coding combining GPU and CPU, and two approaches to assemble the results to build the actual output bitstream both in GPU and CPU memory. Our experiments show that optimising the amount of data transferred from GPU to CPU implementing the last sequential compression steps in the GPU, and using a parallel fast scan implementation of the zigzag scanning improve the overall performance of the system. Savings in transfer time outweigh the extra cost incurred in the GPU.", "paper_title": "Optimising lossless stages in a GPU-based MPEG encoder", "paper_id": "WOS:000318922600008"}