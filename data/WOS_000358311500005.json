{"auto_keywords": [{"score": 0.050078515420922134, "phrase": "refinement_types"}, {"score": 0.03552824651719228, "phrase": "liquidhaskell"}, {"score": 0.004747620102130588, "phrase": "real_world"}, {"score": 0.004703310473363281, "phrase": "haskell"}, {"score": 0.00422177384286051, "phrase": "program_properties"}, {"score": 0.004182301599359094, "phrase": "compile_time"}, {"score": 0.003934540154108188, "phrase": "program_values"}, {"score": 0.0036667768092524576, "phrase": "existing_type_system"}, {"score": 0.0034657012607680173, "phrase": "external_smt_solvers"}, {"score": 0.0033851984021896287, "phrase": "refinement_type_checker"}, {"score": 0.003110515172439764, "phrase": "haskell_code"}, {"score": 0.0028047899594686003, "phrase": "high-level_overview"}, {"score": 0.002613709503583786, "phrase": "qualitative_discussion"}, {"score": 0.0024586427394152196, "phrase": "generic_application_independent_criteria"}, {"score": 0.0023678143146455017, "phrase": "specific_concerns"}, {"score": 0.0023456351719724957, "phrase": "memory_safety"}, {"score": 0.002323663295811215, "phrase": "data_structure_correctness"}, {"score": 0.0022378101636842296, "phrase": "quantitative_evaluation"}, {"score": 0.0021049977753042253, "phrase": "programmer_effort"}], "paper_keywords": [""], "paper_abstract": "Haskell has many delightful features. Perhaps the one most beloved by its users is its type system that allows developers to specify and verify a variety of program properties at compile time. However, many properties, typically those that depend on relationships between program values are impossible, or at the very least, cumbersome to encode within the existing type system. Many such properties can be verified using a combination of Refinement Types and external SMT solvers. We describe the refinement type checker LIQUIDHASKELL, which we have used to specify and verify a variety of properties of over 10,000 lines of Haskell code from various popular libraries, including containers, hscolour, bytestring, text, vector-algorithms and xmonad. First, we present a high-level overview of LIQUIDHASKELL, through a tour of its features. Second, we present a qualitative discussion of the kinds of properties that can be checked - ranging from generic application independent criteria like totality and termination, to application specific concerns like memory safety and data structure correctness invariants. Finally, we present a quantitative evaluation of the approach, with a view towards measuring the efficiency and programmer effort required for verification, and discuss the limitations of the approach.", "paper_title": "LiquidHaskell: Experience with Refinement Types in the Real World", "paper_id": "WOS:000358311500005"}