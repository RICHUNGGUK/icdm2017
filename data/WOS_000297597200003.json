{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "transaction_interaction_properties"}, {"score": 0.004783852487938866, "phrase": "transaction-level_modeling"}, {"score": 0.004722254884093624, "phrase": "hardware_design"}, {"score": 0.004631335513513859, "phrase": "higher_level"}, {"score": 0.004571692719970733, "phrase": "register-transfer_level"}, {"score": 0.004215868268050613, "phrase": "system_synthesis"}, {"score": 0.004081385289516914, "phrase": "chen_et_al"}, {"score": 0.004041880419426066, "phrase": "fmcad"}, {"score": 0.003951175193382119, "phrase": "formal_methods"}, {"score": 0.003925633992809873, "phrase": "computer_aided_design"}, {"score": 0.0038251032877881412, "phrase": "mahajan_et_al"}, {"score": 0.003788069044402032, "phrase": "memocode"}, {"score": 0.003392507399258166, "phrase": "design_automation"}, {"score": 0.0031690434364310435, "phrase": "useful_unit"}, {"score": 0.0031485421129798996, "phrase": "design_verification"}, {"score": 0.0030086877092638945, "phrase": "multiple_transactions"}, {"score": 0.002922069655177295, "phrase": "sequential_processing"}, {"score": 0.0029031614127920232, "phrase": "hazard_checking"}, {"score": 0.0028843751686557736, "phrase": "pipelined_circuits"}, {"score": 0.002828740624702789, "phrase": "rtl_design"}, {"score": 0.0028104345972072534, "phrase": "significant_expertise"}, {"score": 0.0027741761880779535, "phrase": "higher-level_computation"}, {"score": 0.002711842889248926, "phrase": "possible_instrumentation"}, {"score": 0.002566215899764421, "phrase": "easy_use"}, {"score": 0.0025331002386232014, "phrase": "rtl_designs"}, {"score": 0.0024521640882380477, "phrase": "interaction_properties"}, {"score": 0.0023054252458274823, "phrase": "finite-state_system"}, {"score": 0.0022390081666133627, "phrase": "encoded_finite-state_system"}, {"score": 0.0021464286727045623, "phrase": "transaction-level_model"}, {"score": 0.0021049977753042253, "phrase": "simple_examples"}], "paper_keywords": ["Transaction level modeling", " Model checking", " Infinite state systems"], "paper_abstract": "Transaction-level modeling is used in hardware design for describing designs at a higher level compared to the register-transfer level (RTL) (e. g. Cai and Gajski in CODES + ISSS '03: proceedings of the 1st IEEE/ACM/IFIP international conference on Hardware/software codesign and system synthesis, pp. 19-24, 2003; Chen et al. in FMCAD '07: proceedings of the formal methods in computer aided design, pp. 53-61, 2007; Mahajan et al. in MEMOCODE '07: proceedings of the 5th IEEE/ACM international conference on formal methods and models for codesign, pp. 123-132, 2007; Swan in DAC '06: proceedings of the 43rd annual conference on design automation, pp. 90-92, 2006). Each transaction represents a unit of work, which is also a useful unit for design verification. In such models, there are many properties of interest which involve interactions between multiple transactions. Examples of this are ordering relationships in sequential processing and hazard checking in pipelined circuits. Writing such properties on the RTL design requires significant expertise in understanding the higher-level computation being done in a given RTL design and possible instrumentation of the RTL to express the property of interest. This is a barrier to the easy use of such properties in RTL designs. In this paper, we consider specification of interaction properties at the transaction-level and the subsequent encoding of the property and the transaction-level model as a finite-state system for model checking. We discuss how the encoded finite-state system can be automatically generated from the specification of the property and the transaction-level model, and illustrate this through simple examples.", "paper_title": "Specification and encoding of transaction interaction properties", "paper_id": "WOS:000297597200003"}