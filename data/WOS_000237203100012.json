{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "software_components"}, {"score": 0.004731638279336065, "phrase": "component_connection"}, {"score": 0.004187284711626886, "phrase": "conventional_component_connection_models"}, {"score": 0.003792657064634775, "phrase": "code_reuse"}, {"score": 0.003726967166630926, "phrase": "component_source_code"}, {"score": 0.0033559647822437298, "phrase": "new_component_model"}, {"score": 0.003259604990188875, "phrase": "existing_component_architecture"}, {"score": 0.0031660031870090434, "phrase": "component_service_type"}, {"score": 0.003039445153076014, "phrase": "method_type_collection"}, {"score": 0.002952146666681891, "phrase": "requester_components"}, {"score": 0.002884111441153185, "phrase": "flexible_connections"}, {"score": 0.0028341130433482565, "phrase": "relaxed_component_matching"}, {"score": 0.0025967927629150715, "phrase": "return_values"}, {"score": 0.0025221759076833124, "phrase": "required_methods"}, {"score": 0.00249293148301837, "phrase": "provided_ones"}, {"score": 0.0024496978447849835, "phrase": "well-defined_range"}, {"score": 0.0023654615987859402, "phrase": "experimental_evaluations"}, {"score": 0.002231441081806766, "phrase": "conventional_models"}, {"score": 0.0021672995161145276, "phrase": "component-use_cost"}, {"score": 0.0021049977753042253, "phrase": "changing_connections"}], "paper_keywords": ["component-based development", " software components", " connection model", " software reuse", " JavaBeans"], "paper_abstract": "A component connection enables a component to use the functionality of other components directly, without generating adapters or other mechanisms at run-time. In conventional component connection models, the connection between components, particularly third-party components, is very costly for code reuse because the component source code must be modified if the types of requester-side and provider-side are different. This paper proposes a new component model, built upon an existing component architecture, which abandons a component service type and connects components based on a method type collection of the provider and requester components. Our model enables flexible connections owing to relaxed component matching, in which the system that implements our model automatically converts values of parameters, return values, and exceptions between required methods and provided ones within a well-defined range. As a result of experimental evaluations, it is found that our model is superior to conventional models in terms of the component-use cost and the capability of changing connections.", "paper_title": "A flexible connection model for software components", "paper_id": "WOS:000237203100012"}