{"auto_keywords": [{"score": 0.0426592730356598, "phrase": "lp_decoding"}, {"score": 0.00481495049065317, "phrase": "large_scale_lp_decoding"}, {"score": 0.004764859786310636, "phrase": "binary_linear_error-correcting_codes"}, {"score": 0.004633805690244912, "phrase": "relaxed_version"}, {"score": 0.004585590781137879, "phrase": "maximum_likelihood_decoding_problem"}, {"score": 0.0044906540097516545, "phrase": "linear_program"}, {"score": 0.0043976740574978085, "phrase": "lp_decoder"}, {"score": 0.004306610946695577, "phrase": "error-correcting_codes"}, {"score": 0.004016413965935386, "phrase": "standard_lp_solvers"}, {"score": 0.003919515745050147, "phrase": "block_lengths"}, {"score": 0.0038922607214377557, "phrase": "modern_error"}, {"score": 0.0037456980766939836, "phrase": "decomposition_methods"}, {"score": 0.0037196472104696157, "phrase": "optimization_theory"}, {"score": 0.0035299344877334385, "phrase": "efficient_distributed_algorithms"}, {"score": 0.003468864442215017, "phrase": "key_enabling_technical_result"}, {"score": 0.0034327289845581693, "phrase": "\"two-slice\"_characterization"}, {"score": 0.0032919001003538758, "phrase": "convex_hull"}, {"score": 0.0032236602306747637, "phrase": "single_parity_check_code"}, {"score": 0.0031900709094621975, "phrase": "new_characterization"}, {"score": 0.0030062165552187086, "phrase": "efficient_algorithm"}, {"score": 0.00298529328029672, "phrase": "euclidean_norm_projection"}, {"score": 0.002954180291607795, "phrase": "parity_polytope"}, {"score": 0.002872783899731766, "phrase": "admm_decoder"}, {"score": 0.0027356847952125433, "phrase": "large-scale_error"}, {"score": 0.0026696020591118344, "phrase": "numerical_results"}, {"score": 0.002651015392318126, "phrase": "ldpc_codes"}, {"score": 0.0025960262223338293, "phrase": "waterfall_region"}, {"score": 0.002506894277338543, "phrase": "slightly_higher_snr"}, {"score": 0.0024807547991927137, "phrase": "sum-product_bp"}, {"score": 0.00244632460902489, "phrase": "error_floor"}, {"score": 0.002337684811187166, "phrase": "bp._our_implementation"}, {"score": 0.0022972122534119124, "phrase": "admm"}, {"score": 0.0021049977753042253, "phrase": "particularly_simple_schedule"}], "paper_keywords": ["Alternating direction method of multipliers (ADMM)", " belief propagation (BP)", " decomposition methods", " error floors", " Euclidean projection", " graphical models", " iterative algorithms", " linear programming (LP) decoding", " low-density parity check (LDPC) codes", " parity polytope", " permutohedron"], "paper_abstract": "When binary linear error-correcting codes are used over symmetric channels, a relaxed version of the maximum likelihood decoding problem can be stated as a linear program (LP). This LP decoder can be used to decode error-correcting codes at bit-error-rates comparable to state-of-the-art belief propagation (BP) decoders, but with significantly stronger theoretical guarantees. However, LP decoding when implemented with standard LP solvers does not easily scale to the block lengths of modern error correcting codes. In this paper, we draw on decomposition methods from optimization theory, specifically the alternating direction method of multipliers (ADMM), to develop efficient distributed algorithms for LP decoding. The key enabling technical result is a \"two-slice\" characterization of the parity polytope, the polytope formed by taking the convex hull of all codewords of the single parity check code. This new characterization simplifies the representation of points in the polytope. Using this simplification, we develop an efficient algorithm for Euclidean norm projection onto the parity polytope. This projection is required by the ADMM decoder and its solution allows us to use LP decoding, with all its theoretical guarantees, to decode large-scale error correcting codes efficiently. We present numerical results for LDPC codes of lengths more than 1000. The waterfall region of LP decoding is seen to initiate at a slightly higher SNR than for sum-product BP, however an error floor is not observed for LP decoding, which is not the case for BP. Our implementation of LP decoding using the ADMM executes as fast as our baseline sum-product BP decoder, is fully parallelizable, and can be seen to implement a type of message-passing with a particularly simple schedule.", "paper_title": "Decomposition Methods for Large Scale LP Decoding", "paper_id": "WOS:000327594500006"}