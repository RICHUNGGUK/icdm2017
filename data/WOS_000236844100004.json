{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "symbolic_execution"}, {"score": 0.0047468516620285525, "phrase": "uninterpreted_functions"}, {"score": 0.0046797114400479135, "phrase": "symbolic_simulation"}, {"score": 0.004452078350485375, "phrase": "staple_techniques"}, {"score": 0.004389089062127892, "phrase": "formal_hardware_verification"}, {"score": 0.0036990033106718183, "phrase": "different_versions"}, {"score": 0.003646629717560631, "phrase": "assembly_language_programs"}, {"score": 0.0032766780632972363, "phrase": "intricate_code_optimizations"}, {"score": 0.0032302647179383915, "phrase": "complex_architectures"}, {"score": 0.003161870571621079, "phrase": "high-performance_embedded_software"}, {"score": 0.003007846011394511, "phrase": "vliw_processors"}, {"score": 0.002480680078868508, "phrase": "resulting_tools"}, {"score": 0.0023936956017015696, "phrase": "previously_unknown_bugs"}, {"score": 0.002326304140277375, "phrase": "industrial_and_published_example_code"}], "paper_keywords": ["formal verification", " embedded software", " DSP", " VLIW"], "paper_abstract": "Symbolic simulation and uninterpreted functions have long been staple techniques for formal hardware verification. In recent years, we have adapted these techniques for the automatic, formal verification of low-level embedded software-specifically, checking the equivalence of different versions of assembly language programs. Our approach, though limited in scalability, has proven particularly promising for the intricate code optimizations and complex architectures typical of high-performance embedded software, such as for DSPs and VLIW processors. Indeed, one of our key findings was how easy it was to create or retarget our verification tools to different, even very complex, machines. The resulting tools automatically verified or found previously unknown bugs in several small sequences of industrial and published example code. This paper provides an introduction to these techniques and a review of our results.", "paper_title": "Embedded software verification using symbolic execution and uninterpreted functions", "paper_id": "WOS:000236844100004"}