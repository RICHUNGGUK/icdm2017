{"auto_keywords": [{"score": 0.04839945497190436, "phrase": "custom_instructions"}, {"score": 0.047232975924705344, "phrase": "code_compression"}, {"score": 0.004814955496608903, "phrase": "customized"}, {"score": 0.004790458415602282, "phrase": "pipeline_and_instruction_set_architecture"}, {"score": 0.00457553517865013, "phrase": "execution_speed"}, {"score": 0.004483120978156604, "phrase": "embedded_applications"}, {"score": 0.0042819270655224916, "phrase": "simultaneous_registerfile_accesses"}, {"score": 0.004238452771031322, "phrase": "larger_registerfiles"}, {"score": 0.0041316803676012155, "phrase": "complex_forwarding_interconnects"}, {"score": 0.003986684503518077, "phrase": "limited_ports"}, {"score": 0.003926105480202798, "phrase": "base_processor_registerfile"}, {"score": 0.0036928221419965253, "phrase": "recent_researches"}, {"score": 0.0035269696779744266, "phrase": "innovative_architectural_techniques"}, {"score": 0.0034733518170738517, "phrase": "customized_compilations"}, {"score": 0.0031845067058084583, "phrase": "complete_pipeline_design"}, {"score": 0.0030414140732789186, "phrase": "customized_instruction_set"}, {"score": 0.003010496595090984, "phrase": "pipeline_architecture"}, {"score": 0.002964706925144123, "phrase": "optimized_embedded_engine"}, {"score": 0.0028026735035370206, "phrase": "available_registerfile_data_bandwidth"}, {"score": 0.0027041907335656782, "phrase": "achieved_improvements"}, {"score": 0.0026359661683151006, "phrase": "double-word_custom_instructions"}, {"score": 0.0025046245057922557, "phrase": "potential_hazards"}, {"score": 0.002416589459425828, "phrase": "introduced_pipeline_backwarding_concept"}, {"score": 0.0023798115577749225, "phrase": "higher_performance"}, {"score": 0.002249672943553135, "phrase": "proposed_architecture"}, {"score": 0.0022267859286766553, "phrase": "domain-specific_workloads"}, {"score": 0.0022041312401435346, "phrase": "packet-processing_benchmarks"}, {"score": 0.0021705796895687864, "phrase": "developed_framework"}], "paper_keywords": ["Embedded packet-processing engine", " Customized application-specific processor", " Custom instruction generation", " Area performance tradeoffs", " Custom instruction data bandwidth"], "paper_abstract": "Custom instructions potentially improve execution speed and code compression of embedded applications. However, more efficient custom instructions need higher number of simultaneous registerfile accesses. Larger registerfiles are more power hungry with complex forwarding interconnects. Therefore, due to the limited ports of the base processor registerfile, size and efficiency of custom instructions could be generally limited. Recent researches have focused on overcoming this limitation by some innovative architectural techniques supplemented with customized compilations. However, to the best of our knowledge there are few researches that take into account the complete pipeline design and implementation considerations. This paper proposes a customized instruction set and pipeline architecture for an optimized embedded engine. The proposed architecture increases the performance by enhancing the available registerfile data bandwidth through register access pipelining. The achieved improvements are made by introducing double-word custom instructions whose registerfile accesses are overlapped in the pipeline. Potential hazards in such instructions are resolved by the introduced pipeline backwarding concept, yielding higher performance and code compression. While we study the effectiveness of the proposed architecture on domain-specific workloads from packet-processing benchmarks, the developed framework and architecture are applicable to other embedded application domains.", "paper_title": "Customized pipeline and instruction set architecture for embedded processing engines", "paper_id": "WOS:000335559500019"}