{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "speculative_parallelization"}, {"score": 0.004713379149462482, "phrase": "code_sections"}, {"score": 0.004421284843189731, "phrase": "significant_speedups"}, {"score": 0.00421410521089045, "phrase": "novel_compiler_static_cost_model"}, {"score": 0.004081385289516914, "phrase": "resulting_performance"}, {"score": 0.003995226376780718, "phrase": "expected_speedups"}, {"score": 0.003921324779989663, "phrase": "candidate_speculative_sections"}, {"score": 0.0038487848937121204, "phrase": "combined_runtime_effects"}, {"score": 0.003757480190200645, "phrase": "scheduling_restrictions"}, {"score": 0.0036488111139918135, "phrase": "likely_execution_duration"}, {"score": 0.0035056552382170575, "phrase": "quantitative_estimate"}, {"score": 0.003422462630994095, "phrase": "prior_heuristics"}, {"score": 0.00335016692413066, "phrase": "speculative_multithreaded_execution"}, {"score": 0.00332345018550604, "phrase": "previous_work"}, {"score": 0.0032969458013463807, "phrase": "limited_version"}, {"score": 0.003167550968972378, "phrase": "spec_benchmarks"}, {"score": 0.0031255543155487234, "phrase": "load_imbalance"}, {"score": 0.003108911488613549, "phrase": "thread_dispatch"}, {"score": 0.0030270132320276096, "phrase": "extended_framework"}, {"score": 0.002947266048104005, "phrase": "data-dependence_violations"}, {"score": 0.002900426826591769, "phrase": "prediction_accuracy"}, {"score": 0.0027569439953988705, "phrase": "static_model"}, {"score": 0.0021390191069313945, "phrase": "large_slowdowns"}, {"score": 0.0021049977753042253, "phrase": "naive_approach"}], "paper_keywords": ["measurement", " performance", " speculative parallelization", " speculative multithreading", " thread-level speculation"], "paper_abstract": "Speculative parallelization is a technique that allows code sections that cannot be fully analyzed by the compiler to be aggressively executed in parallel. However, while speculative parallelization can potentially deliver significant speedups, several overheads associated with this technique can limit these speedups in practice. This paper proposes a novel compiler static cost model of speculative multithreaded execution that can be used to predict the resulting performance. This model attempts to predict the expected speedups, or slowdowns, of the candidate speculative sections based on the estimation of the combined runtime effects of various overheads, and taking into account the scheduling restrictions of most speculative execution environments. The model is based on estimating the likely execution duration of threads and considers all the possible permutations of these threads. This model also produces a quantitative estimate of the speedup, which is different from prior heuristics that only qualitatively estimate the benefits of speculative multithreaded execution. In previous work, a limited version of the framework was evaluated on a number of loops from a collection of SPEC benchmarks that suffer mainly from load imbalance and thread dispatch and commit overheads. In this work, an extended framework is also evaluated on loops that may suffer from data-dependence violations. Experimental results show that prediction accuracy is lower when loops with violations are included. Nevertheless, accuracy is still very high for a static model: the framework can identify, on average, 45% of the loops that cause slowdowns and, on average, 96% of the loops that lead to speedups; it predicts the speedups or slowdowns with an error of less than 20% for an average of 28% of the loops across the benchmarks and with an error of less than 50% for an average of 80% of the loops. Overall, the framework often outperforms, by as much as 25%, a naive approach that attempts to speculatively parallelize all the loops considered, and is able to curb the large slowdowns caused in many cases by this naive approach.", "paper_title": "A compiler cost model for speculative parallelization", "paper_id": "WOS:000250622500005"}