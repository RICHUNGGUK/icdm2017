{"auto_keywords": [{"score": 0.04585394653231558, "phrase": "subgoal_selection"}, {"score": 0.0445650695614191, "phrase": "delay_declarations"}, {"score": 0.00481495049065317, "phrase": "non-suspension_conditions"}, {"score": 0.004743933823295797, "phrase": "dynamic_scheduling"}, {"score": 0.004701825207431857, "phrase": "logic_program"}, {"score": 0.004646258518859209, "phrase": "logic_component"}, {"score": 0.004605012887484129, "phrase": "control_component"}, {"score": 0.0044967977146747684, "phrase": "predicate_logic"}, {"score": 0.0034612507694547013, "phrase": "abstract_interpretation_schemes"}, {"score": 0.0028269905110337094, "phrase": "lightweight_point-and-click_mode"}, {"score": 0.002414191082427217, "phrase": "n_subgoals"}, {"score": 0.0023927122637929813, "phrase": "single_boolean_function"}, {"score": 0.002329412930430366, "phrase": "suspension_behavior"}, {"score": 0.002315574871863272, "phrase": "large_programs"}, {"score": 0.0022077827041801193, "phrase": "program_development_cycle"}, {"score": 0.0021049977753042253, "phrase": "existing_programs"}], "paper_keywords": ["languages", " theory", " verification", " abstract interpretation", " concurrency", " logic programming", " debugging"], "paper_abstract": "A logic program consists of a logic component and a control component. The former is a specification in predicate logic whereas the latter defines the order of subgoal selection. The order of subgoal selection is often controlled with delay declarations that specify that a subgoal is to suspend until some condition on its arguments is satisfied. Reasoning about delay declarations is notoriously difficult for the programmer and it is not unusual for a program and a goal to reduce to a state that contains a subgoal that suspends indefinitely. Suspending subgoals are usually unintended and often indicate an error in the logic or the control. A number of abstract interpretation schemes have therefore been proposed for checking that a given program and goal cannot reduce to such a state. This article considers a reversal of this problem, advocating an analysis that for a given program infers a class of goals that do not lead to suspension. This article shows that this more general approach can have computational, implementational and user-interface advantages. In terms of user-interface, this approach leads to a lightweight point-and-click mode of operation in which, after directing the analyser at a file, the user merely has to inspect the results inferred by the analysis. In terms of implementation, the analysis can be straightforwardly realized as two simple fixpoint computations. In terms of computation, by modeling n! different schedulings of n subgoals with a single Boolean function, it is possible to reason about the suspension behavior of large programs. In particular, the analysis is fast enough to be applied repeatedly within the program development cycle. The article also demonstrates that the method is precise enough to locate bugs in existing programs.", "paper_title": "Inferring non-suspension conditions for logic programs with dynamic scheduling", "paper_id": "WOS:000257429400003"}