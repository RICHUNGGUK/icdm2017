{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "mobile_thin_clients"}, {"score": 0.0046621835537196754, "phrase": "thin_client_computing_principle"}, {"score": 0.004606148097788071, "phrase": "user_interface"}, {"score": 0.004496080495247288, "phrase": "application_logic"}, {"score": 0.0043358695338488445, "phrase": "client_device"}, {"score": 0.004266501496765747, "phrase": "display_updates"}, {"score": 0.00419823857480455, "phrase": "distant_application_server"}, {"score": 0.004131063310728304, "phrase": "user_interaction"}, {"score": 0.0040978781692373005, "phrase": "existing_remote_display_frameworks"}, {"score": 0.00398380712846857, "phrase": "complex_scenes"}, {"score": 0.003951800212882157, "phrase": "modern_applications"}, {"score": 0.003515479934694842, "phrase": "binary_encoded_objects"}, {"score": 0.003335804608791029, "phrase": "semantic_knowledge"}, {"score": 0.0032038465090068646, "phrase": "user_input"}, {"score": 0.0030895394261534776, "phrase": "display_update"}, {"score": 0.0029553380263320195, "phrase": "interaction_latency"}, {"score": 0.002884603537502399, "phrase": "bursty_remote_display_traffic_pattern"}, {"score": 0.0028042108531816943, "phrase": "particular_interest"}, {"score": 0.0027704444816096484, "phrase": "wireless_context"}, {"score": 0.0025866199378466754, "phrase": "generic_architecture"}, {"score": 0.0025554669315362424, "phrase": "semantic_remote_display_framework"}, {"score": 0.0024149629835339926, "phrase": "semantic_information"}, {"score": 0.0023287359930308864, "phrase": "bandwidth_consumption"}, {"score": 0.0021917966722180132, "phrase": "average_reduction"}, {"score": 0.0021479597698614373, "phrase": "data_peaks"}, {"score": 0.0021049977753042253, "phrase": "remote_display_protocol_traffic"}], "paper_keywords": ["Thin client", " Semantic remote display"], "paper_abstract": "According to the thin client computing principle, the user interface is physically separated from the application logic. In practice only a viewer component is executed on the client device, rendering the display updates received from the distant application server and capturing the user interaction. Existing remote display frameworks are not optimized to encode the complex scenes of modern applications, which are composed of objects with very diverse graphical characteristics. In order to tackle this challenge, we propose to transfer to the client, in addition to the binary encoded objects, semantic information about the characteristics of each object. Through this semantic knowledge, the client is enabled to react autonomously on user input and does not have to wait for the display update from the server. Resulting in a reduction of the interaction latency and a mitigation of the bursty remote display traffic pattern, the presented framework is of particular interest in a wireless context, where the bandwidth is limited and expensive. In this paper, we describe a generic architecture of a semantic remote display framework. Furthermore, we have developed a prototype using the MPEG-4 Binary Format for Scenes to convey the semantic information to the client. We experimentally compare the bandwidth consumption of MPEG-4 BiFS with existing, non-semantic, remote display frameworks. In a text editing scenario, we realize an average reduction of 23% of the data peaks that are observed in remote display protocol traffic.", "paper_title": "Optimized mobile thin clients through a MPEG-4 BiFS semantic remote display framework", "paper_id": "WOS:000307270600008"}