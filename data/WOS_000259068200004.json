{"auto_keywords": [{"score": 0.04810827982024645, "phrase": "omega"}, {"score": 0.02306406534951771, "phrase": "synchrony_assumptions"}, {"score": 0.00481495049065317, "phrase": "weak_reliability"}, {"score": 0.004215057618794356, "phrase": "common_leader"}, {"score": 0.004041546659145336, "phrase": "weak_system_s"}, {"score": 0.0035006643351909246, "phrase": "previously_known_algorithms"}, {"score": 0.003162252895465901, "phrase": "system_s"}, {"score": 0.0030855783418239366, "phrase": "communication_complexity"}, {"score": 0.002896819408461957, "phrase": "quad-ratic_number"}, {"score": 0.002653606593103781, "phrase": "small_additional_assumption"}, {"score": 0.0025711283781017424, "phrase": "unknown_correct_process"}, {"score": 0.002439308179084911, "phrase": "communication-efficient_algorithm"}, {"score": 0.002422249273477746, "phrase": "omega_such_that_eventually_only_one_process"}, {"score": 0.0023387234705715154, "phrase": "recent_experimental_results"}, {"score": 0.0022032718573953922, "phrase": "dynamically-changing_systems"}, {"score": 0.0021497994978515876, "phrase": "schiper"}, {"score": 0.002134760997476979, "phrase": "toueg"}], "paper_keywords": [""], "paper_abstract": "We study the feasibility and cost of implementing Omega-a fundamental failure detector at the core of many algorithms-in systems with weak reliability and synchrony assumptions. Intuitively, Omega allows processes to eventually elect a common leader. We first give an algorithm that implements Omega in a weak system S where (a) except for some unknown timely process s, all processes may be arbitrarily slow or may crash, and (b) only the output links of s are eventually timely (all other links can be arbitrarily slow and lossy). Previously known algorithms for Omega worked only in systems that are strictly stronger than S in terms of reliability or synchrony assumptions.We next show that algorithms that implement Omega in system S are necessarily expensive in terms of communication complexity: all correct processes (except possibly one) must send messages forever; moreover, a quad-ratic number of links must carry messages forever. This result holds even for algorithms that tolerate at most one crash. Finally, we show that with a small additional assumption to system S-the existence of some unknown correct process whose links can be arbitrarily slow and lossy but fair-there is a communication-efficient algorithm for Omega such that eventually only one process (the elected leader) sends messages. Some recent experimental results indicate that two of the algorithms for Omega described in this paper can be used in dynamically-changing systems and work well in practice [Schiper, Toueg in Proceedings of the 38th International Conference on Dependable Systems and Networks, pp. 207-216 (2008)].", "paper_title": "On implementing omega in systems with weak reliability and synchrony assumptions", "paper_id": "WOS:000259068200004"}