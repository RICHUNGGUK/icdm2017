{"auto_keywords": [{"score": 0.041656217336660355, "phrase": "accelerator_architectures"}, {"score": 0.00481495049065317, "phrase": "pair_interactions"}, {"score": 0.004780183091824403, "phrase": "simd_architectures"}, {"score": 0.004478308876320956, "phrase": "correlation_analysis"}, {"score": 0.004445961412092278, "phrase": "straightforward_implementations"}, {"score": 0.004397875849247165, "phrase": "double_loop"}, {"score": 0.004366106816225457, "phrase": "particle_pairs"}, {"score": 0.004180234323211199, "phrase": "good_job"}, {"score": 0.0041200448395938526, "phrase": "inner_loop"}, {"score": 0.004031375102068085, "phrase": "high_performance"}, {"score": 0.004002242925856335, "phrase": "modern_cpu"}, {"score": 0.0038457452426796305, "phrase": "simd"}, {"score": 0.0037222099716098783, "phrase": "memory_bottlenecks"}, {"score": 0.0035507457285983268, "phrase": "arithmetic_operations"}, {"score": 0.003290237137651949, "phrase": "input_and_output_data"}, {"score": 0.003219368413618912, "phrase": "limiting_factor"}, {"score": 0.0031272381208680613, "phrase": "simd_parallelization"}, {"score": 0.0030709962527878656, "phrase": "fixed_number"}, {"score": 0.0029294420752976947, "phrase": "spatial_clusters"}, {"score": 0.0027943943921568456, "phrase": "data_reuse"}, {"score": 0.002754103864198219, "phrase": "traditional_scheme"}, {"score": 0.002665555782056494, "phrase": "cluster_size"}, {"score": 0.002598652897946253, "phrase": "simd_units"}, {"score": 0.002515090164966655, "phrase": "fast_and_efficient_implementation"}, {"score": 0.0024342079318127423, "phrase": "intel_mic"}, {"score": 0.002263639474937039, "phrase": "molecular_dynamics_simulations"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Pair interactions", " SIMD", " GPU", " Molecular dynamics", " Verlet list"], "paper_abstract": "Calculating interactions or correlations between pairs of particles is typically the most time-consuming task in particle simulation or correlation analysis. Straightforward implementations using a double loop over particle pairs have traditionally worked well, especially since compilers usually do a good job of unrolling the inner loop. In order to reach high performance on modern CPU and accelerator architectures, single-instruction multiple-data (SIMD) parallelization has become. essential. Avoiding memory bottlenecks is also increasingly important and requires reducing the ratio of memory to arithmetic operations. Moreover, when pairs only interact within a certain cut-off distance, good SIMD utilization can only be achieved by reordering input and output data, which quickly becomes a limiting factor. Here we present an algorithm for SIMD parallelization based on grouping a fixed number of particles, e.g. 2, 4, or 8, into spatial clusters. Calculating all interactions between particles in a pair of such clusters improves data reuse compared to the traditional scheme and results in a more efficient SIMD parallelization. Adjusting the cluster size allows the algorithm to map to SIMD units of various widths. This flexibility not only enables fast and efficient implementation on current CPUs and accelerator architectures like GPUs or Intel MIC, but it also makes the algorithm future-proof. We present the algorithm with an application to molecular dynamics simulations, where we can also make use of the effective buffering the method introduces. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "A flexible algorithm for calculating pair interactions on SIMD architectures", "paper_id": "WOS:000328725200003"}