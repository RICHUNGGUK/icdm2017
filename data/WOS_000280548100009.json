{"auto_keywords": [{"score": 0.04961325410404205, "phrase": "transactional_memory"}, {"score": 0.015719716506582538, "phrase": "parallel_nesting"}, {"score": 0.004675768396728975, "phrase": "emerging_reality"}, {"score": 0.004630270043271386, "phrase": "affordable_multi-core_architectures"}, {"score": 0.004496402246090618, "phrase": "simple_abstractions"}, {"score": 0.00428179779071721, "phrase": "concurrent_ones"}, {"score": 0.004017989546119125, "phrase": "concurrent_programming"}, {"score": 0.003940122359770492, "phrase": "wide_programmer_community"}, {"score": 0.003901754272977278, "phrase": "current_implementations"}, {"score": 0.0038448988429199086, "phrase": "nested_transactions"}, {"score": 0.003661275004971829, "phrase": "arbitrary_parallel_nesting_depths"}, {"score": 0.003572766402294553, "phrase": "important_obstacle"}, {"score": 0.003520687960750365, "phrase": "central_goal"}, {"score": 0.003368948014436939, "phrase": "parallel_threads"}, {"score": 0.0033361232750221863, "phrase": "restricted_parts"}, {"score": 0.0032079813320482304, "phrase": "intrinsic_difficulty"}, {"score": 0.003024909947609294, "phrase": "novel_solution"}, {"score": 0.0028662606272282926, "phrase": "first_practical_solution"}, {"score": 0.002663208600887875, "phrase": "synthetic_workload"}, {"score": 0.0026115277372906805, "phrase": "parallel_transactions"}, {"score": 0.002573424607574822, "phrase": "multi-core_machine"}, {"score": 0.002474505516708906, "phrase": "substantial_speed-ups"}, {"score": 0.002356173823922118, "phrase": "serial_nesting"}, {"score": 0.0021049977753042253, "phrase": "nesting_depth"}], "paper_keywords": ["Algorithms", " Nested parallel programs", " fork-join", " work-stealing", " transactional memory"], "paper_abstract": "Exploiting the emerging reality of affordable multi-core architectures goes through providing programmers with simple abstractions that would enable them to easily turn their sequential programs into concurrent ones that expose as much parallelism as possible. While transactional memory promises to make concurrent programming easy to a wide programmer community, current implementations either disallow nested transactions to run in parallel or do not scale to arbitrary parallel nesting depths. This is an important obstacle to the central goal of transactional memory, as programmers can only start parallel threads in restricted parts of their code. This paper addresses the intrinsic difficulty behind the support for parallel nesting in transactional memory, and proposes a novel solution that, to the best of our knowledge, is the first practical solution to meet the lowest theoretical upper bound known for the problem. Using a synthetic workload configured to test parallel transactions on a multi-core machine, a practical implementation of our algorithm yields substantial speed-ups (up to 22x with 33 threads) relatively to serial nesting, and shows that the time to start and commit transactions, as well as to detect conflicts, is independent of nesting depth.", "paper_title": "Leveraging Parallel Nesting in Transactional Memory", "paper_id": "WOS:000280548100009"}