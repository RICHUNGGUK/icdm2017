{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "smt-directory"}, {"score": 0.014775725567914871, "phrase": "load-load_ordering"}, {"score": 0.004774937143916685, "phrase": "efficient_load-load_ordering"}, {"score": 0.00473525754853761, "phrase": "smt."}, {"score": 0.004618169566288709, "phrase": "tso"}, {"score": 0.004392565073466714, "phrase": "single_thread"}, {"score": 0.004301834610818624, "phrase": "program_order"}, {"score": 0.00417793854311445, "phrase": "of-order_execution"}, {"score": 0.0040916230716372265, "phrase": "conventional_multi-processors"}, {"score": 0.004057596233938867, "phrase": "out-of-order_cores"}, {"score": 0.0040238512275833265, "phrase": "load-load_ordering_violations"}, {"score": 0.0039571974661570695, "phrase": "age-ordered_load_queue"}, {"score": 0.003701401653850141, "phrase": "remote_stores"}, {"score": 0.0035648266669315943, "phrase": "smt_processor"}, {"score": 0.003505749731180509, "phrase": "completing_store"}, {"score": 0.0033204052817782438, "phrase": "store_completions"}, {"score": 0.0031448288291084, "phrase": "coherence_protocol"}, {"score": 0.00290473242917264, "phrase": "cache_line"}, {"score": 0.0025623050508233078, "phrase": "data_cache_line"}, {"score": 0.00227914162528171, "phrase": "smt-directory_bits"}, {"score": 0.0022226496830385304, "phrase": "load_queue_segments"}, {"score": 0.0021049977753042253, "phrase": "local_store_completions_trigger"}], "paper_keywords": ["Simultaneous multithreading", " consistency models", " load-load ordering", " load queue search", " directory"], "paper_abstract": "Memory models like SC, TSO, and PC enforce load-load ordering, requiring that loads from any single thread appear to occur in program order to all other threads. Out-of-order execution can violate load-load ordering. Conventional multi-processors with out-of-order cores detect load-load ordering violations by snooping an age-ordered load queue on cache invalidations or evictions-events that act as proxies for the completion of remote stores. This mechanism becomes less efficient in an SMT processor, as every completing store must search the loads queue segments of all other threads. This inefficiency exists because store completions from other threads in the same core are not filtered by the cache and coherence protocol: thread 0 observes all of thread 1's stores, not only the first store to every cache line. SMT-Directory eliminates this overhead by implementing the filtering traditionally provided by the cache in the cache itself. SMT-Directory adds a per-thread \"read\" bit to every data cache line. When a load executes, it sets the bit corresponding to its thread. When a store completes and write to the cache, it checks the SMT-Directory bits of its cache line and searches the load queue segments only of those threads whose bits are set. As a result, local store completions trigger searches only for data that is actually shared.", "paper_title": "SMT-Directory: Efficient Load-Load Ordering for SMT", "paper_id": "WOS:000288081600007"}