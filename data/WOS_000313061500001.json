{"auto_keywords": [{"score": 0.046888273895838106, "phrase": "periodic_register_allocation"}, {"score": 0.023129410168436847, "phrase": "software_pipelining"}, {"score": 0.01582555441825637, "phrase": "uk"}, {"score": 0.007829163025572058, "phrase": "maxlive_registers"}, {"score": 0.0075164769218302365, "phrase": "pact"}, {"score": 0.007341134592577864, "phrase": "compilation_techniques"}, {"score": 0.007231694988195845, "phrase": "manchester"}, {"score": 0.00481495049065317, "phrase": "code_generation"}, {"score": 0.004712463245074863, "phrase": "compact_code"}, {"score": 0.004692227830462433, "phrase": "software_pipelined_loops"}, {"score": 0.004632039024076267, "phrase": "powerful_technique"}, {"score": 0.004602233424629559, "phrase": "fine-grain_parallelism"}, {"score": 0.004562789383540859, "phrase": "lifetime_intervals"}, {"score": 0.004543193737836748, "phrase": "multiple_loop_iterations"}, {"score": 0.0043705604923728195, "phrase": "code_generation_challenge"}, {"score": 0.004305203085016233, "phrase": "minimal_unrolling_factor"}, {"score": 0.0042591158963728665, "phrase": "software_pipelined_kernels"}, {"score": 0.004106063237069123, "phrase": "register_files"}, {"score": 0.004062099143026705, "phrase": "unrolling_problem"}, {"score": 0.003941478054422721, "phrase": "register_moves"}, {"score": 0.0037834649508375544, "phrase": "software_pipeline"}, {"score": 0.0036161517374293777, "phrase": "impractical_code_growth"}, {"score": 0.003592859432554987, "phrase": "latter_approach"}, {"score": 0.0032329060306656356, "phrase": "hendren_et_al"}, {"score": 0.0032121518784685296, "phrase": "cc"}, {"score": 0.0031503786105260894, "phrase": "compiler_construction"}, {"score": 0.003103260185224517, "phrase": "london"}, {"score": 0.0029980260560551982, "phrase": "code_growth-modulo_variable_expansion"}, {"score": 0.0029089095588612007, "phrase": "correct_amount"}, {"score": 0.00281635677605879, "phrase": "register_spills"}, {"score": 0.002810292047426252, "phrase": "eisenbeis_et_al"}, {"score": 0.0026116610153271943, "phrase": "open_problem"}, {"score": 0.002566997205079849, "phrase": "software-only_code_generation"}, {"score": 0.0025176604738772843, "phrase": "initiation_interval"}, {"score": 0.002469269628821745, "phrase": "generated_code"}, {"score": 0.002432274687125181, "phrase": "remaining_free_registers"}, {"score": 0.0023906713324572107, "phrase": "register_reuse"}, {"score": 0.0023650305205893353, "phrase": "minimal_loop"}, {"score": 0.0022897425998475362, "phrase": "multiple_register_types"}, {"score": 0.0022505717150817276, "phrase": "formal_problem_definition"}, {"score": 0.002197801146305747, "phrase": "dedicated_algorithm"}, {"score": 0.002150900082318562, "phrase": "industrial-strength_compiler"}, {"score": 0.00213702549310143, "phrase": "vliw_embedded_processor"}, {"score": 0.002127825629703902, "phrase": "stmicroelectronics"}, {"score": 0.0021049977753042253, "phrase": "multiple_benchmarks_suites"}], "paper_keywords": ["Periodic register allocation", " Software pipelining", " Code generation", " Instruction level parallelism", " Embedded systems", " Compilation"], "paper_abstract": "We address the problem of generating compact code from software pipelined loops. Although software pipelining is a powerful technique to extract fine-grain parallelism, it generates lifetime intervals spanning multiple loop iterations. These intervals require periodic register allocation (also called variable expansion), which in turn yields a code generation challenge. We are looking for the minimal unrolling factor enabling the periodic register allocation of software pipelined kernels. This challenge is generally addressed through one of: (1) hardware support in the form of rotating register files, which solve the unrolling problem but are expensive in hardware; (2) register renaming by inserting register moves, which increase the number of operations in the loop, and may damage the schedule of the software pipeline and reduce throughput; (3) post-pass loop unrolling that does not compromise throughput but often leads to impractical code growth. The latter approach relies on the proof that MAXLIVE registers (maximal number of values simultaneously alive) are sufficient for periodic register allocation (Eisenbeis et al. in PACT '95: Proceedings of the IFIP WG10.3 working conference on Parallel Architectures and Compilation Techniques, pages 264-267, Manchester, UK, 1995; Hendren et al. in CC '92: Proceedings of the 4th International Conference on Compiler Construction, pages 176-191, London, UK, 1992). However, the best existing heuristic for controlling this code growth-modulo variable expansion (Lam in SIGPLAN Not 23(7):318-328, 1988)-may not apply the correct amount of loop unrolling to guarantee that MAXLIVE registers are enough, which may result in register spills Eisenbeis et al. in PACT '95: Proceedings of the IFIP WG10.3 working conference on Parallel Architectures and Compilation Techniques, pages 264-267, Manchester, UK, 1995. This paper presents our research results on the open problem of minimal loop unrolling, allowing a software-only code generation that does not trade the optimality of the initiation interval (II) for the compactness of the generated code. Our novel idea is to use the remaining free registers after periodic register allocation to relax the constraints on register reuse. The problem of minimal loop unrolling arises either before or after software pipelining, either with a single or with multiple register types (classes). We provide a formal problem definition for each scenario, and we propose and study a dedicated algorithm for each problem. Our solutions are implemented within an industrial-strength compiler for a VLIW embedded processor from STMicroelectronics, and validated on multiple benchmarks suites.", "paper_title": "Minimal Unroll Factor for Code Generation of Software Pipelining", "paper_id": "WOS:000313061500001"}