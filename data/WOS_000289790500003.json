{"auto_keywords": [{"score": 0.04926219622874721, "phrase": "free_theorems"}, {"score": 0.00481495049065317, "phrase": "forced_strictness"}, {"score": 0.0045726187330434025, "phrase": "interesting_properties"}, {"score": 0.004494570360108983, "phrase": "parametrically_polymorphic_functions"}, {"score": 0.004123781267600542, "phrase": "nice_proof_tool"}, {"score": 0.0040186038781533946, "phrase": "pure_and_lazy_functional_programming_languages"}, {"score": 0.003531474887552889, "phrase": "selective_strictness"}, {"score": 0.003324783554254782, "phrase": "haskell"}, {"score": 0.0028468767420392945, "phrase": "specific_situations"}, {"score": 0.0027503564589458837, "phrase": "refined_type_system"}, {"score": 0.0026116610153271943, "phrase": "enforced_strict_evaluation"}, {"score": 0.0025014259919355453, "phrase": "unnecessary_restrictions"}, {"score": 0.0021601997088758957, "phrase": "refined_types"}], "paper_keywords": [""], "paper_abstract": "Free theorems establish interesting properties of parametrically polymorphic functions, solely from their types, and serve as a nice proof tool. For pure and lazy functional programming languages, they can be used with very few preconditions. Unfortunately, in the presence of selective strictness, as provided in languages like Haskell, their original strength is reduced. In this paper we present an approach for overcoming this weakness in specific situations. Employing a refined type system which tracks the use of enforced strict evaluation, we rule out unnecessary restrictions that otherwise emerge. Additionally, we provide (and implement) an algorithm determining all refined types for a given term.", "paper_title": "Refined typing to localize the impact of forced strictness on free theorems", "paper_id": "WOS:000289790500003"}