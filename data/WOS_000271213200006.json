{"auto_keywords": [{"score": 0.03374372076870131, "phrase": "dynamic_modules"}, {"score": 0.00481495049065317, "phrase": "embedded_fpgas"}, {"score": 0.004723322467153553, "phrase": "difficult_aspect"}, {"score": 0.0046632033374901715, "phrase": "hardware_reconfiguration"}, {"score": 0.0045162169185355, "phrase": "computational_blocks"}, {"score": 0.0043181530164057135, "phrase": "fpga_vendors"}, {"score": 0.004263168852219816, "phrase": "third_parties"}, {"score": 0.003947601392882997, "phrase": "application's_unique_connectivity"}, {"score": 0.0038230844545071303, "phrase": "latency_requirements"}, {"score": 0.0037024804835018373, "phrase": "standard_xilinx_implementation_tools"}, {"score": 0.003631945391344252, "phrase": "dynamic_module"}, {"score": 0.003608732492631878, "phrase": "partial_bitstreams"}, {"score": 0.003494866798828308, "phrase": "module's_coordinates"}, {"score": 0.00334144503360907, "phrase": "runtime_operations"}, {"score": 0.0032359856233193504, "phrase": "interface_wrappers"}, {"score": 0.0030741085942960814, "phrase": "relocatable_partial_bitstreams"}, {"score": 0.0029203055813347874, "phrase": "efficient_runtime_system"}, {"score": 0.002864628676257225, "phrase": "application_requests"}, {"score": 0.0026523079380037706, "phrase": "fpga_reconfiguration_complexities"}, {"score": 0.002535779689260244, "phrase": "large_sandbox"}, {"score": 0.0024088451312725924, "phrase": "fixed_module_slots"}, {"score": 0.002347775213789611, "phrase": "application_engineers"}, {"score": 0.0022159566043745724, "phrase": "runtime_software_api"}, {"score": 0.0021049977753042253, "phrase": "hardware_description_languages"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Performance", " FPGA partial reconfiguration", " runtime routing", " streaming datapaths", " latency tolerant channels", " software defined radio"], "paper_abstract": "The difficult aspect of hardware reconfiguration is not creating the computational blocks, which are generally available from FPGA vendors and third parties, but linking the blocks in a manner that suits each application's unique connectivity, bandwidth, and latency requirements. Our approach uses the standard Xilinx implementation tools to generate dynamic module partial bitstreams, but choosing the module's coordinates and completing connections to other modules are runtime operations. Scripts automatically add interface wrappers to dynamic modules and generate a library of relocatable partial bitstreams. The library is used by an efficient runtime system that completes application requests for instancing and connecting modules, effectively insulating the designer from FPGA reconfiguration complexities. In this way, a large sandbox may be allocated to dynamic modules rather than fixed module slots and interconnect. Application engineers interact with the Wires on Demand (WoD) system through a runtime software API, and do not have to master hardware description languages and implementation tools.", "paper_title": "Slotless Module-Based Reconfiguration of Embedded FPGAs", "paper_id": "WOS:000271213200006"}