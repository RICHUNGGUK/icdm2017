{"auto_keywords": [{"score": 0.04150699121556576, "phrase": "time_efficiency"}, {"score": 0.013305690119535205, "phrase": "space_efficiency"}, {"score": 0.00802112244685671, "phrase": "proposed_algorithms"}, {"score": 0.00481495049065317, "phrase": "data-intensive_applications"}, {"score": 0.0047587234712024775, "phrase": "multithreaded_server_applications"}, {"score": 0.004721602309430702, "phrase": "runtime_systems"}, {"score": 0.004666460260366703, "phrase": "garbage_collection"}, {"score": 0.00459393336391459, "phrase": "essential_feature"}, {"score": 0.00454027551702508, "phrase": "high_performance_systems"}, {"score": 0.004504850679320975, "phrase": "especially_those_running_data-intensive_applications"}, {"score": 0.0044002186469797476, "phrase": "garbage_collector"}, {"score": 0.004264463695140275, "phrase": "recycled_space"}, {"score": 0.00423118169200579, "phrase": "minimal_time_overhead"}, {"score": 0.003776674472150248, "phrase": "novel_concept"}, {"score": 0.0037471850931318942, "phrase": "allocation_speed"}, {"score": 0.003703380599999214, "phrase": "wasted_space"}, {"score": 0.003674461410107989, "phrase": "conventional_static_space_partitioning_techniques"}, {"score": 0.0036172962914449826, "phrase": "inefficient_space_utilization"}, {"score": 0.0033840673522948592, "phrase": "space_partitions"}, {"score": 0.003228517923065361, "phrase": "novel_parallelization_method"}, {"score": 0.0031782684007251403, "phrase": "compacting_gc_parallelization_problem"}, {"score": 0.003141093559655865, "phrase": "tree_traversal_parallelization_problem"}, {"score": 0.002926973459215349, "phrase": "strong_data_dependencies"}, {"score": 0.002881403688962202, "phrase": "source_object"}, {"score": 0.002738131487658495, "phrase": "target_location"}, {"score": 0.0025816239578784067, "phrase": "equal-sized_blocks"}, {"score": 0.002511672561475743, "phrase": "independent_blocks"}, {"score": 0.002349561762300369, "phrase": "different_gc_designs"}, {"score": 0.0023220573674955776, "phrase": "proposed_techniques"}, {"score": 0.0022769287097263564, "phrase": "apache_harmony_jvm"}, {"score": 0.0022152149658434916, "phrase": "specjbb_and_dacapo_benchmark_suites"}, {"score": 0.0021299366231555925, "phrase": "space_utilization"}, {"score": 0.0021049977753042253, "phrase": "corresponding_parallelization_schemes"}], "paper_keywords": ["Java virtual machine", " Garbage collection"], "paper_abstract": "As multithreaded server applications and runtime systems prevail, garbage collection is becoming an essential feature to support high performance systems, especially those running data-intensive applications. The fundamental issue of garbage collector (GC) design is to maximize the recycled space with minimal time overhead. This paper proposes two innovative solutions: one to improve space efficiency, and the other to improve time efficiency. To achieve space efficiency, we propose the Space Tuner that utilizes the novel concept of allocation speed to reduce wasted space. Conventional static space partitioning techniques often lead to inefficient space utilization. The Space Tuner adjusts the heap partitioning dynamically such that when a collection is triggered, all space partitions are fully filled. To achieve time efficiency, we propose a novel parallelization method that reduces the compacting GC parallelization problem into a tree traversal parallelization problem. This method can be applied for both normal and large object compaction. Object compaction is hard to parallelize due to strong data dependencies such that the source object can not be moved to its target location until the object originally in the target location has been moved out. Our proposed algorithm overcomes the difficulties by dividing the heap into equal-sized blocks and parallelizing the movement of the independent blocks. It is noteworthy that these proposed algorithms are generic such that they can be utilized in different GC designs. The proposed techniques have been implemented in Apache Harmony JVM and we evaluated the proposed algorithms with SPECjbb and Dacapo benchmark suites. The experiment results demonstrate that our proposed algorithms greatly improve space utilization and the corresponding parallelization schemes are scalable, which brings time efficiency.", "paper_title": "Space-and-Time Efficient Parallel Garbage Collector for Data-Intensive Applications", "paper_id": "WOS:000290342800001"}