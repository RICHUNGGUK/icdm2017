{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "vectorization_profitability"}, {"score": 0.004774115617883476, "phrase": "binary_classification"}, {"score": 0.004733625412289433, "phrase": "basic_block_vectorization"}, {"score": 0.004653667500876187, "phrase": "instruction-level_parallelism"}, {"score": 0.004497762477097628, "phrase": "simd_instructions"}, {"score": 0.0042373381286051354, "phrase": "vectorized_program"}, {"score": 0.004112812699639956, "phrase": "original_one"}, {"score": 0.0035883942463601688, "phrase": "classification_problem"}, {"score": 0.003468053168607071, "phrase": "machine_learning_technique"}, {"score": 0.003157455511069507, "phrase": "benchmark_suite"}, {"score": 0.0026620655619396263, "phrase": "unprofitable_vectorizations"}, {"score": 0.002413156939479018, "phrase": "llvm"}, {"score": 0.0021688641066186817, "phrase": "slower_program"}], "paper_keywords": ["machine learning", " support vector machine", " automatic vectorization", " software characteristics"], "paper_abstract": "Basic block vectorization consists in realizing instruction-level parallelism inside basic blocks in order to generate SIMD instructions and thus speedup data processing. It is however problematic, because the vectorized program may actually be slower than the original one. Therefore, it would be useful to predict beforehand whether or not vectorization will actually produce any speedup. This paper proposes to do so by expressing vectorization profitability as a classification problem, and by predicting it using a machine learning technique called support vector machine (SVM). It considers three compilers (icc, gcc and llvm), and a benchmark suite made of 151 loops, unrolled with factors ranging from 1 to 20. The paper further proposes a technique that combines the results of two SVMs to reach 99% of accuracy for all three compilers. Moreover, by correctly predicting unprofitable vectorizations, the technique presented in this paper provides speedups of up to 2.16 times, 2.47 times and 3.83 times for icc, gcc and LLVM, respectively (9%, 18% and 56% on average). It also lowers to less than 1% the probability of the compiler generating a slower program with vectorization turned on (from more than 25% for the compilers alone).", "paper_title": "Predicting Vectorization Profitability Using Binary Classification", "paper_id": "WOS:000348141600016"}