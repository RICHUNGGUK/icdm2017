{"auto_keywords": [{"score": 0.048997851305797556, "phrase": "bounded_predicate_arities"}, {"score": 0.00481495049065317, "phrase": "complexity_results"}, {"score": 0.00463507149599759, "phrase": "answer_set_programming"}, {"score": 0.004582423717777699, "phrase": "declarative_programming_paradigm"}, {"score": 0.004530371221172796, "phrase": "logic_programming"}, {"score": 0.004495996972278015, "phrase": "non-monotonic_reasoning"}, {"score": 0.004327981760540394, "phrase": "knowledge_representation_problems"}, {"score": 0.00421410521089045, "phrase": "efficient_methods"}, {"score": 0.0041662189933067, "phrase": "answer_sets"}, {"score": 0.004118874671285618, "phrase": "logic_program"}, {"score": 0.004010477922833839, "phrase": "general_answer"}, {"score": 0.003995226376780718, "phrase": "set_programming"}, {"score": 0.00373036974937097, "phrase": "language_fragment"}, {"score": 0.0034303002275695446, "phrase": "computational_problems"}, {"score": 0.003352722512047951, "phrase": "answer_set_existence"}, {"score": 0.003036263091666092, "phrase": "full_non-ground_language"}, {"score": 0.00293380698353469, "phrase": "respective_ground"}, {"score": 0.0029115112555515277, "phrase": "propositional_languages"}, {"score": 0.0028025415122856973, "phrase": "solver_implementations"}, {"score": 0.0027812405653371503, "phrase": "virtually_all_currently_available_solvers"}, {"score": 0.002547583216040341, "phrase": "polynomial_space"}, {"score": 0.0024150528983695446, "phrase": "\"grounding_bottleneck"}, {"score": 0.002263336340041527, "phrase": "programming_solvers"}, {"score": 0.0022120914337992034, "phrase": "final_contribution"}, {"score": 0.0021049977753042253, "phrase": "exponential_space_requirement"}], "paper_keywords": ["answer set programming", " computational complexity"], "paper_abstract": "Answer set programming is a declarative programming paradigm rooted in logic programming and non-monotonic reasoning. This formalism has become a host for expressing knowledge representation problems, which reinforces the interest in efficient methods for computing answer sets of a logic program. The complexity of various reasoning tasks for general answer set programming has been amply studied and is understood quite well. In this paper, we present a language fragment in which the arities of predicates are bounded by a constant. Subsequently, we analyze the complexity of various reasoning tasks and computational problems for this fragment, comprising answer set existence, brave and cautious reasoning, and strong equivalence. Generally speaking, it turns out that the complexity drops significantly with respect to the full non-ground language, but is still harder than for the respective ground or propositional languages. These results have several implications, most importantly for solver implementations: Virtually all currently available solvers have exponential (in the size of the input) space requirements even for programs with bounded predicate arities, while our results indicate that for those programs polynomial space should be sufficient. This can be seen as a manifestation of the \"grounding bottleneck\" (meaning that programs are first instantiated and then solved) from which answer set programming solvers currently suffer. As a final contribution, we provide a sketch of a method that can avoid the exponential space requirement for programs with bounded predicate arities.", "paper_title": "Complexity results for answer set programming with bounded predicate arities and implications", "paper_id": "WOS:000254176500003"}