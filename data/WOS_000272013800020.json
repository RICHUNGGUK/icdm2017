{"auto_keywords": [{"score": 0.033740565758041165, "phrase": "strong_isolation"}, {"score": 0.01648869178009223, "phrase": "isolation_barriers"}, {"score": 0.00481495049065317, "phrase": "feedback-directed_barrier_optimization"}, {"score": 0.004770295517830214, "phrase": "strongly_isolated_stm._speed_improvements"}, {"score": 0.004581505405526037, "phrase": "multiple_cores"}, {"score": 0.004455179735772526, "phrase": "parallel_programming"}, {"score": 0.004212838053019701, "phrase": "simple_and_composable_model"}, {"score": 0.0041478818670853115, "phrase": "shared_data_structures"}, {"score": 0.004122179528285764, "phrase": "software_transactions"}, {"score": 0.0037318666008429014, "phrase": "shared_memory_accesses"}, {"score": 0.003584025547693836, "phrase": "safety_properties"}, {"score": 0.003528730431045574, "phrase": "memory_operations"}, {"score": 0.0034206776096452015, "phrase": "atomic_block"}, {"score": 0.003357435261066107, "phrase": "non-transactional_loads"}, {"score": 0.0032143649757754595, "phrase": "partially_completed_transaction"}, {"score": 0.0031062294139798273, "phrase": "existing_language"}, {"score": 0.003086961663712383, "phrase": "memory_model"}, {"score": 0.003039311963787733, "phrase": "prohibitive_performance_overhead"}, {"score": 0.002777055546998579, "phrase": "customized_barriers"}, {"score": 0.002759823989317719, "phrase": "accelerated_execution"}, {"score": 0.0026835920552084488, "phrase": "expected_pattern"}, {"score": 0.00265038878247831, "phrase": "hot_swap"}, {"score": 0.0026013505538490223, "phrase": "hypothesized_pattern"}, {"score": 0.0025137856138000014, "phrase": "optimization_hypotheses"}, {"score": 0.0024904187737391807, "phrase": "verification_cost"}, {"score": 0.0024216102875733027, "phrase": "dynamic_barrier_optimization"}, {"score": 0.0023767948946074547, "phrase": "bytecode-rewriting_java_stm._feedback-directed_customization"}, {"score": 0.0021783541405925766, "phrase": "dynamic_optimization"}, {"score": 0.0021580985506699105, "phrase": "multi-threaded_transactional_benchmark"}, {"score": 0.002131383155056741, "phrase": "weakly-isolated_execution"}, {"score": 0.0021049977753042253, "phrase": "strongly-isolated_execution"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " Languages", " Measurement", " Performance", " Transactional Memory", " Strong Isolation", " Weak Isolation", " Hot Swap", " Bytecode Rewriting", " Deoptimization"], "paper_abstract": "Speed improvements in today's processors have largely been delivered in the form of multiple cores, increasing the importance of abstractions that ease parallel programming. Software transactional memory (STM) addresses many of the complications of concurrency by providing a simple and composable model for safe access to shared data structures. Software transactions extend a language with an atomic primitive that declares that the effects of a block of code should not be interleaved with actions executing concurrently on other threads. Adding barriers to shared memory accesses provides atomicity, consistency and isolation. Strongly isolated STMs preserve the safety properties of transactions for all memory operations in a program, not just those inside an atomic block. Isolation barriers are added to non-transactional loads and stores in such a system to prevent those accesses from observing or corrupting a partially completed transaction. Strong isolation is especially important when integrating transactions into an existing language and memory model. Isolation barriers have a prohibitive performance overhead, however, so most STM proposals have chosen not to provide strong isolation. In this paper we reduce the costs of strong isolation by customizing isolation barriers for their observed usage. The customized barriers provide accelerated execution by blocking threads whose accesses do not follow the expected pattern. We use hot swap to tighten or loosen the hypothesized pattern, while preserving strong isolation. We introduce a family of optimization hypotheses that balance verification cost against generality. We demonstrate the feasibility of dynamic barrier optimization by implementing it in a bytecode-rewriting Java STM. Feedback-directed customization reduces the overhead of strong isolation from 505% to 38% across 11 non-transactional benchmarks; persistent feedback data further reduces the overhead to 16%. Dynamic optimization accelerates a multi-threaded transactional benchmark by 31% for weakly-isolated execution and 34% for strongly-isolated execution.", "paper_title": "Feedback-Directed Barrier Optimization in a Strongly Isolated STM", "paper_id": "WOS:000272013800020"}