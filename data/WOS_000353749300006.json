{"auto_keywords": [{"score": 0.04436828137594863, "phrase": "cere"}, {"score": 0.007746872402509793, "phrase": "code_isolation"}, {"score": 0.006743191307638641, "phrase": "original_application"}, {"score": 0.00481495049065317, "phrase": "llvm-based_code"}, {"score": 0.004694700982410345, "phrase": "piecewise_benchmarking"}, {"score": 0.004067635935640407, "phrase": "isolated_fragments"}, {"score": 0.003660452313567116, "phrase": "benchmarking_cost"}, {"score": 0.0036144035798673967, "phrase": "piecewise_optimization"}, {"score": 0.0035240305920962766, "phrase": "previous_approaches"}, {"score": 0.003349984456443527, "phrase": "language_agnostic"}, {"score": 0.0032115323992013773, "phrase": "fortran"}, {"score": 0.0031710903727066313, "phrase": "d._cere"}, {"score": 0.003131178497790961, "phrase": "codelets_invocations"}, {"score": 0.0029890721584351684, "phrase": "reduced_set"}, {"score": 0.0029639342245188203, "phrase": "representative_codelets"}, {"score": 0.00266693888510356, "phrase": "extracted_codelets"}, {"score": 0.0025674490885184173, "phrase": "cross-architecture_performance_prediction"}, {"score": 0.0023794391656001466, "phrase": "execution_time"}, {"score": 0.0023395610923736595, "phrase": "cere_codelets"}, {"score": 0.0023100907305651872, "phrase": "realistic_study"}, {"score": 0.0022522565004588113, "phrase": "nas_benchmarks"}, {"score": 0.002195866991284673, "phrase": "architecture_performance"}, {"score": 0.0021049977753042253, "phrase": "full_benchmark"}], "paper_keywords": ["Performance", " Measurement", " Program replay", " checkpoint restart", " iterative optimization", " performance prediction"], "paper_abstract": "This article presents Code let Extractor and REplayer (CERE), an open-source framework for code isolation. CERE finds and extracts the hotspots of an application as isolated fragments of code, called codelets. Codelets can be modified, compiled, run, and measured independently from the original application. Code isolation reduces benchmarking cost and allows piecewise optimization of an application. Unlike previous approaches, CERE isolates codes at the compiler Intermediate Representation (IR) level. Therefore CERE is language agnostic and supports many input languages such as C, C++, Fortran, and D. CERE automatically detects codelets invocations that have the same performance behavior. Then, it selects a reduced set of representative codelets and invocations, much faster to replay, which still captures accurately the original application. In addition, CERE supports recompiling and retargeting the extracted codelets. Therefore, CERE can be used for cross-architecture performance prediction or piecewise code optimization. On the SPEC 2006 FP benchmarks, CERE codelets cover 90.9% and accurately replay 66.3% of the execution time. We use CERE codelets in a realistic study to evaluate three different architectures on the NAS benchmarks. CERE accurately estimates each architecture performance and is 7.3x to 46.6x cheaper than running the full benchmark.", "paper_title": "CERE: LLVM-Based Code let Extractor and REplayer for Piecewise Benchmarking and Optimization", "paper_id": "WOS:000353749300006"}