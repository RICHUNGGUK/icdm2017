{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "linear_recursive_queries"}, {"score": 0.03491695658737417, "phrase": "duplicate_elimination"}, {"score": 0.026369545366370917, "phrase": "complete_graphs"}, {"score": 0.0047689174754929195, "phrase": "sql._recursion"}, {"score": 0.0047006879240764935, "phrase": "fundamental_computation_mechanism"}, {"score": 0.004545240514015278, "phrase": "sql_language"}, {"score": 0.004311241567238011, "phrase": "sql._query"}, {"score": 0.0041287394089001405, "phrase": "transitive_closure"}, {"score": 0.003992129945230457, "phrase": "power_matrix"}, {"score": 0.003878625406105021, "phrase": "sql_implementations"}, {"score": 0.0037322713756404295, "phrase": "five_query_optimizations"}, {"score": 0.0033900126423990823, "phrase": "nonrecursive_joins"}, {"score": 0.003138874040786261, "phrase": "evaluation_algorithms"}, {"score": 0.0030058503645435455, "phrase": "large_input_tables"}, {"score": 0.0026395715432958665, "phrase": "worst_case"}, {"score": 0.0025767987652419054, "phrase": "seminaive"}, {"score": 0.00236289633510808, "phrase": "aggregation_work"}, {"score": 0.002125371638869951, "phrase": "acyclic_graphs"}, {"score": 0.0021049977753042253, "phrase": "early_selection"}], "paper_keywords": ["Recursive query", " SQL", " query optimization", " transitive closure"], "paper_abstract": "Recursion is a fundamental computation mechanism which has been incorporated into the SQL language. This work focuses on the optimization of linear recursive queries in SQL. Query optimization is studied with two important graph problems: computing the transitive closure of a graph and getting the power matrix of its adjacency matrix. We present SQL implementations for two fundamental algorithms: Seminaive and Direct. Five query optimizations are studied: 1) Storage and indexing; 2) early selection; 3) early evaluation of nonrecursive joins; 4) pushing duplicate elimination; and 5) pushing aggregation. Experiments compare both evaluation algorithms and systematically evaluate the impact of optimizations with large input tables. Optimizations are evaluated on four types of graphs: binary trees, lists, cyclic graphs, and complete graphs, going from the best to worst case. In general, Seminaive is faster than Direct, except for complete graphs. Storing and indexing rows by vertex and pushing aggregation work well on trees, lists, and cyclic graphs. Pushing duplicate elimination is essential for complete graphs, but slows computation for acyclic graphs. Early selection with equality predicates significantly accelerates computation for all types of graphs.", "paper_title": "Optimization of Linear Recursive Queries in SQL", "paper_id": "WOS:000272838500008"}