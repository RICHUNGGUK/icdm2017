{"auto_keywords": [{"score": 0.02875806215342705, "phrase": "critical_sections"}, {"score": 0.00481495049065317, "phrase": "multitask_vlsi_systems"}, {"score": 0.004770211811866158, "phrase": "task_preemption"}, {"score": 0.004703878334423852, "phrase": "critical_enabling_mechanism"}, {"score": 0.00466016686289196, "phrase": "multitask_very_large_scale_integration"}, {"score": 0.004616885764412798, "phrase": "vlsi"}, {"score": 0.004406260054779782, "phrase": "register_files"}, {"score": 0.004146716743362567, "phrase": "extra_memory"}, {"score": 0.004032118497047498, "phrase": "additional_clock_cycles"}, {"score": 0.0037242701420971062, "phrase": "micropreemption_constraints"}, {"score": 0.003689628075766217, "phrase": "multitask_vlsi_system_synthesis"}, {"score": 0.003504756881063581, "phrase": "preemption_points"}, {"score": 0.003472149546470424, "phrase": "scheduled_task_graphs"}, {"score": 0.0034238045290210534, "phrase": "preemption_latency_constraints"}, {"score": 0.003329117824699891, "phrase": "context_switch_overhead"}, {"score": 0.0032674478600540477, "phrase": "dedicated_registers"}, {"score": 0.0030747771905143273, "phrase": "shared_registers"}, {"score": 0.003003726508522467, "phrase": "remaining_values"}, {"score": 0.0029069972482610403, "phrase": "controller-based_scheme"}, {"score": 0.002853124436286832, "phrase": "preemption-related_performance_degradation"}, {"score": 0.002311525062244175, "phrase": "software_implementations"}, {"score": 0.0022686625017583387, "phrase": "real_examples"}, {"score": 0.002154835714714195, "phrase": "functional_simulation"}, {"score": 0.0021049977753042253, "phrase": "layout_implementation"}], "paper_keywords": ["context switch overhead", " critical section", " micro-preemption", " multitask VLSI systems", " preemption latency", " rolling forward"], "paper_abstract": "Task preemption is a critical enabling mechanism in multitask very large scale integration (VLSI) systems. On preemption, data in the register files must be preserved for the task to be resumed. This entails extra memory to preserve the context and additional clock cycles to save and restore the context. In this paper, techniques and algorithms to incorporate micropreemption constraints during multitask VLSI system synthesis are presented. Specifically, algorithms to insert and refine preemption points in scheduled task graphs subject to preemption latency constraints, techniques to minimize the context switch overhead by considering the dedicated registers required to save the state of a task on preemption and the shared registers required to save the remaining values in the tasks, and a controller-based scheme to preclude the preemption-related performance degradation by: 1) partitioning the states of task into critical sections; 2) executing the critical sections atomically; and 3) preserving atomicity by rolling forward to the end of the critical sections on preemption have been developed. The effectiveness of all approaches, algorithms, and software implementations is demonstrated on real examples. Validation of all the results is complete in the sense that functional simulation is conducted to complete layout implementation.", "paper_title": "Micropreemption synthesis: An enabling mechanism for multitask VLSI systems", "paper_id": "WOS:000234307000003"}