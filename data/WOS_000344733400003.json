{"auto_keywords": [{"score": 0.0404616772403515, "phrase": "scheduling_mechanism"}, {"score": 0.00481495049065317, "phrase": "model-to-model_transformations"}, {"score": 0.00456571874088313, "phrase": "model-driven_engineering"}, {"score": 0.004413846562278824, "phrase": "diverse_kinds"}, {"score": 0.0043713857434347254, "phrase": "model_manipulations"}, {"score": 0.004329331617724, "phrase": "transformation_scheduling"}, {"score": 0.004267004541988167, "phrase": "key_issue"}, {"score": 0.00393032656248792, "phrase": "underlying_technique"}, {"score": 0.0037811784409635023, "phrase": "data_dependence"}, {"score": 0.003744780941673966, "phrase": "transformation_rules"}, {"score": 0.0035679633126097115, "phrase": "proof-of-concept_model_transformation_language"}, {"score": 0.0032546105164772995, "phrase": "current_model_transformation_languages"}, {"score": 0.0030414140732789186, "phrase": "model_transformations"}, {"score": 0.002801166393333128, "phrase": "scheduling_algorithm"}, {"score": 0.0027209713296448296, "phrase": "lazy_resolution"}, {"score": 0.0026175952455594277, "phrase": "collection_operations"}, {"score": 0.002469830206270585, "phrase": "java_virtual_machine"}, {"score": 0.0023990982005125763, "phrase": "performance_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["model-to-model transformation", " transformation scheduling", " transformation algorithm"], "paper_abstract": "Model transformations are at the heart of model-driven engineering because they allow the automation of diverse kinds of model manipulations. Transformation scheduling is a key issue in the design and implementation of many transformation languages. This paper reports our results using continuations as the underlying technique for building a scheduling mechanism implicitly driven by data dependence among transformation rules. To support our experiments, we have built a proof-of-concept model transformation language, which is also reported here. First, we motivate the problem by analyzing the scheduling mechanism of current model transformation languages. Then, we introduce the notion of continuation, showing its applicability to model transformations. Afterwards, we present our approach, notably explaining how dependence is specified and giving the scheduling algorithm. We also analyze the lazy resolution of rules and how to deal with collection operations. The approach is validated by an implementation that targets the Java Virtual Machine and by running of the performance benchmarks that show its efficiency and scalability. Besides, we discuss how it can be applied to other existing transformation languages and present several applicability scenarios. Copyright (C) 2013 John Wiley & Sons, Ltd.", "paper_title": "Scheduling model-to-model transformations with continuations", "paper_id": "WOS:000344733400003"}