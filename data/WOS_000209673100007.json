{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "design_patterns"}, {"score": 0.0422978679900886, "phrase": "open-source_libraries"}, {"score": 0.036745787063818064, "phrase": "source_code"}, {"score": 0.004756805752518494, "phrase": "program_code"}, {"score": 0.004558748120167778, "phrase": "reusing_software"}, {"score": 0.0043161190928529755, "phrase": "legacy_code"}, {"score": 0.004086350434865782, "phrase": "core_code"}, {"score": 0.003685067218455088, "phrase": "informative_api_documentation"}, {"score": 0.003640516896245813, "phrase": "reliable_design_information"}, {"score": 0.003384262486955773, "phrase": "sole_reliable_source"}, {"score": 0.0033029038236817372, "phrase": "program_understanding_activities"}, {"score": 0.0031269043024513567, "phrase": "reverse-engineering_approach"}, {"score": 0.0029602552900111407, "phrase": "understanding_software"}, {"score": 0.0029066973917258655, "phrase": "automatic_recovery"}, {"score": 0.0028715299874549245, "phrase": "hidden_design_patterns"}, {"score": 0.0028367868542874737, "phrase": "software_libraries"}, {"score": 0.002735052488172277, "phrase": "ontology_formalism"}, {"score": 0.002669259222649505, "phrase": "conceptual_knowledge"}, {"score": 0.0025892330566358503, "phrase": "semantic_rules"}, {"score": 0.002264607102799332, "phrase": "evaluation_results"}, {"score": 0.0022236070278432575, "phrase": "effective_and_flexible_detection"}, {"score": 0.0021049977753042253, "phrase": "hard-coded_heuristics"}], "paper_keywords": ["Design patterns", " Design recovery", " Software maintenance", " Ontology formalisms", " Knowledge representation", " Semantic inference"], "paper_abstract": "The process of understanding and reusing software is often time-consuming, especially in legacy code and open-source libraries. While some core code of open-source libraries may be well-documented, it is frequently the case that open-source libraries lack informative API documentation and reliable design information. As a result, the source code itself is often the sole reliable source of information for program understanding activities. In this article, we propose a reverse-engineering approach that can provide assistance during the process of understanding software through the automatic recovery of hidden design patterns in software libraries. Specifically, we use ontology formalism to represent the conceptual knowledge of the source code and semantic rules to capture the structures and behaviors of the design patterns in the libraries. Several software libraries were examined with this approach and the evaluation results show that effective and flexible detection of design patterns can be achieved without using hard-coded heuristics.", "paper_title": "Rule-based detection of design patterns in program code", "paper_id": "WOS:000209673100007"}