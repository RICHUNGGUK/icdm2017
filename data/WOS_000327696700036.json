{"auto_keywords": [{"score": 0.0465140947795524, "phrase": "modular_verification"}, {"score": 0.037775038986786684, "phrase": "granularity_abstraction"}, {"score": 0.00481495049065317, "phrase": "hoare-style_reasoning"}, {"score": 0.004632597963417253, "phrase": "higher-order_concurrency"}, {"score": 0.003674192201248236, "phrase": "reusable_components"}, {"score": 0.0033228699494959172, "phrase": "fine-grained_concurrent_data_structures"}, {"score": 0.00317221667574882, "phrase": "data_structures"}, {"score": 0.002913483929932102, "phrase": "first_logic"}, {"score": 0.0026965813247045427, "phrase": "higher-order_concurrent_programs"}, {"score": 0.0024574537875026634, "phrase": "illustrative_examples"}, {"score": 0.0022568866348667547, "phrase": "significant_case_study"}, {"score": 0.0021049977753042253, "phrase": "hendler_et_al"}], "paper_keywords": ["Contextual refinement", " higher-order functions", " fine-grained concurrency", " separation logic", " Kripke logical relations"], "paper_abstract": "Modular programming and modular verification go hand in hand, but most existing logics for concurrency ignore two crucial forms of modularity: higher-order functions, which are essential for building reusable components, and granularity abstraction, a key technique for hiding the intricacies of fine-grained concurrent data structures from the clients of those data structures. In this paper, we present CaReSL, the first logic to support the use of granularity abstraction for modular verification of higher-order concurrent programs. After motivating the features of CaReSL through a variety of illustrative examples, we demonstrate its effectiveness by using it to tackle a significant case study: the first formal proof of (partial) correctness for Hendler et al.'s \"flat combining\" algorithm.", "paper_title": "Unifying Refinement and Hoare-Style Reasoning in a Logic for Higher-Order Concurrency", "paper_id": "WOS:000327696700036"}