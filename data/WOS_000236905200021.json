{"auto_keywords": [{"score": 0.015719718815762243, "phrase": "jni."}, {"score": 0.013063770916279702, "phrase": "string_constants"}, {"score": 0.004721162131188487, "phrase": "multi-lingual_type_inference_system"}, {"score": 0.004494570360108983, "phrase": "java_native_interface"}, {"score": 0.004363847983315585, "phrase": "jni"}, {"score": 0.004321118442104989, "phrase": "specially-formatted_strings"}, {"score": 0.004257806363128601, "phrase": "class_and_field_names"}, {"score": 0.004174824849669107, "phrase": "method_signatures"}, {"score": 0.003858697684681798, "phrase": "string_variables"}, {"score": 0.0035141291835319682, "phrase": "structured_types"}, {"score": 0.0034118234596993836, "phrase": "restricted_form"}, {"score": 0.003378385493203297, "phrase": "dependent_types"}, {"score": 0.0032800186243040663, "phrase": "type_signatures"}, {"score": 0.0030017207229983385, "phrase": "user-defined_functions"}, {"score": 0.002928682556953258, "phrase": "java_type_strings"}, {"score": 0.0028154895878702633, "phrase": "common_practice"}, {"score": 0.00266693888510356, "phrase": "instantiation_constraints"}, {"score": 0.002576503437739865, "phrase": "function_calls"}, {"score": 0.002416589459425828, "phrase": "small_set"}, {"score": 0.002125859121671525, "phrase": "suspicious_programming_practices"}], "paper_keywords": [""], "paper_abstract": "We present a multi-lingual type inference system for checking type safety of programs that use the Java Native Interface (JNI). The JNI uses specially-formatted strings to represent class and field names as well as method signatures, and so our type system tracks the flow of string constants through the program. Our system embeds string variables in types, and as those variables are resolved to string constants during inference they are replaced with the structured types the constants represent. This restricted form of dependent types allows us to directly assign type signatures to each of the more than 200 functions in the JNI. Moreover, it allows us to infer types for user-defined functions that are parameterized by Java type strings, which we have found to be common practice. Our inference system allows such functions to be treated polymorphically by using instantiation constraints, solved with semi-unification, at function calls. Finally, we have implemented our system and applied it to a small set of benchmarks. Although semi-unification is undecidable, we found our system to be scalable and effective in practice. We discovered 155 errors and 36 cases of suspicious programming practices in our benchmarks.", "paper_title": "Polymorphic type inference for the JNI", "paper_id": "WOS:000236905200021"}