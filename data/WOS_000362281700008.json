{"auto_keywords": [{"score": 0.04545268006893582, "phrase": "pcm"}, {"score": 0.011741714316632292, "phrase": "undo-redo_logging"}, {"score": 0.00481495049065317, "phrase": "computer_systems"}, {"score": 0.004519543557571175, "phrase": "new_generation"}, {"score": 0.0044910139920501515, "phrase": "non-volatile_memory"}, {"score": 0.0043786774510943625, "phrase": "phase_change_memory"}, {"score": 0.00430989426244921, "phrase": "stt-mram"}, {"score": 0.004269162593990302, "phrase": "memristor"}, {"score": 0.004228768988306315, "phrase": "non-volatility_property"}, {"score": 0.004109926210263146, "phrase": "data_structures"}, {"score": 0.004083971741538933, "phrase": "instantaneous_failure_recovery"}, {"score": 0.00398177607914381, "phrase": "careful_design"}, {"score": 0.00393163747242631, "phrase": "in-memory_data_structures"}, {"score": 0.003894446653225716, "phrase": "known_consistent_states"}, {"score": 0.0036785473375981533, "phrase": "database_and_data-intensive_systems"}, {"score": 0.0034526191487098093, "phrase": "drastic_performance_overhead"}, {"score": 0.003419943984098415, "phrase": "extensive_nvm"}, {"score": 0.0033876606312095016, "phrase": "cpu"}, {"score": 0.0033661687998511737, "phrase": "flush_operations"}, {"score": 0.00332375606483146, "phrase": "unsorted_leaf_nodes"}, {"score": 0.003240521834737935, "phrase": "remaining_overhead"}, {"score": 0.003060763239325022, "phrase": "new_type"}, {"score": 0.0029001301231553005, "phrase": "small_indirect_slot_array"}, {"score": 0.0027653910844724237, "phrase": "index_entries"}, {"score": 0.0026875632003075804, "phrase": "node_consistency"}, {"score": 0.002662109089955643, "phrase": "atomic_writes"}, {"score": 0.0026036473098881344, "phrase": "-only_logging"}, {"score": 0.0025626757094623755, "phrase": "nvm"}, {"score": 0.002546470093646162, "phrase": "dram"}, {"score": 0.002522344964242888, "phrase": "real_machine"}, {"score": 0.0024747842618794255, "phrase": "cycle-accurate_simulator"}, {"score": 0.0023522840272302507, "phrase": "dram-like_fast_nvm"}, {"score": 0.0022572213326336374, "phrase": "good_search_performance"}, {"score": 0.0022146486355422244, "phrase": "memcached's_internal_hash_index"}, {"score": 0.0021728771392034462, "phrase": "memcached"}, {"score": 0.0021049977753042253, "phrase": "previous_persistent_tree_structures"}], "paper_keywords": [""], "paper_abstract": "Computer systems in the near future are expected to have Non-Volatile Main Memory (NVMM), enabled by a new generation of Non-Volatile Memory (NVM) technologies, such as Phase Change Memory (PCM), STT-MRAM, and Memristor. The non-volatility property has the promise to persist in-memory data structures for instantaneous failure recovery. However, realizing such promise requires a careful design to ensure that in-memory data structures are in known consistent states after failures. This paper studies persistent in-memory B+-Trees as B+-Trees are widely used in database and data-intensive systems. While traditional techniques, such as undo-redo logging and shadowing, support persistent B+-Trees, we find that they incur drastic performance overhead because of extensive NVM writes and CPU cache flush operations. PCM-friendly B+-Trees with unsorted leaf nodes help mediate this issue, but the remaining overhead is still large. In this paper, we propose write atomic B+-Trees (wB(+)-Trees), a new type of main-memory B+-Trees, that aim to reduce such overhead as much as possible. wB(+)-Tree nodes employ a small indirect slot array and/or a bitmap so that most insertions and deletions do not require the movement of index entries. In this way, wB(+)Trees can achieve node consistency either through atomic writes in the nodes or by redo-only logging. We model fast NVM using DRAM on a real machine and model PCM using a cycle-accurate simulator. Experimental results show that compared with previous persistent B+-Tree solutions, wB(+)-Trees achieve up to 8.8x speedups on DRAM-like fast NVM and up to 27.1x speedups on PCM for insertions and deletions while maintaining good search performance. Moreover, we replaced Memcached's internal hash index with tree indices. Our real machine Memcached experiments show that wB(+)-Trees achieve up to 3.8X improvements over previous persistent tree structures with undo-redo logging or shadowing.", "paper_title": "Persistent B+ - Trees in Non-Volatile Main Memory", "paper_id": "WOS:000362281700008"}