{"auto_keywords": [{"score": 0.024117201152177706, "phrase": "kalai"}, {"score": 0.009848336385059211, "phrase": "feige"}, {"score": 0.00481495049065317, "phrase": "weak_client"}, {"score": 0.004661116930794176, "phrase": "untrusted_server"}, {"score": 0.004274396662662802, "phrase": "computational_inefficiency"}, {"score": 0.004122850924351265, "phrase": "high_round_complexity"}, {"score": 0.004063741692442559, "phrase": "relatively_efficient_and_general_solutions"}, {"score": 0.0038356264368681107, "phrase": "correct_answer"}, {"score": 0.0037806195039533355, "phrase": "even_a_single_server"}, {"score": 0.0036862417490612673, "phrase": "refereed_delegation_of_computation"}, {"score": 0.003536815735776182, "phrase": "goldwasser"}, {"score": 0.0034918342672996066, "phrase": "efficiently_computable_function"}, {"score": 0.0034541965053691307, "phrase": "logarithmically_many_rounds"}, {"score": 0.003392363211686023, "phrase": "collision-resistant_hash_family"}, {"score": 0.003190265467214105, "phrase": "turing_machine"}, {"score": 0.0031056197235885146, "phrase": "rothblum"}, {"score": 0.00296781730323553, "phrase": "prototype_implementation"}, {"score": 0.0029358111718032704, "phrase": "quin"}, {"score": 0.0029041492019217033, "phrase": "windows_executables"}, {"score": 0.0028149282136550008, "phrase": "kilian"}, {"score": 0.0027708353425467927, "phrase": "live_cloud_servers"}, {"score": 0.002643624979574088, "phrase": "real-world_cloud_servers"}, {"score": 0.0024591984725764932, "phrase": "log-space_uniform_nc_circuit"}, {"score": 0.0023977287074829798, "phrase": "single_server"}, {"score": 0.0023718560142554634, "phrase": "known_one-round_delegation_protocols"}, {"score": 0.0022958971655679832, "phrase": "arithemetization_techniques"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Refereed Games", " Verifiable Computation", " Delegation of Computation"], "paper_abstract": "Consider a weak client that wishes to delegate a computation to an untrusted server, and then verify the correctness of the result. When the client uses only a single untrusted server, current techniques suffer from disadvantages such as computational inefficiency for the client or the server, limited functionality, or high round complexity. We demonstrate relatively efficient and general solutions where the client delegates the computation to several servers, and is guaranteed to determine the correct answer as long as even a single server is honest. We call such protocols Refereed Delegation of Computation (RDoC) and show: 1. A computationally secure protocol for any efficiently computable function, with logarithmically many rounds, based on any collision-resistant hash family. In our description of this protocol, we model the computation as running on a Turing Machine, but the protocol can be adapted to other computation models. We present an adaptation for the X86 computation model and a prototype implementation, called Quin, for Windows executables. We describe the architecture of Quin and experiment with several parameters on live cloud servers. We show that the protocol is practical, can work with real-world cloud servers, and is efficient for both the servers and for the client 2. A 1-round statistically secure protocol for any log-space uniform NC circuit. In contrast, in the single server setting all known one-round delegation protocols are computationally sound. The protocol extends the arithemetization techniques of Goldwasser, Kalai and Rothblum (STOC 08) and Feige and Kilian (STOC 97). (C) 2013 Elsevier Inc. All rights reserved.", "paper_title": "Refereed delegation of computation", "paper_id": "WOS:000318263000003"}