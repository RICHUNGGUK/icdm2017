{"auto_keywords": [{"score": 0.0445963668867301, "phrase": "mesh_update"}, {"score": 0.032186640943925496, "phrase": "high_probability"}, {"score": 0.006620269555802643, "phrase": "vertical_bar_log"}, {"score": 0.005853501304506013, "phrase": "in-order_traversal"}, {"score": 0.00481495049065317, "phrase": "physical_space"}, {"score": 0.0047941691087656, "phrase": "regularly-shaped_regions"}, {"score": 0.0046814569312295115, "phrase": "finite-element_methods"}, {"score": 0.004654779963297256, "phrase": "decomposition_tree"}, {"score": 0.004631099806015235, "phrase": "collision_detection"}, {"score": 0.004601144706752023, "phrase": "n-body_simulations"}, {"score": 0.0043213410601860985, "phrase": "neighboring_vertices"}, {"score": 0.004129362841119001, "phrase": "mesh_layout"}, {"score": 0.004111528238547658, "phrase": "good_data_locality"}, {"score": 0.0038447018470115146, "phrase": "memory_layout"}, {"score": 0.003786879320080677, "phrase": "asymptotically_optimal_memory_performance"}, {"score": 0.00374610869916551, "phrase": "memory_parameters"}, {"score": 0.0036264021538594685, "phrase": "sequential_memory_scan"}, {"score": 0.003525744120930142, "phrase": "d-dimensional_mesh"}, {"score": 0.003465189575252443, "phrase": "cache_size"}, {"score": 0.003296807590794503, "phrase": "mesh-update_performance"}, {"score": 0.003275454623236867, "phrase": "smaller_caches"}, {"score": 0.003177615880037735, "phrase": "cache-oblivious_mesh_layouts"}, {"score": 0.00315703245547973, "phrase": "first_layout_algorithm"}, {"score": 0.002766171878646582, "phrase": "cache-oblivious_and_disk-access_machine"}, {"score": 0.002689326806831584, "phrase": "fully_balanced_decomposition_tree"}, {"score": 0.0025976649270850393, "phrase": "second_algorithm"}, {"score": 0.0025808284847319528, "phrase": "cache-oblivious_layout"}, {"score": 0.0025641483350747887, "phrase": "ram"}, {"score": 0.002407879390828326, "phrase": "dam"}, {"score": 0.0023974563359295043, "phrase": "cache-oblivious_models"}, {"score": 0.002381914421788877, "phrase": "second_layout_algorithm"}, {"score": 0.0021141471146929806, "phrase": "new_type"}], "paper_keywords": ["Cache-oblivious", " Decomposition tree", " Fully-balanced decomposition tree", " Geometric separator", " Mesh layout", " Relax-balanced decomposition tree"], "paper_abstract": "A mesh is a graph that divides physical space into regularly-shaped regions. Meshes computations form the basis of many applications, including finite-element methods, image rendering, collision detection, and N-body simulations. In one important mesh primitive, called a mesh update, each mesh vertex stores a value and repeatedly updates this value based on the values stored in all neighboring vertices. The performance of a mesh update depends on the layout of the mesh in memory. Informally, if the mesh layout has good data locality (most edges connect a pair of nodes that are stored near each other in memory), then a mesh update runs quickly. This paper shows how to find a memory layout that guarantees that the mesh update has asymptotically optimal memory performance for any set of memory parameters. Specifically, the cost of the mesh update is roughly the cost of a sequential memory scan. Such a memory layout is called cache-oblivious. Formally, for a d-dimensional mesh G, block size B, and cache size M (where M=Omega(B(d))), the mesh update of G uses O(1+vertical bar G vertical bar/B) memory transfers. The paper also shows how the mesh-update performance degrades for smaller caches, where M=o(B(d)). The paper then gives two algorithms for finding cache-oblivious mesh layouts. The first layout algorithm runs in time O(vertical bar G vertical bar log (2)vertical bar G vertical bar) both in expectation and with high probability on a RAM. It uses O(1+vertical bar G vertical bar log (2)(vertical bar G vertical bar/M)/B) memory transfers in expectation and O(1+(vertical bar G vertical bar/B)(log (2)(vertical bar G vertical bar/M)+log vertical bar G vertical bar)) memory transfers with high probability in the cache-oblivious and disk-access machine (DAM) models. The layout is obtained by finding a fully balanced decomposition tree of G and then performing an in-order traversal of the leaves of the tree. The second algorithm computes a cache-oblivious layout on a RAM in time O(vertical bar G vertical bar log vertical bar G vertical bar log log vertical bar G vertical bar) both in expectation and with high probability. In the DAM and cache-oblivious models, the second layout algorithm uses O(1+(vertical bar G vertical bar/B) log (vertical bar G vertical bar/M)min {log log vertical bar G vertical bar,log (vertical bar G vertical bar/M)}) memory transfers in expectation and O(1+(vertical bar G vertical bar/B)(log (vertical bar G vertical bar/M)min {log log vertical bar G vertical bar,log (vertical bar G vertical bar/M)}+log vertical bar G vertical bar)) memory transfers with high probability. The algorithm is based on a new type of decomposition tree, here called a relax-balanced decomposition tree. Again, the layout is obtained by performing an in-order traversal of the leaves of the decomposition tree.", "paper_title": "Optimal Cache-Oblivious Mesh Layouts", "paper_id": "WOS:000286388100002"}