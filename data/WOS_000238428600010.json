{"auto_keywords": [{"score": 0.03461617249114157, "phrase": "first_stage"}, {"score": 0.0333191910239342, "phrase": "second_stage"}, {"score": 0.00481495049065317, "phrase": "object_caching"}, {"score": 0.004767826806287385, "phrase": "modern_applications"}, {"score": 0.004450568197899267, "phrase": "tremendous_functionality"}, {"score": 0.004299910946753963, "phrase": "significant_computational_power"}, {"score": 0.004033464035028803, "phrase": "caching_objects"}, {"score": 0.003935420482629049, "phrase": "popular_way"}, {"score": 0.0037834649508375544, "phrase": "available_memory"}, {"score": 0.003531474887552889, "phrase": "enterprise_application_object"}, {"score": 0.0033288399506044763, "phrase": "two-stage_process"}, {"score": 0.003091767402370757, "phrase": "object_instances"}, {"score": 0.002943147037670826, "phrase": "replacement_policy"}, {"score": 0.0025262061502713683, "phrase": "current_systems"}, {"score": 0.0024891269874339553, "phrase": "critical_step"}, {"score": 0.002428530921948425, "phrase": "ad_hoc_manner"}, {"score": 0.0023694065215394593, "phrase": "nonlinear_mathematical_model"}, {"score": 0.0022890371899188466, "phrase": "feasible_solution_procedure"}, {"score": 0.002255431275670053, "phrase": "genetic_algorithms"}, {"score": 0.0021682027434117095, "phrase": "solution_quality"}, {"score": 0.002146926767291475, "phrase": "lower_bounds"}, {"score": 0.0021049977753042253, "phrase": "lagrangian-relaxation-based_method"}], "paper_keywords": ["caching", " heuristics", " genetic algorithms", " Lagrangian relaxation"], "paper_abstract": "Modern applications are built using object-oriented (OO) principles. Unfortunately, OO technologies, though they add tremendous functionality and flexibility to applications, require significant computational power, which greatly affects the performance and scalability of the applications. Caching objects in memory is a popular way to solve this problem, but the available memory in systems is limited and not sufficient to store each instance of every enterprise application object. Deciding which instances of which objects should be cached is a two-stage process. The first stage is selecting the objects, and the second stage is selecting the object instances. The second stage, typically referred to as a replacement policy, occurs at run-time and has been widely studied. The focus of this paper is the first stage: selecting objects whose instances are candidates for caching at run-time. In current systems, this critical step is performed in an ad hoc manner. We build a nonlinear mathematical model for this problem, develop a feasible solution procedure based on genetic algorithms, and demonstrate its effectiveness by comparing the solution quality to lower bounds obtained using a Lagrangian-relaxation-based method.", "paper_title": "Optimization in object caching", "paper_id": "WOS:000238428600010"}