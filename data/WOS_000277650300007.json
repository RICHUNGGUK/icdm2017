{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "k-nearest_neighbor_graphs"}, {"score": 0.004437613070853689, "phrase": "parallel_algorithm"}, {"score": 0.004347972379250724, "phrase": "k-nearest_neighbor_graph_construction"}, {"score": 0.004216899525688673, "phrase": "morton"}, {"score": 0.003769006950727621, "phrase": "existing_methods"}, {"score": 0.0033685408148574846, "phrase": "multicore_machines"}, {"score": 0.003010496595090984, "phrase": "large_data_sets"}, {"score": 0.002690406375639144, "phrase": "point_set"}, {"score": 0.002453934333239467, "phrase": "one-comparison-based_parallel_sort"}, {"score": 0.0023079225317714815, "phrase": "morton_order"}, {"score": 0.0021928902836049384, "phrase": "additional_steps"}, {"score": 0.0021049977753042253, "phrase": "k-nearest_neighbor_graph"}], "paper_keywords": ["Nearest neighbor searching", " point-based graphics", " k-nearest neighbor graphics", " Morton ordering", " parallel algorithms"], "paper_abstract": "We present a parallel algorithm for k-nearest neighbor graph construction that uses Morton ordering. Experiments show that our approach has the following advantages over existing methods: 1) faster construction of k-nearest neighbor graphs in practice on multicore machines, 2) less space usage, 3) better cache efficiency, 4) ability to handle large data sets, and 5) ease of parallelization and implementation. If the point set has a bounded expansion constant, our algorithm requires one-comparison-based parallel sort of points, according to Morton order plus near-linear additional steps to output the k-nearest neighbor graph.", "paper_title": "Fast Construction of k-Nearest Neighbor Graphs for Point Clouds", "paper_id": "WOS:000277650300007"}