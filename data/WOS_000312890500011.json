{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "traditional_r-tree_index_structures"}, {"score": 0.004663533386096864, "phrase": "important_issue"}, {"score": 0.004455409162867219, "phrase": "r-tree_concurrency_control"}, {"score": 0.004335000368745273, "phrase": "aries-based_recovery"}, {"score": 0.004160435626849478, "phrase": "standard_fine-grained_single-version_update_model"}, {"score": 0.003814563533445401, "phrase": "uncommitted_updates"}, {"score": 0.0035945701438887282, "phrase": "structure_modifications"}, {"score": 0.003371773890338284, "phrase": "consistent_and_balanced_state"}, {"score": 0.0029666322924554274, "phrase": "process_failures"}, {"score": 0.0029396242707327986, "phrase": "system_crashes"}, {"score": 0.0028340217672278975, "phrase": "strictly_consistent_state"}, {"score": 0.002782647772219627, "phrase": "bounding_rectangles"}, {"score": 0.0023173287402646577, "phrase": "relaxed_consistency"}, {"score": 0.0023067494372458427, "phrase": "also_the_number"}, {"score": 0.0022857351723674004, "phrase": "simultaneous_nonexclusive_latches"}, {"score": 0.0021049977753042253, "phrase": "logarithmic_insertion-path_length"}], "paper_keywords": ["Multidimensional index structure", " spatial index", " R-tree", " transaction rollback", " partial rollback", " restart recovery", " ARIES", " concurrency control", " structure modification"], "paper_abstract": "We consider the recoverability of traditional R-tree index structures under concurrent updating transactions, an important issue that is neglected or treated inadequately in many proposals of R-tree concurrency control. We present two solutions to ARIES-based recovery of transactions on R-trees. These assume a standard fine-grained single-version update model with physiological write-ahead logging and steal-and-no-force buffering where records with uncommitted updates by a transaction may migrate from their original page to another page due to structure modifications caused by other transactions. Both solutions guarantee that an R-tree will remain in a consistent and balanced state in the presence of any number of concurrent forward-rolling and ( totally or partially) backward-rolling multiaction transactions and in the event of process failures and system crashes. One solution maintains the R-tree in a strictly consistent state in which the bounding rectangles of pages are as tight as possible, while in the other solution this requirement is relaxed. In both solutions only a small constant number of simultaneous exclusive latches ( write latches) are needed, and in the solution that only maintains relaxed consistency also the number of simultaneous nonexclusive latches is similarly limited. In both solutions, deletions are handled uniformly with insertions, and a logarithmic insertion-path length is maintained under all circumstances.", "paper_title": "On the Recovery of R-Trees", "paper_id": "WOS:000312890500011"}