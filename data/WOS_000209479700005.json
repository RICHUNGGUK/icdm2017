{"auto_keywords": [{"score": 0.048254425966030474, "phrase": "bmc"}, {"score": 0.04114842860379787, "phrase": "minimal_length_counterexamples"}, {"score": 0.010694964564988292, "phrase": "incremental_encoding"}, {"score": 0.010146350280325062, "phrase": "bmc."}, {"score": 0.00481495049065317, "phrase": "linear_encodings_of_bounded"}, {"score": 0.004664352260912174, "phrase": "bounded_model_checking"}, {"score": 0.004582722012454012, "phrase": "linear_temporal_logic"}, {"score": 0.0044237033788643715, "phrase": "size_linear"}, {"score": 0.004180663347795228, "phrase": "ltl"}, {"score": 0.004064117897000019, "phrase": "generalised_encoding"}, {"score": 0.004007083686875716, "phrase": "linear_size"}, {"score": 0.00385431710959668, "phrase": "virtual_unrolling_technique"}, {"score": 0.0035659724303237937, "phrase": "virtual_unrolling"}, {"score": 0.0035408501923902477, "phrase": "buchi_automata"}, {"score": 0.003322540556404882, "phrase": "incremental_sat_technology"}, {"score": 0.003287482882222731, "phrase": "fairly_small_modifications"}, {"score": 0.0031845067058084583, "phrase": "termination_check"}, {"score": 0.0030414140732789186, "phrase": "liveness-to-safety_transformation"}, {"score": 0.0029775511937434797, "phrase": "bmc_encodings"}, {"score": 0.002833689453299307, "phrase": "dedicated_bmc_encodings"}, {"score": 0.002813713457836352, "phrase": "pltl"}, {"score": 0.0026682872124177233, "phrase": "invariant_checking"}, {"score": 0.002649473721888472, "phrase": "buchi"}, {"score": 0.0026214978443388653, "phrase": "fair_cycle_detection"}, {"score": 0.0023491282852109757, "phrase": "dedicated_encodings"}, {"score": 0.0022434880661725493, "phrase": "liveness-to-safety_translation"}, {"score": 0.0022276618873985445, "phrase": "bdd-based_invariant_checking_results"}, {"score": 0.0021731423856364003, "phrase": "shortest_counterexamples"}, {"score": 0.0021425882815624803, "phrase": "bmc-based_approach"}, {"score": 0.0021124628548225065, "phrase": "complex_properties"}, {"score": 0.0021049977753042253, "phrase": "bdd-based_methods"}], "paper_keywords": ["Bounded Model Checking", " LTL", " PLTL", " Liveness to Safety", " NuSMV"], "paper_abstract": "We consider the problem of bounded model checking (BMC) for linear temporal logic (LTL). We present several efficient encodings that have size linear in the bound. Furthermore, we show how the encodings can be extended to LTL with past operators (PLTL). The generalised encoding is still of linear size, but cannot detect minimal length counterexamples. By using the virtual unrolling technique minimal length counterexamples can be captured, however, the size of the encoding is quadratic in the specification. We also extend virtual unrolling to Buchi automata, enabling them to accept minimal length counterexamples. Our BMC encodings can be made incremental in order to benefit from incremental SAT technology. With fairly small modifications the incremental encoding can be further enhanced with a termination check, allowing us to prove properties with BMC. An analysis of the liveness-to-safety transformation reveals many similarities to the BMC encodings in this paper. We conduct experiments to determine the advantage of employing dedicated BMC encodings for PLTL over combining more general but potentially less efficient approaches with BMC: the liveness-to-safety transformation with invariant checking and Buchi automata with fair cycle detection. Experiments clearly show that our new encodings improve performance of BMC considerably, particularly in the case of the incremental encoding, and that they are very competitive for finding bugs. Dedicated encodings seem to have an advantage over using more general methods with BMC. Using the liveness-to-safety translation with BDD-based invariant checking results in an efficient method to find shortest counterexamples that complements the BMC-based approach. For proving complex properties BDD-based methods still tend to perform better.", "paper_title": "LINEAR ENCODINGS OF BOUNDED LTL MODEL CHECKING", "paper_id": "WOS:000209479700005"}