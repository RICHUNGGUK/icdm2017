{"auto_keywords": [{"score": 0.05007852962010534, "phrase": "ifu"}, {"score": 0.03746644318461737, "phrase": "casa"}, {"score": 0.02002394171267796, "phrase": "instruction_cache"}, {"score": 0.010404820558934666, "phrase": "tlb"}, {"score": 0.009767461049446959, "phrase": "traditional_ifu_architectures"}, {"score": 0.00867485785915814, "phrase": "power-saving_logic"}, {"score": 0.00817489567172536, "phrase": "unnecessary_restrictions"}, {"score": 0.005977432023864135, "phrase": "dynamic_power"}, {"score": 0.004757917303420435, "phrase": "power-efficient_instruction_cache"}, {"score": 0.004645860180714466, "phrase": "instruction_fetch_unit"}, {"score": 0.004518442937844318, "phrase": "considerable_portion"}, {"score": 0.0044826811976193485, "phrase": "total_chip_power"}, {"score": 0.004325208730208653, "phrase": "fetch_address"}, {"score": 0.0041074234667687875, "phrase": "tlb_arrays"}, {"score": 0.004074901471704325, "phrase": "instruction_fetch"}, {"score": 0.004026598712747509, "phrase": "limited_work"}, {"score": 0.003885085477351673, "phrase": "fetch_address_generation"}, {"score": 0.0037784540167266497, "phrase": "previous_power-saving_approaches"}, {"score": 0.0033269488835014583, "phrase": "power-saving_approaches"}, {"score": 0.003287482882222731, "phrase": "sufficient_time"}, {"score": 0.0031592690527974285, "phrase": "tlb."}, {"score": 0.0030481444896915504, "phrase": "key_information"}, {"score": 0.0030119758165837625, "phrase": "dynamic_instruction_flow"}, {"score": 0.002964415652865295, "phrase": "front-end_pipeline"}, {"score": 0.0028601252251285025, "phrase": "power_efficiency"}, {"score": 0.002814956065949522, "phrase": "performance_overhead"}, {"score": 0.0027594936602962075, "phrase": "baseline_configuration"}, {"score": 0.0024586427394152196, "phrase": "performance_degradation"}, {"score": 0.002429451930463481, "phrase": "worst_case"}, {"score": 0.002372103459168231, "phrase": "previous_state-of-the-art_power-saving_approaches"}, {"score": 0.0022168460543913787, "phrase": "better_scalability"}, {"score": 0.0021218313648947926, "phrase": "architectural_solutions"}, {"score": 0.0021049977753042253, "phrase": "power-efficient_ifu_designs"}], "paper_keywords": ["computer architecture", " instruction cache", " instruction TLB", " instruction fetch unit", " power-efficient design", " dynamic voltage scaling"], "paper_abstract": "The instruction fetch unit (IFU) usually dissipates a considerable portion of total chip power. In traditional IFU architectures, as soon as the fetch address is generated, it needs to be sent to the instruction cache and TLB arrays for instruction fetch. Since limited work can be done by the power-saving logic after the fetch address generation and before the instruction fetch, previous power-saving approaches usually suffer from the unnecessary restrictions from traditional IFU architectures. In this paper, we present CASA, a new power-aware IFU architecture, which effectively reduces the unnecessary restrictions on the power-saving approaches and provides sufficient time and information for the power-saving logic of both instruction cache and TLB. By analyzing, recording, and utilizing the key information of the dynamic instruction flow early in the front-end pipeline, CASA brings the opportunity to maximize the power efficiency and minimize the performance overhead. Compared to the baseline configuration, the leakage and dynamic power of instruction cache is reduced by 89.7% and 64.1% respectively, and the dynamic power of instruction TLB is reduced by 90.2%. Meanwhile the performance degradation in the worst case is only 0.63%. Compared to previous state-of-the-art power-saving approaches, the CASA-based approach saves IFU power more effectively, incurs less performance overhead and achieves better scalability. It is promising that CASA can stimulate further work on architectural solutions to power-efficient IFU designs.", "paper_title": "CASA: A new IFU architecture for power-efficient instruction cache and TLB designs", "paper_id": "WOS:000252681500012"}