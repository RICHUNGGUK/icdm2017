{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "implementation_structure"}, {"score": 0.04225085299024358, "phrase": "method_placement"}, {"score": 0.03178164007123485, "phrase": "multiple_dispatch"}, {"score": 0.004776297980616768, "phrase": "symmetrically_encapsulated_multimethods"}, {"score": 0.004718897469501381, "phrase": "object-oriented_languages"}, {"score": 0.0045876189888390895, "phrase": "module_interfaces"}, {"score": 0.0039677715255034595, "phrase": "global_effect"}, {"score": 0.0036898803847106023, "phrase": "software_evolution"}, {"score": 0.003601628511550962, "phrase": "multiple_parameters"}, {"score": 0.0035296940954990964, "phrase": "clear_owner"}, {"score": 0.003459191419478298, "phrase": "simple_scheme"}, {"score": 0.0032428780373184207, "phrase": "client_code"}, {"score": 0.002931569771634119, "phrase": "modular_extensibility"}, {"score": 0.002639385610609024, "phrase": "core_calculus"}, {"score": 0.0026181517251690606, "phrase": "class-based_object-oriented_languages"}, {"score": 0.0023762535034673017, "phrase": "modular_type-checking"}, {"score": 0.0023287359930308864, "phrase": "different_strategies"}, {"score": 0.0022546720211200893, "phrase": "type-checking_problem"}, {"score": 0.0022006705963260433, "phrase": "original_calculus"}, {"score": 0.0021566565951738658, "phrase": "modular_checking"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Object-orientation", " Encapsulated multimethods", " Modular type-checking"], "paper_abstract": "In object-oriented languages, methods are encapsulated, hence module interfaces are made up of sets of methods partitioned along the objects or classes that make up the module. This prevents abstraction over the implementation structure of applications. Any change in method placement may cause a global effect that ripples through all clients depending on that method. Sometimes this unduly restricts the scope of software evolution, particularly for methods with multiple parameters where there is no clear owner. We investigate a simple scheme where methods may be defined in the classes of any of their parameters. This allows client code to be oblivious to choice of method placement, and therefore immune against it changing. When combined with multiple dispatch, this scheme allows for modular extensibility, where methods defined in one class may be overloaded by methods defined in classes that are not its subclasses. We detail our proposal by extending a core calculus of class-based object-oriented languages with these symmetrically encapsulated multimethods, and prove the result sound. It is well-known that multiple dispatch is at odds with modular type-checking. We also discuss different strategies that can be followed to mitigate the type-checking problem and propose variants of the original calculus that are amenable to modular checking. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Abstraction over implementation structure with symmetrically encapsulated multimethods", "paper_id": "WOS:000320421700012"}