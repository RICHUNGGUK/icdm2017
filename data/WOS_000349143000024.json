{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "haskell"}, {"score": 0.04489478172391801, "phrase": "refinement_types"}, {"score": 0.026786238083620753, "phrase": "liquidhaskell"}, {"score": 0.004762893197005439, "phrase": "smt-based_checking"}, {"score": 0.004535481695403089, "phrase": "value_languages"}, {"score": 0.004462105963334103, "phrase": "well-studied_subject"}, {"score": 0.004342430078306461, "phrase": "classical_translation"}, {"score": 0.0042489946866108895, "phrase": "verification_conditions"}, {"score": 0.004157561334726201, "phrase": "lazy_evaluation"}, {"score": 0.003272375502853897, "phrase": "refinement_type_system"}, {"score": 0.0031845067058084583, "phrase": "corresponding_verification_conditions"}, {"score": 0.002918826667294298, "phrase": "stratified_type_system"}, {"score": 0.0024653491388223546, "phrase": "experimental_evaluation"}, {"score": 0.002386062690026682, "phrase": "widely_used_haskell_libraries"}, {"score": 0.0022228943786652914, "phrase": "recursive_functions"}], "paper_keywords": [""], "paper_abstract": "SMT-based checking of refinement types for call-by-value languages is a well-studied subject. Unfortunately, the classical translation of refinement types to verification conditions is unsound under lazy evaluation. When checking an expression, such systems implicitly assume that all the free variables in the expression are bound to values. This property is trivially guaranteed by eager, but does not hold under lazy, evaluation. Thus, to be sound and precise, a refinement type system for Haskell and the corresponding verification conditions must take into account which subset of binders actually reduces to values. We present a stratified type system that labels binders as potentially diverging or not, and that (circularly) uses refinement types to verify the labeling. We have implemented our system in LIQUIDHASKELL and present an experimental evaluation of our approach on more than 10,000 lines of widely used Haskell libraries. We show that LIQUIDHASKELL is able to prove 96% of all recursive functions terminating, while requiring a modest 1.7 lines of termination-annotations per 100 lines of code.", "paper_title": "Refinement Types For Haskell", "paper_id": "WOS:000349143000024"}