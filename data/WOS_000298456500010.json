{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "high-performance_memory_allocators"}, {"score": 0.0046928556063004214, "phrase": "large_variety"}, {"score": 0.004652845998457721, "phrase": "memory_allocators"}, {"score": 0.004496174406337201, "phrase": "memory_usage_and_energy_consumption"}, {"score": 0.004363401436068803, "phrase": "software_engineers"}, {"score": 0.004307700591183651, "phrase": "difficult_choices"}, {"score": 0.00409188863874203, "phrase": "custom_allocators"}, {"score": 0.003937126962709418, "phrase": "difficult_and_error-prone_process"}, {"score": 0.00385368199735867, "phrase": "special_impact"}, {"score": 0.0037719988989298983, "phrase": "portable_consumer_embedded_systems"}, {"score": 0.0036762529165489644, "phrase": "limited_amount"}, {"score": 0.0036448787596988423, "phrase": "multimedia_applications"}, {"score": 0.003598317040926701, "phrase": "high_performance"}, {"score": 0.0035676056286816915, "phrase": "extensive_memory_usage"}, {"score": 0.003522027550662857, "phrase": "low_energy_consumption"}, {"score": 0.003432604816716035, "phrase": "flexible_and_efficient_simulator"}, {"score": 0.003388745581055085, "phrase": "dynamic_memory_managers"}, {"score": 0.003123652729688503, "phrase": "general_dmms"}, {"score": 0.0030054007508185858, "phrase": "additional_runtime_overhead"}, {"score": 0.0029797347088361056, "phrase": "additional_programming_cost"}, {"score": 0.002879237498994052, "phrase": "dmm_construction"}, {"score": 0.0028181504086563967, "phrase": "target_application"}, {"score": 0.0026998264237910884, "phrase": "new_dmm"}, {"score": 0.002597577409911978, "phrase": "structured_method"}, {"score": 0.0025099367332615794, "phrase": "object-oriented_fashion"}, {"score": 0.002467228805628948, "phrase": "search_procedure"}, {"score": 0.0024356742694508662, "phrase": "system_designer"}, {"score": 0.0023942269247089277, "phrase": "\"best\"_allocator"}, {"score": 0.0023434058350520763, "phrase": "particular_target_application"}, {"score": 0.002216251512062482, "phrase": "better_performance"}, {"score": 0.0021599099979586946, "phrase": "single_memory_allocators"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Dynamic memory management", " Memory allocation", " Embedded systems design", " Evolutionary computation", " Grammatical evolution"], "paper_abstract": "For the last 30 years, a large variety of memory allocators have been proposed. Since performance, memory usage and energy consumption of each memory allocator differs, software engineers often face difficult choices in selecting the most suitable approach for their applications. To this end, custom allocators are developed from scratch, which is a difficult and error-prone process. This issue has special impact in the field of portable consumer embedded systems, that must execute a limited amount of multimedia applications, demanding high performance and extensive memory usage at a low energy consumption. This paper presents a flexible and efficient simulator to study Dynamic Memory Managers (DMMs), a composition of one or more memory allocators. This novel approach allows programmers to simulate custom and general DMMs, which can be composed without incurring any additional runtime overhead or additional programming cost. We show that this infrastructure simplifies DMM construction, mainly because the target application does not need to be compiled every time a new DMM must be evaluated and because we propose a structured method to search and build DMMs in an object-oriented fashion. Within a search procedure, the system designer can choose the \"best\" allocator by simulation for a particular target application and embedded system. In our evaluation, we show that our scheme delivers better performance, less memory usage and less energy consumption than single memory allocators. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Simulation of high-performance memory allocators", "paper_id": "WOS:000298456500010"}