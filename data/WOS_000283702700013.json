{"auto_keywords": [{"score": 0.04963335999005966, "phrase": "w-stream_model"}, {"score": 0.03358809053029017, "phrase": "rpram"}, {"score": 0.00481495049065317, "phrase": "parallel_algorithms"}, {"score": 0.004481740377469438, "phrase": "efficient_streaming_algorithms"}, {"score": 0.004303664701305258, "phrase": "pass_one_input_stream"}, {"score": 0.004184526032558792, "phrase": "data_items"}, {"score": 0.00410693065248228, "phrase": "limited_space"}, {"score": 0.003993216345115755, "phrase": "output_stream"}, {"score": 0.003894772585498127, "phrase": "input_stream"}, {"score": 0.0037633479183921677, "phrase": "simulation_technique"}, {"score": 0.00371666051014234, "phrase": "efficient_pram_algorithms"}, {"score": 0.003693533648584145, "phrase": "optimal_w-stream_ones"}, {"score": 0.0035912243639260846, "phrase": "euler_tour"}, {"score": 0.00338441786634626, "phrase": "suboptimal_algorithms"}, {"score": 0.003219505953424043, "phrase": "pram"}, {"score": 0.0031994574580544, "phrase": "w-stream"}, {"score": 0.0031107911390188055, "phrase": "non-constant_number"}, {"score": 0.0030625949549620475, "phrase": "parallel_round"}, {"score": 0.0029042284259394044, "phrase": "pram_model"}, {"score": 0.002797382279419762, "phrase": "extra_power"}, {"score": 0.002619748321217153, "phrase": "parallel_rounds"}, {"score": 0.0025312385659888178, "phrase": "new_insights"}, {"score": 0.002507621527279442, "phrase": "streaming_algorithms"}, {"score": 0.0024842242921857705, "phrase": "efficient_algorithms"}, {"score": 0.0024002822777025906, "phrase": "minimum_spanning_tree"}, {"score": 0.002385326947545194, "phrase": "biconnected_components"}, {"score": 0.0023630680726174627, "phrase": "maximal_independent_set"}, {"score": 0.0022268288922192704, "phrase": "almost-tight_communication_complexity-based_lower_bounds"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Data streaming model", " Reductions to parallel algorithms", " Graph problems"], "paper_abstract": "In this paper we show how parallel algorithms can be turned into efficient streaming algorithms for several classical combinatorial problems in the W-Stream model. In this model, at each pass one input stream is read, one output stream is written, and data items have to be processed using limited space; streams are pipelined in such a way that the output stream produced at pass i is given as input stream at pass i + 1. We first introduce a simulation technique that allows turning efficient PRAM algorithms into optimal W-Stream ones, for many classical combinatorial problems, including list ranking and Euler tour of a tree. For other problems, most notably graph problems, however, this technique leads to suboptimal algorithms. To overcome this difficulty we introduce the Relaxed PRAM (RPRAM) computational model, as an intermediate model between PRAM and W-Stream. RPRAM allows every processor to access a non-constant number of memory cells per parallel round, albeit with some restrictions. The RPRAM model, while being more powerful than the PRAM model, can be simulated in W-Stream within the same asymptotic bounds. The extra power provided by RPRAM allows us in many cases to substantially reduce the number of processors, while maintaining the same number of parallel rounds, leading to more efficient W-Stream simulations of parallel algorithms. Our RPRAM technique gives new insights on developing streaming algorithms and yields efficient algorithms for several classical problems in this model including sorting, connectivity, minimum spanning tree, biconnected components, and maximal independent set. In addition to allowing smooth space-passes tradeoffs, our algorithms are also shown, by proving almost-tight communication complexity-based lower bounds in W-Stream, to be optimal up to polylog factors. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Adapting parallel algorithms to the W-Stream model, with applications to graph problems", "paper_id": "WOS:000283702700013"}