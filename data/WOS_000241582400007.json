{"auto_keywords": [{"score": 0.0383084906782155, "phrase": "roots_constraint"}, {"score": 0.023232759516950405, "phrase": "roots"}, {"score": 0.010177321726040002, "phrase": "occurrence_constraints"}, {"score": 0.007014244134709403, "phrase": "linear_time"}, {"score": 0.0054792985089390026, "phrase": "bound_consistency"}, {"score": 0.00471465954562773, "phrase": "wide_range"}, {"score": 0.004432464467019507, "phrase": "range"}, {"score": 0.002858313353461727, "phrase": "global_nature"}, {"score": 0.0027258422018680453, "phrase": "possible_values"}, {"score": 0.0021049980887990318, "phrase": "csplib"}], "paper_keywords": [""], "paper_abstract": "A wide range of counting and occurrence constraints can be specified with just two global primitives: the RANGE constraint, which computes the range of values used by a sequence of variables, and the ROOTS constraint, which computes the variables mapping onto a set of values. We focus here on the ROOTS constraint. We show that propagating the ROOTS constraint completely is intractable. We therefore propose a decomposition which can be used to propagate the constraint in linear time. Interestingly, for all uses of the ROOTS constraint we have met, this decomposition does not destroy the global nature of the constraint as we still prune all possible values. In addition, even when the ROOTS constraint is intractable to propagate completely, we can enforce bound consistency in linear time simply by enforcing bound consistency on the decomposition. Finally, we show that specifying counting and occurrence constraints using ROOTS is effective and efficient in practice on two benchmark problems from CSPLib.", "paper_title": "The ROOTS constraint", "paper_id": "WOS:000241582400007"}