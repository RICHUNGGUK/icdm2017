{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "graphics_processing_units"}, {"score": 0.004590052784169268, "phrase": "asynchronous_relaxation_methods"}, {"score": 0.004413846562278824, "phrase": "asynchronous_iteration_algorithms"}, {"score": 0.004375695378153595, "phrase": "cuda"}, {"score": 0.00428146713705618, "phrase": "parallel_implementations"}, {"score": 0.004244375827831527, "phrase": "synchronous_relaxation_methods"}, {"score": 0.00420760511639957, "phrase": "cpu-"}, {"score": 0.00417115038996633, "phrase": "gpu-based_systems"}, {"score": 0.004063664475797303, "phrase": "test_matrices"}, {"score": 0.004028453603563376, "phrase": "ufmc"}, {"score": 0.003976203286249396, "phrase": "convergence_behavior"}, {"score": 0.003613119346373748, "phrase": "gpus_computing_power"}, {"score": 0.0034742854447532678, "phrase": "gauss-seidel_relaxation"}, {"score": 0.003384695931421288, "phrase": "solution_approximations"}, {"score": 0.0033262524445013303, "phrase": "considerably_shorter_time"}, {"score": 0.003297421722728844, "phrase": "gauss-seidel"}, {"score": 0.0032546105164772995, "phrase": "cpus-"}, {"score": 0.003226631966557132, "phrase": "gpu"}, {"score": 0.003184930103458205, "phrase": "jacobi"}, {"score": 0.0030754582519753474, "phrase": "slower_convergence"}, {"score": 0.0029830992938695007, "phrase": "good_fit"}, {"score": 0.0029443683459283955, "phrase": "asynchronous_schemes"}, {"score": 0.002906138793910919, "phrase": "highly_parallel_gpu_architectures"}, {"score": 0.0027581067089091434, "phrase": "multiple_iterations"}, {"score": 0.002663620639539737, "phrase": "gpu_thread_block"}, {"score": 0.0025389513338018414, "phrase": "global_convergence"}, {"score": 0.0024201029474586007, "phrase": "execution_time"}, {"score": 0.0023886641270884973, "phrase": "global_iteration"}, {"score": 0.0022967713922705, "phrase": "advantageous_properties"}, {"score": 0.0022768346311104735, "phrase": "asynchronous_iteration_methods"}, {"score": 0.002237477619351199, "phrase": "hardware_failure"}, {"score": 0.0022084059770026416, "phrase": "high_potential"}, {"score": 0.0021797112385590913, "phrase": "asynchronous_methods"}, {"score": 0.0021607883988873492, "phrase": "exascale_computing"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Asynchronous-relaxation", " Chaotic iteration", " Graphics processing units (GPUs)", " Jacobi method"], "paper_abstract": "In this paper, we analyze the potential of asynchronous relaxation methods on Graphics Processing Units (GPUs). We develop asynchronous iteration algorithms in CUDA and compare them with parallel implementations of synchronous relaxation methods on CPU- or GPU-based systems. For a set of test matrices from UFMC we investigate convergence behavior, performance and tolerance to hardware failure. We observe that even for our most basic asynchronous relaxation scheme, the method can efficiently leverage the GPUs computing power and is, despite its lower convergence rate compared to the Gauss-Seidel relaxation, still able to provide solution approximations of certain accuracy in considerably shorter time than Gauss-Seidel running on CPUs- or GPU-based Jacobi. Hence, it overcompensates for the slower convergence by exploiting the scalability and the good fit of the asynchronous schemes for the highly parallel GPU architectures. Further, enhancing the most basic asynchronous approach with hybrid schemes-using multiple iterations within the \"subdomain\" handled by a GPU thread block-we manage to not only recover the loss of global convergence but often accelerate convergence of up to two times, while keeping the execution time of a global iteration practically the same. The combination with the advantageous properties of asynchronous iteration methods with respect to hardware failure identifies the high potential of the asynchronous methods for Exascale computing. (C) 2013 Elsevier Inc. All rights reserved.", "paper_title": "A block-asynchronous relaxation method for graphics processing units", "paper_id": "WOS:000326057700009"}