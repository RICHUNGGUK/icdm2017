{"auto_keywords": [{"score": 0.003858110309630846, "phrase": "internal_working"}, {"score": 0.0030645676308053444, "phrase": "fully-device-independent_protocols"}, {"score": 0.0026507289852980512, "phrase": "random_access_codes"}, {"score": 0.002539978170928796, "phrase": "general_framework"}, {"score": 0.002475755804232436, "phrase": "one-sided_classical_communication_tasks"}, {"score": 0.002332133125576037, "phrase": "detection_inefficiencies"}, {"score": 0.002215663255682209, "phrase": "malicious_provider"}, {"score": 0.0021049977753042253, "phrase": "semi-device-independent_quantum_and_classical_protocols"}], "paper_keywords": ["semi-device-independent protocols", " random access codes", " detection loophole"], "paper_abstract": "Semi-device-independent quantum protocols realize information tasks - e.g. secure key distribution, random access coding, and randomness generation - in a scenario where no assumption on the internal working of the devices used in the protocol is made, except their dimension. These protocols offer two main advantages: first, their implementation is often less demanding than fully-device-independent protocols. Second, they are more secure than their device-dependent counterparts. Their classical analogous is represented by random access codes, which provide a general framework for describing one-sided classical communication tasks. We discuss conditions under which detection inefficiencies can be exploited by a malicious provider to fake the performance of semi-device-independent quantum and classical protocols - and how to prevent it.", "paper_title": "DETECTION LOOPHOLE ATTACKS ON SEMI-DEVICE-INDEPENDENT QUANTUM AND CLASSICAL PROTOCOLS", "paper_id": "WOS:000358188400003"}