{"auto_keywords": [{"score": 0.04627141957002931, "phrase": "mpds"}, {"score": 0.04100562739343217, "phrase": "lncs"}, {"score": 0.04072472046898861, "phrase": "springer"}, {"score": 0.04044252948812757, "phrase": "berlin"}, {"score": 0.00481495049065317, "phrase": "budget-bounded"}, {"score": 0.004645057834614705, "phrase": "verification_problem"}, {"score": 0.0046118021635786315, "phrase": "concurrent_programs"}, {"score": 0.004562362497952548, "phrase": "multi-pushdown_systems"}, {"score": 0.004401526587363432, "phrase": "turing"}, {"score": 0.0042459818200777846, "phrase": "basic_decision_problems"}, {"score": 0.003798231095121328, "phrase": "la_torre_et_al"}, {"score": 0.0037038301316019203, "phrase": "lange"}, {"score": 0.0036772897994908123, "phrase": "lei"}, {"score": 0.0035729950293864514, "phrase": "qadeer"}, {"score": 0.003547387822030316, "phrase": "rehof"}, {"score": 0.0035219624421076335, "phrase": "tacas"}, {"score": 0.0032774911048411835, "phrase": "bounded-budget_mpds"}, {"score": 0.0031164983132321417, "phrase": "unbounded_number"}, {"score": 0.002952745241052452, "phrase": "bounded_number"}, {"score": 0.002931569771634119, "phrase": "context_switches"}, {"score": 0.0028586409810976367, "phrase": "reachability_problem"}, {"score": 0.0026410082462069596, "phrase": "code-to-code_translation"}, {"score": 0.0025568135952982345, "phrase": "sequential_program"}, {"score": 0.0025021765811679446, "phrase": "budget-bounded_restriction"}, {"score": 0.00245753647863636, "phrase": "reachable_states"}, {"score": 0.0022950308685133224, "phrase": "ltl-model-checking_of"}, {"score": 0.002262209824105154, "phrase": "standard_sequential_analysis_tools"}, {"score": 0.0022138542785562444, "phrase": "prototype_tool"}], "paper_keywords": ["Concurrent pushdown systems", " Verification problems", " LTL-model-checking", " Reachability problem", " Recursive programs"], "paper_abstract": "We address the verification problem for concurrent programs modeled as multi-pushdown systems (MPDS). In general, MPDS are Turing powerful and hence come along with undecidability of all basic decision problems. Because of this, several subclasses of MPDS have been proposed and studied in the literature (Atig et al. in LNCS, Springer, Berlin, 2005; La Torre et al. in LICS, IEEE, 2007; Lange and Lei in Inf Didact 8, 2009; Qadeer and Rehof in TACAS, LNCS, Springer, Berlin, 2005). In this paper, we propose the class of bounded-budget MPDS, which are restricted in the sense that each stack can perform an unbounded number of context switches only if its depth is below a given bound, and a bounded number of context switches otherwise. We show that the reachability problem for this subclass is Pspace-complete and that LTL-model-checking is Exptime-complete. Furthermore, we propose a code-to-code translation that inputs a concurrent program and produces a sequential program such that running under the budget-bounded restriction yields the same set of reachable states as running . Moreover, detecting (fair) non-terminating executions in can be reduced to LTL-Model-Checking of . By leveraging standard sequential analysis tools, we have implemented a prototype tool and applied it on a set of benchmarks, showing the feasibility of our translation.", "paper_title": "Budget-bounded model-checking pushdown systems", "paper_id": "WOS:000343210700007"}