{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "object-oriented_components"}, {"score": 0.0047823219739028325, "phrase": "finite_state_machines"}, {"score": 0.004733791336312872, "phrase": "object-oriented_terms"}, {"score": 0.004622450915803531, "phrase": "integration_testing"}, {"score": 0.004347972379250724, "phrase": "proper_order"}, {"score": 0.004289215825521407, "phrase": "intended_effect"}, {"score": 0.0040619911719900976, "phrase": "existing_single-class_testing_technique"}, {"score": 0.003993472712847928, "phrase": "multiple_classes"}, {"score": 0.00395291546135423, "phrase": "single-class_technique_models"}, {"score": 0.0038862297330905836, "phrase": "single_class"}, {"score": 0.0038467574225322086, "phrase": "finite_state_machine"}, {"score": 0.0037562016088622447, "phrase": "data_flow_graph"}, {"score": 0.0036305081978734127, "phrase": "state_variable"}, {"score": 0.003532977898022071, "phrase": "conventional_data_flow_testing"}, {"score": 0.0032892054393958052, "phrase": "inter-class_testing"}, {"score": 0.003255777265493076, "phrase": "flow_graphs"}, {"score": 0.0031147914181909775, "phrase": "infeasible_paths"}, {"score": 0.0030414140732789186, "phrase": "arbitrary_number"}, {"score": 0.0029596622424171264, "phrase": "flexible_representations"}, {"score": 0.0027273213556458214, "phrase": "relational_database_and_database_queries"}, {"score": 0.002681255756642227, "phrase": "def-use_information"}, {"score": 0.002487612781045517, "phrase": "processing_techniques"}, {"score": 0.002420710733288495, "phrase": "directed_graphs"}, {"score": 0.0023798115577749225, "phrase": "empirical_results"}, {"score": 0.002323708293955822, "phrase": "automotive_system"}, {"score": 0.00226892463779702, "phrase": "u.s._government_employees"}], "paper_keywords": ["software integration testing", " data flow testing", " data modelling", " finite state machines", " object-oriented"], "paper_abstract": "In object-oriented terms, one of the goals of integration testing is to ensure that messages from objects in one class or component are sent and received in the proper order and have the intended effect on the state of the objects that receive the messages. This research extends an existing single-class testing technique to integration testing of multiple classes. The single-class technique models the behaviour of a single class as a finite state machine, transforms the representation into a data flow graph that explicitly identifies the definitions and uses of each state variable of the class, and then applies conventional data flow testing to produce test case specifications that can be used to test the class. This paper extends those ideas to inter-class testing by developing flow graphs, finding paths between pairs of definitions and uses, detecting some infeasible paths and automatically generating tests for an arbitrary number of classes and components. It introduces flexible representations for message sending and receiving among objects and allows concurrency among any or all classes and components. Data flow graphs are stored in a relational database and database queries are used to gather def-use information. This approach is conceptually simple, mathematically precise, quite powerful and general enough to be used for traditional data flow analysis. This testing approach relies on finite state machines, database modelling and processing techniques and algorithms for analysis and traversal of directed graphs. The paper presents empirical results of the approach applied to an automotive system. This work was prepared by U.S. Government employees as part of their official duties and is, therefore, a work of the U.S. Government and not subject to copyright. Published in 2006 by John Wiley & Sons, Ltd.", "paper_title": "Integration testing of object-oriented components using finite state machines", "paper_id": "WOS:000243367000002"}