{"auto_keywords": [{"score": 0.043113908496203925, "phrase": "c"}, {"score": 0.00481495049065317, "phrase": "multithreaded_program_verification"}, {"score": 0.004738765336344627, "phrase": "multithreaded_programs"}, {"score": 0.00470862827326028, "phrase": "rich_thread_communication_mechanisms"}, {"score": 0.004648925234889467, "phrase": "shared_variables"}, {"score": 0.004445836970274954, "phrase": "automated_verification"}, {"score": 0.004424579657584498, "phrase": "java"}, {"score": 0.00437546648278148, "phrase": "unknown_number"}, {"score": 0.004184274042752558, "phrase": "predicate_abstractions"}, {"score": 0.004157648639294148, "phrase": "recursion-free_source_code"}, {"score": 0.004039906986937495, "phrase": "finite-data_replicated_multithreaded_programs"}, {"score": 0.0039380388343479384, "phrase": "coverability_problem"}, {"score": 0.0038880683136866268, "phrase": "well-ordered_infinite-state_transition_systems"}, {"score": 0.0037900142749506425, "phrase": "full_generality"}, {"score": 0.003746540589820983, "phrase": "ackermann"}, {"score": 0.0036243109044803955, "phrase": "efficient_algorithmic_treatment"}, {"score": 0.0035103899379658006, "phrase": "complete_yet_empirically_efficient_solution"}, {"score": 0.0034109154088832376, "phrase": "original_set"}, {"score": 0.0033891942983439146, "phrase": "coverability_targets"}, {"score": 0.0030892986597489485, "phrase": "original_targets"}, {"score": 0.0030209660697925285, "phrase": "\"bad_guesses\"-configurations"}, {"score": 0.002937942185615948, "phrase": "reasoning"}, {"score": 0.002907312188714594, "phrase": "parallel_engine"}, {"score": 0.0028795712616923462, "phrase": "coverable_configurations"}, {"score": 0.0027360168758119277, "phrase": "bad_widening_choices"}, {"score": 0.00266693888510356, "phrase": "coverability_analysis"}, {"score": 0.002550520546359615, "phrase": "linux"}, {"score": 0.0025502118431246276, "phrase": "multithreaded_c_programs"}, {"score": 0.0025258696565944, "phrase": "device_driver_code"}, {"score": 0.002512421450956107, "phrase": "freebsd"}, {"score": 0.002500100202649692, "phrase": "solaris"}, {"score": 0.0024307967304431806, "phrase": "existing_coverability_methods"}, {"score": 0.0023674407371583922, "phrase": "distributed"}, {"score": 0.002256463899857465, "phrase": "verifying"}, {"score": 0.0021717069990043413, "phrase": "concurrent"}, {"score": 0.0021049977753042253, "phrase": "parallel_languages"}], "paper_keywords": ["Verification", " Algorithms", " Multithreaded program verification", " well-structured transition systems", " coverability"], "paper_abstract": "Pthread-style multithreaded programs feature rich thread communication mechanisms, such as shared variables, signals, and broadcasts. In this article, we consider the automated verification of such programs where an unknown number of threads execute a given finite-data procedure in parallel. Such procedures are typically obtained as predicate abstractions of recursion-free source code written in C or Java. Many safety problems over finite-data replicated multithreaded programs are decidable via a reduction to the coverability problem in certain types of well-ordered infinite-state transition systems. On the other hand, in full generality, this problem is Ackermann-hard, which seems to rule out efficient algorithmic treatment. We present a novel, sound, and complete yet empirically efficient solution. Our approach is to judiciously widen the original set of coverability targets by configurations that involve fewer threads and are thus easier to decide, and whose exploration may well be sufficient: if they turn out uncoverable, so are the original targets. To soften the impact of \"bad guesses\"-configurations that turn out coverable-the exploration is accompanied by a parallel engine that generates coverable configurations; none of these is ever selected for widening. Its job being merely to prevent bad widening choices, such an engine need not be complete for coverability analysis, which enables a range of existing partial (e. g., nonterminating) techniques. We present extensive experiments on multithreaded C programs, including device driver code from FreeBSD, Solaris, and Linux distributions. Our approach outperforms existing coverability methods by orders of magnitude. Categories and Subject Descriptors: D.2.4 [Software/Program Verification]: Formal Methods; F.3.1 [Specifying and Verifying and Reasoning about Programs]: Mechanical Verification; D.3.2 [Language Classifications]: Concurrent, Distributed, and Parallel Languages; F.1.2 [Models of Computation]: Parallelism and Concurrency", "paper_title": "A Widening Approach to Multithreaded Program Verification", "paper_id": "WOS:000344622700004"}