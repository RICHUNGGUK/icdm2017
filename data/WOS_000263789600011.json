{"auto_keywords": [{"score": 0.03623164717943454, "phrase": "owner_approach"}, {"score": 0.015719716506582538, "phrase": "streamline_simulators"}, {"score": 0.010824947875835395, "phrase": "distributed_approach"}, {"score": 0.01007868027464095, "phrase": "tracing_and_mapping_stages"}, {"score": 0.008492291232269255, "phrase": "single-phase_flow_problem"}, {"score": 0.004715851987695018, "phrase": "single-phase_shared_memory_implementation"}, {"score": 0.004662656580437189, "phrase": "shared_memory_programming_model"}, {"score": 0.004610058444728656, "phrase": "streamline_simulation"}, {"score": 0.004558050936835238, "phrase": "rapid_advance"}, {"score": 0.004540845213653946, "phrase": "multicore_processors"}, {"score": 0.004438960192794022, "phrase": "streamline-based_methods"}, {"score": 0.00439718277700031, "phrase": "shared_memory_architectures"}, {"score": 0.0043557968304014, "phrase": "multidimensional_transport_equations"}, {"score": 0.0043311516537076185, "phrase": "large_set"}, {"score": 0.004030739553755089, "phrase": "shared_memory_machines"}, {"score": 0.003985241356967285, "phrase": "built-in_schedulers"}, {"score": 0.0039551937697809405, "phrase": "specialized_load"}, {"score": 0.0038011072845536517, "phrase": "field_applications"}, {"score": 0.0037795886373524798, "phrase": "average_workload"}, {"score": 0.0037298492455995263, "phrase": "workload_variations"}, {"score": 0.0037157581470553336, "phrase": "individual_streamlines"}, {"score": 0.0036877348638630915, "phrase": "load_balancing_advantage"}, {"score": 0.0036668556727648986, "phrase": "explicit_strategies"}, {"score": 0.0036254499741699186, "phrase": "associated_computational_and_parallel_overhead"}, {"score": 0.0034644340888523475, "phrase": "streamline_segments"}, {"score": 0.003399466007862412, "phrase": "complete_streamlines"}, {"score": 0.0033231051425087416, "phrase": "slight_advantage"}, {"score": 0.0032731500822008627, "phrase": "load_balancing"}, {"score": 0.0032239435494724146, "phrase": "additional_overheads"}, {"score": 0.0031814930955904592, "phrase": "straightforward_re-use"}, {"score": 0.0031694670559988813, "phrase": "existing_sequential_codes"}, {"score": 0.0030923947874557023, "phrase": "implicit_or_adaptive_implicit_solution_strategies"}, {"score": 0.0030458973150785194, "phrase": "low_parallel_efficiency"}, {"score": 0.0030171910207671205, "phrase": "real-field_models"}, {"score": 0.0030000968780771746, "phrase": "computational_burden"}, {"score": 0.0027759284865836085, "phrase": "sun_sparc"}, {"score": 0.002739360944604333, "phrase": "sun_opteron"}, {"score": 0.002708399936381754, "phrase": "state-of-the-art_shared_memory_systems"}, {"score": 0.0025587521427561633, "phrase": "varying_well_placements"}, {"score": 0.0025298272464180814, "phrase": "worst_case_scenario"}, {"score": 0.0025154873363010706, "phrase": "tracing_and_mapping_costs"}, {"score": 0.0024823420675793395, "phrase": "transport_costs"}, {"score": 0.0024589361396764858, "phrase": "sparc"}, {"score": 0.00244963246428443, "phrase": "opteron_system"}, {"score": 0.0024311346712789553, "phrase": "parallel_efficiencies"}, {"score": 0.0023945560716448094, "phrase": "tracer_flow_problems"}, {"score": 0.0023809810936809505, "phrase": "sublinear_speedup"}, {"score": 0.002358526528622834, "phrase": "communication_overheads"}, {"score": 0.002309867366839902, "phrase": "relative_contributions"}, {"score": 0.0022579262746365487, "phrase": "parallel_performance"}, {"score": 0.002245124121487381, "phrase": "nearly_linear"}, {"score": 0.0022281671731994405, "phrase": "niagara_ii"}, {"score": 0.0022113380133120674, "phrase": "almost_perfect_linear_scalability"}, {"score": 0.0021780592308757586, "phrase": "lowered_communication_costs"}, {"score": 0.002149350496497899, "phrase": "shared_cache"}, {"score": 0.0021049977753042253, "phrase": "future_server_designs"}], "paper_keywords": ["Streamline simulator", " Parallel implementation", " Shared memory architecture"], "paper_abstract": "We discuss various strategies for parallelizing streamline simulators and present a single-phase shared memory implementation. The choice of a shared memory programming model is motivated by its suitability for streamline simulation, as well as the rapid advance of multicore processors, which are readily available at low-cost. We show that streamline-based methods are easily parallelizable on shared memory architectures through their decomposition of the multidimensional transport equations into a large set of independent 1D transport solves. We tested both a specialized explicit load balancing algorithm that optimizes the streamline load distribution across threads to minimize the time that any of the threads are idle, and the dynamic load balancing algorithms provided by OpenMP on the shared memory machines. Our results clearly indicate that built-in schedulers are competitive with specialized load balancing strategies as long as the number of streamlines per thread is sufficiently high, which is the case in field applications. The average workload per thread is nominally insensitive to workload variations between individual streamlines, and any load balancing advantage offered by explicit strategies is not sufficient to overcome associated computational and parallel overhead. In terms of the allocation of streamlines or streamline segments to threads, we investigated both the distributed approach, in which threads are assigned streamline segments, and the owner approach, in which threads own complete streamlines. We found that the owner approach is most suitable. The slight advantage that the distributed approach has in terms of load balancing is not enough to compensate for the additional overheads. Moreover, the owner approach allows straightforward re-use of existing sequential codes, which is not the case for the distributed approach in case of implicit or adaptive implicit solution strategies. The tracing and mapping stages in streamline simulation have low parallel efficiency. However, in real-field models, the computational burden of the streamline solves is significantly heavier than that of the tracing and mapping stages, and therefore, the impact of these stages is limited. We tested the parallelization on three shared memory systems: a 24 dual-core processor Sun SPARC server; an eight-way Sun Opteron server, representative of the state-of-the-art shared memory systems in use in the industry; and the very recently released Sun Niagara II multicore machine that has eight floating point compute units on the chip. We test a single-phase flow problem on three heterogeneous reservoirs with varying well placements (this system gives the worst case scenario as the tracing and mapping costs are not negligible compared to the transport costs). For the SPARC and Opteron system, we find parallel efficiencies ranging between 60 and 75 for the tracer flow problems. The sublinear speedup is mostly due to communication overheads in the tracing and mapping stages. In applications with more complex physics, the relative contributions of these stages will decrease significantly, and we predict the parallel performance to be nearly linear. On the Niagara II, we obtain almost perfect linear scalability even for the single-phase flow problem thanks to the lowered communication costs on these architectures that have a shared cache. This result is all the more satisfactory considering that future server designs will be akin to this system.", "paper_title": "Parallel implementations of streamline simulators", "paper_id": "WOS:000263789600011"}