{"auto_keywords": [{"score": 0.04230702677122493, "phrase": "k-ary"}, {"score": 0.00481495049065317, "phrase": "variable_length_codes"}, {"score": 0.004163427731140163, "phrase": "code_symbols"}, {"score": 0.00385658790017119, "phrase": "source_symbols"}, {"score": 0.0037402558657576124, "phrase": "incomplete_internal_nodes"}, {"score": 0.0035179764329354877, "phrase": "aifv_codes"}, {"score": 0.003438058620195309, "phrase": "instantaneous_codes"}, {"score": 0.0032336801561165113, "phrase": "decoding_delay"}, {"score": 0.002731971103291716, "phrase": "aifv_code"}, {"score": 0.0026698611202305715, "phrase": "better_average_compression_rate"}, {"score": 0.0026091594819333654, "phrase": "huffman_code"}, {"score": 0.0023798115577749225, "phrase": "multiple_code_trees"}, {"score": 0.002255431275670053, "phrase": "binary_and_ternary_aifv_codes"}, {"score": 0.0022041312401435346, "phrase": "optimal_aifv_code"}], "paper_keywords": ["AIFV code", " Huffman code", " FV code", " code tree", " Kraft inequality", " integer programming"], "paper_abstract": "We propose almost instantaneous fixed-to-variable length (AIFV) codes such that two (resp. K - 1) code trees are used, if code symbols are binary (resp. K-ary for K >= 3), and source symbols are assigned to incomplete internal nodes in addition to leaves. Although the AIFV codes are not instantaneous codes, they are devised such that the decoding delay is at most two bits (resp. one code symbol) in the case of binary (resp. K-ary) code alphabet. The AIFV code can attain better average compression rate than the Huffman code at the expenses of a little decoding delay and a little large memory size to store multiple code trees. We also show for the binary and ternary AIFV codes that the optimal AIFV code can be obtained by solving 0-1 integer programming problems.", "paper_title": "Almost Instantaneous Fixed-to-Variable Length Codes", "paper_id": "WOS:000368420200002"}