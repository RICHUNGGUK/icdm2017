{"auto_keywords": [{"score": 0.04567789125447872, "phrase": "safe_memory"}, {"score": 0.03282854809187119, "phrase": "theta"}, {"score": 0.00481495049065317, "phrase": "non-constant_safe_memory"}, {"score": 0.004706305193222972, "phrase": "data_structures"}, {"score": 0.004600100053651545, "phrase": "faulty_ram_model"}, {"score": 0.004558290392967033, "phrase": "finocchi"}, {"score": 0.004335000368745273, "phrase": "arbitrary_size_s"}, {"score": 0.004122604238556912, "phrase": "resilient_algorithmic_techniques"}, {"score": 0.003814563533445401, "phrase": "maximum_amount"}, {"score": 0.0035781807623238905, "phrase": "actual_number"}, {"score": 0.003545625043276134, "phrase": "occurred_faults"}, {"score": 0.003418327319110734, "phrase": "resilient_algorithm"}, {"score": 0.0029666322924554274, "phrase": "previous_resilient_sorting_algorithms"}, {"score": 0.0028863414975346512, "phrase": "available_safe_memory"}, {"score": 0.0026461080202599694, "phrase": "resilient_priority_queue"}, {"score": 0.0024706232839499546, "phrase": "n_keys"}, {"score": 0.0022857351723674004, "phrase": "deletemin_operation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Resilient algorithm", " Resilient data structure", " Memory errors", " Sorting", " Priority queue", " Tradeoffs", " Fault tolerance"], "paper_abstract": "We extend the Faulty RAM model by Finocchi and Italiana (2008) by adding a safe memory of arbitrary size S, and we then derive tradeoffs between the performance of resilient algorithmic techniques and the size of the safe memory. Let delta and alpha denote, respectively, the maximum amount of faults which can happen during the execution of an algorithm and the actual number of occurred faults, with alpha <= delta. We propose a resilient algorithm for sorting n entries which requires O (n log n + alpha(delta/S +log S)) time and uses Theta (S) safe memory words. Our algorithm outperforms previous resilient sorting algorithms which do not exploit the available safe memory and require O (n log n + alpha delta) time. Finally, we exploit our sorting algorithm for deriving a resilient priority queue. Our implementation uses Theta (S) safe memory words and Theta (n) faulty memory words for storing n keys, and requires O (log n + delta/S) amortized time for each insert and deletemin operation. Our resilient priority queue improves the O (log n + delta) amortized time required by the state of the art. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Exploiting non-constant safe memory in resilient algorithms and data structures", "paper_id": "WOS:000355038600008"}