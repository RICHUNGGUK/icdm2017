{"auto_keywords": [{"score": 0.04821664133686311, "phrase": "htm"}, {"score": 0.00481495049065317, "phrase": "hardware_transactions"}, {"score": 0.004689321062844586, "phrase": "transactional_memory"}, {"score": 0.004536862734384202, "phrase": "complex_operations"}, {"score": 0.004218602458288531, "phrase": "hardware_buffers"}, {"score": 0.003922580121023413, "phrase": "concurrent_operations"}, {"score": 0.003794954883650141, "phrase": "programming_technique"}, {"score": 0.0037450707321601963, "phrase": "compiler_support"}, {"score": 0.0035993041437026225, "phrase": "conflict_rates"}, {"score": 0.0035285548582081627, "phrase": "common_operations"}, {"score": 0.003091036449708673, "phrase": "ordinary_code"}, {"score": 0.002912222095383313, "phrase": "overall_operation"}, {"score": 0.002798780784517325, "phrase": "application-specific_validator_object"}, {"score": 0.002689746491842271, "phrase": "transparent_composition"}, {"score": 0.0026543514413663893, "phrase": "partitioned_operations"}, {"score": 0.0025678829712650437, "phrase": "fully-automated_compiler_support"}, {"score": 0.0024842242921857705, "phrase": "planning_operations"}, {"score": 0.0024192592458651204, "phrase": "parent_transaction"}, {"score": 0.0023559890904375526, "phrase": "program_data_flow"}, {"score": 0.0022641658133181115, "phrase": "micro-and_macro-benchmarks"}, {"score": 0.0022049428043454966, "phrase": "ibm_z-series_and_intel_haswell_machines"}, {"score": 0.0021049977753042253, "phrase": "dramatically_lower_abort_rates"}], "paper_keywords": ["Algorithm", " Performance", " Hardware Transactional Memory", " Partitioned Transactions", " Compiler Automation"], "paper_abstract": "Best-effort hardware transactional memory (HTM) allows complex operations to execute atomically and in parallel, so long as hardware buffers do not overflow, and conflicts are not encountered with concurrent operations. We describe a programming technique and compiler support to reduce both overflow and conflict rates by partitioning common operations into read-mostly (planning) and write-mostly (completion) operations, which then execute separately. The completion operation remains transactional; planning can often occur in ordinary code. High-level (semantic) atomicity for the overall operation is ensured by passing an application-specific validator object between planning and completion. Transparent composition of partitioned operations is made possible through fully-automated compiler support, which migrates all planning operations out of the parent transaction while respecting all program data flow and dependences. For both micro-and macro-benchmarks, experiments on IBM z-Series and Intel Haswell machines demonstrate that partitioning can lead to dramatically lower abort rates and higher scalability.", "paper_title": "Software Partitioning of Hardware Transactions", "paper_id": "WOS:000367254800008"}