{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "read-copy_update"}, {"score": 0.0045726187330434025, "phrase": "synchronization_technique"}, {"score": 0.004456044928556639, "phrase": "reader-writer_locking"}, {"score": 0.004398872331144531, "phrase": "rcu's_read-side_primitives"}, {"score": 0.004044645056447888, "phrase": "uncontended_locking"}, {"score": 0.003967021436047945, "phrase": "rcu_updates"}, {"score": 0.003916098498242888, "phrase": "relatively_heavy_weight"}, {"score": 0.003791621842185417, "phrase": "read-side_performance"}, {"score": 0.003694884775158077, "phrase": "computing_systems"}, {"score": 0.003486123304074186, "phrase": "rcu"}, {"score": 0.003289117944111902, "phrase": "kernel-level_implementations"}, {"score": 0.003163985877966426, "phrase": "unavailable_to_user_applications"}, {"score": 0.002927780883930371, "phrase": "inefficient_read-side_primitives"}, {"score": 0.0028530201960995896, "phrase": "application_architecture"}, {"score": 0.0026916956768363158, "phrase": "efficient_and_flexible_rcu_implementations"}, {"score": 0.0025725382476862305, "phrase": "user-level_applications"}, {"score": 0.00244278788608393, "phrase": "rcu_implementations"}, {"score": 0.0023497779149212737, "phrase": "standard_locking"}, {"score": 0.002260301305523054, "phrase": "best_mechanism"}, {"score": 0.0021049977753042253, "phrase": "widespread_user-application_use"}], "paper_keywords": ["Synchronization", " process management", " operating systems", " software/software engineering", " threads", " concurrency"], "paper_abstract": "Read-copy update (RCU) is a synchronization technique that often replaces reader-writer locking because RCU's read-side primitives are both wait-free and an order of magnitude faster than uncontended locking. Although RCU updates are relatively heavy weight, the importance of read-side performance is increasing as computing systems become more responsive to changes in their environments. RCU is heavily used in several kernel-level environments. Unfortunately, kernel-level implementations use facilities that are often unavailable to user applications. The few prior user-level RCU implementations either provided inefficient read-side primitives or restricted the application architecture. This paper fills this gap by describing efficient and flexible RCU implementations based on primitives commonly available to user-level applications. Finally, this paper compares these RCU implementations with each other and with standard locking, which enables choosing the best mechanism for a given workload. This work opens the door to widespread user-application use of RCU.", "paper_title": "User-Level Implementations of Read-Copy Update", "paper_id": "WOS:000298381100021"}