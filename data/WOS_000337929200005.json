{"auto_keywords": [{"score": 0.03685919070561432, "phrase": "package_blueprint"}, {"score": 0.006466939516159342, "phrase": "multiple_packages"}, {"score": 0.00501242457027226, "phrase": "observed_package"}, {"score": 0.0047388139424516555, "phrase": "packages_dependencies"}, {"score": 0.004713702303619539, "phrase": "large_object-oriented_applications"}, {"score": 0.004614573278897633, "phrase": "important_but_complex_structural_entities"}, {"score": 0.004029636266402555, "phrase": "massive_amount"}, {"score": 0.0034536749437877813, "phrase": "detail_package_internal_structure"}, {"score": 0.0033185766249800917, "phrase": "package_and_class_levels"}, {"score": 0.003240059402545145, "phrase": "understanding_package_structure"}, {"score": 0.003113291034530603, "phrase": "refactoring_decisions"}, {"score": 0.002999439235243178, "phrase": "space_filling_matrix-based_visualization"}, {"score": 0.002366703985831692, "phrase": "understanding_packages"}, {"score": 0.002341628146530334, "phrase": "exploratory_user_study"}, {"score": 0.002310655771784907, "phrase": "advanced_ide."}, {"score": 0.0022260904764292372, "phrase": "package_structure"}, {"score": 0.002121885708280336, "phrase": "standard_browser_users"}], "paper_keywords": ["Software engineering", " Software comprehension", " Software maintenance", " Software visualization"], "paper_abstract": "Large object-oriented applications are structured over many packages. Packages are important but complex structural entities that are difficult to understand since they act as containers of classes, which can have many dependencies with other classes spread over multiple packages. However to be able to take decisions (e.g. refactoring and/or assessment decisions), maintainers face the challenges of managing (sorting, grouping) the massive amount of dependencies between classes spread over multiple packages. To help maintainers, there is a need for at the same time understanding, and quantifying, dependencies between classes as well as understanding how packages as containers of such classes depend on each other. In this paper, we present a visualization, named Package Blueprint, that reveals in detail package internal structure, as well as the dependencies between an observed package and its neighbors, at both package and class levels. Package blueprint aims at assisting maintainers in understanding package structure and dependencies, in particular when they focus on few packages and want to take refactoring decisions and/or to assess the structure of those packages. A package blueprint is a space filling matrix-based visualization, using two placement strategies that are enclosure and adjacency. Package blueprint is structured around the notion of surfaces that group classes and their dependencies by their packages (i.e., enclosure placement); whilst surfaces are placed next to their parent node which is the package under-analysis (i.e., adjacency placement). We present two views: one stressing how an observed package depends upon the rest of the system and another stressing how the system depends upon that package. To evaluate the contribution of package blueprint for understanding packages we performed an exploratory user study comparing package blueprint with an advanced IDE. The results show that users of package blueprint are faster in analyzing and assessing package structure. The results are proved statically significant and they show that package blueprint considerably improves the experience of standard browser users. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "The Package Blueprint: Visually analyzing and quantifying packages dependencies", "paper_id": "WOS:000337929200005"}