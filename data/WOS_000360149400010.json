{"auto_keywords": [{"score": 0.04895692824063779, "phrase": "flutter_shutter"}, {"score": 0.012874320129321212, "phrase": "optimal_flutter_shutter_codes"}, {"score": 0.011047222961307833, "phrase": "velocity_distribution"}, {"score": 0.01017260955548509, "phrase": "mse"}, {"score": 0.004628320711601916, "phrase": "uniform_motion_blur_invertible"}, {"score": 0.0045557008859819234, "phrase": "\"fluttering\"_shutter"}, {"score": 0.004396426822203258, "phrase": "well_chosen_sub-intervals"}, {"score": 0.004344577216137524, "phrase": "exposure_time_interval"}, {"score": 0.0042426974826585695, "phrase": "photon_flux"}, {"score": 0.004143196873246147, "phrase": "well_chosen_sequence"}, {"score": 0.003982500388997765, "phrase": "numerical_method"}, {"score": 0.0038737214010638745, "phrase": "mean_square_error"}, {"score": 0.003738200814271716, "phrase": "observed_objects"}, {"score": 0.0036217089991592275, "phrase": "random_velocity_distribution"}, {"score": 0.0035380356512773937, "phrase": "gaussian"}, {"score": 0.003508834578859094, "phrase": "uniform_velocity_distributions"}, {"score": 0.0032161835102640372, "phrase": "optimal_flutter_shutter_code"}, {"score": 0.003153140905312787, "phrase": "optimal_snapshot"}, {"score": 0.003042752533935891, "phrase": "symmetric_optimization"}, {"score": 0.00289007009553812, "phrase": "equal_footing"}, {"score": 0.0028446460307503343, "phrase": "i.e._camera_designs"}, {"score": 0.002607246047604476, "phrase": "reverse_engineering"}, {"score": 0.0025059724686541263, "phrase": "shutter_codes"}, {"score": 0.0023520340492933383, "phrase": "underlying_velocity_distribution"}, {"score": 0.0022162970216404927, "phrase": "comprehensive_study"}, {"score": 0.0021049977753042253, "phrase": "backward_numerical_solution"}], "paper_keywords": [""], "paper_abstract": "The goal of the flutter shutter is to make uniform motion blur invertible, by a \"fluttering\" shutter that opens and closes on a sequence of well chosen sub-intervals of the exposure time interval. In other words, the photon flux is modulated according to a well chosen sequence called flutter shutter code. This article provides a numerical method that computes optimal flutter shutter codes in terms of mean square error (MSE). We assume that the observed objects follow a known (or learned) random velocity distribution. In this paper, Gaussian and uniform velocity distributions are considered. Snapshots are also optimized taking the velocity distribution into account. For each velocity distribution, the gain of the optimal flutter shutter code with respect to the optimal snapshot in terms of MSE is computed. This symmetric optimization of the flutter shutter and of the snapshot allows to compare on an equal footing both solutions, i.e. camera designs. Optimal flutter shutter codes are demonstrated to improve substantially the MSE compared to classic (patented or not) codes. A numerical method that permits to perform a reverse engineering of any existing (patented or not) flutter shutter codes is also described and an implementation is given. In this case we give the underlying velocity distribution from which a given optimal flutter shutter code comes from. The combination of these two numerical methods furnishes a comprehensive study of the optimization of a flutter shutter that includes a forward and a backward numerical solution.", "paper_title": "The Flutter Shutter Code Calculator", "paper_id": "WOS:000360149400010"}