{"auto_keywords": [{"score": 0.03517083259120442, "phrase": "communication_costs"}, {"score": 0.019655177219526723, "phrase": "stream_programs"}, {"score": 0.016398401307836662, "phrase": "data_channels"}, {"score": 0.007849339854116621, "phrase": "stream_program"}, {"score": 0.005440697147789655, "phrase": "profiling_steps"}, {"score": 0.00481495049065317, "phrase": "stream_programs_on_multicores"}, {"score": 0.004749106104067268, "phrase": "multicore_architectures"}, {"score": 0.004662705558154439, "phrase": "industry_standard"}, {"score": 0.004620093797504386, "phrase": "programming_abstractions"}, {"score": 0.004577869668211548, "phrase": "concurrent_programming"}, {"score": 0.004515252649226697, "phrase": "key_importance"}, {"score": 0.004473982381245469, "phrase": "stream_programming_languages"}, {"score": 0.00443308765153716, "phrase": "application_domains"}, {"score": 0.004372442291178139, "phrase": "regular_sequences"}, {"score": 0.0039522429946090174, "phrase": "independent_actors"}, {"score": 0.0038802832668554457, "phrase": "fifo_data_channels"}, {"score": 0.0038271712887391015, "phrase": "major_challenge"}, {"score": 0.0036553070575015344, "phrase": "available_processing_cores"}, {"score": 0.0034911335714333507, "phrase": "actor_execution_times"}, {"score": 0.0033037970113095577, "phrase": "cache-coherent_shared-memory_multiprocessors"}, {"score": 0.003126481516783286, "phrase": "cache_coherence_protocol"}, {"score": 0.003097865379563127, "phrase": "standard_execution_time_profiling_techniques"}, {"score": 0.002878140062594849, "phrase": "execution_time_overhead"}, {"score": 0.002673957615079041, "phrase": "cache-coherent_multicore_architectures"}, {"score": 0.002530359917257626, "phrase": "novel_profiling_scheme"}, {"score": 0.002361632539339945, "phrase": "streamit_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "exhaustive_profiling"}], "paper_keywords": ["Languages", " Algorithms", " Profiling", " Performance", " Optimization", " StreamIt", " multicore", " stream programming"], "paper_abstract": "Because multicore architectures have become the industry standard, programming abstractions for concurrent programming are of key importance. Stream programming languages facilitate application domains characterized by regular sequences of data, such as multimedia, graphics, signal processing and networking. With stream programs, computations are expressed through independent actors that interact through FIFO data channels. A major challenge with stream programs is to load-balance actors among available processing cores. The workload of a stream program is determined by actor execution times and the communication overhead induced by data channels. Estimating communication costs on cache-coherent shared-memory multiprocessors is difficult, because data movements are abstracted away by the cache coherence protocol. Standard execution time profiling techniques cannot separate actor execution times from communication costs, because communication costs manifest in terms of execution time overhead. In this work we present a unified Integer Linear Programming (ILP) formulation that balances the workload of stream programs on cache-coherent multicore architectures. For estimating the communication costs of data channels, we devise a novel profiling scheme that minimizes the number of profiling steps. We conduct experiments across a range of StreamIt benchmarks and show that our method achieves a speedup of up to 4.02x on 6 processors. The number of profiling steps is on average only 17% of an exhaustive profiling run over all data channels of a stream program.", "paper_title": "Profile-Guided Deployment of Stream Programs on Multicores", "paper_id": "WOS:000307580000009"}