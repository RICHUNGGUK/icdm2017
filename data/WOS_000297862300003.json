{"auto_keywords": [{"score": 0.03961779893438284, "phrase": "lut_optimization"}, {"score": 0.00857623295332961, "phrase": "mesa"}, {"score": 0.00481495049065317, "phrase": "software_lookup_table_optimization"}, {"score": 0.00470325458481566, "phrase": "scientific_applications"}, {"score": 0.004487541157100498, "phrase": "costly_elementary_functions"}, {"score": 0.00444559516711374, "phrase": "lookup_table"}, {"score": 0.004201991568145053, "phrase": "previously_computed_results"}, {"score": 0.004162703509434786, "phrase": "lut_methods"}, {"score": 0.0039716833701918365, "phrase": "function_results"}, {"score": 0.0038794730876377057, "phrase": "high_level"}, {"score": 0.0038431888954930083, "phrase": "fuzzy_reuse"}, {"score": 0.003531474887552889, "phrase": "current_practice"}, {"score": 0.0034494494982242187, "phrase": "programming_effort"}, {"score": 0.003401148484767927, "phrase": "extensive_experimentation"}, {"score": 0.003095923814666088, "phrase": "tool_implementation"}, {"score": 0.0029260602766930065, "phrase": "source-to-source_transformations"}, {"score": 0.0028047899594686003, "phrase": "tedious_and_error-prone_aspects"}, {"score": 0.0027785321992996413, "phrase": "lut"}, {"score": 0.002726740692380339, "phrase": "domain_profiling"}, {"score": 0.0027012086158226456, "phrase": "error_analysis"}, {"score": 0.0026633568650501873, "phrase": "code_generation"}, {"score": 0.0025892330566358503, "phrase": "five_scientific_applications"}, {"score": 0.0025290375256888883, "phrase": "performance_improvement"}, {"score": 0.0024014759148123736, "phrase": "molecular_dynamics_program"}, {"score": 0.002323663295811215, "phrase": "neural_network_application"}, {"score": 0.0022589720760078274, "phrase": "hydrology_calculation"}, {"score": 0.0021049977753042253, "phrase": "manual_approaches"}], "paper_keywords": ["Lookup table", " performance optimization", " error analysis", " code generation", " scientific computing", " memoization", " fuzzy reuse"], "paper_abstract": "A number of scientific applications are performance-limited by expressions that repeatedly call costly elementary functions. Lookup table (LUT) optimization accelerates the evaluation of such functions by reusing previously computed results. LUT methods can speed up applications that tolerate an approximation of function results, thereby achieving a high level of fuzzy reuse. One problem with LUT optimization is the difficulty of controlling the tradeoff between performance and accuracy. The current practice of manual LUT optimization adds programming effort by requiring extensive experimentation to make this tradeoff, and such hand tuning can obfuscate algorithms. In this paper we describe a methodology and tool implementation to improve the application of software LUT optimization. Our Mesa tool implements source-to-source transformations for C or C++ code to automate the tedious and error-prone aspects of LUT generation such as domain profiling, error analysis, and code generation. We evaluate Mesa with five scientific applications. Our results show a performance improvement of 3.0x and 6.9x for two molecular biology algorithms, 1.4x for a molecular dynamics program, 2.1x to 2.8x for a neural network application, and 4.6x for a hydrology calculation. We find that Mesa enables LUT optimization with more control over accuracy and less effort than manual approaches.", "paper_title": "Tool support for software lookup table optimization", "paper_id": "WOS:000297862300003"}