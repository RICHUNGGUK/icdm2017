{"auto_keywords": [{"score": 0.031238330630895195, "phrase": "gpa"}, {"score": 0.00481495049065317, "phrase": "alternative_nested_paging_models"}, {"score": 0.0047051051659828275, "phrase": "address_translation"}, {"score": 0.004597754207658615, "phrase": "critical_performance_bottleneck"}, {"score": 0.004555499634179394, "phrase": "virtualized_systems"}, {"score": 0.004390312150344245, "phrase": "hardware_paging_mechanisms"}, {"score": 0.004290112502811656, "phrase": "similar_translation_models"}, {"score": 0.004231089088705995, "phrase": "guest_and_host_address_translations"}, {"score": 0.004134508282135594, "phrase": "important_observation"}, {"score": 0.00398452530840582, "phrase": "guest_physical_addresses"}, {"score": 0.0038756055612167942, "phrase": "physical_addresses"}, {"score": 0.0036328561748082138, "phrase": "guest_virtual_addresses"}, {"score": 0.0034528025626422154, "phrase": "vmm_cooperation"}, {"score": 0.0033428820402140683, "phrase": "guest_os_compatibility"}, {"score": 0.0032066653632708965, "phrase": "hashed_page_table_approach"}, {"score": 0.0031479142819948007, "phrase": "nested_paging"}, {"score": 0.0030056887638095883, "phrase": "unhashed_multi-level_forward_page_tables"}, {"score": 0.0028172726995962173, "phrase": "page_walk_cost"}, {"score": 0.0027784560880013886, "phrase": "tlb_miss"}, {"score": 0.00274017282519193, "phrase": "n-level_page_tables"}, {"score": 0.00249805321224923, "phrase": "hashed_page_table"}, {"score": 0.0024409345168575833, "phrase": "nested_level"}, {"score": 0.0023741093119014436, "phrase": "memory_system"}, {"score": 0.0022563011263787847, "phrase": "nested_forward-mapped_page_table"}, {"score": 0.0021049977753042253, "phrase": "alternative_paging_mechanisms"}], "paper_keywords": ["Virtualization", " Computer Architecture", " Virtual Memory", " Nested Paging"], "paper_abstract": "Address translation often emerges as a critical performance bottleneck for virtualized systems and has recently been the impetus for hardware paging mechanisms. These mechanisms apply similar translation models for both guest and host address translations. We make an important observation that the model employed to translate from guest physical addresses (GPAs) to host physical addresses (HPAs) is in fact orthogonal to the model used to translate guest virtual addresses (GVAs) to GPAs. Changing this model requires VMM cooperation, but has no implications for guest OS compatibility. As an example, we consider a hashed page table approach for GPA -> HPA translation. Nested paging, widely considered the most promising approach, uses unhashed multi-level forward page tables for both GVA -> GPA and GPA -> HPA translations, resulting in a potential O(n(2)) page walk cost on a TLB miss, for n-level page tables. In contrast, the hashed page table approach results in an expected O(n) cost. Our simulation results show that when a hashed page table is used in the nested level, the performance of the memory system is not worse, and sometimes even better than a nested forward-mapped page table due to reduced page walks and cache pressure. This showcases the potential for alternative paging mechanisms.", "paper_title": "A Case for Alternative Nested Paging Models for Virtualized Systems", "paper_id": "WOS:000288081600005"}