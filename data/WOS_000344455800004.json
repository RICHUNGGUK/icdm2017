{"auto_keywords": [{"score": 0.049472618603403344, "phrase": "aeminium"}, {"score": 0.005641700854710508, "phrase": "formal_system"}, {"score": 0.00481495049065317, "phrase": "-default_programming_language_approach"}, {"score": 0.004646088032529303, "phrase": "concurrent-by-default_programming_language"}, {"score": 0.004473654235695817, "phrase": "case_studies"}, {"score": 0.004471700631129084, "phrase": "concurrent-by-default_aeminium_programming_language"}, {"score": 0.0044150318724093226, "phrase": "permission_flow_of_object_and_group_permissions"}, {"score": 0.004336894811284795, "phrase": "program's_correctness"}, {"score": 0.0042710170430179184, "phrase": "possible_parallelization_strategy"}, {"score": 0.004261996270450828, "phrase": "performance_improvements"}, {"score": 0.004238452771031322, "phrase": "dataflow_graph"}, {"score": 0.003936137932404253, "phrase": "core_concepts"}, {"score": 0.003916098498242888, "phrase": "aeminium._mu_aeminium's_static_type_system"}, {"score": 0.0038467574225322086, "phrase": "aeminium-specific_extensions"}, {"score": 0.003788296551609616, "phrase": "aeminium's_type_system"}, {"score": 0.0036928221419965253, "phrase": "potential_parallel_execution_strategy"}, {"score": 0.003636692152882991, "phrase": "aeminium's_dynamic_semantics"}, {"score": 0.003608946747385227, "phrase": "concurrent-by-default_evaluation_approach"}, {"score": 0.0034911335714333507, "phrase": "full_description"}, {"score": 0.003308862957060602, "phrase": "plaid_programming_language"}, {"score": 0.0032752356604145738, "phrase": "first-class_support"}, {"score": 0.003208999546225013, "phrase": "aeminium_implementation"}, {"score": 0.003088384809415812, "phrase": "aeminium's_applicability"}, {"score": 0.0030491927770430693, "phrase": "aeminium_parallelized_code"}, {"score": 0.002949598537993663, "phrase": "common_domains"}, {"score": 0.0027600360731762997, "phrase": "webserver_application"}, {"score": 0.002731971103291716, "phrase": "aeminium's_impact"}, {"score": 0.002718045523483502, "phrase": "latency-bound_applications"}, {"score": 0.0026494723416072316, "phrase": "sequential_counterpart"}, {"score": 0.002622528664187849, "phrase": "case_study"}, {"score": 0.0025826247025542235, "phrase": "dictionary_function"}, {"score": 0.0025629004054291524, "phrase": "aeminium's_capabilities"}, {"score": 0.0025433263646920364, "phrase": "essential_data_structures"}, {"score": 0.002392008392892289, "phrase": "annotation_effort"}, {"score": 0.002325689073229477, "phrase": "integral_computationally_example"}, {"score": 0.0023079225317714815, "phrase": "pure_functional_programming_and_computational_intensive_use_cases"}, {"score": 0.0022324858095648338, "phrase": "functional_code"}, {"score": 0.0021817065300196634, "phrase": "plaid's_inherent_performance_bounds"}, {"score": 0.0021157891421445846, "phrase": "concurrent_programming"}, {"score": 0.0021049977753042253, "phrase": "modern_programming_environments"}], "paper_keywords": ["Languages", " Theory", " Performance", " access permissions", " permissions", " data groups", " concurrency"], "paper_abstract": "The aim of AEMINIUM is to study the implications of having a concurrent-by-default programming language. This includes language design, runtime system, performance and software engineering considerations. We conduct our study through the design of the concurrent-by-default AEMINIUM programming language. AEMINIUM leverages the permission flow of object and group permissions through the program to validate the program's correctness and to automatically infer a possible parallelization strategy via a dataflow graph. AEMINIUM supports not only fork-join parallelism but more general dataflow patterns of parallelism. In this paper we present a formal system, called mu AEMINIUM, modeling the core concepts of AEMINIUM. mu AEMINIUM's static type system is based on Featherweight Java with AEMINIUM-specific extensions. Besides checking for correctness AEMINIUM's type system it also uses the permission flow to compute a potential parallel execution strategy for the program. mu AEMINIUM's dynamic semantics use a concurrent-by-default evaluation approach. Along with the formal system we present its soundness proof. We provide a full description of the implementation along with the description of various optimization techniques we used. We implemented AEMINIUM as an extension of the Plaid programming language, which has first-class support for permissions built-in. The AEMINIUM implementation and all case studies are publicly available under the General Public License. We use various case studies to evaluate AEMINIUM's applicability and to demonstrate that AEMINIUM parallelized code has performance improvements compared to its sequential counterpart. We chose to use case studies from common domains or problems that are known to benefit from parallelization, to show that AEMINIUM is powerful enough to encode them. We demonstrate through a webserver application, which evaluates AEMINIUM's impact on latency-bound applications, that AEMINIUM can achieve a 70% performance improvement over the sequential counterpart. In another case study we chose to implement a dictionary function to evaluate AEMINIUM's capabilities to express essential data structures. Our evaluation demonstrates that AEMINIUM can be used to express parallelism in such data-structures and that the performance benefits scale with the amount of annotation effort which is put into the implementation. We chose an integral computationally example to evaluate pure functional programming and computational intensive use cases. Our experiments show that AEMINIUM is capable of extracting parallelism from functional code and achieving performance improvements up to the limits of Plaid's inherent performance bounds. Overall, we hope that the work helps to advance concurrent programming in modern programming environments.", "paper_title": "AEMINIUM: A Permission Based Concurrent-by-Default Programming Language Approach", "paper_id": "WOS:000344455800004"}