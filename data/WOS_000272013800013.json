{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "automatic_modular_abstractions_for_linear_constraints"}, {"score": 0.004513450434595191, "phrase": "abstract_transformers"}, {"score": 0.004449045430179066, "phrase": "static_analysis"}, {"score": 0.004385555408850022, "phrase": "abstract_interpretation"}, {"score": 0.0042004472903194616, "phrase": "linear_constraints"}, {"score": 0.00374399358035391, "phrase": "loop-free_code"}, {"score": 0.0035346515636097533, "phrase": "least_fixed_points"}, {"score": 0.0031959843979467704, "phrase": "recursive_functions"}, {"score": 0.0030609320300175953, "phrase": "new_quantifier_elimination"}, {"score": 0.0030171910207671205, "phrase": "symbolic_manipulation_techniques"}, {"score": 0.0028689475587958917, "phrase": "abstract_domain"}, {"score": 0.0025938977569302177, "phrase": "corresponding_abstract_transformer"}, {"score": 0.002448704249007665, "phrase": "program_transformation"}, {"score": 0.00232832698253493, "phrase": "data-flow_synchronous_programming_languages"}, {"score": 0.0021049977753042253, "phrase": "imperative_and_functional_programming"}], "paper_keywords": ["algorithms", " languages", " theory", " verification", " quantifier elimination", " abstract interpretation", " program transformation", " linear inequalities"], "paper_abstract": "We propose a method for automatically generating abstract transformers for static analysis by abstract interpretation. The method focuses on linear constraints on programs operating on rational, real or floating-point variables and containing linear assignments and tests. In addition to loop-free code, the same method also applies for obtaining least fixed points as functions of the precondition, which permits the analysis of loops and recursive functions. Our algorithms are based on new quantifier elimination and symbolic manipulation techniques. Given the specification of an abstract domain, and a program block, our method automatically outputs an implementation of the corresponding abstract transformer. It is thus a form of program transformation. The motivation of our work is data-flow synchronous programming languages, used for building control-command embedded systems, but it also applies to imperative and functional programming.", "paper_title": "Automatic Modular Abstractions for Linear Constraints", "paper_id": "WOS:000272013800013"}