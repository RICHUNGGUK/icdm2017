{"auto_keywords": [{"score": 0.04476011617302401, "phrase": "speculative_threads"}, {"score": 0.03249223992321251, "phrase": "best_loop_level"}, {"score": 0.0275766231024351, "phrase": "loop_speculation"}, {"score": 0.00481495049065317, "phrase": "static_greedy"}, {"score": 0.004766090327062509, "phrase": "dynamic_adaptive_thread_spawning_approach"}, {"score": 0.004717723626157272, "phrase": "loop-level_parallelism"}, {"score": 0.004669845451682529, "phrase": "thread-level_speculation"}, {"score": 0.004483120978156604, "phrase": "thread-level_parallelism"}, {"score": 0.004437613070853689, "phrase": "irregular_sequential_applications"}, {"score": 0.004152818376630929, "phrase": "expected_parallel_performance"}, {"score": 0.0036553070575015344, "phrase": "compiler-directed_performance_estimation"}, {"score": 0.003403122817578447, "phrase": "underlying_hardware_configuration"}, {"score": 0.0033685408148574876, "phrase": "program_behaviors"}, {"score": 0.0032336801561165113, "phrase": "statically_greedy_and_dynamically_adaptive_approach"}, {"score": 0.002860546817196148, "phrase": "loop_candidates"}, {"score": 0.002731971103291716, "phrase": "cost-benefit_analysis"}, {"score": 0.0027041907335656782, "phrase": "different_loop_nesting_levels"}, {"score": 0.0025433263646920364, "phrase": "runtime_loop_execution_prediction"}, {"score": 0.0022154296909169826, "phrase": "overall_performance"}, {"score": 0.0021705796895687864, "phrase": "traditional_static_loop_selection_techniques"}, {"score": 0.0021049977753042253, "phrase": "comparable_or_better_performance"}], "paper_keywords": ["thread-level speculation", " loop performance prediction", " dynamic loop selection"], "paper_abstract": "Thread-level speculation becomes more attractive for the exploitation of thread-level parallelism from irregular sequential applications. But it is common for speculative threads to fail to reach the expected parallel performance. The reason is that the performance of speculative threads is extremely complicated by the fact that it not only suffers from the imprecision of compiler-directed performance estimation due to ambiguous control and data dependences, but also depends on the underlying hardware configuration and program behaviors. Thus, this paper proposes a statically greedy and dynamically adaptive approach for loop-level speculation to dynamically determine the best loop level at runtime. It relies on the compiler to select and optimize all loop candidates greedily, which are then proceeded on the cost-benefit analysis of different loop nesting levels for the determination of the order of loop speculation. Under the runtime loop execution prediction, we dynamically schedule and update the order of loop speculation, and ensure the best loop level to be always parallelized. Two different policies are also examined to maximize overall performance. Compared with traditional static loop selection techniques, our approach can achieve comparable or better performance.", "paper_title": "A Static Greedy and Dynamic Adaptive Thread Spawning Approach for Loop-Level Parallelism", "paper_id": "WOS:000345382500003"}