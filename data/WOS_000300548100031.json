{"auto_keywords": [{"score": 0.0489928999746962, "phrase": "nominal_sets"}, {"score": 0.03718034097391593, "phrase": "data_words"}, {"score": 0.00481495049065317, "phrase": "nominal_computation"}, {"score": 0.0045464538515249085, "phrase": "different_kind"}, {"score": 0.004443276312972159, "phrase": "set_theory"}, {"score": 0.003916098498242888, "phrase": "elegant_formalism"}, {"score": 0.0037402558657576124, "phrase": "modulo_alpha-conversion"}, {"score": 0.002938317647182056, "phrase": "rudimentary_programming_language"}, {"score": 0.002711109302199029, "phrase": "key_idea"}, {"score": 0.002530359917257626, "phrase": "native_type"}, {"score": 0.002472822097373027, "phrase": "finite_sets"}, {"score": 0.0023889533502525527, "phrase": "nominal_sense"}, {"score": 0.0021049977753042253, "phrase": "short_programs"}], "paper_keywords": ["Theory", " lambda-calculus", " nominal sets", " automata on data words"], "paper_abstract": "Nominal sets are a different kind of set theory, with a more relaxed notion of finiteness. They offer an elegant formalism for describing lambda-terms modulo alpha-conversion, or automata on data words. This paper is an attempt at defining computation in nominal sets. We present a rudimentary programming language, called N lambda. The key idea is that it includes a native type for finite sets in the nominal sense. To illustrate the power of our language, we write short programs that process automata on data words.", "paper_title": "Towards Nominal Computation", "paper_id": "WOS:000300548100031"}