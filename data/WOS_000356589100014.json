{"auto_keywords": [{"score": 0.05007849175568261, "phrase": "order_violations"}, {"score": 0.03675883934633625, "phrase": "biped"}, {"score": 0.005200593743022203, "phrase": "order_violation_bugs"}, {"score": 0.004761850836420121, "phrase": "concurrency_bugs"}, {"score": 0.004657393640152439, "phrase": "system_reliability"}, {"score": 0.004031865694174726, "phrase": "concurrent_programs"}, {"score": 0.0039433581938239926, "phrase": "atomicity_violations"}, {"score": 0.0037931018103829427, "phrase": "efficient_and_effective_approaches"}, {"score": 0.0036485497734171294, "phrase": "urgent_need"}, {"score": 0.0035290250358997904, "phrase": "bidirectional_predictive_trace_analysis_approach"}, {"score": 0.003283272764794988, "phrase": "recorded_program_execution"}, {"score": 0.0031933617014256676, "phrase": "expected-order_execution_trace"}, {"score": 0.0031405975280029913, "phrase": "layered_bidirectional_prediction_model"}, {"score": 0.0030208364972341096, "phrase": "expected-order_data"}, {"score": 0.0029544572689681934, "phrase": "bottom_layer"}, {"score": 0.0028895324165046166, "phrase": "lock_sets"}, {"score": 0.002841774126940817, "phrase": "bidirectionally_order_constraints"}, {"score": 0.002794802975530612, "phrase": "upper_layer"}, {"score": 0.0026881926384093088, "phrase": "candidate_violation_intervals"}, {"score": 0.00262910358108176, "phrase": "bottom-layer_model"}, {"score": 0.0025570607111118793, "phrase": "recognized_intervals"}, {"score": 0.002486987042061596, "phrase": "upper-layer_constraint_model"}, {"score": 0.0024323098907299027, "phrase": "concrete_schedules"}, {"score": 0.0022377394845878268, "phrase": "real_order_violation_bugs"}, {"score": 0.0022007302738063566, "phrase": "analysis_speed"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_predictive_dynamic_analysis_approaches"}], "paper_keywords": ["concurrency bug", " trace model", " predictive trace analysis", " order violation"], "paper_abstract": "Concurrency bugs do significantly affect system reliability. Although many efforts have been made to address this problem, there are still many bugs that cannot be detected because of the complexity of concurrent programs. Compared with atomicity violations, order violations are always neglected. Efficient and effective approaches to detecting order violations are therefore in urgent need. This paper presents a bidirectional predictive trace analysis approach, BIPED, which can detect order violations in parallel based on a recorded program execution. BIPED collects an expected-order execution trace into a layered bidirectional prediction model, which intensively represents two types of expected-order data flows in the bottom layer and combines the lock sets and the bidirectionally order constraints in the upper layer. BIPED then recognizes two types of candidate violation intervals driven by the bottom-layer model and then checks these recognized intervals bidirectionally based on the upper-layer constraint model. Consequently, concrete schedules can be generated to expose order violation bugs. Our experimental results show that BIPED can effectively detect real order violation bugs and the analysis speed is 2.3x-10.9x and 1.24x-1.8x relative to the state-of-the-art predictive dynamic analysis approaches and hybrid model based static prediction analysis approaches in terms of order violation bugs.", "paper_title": "Biped: Bidirectional Prediction of Order Violations", "paper_id": "WOS:000356589100014"}