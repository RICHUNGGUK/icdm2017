{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "preference_list"}, {"score": 0.044692387059559566, "phrase": "matching_m"}, {"score": 0.024809870214147014, "phrase": "preference_lists"}, {"score": 0.004701825207431857, "phrase": "nonempty_subset"}, {"score": 0.0034101316738399203, "phrase": "first_polynomial-time_algorithms"}, {"score": 0.003251552926963083, "phrase": "popular_matching"}, {"score": 0.0031561961485589633, "phrase": "largest_such_matching"}, {"score": 0.003009390313137981, "phrase": "special_case"}, {"score": 0.002532035301903554, "phrase": "total_number"}, {"score": 0.002399850604120431, "phrase": "total_length"}, {"score": 0.0022745508619577927, "phrase": "general_case"}, {"score": 0.0021049977753042253, "phrase": "time_algorithm"}], "paper_keywords": ["matchings", " bipartite graphs", " one-sided preference lists"], "paper_abstract": "We consider the problem of matching a set of applicants to a set of posts, where each applicant has a preference list, ranking a nonempty subset of posts in order of preference, possibly involving ties. We say that a matching M is popular if there is no matching M' such that the number of applicants preferring M' to M exceeds the number of applicants preferring M to M'. In this paper, we give the first polynomial-time algorithms to determine if an instance admits a popular matching and to find a largest such matching, if one exists. For the special case in which every preference list is strictly ordered (i. e., contains no ties), we give an O(n + m) time algorithm, where n is the total number of applicants and posts and m is the total length of all of the preference lists. For the general case in which preference lists may contain ties, we give an O(root nm) time algorithm.", "paper_title": "Popular matchings", "paper_id": "WOS:000252844100003"}