{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "key_methods"}, {"score": 0.004730458558634266, "phrase": "scalable_quantitative_analysis"}, {"score": 0.004674952036988355, "phrase": "functional_correctness"}, {"score": 0.004620093797504386, "phrase": "low-level_operating-system"}, {"score": 0.00443308765153716, "phrase": "indispensable_requirement"}, {"score": 0.004228577663320847, "phrase": "quantitative_aspects"}, {"score": 0.004105558123159003, "phrase": "energy_efficiency"}, {"score": 0.003735349093835257, "phrase": "probabilistic_model-checking_techniques"}, {"score": 0.0036481158025940016, "phrase": "quantitative_long-run_behaviour"}, {"score": 0.0036052633308076933, "phrase": "low-level_os-code"}, {"score": 0.0034388111429203222, "phrase": "case_study"}, {"score": 0.0031100973266506163, "phrase": "high-level_models"}, {"score": 0.0030195184114140063, "phrase": "realistic_systems"}, {"score": 0.0028800314406626022, "phrase": "future_system_behaviour"}, {"score": 0.0027469703311742647, "phrase": "nearly_perfect_match"}, {"score": 0.0027146742941153443, "phrase": "analytic_results"}, {"score": 0.0025892330566358503, "phrase": "state-explosion_problem"}, {"score": 0.0025436978068459565, "phrase": "model-checking_results"}, {"score": 0.002498961351132696, "phrase": "large_number"}, {"score": 0.0023003498123420237, "phrase": "valuable_insights"}, {"score": 0.002259883463607508, "phrase": "delicate_interplay"}, {"score": 0.002233301265743633, "phrase": "lock_load"}, {"score": 0.0022070310530794097, "phrase": "average_spinning_times"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Probabilistic model checking", " Measure-based quantitative analysis", " Low-level operating system code", " Test-and-test-and-set spinlock", " Conditional long-run probabilities", " Quantile-based queries", " Symmetry reduction"], "paper_abstract": "Functional correctness of low-level operating-system (OS) code is an indispensable requirement. However, many applications rely also on quantitative aspects such as speed, energy efficiency, resilience with regards to errors and other cost factors. We report on our experiences of applying probabilistic model-checking techniques for analysing the quantitative long-run behaviour of low-level OS-code. Our approach, illustrated in a case study analysing a simple test-and-test-and-set (TTS) spinlock protocol, combines measure-based simulation with probabilistic model-checking to obtain high-level models of the performance of realistic systems and to tune the models to predict future system behaviour. We report how we obtained a nearly perfect match of analytic results and measurements and how we tackled the state-explosion problem to obtain model-checking results for a large number of processes where measurements are no longer feasible. These results gave us valuable insights in the delicate interplay between lock load, average spinning times and other performance measures. (c) 2014 Elsevier Inc. All rights reserved.", "paper_title": "Locks: Picking key methods for a scalable quantitative analysis", "paper_id": "WOS:000342481400019"}