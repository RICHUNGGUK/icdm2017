{"auto_keywords": [{"score": 0.04915478659311388, "phrase": "ts"}, {"score": 0.007665559052428622, "phrase": "tabu_search"}, {"score": 0.004815015411722131, "phrase": "generic"}, {"score": 0.004642105253191792, "phrase": "combinatorial_optimization_problems"}, {"score": 0.004585873765376289, "phrase": "existing_implementations"}, {"score": 0.004293737181845561, "phrase": "sequential_setting"}, {"score": 0.004241707618476644, "phrase": "reported_parallel_implementations"}, {"score": 0.004169919277461685, "phrase": "sequential_implementations"}, {"score": 0.00410935022329555, "phrase": "computing_resources"}, {"score": 0.00406945841245389, "phrase": "lan_environments"}, {"score": 0.00399082814879396, "phrase": "parallel_implementations"}, {"score": 0.003885176600463076, "phrase": "computer_science"}, {"score": 0.0038287275986210543, "phrase": "control_theory"}, {"score": 0.003700170452390401, "phrase": "parallel_programming"}, {"score": 0.0036286495901153605, "phrase": "generic_implementation"}, {"score": 0.003558506222096925, "phrase": "sequential_and_parallel_settings"}, {"score": 0.0035325522020551, "phrase": "key_point"}, {"score": 0.00343060885627576, "phrase": "algorithmic_skeleton"}, {"score": 0.003157415782206435, "phrase": "problem-dependent_elements"}, {"score": 0.003066264912163443, "phrase": "fixed_interface"}, {"score": 0.003051330222508351, "phrase": "purely_sequential_constructs"}, {"score": 0.002992313172550772, "phrase": "unique_interface"}, {"score": 0.002934434236130622, "phrase": "concrete_problems"}, {"score": 0.0028566690159084183, "phrase": "straightforward_way"}, {"score": 0.00284275228258112, "phrase": "different_parallel_implementations"}, {"score": 0.0026162496764252936, "phrase": "computation_efficiency"}, {"score": 0.002565626044684815, "phrase": "fast_development"}, {"score": 0.0025531235447463665, "phrase": "problem_instantiations"}, {"score": 0.002467291259815224, "phrase": "different_ways"}, {"score": 0.002461271691636336, "phrase": "internal_methods"}, {"score": 0.002372716464594954, "phrase": "good_quality_results"}, {"score": 0.0023324855762635616, "phrase": "ad_hoc_implementations"}, {"score": 0.002237592712694882, "phrase": "standard_benchmarks"}, {"score": 0.002141313358342847, "phrase": "resulting_program"}, {"score": 0.0021308741505380296, "phrase": "high_quality-solutions"}, {"score": 0.0021049977753042253, "phrase": "optimal_ones"}], "paper_keywords": ["combinatorial optimization", " algorithmic skeletons", " Tabu Search", " 0-1 multi-dimensional knapsack"], "paper_abstract": "Tabu Search (TS) is a meta-heuristic for solving combinatorial optimization problems. A review of existing implementations for TS reveals that, on the one hand, these implementations are ad hoc and, on the other hand, most of them run in a sequential setting. Indeed, the reported parallel implementations are few as compared to the sequential implementations. Due to increase in computing resources, especially in LAN environments, it is quite desirable to obtain parallel implementations of TS for solving problems arising in fields others than computer science, such as biology, control theory, etc., in which researchers and practitioners are less familiar with parallel programming. In this work we present a generic implementation of TS able to be run in sequential and parallel settings. The key point in our approach is the design and implementation in C++ of an algorithmic skeleton for TS embedding its main flow as well as several parallel implementations for the method. This is achieved through a separation of concerns: elements related to TS are provided by the skeleton, whereas the problem-dependent elements are expected to be provided by the user according to a fixed interface using purely sequential constructs. Thus, the skeleton has a unique interface but is expected to have many instantiations for concrete problems, all of them being able to run in a straightforward way using different parallel implementations. In order to assess the effectiveness of our approach, we have applied it to several NP-hard combinatorial optimization problems. We have considered developing time, flexibility and ease of use, quality of solutions and computation efficiency. We have observed that our approach allows fast development of problem instantiations. Moreover, the skeleton allows the user to configure and implement in different ways internal methods related to TS. Furthermore, the results obtained by our generic parallel implementations are efficient and report good quality results compared to the ones reported by ad hoc implementations. We exemplify our approach through the application to the 0-1 Multi-dimensional Knapsack problem. The experimental results obtained for standard benchmarks of this problem show that, in spite of the genericity and flexibility of our implementation, the resulting program provides high quality-solutions very close to the optimal ones.", "paper_title": "Generic parallel implementations for Tabu Search", "paper_id": "WOS:000243956900003"}