{"auto_keywords": [{"score": 0.04373932371398143, "phrase": "compiler-directed_prefetching"}, {"score": 0.015626023276806147, "phrase": "data_mining_applications"}, {"score": 0.005933127106985681, "phrase": "multithreaded_execution"}, {"score": 0.00481495049065317, "phrase": "compiler-directed_prefetching_on_data_mining"}, {"score": 0.004762893197005439, "phrase": "today's_increasingly_power-constrained_multicore_systems"}, {"score": 0.004576763709613412, "phrase": "order_cores"}, {"score": 0.004397875849247165, "phrase": "complex_hardware_support"}, {"score": 0.004350308086118336, "phrase": "long-latency_memory_accesses"}, {"score": 0.004016782710006123, "phrase": "application_side"}, {"score": 0.003973320429450603, "phrase": "large_class"}, {"score": 0.00393032656248792, "phrase": "centric_applications"}, {"score": 0.0038457240885563146, "phrase": "underlying_properties"}, {"score": 0.003804105622385469, "phrase": "explosively_growing_data"}, {"score": 0.0036953036453370087, "phrase": "traditional_benchmarks"}, {"score": 0.0036288825833675127, "phrase": "substantial_thread-level_parallelism"}, {"score": 0.0036026484429137998, "phrase": "complex_and_unpredictable_control_flow"}, {"score": 0.003537886893587656, "phrase": "intensive_and_irregular_memory_access_patterns"}, {"score": 0.003424225677958491, "phrase": "dominating_workloads"}, {"score": 0.003399466007862412, "phrase": "future_microprocessors"}, {"score": 0.0031960852616842207, "phrase": "in-order_multicore_systems"}, {"score": 0.003115908199991072, "phrase": "properly_inserted_prefetch_instructions"}, {"score": 0.003059869469624301, "phrase": "memory_access_latencies"}, {"score": 0.002814759530655965, "phrase": "complex_control_flow"}, {"score": 0.0027943943921568456, "phrase": "memory_access"}, {"score": 0.002655894070657161, "phrase": "single_die"}, {"score": 0.0025518930446603335, "phrase": "prefetch_instructions"}, {"score": 0.0024788167298469455, "phrase": "single-threaded_execution"}, {"score": 0.0023051296931856265, "phrase": "performance_bottlenecks"}, {"score": 0.0022228943786652914, "phrase": "dynamic_performance_tuning_techniques"}, {"score": 0.0021049977753042253, "phrase": "aggressive_optimizations"}], "paper_keywords": ["Multicore", " data mining", " prefetching", " compilers", " optimization"], "paper_abstract": "For today's increasingly power-constrained multicore systems, integrating simpler and more energy-efficient in-order cores becomes attractive. However, since in-order processors lack complex hardware support for tolerating long-latency memory accesses, developing compiler technologies to hide such latencies becomes critical. Compiler-directed prefetching has been demonstrated effective on some applications. On the application side, a large class of data centric applications has emerged to explore the underlying properties of the explosively growing data. These applications, in contrast to traditional benchmarks, are characterized by substantial thread-level parallelism, complex and unpredictable control flow, as well as intensive and irregular memory access patterns. These applications are expected to be the dominating workloads on future microprocessors. Thus, in this paper, we investigated the effectiveness of compiler-directed prefetching on data mining applications in in-order multicore systems. Our study reveals that although properly inserted prefetch instructions can often effectively reduce memory access latencies for data mining applications, the compiler is not always able to exploit this potential. Compiler-directed prefetching can become inefficient in the presence of complex control flow and memory access patterns; and architecture dependent behaviors. The integration of multithreaded execution onto a single die makes it even more difficult for the compiler to insert prefetch instructions, since optimizations that are effective for single-threaded execution may or may not be effective in multithreaded execution. Thus, compiler-directed prefetching must be judiciously deployed to avoid creating performance bottlenecks that otherwise do not exist. Our experiences suggest that dynamic performance tuning techniques that adjust to the behaviors of a program can potentially facilitate the deployment of aggressive optimizations in data mining applications.", "paper_title": "EFFECTIVENESS OF COMPILER-DIRECTED PREFETCHING ON DATA MINING BENCHMARKS", "paper_id": "WOS:000305249100007"}