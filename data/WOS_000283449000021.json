{"auto_keywords": [{"score": 0.04318433045612149, "phrase": "c."}, {"score": 0.00481495049065317, "phrase": "list_size"}, {"score": 0.004768649568826951, "phrase": "list_decoding"}, {"score": 0.004700027722284931, "phrase": "q-ary_error-correcting_code_c_subset"}, {"score": 0.004329331617724, "phrase": "list_size_l"}, {"score": 0.004267004541988167, "phrase": "hamming_ball"}, {"score": 0.004225950334493496, "phrase": "radius_rho"}, {"score": 0.003987755561492638, "phrase": "q-ary_code"}, {"score": 0.0024575743537282686, "phrase": "blinovsky"}, {"score": 0.0024224481033945943, "phrase": "problems_of_information_transmission"}, {"score": 0.0021881743793875767, "phrase": "alphabet_sizes"}, {"score": 0.0021049977753042253, "phrase": "lower_bound"}], "paper_keywords": ["Bounds on codes", " list decoding", " probabilistic method", " random codes", " randomness extractors"], "paper_abstract": "A q-ary error-correcting code C subset of {1 2,...,q}(n) is said to be list decodable to radius rho with list size L if every Hamming ball of radius rho contains at most L codewords of C. We prove that in order for q-ary code to be list-decodable up to radius (1 - 1/q)(1 - epsilon)n, we must have L = ohm(1/epsilon(2)). Specifically we prove that there exists a constant c(q) > 0 and a function f(q) such that for small enough epsilon > 0, if C is list-decodable to radius (1 - 1/q)(1 - epsilon)n with list size c(q)/epsilon(2) then C has at most f(q)(epsilon) codewords independent of n. This result is asymptotically tight (treating q as a constant) since such codes with an exponential (in n) number of codewords are known for list size L = O(1/epsilon(2)). A result similar to ours is implicit in Blinovsky (Problems of Information Transmission, 1986) for the binary (q = 2) case. Our proof is simpler and works for all alphabet sizes, and provides more intuition for why the lower bound arises.", "paper_title": "A Lower Bound on List Size for List Decoding", "paper_id": "WOS:000283449000021"}