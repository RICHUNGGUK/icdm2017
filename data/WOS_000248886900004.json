{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "chapel"}, {"score": 0.004442032546224076, "phrase": "productivity_challenges"}, {"score": 0.0043533862892678864, "phrase": "parallel_programmers"}, {"score": 0.004139401327448807, "phrase": "parallel_language_design"}, {"score": 0.003975781274672803, "phrase": "end-user_productivity"}, {"score": 0.003780286517897356, "phrase": "candidate_list"}, {"score": 0.003704797078215222, "phrase": "desirable_qualities"}, {"score": 0.003594369823549604, "phrase": "parallel_programming_language"}, {"score": 0.0031208772639433145, "phrase": "chapel_language"}, {"score": 0.0025761937402886954, "phrase": "parallel_productivity"}, {"score": 0.0024493494346360415, "phrase": "current_techniques"}, {"score": 0.002400373755068185, "phrase": "parallel_programming"}], "paper_keywords": ["parallel languages", " productivity", " parallel programming", " programming models", " Chapel"], "paper_abstract": "In this paper we consider productivity challenges for parallel programmers and explore ways that parallel language design might help improve end-user productivity. We offer a candidate list of desirable qualities for a parallel programming language, and describe how these qualities are addressed in the design of the Chapel language. In doing so, we provide an overview of Chapel's features an how they help address parallel productivity. We also survey current techniques for parallel programming and describe ways in which we consider them to fall short of our idealized productive programming model.", "paper_title": "Parallel programmability and the Chapel language", "paper_id": "WOS:000248886900004"}