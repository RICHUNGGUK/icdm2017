{"auto_keywords": [{"score": 0.004657393640152439, "phrase": "unifying_abstraction"}, {"score": 0.004580550308652044, "phrase": "data_management"}, {"score": 0.004504969093304219, "phrase": "different_physical_representations"}, {"score": 0.004145287175409325, "phrase": "particular_representation"}, {"score": 0.004076858589744185, "phrase": "logical_data"}, {"score": 0.0035486713647627246, "phrase": "data-specific_policy"}, {"score": 0.002905629026254221, "phrase": "qufile_abstraction"}, {"score": 0.002810373366887749, "phrase": "six_case_studies"}, {"score": 0.0021049977753042253, "phrase": "application-level_file_system"}], "paper_keywords": ["Design", " Performance", " Context-aware file systems", " data management", " distributed storage", " copy-on-write versions"], "paper_abstract": "A quFile is a unifying abstraction that simplifies data management by encapsulating different physical representations of the same logical data. Similar to a quBit (quantum bit), the particular representation of the logical data displayed by a quFile is not determined until the moment it is needed. The representation returned by a quFile is specified by a data-specific policy that can take context into account such as the application requesting the data, the device on which data is accessed, screen size, and battery status. We demonstrate the generality of the quFile abstraction by using it to implement six case studies: resource management, copy-on-write versioning, data redaction, resource-aware directories, application-aware adaptation, and platform-specific encoding. Most quFile policies were expressed using less than one hundred lines of code. Our experimental results show that, with caching and other performance optimizations, quFiles add less than 1% overhead to application-level file system.", "paper_title": "quFiles: The Right File at the Right Time", "paper_id": "WOS:000208424800005"}