{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "performance_portability"}, {"score": 0.004081385289516914, "phrase": "nas_parallel_benchmark_suite"}, {"score": 0.003901407184706592, "phrase": "design_decisions"}, {"score": 0.003485304124598714, "phrase": "memory_arrangement"}, {"score": 0.0032817813775647756, "phrase": "different_device_types"}, {"score": 0.0030901063954739375, "phrase": "single_source_application"}, {"score": 0.002931569771634119, "phrase": "different_architectures"}, {"score": 0.0025989960809479104, "phrase": "multiple_nodes"}, {"score": 0.0024842242921857705, "phrase": "potential_performance_gains"}, {"score": 0.002447101794397243, "phrase": "opencl's_device"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Many-core computing", " GPU computing", " Optimisation", " OpenCL", " High performance computing"], "paper_abstract": "This paper reports on the development of an MPI/OpenCL implementation of LU, an application-level benchmark from the NAS Parallel Benchmark Suite. An account of the design decisions addressed during the development of this code is presented, demonstrating the importance of memory arrangement and work-item/work-group distribution strategies when applications are deployed on different device types. The resulting platform-agnostic, single source application is benchmarked on a number of different architectures, and is shown to be 1.3-1.5x slower than native FORTRAN 77 or CUDA implementations on a single node and 1.3-3.1x slower on multiple nodes. We also explore the potential performance gains of OpenCL's device fissioning capability, demonstrating up to a 3 x speed-up over our original OpenCL implementation. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "An investigation of the performance portability of OpenCL", "paper_id": "WOS:000325447100004"}