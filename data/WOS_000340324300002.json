{"auto_keywords": [{"score": 0.04205963193676696, "phrase": "red-black_tree"}, {"score": 0.00481495049065317, "phrase": "relative_node_keys"}, {"score": 0.004185632403886255, "phrase": "ordered_list"}, {"score": 0.003848088904418221, "phrase": "node_keys"}, {"score": 0.002787181295054319, "phrase": "relative_key_values"}, {"score": 0.0025264171945423254, "phrase": "relative_keys"}, {"score": 0.002456486927713543, "phrase": "neighboring_nodes"}, {"score": 0.0023551955270737215, "phrase": "constant_overhead"}, {"score": 0.002195552442011313, "phrase": "logarithmic_time_complexity"}, {"score": 0.0021049977753042253, "phrase": "original_operations"}], "paper_keywords": ["Data structures", " Algorithms", " Search trees", " Red-black trees", " Relative keys"], "paper_abstract": "This paper addresses the problem of storing an ordered list using a red-black tree, where node keys can only be expressed relative to each other. The insert and delete operations in a red-black tree are extended to maintain the relative key values. The extensions rely only on relative keys of neighboring nodes, adding constant overhead and thus preserving the logarithmic time complexity of the original operations. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Red-black trees with relative node keys", "paper_id": "WOS:000340324300002"}