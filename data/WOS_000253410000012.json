{"auto_keywords": [{"score": 0.02598468129300402, "phrase": "smalltalk"}, {"score": 0.00481495049065317, "phrase": "unanticipated_name_clashes"}, {"score": 0.004294381488413906, "phrase": "multiple_inheritance"}, {"score": 0.0037495207047193034, "phrase": "different_method"}, {"score": 0.0033437537557378157, "phrase": "freezeable_traits"}, {"score": 0.00327356326590461, "phrase": "expressive_composition_mechanism"}, {"score": 0.0032321559007422087, "phrase": "unanticipated_method_composition_conflicts"}, {"score": 0.0031643005824589917, "phrase": "private_trait_methods"}, {"score": 0.0031110402375026016, "phrase": "class_composer_change_method_visibility"}, {"score": 0.0028822153400215973, "phrase": "different_composition_policies"}, {"score": 0.002750721367040336, "phrase": "mainstream_languages"}, {"score": 0.0026252106881752067, "phrase": "class_composer"}, {"score": 0.0024632148715152393, "phrase": "freezable_traits"}, {"score": 0.002177762848946681, "phrase": "compile-time_bytecode_manipulation"}, {"score": 0.0021049977753042253, "phrase": "run-time_penalties"}], "paper_keywords": ["languages", " dynamic typing", " traits", " encapsulation", " information hiding", " composition"], "paper_abstract": "A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezeable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts. Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.", "paper_title": "User-changeable visibility: Resolving unanticipated name clashes in traits", "paper_id": "WOS:000253410000012"}