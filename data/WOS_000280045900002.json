{"auto_keywords": [{"score": 0.03332335444932379, "phrase": "lambda_expressions"}, {"score": 0.00481495049065317, "phrase": "higher-order_functions"}, {"score": 0.004580326255788704, "phrase": "stl"}, {"score": 0.00451043437607004, "phrase": "standard_library"}, {"score": 0.004357061494162031, "phrase": "stl_algorithms"}, {"score": 0.004323690117778359, "phrase": "function_parameters"}, {"score": 0.0042250952759280225, "phrase": "gui_events"}, {"score": 0.003912335018240945, "phrase": "function_objects"}, {"score": 0.0037215192436590772, "phrase": "function's_definition"}, {"score": 0.003485913728272778, "phrase": "full_advantage"}, {"score": 0.0034194902384248006, "phrase": "effective_use"}, {"score": 0.00334144503360907, "phrase": "concise_mechanism"}, {"score": 0.0033030907500120397, "phrase": "small_one-off_functions"}, {"score": 0.0030349168871027558, "phrase": "language_support"}, {"score": 0.002820850247525606, "phrase": "automatic_object_lifetime_management"}, {"score": 0.0027992118597278087, "phrase": "safe_lambda_functions"}, {"score": 0.0026218430041123164, "phrase": "closure_dangle"}, {"score": 0.0025034338848015187, "phrase": "explicit_annotations"}, {"score": 0.002446245096967702, "phrase": "presented_design"}, {"score": 0.0023995846112991625, "phrase": "draft_specification"}, {"score": 0.00237201560368486, "phrase": "forthcoming_major_revision"}, {"score": 0.0022388390432214415, "phrase": "lambda_functions"}, {"score": 0.0022046030435199796, "phrase": "clear_benefits"}, {"score": 0.0021708894366462153, "phrase": "reduced_code_size"}, {"score": 0.002154226045704907, "phrase": "improved_clarity"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["C plus", " Closures", " Lambda expressions"], "paper_abstract": "A style of programming that uses higher-order functions has become common in C++, following the introduction of the Standard Template Library (STL) into the standard library. In addition to their utility as arguments to STL algorithms, function parameters are useful as callbacks on GUI events, defining tasks to be executed in a thread, and so forth. C++'s mechanisms for defining functions or function objects are, however, rather verbose, and they often force the function's definition to be placed far from its use. As a result, C++ frustrates programmers in taking full advantage of its own standard libraries. The effective use of modern C++ libraries calls for a concise mechanism for defining small one-off functions in the language, a need that can be fulfilled with lambda expressions. This paper describes a design and implementation of language support for lambda expressions in C++. C++'s compilation model, where activation records are maintained in a stack, and the lack of automatic object lifetime management make safe lambda functions and closures challenging: if a closure outlives its scope of definition, references stored in a closure dangle. Our design is careful to balance between conciseness of syntax and explicit annotations to guarantee safety. The presented design is included in the draft specification of the forthcoming major revision of the ISO C++ standard, dubbed C++0x. In rewriting typical C++ programs to take advantage of lambda functions, we observed clear benefits, such as reduced code size and improved clarity. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "C++ lambda expressions and closures", "paper_id": "WOS:000280045900002"}