{"auto_keywords": [{"score": 0.04650901009291314, "phrase": "soft_errors"}, {"score": 0.00481495049065317, "phrase": "random_variations"}, {"score": 0.004775918707955445, "phrase": "low_reliability"}, {"score": 0.004737201825299411, "phrase": "nanometer_new_silicons"}, {"score": 0.00462291551375938, "phrase": "fault-tolerant_design"}, {"score": 0.004585433265422727, "phrase": "large-area_powerful_integrated_circuits"}, {"score": 0.004420472010542188, "phrase": "transient_faults"}, {"score": 0.004366808573435364, "phrase": "serious_problems"}, {"score": 0.004331393784852601, "phrase": "embedded_processing_cores"}, {"score": 0.004226856126282259, "phrase": "embedded_processor"}, {"score": 0.004175533280178052, "phrase": "specific_custom_instructions"}, {"score": 0.003848886045448135, "phrase": "augmented_processor"}, {"score": 0.003771282384646587, "phrase": "efficient_custom_instruction_selection"}, {"score": 0.003562186600028245, "phrase": "exhaustive_fault_injection"}, {"score": 0.0035332741328861776, "phrase": "lengthy_and_expensive_simulations"}, {"score": 0.0030386598795433474, "phrase": "analytical_modeling_solution"}, {"score": 0.002953164020173741, "phrase": "simple_analytical_method"}, {"score": 0.0028351712509358997, "phrase": "custom_instruction"}, {"score": 0.0028006988338192375, "phrase": "time-saving_manner"}, {"score": 0.002623783458189614, "phrase": "word_length"}, {"score": 0.002581324549141829, "phrase": "different_custom_instruction_subgraphs"}, {"score": 0.0025189177411152645, "phrase": "extensible_processor"}, {"score": 0.002321563536990284, "phrase": "custom_functional_units"}, {"score": 0.0022933216359142736, "phrase": "different_vulnerabilities"}, {"score": 0.0021748483128942687, "phrase": "operand_types"}, {"score": 0.0021571717917276724, "phrase": "also_the_custom_functional_unit_structures"}, {"score": 0.0021222476760114914, "phrase": "acceptable_vulnerability_level"}, {"score": 0.0021049977753042253, "phrase": "low_computational_and_design_time_costs"}], "paper_keywords": ["Instruction set extension", " Custom instruction", " Vulnerability analysis", " Analytic method", " Architectural vulnerability factor", " Soft error"], "paper_abstract": "Random variations and low reliability of nanometer new silicons are the most important concerns for the fault-tolerant design of large-area powerful integrated circuits. Logic faults in terms of soft errors or transient faults are now serious problems for embedded processing cores. Recently, augmenting an embedded processor with application specific custom instructions is widely used for improving the performance of a processor. Although area, power, and performance of an augmented processor have been considered for efficient custom instruction selection, its reliability consideration is much needed. This is impeding because this action needs exhaustive fault injection and lengthy and expensive simulations. This demand becomes more serious in the case of many-core, larger area and, therefore, more fault-prone integrated circuits, e.g., tera-computing processors. In this work, we propose an analytical modeling solution for such a demanding problem. First, a simple analytical method is introduced that can evaluate the vulnerability of a custom instruction in a time-saving manner. Using this method and our configurable custom instruction vulnerability analysis framework, the effects of type, order, and word length of various operations of different custom instruction subgraphs on the vulnerability of an extensible processor have been explored analytically and experimentally. Based on our results, for example, replacing orders of operators in custom functional units could yield different vulnerabilities to soft errors. Therefore, our approach enables designers to optionally constrain the operand types and also the custom functional unit structures to reach an acceptable vulnerability level at low computational and design time costs.", "paper_title": "An analytical method for reliability aware instruction set extension", "paper_id": "WOS:000329111400006"}