{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "java_generics"}, {"score": 0.004234884779773412, "phrase": "unknown_type"}, {"score": 0.003694652993546994, "phrase": "different_code_definition"}, {"score": 0.003549245218355768, "phrase": "trade-_offs"}, {"score": 0.0034926916198124484, "phrase": "multiple_axes"}, {"score": 0.0029268619875960715, "phrase": "language_design"}, {"score": 0.002880196765572443, "phrase": "sophisticated_users"}, {"score": 0.0026577673946415583, "phrase": "fine_granularity"}, {"score": 0.002299689297293321, "phrase": "abstraction_layer"}, {"score": 0.002244876254113051, "phrase": "compi-_lation"}, {"score": 0.0021049977753042253, "phrase": "java_compiler"}], "paper_keywords": ["mixins", " reification", " type annotation", " pluggable types"], "paper_abstract": "Java generics are compiled by-erasure: all clients reuse the same bytecode, with uses of the unknown type erased. C++ templates are compiled by-expansion: each type-instantiation of a template pro- duces a different code definition. The two approaches offer trade- offs on multiple axes. We propose an extension of Java generics that allows by-expansion translation relative to selected type pa- rameters only. This language design allows sophisticated users to get the best of both worlds at a fine granularity. Furthermore, our proposal is based on Java 8 Type Annotations (JSR 308) and the Checker Framework as an abstraction layer for controlling compi- lation without changes to the internals of a Java compiler.", "paper_title": "Reified Type Parameters Using Java Annotations", "paper_id": "WOS:000338625500008"}