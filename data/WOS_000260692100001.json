{"auto_keywords": [{"score": 0.04427417173634225, "phrase": "nested_loops"}, {"score": 0.02322730111336097, "phrase": "code_size"}, {"score": 0.01005579919605392, "phrase": "execution_time"}, {"score": 0.008214307639536149, "phrase": "loop_transformation"}, {"score": 0.007941725107798243, "phrase": "computation_time"}, {"score": 0.007704083090310493, "phrase": "execution_sequence"}, {"score": 0.006441251966667716, "phrase": "spine"}, {"score": 0.004782455247247007, "phrase": "embedded_systems"}, {"score": 0.004750178261675602, "phrase": "strict_timing_and_code_size_requirements"}, {"score": 0.004439097815805505, "phrase": "successive_loop_iterations"}, {"score": 0.004335081499311714, "phrase": "effective_techniques"}, {"score": 0.004262273304740847, "phrase": "software_pipelining_problem"}, {"score": 0.004190682785437681, "phrase": "existing_software_pipelining_techniques"}, {"score": 0.0040373708328770306, "phrase": "innermost_loop"}, {"score": 0.003983016985197904, "phrase": "final_timing_performance"}, {"score": 0.003863370968575808, "phrase": "outer_loop_parallelism"}, {"score": 0.0038113506617834087, "phrase": "large_overheads"}, {"score": 0.0037856027705164817, "phrase": "loop_index_generation"}, {"score": 0.0035374660789922715, "phrase": "pipelined_nested_loop"}, {"score": 0.003057503388220776, "phrase": "software_pipelining_degree"}, {"score": 0.0030265495849271617, "phrase": "nested_loop"}, {"score": 0.003006087482938274, "phrase": "retiming_concepts"}, {"score": 0.002966005573888038, "phrase": "software"}, {"score": 0.0028472791870440065, "phrase": "fundamental_understanding"}, {"score": 0.0027429789393362703, "phrase": "spine-full_algorithm"}, {"score": 0.002724428781940696, "phrase": "fully_parallelized_loops"}, {"score": 0.002696837864985637, "phrase": "minimal_overheads"}, {"score": 0.002669525619637691, "phrase": "spine-row-wise_algorithm"}, {"score": 0.0025804616931593897, "phrase": "fixed_row-wise_execution_sequence"}, {"score": 0.002427549902743566, "phrase": "imperfect_nested_loops"}, {"score": 0.0024029583021102255, "phrase": "experimental_results"}, {"score": 0.002370555661688831, "phrase": "average_improvement"}, {"score": 0.002322767202375341, "phrase": "pipelined_loop"}, {"score": 0.0022300545742463262, "phrase": "standard_software_pipelining_technique"}, {"score": 0.0022074592164608134, "phrase": "average_code_size"}, {"score": 0.002126546582044807, "phrase": "md_retiming_technique"}], "paper_keywords": [""], "paper_abstract": "Embedded systems have strict timing and code size requirements. Software pipelining is one of the most important optimization techniques to improve the execution time of loops by increasing the parallelism among successive loop iterations. However, there is no effective techniques exist for solving the software pipelining problem on nested loops. The existing software pipelining techniques for single loops can only explore the parallelism of the innermost loop, so the final timing performance is inferior. While multidimensional (MD) retiming can explore the outer loop parallelism, it introduces large overheads in loop index generation and code size due to loop transformation. In this paper, we show how the computation time and code size of a pipelined nested loop is affected by execution sequence and retiming, assuming there is no loop unfolding. We present the theory of Software PIpelining for NEsted loops (SPINE) to reveal the relationship among the computation time of an iteration, the execution sequence, and the software pipelining degree of a nested loop using retiming concepts. Two algorithms of Software PIpelining for NEsted loops (SPINE) are proposed based on the fundamental understanding of the properties of software pipelining for nested loops: the SPINE-FULL algorithm generates fully parallelized loops with the minimal overheads. The SPINE-ROW-WISE algorithm achieves the maximal parallelism in an iteration with a fixed row-wise execution sequence. Therefore, the overheads due to loop transformation are minimal. Our technique can be directly applied to imperfect nested loops. The experimental results show that the average improvement on the execution time of the pipelined loop generated by SPINE is 71.7% compared with that generated by the standard software pipelining technique. The average code size is reduced by 69.5% compared with that generated by the MD retiming technique. (c) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Timing optimization via nest-loop pipelining considering code size", "paper_id": "WOS:000260692100001"}