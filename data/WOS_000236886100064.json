{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "ion-restricted_substring_searching"}, {"score": 0.004783400286017588, "phrase": "full-text_index"}, {"score": 0.004752055828514541, "phrase": "data_structure"}, {"score": 0.0047105809740660125, "phrase": "text_string"}, {"score": 0.004568235944625188, "phrase": "pattern_string"}, {"score": 0.003265908639713106, "phrase": "first_solution"}, {"score": 0.0031393948330209255, "phrase": "constant_time"}, {"score": 0.0030177670428019557, "phrase": "second_solution"}, {"score": 0.0027701180719246305, "phrase": "alphabet_size"}, {"score": 0.0027519296831540786, "phrase": "second_structure"}, {"score": 0.0025204989588388247, "phrase": "i-th_occurrence"}, {"score": 0.0024989454304429866, "phrase": "t."}, {"score": 0.0024334576011293845, "phrase": "rank_queries"}, {"score": 0.0023858213207279258, "phrase": "character_select"}, {"score": 0.0023701501986525446, "phrase": "select_queries"}, {"score": 0.0022385645252262056, "phrase": "alternative_implementation"}, {"score": 0.0022238584942804473, "phrase": "well-known_two-dimensional_range_search_data_structure"}, {"score": 0.002214110373792296, "phrase": "chazelle"}, {"score": 0.0021851119739828913, "phrase": "grossi_et_al"}, {"score": 0.002170756330376191, "phrase": "wavelet_trees"}, {"score": 0.0021049977753042253, "phrase": "chazelle's_data_structure"}], "paper_keywords": [""], "paper_abstract": "A full-text index is a data structure built over a text string T[1, n]. The most basic functionality provided is (a) counting bow many times a pattern string P[l,m] appears in T and (b) locating all those occ positions. There exist several indexes that solve (a) in 0(m) time and (b) in 0(occ) time. In this paper we propose two new queries, (c) counting how many times P[1, m] appears in T[l, r] and (d) locating all those occ(l,r) positions. These can be solved using (a) and (b) but this requires 0(occ) time. We present two solutions to (c) and (d) in this paper. The first is an index that requires O(n log n) bits of space and answers (c) in O(m + log n) time and (d) in O(log n) time per occurrence (that is, O(occ(l,r) log n) time overall). A variant of the first solution answers (c) in 0(m + log log n) time and (d) in constant time per occurrence, but requires 0(n logl + n) bits of space for any constant epsilon > 0. The second solution requires O(nm log sigma) bits of space, solving (c) in O(m [log sigma log log n]) time and (d) in O(m [log sigma/ log log n]) time per occurrence, where sigma is the alphabet size. This second structure takes less space when the text is compressible. Our solutions can be seen as a generalization of rank and select dictionaries, which allow computing how many times a given character c appears in a prefix T[1, i] and also locate the i-th occurrence of c in T. Our solution to (c) extends character rank queries to substring rank queries, and our solution to (d) extends character select to substring select queries. As a byproduct, we show how rank queries can be used to implement fractional cascading in little space, so as to obtain an alternative implementation of a well-known two-dimensional range search data structure by Chazelle. We also show how Grossi et al.'s wavelet trees are suitable for two-dimensional range searching, and their connection with Chazelle's data structure.", "paper_title": "Posit ion-restricted substring searching", "paper_id": "WOS:000236886100064"}