{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "chip_multiprocessors"}, {"score": 0.004764220976404241, "phrase": "polyhedral_algebra"}, {"score": 0.004542441734438654, "phrase": "chip_multiprocessor"}, {"score": 0.004240116703465252, "phrase": "application-specific_memory_architecture"}, {"score": 0.004064117897000019, "phrase": "best_option"}, {"score": 0.003957833102043277, "phrase": "storage_demands"}, {"score": 0.003916098498242888, "phrase": "individual_processors"}, {"score": 0.0033579708256295847, "phrase": "polyhedral_method"}, {"score": 0.0032184697893776052, "phrase": "array-based_data-intensive_embedded_applications"}, {"score": 0.0031676593724896075, "phrase": "application-specific_hybrid_memory_architecture"}, {"score": 0.0030684249587688826, "phrase": "private_components"}, {"score": 0.002988101395789399, "phrase": "resulting_memory_configurations"}, {"score": 0.0027159094186967247, "phrase": "chip_multiprocessor_architectures"}, {"score": 0.00267301171407926, "phrase": "second_approach"}, {"score": 0.0026307897899760383, "phrase": "dynamic_configuration"}, {"score": 0.002603012037901889, "phrase": "software-managed_on-chip_memory_space"}, {"score": 0.0024947959375982614, "phrase": "data_storage_demand"}, {"score": 0.002468450551616404, "phrase": "interprocessor_sharing_patterns"}, {"score": 0.002429451930463481, "phrase": "proposed_framework"}, {"score": 0.0023532890136269986, "phrase": "optimising_compiler"}, {"score": 0.002316105585203396, "phrase": "polyhedral_tool"}, {"score": 0.0022674379203603224, "phrase": "memory_partitioner"}, {"score": 0.002219790619936024, "phrase": "integer_linear_programming"}, {"score": 0.0021049977753042253, "phrase": "eight_data-intensive_embedded_applications"}], "paper_keywords": [""], "paper_abstract": "One of the most important issues in designing a chip multiprocessor is to decide its on-chip memory organisation. While it is possible to design an application-specific memory architecture, this may not necessarily be the best option, in particular when storage demands of individual processors and/or their data sharing patterns can change from one point in execution to another for the same application. Here, two problems are formulated. First, we show how a polyhedral method can be used to design, for array-based data-intensive embedded applications, an application-specific hybrid memory architecture that has both shared and private components. We evaluate the resulting memory configurations using a set of benchmarks and compare them to pure private and pure shared memory on-chip multiprocessor architectures. The second approach proposed consider dynamic configuration of software-managed on-chip memory space to adapt to the runtime variations in data storage demand and interprocessor sharing patterns. The proposed framework is fully implemented using an optimising compiler, a polyhedral tool, and a memory partitioner (based on integer linear programming), and is tested using a suite of eight data-intensive embedded applications.", "paper_title": "On-chip memory space partitioning for chip multiprocessors using polyhedral algebra", "paper_id": "WOS:000283750700004"}