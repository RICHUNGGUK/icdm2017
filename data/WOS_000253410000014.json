{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java"}, {"score": 0.0071797502712779545, "phrase": "streamflex"}, {"score": 0.004748740786945996, "phrase": "stream_programming_paradigm"}, {"score": 0.004661868629458321, "phrase": "coarse-grained_parallelism"}, {"score": 0.004534517530868195, "phrase": "continuous_sequences"}, {"score": 0.004390312150344245, "phrase": "stream_programming"}, {"score": 0.004172874316207784, "phrase": "independent_filters"}, {"score": 0.004040123129261597, "phrase": "uni-directional_data_channels"}, {"score": 0.0038935506745975835, "phrase": "concurrent_and_efficient_implementations"}, {"score": 0.0037696519417841287, "phrase": "output_behavior"}, {"score": 0.0035828427627676075, "phrase": "stream_programs"}, {"score": 0.0034368818187904744, "phrase": "data_races"}, {"score": 0.0033274664434575136, "phrase": "memory_concurrent_programming"}, {"score": 0.002896535621940078, "phrase": "traditional_object-oriented_components"}, {"score": 0.002843450389745497, "phrase": "high-throughput_low-latency_applications"}, {"score": 0.0027528751037412128, "phrase": "service_requirements"}, {"score": 0.0024865237976623286, "phrase": "program_optimization"}, {"score": 0.0024522530645471065, "phrase": "latency_guarantees"}, {"score": 0.002418453525649304, "phrase": "streamflex_compiler"}, {"score": 0.0023522423291484212, "phrase": "stricter_typing_discipline"}, {"score": 0.0022355167967736326, "phrase": "java_virtual_machine"}, {"score": 0.0022149235007885805, "phrase": "real-time_capabilities"}, {"score": 0.002164264600379492, "phrase": "type-safe_region-based_allocation"}, {"score": 0.0021049977753042253, "phrase": "rich_and_expressive_language"}], "paper_keywords": ["languages", " experimentation.", " real-time systems", " Java virtual machine", " memory management", " ownership types", " stream processing"], "paper_abstract": "The stream programming paradigm aims to expose coarse-grained parallelism in applications that must process continuous sequences of events. The appeal of stream programming comes from its conceptual simplicity. A program is a collection of independent filters which communicate by the means of uni-directional data channels. This model lends itself naturally to concurrent and efficient implementations on modern multiprocessors. As the output behavior of filters is determined by the state of their input channels, stream programs have fewer opportunities for the errors (such as data races and deadlocks) that plague shared memory concurrent programming. This paper introduces STREAMFLEX, an extension to Java which marries streams with objects and thus enables to combine, in the same Java virtual machine, stream processing code with traditional object-oriented components. STREAMFLEX targets high-throughput low-latency applications with stringent quality-of-service requirements. To achieve these goals, it must, at the same time, extend and restrict Java. To allow for program optimization and provide latency guarantees, the STREAMFLEX compiler restricts Java by imposing a stricter typing discipline on filters. On the other hand, STREAMFLEX extends the Java virtual machine with real-time capabilities, transactional memory and type-safe region-based allocation. The result is a rich and expressive language that can be implemented efficiently.", "paper_title": "StreamFlex: High-throughput stream programming in Java", "paper_id": "WOS:000253410000014"}