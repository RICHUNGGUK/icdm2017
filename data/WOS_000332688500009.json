{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "concurrent_refinement_part"}, {"score": 0.004438250823243621, "phrase": "state-based_language"}, {"score": 0.004236321075918639, "phrase": "relational_model"}, {"score": 0.004067152645111547, "phrase": "abstract_programs"}, {"score": 0.004020066537823032, "phrase": "downward_and_upward_simulation_conditions"}, {"score": 0.003904713104101532, "phrase": "jointly_complete_methodology"}, {"score": 0.003837089839193524, "phrase": "relational_data_refinements"}, {"score": 0.003662410853488772, "phrase": "event-by-event_basis"}, {"score": 0.002917931350071647, "phrase": "explicit_properties"}, {"score": 0.002736694413701639, "phrase": "relational_framework"}, {"score": 0.0027049694095434905, "phrase": "eventwise_verification_methods"}, {"score": 0.0024640253074497114, "phrase": "simulation_conditions"}, {"score": 0.002435453488008121, "phrase": "process_algebraic_refinement"}, {"score": 0.0021049977753042253, "phrase": "automata_based_refinement"}], "paper_keywords": ["Data refinement", " Z", " Simulations", " Automata-based refinements", " Concurrency", " Traces", " Completed traces", " Failures", " Failure traces", " Extension"], "paper_abstract": "Data refinement in a state-based language such as Z is defined using a relational model in terms of the behaviour of abstract programs. Downward and upward simulation conditions form a sound and jointly complete methodology to verify relational data refinements, which can be checked on an event-by-event basis rather than per trace. In models of concurrency, refinement is often defined in terms of sets of observations, which can include the events a system is prepared to accept or refuse, or depend on explicit properties of states and transitions. By embedding such concurrent semantics into a relational framework, eventwise verification methods for such refinement relations can be derived. In this paper, we continue our program of deriving simulation conditions for process algebraic refinement by defining further embeddings into our relational model: traces, completed traces, failure traces and extension. We then extend our framework to include various notions of automata based refinement.", "paper_title": "Relational concurrent refinement part III: traces, partial relations and automata", "paper_id": "WOS:000332688500009"}