{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "haskell"}, {"score": 0.004300453431933622, "phrase": "type-class_constraints"}, {"score": 0.004121960535174029, "phrase": "data_type"}, {"score": 0.003978866233891427, "phrase": "frustrating_problem"}, {"score": 0.003760137090849196, "phrase": "considerable_amount"}, {"score": 0.0035283552859817764, "phrase": "data_types"}, {"score": 0.003241312187060814, "phrase": "monadic_computation"}, {"score": 0.00310664242361199, "phrase": "normal_form"}, {"score": 0.002998688867384969, "phrase": "monad_class_c"}, {"score": 0.0024772013657695896, "phrase": "applicative_functors"}, {"score": 0.002357457094026928, "phrase": "domain-specific_languages"}, {"score": 0.002196342933346204, "phrase": "deep_embedding"}], "paper_keywords": ["Class Constraints", " Monads", " Deep Embeddings", " Haskell"], "paper_abstract": "In Haskell, there are many data types that would form monads were it not for the presence of type-class constraints on the operations on that data type. This is a frustrating problem in practice, because there is a considerable amount of support and infrastructure for monads that these data types cannot use. Using several examples, we show that a monadic computation can be restructured into a normal form such that the standard monad class c an be used. The technique is not specific to monads, and we show how it can also be applied to other structures, such as applicative functors. One significant use case for this technique is domain-specific languages, where it is often desirable to compile a deep embedding of a computation to some other language, which requires restricting the types that can appear in that computation.", "paper_title": "The Constrained-Monad Problem", "paper_id": "WOS:000327696700027"}