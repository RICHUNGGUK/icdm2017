{"auto_keywords": [{"score": 0.043226782433942644, "phrase": "design_debugging"}, {"score": 0.03381238233390183, "phrase": "error_trace"}, {"score": 0.00481495049065317, "phrase": "sat-based_design_debugging"}, {"score": 0.004353948887538618, "phrase": "total_project_time"}, {"score": 0.004285289574869884, "phrase": "largest_component"}, {"score": 0.003978866233891427, "phrase": "ever_growing_size"}, {"score": 0.0039369107163201855, "phrase": "modern_designs"}, {"score": 0.003753498345597498, "phrase": "debugging_problem"}, {"score": 0.0036942726653704213, "phrase": "great_challenge"}, {"score": 0.0036553070575015344, "phrase": "automated_debugging_techniques"}, {"score": 0.0034482025128821548, "phrase": "novel_path-directed_abstraction"}, {"score": 0.003304965389155549, "phrase": "excessive_error_trace_lengths"}, {"score": 0.0032527939106509977, "phrase": "sliding_window"}, {"score": 0.003101153870424188, "phrase": "time-windowing_framework"}, {"score": 0.0029253546782349875, "phrase": "path-directed_abstraction"}, {"score": 0.002833689453299307, "phrase": "concise_approximation"}, {"score": 0.0028037753646260937, "phrase": "nonmodeled_parts"}, {"score": 0.002687235334499192, "phrase": "efficient_representation"}, {"score": 0.002508073621696602, "phrase": "memory_requirements"}, {"score": 0.002429451930463481, "phrase": "incomplete_results"}, {"score": 0.002378408229095287, "phrase": "experimental_results"}, {"score": 0.0023532890136269986, "phrase": "industrial_designs"}, {"score": 0.002328434471939886, "phrase": "long_error"}, {"score": 0.0022674379203603224, "phrase": "proposed_approach"}, {"score": 0.0021387992835532367, "phrase": "peak_memory_usage"}, {"score": 0.0021049977753042253, "phrase": "previous_work"}], "paper_keywords": ["Abstraction", " debugging", " diagnosis", " refinement", " register transfer level (RTL)", " verification", " very large scale integration"], "paper_abstract": "Functional verification has become one of the most time-consuming tasks in the very large scale integration design flow accounting for up to 57% of the total project time. The largest component of this task is that of design debugging due to its resource-intensive manual nature. With the ever growing size of modern designs and their error traces, the complexity of the debugging problem poses a great challenge to automated debugging techniques. To overcome this challenge, this paper introduces a novel path-directed abstraction and refinement algorithm for design debugging to manage excessive error trace lengths. A sliding window of the error trace is iteratively analyzed in a time-windowing framework, which is made possible by the use of the path-directed abstraction. This abstraction forms a concise approximation of nonmodeled parts of the error trace while simultaneously providing an efficient representation for refinement. The result is an algorithm that dramatically reduces the memory requirements of debugging while mitigating the incomplete results of past techniques. Experimental results on industrial designs with long error traces show that the proposed approach can analyze traces that are 64.6% longer while simultaneously decreasing peak memory usage compared to previous work.", "paper_title": "Path-Directed Abstraction and Refinement for SAT-Based Design Debugging", "paper_id": "WOS:000324876500013"}