{"auto_keywords": [{"score": 0.046258503538949974, "phrase": "transfer_functions"}, {"score": 0.007740489563401459, "phrase": "abstract_transfer_functions"}, {"score": 0.005387769216614261, "phrase": "bitwise_domain"}, {"score": 0.00476527679607755, "phrase": "embedded_software"}, {"score": 0.004587464246981363, "phrase": "dataflow_analyses"}, {"score": 0.004008624230034271, "phrase": "program_analysis"}, {"score": 0.0037796484923665855, "phrase": "resulting_code"}, {"score": 0.0036891952845575036, "phrase": "new_analyzers"}, {"score": 0.0036384794303356413, "phrase": "new_languages"}, {"score": 0.0034544053534458093, "phrase": "unsigned_interval_abstract_domains"}, {"score": 0.003418719577853084, "phrase": "interval_domain"}, {"score": 0.00327961310338175, "phrase": "three-valued_bits"}, {"score": 0.0032121901685844803, "phrase": "important_challenges"}, {"score": 0.0030814613175385672, "phrase": "integer_overflow"}, {"score": 0.0030285690317007805, "phrase": "precise_transfer_functions"}, {"score": 0.0022875739347765914, "phrase": "interval_and_bitwise_transfer_functions"}, {"score": 0.0022327484973125936, "phrase": "c_source_code"}, {"score": 0.002217326282120832, "phrase": "arm_object_code"}, {"score": 0.0021049977753042253, "phrase": "interprocedural_dataflow_analyzer"}], "paper_keywords": ["algorithms", " reliability", " languages", " verification", " static analysis", " abstract interpretation", " transfer functions", " embedded software"], "paper_abstract": "This paper addresses the problem of creating abstract transfer functions supporting dataflow analyses. Writing these functions by hand is problematic: transfer functions are difficult to understand, difficult to make precise, and difficult to debug. Bugs in transfer functions are particularly serious since they defeat the soundness of any program analysis running on top of them. Furthermore, implementing transfer functions by hand is wasteful because the resulting code is often difficult to reuse in new analyzers and to analyze new languages. We have developed algorithms and tools for deriving transfer functions for the bitwise and unsigned interval abstract domains. The interval domain is standard; in the bitwise domain, values are vectors of three-valued bits. For both domains, important challenges are to derive transfer functions that are sound in the presence of integer overflow, and to derive precise transfer functions for operations whose semantics are a mismatch for the domain (i. e., bit-vector operations in the interval domain and arithmetic operations in the bitwise domain). We can derive transfer functions, and execute them, in time linear in the bitwidth of the operands. These functions are maximally precise in most cases. Our generated transfer functions are parameterized by a bitwidth and are independent of the language being analyzed, and also of the language in which the analyzer is written. Currently, we generate interval and bitwise transfer functions in C and OCaml for analyzing C source code, ARM object code, and AVR object code. We evaluate our derived functions by using them in an interprocedural dataflow analyzer.", "paper_title": "Deriving abstract transfer functions for analyzing embedded software", "paper_id": "WOS:000202972200006"}