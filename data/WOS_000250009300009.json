{"auto_keywords": [{"score": 0.04954397446159371, "phrase": "xpath"}, {"score": 0.00481495049065317, "phrase": "xpath_fragment"}, {"score": 0.004655285779819366, "phrase": "xml_applications"}, {"score": 0.004577440795549049, "phrase": "xml_trees"}, {"score": 0.004425616928975799, "phrase": "element_nodes"}, {"score": 0.004351595642056769, "phrase": "xpath_query_processing"}, {"score": 0.004090577229368418, "phrase": "containment_relationship"}, {"score": 0.00378080526397273, "phrase": "numerous_xpath_features"}, {"score": 0.0036144035798673967, "phrase": "frequently_used_fragment"}, {"score": 0.00357395617690842, "phrase": "xpath_expressions"}, {"score": 0.0034944094552943, "phrase": "node_tests"}, {"score": 0.0034359094594153304, "phrase": "child_axis"}, {"score": 0.0030017207229983385, "phrase": "prior_work"}, {"score": 0.0029348729207661225, "phrase": "homomorphism_technology"}, {"score": 0.002853396755102163, "phrase": "containment_checking"}, {"score": 0.002743105561254975, "phrase": "sufficient_but_not_necessary_condition"}, {"score": 0.00266693888510356, "phrase": "special_classes"}, {"score": 0.00257831812581194, "phrase": "homomorphism_algorithm"}, {"score": 0.0025494354909453847, "phrase": "false_negatives"}, {"score": 0.0023296961971785357, "phrase": "conditioned_homomorphism"}, {"score": 0.002264982416465872, "phrase": "sound_algorithms"}, {"score": 0.0022020622730208514, "phrase": "experimental_results"}, {"score": 0.0021049977753042253, "phrase": "proposed_algorithms"}], "paper_keywords": ["computer software", " query containment", " conditioned homomorphism", " tree pattern", " XML", " XPath"], "paper_abstract": "XPath is ubiquitous in XML applications for navigating XML trees and selecting a set of element nodes. In XPath query processing, one of the most important issues is how to efficiently check containment relationship between two XPath expressions. To get out of the intricacy and complexity caused by numerous XPath features, we investigate this issue on a frequently used fragment of XPath expressions that consists of node tests, the child axis (/), the descendant axis (//), branches ([]) and label wildcards (*). Prior work has shown that homomorphism technology can be used for containment checking. However, homomorphism is the sufficient but not necessary condition for containment. For special classes of this fragment, the homomorphism algorithm returns false negatives. To address this problem, this paper proposes two containment techniques, conditioned homomorphism and hidden conditioned homomorphism, and then presents sound algorithms for checking containment. Experimental results confirm the practicability and efficiency of the proposed algorithms.", "paper_title": "HCH for checking containment of XPath fragment", "paper_id": "WOS:000250009300009"}