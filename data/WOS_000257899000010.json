{"auto_keywords": [{"score": 0.04249946592512055, "phrase": "join_node"}, {"score": 0.041632877340808054, "phrase": "ancestor_nodes"}, {"score": 0.02889275766803845, "phrase": "proposed_algorithm"}, {"score": 0.012239576873832637, "phrase": "redundant_duplications"}, {"score": 0.011289949743492554, "phrase": "bounded_number"}, {"score": 0.00481495049065317, "phrase": "minimized_duplications"}, {"score": 0.004773904938276846, "phrase": "homogeneous_systems"}, {"score": 0.004712988631183401, "phrase": "fine_grain_task_graphs"}, {"score": 0.004672808182229058, "phrase": "duplication-based_scheduling_algorithms"}, {"score": 0.004515467468684217, "phrase": "cluster-based_algorithms"}, {"score": 0.004344755264641137, "phrase": "possible_ancestor_nodes"}, {"score": 0.004162602203448056, "phrase": "earliest_start_time"}, {"score": 0.0038702288460744274, "phrase": "previous_steps"}, {"score": 0.003788196352457501, "phrase": "duplication_heuristics"}, {"score": 0.0036448787596988423, "phrase": "superfluous_consumption"}, {"score": 0.003537155405923517, "phrase": "scheduling_result"}, {"score": 0.003288567185099276, "phrase": "unbounded_number"}, {"score": 0.003218823621926739, "phrase": "required_number"}, {"score": 0.0030837288356760973, "phrase": "task_graph"}, {"score": 0.002954287204671029, "phrase": "large_task_graphs"}, {"score": 0.002842428606954139, "phrase": "novel_algorithm"}, {"score": 0.0027940789980683, "phrase": "join_nodes"}, {"score": 0.0025424508991051483, "phrase": "original_allocations"}, {"score": 0.0022257833099336858, "phrase": "recently_proposed_algorithms"}, {"score": 0.002178529882942255, "phrase": "better_or_comparable_schedules"}, {"score": 0.0021049977753042253, "phrase": "simulation_results"}], "paper_keywords": ["load balancing and task assignment", " parallel processors", " scheduling and task partitioning", " distributed architectures"], "paper_abstract": "For fine grain task graphs, duplication-based scheduling algorithms are generally more efficient than list and cluster-based algorithms. However, most duplication-based heuristics try to duplicate all possible ancestor nodes of a given join node, in order to reduce the earliest start time (EST) of the join node, even though these ancestor nodes have already been allocated in previous steps. Thus, these duplication heuristics inevitably induce redundant duplications, which lead to the superfluous consumption of resources and generally deteriorate the scheduling result in the case of a bounded number of processors. When scheduling algorithms are used on an unbounded number of processors, the required number of processors grows excessively with the size of the task graph, thereby limiting the practicality of these algorithms for large task graphs. In this paper, we propose a novel algorithm designed to allocate join nodes without redundant duplications. In the proposed algorithm, if the ancestor nodes of a join node are duplicated when scheduling the join node, the original allocations of these ancestor nodes are removed using a very efficient method. The performance of the proposed algorithm, in terms of its normalized schedule length and efficiency, is compared with that of some of the recently proposed algorithms. The proposed algorithm generates better or comparable schedules with minimized duplication. Specifically, the simulation results show that it is most useful on a bounded number of processors. (C) 2008 Elsevier Inc. All rights reserved.", "paper_title": "Task scheduling algorithm using minimized duplications in homogeneous systems", "paper_id": "WOS:000257899000010"}