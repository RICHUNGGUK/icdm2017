{"auto_keywords": [{"score": 0.0494208158242398, "phrase": "kernel_control_data"}, {"score": 0.03447806482501646, "phrase": "indexed_hooks"}, {"score": 0.00481495049065317, "phrase": "comprehensive_and_efficient_protection_of_kernel_control_data"}, {"score": 0.004640398886726948, "phrase": "return_addresses"}, {"score": 0.004534517530868195, "phrase": "serious_issue"}, {"score": 0.004492841495994535, "phrase": "rootkit_defenders"}, {"score": 0.004390312150344245, "phrase": "rootkit_authors"}, {"score": 0.003929689573550262, "phrase": "kernel_memory_space"}, {"score": 0.0035498822293046884, "phrase": "run_time"}, {"score": 0.003517223847512266, "phrase": "existing_solutions"}, {"score": 0.0034052594710793664, "phrase": "excessive_performance_overhead"}, {"score": 0.0031625006830124512, "phrase": "kernel_control-flow_enforcement"}, {"score": 0.0029642838574678526, "phrase": "kernel's_control-flow_graph"}, {"score": 0.0028042741141125712, "phrase": "attackers'_possibility"}, {"score": 0.0027275289970185015, "phrase": "infection_vector"}, {"score": 0.0026899455459275575, "phrase": "rootkit_attacks"}, {"score": 0.0025683581446365165, "phrase": "compiler-based_prototype"}, {"score": 0.0023741093119014436, "phrase": "code_base"}, {"score": 0.00229844995872581, "phrase": "direct_pointers"}, {"score": 0.0021344259291927914, "phrase": "commodity_hardware"}, {"score": 0.0021049977753042253, "phrase": "low_performance_overhead"}], "paper_keywords": ["Intrusion prevention and tolerance", " software", " system design and implementation"], "paper_abstract": "Protecting kernel control data (e.g., function pointers and return addresses) has been a serious issue plaguing rootkit defenders. In particular, rootkit authors only need to compromise one piece of control data to launch their attacks, while defenders need to protect thousands of such values widely scattered across kernel memory space. Worse, some of this data (e.g., return addresses) is volatile and can be dynamically generated at run time. Existing solutions, however, offer either incomplete protection or excessive performance overhead. To overcome these limitations, we present indexed hooks, a scheme that greatly facilitates kernel control-flow enforcement by thoroughly transforming and restricting kernel control data to take only legal jump targets (allowed by the kernel's control-flow graph). By doing so, we can severely limit the attackers' possibility of exploiting them as an infection vector to launch rootkit attacks. To validate our approach, we have developed a compiler-based prototype that implements this technique in the FreeBSD 8.0 kernel, transforming 49 025 control transfer instructions (similar to 7.25% of the code base) to use indexed hooks instead of direct pointers. Our evaluation results indicate that our approach is generic, effective, and can be implemented on commodity hardware with a low performance overhead (<5% based on benchmarks).", "paper_title": "Comprehensive and Efficient Protection of Kernel Control Data", "paper_id": "WOS:000297344200019"}