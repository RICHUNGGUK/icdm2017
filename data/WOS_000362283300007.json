{"auto_keywords": [{"score": 0.0341532596630476, "phrase": "botim"}, {"score": 0.00481495049065317, "phrase": "serializable_multiversion_concurrency_control"}, {"score": 0.004772137871562584, "phrase": "multi-versioned_database_systems"}, {"score": 0.004523103062368843, "phrase": "transaction_processing"}, {"score": 0.0040996651541091575, "phrase": "transaction_serializability"}, {"score": 0.003973398317120165, "phrase": "full_serializability"}, {"score": 0.0039380388343479384, "phrase": "modern_multi-versioned_systems"}, {"score": 0.0037997077863530897, "phrase": "conflicting_transactions"}, {"score": 0.0037490909410974166, "phrase": "expensive_synchronization_patterns"}, {"score": 0.003666217992454448, "phrase": "main-memory_multi-core_settings"}, {"score": 0.0035216195857272403, "phrase": "multiversioned_systems"}, {"score": 0.0034283921404628975, "phrase": "single-version_systems"}, {"score": 0.0033676721436253893, "phrase": "bohm"}, {"score": 0.0032638170723261538, "phrase": "main-memory_multi-versioned_database_systems"}, {"score": 0.002741269087816162, "phrase": "shared_memory"}, {"score": 0.0026806139086152365, "phrase": "excellent_scalability"}, {"score": 0.0026330549554033876, "phrase": "multi-core_settings"}, {"score": 0.002364865100579589, "phrase": "excessive_aborts"}, {"score": 0.0022816681646340518, "phrase": "experimental_evaluation"}, {"score": 0.0022013916728990564, "phrase": "high_contention"}, {"score": 0.002181766829493483, "phrase": "low_contention_settings"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_multi-versioned_systems"}], "paper_keywords": [""], "paper_abstract": "Multi-versioned database systems have the potential to significantly increase the amount of concurrency in transaction processing because they can avoid read-write conflicts. Unfortunately, the increase in concurrency usually comes at the cost of transaction serializability. If a database user requests full serializability, modern multi-versioned systems significantly constrain read-write concurrency among conflicting transactions and employ expensive synchronization patterns in their design. In main-memory multi-core settings, these additional constraints are so burdensome that multiversioned systems are often significantly outperformed by single-version systems. We propose BOHM a new concurrency control protocol for main-memory multi-versioned database systems. Botim guarantees serializable execution while ensuring that reads never block writes. In addition, Botim does not require reads to perform any bookkeeping whatsoever, thereby avoiding the overhead of tracking reads via contended writes to shared memory. This leads to excellent scalability and performance in multi-core settings. Botim has all the above characteristics without performing validation based concurrency control. Instead, it is pessimistic, and is therefore not prone to excessive aborts in the presence of contention. An experimental evaluation shows that Botim performs well in both high contention and low contention settings, and is able to dramatically outperform state-of-the-art multi-versioned systems despite maintaining the full set of serializability guarantees.", "paper_title": "Rethinking serializable multiversion concurrency control", "paper_id": "WOS:000362283300007"}