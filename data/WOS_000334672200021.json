{"auto_keywords": [{"score": 0.03754149614401332, "phrase": "suspect_program"}, {"score": 0.00481495049065317, "phrase": "high_processor_counts"}, {"score": 0.004719664411221952, "phrase": "challenging_task"}, {"score": 0.004356926418550194, "phrase": "special_debugging_method"}, {"score": 0.004075946554498088, "phrase": "debugging_applications"}, {"score": 0.0038642157757169315, "phrase": "larger_machines"}, {"score": 0.0034963129868796033, "phrase": "reference_version"}, {"score": 0.0032489004068215407, "phrase": "innovative_idea"}, {"score": 0.0031422859551159506, "phrase": "runtime_data"}, {"score": 0.002842920225545139, "phrase": "comparison_phase"}, {"score": 0.0027495914857929584, "phrase": "large_problems"}, {"score": 0.0026950674053179404, "phrase": "large_machines"}, {"score": 0.0025042115651986332, "phrase": "hash-based_scheme"}, {"score": 0.0024545413637350765, "phrase": "direct_point-to-point_scheme"}], "paper_keywords": ["Parallellism and concurrency", " distributed debugging", " assertion checkers"], "paper_abstract": "Detecting and isolating bugs that arise only at high processor counts is a challenging task. Over a number of years, we have implemented a special debugging method, called \"relative debugging,\" that supports debugging applications as they evolve or are ported to larger machines. It allows a user to compare the state of a suspect program against another reference version even as the number of processors is increased. The innovative idea is the comparison of runtime data to reason about the state of the suspect program. While powerful, a naive implementation of the comparison phase does not scale to large problems running on large machines. In this paper, we propose two different solutions including a hash-based scheme and a direct point-to-point scheme. We demonstrate the implementation, a case study, as well as the performance, of our techniques on 20K cores of a Cray XE6 system.", "paper_title": "Scalable Relative Debugging", "paper_id": "WOS:000334672200021"}