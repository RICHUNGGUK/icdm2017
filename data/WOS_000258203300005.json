{"auto_keywords": [{"score": 0.03414229704911108, "phrase": "member_deletions"}, {"score": 0.025588596101075965, "phrase": "internal_node"}, {"score": 0.00481495049065317, "phrase": "deletion_cost"}, {"score": 0.004766090327062509, "phrase": "secure_multicast_key_management"}, {"score": 0.0047178315381402065, "phrase": "multicast"}, {"score": 0.004622450915803531, "phrase": "efficient_ways"}, {"score": 0.004260134699483774, "phrase": "growing_security_concerns"}, {"score": 0.0040481944502103505, "phrase": "secret_group_key"}, {"score": 0.003986684503518077, "phrase": "key_tree_model"}, {"score": 0.0037307208089736835, "phrase": "tree_structure"}, {"score": 0.0036181717017041387, "phrase": "group_member_change"}, {"score": 0.003563172322934695, "phrase": "group_key"}, {"score": 0.0034556603183020407, "phrase": "secure_and_efficient_way"}, {"score": 0.0032836104153151973, "phrase": "updating_cost"}, {"score": 0.0030726480920918097, "phrase": "key_tree"}, {"score": 0.0029951555610569225, "phrase": "encrypted_messages"}, {"score": 0.0027741761880779535, "phrase": "best_key_tree"}, {"score": 0.0027041907335656782, "phrase": "worst-case_deletion_cost"}, {"score": 0.002453934333239467, "phrase": "optimal_tree"}, {"score": 0.0021705796895687864, "phrase": "dynamic_programming_algorithm"}, {"score": 0.002126635713519053, "phrase": "optimal_key_tree"}], "paper_keywords": ["key tree", " security", " dynamic", " optimization"], "paper_abstract": "Multicast and broadcast are efficient ways to deliver messages to a group of recipients in a network. Due to the growing security concerns in various applications, messages are ofter encrypted with a secret group key. The key tree model which has been widely adopted maintains a set of keys in a tree structure so that in case of group member change, the group key can be updated in a secure and efficient way. In this paper, we focus on the updating cost incurred by member deletions. To implement a sequence of member deletions in any key tree, a certain number of encrypted messages need to be broadcast to accomplish the updates. Our goal is to identify the best key tree which can minimize the worst-case deletion cost (i.e., the amortized cost over n member deletions). We prove that there is an optimal tree in which each internal node has at most five children and each internal node with at least one non-leaf child has exactly three children. Based on these characterizations we present a dynamic programming algorithm that computes an optimal key tree in O(n(2)) time.", "paper_title": "Optimizing deletion cost for secure multicast key management", "paper_id": "WOS:000258203300005"}