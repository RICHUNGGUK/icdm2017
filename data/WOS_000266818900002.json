{"auto_keywords": [{"score": 0.04547624598453918, "phrase": "security-relevant_actions"}, {"score": 0.00481495049065317, "phrase": "expressive_runtime_security_policies"}, {"score": 0.004695183699894267, "phrase": "security_policies"}, {"score": 0.004555371402128666, "phrase": "control_flow"}, {"score": 0.004509694461067052, "phrase": "untrusted_software"}, {"score": 0.003916098498242888, "phrase": "untrusted_software's_attempted_action"}, {"score": 0.0038186039088445524, "phrase": "common_security_enforcement_mechanisms"}, {"score": 0.0037235274565193665, "phrase": "operating_systems"}, {"score": 0.0036861605703168397, "phrase": "virtual_machines"}, {"score": 0.0036125439380579626, "phrase": "network_auditors"}, {"score": 0.003558294449586273, "phrase": "antivirus_and_antispyware_tools"}, {"score": 0.003469676666252421, "phrase": "runtime_policies"}, {"score": 0.003417565253539315, "phrase": "program_monitors"}, {"score": 0.0032494292163722065, "phrase": "monitored_software"}, {"score": 0.0032006150973842846, "phrase": "new_capabilities"}, {"score": 0.0030278017562213265, "phrase": "user_feedback"}, {"score": 0.0029374939071038146, "phrase": "policy_complexity"}, {"score": 0.0027370835853738626, "phrase": "complex_policies"}, {"score": 0.0026155094974689595, "phrase": "smaller_subpolicy_modules"}, {"score": 0.0025503112711036994, "phrase": "fully_implemented_language"}, {"score": 0.0024617483174454113, "phrase": "security_engineers"}, {"score": 0.002400373755068185, "phrase": "composable_policies"}, {"score": 0.0023762535034673017, "phrase": "java_applications"}, {"score": 0.0023170054862555896, "phrase": "central_workings"}, {"score": 0.0022478501955483007, "phrase": "unambiguous_semantics"}, {"score": 0.0021049977753042253, "phrase": "uncircumventability_theorem"}], "paper_keywords": ["Design", " Languages", " Security", " Policy composition", " policy-specification language", " policy enforcement"], "paper_abstract": "Program monitors enforce security policies by interposing themselves into the control flow of untrusted software whenever that software attempts to execute security-relevant actions. At the point of interposition, a monitor has authority to permit or deny (perhaps conditionally) the untrusted software's attempted action. Program monitors are common security enforcement mechanisms and integral parts of operating systems, virtual machines, firewalls, network auditors, and antivirus and antispyware tools. Unfortunately, the runtime policies we require program monitors to enforce grow more complex, both as the monitored software is given new capabilities and as policies are refined in response to attacks and user feedback. We propose dealing with policy complexity by organizing policies in such a way as to make them composable, so that complex policies can be specified more simply as compositions of smaller subpolicy modules. We present a fully implemented language and system called Polymer that allows security engineers to specify and enforce composable policies on Java applications. We formalize the central workings of Polymer by defining an unambiguous semantics for our language. Using this formalization, we state and prove an uncircumventability theorem which guarantees that monitors will intercept all security-relevant actions of untrusted software.`", "paper_title": "Composing Expressive Runtime Security Policies", "paper_id": "WOS:000266818900002"}