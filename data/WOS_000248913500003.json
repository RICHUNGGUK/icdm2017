{"auto_keywords": [{"score": 0.048970045726729895, "phrase": "unreachable_cyclic_structures"}, {"score": 0.00481495049065317, "phrase": "reference-counting_garbage_collector"}, {"score": 0.00454090611248773, "phrase": "reference-counting_collectors"}, {"score": 0.0044356867986444426, "phrase": "backup_tracing_collector"}, {"score": 0.004282391936827106, "phrase": "cycle_collector"}, {"score": 0.004207734323806386, "phrase": "cyclic_structures"}, {"score": 0.00408617426304956, "phrase": "new_concurrent_cycle_collector"}, {"score": 0.0038989120088094185, "phrase": "program_threads"}, {"score": 0.0038309141193444015, "phrase": "negligible_pauses"}, {"score": 0.0035496495489801667, "phrase": "state-of-the-art_cycle_collector"}, {"score": 0.0035082504366758553, "phrase": "bacon"}, {"score": 0.003467323710346532, "phrase": "rajan"}, {"score": 0.0033868916699805224, "phrase": "sliding-views_collectors"}, {"score": 0.0032697235411641695, "phrase": "azatchi"}, {"score": 0.0030833537429977797, "phrase": "sliding_views"}, {"score": 0.0028234703730349894, "phrase": "cycle_candidates"}, {"score": 0.0025106241866273897, "phrase": "cycle_collection_efficiency"}, {"score": 0.002381365139274329, "phrase": "theoretical_termination_problem"}, {"score": 0.0023124457559811087, "phrase": "earlier_concurrent_cycle_collector"}, {"score": 0.0022455164874830777, "phrase": "rare_race"}, {"score": 0.0021550502873107654, "phrase": "unreachable_cyclic_structure"}, {"score": 0.0021049977753042253, "phrase": "sliding-views_cycle_collector"}], "paper_keywords": ["languages", " algorithms", " programming languages", " memory management", " garbage collection", " reference counting", " concurrent cycle collection", " runtime systems"], "paper_abstract": "A reference-counting garbage collector cannot reclaim unreachable cyclic structures of objects. Therefore, reference-counting collectors either use a backup tracing collector infrequently, or employ a cycle collector to reclaim cyclic structures. We propose a new concurrent cycle collector, one that runs concurrently with the program threads, imposing negligible pauses (of around 1ms) on a multiprocessor. Our new collector combines a state-of-the-art cycle collector [Bacon and Rajan 2001] with sliding-views collectors [Levanoni and Petrank 2001, 2006; Azatchi et al. 2003]. The use of sliding views for cycle collection yields two advantages. First, it drastically reduces the number of cycle candidates, which in turn drastically reduces the work required to record and trace these candidates. Consequentially, a large improvement in cycle collection efficiency is achieved. Second, it eliminates the theoretical termination problem that appeared in the earlier concurrent cycle collector. There, a rare race may delay the reclamation of an unreachable cyclic structure forever. The sliding-views cycle collector guarantees reclamation of all unreachable cyclic structures.", "paper_title": "An efficient on-the-fly cycle collection", "paper_id": "WOS:000248913500003"}