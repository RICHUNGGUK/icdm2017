{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "rank_and_select_indexes"}, {"score": 0.004675930527604869, "phrase": "new_lower_bound_technique"}, {"score": 0.004461761855323898, "phrase": "optimal_q"}, {"score": 0.0040622852274783275, "phrase": "bit_vector_b"}, {"score": 0.0035288860880035985, "phrase": "lower_bounds"}, {"score": 0.0029075757820516634, "phrase": "select_index"}, {"score": 0.002206290313627494, "phrase": "explicit_constant"}, {"score": 0.002129877319760485, "phrase": "ram_model"}, {"score": 0.0021049977753042253, "phrase": "word_size"}], "paper_keywords": [""], "paper_abstract": "We develop a new lower bound technique for data structures. We show an optimal Q (n Ig Ig n/ Ig n) space lower bounds for storing an index that allows to implement rank and select queries on a bit vector B provided that B is stored explicitly. These results improve upon [Miltersen, SODA'05]. We show Omega((m/t) Ig t) lower bounds for storing rank/select index in the case where B has m 1-bits in it (e.g. low 0th entropy) and the algorithm is allowed to probe t bits of B. We simplify the select index given in [Raman et al., SODA'02] and show how to implement both rank and select queries with an index of size (1 + o(1)) (n Ig Ig n/ Ig n) + O(n/ Ig n) (i.e. we give an explicit constant for storage) in the RAM model with word size Ig n.", "paper_title": "Optimal lower bounds for rank and select indexes", "paper_id": "WOS:000239474500033"}