{"auto_keywords": [{"score": 0.0340699507525149, "phrase": "goa"}, {"score": 0.00481495049065317, "phrase": "modern_compilers"}, {"score": 0.004690305164360866, "phrase": "executable_size"}, {"score": 0.00450933377534525, "phrase": "non-functional_properties"}, {"score": 0.004421471944783611, "phrase": "power_efficiency"}, {"score": 0.0038271712887391015, "phrase": "standard_dataflow_optimizations"}, {"score": 0.003703611021999795, "phrase": "general_post-compilation_approach"}, {"score": 0.0036553070575015344, "phrase": "genetic_optimization_algorithm"}, {"score": 0.0034911335714333507, "phrase": "measurable_non-functional_aspects"}, {"score": 0.0031429517477457925, "phrase": "profile-guided_optimization"}, {"score": 0.0030614565460256897, "phrase": "evolutionary_computation"}, {"score": 0.003021502415143067, "phrase": "mutational_robustness"}, {"score": 0.0029238768315330305, "phrase": "program_variants"}, {"score": 0.0028480459059007468, "phrase": "functional_behavior"}, {"score": 0.0027924625350414655, "phrase": "non-functional_behavior"}, {"score": 0.002737960968372391, "phrase": "characteristic_workloads"}, {"score": 0.00270221723573854, "phrase": "predictive_modeling"}, {"score": 0.0025807396931129926, "phrase": "resulting_optimizations"}, {"score": 0.0025137856138000014, "phrase": "physical_performance_measurements"}, {"score": 0.002464709648714996, "phrase": "larger_held-out_test_suite"}, {"score": 0.0023694065215394593, "phrase": "parsec_benchmark_programs"}, {"score": 0.0023384629381463054, "phrase": "average_energy_reductions"}, {"score": 0.002233301265743633, "phrase": "large_amd_system"}, {"score": 0.0021896891011033105, "phrase": "small_intel_system"}, {"score": 0.0021328586481696157, "phrase": "program_functionality"}, {"score": 0.0021049977753042253, "phrase": "target_workloads"}], "paper_keywords": ["Evolutionary Computation", " Power Modeling", " Assembly Code", " Compilation", " Profile-guided Optimization", " Superoptimization", " Mutational Robustness"], "paper_abstract": "Modern compilers typically optimize for executable size and speed, rarely exploring non-functional properties such as power efficiency. These properties are often hardware-specific, time-intensive to optimize, and may not be amenable to standard dataflow optimizations. We present a general post-compilation approach called Genetic Optimization Algorithm (GOA), which targets measurable non-functional aspects of software execution in programs that compile to x86 assembly. GOA combines insights from profile-guided optimization, superoptimization, evolutionary computation and mutational robustness. GOA searches for program variants that retain required functional behavior while improving non-functional behavior, using characteristic workloads and predictive modeling to guide the search. The resulting optimizations are validated using physical performance measurements and a larger held-out test suite. Our experimental results on PARSEC benchmark programs show average energy reductions of 20%, both for a large AMD system and a small Intel system, while maintaining program functionality on target workloads.", "paper_title": "Post-compiler Software Optimization for Reducing Energy", "paper_id": "WOS:000360535000044"}