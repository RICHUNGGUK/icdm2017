{"auto_keywords": [{"score": 0.04539751403115773, "phrase": "sublinear_time"}, {"score": 0.04286246575822761, "phrase": "convergence_time"}, {"score": 0.00481495049065317, "phrase": "automatic_recovery"}, {"score": 0.0047739754059430055, "phrase": "arbitrary_state"}, {"score": 0.004613516457919661, "phrase": "local_attributes"}, {"score": 0.004223415145617665, "phrase": "topology_changes"}, {"score": 0.004023619476547389, "phrase": "upper_bound"}, {"score": 0.0039553744129764016, "phrase": "topology_change"}, {"score": 0.0037042817107563785, "phrase": "self-organization_property"}, {"score": 0.0035189057079817285, "phrase": "self-stabilizing_and_self-organizing_algorithms"}, {"score": 0.0034493376812017983, "phrase": "distributed_snapshot"}, {"score": 0.003371508176308189, "phrase": "new_randomized_self-stabilizing_distributed_algorithm"}, {"score": 0.0032954289787083713, "phrase": "bounded_degree_processors"}, {"score": 0.0032487508969192293, "phrase": "sensor_networks_deployment"}, {"score": 0.003166384930533443, "phrase": "expected_number"}, {"score": 0.0031215289677725693, "phrase": "dynamic_changes"}, {"score": 0.003007846011394511, "phrase": "clustering_algorithm"}, {"score": 0.0029907265264530816, "phrase": "specific_classes"}, {"score": 0.002973704188310602, "phrase": "communication_graphs"}, {"score": 0.0028900306270345866, "phrase": "overlay_network_abstraction"}, {"score": 0.002849078393246526, "phrase": "self-stabilizing_and_self-organizing_distributed_algorithm"}, {"score": 0.0027927155990963063, "phrase": "obtained_hierarchy_definition"}, {"score": 0.0027374647587075935, "phrase": "hierarchical_distributed_snapshots"}, {"score": 0.002675654549462983, "phrase": "new_basic_snap-stabilizing_snapshot_algorithm"}, {"score": 0.0026003455833291124, "phrase": "distributed_spanning_tree"}, {"score": 0.0025343769150179764, "phrase": "bounded_links_capacity"}, {"score": 0.002366508404418069, "phrase": "snapshot_invocations"}, {"score": 0.002326304140277375, "phrase": "self-stabilizing_and_self-organizing_distributed_hierarchy_construction"}, {"score": 0.0022802596433757565, "phrase": "efficient_self-stabilizer_transformer"}, {"score": 0.002254357921422124, "phrase": "distributed_algorithm"}, {"score": 0.002235124462642752, "phrase": "specific_task"}, {"score": 0.0021659920594094407, "phrase": "self-stabilizing_algorithm"}, {"score": 0.0021291870676682406, "phrase": "expected_convergence_time"}], "paper_keywords": ["Self-stabilizing", " Self-organizing", " Communication and routing", " Clustering"], "paper_abstract": "Self-stabilization ensures automatic recovery from an arbitrary state; we define self-organization as a property of algorithms which display local attributes. More precisely, we say that all algorithm is self-organizing if ( 1) it converges in sublinear time and (2) reacts \"fast\" to topology changes. If s(n) is an upper bound an the convergence time and d(n) is an upper bound on the convergence time following a topology change, then s(n) is an element of o(n) and d(n) is an element of o(s(n)). The self-organization property can then be used for gaining, in sublinear time, global properties and reaction to changes. We present self-stabilizing and self-organizing algorithms for many distributed algorithms, including distributed snapshot and leader election. We present a new randomized self-stabilizing distributed algorithm for cluster definition in communication graphs of bounded degree processors. These graphs reflect sensor networks deployment. The algorithm converges in O(log n) expected number of rounds, handles dynamic changes locally and is, therefore, self-organizing. Applying the clustering algorithm to specific classes of communication graphs, in O(log n) levels, using an overlay network abstraction, results ill a self-stabilizing and self-organizing distributed algorithm for hierarchy definition. Given the obtained hierarchy definition, we present an algorithm for hierarchical distributed snapshots. The algorithms are based on a new basic snap-stabilizing snapshot algorithm, designed for message passing systems in which a distributed spanning tree is defined and in which processors communicate using bounded links capacity. The algorithm is on-demand self-stabilizing when no Such distributed spanning tree is defined. Namely, it stabilizes regardless of the number of snapshot invocations. The combination of the self-stabilizing and self-organizing distributed hierarchy construction and the snapshot algorithm forms an efficient self-stabilizer transformer. Given a distributed algorithm for a specific task, we are able to convert the algorithm into a self-stabilizing algorithm for the same task with an expected convergence time of O(log(2) n) rounds. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Empire of colonies: Self-stabilizing and self-organizing distributed algorithm", "paper_id": "WOS:000263635200006"}