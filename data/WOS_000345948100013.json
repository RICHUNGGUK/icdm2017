{"auto_keywords": [{"score": 0.04702121779550708, "phrase": "implicit_parallelism"}, {"score": 0.00481495049065317, "phrase": "logic_programming_languages"}, {"score": 0.004718406620490183, "phrase": "prolog"}, {"score": 0.004623608221548592, "phrase": "great_potential"}, {"score": 0.004306795240631196, "phrase": "prolog_programs"}, {"score": 0.00409382470158851, "phrase": "simultaneous_evaluation"}, {"score": 0.004032002950217457, "phrase": "subgoal_call"}, {"score": 0.00309681702203087, "phrase": "memory_architectures"}, {"score": 0.003019189898170698, "phrase": "or-parallel_prolog_system"}, {"score": 0.002769483748975581, "phrase": "independent_prolog_engines"}, {"score": 0.002501955525421155, "phrase": "team-based_scheduling_model"}, {"score": 0.0024268423699752113, "phrase": "different_or-parallel_engines"}, {"score": 0.002283298119790413, "phrase": "layered_approach"}, {"score": 0.002248755794042486, "phrase": "second-level_scheduler"}, {"score": 0.002214734873559146, "phrase": "clean_interface"}, {"score": 0.002148226022654619, "phrase": "base_or-parallel_engines"}, {"score": 0.0021049977753042253, "phrase": "different_scheduling_combinations"}], "paper_keywords": ["Prolog", " or-parallelism", " environment copying", " scheduling"], "paper_abstract": "Logic Programming languages, such as Prolog, offer a great potential for the exploitation of implicit parallelism. One of the most noticeable sources of implicit parallelism in Prolog programs is or-parallelism. Or-parallelism arises from the simultaneous evaluation of a subgoal call against the clauses that match that call. Nowadays, multicores and clusters of multicores are becoming the norm and, although, many parallel Prolog systems have been developed in the past, to the best of our knowledge, none of them was specially designed to explore the combination of shared and distributed memory architectures. Conceptually, an or-parallel Prolog system consists of two components: an or-parallel engine (i.e., a set of independent Prolog engines which we named a team of workers) and a scheduler. In this work, we propose a team-based scheduling model to efficiently exploit parallelism between different or-parallel engines running on top of clusters of multicores. Our proposal defines a layered approach where a second-level scheduler specifies a clean interface for scheduling work between the base or-parallel engines, thus enabling different scheduling combinations to be used for distributing work among workers inside a team and among teams.", "paper_title": "A Team-Based Scheduling Model for Interfacing Or-Parallel Prolog Engines", "paper_id": "WOS:000345948100013"}