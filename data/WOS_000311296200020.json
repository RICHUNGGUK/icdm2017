{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "increasing_levels"}, {"score": 0.004725385523804256, "phrase": "hardware_parallelism"}, {"score": 0.004508661664944657, "phrase": "main_challenges"}, {"score": 0.004261617028111862, "phrase": "managed_runtimes"}, {"score": 0.0037363522297378777, "phrase": "application_benchmarks"}, {"score": 0.0034984340449789745, "phrase": "highly_concurrent_applications"}, {"score": 0.003066945490483524, "phrase": "vm_developers"}, {"score": 0.0027916287357898544, "phrase": "platform_independent_concurrency-related_metrics"}, {"score": 0.0027139447110929586, "phrase": "in-depth_observational_study"}, {"score": 0.002564985233317994, "phrase": "art_benchmarks"}, {"score": 0.0021049977753042253, "phrase": "shared_memory"}], "paper_keywords": ["Benchmarks", " DaCapo", " concurrency", " scalability"], "paper_abstract": "Increasing levels of hardware parallelism are one of the main challenges for programmers and implementers of managed runtimes. Any concurrency or scalability improvements must be evaluated experimentally. However, application benchmarks available today may not reflect the highly concurrent applications we anticipate in the future. They may also behave in ways that VM developers do not expect. We provide a set of platform independent concurrency-related metrics and an in-depth observational study of current state of the art benchmarks, discovering how concurrent they really are, how they scale the work and how they synchronise and communicate via shared memory.", "paper_title": "A Black-box Approach to Understanding Concurrency in DaCapo", "paper_id": "WOS:000311296200020"}