{"auto_keywords": [{"score": 0.040708700726361825, "phrase": "tree_automata"}, {"score": 0.00481495049065317, "phrase": "heap_manipulation"}, {"score": 0.004637478829869904, "phrase": "dynamic_linked_data_structures"}, {"score": 0.004529881123652277, "phrase": "singly_and_doubly-linked_lists"}, {"score": 0.00440403952059725, "phrase": "important_properties"}, {"score": 0.004241648852523704, "phrase": "null-pointer_dereferences"}, {"score": 0.004123781267600542, "phrase": "shape_properties"}, {"score": 0.003990385737207714, "phrase": "verification_method"}, {"score": 0.003916098498242888, "phrase": "novel_use"}, {"score": 0.003825173769489887, "phrase": "heap_configurations"}, {"score": 0.0034494494982242187, "phrase": "tree_automaton"}, {"score": 0.0032756158688245, "phrase": "different_parts"}, {"score": 0.003038237581227068, "phrase": "hierarchical_representation"}, {"score": 0.002626034130205569, "phrase": "symbolic_state-space_exploration"}, {"score": 0.0025409639091476363, "phrase": "so-called_abstract_regular_tree_model_checking"}, {"score": 0.0024014759148123736, "phrase": "automata-based_approaches"}, {"score": 0.002248366278757655, "phrase": "separation-logic-based_approaches"}, {"score": 0.0021049977753042253, "phrase": "multiple_non-trivial_case_studies"}], "paper_keywords": ["Pointers", " Shape analysis", " Regular model checking", " Tree automata"], "paper_abstract": "We consider verification of programs manipulating dynamic linked data structures such as various forms of singly and doubly-linked lists or trees. We consider important properties for this kind of systems like no null-pointer dereferences, absence of garbage, shape properties, etc. We develop a verification method based on a novel use of tree automata to represent heap configurations. A heap is split into several \"separated\" parts such that each of them can be represented by a tree automaton. The automata can refer to each other allowing the different parts of the heaps to mutually refer to their boundaries. Moreover, we allow for a hierarchical representation of heaps by allowing alphabets of the tree automata to contain other, nested tree automata. Program instructions can be easily encoded as operations on our representation structure. This allows verification of programs based on symbolic state-space exploration together with refinable abstraction within the so-called abstract regular tree model checking. A motivation for the approach is to combine advantages of automata-based approaches (higher generality and flexibility of the abstraction) with some advantages of separation-logic-based approaches (efficiency). We have implemented our approach and tested it successfully on multiple non-trivial case studies.", "paper_title": "Forest automata for verification of heap manipulation", "paper_id": "WOS:000305785600006"}