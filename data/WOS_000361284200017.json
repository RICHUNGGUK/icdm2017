{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "racy_tests"}, {"score": 0.004765482708043842, "phrase": "subtle_concurrency_errors"}, {"score": 0.004716520738331953, "phrase": "multithreaded_libraries"}, {"score": 0.004596295252559861, "phrase": "incorrect_or_inadequate_synchronization"}, {"score": 0.004209893377338457, "phrase": "dynamic_race_detectors"}, {"score": 0.004102528738941734, "phrase": "multithreaded_test_suites"}, {"score": 0.0037188360359702182, "phrase": "specific_combination"}, {"score": 0.003370907075333389, "phrase": "priori_knowledge"}, {"score": 0.0030554300179552415, "phrase": "lightweight_and_scalable_technique"}, {"score": 0.0030083825666563898, "phrase": "precisely_these_kinds"}, {"score": 0.0029164434911787187, "phrase": "multithreaded_library"}, {"score": 0.0028715299874549245, "phrase": "sequential_test_suite"}, {"score": 0.0027982016314450717, "phrase": "fully_automated_analysis"}, {"score": 0.002755104031926742, "phrase": "sequential_execution_traces"}, {"score": 0.0025892330566358503, "phrase": "shared_objects"}, {"score": 0.0025625729433234623, "phrase": "library_method"}, {"score": 0.0024333239726872604, "phrase": "experimental_results"}, {"score": 0.0023711591828229736, "phrase": "well-tested_java_libraries"}, {"score": 0.0023225701080913388, "phrase": "multithreaded_tests"}, {"score": 0.0021826828321952615, "phrase": "off-the-shelf_race_detector"}], "paper_keywords": ["Design", " Reliability", " Verification", " Race detection", " dynamic analysis", " concurrency"], "paper_abstract": "Subtle concurrency errors in multithreaded libraries that arise because of incorrect or inadequate synchronization are often difficult to pinpoint precisely using only static techniques. On the other hand, the effectiveness of dynamic race detectors is critically dependent on multithreaded test suites whose execution can be used to identify and trigger races. Usually, such multithreaded tests need to invoke a specific combination of methods with objects involved in the invocations being shared appropriately to expose a race. Without a priori knowledge of the race, construction of such tests can be challenging. In this paper, we present a lightweight and scalable technique for synthesizing precisely these kinds of tests. Given a multithreaded library and a sequential test suite, we describe a fully automated analysis that examines sequential execution traces, and produces as its output a concurrent client program that drives shared objects via library method calls to states conducive for triggering a race. Experimental results on a variety of well-tested Java libraries yield 101 synthesized multithreaded tests in less than four minutes. Analyzing the execution of these tests using an off-the-shelf race detector reveals 187 harmful races, including several previously unreported ones.", "paper_title": "Synthesizing Racy Tests", "paper_id": "WOS:000361284200017"}