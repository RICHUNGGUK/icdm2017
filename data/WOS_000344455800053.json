{"auto_keywords": [{"score": 0.04937375953276774, "phrase": "parallel_scripting_language"}, {"score": 0.025613089897828317, "phrase": "tardis"}, {"score": 0.00481495049065317, "phrase": "dynamic_enforcement_of_determinism"}, {"score": 0.004628101576367193, "phrase": "appealing_property"}, {"score": 0.004582528208024817, "phrase": "parallel_programs"}, {"score": 0.003989487818395848, "phrase": "dominant_design_goal"}, {"score": 0.00393066798511457, "phrase": "existing_parallel_languages"}, {"score": 0.0038727120021750973, "phrase": "type_system"}, {"score": 0.0036312482387007815, "phrase": "dynamic_languages"}, {"score": 0.0033050703534275717, "phrase": "appropriate_extensions"}, {"score": 0.003114283314285167, "phrase": "deterministic_parallel_ruby"}, {"score": 0.002993231973906559, "phrase": "run-time_system"}, {"score": 0.0028203950416405563, "phrase": "correct_usage"}, {"score": 0.0027650234530228897, "phrase": "commutative_operators"}, {"score": 0.002710735995572145, "phrase": "mutual_independence"}, {"score": 0.002605329434787829, "phrase": "concurrent_tasks"}, {"score": 0.002579622880371082, "phrase": "experimental_results"}, {"score": 0.0025415404222694, "phrase": "dpr"}, {"score": 0.002504011301105577, "phrase": "scalable_performance"}, {"score": 0.0024793019587009035, "phrase": "multicore_machines"}, {"score": 0.0023476849595393872, "phrase": "practical_testing"}, {"score": 0.0022563636435096457, "phrase": "alternative_data-race_detectors"}, {"score": 0.0021365562685368767, "phrase": "future_directions"}, {"score": 0.0021049977753042253, "phrase": "dynamic_enforcement"}], "paper_keywords": ["Design", " Languages", " Reliability", " Determinism", " deterministic parallelism", " data races", " scripting language"], "paper_abstract": "Determinism is an appealing property for parallel programs, as it simplifies understanding, reasoning and debugging. It is particularly appealing in dynamic (scripting) languages, where ease of programming is a dominant design goal. Some existing parallel languages use the type system to enforce determinism statically, but this is not generally practical for dynamic languages. In this paper, we describe how determinism can be obtained-and dynamically enforced/verified-for appropriate extensions to a parallel scripting language. Specifically, we introduce the constructs of Deterministic Parallel Ruby (DPR), together with a run-time system (TARDIS) that verifies properties required for determinism, including correct usage of reductions and commutative operators, and the mutual independence (data-race freedom) of concurrent tasks. Experimental results confirm that DPR can provide scalable performance on multicore machines and that the overhead of TARDIS is low enough for practical testing. In particular, TARDIS significantly outperforms alternative data-race detectors with comparable functionality. We conclude with a discussion of future directions in the dynamic enforcement of determinism.", "paper_title": "Dynamic Enforcement of Determinism in a Parallel Scripting Language", "paper_id": "WOS:000344455800053"}