{"auto_keywords": [{"score": 0.05007681166225229, "phrase": "hardware_api"}, {"score": 0.03355922214339965, "phrase": "api"}, {"score": 0.0047448515702010734, "phrase": "feature-based_operating_system_family"}, {"score": 0.004474468584252318, "phrase": "popular_class"}, {"score": 0.004430920292612374, "phrase": "course-grained_parallel_computer_architectures"}, {"score": 0.00413767314434795, "phrase": "legacy_software_components"}, {"score": 0.004097389262726735, "phrase": "application-specific_tailoring"}, {"score": 0.003901754272977278, "phrase": "model-driven_design_frameworks"}, {"score": 0.0038074544783102226, "phrase": "xilinx'_edk"}, {"score": 0.0035379628447303703, "phrase": "design_frameworks"}, {"score": 0.0034355662264234864, "phrase": "development_process_perspective"}, {"score": 0.003319830633865628, "phrase": "software-centric_approach"}, {"score": 0.0032237268289353983, "phrase": "hardware_api_concept"}, {"score": 0.003099888654615187, "phrase": "hardware_components"}, {"score": 0.003054681986032532, "phrase": "software_level"}, {"score": 0.002951739421935396, "phrase": "hardware_meta-model"}, {"score": 0.0028244513779243107, "phrase": "hardware_structure"}, {"score": 0.002783250284824728, "phrase": "access_patterns"}, {"score": 0.002689430273401131, "phrase": "static_code_analysis"}, {"score": 0.0025860636370864084, "phrase": "hardware_details"}, {"score": 0.002474505516708906, "phrase": "configuration_inconsistencies"}, {"score": 0.0024383967028975616, "phrase": "hardware_and_software_levels"}, {"score": 0.002321787726770895, "phrase": "development_process"}, {"score": 0.0021678232353129472, "phrase": "configurable_operating_system"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["HW/SW co-design", " Software-centric configuration", " Operating system", " MPSoC", " Hardware representation", " FPGA"], "paper_abstract": "Multiprocessor systems on a chip (MPSoCs) are a popular class of course-grained parallel computer architectures, which are very useful, because they support re-use of legacy software components and application-specific tailoring of hardware structures at the same time. Furthermore, model-driven design frameworks for MPSoCs such as Xilinx' EDK or our own LavA-framework facilitate very fast system development. However, in this paper we argue that these design frameworks are not ideal from the development process perspective. Instead, we propose a software-centric approach that is based on the hardware API concept. The API is a representation of hardware components on the software level, which is generated from a hardware meta-model. It allows us to automatically derive a hardware structure based on access patterns in software, revealed by a static code analysis. This trick reduces the number of hardware details the developer needs to deal with and avoids configuration inconsistencies between the hardware and software levels by design. Furthermore, we present how the development process can benefit from the hardware API, when the API is interfaced with a configurable operating system. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Interfacing the hardware API with a feature-based operating system family", "paper_id": "WOS:000367492700003"}