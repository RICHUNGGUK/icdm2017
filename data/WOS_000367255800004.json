{"auto_keywords": [{"score": 0.04923607408107278, "phrase": "pycket"}, {"score": 0.007372395871416531, "phrase": "jit"}, {"score": 0.007275055284309619, "phrase": "racket"}, {"score": 0.004425215632459868, "phrase": "wide_variety"}, {"score": 0.00436661740263741, "phrase": "sophisticated_features"}, {"score": 0.004121490798711703, "phrase": "dynamic_binding"}, {"score": 0.003942299471749811, "phrase": "standard_suite"}, {"score": 0.0038385317554884713, "phrase": "existing_compilers"}, {"score": 0.0036565634476050917, "phrase": "scheme"}, {"score": 0.0035118972210075633, "phrase": "racket_proxies"}, {"score": 0.0034807976670686628, "phrase": "existing_systems"}, {"score": 0.0033442114331500407, "phrase": "gradual_typing"}, {"score": 0.0032416819339366712, "phrase": "performance_evaluation"}, {"score": 0.0032129675521135616, "phrase": "multiple_existing_benchmark_suites"}, {"score": 0.0031703706626348507, "phrase": "pycket_implementation"}, {"score": 0.003128336741911927, "phrase": "independent_interest"}, {"score": 0.0030459283281463953, "phrase": "rpython_meta-tracing_framework"}, {"score": 0.0028875481626754696, "phrase": "jit_compilers"}, {"score": 0.0027989800906333784, "phrase": "meta-tracing_focuses"}, {"score": 0.002689076130099546, "phrase": "high-level_interpreter"}, {"score": 0.002641621667026613, "phrase": "cek_abstract_machine"}, {"score": 0.00258347644721642, "phrase": "abstract_syntax_trees"}, {"score": 0.002537880772794665, "phrase": "proper_tail_calls"}, {"score": 0.002515384834484012, "phrase": "first-class_continuations"}, {"score": 0.002438203996977464, "phrase": "functional_language"}, {"score": 0.002405853977978678, "phrase": "recursion_and_higher-order_functions"}, {"score": 0.002352886041381761, "phrase": "explicit_loops"}], "paper_keywords": ["Experimentation", " Languages", " Measurement", " Performance", " JIT compilers", " contracts", " tracing", " functional languages", " Racket"], "paper_abstract": "We present Pycket, a high-performance tracing JIT compiler for Racket. Pycket supports a wide variety of the sophisticated features in Racket such as contracts, continuations, classes, structures, dynamic binding, and more. On average, over a standard suite of benchmarks, Pycket outperforms existing compilers, both Racket's JIT and other highly-optimizing Scheme compilers. Further, Pycket provides much better performance for Racket proxies than existing systems, dramatically reducing the overhead of contracts and gradual typing. We validate this claim with performance evaluation on multiple existing benchmark suites. The Pycket implementation is of independent interest as an application of the RPython meta-tracing framework (originally created for PyPy), which automatically generates tracing JIT compilers from interpreters. Prior work on meta-tracing focuses on bytecode interpreters, whereas Pycket is a high-level interpreter based on the CEK abstract machine and operates directly on abstract syntax trees. Pycket supports proper tail calls and first-class continuations. In the setting of a functional language, where recursion and higher-order functions are more prevalent than explicit loops, the most significant performance challenge for a tracing JIT is identifying which control flows constitute a loop-we discuss two strategies for identifying loops and measure their impact.", "paper_title": "Pycket: A Tracing JIT for a Functional Language", "paper_id": "WOS:000367255800004"}