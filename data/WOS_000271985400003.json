{"auto_keywords": [{"score": 0.0479944128286434, "phrase": "relativized_hyperequivalence"}, {"score": 0.015719716506582538, "phrase": "logic_programs"}, {"score": 0.01552332939750404, "phrase": "modular_programming"}, {"score": 0.011545003503602824, "phrase": "context_programs"}, {"score": 0.004664352260912174, "phrase": "recent_framework"}, {"score": 0.004461359547152617, "phrase": "unifying_generalization"}, {"score": 0.004404994123834589, "phrase": "strong_and_uniform_equivalence"}, {"score": 0.004081385289516914, "phrase": "program_optimization"}, {"score": 0.003144222265269426, "phrase": "minimal_models"}, {"score": 0.0025810006125483835, "phrase": "hyperequivalence_relative"}], "paper_keywords": ["answer-set programming", " strong equivalence", " uniform equivalence", " relativized equivalence", " stable models", " supported models", " minimal models", " complexity"], "paper_abstract": "A recent framework of relativized hyperequivalence of programs offers a unifying generalization of strong and uniform equivalence. It seems to be especially well suited for applications in program optimization and modular programming due to its flexibility that allows us to restrict, independently of each other, the head and body alphabets in context programs. We study relativized hyperequivalence for the three semantics of logic programs given by stable, supported, and supported minimal models. For each semantics, we identify four types of contexts, depending on whether the head and body alphabets are given directly or as the complement of a given set. Hyperequivalence relative to contexts where the head and body alphabets are specified directly has been studied before. In this paper, we establish the complexity of deciding relativized hyperequivalence with respect to the three other types of context programs.", "paper_title": "Relativized hyperequivalence of logic programs for modular programming", "paper_id": "WOS:000271985400003"}