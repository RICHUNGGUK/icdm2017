{"auto_keywords": [{"score": 0.04518073439008109, "phrase": "parallel_computations"}, {"score": 0.04392623154267514, "phrase": "mutable_references"}, {"score": 0.00481495049065317, "phrase": "ml-like_languages"}, {"score": 0.004474468584252318, "phrase": "higher-order_channels"}, {"score": 0.004409304640026443, "phrase": "advanced_form"}, {"score": 0.004366387782457736, "phrase": "task_parallelism"}, {"score": 0.004057495982111461, "phrase": "safety_problem"}, {"score": 0.003920891569777891, "phrase": "remote_threads"}, {"score": 0.003697287104870263, "phrase": "ml-like_parallel_language"}, {"score": 0.003661275004971829, "phrase": "type-safe_higher-order_channels"}, {"score": 0.003054681986032532, "phrase": "type_system"}, {"score": 0.0030101325901285537, "phrase": "typing_judgment"}, {"score": 0.002598764579760562, "phrase": "desirable_feature"}, {"score": 0.0024383967028975616, "phrase": "unique_thread"}, {"score": 0.002287902310873394, "phrase": "sequential_computations"}, {"score": 0.0021049977753042253, "phrase": "sequential_programming"}], "paper_keywords": ["languages", " higher-order channels", " channel locality", " parallel languages", " distributed languages"], "paper_abstract": "As a means of transmitting not only data but also code encapsulated within functions, higher-order channels provide an advanced form of task parallelism in parallel computations. In the presence of mutable references, however, they pose a safety problem because references may be transmitted to remote threads where they are no longer valid. This paper presents an ML-like parallel language with type-safe higher-order channels. By type safety, we mean that no value written to a channel contains references, or equivalently, that no reference escapes via a channel from the thread where it is created. The type system uses a typing judgment that is capable of deciding whether the value to which a term evaluates contains references or not. The use of such a typing judgment also makes it easy to achieve another desirable feature of channels, channel locality, that associates every channel with a unique thread for serving all values addressed to it. Our type system permits mutable references in sequential computations and also ensures that mutable references never interfere with parallel computations. Thus it provides both flexibility in sequential programming and ease of implementing parallel computations.", "paper_title": "Type-safe higher-order channels in ML-like languages", "paper_id": "WOS:000253409900021"}