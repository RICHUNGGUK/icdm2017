{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "optimal_spilling"}, {"score": 0.00473509474652851, "phrase": "ssa._recent_developments"}, {"score": 0.0047035227618053965, "phrase": "register_allocation"}, {"score": 0.004625506452304716, "phrase": "static_single_assignment"}, {"score": 0.004197758831410097, "phrase": "register_pressure"}, {"score": 0.0039259432210911925, "phrase": "physical_registers"}, {"score": 0.0038478705530517296, "phrase": "move_instructions"}, {"score": 0.0037336520904376687, "phrase": "first_phase"}, {"score": 0.003410871299189454, "phrase": "ssa_form"}, {"score": 0.003287482882222731, "phrase": "important_features"}, {"score": 0.0032328778271536454, "phrase": "load-store_architectures"}, {"score": 0.00317917686846757, "phrase": "new_integer_linear_programming_formulation"}, {"score": 0.0031054861345720854, "phrase": "previous_approaches"}, {"score": 0.0030233510365494406, "phrase": "ssa_phi-functions"}, {"score": 0.003003157931633302, "phrase": "memory-to-memory_copies"}, {"score": 0.0027525658515943985, "phrase": "thorough_analysis"}, {"score": 0.0023277839538663834, "phrase": "conventional_ssa"}, {"score": 0.0022661710658109916, "phrase": "microarchitectural_features"}, {"score": 0.0021549990311897347, "phrase": "significant_savings"}, {"score": 0.0021049977753042253, "phrase": "static_spill_costs"}], "paper_keywords": ["Algorithms", " Experimentation", " Performance", " Theory", " Register allocation", " spilling", " static single assignment form", " performance models"], "paper_abstract": "Recent developments in register allocation, mostly linked to static single assignment (SSA) form, have shown the benefits of decoupling the problem in two phases: a first spilling phase places load and store instructions so that the register pressure at all program points is small enough, and a second assignment and coalescing phase maps the variables to physical registers and reduces the number of move instructions among registers. This article focuses on the first phase, for which many open questions remain: in particular, we study the notion of optimal spilling (what can be expressed?) and the impact of SSA form (does it help?). To identify the important features for optimal spilling on load-store architectures, we develop a new integer linear programming formulation, more accurate and expressive than previous approaches. Among other features, we can express SSA phi-functions, memory-to-memory copies, and the fact that a value can be stored simultaneously in a register and inmemory. Based on this formulation, we present a thorough analysis of the results obtained for the SPECINT 2000 and EEMBC 1.1 benchmarks, from which we draw, among others, the following conclusions: (1) rematerialization is extremely important; (2) SSA complicates the formulation of optimal spilling, especially because of memory coalescing when the code is not in conventional SSA (CSSA); (3) microarchitectural features are significant and thus have to be accounted for; and (4) significant savings can be obtained in terms of static spill costs, cache miss rates, and dynamic instruction counts.", "paper_title": "Studying Optimal Spilling in the Light of SSA", "paper_id": "WOS:000348232000013"}