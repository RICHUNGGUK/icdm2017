{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "function's_body"}, {"score": 0.0046578649614541995, "phrase": "function_call"}, {"score": 0.004588158931776543, "phrase": "additional_optimization_opportunities"}, {"score": 0.004478782833067256, "phrase": "redundant_operations"}, {"score": 0.00445184683414215, "phrase": "unused_conditional_branches"}, {"score": 0.004319566932528865, "phrase": "redundant_copy"}, {"score": 0.004280651472525981, "phrase": "still-live_variable"}, {"score": 0.004216566615939546, "phrase": "copy_propagation"}, {"score": 0.004165987300206134, "phrase": "total_number"}, {"score": 0.004140924670517666, "phrase": "live_variables"}, {"score": 0.004103611985528699, "phrase": "register_pressure"}, {"score": 0.004078923069461593, "phrase": "memory_usage"}, {"score": 0.004017846065981193, "phrase": "redundant_memory-to-memory_copies"}, {"score": 0.0038749521906474593, "phrase": "nearly_every_modern_compiler"}, {"score": 0.0037484181615819318, "phrase": "first-order_languages"}, {"score": 0.0036811433915589216, "phrase": "lexically-scoped_first-class_functions"}, {"score": 0.003496994062890991, "phrase": "higher-order_style"}, {"score": 0.003465463460811278, "phrase": "higher-order_functions"}, {"score": 0.0034342161742428666, "phrase": "analysis_challenge"}, {"score": 0.003352256019007896, "phrase": "call_site"}, {"score": 0.0032722454818973853, "phrase": "closure_capture_location"}, {"score": 0.003223208419566199, "phrase": "free_variables"}, {"score": 0.002813566267090177, "phrase": "higher-order_optimizations"}, {"score": 0.0027713837460773974, "phrase": "functional-language_compilers"}, {"score": 0.0027133856739937133, "phrase": "higher-order_values"}, {"score": 0.002640591917408814, "phrase": "compiler_benchmarks"}, {"score": 0.0025853238923610076, "phrase": "first_practical_and_effective_technique"}, {"score": 0.0025697460140513932, "phrase": "super-beta"}, {"score": 0.0023258192563656204, "phrase": "real_compiler"}, {"score": 0.002304824112812496, "phrase": "ml-family_language"}, {"score": 0.0022702515669908306, "phrase": "required_analyses"}, {"score": 0.002222717552124615, "phrase": "total_compilation_time"}, {"score": 0.002202651051682622, "phrase": "technique's_effectiveness"}, {"score": 0.002143529653780496, "phrase": "example_programs"}, {"score": 0.0021049977753042253, "phrase": "additional_potential_optimization_sites"}], "paper_keywords": ["control-flow analysis", " inlining", " optimization"], "paper_abstract": "Inlining is an optimization that replaces a call to a function with that function's body. This optimization not only reduces the overhead of a function call, but can expose additional optimization opportunities to the compiler, such as removing redundant operations or unused conditional branches. Another optimization, copy propagation, replaces a redundant copy of a still-live variable with the original. Copy propagation can reduce the total number of live variables, reducing register pressure and memory usage, and possibly eliminating redundant memory-to-memory copies. In practice, both of these optimizations are implemented in nearly every modern compiler. These two optimizations are practical to implement and effective in first-order languages, but in languages with lexically-scoped first-class functions (aka, closures), these optimizations are not available to code programmed in a higher-order style. With higher-order functions, the analysis challenge has been that the environment at the call site must be the same as at the closure capture location, up to the free variables, or the meaning of the program may change. Olin Shivers' 1991 dissertation called this family of optimizations Super-beta and he proposed one analysis technique, called reflow, to support these optimizations. Unfortunately, reflow has proven too expensive to implement in practice. Because these higher-order optimizations are not available in functional-language compilers, programmers studiously avoid uses of higher-order values that cannot be optimized (particularly in compiler benchmarks). This paper provides the first practical and effective technique for Super-beta (higher-order) inlining and copy propagation, which we call unchanged variable analysis. We show that this technique is practical by implementing it in the context of a real compiler for an ML-family language and showing that the required analyses have costs below 3% of the total compilation time. This technique's effectiveness is shown through a set of benchmarks and example programs, where this analysis exposes additional potential optimization sites.", "paper_title": "Practical and Effective Higher-Order Optimizations", "paper_id": "WOS:000349143000008"}