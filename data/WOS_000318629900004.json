{"auto_keywords": [{"score": 0.048004834084269796, "phrase": "finite_data"}, {"score": 0.009344889035059051, "phrase": "pattern_matching"}, {"score": 0.007833962360264717, "phrase": "infinite_data"}, {"score": 0.00481495049065317, "phrase": "copatterns_programming_infinite_structures"}, {"score": 0.004721162131188487, "phrase": "inductive_datatypes"}, {"score": 0.004539005582217309, "phrase": "finite_lists"}, {"score": 0.004053362743156545, "phrase": "dual_approach"}, {"score": 0.003974349782102708, "phrase": "infinite_data_structures"}, {"score": 0.0037463983616303786, "phrase": "greatest_fixpoints"}, {"score": 0.0032319109979344184, "phrase": "copattern_matching"}, {"score": 0.0030314419455512013, "phrase": "symmetric_language_design"}, {"score": 0.002986969236641105, "phrase": "finite_and_infinite_data"}, {"score": 0.0028715299874549245, "phrase": "core_language"}, {"score": 0.0028154895878702633, "phrase": "infinite_structures"}, {"score": 0.0024405312482831646, "phrase": "value_interpretations"}, {"score": 0.002357755095722877, "phrase": "existing_languages"}, {"score": 0.002334632715868078, "phrase": "haskell"}, {"score": 0.0022777800735119405, "phrase": "type_soundness"}, {"score": 0.0021896891011033105, "phrase": "new_directions"}, {"score": 0.0021049977753042253, "phrase": "coinductive_and_dependent_types"}], "paper_keywords": ["Languages", " Theory", " Coinduction", " Functional programming", " Introduction vs. elimination", " Message passing", " Pattern matching"], "paper_abstract": "Inductive datatypes provide mechanisms to define finite data such as finite lists and trees via constructors and allow programmers to analyze and manipulate finite data via pattern matching. In this paper, we develop a dual approach for working with infinite data structures such as streams. Infinite data inhabits coinductive datatypes which denote greatest fixpoints. Unlike finite data which is defined by constructors we define infinite data by observations. Dual to pattern matching, a tool for analyzing finite data, we develop the concept of copattern matching, which allows us to synthesize infinite data. This leads to a symmetric language design where pattern matching on finite and infinite data can be mixed. We present a core language for programming with infinite structures by observations together with its operational semantics based on (co) pattern matching and describe coverage of copatterns. Our language naturally supports both call-by-name and call-by-value interpretations and can be seamlessly integrated into existing languages like Haskell and ML. We prove type soundness for our language and sketch how copatterns open new directions for solving problems in the interaction of coinductive and dependent types.", "paper_title": "Copatterns Programming Infinite Structures by Observations", "paper_id": "WOS:000318629900004"}