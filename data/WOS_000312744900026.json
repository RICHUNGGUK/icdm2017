{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "data_representation_synthesis"}, {"score": 0.00436890075128947, "phrase": "data_structures"}, {"score": 0.004284755353695709, "phrase": "complex_sharing"}, {"score": 0.0038876302202924644, "phrase": "provably_correct_code"}, {"score": 0.0037030390595465673, "phrase": "abstract_data_types"}, {"score": 0.0035616743422949766, "phrase": "relational_algebra"}, {"score": 0.003493021648360933, "phrase": "functional_dependencies"}, {"score": 0.003048001809453513, "phrase": "different_concrete_representations"}, {"score": 0.0027922467043592597, "phrase": "concrete_representations"}, {"score": 0.002436289099444074, "phrase": "best_decomposition"}, {"score": 0.002366110899738696, "phrase": "particular_workload"}, {"score": 0.0022101055924375725, "phrase": "data_representations"}, {"score": 0.0021049977753042253, "phrase": "existing_systems"}], "paper_keywords": [""], "paper_abstract": "We consider the problem of specifying combinations of data structures with complex sharing in a manner that is declarative and results in provably correct code. In our approach, abstract data types are specified using relational algebra and functional dependencies. We describe a language of decompositions that permits the user to specify different concrete representations for relations, and show that operations on concrete representations soundly implement their relational specification. We also describe an auto-tuner that automatically identifies the best decomposition for a particular workload. It is easy to incorporate data representations synthesized by our compiler into existing systems, leading to code that is simpler, correct by construction, and comparable in performance to the code it replaces.", "paper_title": "An Introduction to Data Representation Synthesis", "paper_id": "WOS:000312744900026"}