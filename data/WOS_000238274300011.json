{"auto_keywords": [{"score": 0.05007843022623741, "phrase": "program_logic"}, {"score": 0.038521130357784844, "phrase": "abadi"}, {"score": 0.004565007074039171, "phrase": "imperative_and_object-based_programming_language"}, {"score": 0.003614895644619489, "phrase": "leino"}, {"score": 0.003427032390942116, "phrase": "object_types"}, {"score": 0.003381607100127276, "phrase": "method_specifications"}, {"score": 0.0032706520949775065, "phrase": "new_soundness_proof"}, {"score": 0.0031845067058084583, "phrase": "denotational_semantics"}, {"score": 0.0030189426536422577, "phrase": "store_specifications"}, {"score": 0.0029198522863606953, "phrase": "mixed-variant_recursion"}, {"score": 0.002438203996977464, "phrase": "leino's_logic"}, {"score": 0.002405853977978678, "phrase": "incidental_design_decisions"}, {"score": 0.002250415129116109, "phrase": "higher-order_store"}], "paper_keywords": [""], "paper_abstract": "The object-calculus is an imperative and object-based programming language in which every object comes equipped with its own method suite. Consequently, methods need to reside in the store ('higher-order store'), which complicates the semantics. Abadi and Leino defined a program logic for this language enriching object types by method specifications. We present a new soundness proof for their logic using denotational semantics. It turns out that denotations of store specifications are predicates defined by mixed-variant recursion. A benefit of our approach is that derivability and validity can be kept distinct. Moreover, it reveals which of the limitations of Abadi and Leino's logic are incidental design decisions and which follow inherently from the use of a higher-order store. We discuss the implications for the development of other, more expressive, program logics.", "paper_title": "Denotational semantics for a program logic of objects", "paper_id": "WOS:000238274300011"}