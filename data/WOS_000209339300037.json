{"auto_keywords": [{"score": 0.032443420576454676, "phrase": "region_scheduling"}, {"score": 0.00481495049065317, "phrase": "cache_architectures"}, {"score": 0.004782455247247007, "phrase": "page-level_affinity"}, {"score": 0.004702168843383725, "phrase": "modern_many-core_platforms"}, {"score": 0.004454158739805578, "phrase": "memory-centric_approach"}, {"score": 0.004276736877590646, "phrase": "memory_blocks"}, {"score": 0.004204904449336037, "phrase": "cpu_idleness"}, {"score": 0.00414830454375092, "phrase": "application_processes"}, {"score": 0.003956113993518042, "phrase": "current_set"}, {"score": 0.003929391999210588, "phrase": "physical_memory_pages"}, {"score": 0.003772793879444995, "phrase": "region-based_scheduling_methods"}, {"score": 0.00357362651129581, "phrase": "memory_regions"}, {"score": 0.0035374660789922715, "phrase": "executable_entities"}, {"score": 0.003350679980619693, "phrase": "performance_goals"}, {"score": 0.003141598480804135, "phrase": "direct_access"}, {"score": 0.002975652654536407, "phrase": "improved_performance"}, {"score": 0.002895986736522535, "phrase": "multiple_caches"}, {"score": 0.0028569549040495163, "phrase": "underlying_physical_machine"}, {"score": 0.002799388549023265, "phrase": "cache_usage"}, {"score": 0.002771040606604632, "phrase": "maximum_advantage"}, {"score": 0.0027523011981394835, "phrase": "available_cache_space"}, {"score": 0.0025804616931593897, "phrase": "cache_availability"}, {"score": 0.002494361792853833, "phrase": "standard_scheduling_and_cpu-based_load_balancing"}, {"score": 0.002338588929719847, "phrase": "representative_multi-core_applications"}, {"score": 0.0022992346264367374, "phrase": "performance_improvements"}, {"score": 0.0021776870246727233, "phrase": "multiple_applications"}, {"score": 0.002162951519368368, "phrase": "superior_isolation"}, {"score": 0.0021049977753042253, "phrase": "cache-sensitive_or_real-time_codes"}], "paper_keywords": ["Performance", " Design", " Experimentation", " Virtualization", " Xen", " Cache", " Memory", " Region", " Server Consolidation"], "paper_abstract": "The performance of modern many-core platforms strongly depends on the effectiveness of using their complex cache and memory structures. This indicates the need for a memory-centric approach to platform scheduling, in which it is the locations of memory blocks in caches rather than CPU idleness that determines where application processes are run. Using the term 'memory region' to denote the current set of physical memory pages actively used by an application, this paper presents and evaluates region-based scheduling methods for multicore platforms. This involves (i) continuously and at runtime identifying the memory regions used by executable entities, and their sizes, (ii) mapping these regions to caches to match performance goals, and (iii) maintaining region to cache mappings by ensuring that entities run on processors with direct access to the caches containing their regions. Region scheduling can implement policies that (i) offer improved performance to applications by 'unifying' the multiple caches present on the underlying physical machine and/or by 'balancing' cache usage to take maximum advantage of available cache space, (ii) better isolate applications from each other, particularly when their performance is strongly affected by cache availability, and also (iii) take advantage of standard scheduling and CPU-based load balancing when regioning is ineffective. The paper describes region scheduling and its system-level implementation and evaluates its performance with micro-benchmarks and representative multi-core applications. Single applications see performance improvements of up to 15% with region scheduling, and we observe 40% latency improvements when a platform is shared by multiple applications. Superior isolation is shown to be particularly important for cache-sensitive or real-time codes.", "paper_title": "Region Scheduling: Efficiently Using the Cache Architectures via Page-level Affinity", "paper_id": "WOS:000209339300037"}