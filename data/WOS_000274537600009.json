{"auto_keywords": [{"score": 0.04745358435978179, "phrase": "right_arrow"}, {"score": 0.0075620548328978075, "phrase": "code_length"}, {"score": 0.007352600599618189, "phrase": "locally_decodable_code_c"}, {"score": 0.00481495049065317, "phrase": "subexponential_length"}, {"score": 0.004626605569565759, "phrase": "q_n_error-correcting_code"}, {"score": 0.003796463564357421, "phrase": "integer_r"}, {"score": 0.0036754026483561764, "phrase": "randomized_decoding_algorithm"}, {"score": 0.0030240178370021737, "phrase": "proc"}, {"score": 0.003002734955136739, "phrase": "stoc"}, {"score": 0.0028850681778695765, "phrase": "mersenne"}, {"score": 0.0023291369393531993, "phrase": "improved_constructions"}, {"score": 0.002318202485845406, "phrase": "query-efficient_locally_decodable_codes"}, {"score": 0.0022696277881969896, "phrase": "locally_decodable_codes"}], "paper_keywords": ["locally decodable codes", " S-matching vectors", " S-decoding polynomials", " perfectly smooth decoders", " private information retrieval"], "paper_abstract": "A (k, delta, epsilon)-locally decodable code C : F-q(n) --> F-q(N) is an q N error-correcting code that encodes (x) over right arrow = (x(1), x(2), ..., x(n)) is an element of F-q(n) to C((x) over right arrow) is an element of F-q(N) and has the following property: For any (y) over right arrow is an element of F-q(N) such that d((y) over right arrow, C((x) over right arrow) <= delta N and each 1 <= i <= n, the symbol x(i) of (x) over right arrow can be recovered with probability at least 1 - epsilon by a randomized decoding algorithm looking at only k coordinates of (y) over right arrow. The efficiency of a (k, delta, epsilon)-locally decodable code C : F-q(n) --> F-q(N) is measured by the code length N and the number k of queries. For a k-query locally decodable code C : F-q(n) --> F-q(N), the code length N was conjectured to be exponential of it, i.e., N = exp(n(Omega(1))), however, this was disproved. Yekhanin [In Proc. of STOC, 2007] showed that there exists a 3-query locally decodable code C : F-2(n) --> F-2(N) such that N = exp(n(1/log log n)) assuming that infinitely many Mersenne primes exist, For a 3-query locally decodable code C : F-q(n) --> F-q(N), Efremenko [ECCC Report No.69,2008] further reduced the code length to N = exp(n(O((log log) (n/log) (n)1/2))), and in general showed that for any integer r > 1, there exists a 2(r)-query locally decodable code C : F-q(n) --> F-q(N) such that N = exp(n(O(log log n/ log n)1-1/r))). In this paper, we will present improved constructions for query-efficient locally decodable codes by introducing a technique of \"composition of locally decodable codes,\" and show that for any integer r > 5, there exists a 9 . 2(r-4)-query locally decodable code C : F-q(n) --> F-q(N) such that N = exp(n(O((log log n/ log n)1-1/r))).", "paper_title": "Improved Constructions for Query-Efficient Locally Decodable Codes of Subexponential Length", "paper_id": "WOS:000274537600009"}