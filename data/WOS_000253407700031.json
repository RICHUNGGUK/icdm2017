{"auto_keywords": [{"score": 0.04704420838626198, "phrase": "atomic_sections"}, {"score": 0.00481495049065317, "phrase": "lock_allocation"}, {"score": 0.004591345494188032, "phrase": "multi-threaded_program"}, {"score": 0.0041995784967999985, "phrase": "lock_assignment"}, {"score": 0.004149922666541166, "phrase": "global_variables"}, {"score": 0.004028326293950714, "phrase": "lock_instrumentation"}, {"score": 0.003706410380455668, "phrase": "resulting_instrumented_program"}, {"score": 0.0035551969986263553, "phrase": "deadlock_freedom"}, {"score": 0.0034715658596258018, "phrase": "shared_state"}, {"score": 0.0030454408569868347, "phrase": "lock_allocation_problem"}, {"score": 0.002921114512115261, "phrase": "conflict_cost"}, {"score": 0.002577762494764253, "phrase": "java"}, {"score": 0.002399850604120431, "phrase": "aolserver_code"}, {"score": 0.0023018188296933923, "phrase": "hand_annotations"}, {"score": 0.002168664249034287, "phrase": "optimization_instances"}], "paper_keywords": ["languages", " algorithms", " atomicity", " lock inference", " ILP"], "paper_abstract": "We introduce lock allocation, an automatic technique that takes a multi-threaded program annotated with atomic sections (that must be executed atomically), and infers a lock assignment from global variables to locks and a lock instrumentation that determines where each lock should be acquired and released such that the resulting instrumented program is guaranteed to preserve atomicity and deadlock freedom (provided all shared state is accessed only within atomic sections). Our algorithm works in the presence of pointers and procedures, and sets up the lock allocation problem as a 0-1 ILP which minimizes the conflict cost between atomic sections while simultaneously minimizing the number of locks. We have implemented our algorithm for both C with pthreads and Java, and have applied it to infer locks in 15K lines of AOLserver code. Our automatic allocation produces the same results as hand annotations for most of this code, while solving the optimization instances within a second for most programs.", "paper_title": "Lock allocation", "paper_id": "WOS:000253407700031"}