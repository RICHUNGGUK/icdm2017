{"auto_keywords": [{"score": 0.045236638474264644, "phrase": "memory_model"}, {"score": 0.0414747929403005, "phrase": "testing_problem"}, {"score": 0.006102512671816023, "phrase": "steinke-nutt_hierarchy"}, {"score": 0.005590846269532015, "phrase": "memory_models"}, {"score": 0.00481495049065317, "phrase": "unified_complexity_analysis"}, {"score": 0.004713702303619539, "phrase": "memory_system"}, {"score": 0.004663875663629251, "phrase": "weak_memory_consistency_models"}, {"score": 0.004639159282212062, "phrase": "weak_memory_models"}, {"score": 0.004614573278897633, "phrase": "different_views"}, {"score": 0.004410760907029884, "phrase": "program_analyses"}, {"score": 0.004295083912947681, "phrase": "targeted_hardware"}, {"score": 0.004227132853636806, "phrase": "numerous_memory_models"}, {"score": 0.004029636266402555, "phrase": "prominent_approach"}, {"score": 0.004008267524489621, "phrase": "program_analysis"}, {"score": 0.003923915284959959, "phrase": "input_sequences"}, {"score": 0.0038209573436122414, "phrase": "concurrent_program"}, {"score": 0.003642368336280774, "phrase": "entire_program"}, {"score": 0.0034353499299367707, "phrase": "known_memory_models"}, {"score": 0.0032660238803713104, "phrase": "concurrent_processes"}, {"score": 0.0031718222834860492, "phrase": "shared_variables"}, {"score": 0.003121586251550337, "phrase": "related_results"}, {"score": 0.0030967664671042445, "phrase": "uniform_approach"}, {"score": 0.0029755883351975433, "phrase": "steinke"}, {"score": 0.002959792195481946, "phrase": "nutt"}, {"score": 0.002912904241423194, "phrase": "existing_memory_models"}, {"score": 0.0027914598613605576, "phrase": "latter's_behavior"}, {"score": 0.0025909569700927324, "phrase": "problem_reductions"}, {"score": 0.0025771976533995205, "phrase": "complexity_theory"}, {"score": 0.002563511217968509, "phrase": "so-called_range_reductions"}, {"score": 0.0024762995340883013, "phrase": "np_lower_bounds"}, {"score": 0.0024565977916167665, "phrase": "stronger_memory_models"}, {"score": 0.0024176621712770664, "phrase": "weaker_models"}, {"score": 0.0023920477114211104, "phrase": "polynomial-time_testing_algorithms"}, {"score": 0.0023604100222616668, "phrase": "determinization_algorithms"}, {"score": 0.002304510517364523, "phrase": "single_sat_encoding"}, {"score": 0.002208389380077343, "phrase": "np."}, {"score": 0.0021560682451536566, "phrase": "future_weak_memory_models"}, {"score": 0.002116241428289309, "phrase": "sat_solvers"}, {"score": 0.0021049977753042253, "phrase": "adequate_tools"}], "paper_keywords": ["Weak memory models", " testing", " complexity analysis", " NP-completeness", " SAT"], "paper_abstract": "To improve the performance of the memory system, multiprocessors implement weak memory consistency models. Weak memory models admit different views of the processes on their load and store instructions, thus allowing for computations that are not sequentially consistent. Program analyses have to take into account the memory model of the targeted hardware. This is challenging because numerous memory models have been developed, and every memory model requires its own analysis. In this article, we study a prominent approach to program analysis: testing. The testing problem takes as input sequences of operations, one for each process in the concurrent program. The task is to check whether these sequences can be interleaved to an execution of the entire program that respects the constraints of a memory model under consideration. We determine the complexity of the testing problem for most of the known memory models. Moreover, we study the impact on the complexity of parameters, such as the number of concurrent processes, the length of their executions, and the number of shared variables. What differentiates our contribution from related results is a uniform approach that avoids considering each memory model on its own. We build upon work of Steinke and Nutt. They showed that the existing memory models form a hierarchy where one model is called weaker than another one if it includes the latter's behavior. Using the Steinke-Nutt hierarchy, we develop three general concepts that allow us to quickly determine the complexity of a testing problem. First, we generalize the technique of problem reductions from complexity theory. So-called range reductions propagate hardness results between memory models, and we apply them to establish NP lower bounds for the stronger memory models. Second, for the weaker models, we present polynomial-time testing algorithms that are inspired by determinization algorithms for automata. Finally, we describe a single SAT encoding of the testing problem that works for all memory models in the Steinke-Nutt hierarchy to prove their membership in NP. Our results are general enough to carry over to future weak memory models. Moreover, they show that SAT solvers are adequate tools for testing.", "paper_title": "Memory-Model-Aware Testing: A Unified Complexity Analysis", "paper_id": "WOS:000367206600003"}