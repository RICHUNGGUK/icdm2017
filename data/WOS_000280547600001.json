{"auto_keywords": [{"score": 0.03164512769284701, "phrase": "interface_descriptions"}, {"score": 0.0046659637258752535, "phrase": "modern_compilers"}, {"score": 0.004562362497952548, "phrase": "predetermined_set"}, {"score": 0.004521566043596533, "phrase": "primitive_types"}, {"score": 0.0042650992966174065, "phrase": "user-defined_types"}, {"score": 0.0037948184359488284, "phrase": "new_optimizations"}, {"score": 0.0035794251590584563, "phrase": "reuse_methodologies"}, {"score": 0.0035473867669654174, "phrase": "generic_programming"}, {"score": 0.0035156341294017685, "phrase": "compiler_analyses"}, {"score": 0.0032716011062067286, "phrase": "particular_types"}, {"score": 0.0031559919178954644, "phrase": "generic_interface_descriptions"}, {"score": 0.003071965703296204, "phrase": "haskell_type_classes"}, {"score": 0.00295008998986066, "phrase": "associated_program_analysis"}, {"score": 0.002820319063320601, "phrase": "user-defined_transformations"}, {"score": 0.0026009105281485888, "phrase": "generic_fashion"}, {"score": 0.0025089420019955232, "phrase": "classical_compiler_optimizations"}, {"score": 0.0023770362063833903, "phrase": "broad_range"}, {"score": 0.0021920373388760314, "phrase": "initial_implementation"}], "paper_keywords": ["Languages", " Performance", " Generic programming", " compiler optimization", " program analysis"], "paper_abstract": "The optimizations in modern compilers are constructed for a predetermined set of primitive types. As a result, programmers are unable to exploit optimizations for user-defined types where these optimizations would be correct and beneficial. Moreover, because the set of optimizations is also fixed, programmers are unable to incorporate new optimizations into the compiler. To address these limitations, we apply the reuse methodologies from generic programming to compiler analyses and optimizations. To enable compilers to apply optimizations to classes of types rather than particular types, we define optimizations in terms of generic interface descriptions (similar to C++ concepts or Haskell type classes). By extending these interface descriptions to include associated program analysis and transformation fragments, we enable compilers to incorporate user-defined transformations and analyses. Since these transformations are explicitly associated with interface descriptions, they can be applied in generic fashion by the compiler. We demonstrate that classical compiler optimizations, when generalized using this framework, can apply to a broad range of types, both built-in and user-defined. Finally, we present an initial implementation, the principles of which are generalizable to other compilers.", "paper_title": "Reusable, Generic Program Analyses and Transformations", "paper_id": "WOS:000280547600001"}