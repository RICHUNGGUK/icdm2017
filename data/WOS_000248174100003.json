{"auto_keywords": [{"score": 0.027580823811834767, "phrase": "update_calculus"}, {"score": 0.014072355232138498, "phrase": "text_editors"}, {"score": 0.009730148845696509, "phrase": "update_language"}, {"score": 0.00481495049065317, "phrase": "type-safe_program_updates"}, {"score": 0.004711843410316589, "phrase": "software_development_costs"}, {"score": 0.004644329185633612, "phrase": "software_maintenance"}, {"score": 0.0044635893862404385, "phrase": "changing_requirements"}, {"score": 0.004034504342397309, "phrase": "logical_errors"}, {"score": 0.003794297119656863, "phrase": "whole_program"}, {"score": 0.0034541965053691307, "phrase": "\"text-editor_method"}, {"score": 0.0034046409849387365, "phrase": "low-level_view"}, {"score": 0.003178758306417406, "phrase": "programming-language-based_approach"}, {"score": 0.0029358111718032704, "phrase": "update_programs"}, {"score": 0.002872827714395808, "phrase": "essential_part"}, {"score": 0.002821371992763293, "phrase": "scope_update"}, {"score": 0.002790940765338191, "phrase": "coordinated_update"}, {"score": 0.0026628098176168682, "phrase": "underlying_basis"}, {"score": 0.002643624979574088, "phrase": "update_languages"}, {"score": 0.0025682543875086934, "phrase": "lambda_calculus_programs"}, {"score": 0.002522240133079871, "phrase": "type_system"}, {"score": 0.0024591984725764954, "phrase": "possible_type_changes"}, {"score": 0.0023977287074829798, "phrase": "update_program"}, {"score": 0.002354762471810519, "phrase": "type-safe_update_programs"}, {"score": 0.0023042157412517333, "phrase": "type_correctness"}, {"score": 0.0022876085523721324, "phrase": "lambda_terms"}, {"score": 0.0022063469115990715, "phrase": "higher-level_update_languages"}, {"score": 0.0021668156107991082, "phrase": "haskell"}, {"score": 0.0021512431753665353, "phrase": "java"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["program transformation", " meta programming", " type safety", " refactoring", " software evolution"], "paper_abstract": "The dominant share of software development costs is spent on software maintenance, particularly the process of updating programs in response to changing requirements. Currently, such program changes tend to be performed using text editors, an unreliable method that often causes many errors. In addition to syntax and type errors, logical errors can be easily introduced since text editors cannot guarantee that changes are performed consistently over the whole program. All these errors can cause a correct and perfectly running program to become instantly unusable. It is not surprising that this situation exists because the \"text-editor method\" reveals a low-level view of programs that fails to reflect the structure of programs. We address this problem by pursuing a programming-language-based approach to program updates. To this end we discuss in this paper the design and requirements of an update language for expressing update programs. We identify as the essential part of any update language a scope update that performs coordinated update of the definition and all uses of a symbol. As the underlying basis for update languages, we define an update calculus for updating lambda calculus programs. We develop a type system for the update calculus that infers the possible type changes that can be caused by an update program. We demonstrate that type-safe update programs that fulfill certain structural constraints preserve the type correctness of lambda terms. The update calculus can serve as a basis for higher-level update languages, such as for Haskell or Java. (c) 2007 Elsevier B.V. All rights reserved.", "paper_title": "An update calculus for expressing type-safe program updates", "paper_id": "WOS:000248174100003"}