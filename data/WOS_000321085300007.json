{"auto_keywords": [{"score": 0.03334814006307848, "phrase": "vertical_bar_l_vertical_bar"}, {"score": 0.00481495049065317, "phrase": "binary_jumbled_pattern_matching"}, {"score": 0.004746558955503364, "phrase": "pattern_p"}, {"score": 0.004579780586951551, "phrase": "binary_alphabet"}, {"score": 0.004530894050040479, "phrase": "binary_jumbled_string_matching_problem"}, {"score": 0.004324985524216987, "phrase": "indexed_version"}, {"score": 0.003940706575253453, "phrase": "best_bounds"}, {"score": 0.0036947962580655075, "phrase": "rahman"}, {"score": 0.0032016639006812856, "phrase": "run-length_encoding"}, {"score": 0.0029802879302375986, "phrase": "new_results"}, {"score": 0.002896071795090179, "phrase": "alternative_construction"}, {"score": 0.0028446460307503343, "phrase": "badkobeh_et_al"}, {"score": 0.002676514445417281, "phrase": "time_complexity"}, {"score": 0.0024036292057373803, "phrase": "second_result"}, {"score": 0.0022054488653549175, "phrase": "word-level_parallelism"}, {"score": 0.0021662599012740127, "phrase": "word_size"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Combinatorial problems", " String algorithms", " Jumbled pattern matching", " Parikh vectors", " Run-length encoding", " Word-level parallelism"], "paper_abstract": "Given a pattern P and a text T, both strings over a binary alphabet, the binary jumbled string matching problem consists in telling whether any permutation of P occurs in T. The indexed version of this problem, i.e., preprocessing a string to efficiently answer such permutation queries, is hard and has been studied in the last few years. Currently the best bounds for this problem are 0 (n(2)/log(2) n) (with O(n) space and O(1) query time) (Moosa and Rahman (2012) [1]) and O(r(2)logr) (with O(vertical bar L vertical bar space and O(log vertical bar L vertical bar) query time) (Badkobeh et al. (2012) [2]), where r is the length of the run-length encoding of T and vertical bar L vertical bar = O(n) is the size of the index. In this paper we present new results for this problem. Our first result is an alternative construction of the index by Badkobeh et al. (2012) [2] that obtains a trade-off between the space and the time complexity. It has O (r(2) logk + n/k) complexity to build the index, O(logk) query time, and uses O(n/k + vertical bar L vertical bar) space, where k is a parameter. The second result is an O(n(2) log(2) w/w) algorithm (with O(n) space and O(1) query time), based on word-level parallelism where w is the word size in bits. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "New algorithms for binary jumbled pattern matching", "paper_id": "WOS:000321085300007"}