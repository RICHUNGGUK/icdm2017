{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "eddy"}, {"score": 0.0047784273577245505, "phrase": "model_checking"}, {"score": 0.004742179945772899, "phrase": "safety_properties"}, {"score": 0.004565007074039171, "phrase": "memory_resources"}, {"score": 0.004530371221172796, "phrase": "multiple_computers"}, {"score": 0.004478907336898875, "phrase": "compute_clusters"}, {"score": 0.00377326532920359, "phrase": "hardware_resources"}, {"score": 0.0034303002275695446, "phrase": "state_generation"}, {"score": 0.003352722512047951, "phrase": "efficient_communication"}, {"score": 0.0032519989404960073, "phrase": "asynchronous_message"}, {"score": 0.0030829367866722825, "phrase": "larger_chunks"}, {"score": 0.003024705160129876, "phrase": "communication_network_utilization"}, {"score": 0.0029675701595142656, "phrase": "design_details"}, {"score": 0.0028456326741466494, "phrase": "design_rationale"}, {"score": 0.0025282151875392817, "phrase": "murphi_modeling_language"}, {"score": 0.002499438189264537, "phrase": "eddy_murphi"}, {"score": 0.0023784664152543718, "phrase": "communication_parameters"}, {"score": 0.0023335099338323974, "phrase": "state_aggregation"}, {"score": 0.0023157656212149367, "phrase": "nearly_linear_reduction"}, {"score": 0.0022719915771356354, "phrase": "increasing_number"}, {"score": 0.0021049977753042253, "phrase": "different_modeling_languages"}], "paper_keywords": [""], "paper_abstract": "Model checking of safety properties can be scaled up by pooling the CPU and memory resources of multiple computers. As compute clusters containing 100s of nodes, with each node realized using multicore (e.g., 2) CPUs will be widespread, a model checker based on the parallel (shared memory) and distributed (message passing) paradigms will more efficiently use the hardware resources. Such a model checker can be designed by having each node employ two shared memory threads that run on the (typically) two CPUs of a node, with one thread responsible for state generation, and the other for efficient communication, including (i) performing overlapped asynchronous message passing, and (ii) aggregating the states to be sent into larger chunks in order to improve communication network utilization. We present the design details of such a novel model checking architecture called Eddy. We describe the design rationale, details of how the threads interact and yield control, exchange messages, as well as detect termination. We have realized an instance of this architecture for the Murphi modeling language. Called Eddy_Murphi, we report its performance over the number of nodes as well as communication parameters such as those controlling state aggregation. Nearly linear reduction of compute time with increasing number of nodes is observed. Our thread task partition is done in such a way that it is modular, easy to port across different modeling languages, and easy to tune across a variety of platforms.", "paper_title": "Parallel and distributed model checking in Eddy", "paper_id": "WOS:000236941300007"}