{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "first-class_classes"}, {"score": 0.01917980735717906, "phrase": "contract_system"}, {"score": 0.004569905085027681, "phrase": "class_hierarchy"}, {"score": 0.004462663711734448, "phrase": "new_forms"}, {"score": 0.004420472010542188, "phrase": "object-oriented_programming"}, {"score": 0.004215397034321004, "phrase": "expressive_power"}, {"score": 0.004019797503157808, "phrase": "software_architecture"}, {"score": 0.003815064377019477, "phrase": "object-oriented_programming_languages"}, {"score": 0.0037610536973798113, "phrase": "existing_contract_systems"}, {"score": 0.0035525230119401153, "phrase": "typical_contract_language"}, {"score": 0.003485605409687907, "phrase": "plain_values"}, {"score": 0.003355515315708125, "phrase": "higher-order_values"}, {"score": 0.003261133560558666, "phrase": "contract_specifications"}, {"score": 0.0031845067058084583, "phrase": "class_definitions"}, {"score": 0.003051073364818384, "phrase": "separate_contract_language"}, {"score": 0.0028006988338192375, "phrase": "two-pronged_evaluation"}, {"score": 0.002683304054823427, "phrase": "\"blame_correctness\"_theorem"}, {"score": 0.0024281181691350085, "phrase": "contract_violation"}, {"score": 0.0023152577218214804, "phrase": "nonconforming_value"}, {"score": 0.0022824314760583834, "phrase": "second_part"}, {"score": 0.0022181655497912796, "phrase": "case_studies"}, {"score": 0.0021454671611847507, "phrase": "rich_contract_language"}], "paper_keywords": ["Reliability", " Contracts", " first-class class systems"], "paper_abstract": "First-class classes enable programmers to abstract over patterns in the class hierarchy and to experiment with new forms of object-oriented programming such as mixins and traits. This increase in expressive power calls for tools to control the complexity of the software architecture. A contract system is one possible tool that has seen much use in object-oriented programming languages, but existing contract systems cannot cope with first-class classes. On the one hand, the typical contract language deals only with plain values such as numbers, while classes are higher-order values. On the other hand, contract specifications are usually contained within class definitions, while classes as values call for a separate contract language. This article presents the design and implementation of a contract system for first-class classes as well as a two-pronged evaluation. The first one states and proves a \"blame correctness\" theorem for a model of our language. The theorem shows that when the contract system assigns blame to a component for a contract violation, the component is indeed responsible for providing the nonconforming value. The second part, consisting of benchmarks and case studies, demonstrates the need for the rich contract language and validates that our implementation approach is performant with respect to time.", "paper_title": "Contracts for First-Class Classes", "paper_id": "WOS:000327432300003"}