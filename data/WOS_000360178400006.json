{"auto_keywords": [{"score": 0.04259666873889811, "phrase": "binary_matrices"}, {"score": 0.00481495049065317, "phrase": "fast_sparse_matrix-vector_multiplication"}, {"score": 0.004757227624616643, "phrase": "sparse_matrix-vector_multiplication"}, {"score": 0.004478782833067256, "phrase": "iterative_methods"}, {"score": 0.004398457709182882, "phrase": "linear_systems"}, {"score": 0.004191200981137508, "phrase": "critical_operation"}, {"score": 0.004116012194714212, "phrase": "particular_case"}, {"score": 0.0038284549148537373, "phrase": "graph_theory"}, {"score": 0.003692271726952282, "phrase": "irregular_memory_access_patterns"}, {"score": 0.0036479584876742085, "phrase": "poor_memory_throughput"}, {"score": 0.0034550163444256386, "phrase": "memory_throughput"}, {"score": 0.0032920678776655783, "phrase": "straight-line_program"}, {"score": 0.003174903873774882, "phrase": "cpu's_instruction_cache"}, {"score": 0.00306189690236109, "phrase": "regular_loopless_pattern"}, {"score": 0.0029707940194245216, "phrase": "cache_misses"}, {"score": 0.002600995957987461, "phrase": "memory_access_policies"}, {"score": 0.0025697460140513932, "phrase": "code_size"}, {"score": 0.0023755529073496394, "phrase": "floating-point_reals"}, {"score": 0.0022497569011987587, "phrase": "compressed_row_storage_implementation"}, {"score": 0.0021960024679620886, "phrase": "significant_speedups"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["large-scale scientific computing", " instruction-level parallelism", " thread-level parallelism", " memory-level parallelism", " multi-core architectures and support"], "paper_abstract": "Sparse matrix-vector multiplication dominates the performance of many scientific and industrial problems. For example, iterative methods for solving linear systems often rely on the performance of this critical operation. The particular case of binary matrices shows up in several important areas of computing, such as graph theory and cryptography. Unfortunately, irregular memory access patterns cause poor memory throughput, slowing down this operation. To maximize memory throughput, we translate the matrix into a straight-line program that takes advantage of the CPU's instruction cache and hardware prefetchers. The regular loopless pattern of the program reduces cache misses, thus decreasing the latency for most instructions. We focus on the widely used x86_64 architecture and on binary matrices, to explore several possible tradeoffs regarding memory access policies and code size. We also consider matrices with elements over various mathematical structures, such as floating-point reals and integers modulo m. When compared to a Compressed Row Storage implementation, we obtain significant speedups. Copyright (c) 2014 John Wiley & Sons, Ltd.", "paper_title": "Straight-line programs for fast sparse matrix-vector multiplication", "paper_id": "WOS:000360178400006"}