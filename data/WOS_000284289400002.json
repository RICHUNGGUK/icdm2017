{"auto_keywords": [{"score": 0.04862539438503134, "phrase": "verilog"}, {"score": 0.0072689188154759716, "phrase": "generated_code"}, {"score": 0.005293884603486372, "phrase": "generative_constructs"}, {"score": 0.00481495049065317, "phrase": "synthesizable_high_level_hardware_descriptions"}, {"score": 0.004785356349906913, "phrase": "modern_hardware_description_languages"}, {"score": 0.004555028829645471, "phrase": "regular_or_parameterized_hardware_designs"}, {"score": 0.004430354365175098, "phrase": "hardware_descriptions"}, {"score": 0.0038442670949832523, "phrase": "physical_resources"}, {"score": 0.003808845109556467, "phrase": "combinatorial_gates"}, {"score": 0.0035478628449322866, "phrase": "fully-expanded_code"}, {"score": 0.0034827622221683756, "phrase": "vhdl_communities"}, {"score": 0.0034506596895901003, "phrase": "generation_process"}, {"score": 0.003335452981547803, "phrase": "disciplined_approach"}, {"score": 0.0032240802202623316, "phrase": "statically_typed_two-level_language"}, {"score": 0.003078158564144202, "phrase": "elaboration_time"}, {"score": 0.0030030452897701863, "phrase": "circuit_computation"}, {"score": 0.0028670988845838296, "phrase": "module_parameters"}, {"score": 0.0027457584014804574, "phrase": "static_type_system"}, {"score": 0.0026953359825383624, "phrase": "type_system"}, {"score": 0.0026133424923929227, "phrase": "array_indices"}, {"score": 0.0025338369486914364, "phrase": "core_calculus"}, {"score": 0.0024340759772801847, "phrase": "associated_static_type_system"}, {"score": 0.0023893635026860727, "phrase": "preprocessing_step"}, {"score": 0.0023600113419817523, "phrase": "elaboration_phase"}, {"score": 0.0022048882869630114, "phrase": "well-typed_design"}, {"score": 0.0021777973668394737, "phrase": "preprocessing_errors"}, {"score": 0.0021049977753042253, "phrase": "synthesizable_circuit"}], "paper_keywords": ["Code Generation", " Hardware Description Languages", " Statically Typed Two-Level Languages", " Synthesizability", " Verilog Elaboration"], "paper_abstract": "Modern hardware description languages support code generation constructs like generate/endgenerate in Verilog. These constructs are used to describe regular or parameterized hardware designs and, when used effectively, can make hardware descriptions shorter, more understandable, and more reusable. In practice, however, designers avoid these abstractions; because it is difficult to understand and predict the properties of the generated code. Is the generated code even type safe? Is it synthesizable? What physical resources (e.g. combinatorial gates and flip-flops) does it require? It is often impossible to answer these questions without first; generating the fully-expanded code. In the Verilog and VHDL communities, this generation process is referred to as elaboration. This paper proposes a disciplined approach to elaboration in Verilog.*(1) By viewing Verilog as a statically typed two-level language, we are able to reflect the distinction between values that are known at elaboration time and values that are part of the circuit computation. This distinction is crucial for determining whether generative constructs, such as iteration and module parameters, are used in a synthesizable, manner. This allows us to develop a static type system that guarantees synthesizability. The type system achieves safety by performing additional checking on generative constructs and array indices. To illustrate this approach, we develop a core calculus for Verilog that we call Featherweight Verilog (FV) and an associated static type system. We formally define a preprocessing step analogous to the elaboration phase of Verilog, and the kinds of errors that can occur during this phase. Finally, we show that a well-typed design cannot cause preprocessing errors, and that the result of its elaboration is always a synthesizable circuit.", "paper_title": "Synthesizable High Level Hardware Descriptions", "paper_id": "WOS:000284289400002"}