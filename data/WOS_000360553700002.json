{"auto_keywords": [{"score": 0.0254736774554585, "phrase": "ram"}, {"score": 0.00481495049065317, "phrase": "large_distributed_dynamic_graphs"}, {"score": 0.00475924837336259, "phrase": "sensor_networks"}, {"score": 0.0047224703862074665, "phrase": "transportation_infrastructure"}, {"score": 0.0046859752697029355, "phrase": "social_networks"}, {"score": 0.004490212943845175, "phrase": "real-world_networks"}, {"score": 0.004027876348834879, "phrase": "traditional_systems"}, {"score": 0.0037414662674652805, "phrase": "dynamic_graphs"}, {"score": 0.0037125240439927114, "phrase": "modern_analytics"}, {"score": 0.0034484600692786097, "phrase": "dynamic_graph_data"}, {"score": 0.003304224820203298, "phrase": "deduplicated_storage"}, {"score": 0.0032786537599187125, "phrase": "multiple_servers"}, {"score": 0.0032031180198375283, "phrase": "obvious_space-saving_advantage"}, {"score": 0.003178326919668771, "phrase": "large-scale_graph_processing"}, {"score": 0.003010063382882408, "phrase": "stable_storage"}, {"score": 0.0029867619862229853, "phrase": "faster_results"}, {"score": 0.002952146666681891, "phrase": "traditional_database_and_graph_processing_systems"}, {"score": 0.002895341091441627, "phrase": "complex_queries"}, {"score": 0.0028729252198422825, "phrase": "large_graphs"}, {"score": 0.002850682396853918, "phrase": "distributed_operators"}, {"score": 0.002817639725689939, "phrase": "graph_data"}, {"score": 0.002720785798036066, "phrase": "multiple_graphs"}, {"score": 0.0026892447164623247, "phrase": "graph_commonalities"}, {"score": 0.0026069066266394118, "phrase": "relevant_graphs"}, {"score": 0.0021463304704817873, "phrase": "evaluation_results"}, {"score": 0.0021049977753042253, "phrase": "traditional_graph_processing_systems"}], "paper_keywords": ["Graphs", " Queries", " Distributed databases", " Parallel computing", " Big data"], "paper_abstract": "From sensor networks to transportation infrastructure to social networks, we are awash in data. Many of these real-world networks tend to be large (\"big data\") and dynamic, evolving over time. Their evolution can be modeled as a series of graphs. Traditional systems that store and analyze one graph at a time cannot effectively handle the complexity and subtlety inherent in dynamic graphs. Modern analytics require systems capable of storing and processing series of graphs. We present such a system. G* compresses dynamic graph data based on commonalities among the graphs in the series for deduplicated storage on multiple servers. In addition to the obvious space-saving advantage, large-scale graph processing tends to be I/O bound, so faster reads from and writes to stable storage enable faster results. Unlike traditional database and graph processing systems, G* executes complex queries on large graphs using distributed operators to process graph data in parallel. It speeds up queries on multiple graphs by processing graph commonalities only once and sharing the results across relevant graphs. This architecture not only provides scalability, but since G* is not limited to processing only what is available in RAM, its analysis capabilities are far greater than other systems which are limited to what they can hold in memory. This paper presents G*'s design and implementation principles along with evaluation results that document its unique benefits over traditional graph processing systems.", "paper_title": "The G* graph database: efficiently managing large distributed dynamic graphs", "paper_id": "WOS:000360553700002"}