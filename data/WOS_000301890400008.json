{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "computational_biology"}, {"score": 0.03762867376091313, "phrase": "dynamic_programming_algorithms"}, {"score": 0.004775335634705251, "phrase": "dynamic_programming"}, {"score": 0.004736294859113598, "phrase": "dp"}, {"score": 0.004658426838467567, "phrase": "popular_and_efficient_technique"}, {"score": 0.004378469469879815, "phrase": "burgeoning_volume"}, {"score": 0.004342430078306461, "phrase": "scientific_data"}, {"score": 0.004149429072483132, "phrase": "computation_time"}, {"score": 0.004115267130977749, "phrase": "acceptable_levels"}, {"score": 0.004064548693812535, "phrase": "intrinsically_strong_data_dependency"}, {"score": 0.0037886833451021723, "phrase": "correct_and_efficient_parallel_program"}, {"score": 0.0036653985479652854, "phrase": "runtime_system"}, {"score": 0.0036352070472201086, "phrase": "easypdp"}, {"score": 0.0035461111918923117, "phrase": "multicore_and_multiprocessor_platforms"}, {"score": 0.003459191419478298, "phrase": "software_reusability"}, {"score": 0.0034306925765832633, "phrase": "complexity_reduction"}, {"score": 0.0034024277222012597, "phrase": "parallel_programming"}, {"score": 0.003360464999544279, "phrase": "dag_data_driven_model"}, {"score": 0.0032242793143795454, "phrase": "strong_data_interdependence_relationship"}, {"score": 0.003132236287543072, "phrase": "easypdp_runtime_system"}, {"score": 0.0030177339185643226, "phrase": "thread_creation"}, {"score": 0.0029928611380840757, "phrase": "dynamic_data_task_allocation"}, {"score": 0.0028953973490895746, "phrase": "fault_tolerance"}, {"score": 0.0028715299874549245, "phrase": "five_frequently_used_dag_patterns"}, {"score": 0.002847858807513713, "phrase": "biological_dynamic_programming_algorithms"}, {"score": 0.002778006389296707, "phrase": "dag_pattern_library"}, {"score": 0.0025361866386341796, "phrase": "ideal_computing_distribution_model"}, {"score": 0.002473959963690124, "phrase": "optimal_values"}, {"score": 0.0024434201175883674, "phrase": "performance_tuning_arguments"}, {"score": 0.0024232694434408093, "phrase": "easypdp."}, {"score": 0.0023834640793589435, "phrase": "performance_potential_and_fault_tolerance_feature"}, {"score": 0.0022399174232611853, "phrase": "block-cycle_wavefront"}, {"score": 0.002184943946549964, "phrase": "experimental_results"}, {"score": 0.0021579641460002523, "phrase": "easypdp_system"}, {"score": 0.0021049977753042253, "phrase": "efficient_infrastructure"}], "paper_keywords": ["Dynamic programming", " Easypdp", " DAG data driven model", " fault tolerance", " DAG pattern", " multicore", " block cycle"], "paper_abstract": "Dynamic programming (DP) is a popular and efficient technique in many scientific applications such as computational biology. Nevertheless, its performance is limited due to the burgeoning volume of scientific data, and parallelism is necessary and crucial to keep the computation time at acceptable levels. The intrinsically strong data dependency of dynamic programming makes it difficult and error-prone for the programmer to write a correct and efficient parallel program. Therefore, this paper builds a runtime system named EasyPDP aiming at parallelizing dynamic programming algorithms on multicore and multiprocessor platforms. Under the concept of software reusability and complexity reduction of parallel programming, a DAG Data Driven Model is proposed, which supports those applications with a strong data interdependence relationship. Based on the model, EasyPDP runtime system is designed and implemented. It automatically handles thread creation, dynamic data task allocation and scheduling, data partitioning, and fault tolerance. Five frequently used DAG patterns from biological dynamic programming algorithms have been put into the DAG pattern library of EasyPDP, so that the programmer can choose to use any of them according to his/her specific application. Besides, an ideal computing distribution model is proposed to discuss the optimal values for the performance tuning arguments of EasyPDP. We evaluate the performance potential and fault tolerance feature of EasyPDP in multicore system. We also compare EasyPDP with other methods such as Block-Cycle Wavefront (BCW). The experimental results illustrate that EasyPDP system is fine and provides an efficient infrastructure for dynamic programming algorithms.", "paper_title": "EasyPDP: An Efficient Parallel Dynamic Programming Runtime System for Computational Biology", "paper_id": "WOS:000301890400008"}