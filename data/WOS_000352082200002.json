{"auto_keywords": [{"score": 0.04371887194895359, "phrase": "failure_detector"}, {"score": 0.00481495049065317, "phrase": "new_way"}, {"score": 0.004697655699119423, "phrase": "failure_detectors"}, {"score": 0.0039281997063335735, "phrase": "computation_processes"}, {"score": 0.0036703791815812328, "phrase": "synchronization_processes"}, {"score": 0.002867098884583832, "phrase": "finite_number"}, {"score": 0.0025495426598675583, "phrase": "weakest_failure_detector"}, {"score": 0.002295277579105179, "phrase": "set_agreement"}, {"score": 0.0022117133940361025, "phrase": "complete_classification"}, {"score": 0.0021049977753042253, "phrase": "comprehensible_characterization"}], "paper_keywords": ["Failure detectors", " Computation and synchronization", " k-Concurrency"], "paper_abstract": "We motivate and propose a new way of thinking about failure detectors which allows us to define what it means to solve a distributed task wait-free using a failure detector. In our model, the system is composed of computation processes that obtain inputs and are supposed to produce outputs and synchronization processes that are subject to failures and can query a failure detector. Under the condition that correct (never failing) synchronization processes take sufficiently many steps, they provide the computation processes with enough advice to solve the given task waitfree: every computation process outputs in a finite number of its own steps, regardless of the behavior of other computation processes. Every task can thus be characterized by the weakest failure detector that allows for solving it, and we show that every such failure detector captures a form of set agreement. We then obtain a complete classification of tasks, including ones that evaded comprehensible characterization so far, such as renaming or weak symmetry breaking.", "paper_title": "Wait-freedom with advice", "paper_id": "WOS:000352082200002"}