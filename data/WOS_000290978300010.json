{"auto_keywords": [{"score": 0.04433678982697986, "phrase": "satellite_data"}, {"score": 0.04190471418686174, "phrase": "basic_navigation_operations"}, {"score": 0.030424249019695215, "phrase": "raman"}, {"score": 0.03027352233851443, "phrase": "rao"}, {"score": 0.00481495049065317, "phrase": "dynamic_trees"}, {"score": 0.004714307129348789, "phrase": "dynamic_ordered_tree"}, {"score": 0.004211871140493766, "phrase": "fixed_size"}, {"score": 0.004085221464783815, "phrase": "update_operations"}, {"score": 0.004066076430818046, "phrase": "constant_amortized_time"}, {"score": 0.003581620064675766, "phrase": "i-th_child"}, {"score": 0.003377251337648774, "phrase": "restrictive_pattern"}, {"score": 0.0033614129455356123, "phrase": "update_strategy"}, {"score": 0.003306559295382181, "phrase": "finger-update_model"}, {"score": 0.003066945490483524, "phrase": "consecutive_siblings"}, {"score": 0.002995677265350124, "phrase": "named_extended_operations"}, {"score": 0.002967634471075658, "phrase": "worst-case_constant_time"}, {"score": 0.002932948760756593, "phrase": "dynamic_succinct_trees"}, {"score": 0.002785071236557779, "phrase": "binary_trees"}, {"score": 0.002407132412260114, "phrase": "previous_result"}, {"score": 0.0023958326775913165, "phrase": "ordinal_trees"}, {"score": 0.002373391713337104, "phrase": "\"poly-log-log\"_query_time"}, {"score": 0.002362277419557415, "phrase": "gupta"}, {"score": 0.002280333649167796, "phrase": "update_time"}, {"score": 0.002175505194815028, "phrase": "sadakane"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Ordered trees", " Dynamic trees", " Succinct data structures"], "paper_abstract": "We study the problem of maintaining a dynamic ordered tree succinctly under updates of the following form: insertion or deletion of a leaf, insertion of a node on an edge (edge subdivision) or deletion of a node with only one child (the child becomes a child of its former grandparent). We allow satellite data of a fixed size to be associated to the nodes of the tree. We support update operations in constant amortized time and support access to satellite data and basic navigation operations in worst-case. constant time; the basic navigation operations include parent, first/last-child, previous/next-child. These operations are moving from a node to its parent, leftmost/rightmost child, and its previous and next child respectively. We demonstrate that to efficiently support more extended operations, such as determining the i-th child of a node, rank of a child among its siblings, or size of the subtree rooted at a node, one requires a restrictive pattern for update strategy, for which we propose the finger-update model. In this model, updates are performed at the location of a finger that is only allowed to crawl on the tree between a child and a parent or between consecutive siblings. Under this model, we describe how the named extended operations are performed in worst-case constant time. Previous work on dynamic succinct trees (Munro et al., 2001 [17]; Raman and Rao, 2003 [19]) is mainly restricted to binary trees and achieves poly-logarithmic (Munro et al., 2001 [17]) or \"poly-log-log\" (Raman and Rao, 2003 [19]) update time under a more restricted model, where updates are performed in traversals starting at the root and ending at the root and queries can be answered when the traversal is completed. A previous result on ordinal trees achieves only sublinear amortized update time and \"poly-log-log\" query time (Gupta et al., 2007 [11]). More recently, the update time has been improved to O(log n/log log n) while queries can be performed in O(log n/log log n) time (Sadakane and Navarro, 2010 [20]). (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Succinct representation of dynamic trees", "paper_id": "WOS:000290978300010"}