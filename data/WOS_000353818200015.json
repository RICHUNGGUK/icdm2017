{"auto_keywords": [{"score": 0.02356636160108415, "phrase": "well-behaved_bxs"}, {"score": 0.00481495049065317, "phrase": "bidirectional_programming"}, {"score": 0.0047761092701293474, "phrase": "bidirectional_transformations"}, {"score": 0.0046238380150870435, "phrase": "forward_transformation"}, {"score": 0.004567990533989851, "phrase": "backward_transformation"}, {"score": 0.004012500850311087, "phrase": "increased_maintainability"}, {"score": 0.0036553070575015344, "phrase": "separate_programs"}, {"score": 0.003495855671790616, "phrase": "existing_bidirectional_languages"}, {"score": 0.003289534854212415, "phrase": "default_strategies"}, {"score": 0.0031845067058084613, "phrase": "programmers'_inability"}, {"score": 0.0031459887611258765, "phrase": "synchronization_strategies"}, {"score": 0.0030455297429878873, "phrase": "vast_number"}, {"score": 0.002984373546099842, "phrase": "tailor-made_synchronization_strategies"}, {"score": 0.002740607717745287, "phrase": "synchronization_strategy"}, {"score": 0.0025682999078906936, "phrase": "novel_approach"}, {"score": 0.002537216271965659, "phrase": "so-called_well-behaved_bidirectional_programs"}, {"score": 0.0023016843709107297, "phrase": "systematic_analysis"}, {"score": 0.002264607102799332, "phrase": "existing_mathematical_concepts"}, {"score": 0.0022281257694320433, "phrase": "instrumental_laws"}, {"score": 0.0021049977753042253, "phrase": "corresponding_forward_transformations"}], "paper_keywords": ["bidirectional transformation", " software adaption and coevolution", " bidirectional programming"], "paper_abstract": "Bidirectional transformations (BXs), programs with a forward transformation and a backward transformation that maintain consistency between input and output, are routinely written in ways that do not let programmers specify their behavior completely. Several bidirectional programming languages exist to aid programmers in writing BXs with increased maintainability but decreased expressiveness. Such languages allow programmers to write BXs as one program for both directions, which is easier to maintain than separate programs for each direction. However, the maintainability provided by existing bidirectional languages comes at the cost of expressiveness because the ambiguity of synchronization is solved by default strategies which are hidden from programmers. The programmers' inability to influence synchronization strategies has led to the proposal of a vast number of approaches that consider tailor-made synchronization strategies for particular applications. In this paper, we argue that such ambiguity is essential for BX and advocate that the synchronization strategy should not be hidden from programmers but considered from the start. We propose a novel approach to specifying so-called well-behaved bidirectional programs by their backward transformations, capable of expressing all aspects of a BX while retaining maintainability. Soundness of our approach results from a systematic analysis, based on existing mathematical concepts, of the instrumental laws of well-behaved BXs. We show that well-behaved BXs are uniquely determined by their backward transformations and corresponding forward transformations can be obtained for free.", "paper_title": "The essence of bidirectional programming", "paper_id": "WOS:000353818200015"}