{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "functional_language"}, {"score": 0.004688321299229397, "phrase": "dominant_control-flow_mechanism"}, {"score": 0.0034963129868796033, "phrase": "control-flow_graphs"}, {"score": 0.0033442114331500407, "phrase": "precision-degrading_spurious_control-flow_paths"}, {"score": 0.0027495914857929584, "phrase": "higher-order_functions"}, {"score": 0.002515384834484012, "phrase": "abstract_interpretation"}, {"score": 0.002427372728532664, "phrase": "continuation-passing_style"}, {"score": 0.0023424328921363585, "phrase": "sound_and_complete_summarization_algorithm"}, {"score": 0.002200861826643147, "phrase": "preliminary_evaluation"}], "paper_keywords": ["control-flow analysis", " higher-order languages", " pushdown models", " summarization"], "paper_abstract": "In a functional language, the dominant control-flow mechanism is function call and return. Most higher-order flow analyses, including k-CFA, do not handle call and return well: they remember only a bounded number of pending calls because they approximate programs with control-flow graphs. Call/return mismatch introduces precision-degrading spurious control-flow paths and increases the analysis time. We describe CFA2, the first flow analysis with precise call/return matching in the presence of higher-order functions and tail calls. We formulate CFA2 as an abstract interpretation of programs in continuation-passing style and describe a sound and complete summarization algorithm for our abstract semantics. A preliminary evaluation shows that CFA2 gives more accurate data-flow information than 0CFA and 1CFA.", "paper_title": "CFA2: A CONTEXT-FREE APPROACH TO CONTROL-FLOW ANALYSIS", "paper_id": "WOS:000301227100007"}