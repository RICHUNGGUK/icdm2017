{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "suffix_trees"}, {"score": 0.00447282529270722, "phrase": "information_retrieval"}, {"score": 0.004438250823243621, "phrase": "classical_representations"}, {"score": 0.004043541331944951, "phrase": "sigma_bits"}, {"score": 0.003874512990986722, "phrase": "alphabet_size"}, {"score": 0.0036553070575015344, "phrase": "recent_compressed_suffix_tree_representations"}, {"score": 0.003557283483525861, "phrase": "compressed_string"}, {"score": 0.0035024506353894644, "phrase": "extra_bits"}, {"score": 0.0033821367649595254, "phrase": "linear_extra_bits"}, {"score": 0.003253279945540651, "phrase": "dna_sequences"}, {"score": 0.003141498438356646, "phrase": "first_compressed_suffix_tree_representation"}, {"score": 0.002952146666681891, "phrase": "compressed_text_size"}, {"score": 0.002895341091441627, "phrase": "wide_set"}, {"score": 0.0028729252198422825, "phrase": "navigational_operations"}, {"score": 0.002850682396853918, "phrase": "almost_logarithmic_time"}, {"score": 0.0027958237350835607, "phrase": "arbitrary_text_substrings"}, {"score": 0.002752695791351096, "phrase": "fcst"}, {"score": 0.0026997176829763746, "phrase": "almost_the_same_space"}, {"score": 0.002668420182908979, "phrase": "compressed_text"}, {"score": 0.0026374845514245547, "phrase": "essential_ingredient"}, {"score": 0.0025867180355950816, "phrase": "lowest_common_ancestor"}, {"score": 0.002507511169156787, "phrase": "important_connections"}, {"score": 0.0024688196796198766, "phrase": "suffix_tree_navigation"}, {"score": 0.00227525089435209, "phrase": "dynamic_fcst"}, {"score": 0.0021715177915174375, "phrase": "static_fcst"}, {"score": 0.002154693685426657, "phrase": "optimal_space"}, {"score": 0.002137999646917136, "phrase": "polylogarithmic_time"}], "paper_keywords": ["Text processing", " pattern matching", " string algorithms", " suffix tree", " data compression", " compressed index"], "paper_abstract": "Suffix trees are by far the most important data structure in stringology, with a myriad of applications in fields like bioinformatics and information retrieval. Classical representations of suffix trees require Theta(nlogn) bits of space, for a string of size n. This is considerably more than the nlog(2) sigma bits needed for the string itself, where s is the alphabet size. The size of suffix trees has been a barrier to their wider adoption in practice. Recent compressed suffix tree representations require just the space of the compressed string plus Theta(n) extra bits. This is already spectacular, but the linear extra bits are still unsatisfactory when s is small as in DNA sequences. In this article, we introduce the first compressed suffix tree representation that breaks this Theta(n)bit space barrier. The Fully Compressed Suffix Tree (FCST) representation requires only sublinear space on top of the compressed text size, and supports a wide set of navigational operations in almost logarithmic time. This includes extracting arbitrary text substrings, so the FCST replaces the text using almost the same space as the compressed text. An essential ingredient of FCSTs is the lowest common ancestor (LCA) operation. We reveal important connections between LCAs and suffix tree navigation. We also describe how to make FCSTs dynamic, that is, support updates to the text. The dynamic FCST also supports several operations. In particular, it can build the static FCST within optimal space and polylogarithmic time per symbol. Our theoretical results are also validated experimentally, showing that FCSTs are very effective in practice as well.", "paper_title": "Fully Compressed Suffix Trees", "paper_id": "WOS:000296200900014"}