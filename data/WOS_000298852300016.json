{"auto_keywords": [{"score": 0.04366909172920831, "phrase": "np"}, {"score": 0.00633100423931618, "phrase": "combinatorial"}, {"score": 0.00481495049065317, "phrase": "small_number"}, {"score": 0.004494570360108983, "phrase": "recent_literature"}, {"score": 0.0043080553835735825, "phrase": "total_number"}, {"score": 0.004010624853427534, "phrase": "practical_dataset"}, {"score": 0.0037834649508375544, "phrase": "large_pedigree"}, {"score": 0.00347574024760684, "phrase": "simple_probabilistic_model"}, {"score": 0.0034299649219748513, "phrase": "prior_haplotype_probability"}, {"score": 0.003375826910838081, "phrase": "haplotype_transmission_probability"}, {"score": 0.0032614317990293695, "phrase": "uniform_distribution"}, {"score": 0.0032355864829403413, "phrase": "random_recombination_events"}, {"score": 0.0030199761431186434, "phrase": "mating_loops"}, {"score": 0.0028944757265206332, "phrase": "input_pedigree"}, {"score": 0.0027303606813078255, "phrase": "feasible_haplotype_configuration"}, {"score": 0.0027015344365793016, "phrase": "mendelian_law"}, {"score": 0.002488183412451029, "phrase": "moderate_value"}, {"score": 0.0024101837218440834, "phrase": "large_tree_pedigrees"}, {"score": 0.002322261865873902, "phrase": "tree-k-rhc."}, {"score": 0.002273465135642801, "phrase": "missing_data"}, {"score": 0.0022434880661725493, "phrase": "large_number"}, {"score": 0.002196342933346204, "phrase": "simulated_and_real_datasets"}, {"score": 0.0021789194955896124, "phrase": "tree-k-rhc"}, {"score": 0.002144485291571595, "phrase": "high_accuracy"}, {"score": 0.0021049977753042253, "phrase": "best_combinatorial_method"}], "paper_keywords": ["Computational biology", " Haplotype inference", " Pedigree", " Recombination", " Combinatorial algorithm", " Probabilistic model"], "paper_abstract": "Combinatorial (or rule-based) methods for inferring haplotypes from genotypes on a pedigree have been studied extensively in the recent literature. These methods generally try to reconstruct the haplotypes of each individual so that the total number of recombinants is minimized in the pedigree. The problem is NP-hard, although it is known that the number of recombinants in a practical dataset is usually very small. In this paper, we consider the question of how to efficiently infer haplotypes on a large pedigree when the number of recombinants is bounded by a small constant, i.e. the so called k-recombinant haplotype configuration (k-RHC) problem. We introduce a simple probabilistic model for k-RHC where the prior haplotype probability of a founder and the haplotype transmission probability from a parent to a child are all assumed to follow the uniform distribution and k random recombination events are assumed to have taken place uniformly and independently in the pedigree. We present an O(mnlog (k+1) n) time algorithm for k-RHC on tree pedigrees without mating loops, where m is the number of loci and n is the size of the input pedigree, and prove that when 90log n < m < n (3), the algorithm can correctly find a feasible haplotype configuration that obeys the Mendelian law of inheritance and requires no more than k recombinants with probability 1 - O (k(2). og 2n/mn + 1/n(2)) The algorithm is efficient when k is of a moderate value and could thus be used to infer haplotypes from genotypes on large tree pedigrees efficiently in practice. We have implemented the algorithm as a C++ program named Tree-k-RHC. The implementation incorporates several ideas for dealing with missing data and data with a large number of recombinants effectively. Our experimental results on both simulated and real datasets show that Tree-k-RHC can reconstruct haplotypes with a high accuracy and is much faster than the best combinatorial method in the literature.", "paper_title": "An Efficient Algorithm for Haplotype Inference on Pedigrees with a Small Number of Recombinants", "paper_id": "WOS:000298852300016"}