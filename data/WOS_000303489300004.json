{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "class_hierarchies"}, {"score": 0.004769702911065878, "phrase": "refactoring_transformations"}, {"score": 0.004592905436175987, "phrase": "software_evolution"}, {"score": 0.004549734943142138, "phrase": "modular_reasoning"}, {"score": 0.004360412703519539, "phrase": "typed_class-based_languages"}, {"score": 0.004238576355081601, "phrase": "internal_representations"}, {"score": 0.0041987222897385676, "phrase": "multiple_interdependent_classes"}, {"score": 0.0040049806975968145, "phrase": "mutable_objects"}, {"score": 0.0038746849003761024, "phrase": "existing_theory"}, {"score": 0.0038382392088338784, "phrase": "representation_independence"}, {"score": 0.003784209997115174, "phrase": "single_class"}, {"score": 0.0036958398682001015, "phrase": "simple_notion"}, {"score": 0.0036610702290043387, "phrase": "ownership_confinement"}, {"score": 0.0034428776029411974, "phrase": "refactoring_rules"}, {"score": 0.0033624514778823763, "phrase": "complete_class_trees"}, {"score": 0.0031920445513574907, "phrase": "class_inheritance"}, {"score": 0.0028093921138602606, "phrase": "private_attributes"}, {"score": 0.002769805263310232, "phrase": "extract_class"}, {"score": 0.002679585860537941, "phrase": "data_refinement"}, {"score": 0.0026543514413663893, "phrase": "protected_attributes"}, {"score": 0.002555761854502478, "phrase": "corresponding_transformations"}, {"score": 0.002426137929553724, "phrase": "proposed_rules"}, {"score": 0.0023694065215394593, "phrase": "relatively_extensive_case_study"}, {"score": 0.00218623706110975, "phrase": "relational_reasoning"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Refactoring", " Program transformation", " Class inheritance", " Representation independence", " Semantics", " Verification"], "paper_abstract": "Refactoring transformations are important for productivity and quality in software evolution. Modular reasoning about semantics preserving transformations is difficult even in typed class-based languages because transformations can change the internal representations for multiple interdependent classes and because encapsulation can be violated by pointers to mutable objects. In this paper, an existing theory of representation independence for a single class, based on a simple notion of ownership confinement, is generalized to a hierarchy of classes and used to prove refactoring rules that embody transformations of complete class trees. This allows us to formalize refactorings that inherently involve class inheritance, such as Pull Up or Push Down Field; moreover, this makes it possible to generalize refactorings previously restricted to change of data representation of private attributes (like Extract Class and Encapsulate Field) to address data refinement of protected attributes, dealing with the impact that the corresponding transformations may cause in the subclasses. The utility of the proposed rules is shown in a relatively extensive case study. Shortcomings of the theory are described as a challenge to other approaches to heap encapsulation and relational reasoning for classes. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "Refactoring and representation independence for class hierarchies", "paper_id": "WOS:000303489300004"}