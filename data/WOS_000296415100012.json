{"auto_keywords": [{"score": 0.03760584903191966, "phrase": "stable_storage"}, {"score": 0.01134019911726935, "phrase": "unstable_processes"}, {"score": 0.00916269408841909, "phrase": "correct_processes"}, {"score": 0.00481495049065317, "phrase": "crash-recovery_systems"}, {"score": 0.004666228956744244, "phrase": "leader_election_problem"}, {"score": 0.0046176782475198085, "phrase": "partially_synchronous_distributed_systems"}, {"score": 0.004246947739596565, "phrase": "omega_failure_detector_class"}, {"score": 0.004137288854115515, "phrase": "leader_election_functionality"}, {"score": 0.004051595625804513, "phrase": "crash-recovery_failure_model"}, {"score": 0.003946960862020283, "phrase": "communication_efficiency"}, {"score": 0.0037855073142577405, "phrase": "omega"}, {"score": 0.003085989256759819, "phrase": "first_algorithm"}, {"score": 0.0028828348726682965, "phrase": "permanently_unstable_processes"}, {"score": 0.0027356847952125433, "phrase": "second_algorithm"}, {"score": 0.002206700502606511, "phrase": "first_message"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Fault-tolerant distributed computing", " Consensus", " Omega failure detector", " Leader election", " Crash-recovery", " Communication-efficient algorithm"], "paper_abstract": "This work addresses the leader election problem in partially synchronous distributed systems where processes can crash and recover. More precisely, it focuses on implementing the Omega failure detector class, which provides a leader election functionality, in the crash-recovery failure model. The concepts of communication efficiency and near-efficiency for an algorithm implementing Omega are defined. Depending on the use or not of stable storage, the property satisfied by unstable processes, i.e., those that crash and recover infinitely often, varies. Two algorithms implementing Omega are presented. In the first algorithm, which is communication-efficient and uses stable storage, eventually and permanently unstable processes agree on the leader with correct processes. In the second algorithm, which is near-communication-efficient and does not use stable storage, processes start their execution with no leader in order to avoid the disagreement among unstable processes, that will agree on the leader with correct processes after receiving a first message from the leader. (C) 2011 Elsevier Inc. All rights reserved.", "paper_title": "Communication-efficient leader election in crash-recovery systems", "paper_id": "WOS:000296415100012"}