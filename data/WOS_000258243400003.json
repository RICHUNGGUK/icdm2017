{"auto_keywords": [{"score": 0.04833320368251523, "phrase": "k-set_agreement"}, {"score": 0.04572128254759442, "phrase": "crash_failure_model"}, {"score": 0.042764270483565174, "phrase": "failure_detectors"}, {"score": 0.041170637589374566, "phrase": "failure_detector_classes"}, {"score": 0.00481495049065317, "phrase": "computability_power"}, {"score": 0.004759403938301023, "phrase": "set_agreement-oriented_failure_detector_classes"}, {"score": 0.004607243430766871, "phrase": "asynchronous_distributed_systems"}, {"score": 0.004564665273325141, "phrase": "unbounded_number"}, {"score": 0.004543523306465106, "phrase": "process_failures"}, {"score": 0.004408456735066782, "phrase": "unreliable_failure_detectors"}, {"score": 0.00421821065416333, "phrase": "exact_nature"}, {"score": 0.00413096972023037, "phrase": "abstract_properties"}, {"score": 0.004102290567217261, "phrase": "particular_class"}, {"score": 0.0040455257709258, "phrase": "weakest_class"}, {"score": 0.0034383545365178087, "phrase": "failure_detector"}, {"score": 0.003096905353118796, "phrase": "right_arrow"}, {"score": 0.0028087949095629955, "phrase": "maximum_number"}, {"score": 0.0025832180231667853, "phrase": "t-set_agreement"}, {"score": 0.0021296312949018736, "phrase": "weakest_failure_detector_class"}, {"score": 0.0021049977753042253, "phrase": "k-set_agreement_problem"}], "paper_keywords": ["asynchronous system", " distributed algorithm", " fault-tolerance", " set-agreement", " unreliable failure detector"], "paper_abstract": "Solving agreement problems deterministically, such as consensus and k-set agreement, in asynchronous distributed systems prone to an unbounded number of process failures has been shown to be impossible. To circumvent this impossibility, unreliable failure detectors for the crash failure model have been widely studied. These are oracles that provide information on failures. The exact nature of such information is defined by a set of abstract properties that a particular class of failure detectors satisfy. The weakest class of such failure detectors that allow to solve consensus is.. This paper considers failure detector classes from the literature that solve k-set agreement in the crash failure model, and studies their relative power. It shows that the family of failure detector classes lozenge S(x) (1 <= x <= n), and lozenge psi(y) (0 <= y <= n), can be \"added\" to provide a failure detector of the class Omega(z) (1 <= z <= n, a generalization of.). It also characterizes the power of such an \"addition\", namely, lozenge S(x) + lozenge psi(y) (sic) Omega(z) double left right arrow x+ y + z > t + 1, lozenge psi(y) can construct Omega(z) iff y+ z > t, and lozenge S(x) can construct Omega(z) iff x+ z > t + 1, where t is the maximum number of processes that can crash in a run. As an example, the paper shows that, while lozenge S(t) allows solving 2-set agreement (but not consensus) and lozenge psi(1) allows solving t-set agreement (but not ( t - 1)-set agreement), a system with failure detectors of both classes can solve consensus for any value of t. More generally, the paper studies the failure detector classes lozenge S(x), lozenge psi(y) and Omega(z), and shows which reductions among these classes are possible and which are not. The paper also presents a message-passing Omega(k)-based k-set agreement protocol and shows that Omega(k) is not enough to solve (k - 1)-set agreement. In that sense, it can be seen as a step toward the characterization of the weakest failure detector class that allows solving the k-set agreement problem.", "paper_title": "On the computability power and the robustness of set agreement-oriented failure detector classes", "paper_id": "WOS:000258243400003"}