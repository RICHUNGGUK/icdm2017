{"auto_keywords": [{"score": 0.04269803168773222, "phrase": "polytypic_proofs"}, {"score": 0.04222923751583133, "phrase": "polytypic_functions"}, {"score": 0.0045726187330434025, "phrase": "generic_haskell-style_polytypic_programs"}, {"score": 0.0042928648367867835, "phrase": "polytypic_programming"}, {"score": 0.004219571240696568, "phrase": "proof_assistant_cog"}, {"score": 0.0039387132643840484, "phrase": "coq"}, {"score": 0.0036553070575015344, "phrase": "dependently_typed_term_specialization_function"}, {"score": 0.003058944053868522, "phrase": "polytypic_proof"}, {"score": 0.0023889533502525527, "phrase": "polytypic_function"}, {"score": 0.0021789194955896124, "phrase": "similar_way"}, {"score": 0.0021049977753042253, "phrase": "generic_haskell"}], "paper_keywords": [""], "paper_abstract": "The aim of our work is to be able to do fully formal, machine-verified proofs over Generic Haskell-style polytypic programs. In order to achieve this goal, we embed polytypic programming in the proof assistant Cog and provide an infrastructure for polytypic proofs. Polytypic functions are reified within Coq as a datatype and they can then be specialized by applying a dependently typed term specialization function. Polytypic functions are thus first-class citizens and can be passed as arguments or returned as results. Likewise, we reify polytypic proofs as a datatype and provide a lemma that a polytypic proof can be specialized to any datatype in the universe. The correspondence between polytypic functions and their polytypic proofs is very clear: programmers need to give proofs for, and only for, the same cases that they need to give instances for when they define the polytypic function itself. Finally, we discuss how to write (co)recursive functions and do (co)recursive proofs in a similar way that recursion is handled in Generic Haskell.", "paper_title": "Formal polytypic programs and proofs", "paper_id": "WOS:000286560000002"}