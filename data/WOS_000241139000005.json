{"auto_keywords": [{"score": 0.0487291113922519, "phrase": "sfe"}, {"score": 0.00481495049065317, "phrase": "two-party_secure_computation"}, {"score": 0.00470903269511684, "phrase": "secure_function_evaluation"}, {"score": 0.0041074234667687875, "phrase": "work_deals"}, {"score": 0.004017006809411963, "phrase": "secure_two-party_computation"}, {"score": 0.0037935066882208235, "phrase": "secure_evaluation"}, {"score": 0.003582397044768098, "phrase": "sfe_protocols"}, {"score": 0.003437248394635138, "phrase": "efficient_sfe_protocols"}, {"score": 0.003404593678001724, "phrase": "previous_study"}, {"score": 0.0033084729942065142, "phrase": "information_theoretic_point"}, {"score": 0.003256246326294201, "phrase": "strong_answers"}, {"score": 0.003204841443605308, "phrase": "combinatorial_properties"}, {"score": 0.0031143426702382117, "phrase": "major_differences"}, {"score": 0.0030847461428168614, "phrase": "information_theoretic"}, {"score": 0.0030651710672229926, "phrase": "computational_settings"}, {"score": 0.0029037051302566942, "phrase": "combinatorial_criteria"}, {"score": 0.0028397103530211415, "phrase": "computational_setting"}, {"score": 0.0027948626965516947, "phrase": "fully_computational_study"}, {"score": 0.002768293851511292, "phrase": "fundamental_questions"}, {"score": 0.0026815368507715, "phrase": "almost_full_characterization"}, {"score": 0.0026560424475094396, "phrase": "complete_functions"}, {"score": 0.002548331088496964, "phrase": "computational_criterion"}, {"score": 0.0024063484128685367, "phrase": "asymmetric_case"}, {"score": 0.0023532890136269986, "phrase": "matching_criterion"}, {"score": 0.002279508335630797, "phrase": "simple_sfe"}, {"score": 0.0022434880661725493, "phrase": "additional_assumptions"}, {"score": 0.0021593396036472777, "phrase": "computational_row"}, {"score": 0.0021049977753042253, "phrase": "\"nice\"_functions"}], "paper_keywords": ["oblivious transfer", " one-way function", " secure function evaluation"], "paper_abstract": "A Secure Function Evaluation (SFE) of a two-variable function f(.,.) is a protocol that allows two parties with inputs x and y to evaluate f(x,y) in a manner where neither party learns \"more than is necessary\". A rich body of work deals with the study of completeness for secure two-party computation. A function f is complete for SFE if a protocol for securely evaluating f allows the secure evaluation of all (efficiently computable) functions. The questions investigated are which functions are complete for SFE, which functions have SFE protocols unconditionally and whether there are functions that are neither complete nor have efficient SFE protocols. The previous study of these questions was mainly conducted from an information theoretic point of view and provided strong answers in the form of combinatorial properties. However, we show that there are major differences between the information theoretic and computational settings. In particular, we show functions that are considered as having SFE unconditionally by the combinatorial criteria but are actually complete in the computational setting. We initiate the fully computational study of these fundamental questions. Somewhat surprisingly, we manage to provide an almost full characterization of the complete functions in this model as well. More precisely, we present a computational criterion (called computational row non-transitivity) for a function f to be complete for the asymmetric case. Furthermore, we show a matching criterion called computational row transitivity for f to have a simple SFE (based on no additional assumptions). This criterion is close to the negation of the computational row non-transitivity and thus we essentially characterize all \"nice\" functions as either complete or having SFE unconditionally.", "paper_title": "Completeness in two-party secure computation: A computational view", "paper_id": "WOS:000241139000005"}