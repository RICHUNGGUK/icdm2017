{"auto_keywords": [{"score": 0.039271912623931836, "phrase": "development_history"}, {"score": 0.00481495049065317, "phrase": "multi-objective_code-smells_correction"}, {"score": 0.004688321299229397, "phrase": "widely_used_techniques"}, {"score": 0.004595529592539951, "phrase": "software_systems"}, {"score": 0.0045346863560033175, "phrase": "software_refactoring"}, {"score": 0.00448958076531243, "phrase": "internal_structure"}, {"score": 0.004313581307559327, "phrase": "existing_approaches"}, {"score": 0.004284923367722827, "phrase": "refactoring_automation"}, {"score": 0.0042281749832498, "phrase": "recent_studies"}, {"score": 0.004089556946377719, "phrase": "correct_and_consistent_refactoring_solutions"}, {"score": 0.004021954624114115, "phrase": "quality_improvement"}, {"score": 0.0038642157757169315, "phrase": "semantics_preservation"}, {"score": 0.003675681237571904, "phrase": "powerful_source"}, {"score": 0.0034730657554172405, "phrase": "automated_software_refactoring"}, {"score": 0.0033367819052051995, "phrase": "existing_software_projects"}, {"score": 0.0033035520810722886, "phrase": "new_refactoring_solutions"}, {"score": 0.0032706520949775065, "phrase": "account_context_similarity"}, {"score": 0.0031527885391562423, "phrase": "multi-objective_optimization-based_approach"}, {"score": 0.002842920225545139, "phrase": "construct_semantics"}, {"score": 0.0027587851842693725, "phrase": "non-dominated_sorting_genetic_algorithm"}, {"score": 0.002740430108703258, "phrase": "nsga"}, {"score": 0.0026771333996253783, "phrase": "best_trade-offs"}, {"score": 0.0025634286580668427, "phrase": "five_medium"}, {"score": 0.002546368390189036, "phrase": "large-size_open-source_systems"}, {"score": 0.002446359075737738, "phrase": "data_class"}, {"score": 0.002198412942421744, "phrase": "suggested_refactorings"}, {"score": 0.0021620042653528846, "phrase": "change_history"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Search-based software engineering", " Refactoring", " Code-smells"], "paper_abstract": "One of the widely used techniques to improve the quality of software systems is refactoring. Software refactoring improves the internal structure of the system while preserving its external behavior. These two concerns drive the existing approaches to refactoring automation. However, recent studies demonstrated that these concerns are not enough to produce correct and consistent refactoring solutions. In addition to quality improvement and behavior preservation, studies consider, among others, construct semantics preservation and minimization of changes. From another perspective, development history was proven as a powerful source of knowledge in many maintenance tasks. Still, development history is not widely explored in the context of automated software refactoring. In this paper, we use the development history collected from existing software projects to propose new refactoring solutions taking into account context similarity with situations seen in the past. We propose a multi-objective optimization-based approach to find good refactoring sequences that (1) minimize the number of code-smells, and (2) maximize the use of development history while (3) preserving the construct semantics. To this end, we use the non-dominated sorting genetic algorithm (NSGA-II) to find the best trade-offs between these three objectives. We evaluate our approach using a benchmark composed of five medium and large-size open-source systems and four types of code-smells (Blob, spaghetti code, functional decomposition, and data class). Our experimental results show the effectiveness of our approach, compared to three different state-of-the-art approaches, with more than 85% of code-smells fixed and 86% of suggested refactorings semantically coherent when the change history is used. (c) 2015 Elsevier Inc. All rights reserved.", "paper_title": "Improving multi-objective code-smells correction using development history", "paper_id": "WOS:000355707300002"}