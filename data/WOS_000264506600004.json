{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "regular-expression_derivatives"}, {"score": 0.004264923517966271, "phrase": "regular_expressions"}, {"score": 0.004013843843250455, "phrase": "regular-expression_operators"}, {"score": 0.0025069746344846397, "phrase": "large_character_sets"}, {"score": 0.002431938942513382, "phrase": "unicode"}, {"score": 0.002288519595829552, "phrase": "derivatives_approach"}, {"score": 0.0022369407711124775, "phrase": "smaller_state_machines"}, {"score": 0.0021865218861454256, "phrase": "traditional_algorithm"}, {"score": 0.002137238878679088, "phrase": "mcnaughton"}, {"score": 0.002105008747329694, "phrase": "yamada"}], "paper_keywords": [""], "paper_abstract": "Regular-expression derivatives Lire an old, but elegant, technique for compiling regular expressions to deterministic finite-state machines. It easily supports extending the regular-expression operators with boolean operations, such as intersection and complement. Unfortunately, this technique has been lost in the sands of time and few computer scientists are aware of it. In this paper, we reexamine regular-expression derivatives and report on our experiences in the context of two different functional-language implementations. The basic: implementation is simple and we show how to extend it to handle large character sets (e.g., Unicode). We also show that the derivatives approach leads to smaller state machines than the traditional algorithm given by McNaughton and Yamada.", "paper_title": "Regular-expression derivatives re-examined", "paper_id": "WOS:000264506600004"}