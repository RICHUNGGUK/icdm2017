{"auto_keywords": [{"score": 0.04351879568458235, "phrase": "soundness_conditions"}, {"score": 0.00481495049065317, "phrase": "gcc_optimizers"}, {"score": 0.004782977628406988, "phrase": "trace_generation"}, {"score": 0.004735414083933722, "phrase": "translation_validation_approach"}, {"score": 0.004688321299229397, "phrase": "semantics_preservation"}, {"score": 0.004657185361669812, "phrase": "individual_compilations"}, {"score": 0.0045196012587080114, "phrase": "novel_framework"}, {"score": 0.00448958076531243, "phrase": "translation_validation"}, {"score": 0.004386063799793622, "phrase": "comprehensive_set"}, {"score": 0.004356926418550194, "phrase": "primitive_program_transformations"}, {"score": 0.003877121909026298, "phrase": "particular_compiler_implementation"}, {"score": 0.003813017794036879, "phrase": "pvs._an_optimizer"}, {"score": 0.003700279655380723, "phrase": "optimization_run"}, {"score": 0.0036390887584943723, "phrase": "predefined_transformation-primitives"}, {"score": 0.003370344851760079, "phrase": "individual_transformations"}, {"score": 0.0032815823097599316, "phrase": "first_step"}, {"score": 0.00312138530097218, "phrase": "temporal_logic"}, {"score": 0.0030799988391729464, "phrase": "second_step"}, {"score": 0.0030595112110658675, "phrase": "model_checking"}, {"score": 0.0028907624732186373, "phrase": "rtl_intermediate_code"}, {"score": 0.0028715299874549245, "phrase": "gnu_compiler_collection"}, {"score": 0.00285242961883492, "phrase": "gcc"}, {"score": 0.0025978919678702793, "phrase": "sample_programs"}, {"score": 0.002537880772794665, "phrase": "c_language"}, {"score": 0.0024627509513027923, "phrase": "program_analyses"}, {"score": 0.0024382043599750236, "phrase": "gcc."}, {"score": 0.002397833600728684, "phrase": "gcc_code_base"}, {"score": 0.002250415129116109, "phrase": "instrumentation_code"}, {"score": 0.002220551141101661, "phrase": "pvs_specifications"}, {"score": 0.0021764949731965656, "phrase": "gcc_code"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["compiler optimization", " translation validation", " GCC", " temporal logic", " PVS"], "paper_abstract": "The translation validation approach involves establishing semantics preservation of individual compilations. In this paper, we present a novel framework for translation validation of optimizers. We identify a comprehensive set of primitive program transformations that are commonly used in many optimizations. For each primitive, we define soundness conditions that guarantee. that the transformation is semantics preserving. This framework of transformations and soundness conditions is independent of any particular compiler implementation and is formalized in PVS. An optimizer is instrumented to generate the trace of an optimization run in terms of the predefined transformation-primitives. The validation succeeds if (1) the trace conforms to the optimization and (2) the soundness conditions of the individual transformations in the trace are satisfied. The first step eliminates the need to trust the instrumentation. The soundness conditions are defined in a temporal logic and therefore the second step involves model checking. Thus the scheme is completely automatable. We have applied this approach to several intraprocedural optimizations of RTL intermediate code in GNU Compiler Collection (GCC) v4.1.0, namely, loop invariant code motion, partial redundancy elimination, lazy code motion, code hoisting, and copy and constant propagation for sample programs written in a subset of the C language. The validation does not require information about program analyses performed by GCC. Therefore even though the GCC code base is quite large and complex, instrumentation could be achieved easily. The framework requires an estimated 21 lines of instrumentation code and 140 lines of PVS specifications for every 1000 lines of the GCC code considered for validation. Copyright (C) 2009 John Wiley & Sons, Ltd.", "paper_title": "Validation of GCC optimizers through trace generation", "paper_id": "WOS:000264940900003"}