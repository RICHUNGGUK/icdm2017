{"auto_keywords": [{"score": 0.04945540937697203, "phrase": "dynamic_compilation"}, {"score": 0.008840449758594326, "phrase": "compilation_overhead"}, {"score": 0.00481495049065317, "phrase": "java_dynamic_compilation"}, {"score": 0.004690305164360866, "phrase": "java_virtual_machine"}, {"score": 0.004479855062309818, "phrase": "compiled_codes"}, {"score": 0.00433531459712787, "phrase": "java_bytecodes"}, {"score": 0.004223032986655664, "phrase": "inappropriate_decision"}, {"score": 0.003928969293303814, "phrase": "good_heuristic_algorithm"}, {"score": 0.003777261911983744, "phrase": "appropriate_balance"}, {"score": 0.003584025547693836, "phrase": "method_invocation_sequence"}, {"score": 0.0035141291835319682, "phrase": "method-size_and_execution-time_heuristic_algorithm"}, {"score": 0.003334309053314909, "phrase": "key_principle"}, {"score": 0.0032054891061528896, "phrase": "different_method-sizes"}, {"score": 0.0031636612155559267, "phrase": "different_compile_thresholds"}, {"score": 0.0031223774204093713, "phrase": "optimal_performance"}, {"score": 0.0030614565460256897, "phrase": "parameter_search_mechanism"}, {"score": 0.0030017207229983385, "phrase": "genetic_algorithm"}, {"score": 0.002866817775018445, "phrase": "optimised_multi-thresholds"}, {"score": 0.0027560092576928595, "phrase": "heuristic_algorithm"}, {"score": 0.00266693888510356, "phrase": "openjdk_java_server_jvm"}, {"score": 0.0026321278558195933, "phrase": "spec"}, {"score": 0.0025137856138000014, "phrase": "overall_advantage"}, {"score": 0.002480961181275199, "phrase": "performance_speedup"}, {"score": 0.0024485643104830814, "phrase": "testing_benchmarks"}, {"score": 0.0022041312401435346, "phrase": "original_openjdk"}, {"score": 0.0021049977753042253, "phrase": "whole_benchmark_suite"}], "paper_keywords": [""], "paper_abstract": "Dynamic compilation increases Java virtual machine (JVM) performance because running compiled codes is faster than interpreting Java bytecodes. However, inappropriate decision on dynamic compilation may degrade performance owing to compilation overhead. A good heuristic algorithm for dynamic compilation should achieve an appropriate balance between compilation overhead and performance gain in each method invocation sequence. A method-size and execution-time heuristic algorithm is proposed in the study. The key principle of the algorithm is that different method-sizes necessitate different compile thresholds for optimal performance. A parameter search mechanism using a genetic algorithm for dynamic compilation is proposed to find optimised multi-thresholds in the algorithm. This heuristic algorithm is evaluated in an openJDK Java Server JVM using SPEC JVM98 benchmark suite. The algorithm shows an overall advantage in performance speedup when testing benchmarks and gain speedup by 19.1% on average. The algorithm also increases the performance of original openJDK by 10.2% when extended to the whole benchmark suite.", "paper_title": "Heuristic optimisation algorithm for Java dynamic compilation", "paper_id": "WOS:000308914700003"}