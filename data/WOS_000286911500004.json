{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "distributed_state-space_generation"}, {"score": 0.03708680829562347, "phrase": "state_values"}, {"score": 0.004278807087784626, "phrase": "global_hash_function"}, {"score": 0.004047500054405469, "phrase": "unbounded_domains"}, {"score": 0.003571591012750155, "phrase": "global_numbering"}, {"score": 0.003401954670986958, "phrase": "tree_compression"}, {"score": 0.003285725064532174, "phrase": "recursive_state_folding"}, {"score": 0.0030650070965891653, "phrase": "plain_state_vectors"}, {"score": 0.0028590732866152118, "phrase": "mu_crl_toolset"}, {"score": 0.002723186210025975, "phrase": "maximally_shared_terms"}, {"score": 0.0024533019565858073, "phrase": "e.g._promela"}, {"score": 0.002419393934835993, "phrase": "lotos"}, {"score": 0.0021049977753042253, "phrase": "available_network_bandwidth"}], "paper_keywords": ["State-space partitioning", " state collapsing", " tree compression", " mu CRL"], "paper_abstract": "We study distributed state-space generation on a cluster of workstations. It is explained why state-space partitioning by a global hash function is problematic when states contain variables from unbounded domains, such as lists or other recursive data types. Our solution is to introduce a database which maintains a global numbering of state values. We also describe tree compression, a technique of recursive state folding, and show that it is superior to manipulating plain state vectors. This solution is implemented and linked to the mu CRL toolset, where state values are implemented as maximally shared terms (ATerms). However, it is applicable to other models as well, e.g. PROMELA or LOTOS models. Our experiments show the trade-offs between keeping the database global, replicated or local, depending on the available network bandwidth and latency.", "paper_title": "A Database Approach to Distributed State-Space Generation", "paper_id": "WOS:000286911500004"}