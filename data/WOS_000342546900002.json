{"auto_keywords": [{"score": 0.04107868567004354, "phrase": "succinct_data_structures"}, {"score": 0.035366979368155665, "phrase": "first_one"}, {"score": 0.004590820632326585, "phrase": "relatively_small_alphabet_size"}, {"score": 0.00453643016617164, "phrase": "rather_skewed_distribution"}, {"score": 0.00446490613141384, "phrase": "considerable_amount"}, {"score": 0.004091130285858113, "phrase": "biological_collections"}, {"score": 0.00405873677211836, "phrase": "source_code"}, {"score": 0.0038390240716280302, "phrase": "floating_point_data"}, {"score": 0.0037935066882208235, "phrase": "obvious_reason"}, {"score": 0.0037336520904376687, "phrase": "data_type"}, {"score": 0.0036456298076415652, "phrase": "aforementioned_requirements"}, {"score": 0.003503497128638099, "phrase": "store_and_index_floating_point_data"}, {"score": 0.0034208822062692127, "phrase": "latest_developments"}, {"score": 0.003287482882222731, "phrase": "well-known_inverted_index"}, {"score": 0.0031592690527974285, "phrase": "source_data"}, {"score": 0.0031217859267564344, "phrase": "appealing_search_times"}, {"score": 0.003036040409062437, "phrase": "self-indexing_structures"}, {"score": 0.002964415652865295, "phrase": "binary_huffman-shaped_wavelet_tree"}, {"score": 0.0028037753646260937, "phrase": "good_balance"}, {"score": 0.0027594936602962075, "phrase": "search_performance"}, {"score": 0.002726740692380339, "phrase": "second_one"}, {"score": 0.0026836723685046407, "phrase": "wavelet_trees"}, {"score": 0.002548331088496964, "phrase": "last_one"}, {"score": 0.002508073621696602, "phrase": "sadakane's_compressed_suffix_array"}, {"score": 0.0023253461255420436, "phrase": "original_data"}, {"score": 0.002208035721125305, "phrase": "original_collection"}, {"score": 0.0021731423856364003, "phrase": "fast_indexed_searches"}, {"score": 0.0021049977753042253, "phrase": "elsevier_ltd."}], "paper_keywords": ["Indexing", " Compact structures", " Real numbers"], "paper_abstract": "Succinct data structures were designed to store and/or index data with a relatively small alphabet size, a rather skewed distribution and/or, a considerable amount of repetitiveness. Although many of them were developed to handle text, they have been used with other data types, like biological collections or source code. However, there are no applications of succinct data structures in the case of floating point data, the obvious reason is that this data type does not usually fulfill the aforementioned requirements. In this work, we present four solutions to store and index floating point data that take advantage of the latest developments in succinct data structures. The first one is based on the well-known inverted index. It consumes space around the size of the source data, providing appealing search times. The other three solutions are based on self-indexing structures. The first one uses a binary Huffman-shaped wavelet tree. It is never the winner in our experiments, but still yields a good balance between space and search performance. The second one is based on wavelet trees on bytecodes, and obtains the best space/time trade-off in most scenarios. The last one is based on Sadakane's Compressed Suffix Array. It excels in space at the expense of less performance at searches. Including a representation of the original data, our indexes occupy from around 70% to 115% of the size of the original collection, and permit fast indexed searches within it. (C) 2014 Elsevier Ltd. All rights reserved.", "paper_title": "Indexing and Self-indexing sequences of IEEE 754 double precision numbers", "paper_id": "WOS:000342546900002"}