{"auto_keywords": [{"score": 0.03153336899228719, "phrase": "implicit_finite_element"}, {"score": 0.0307997635923216, "phrase": "unstructured_meshes"}, {"score": 0.00481495049065317, "phrase": "performance_proxy"}, {"score": 0.004757087682427765, "phrase": "finite_element_method_engineering_application"}, {"score": 0.00445997627516653, "phrase": "small_subset"}, {"score": 0.004283739213556286, "phrase": "computational_and_data_access_patterns"}, {"score": 0.004147756103284082, "phrase": "even_smaller_portion"}, {"score": 0.004081385289516914, "phrase": "performance-impacting_features"}, {"score": 0.004032302251481604, "phrase": "application_developers"}, {"score": 0.003999907278478564, "phrase": "parallel_computing_experts"}, {"score": 0.003951800212882157, "phrase": "computer_architects"}, {"score": 0.0038728990904778678, "phrase": "representative_subset"}, {"score": 0.0037955672944969287, "phrase": "small_mini-application"}, {"score": 0.0036602262729063775, "phrase": "primary_performance_characteristics"}, {"score": 0.0032956583072431423, "phrase": "high-performance_computing_community"}, {"score": 0.003229815147800001, "phrase": "critical_question"}, {"score": 0.0031271827534050493, "phrase": "key_performance_behavior"}, {"score": 0.002607598760956807, "phrase": "node_performance"}, {"score": 0.0023666732429695908, "phrase": "performance_characteristics"}, {"score": 0.0023099954987126, "phrase": "single_iteration"}, {"score": 0.002254672021120091, "phrase": "single_compute_node"}, {"score": 0.002174155795026218, "phrase": "u.s._government_work"}, {"score": 0.0021306709646058295, "phrase": "public_domain"}, {"score": 0.00210502849674439, "phrase": "usa."}], "paper_keywords": ["miniapps", " proxy application", " performance proxy", " validation", " finite element method", " co-design"], "paper_abstract": "The performance of a large-scale, production-quality science and engineering application (app') is often dominated by a small subset of the code. Even within that subset, computational and data access patterns are often repeated, so that an even smaller portion can represent the performance-impacting features. If application developers, parallel computing experts, and computer architects can together identify this representative subset and then develop a small mini-application (miniapp') that can capture these primary performance characteristics, then this miniapp can be used to both improve the performance of the app as well as provide a tool for co-design for the high-performance computing community. However, a critical question is whether a miniapp can effectively capture key performance behavior of an app. This study provides a comparison of an implicit finite element semiconductor device modeling app on unstructured meshes with an implicit finite element miniapp on unstructured meshes. The goal is to assess whether the miniapp is predictive of the performance of the app. Single compute node performance will be compared, as well as scaling up to 16,000 cores. Results indicate that the miniapp can be reasonably predictive of the performance characteristics of the app for a single iteration of the solver on a single compute node. Published 2015. This article is a U.S. Government work and is in the public domain in the USA.", "paper_title": "Assessing a mini-application as a performance proxy for a finite element method engineering application", "paper_id": "WOS:000363766600044"}