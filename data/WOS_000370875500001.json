{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "static_pipeline_architecture"}, {"score": 0.00471811808206897, "phrase": "pipelined_processors"}, {"score": 0.004623224002010226, "phrase": "new_way"}, {"score": 0.004349791059765796, "phrase": "traditional_in-order_pipeline"}, {"score": 0.004233492114255375, "phrase": "energy_usage"}, {"score": 0.003249966782844541, "phrase": "conventional_architecture"}, {"score": 0.0030163012350270025, "phrase": "target_address_calculations"}, {"score": 0.0025630077791393125, "phrase": "return_addresses"}, {"score": 0.0024440836179156593, "phrase": "conditional_calls"}, {"score": 0.0021776870246727233, "phrase": "execution_time"}, {"score": 0.0021049977753042253, "phrase": "estimated_energy_usage"}], "paper_keywords": ["Algorithms", " Measurements", " Performance", " Transfers of Control", " Compiler Optimizations", " Energy Efficiency"], "paper_abstract": "Statically pipelined processors offer a new way to improve the performance beyond that of a traditional in-order pipeline while simultaneously reducing energy usage by enabling the compiler to control more fine-grained details of the program execution. This paper describes how a compiler can exploit the features of the static pipeline architecture to apply optimizations on transfers of control that are not possible on a conventional architecture. The optimizations presented in this paper include hoisting the target address calculations for branches, jumps, and calls out of loops, performing branch chaining between calls and jumps, hoisting the setting of return addresses out of loops, and exploiting conditional calls and returns. The benefits of performing these transfer of control optimizations include a 6.8% reduction in execution time and a 3.6% decrease in estimated energy usage.", "paper_title": "Optimizing Transfers of Control in the Static Pipeline Architecture", "paper_id": "WOS:000370875500001"}