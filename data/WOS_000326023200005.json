{"auto_keywords": [{"score": 0.03376529746472917, "phrase": "stm_algorithms"}, {"score": 0.010612387000973441, "phrase": "in-place_metadata"}, {"score": 0.010292158716420675, "phrase": "stm"}, {"score": 0.007114416001113124, "phrase": "efficient_implementation"}, {"score": 0.004777917315737992, "phrase": "java_software_transactional_memory"}, {"score": 0.004544016163767266, "phrase": "memory_locations"}, {"score": 0.004474366340935036, "phrase": "transaction's_lifetime"}, {"score": 0.0043215158337835706, "phrase": "external_table"}, {"score": 0.0042388570312522, "phrase": "mapping_function"}, {"score": 0.004125773078637226, "phrase": "memory_cell"}, {"score": 0.004078232992955235, "phrase": "table_entry"}, {"score": 0.004031238480458909, "phrase": "corresponding_metadata"}, {"score": 0.0037314328720368453, "phrase": "associated_memory_cell"}, {"score": 0.0035076666315744525, "phrase": "implementation_techniques"}, {"score": 0.003374655868348244, "phrase": "stm_framework"}, {"score": 0.003075583447856341, "phrase": "fair_comparison"}, {"score": 0.00282470997972535, "phrase": "memory_cells"}, {"score": 0.00268616928039386, "phrase": "transactional_metadata"}, {"score": 0.0026551731045904854, "phrase": "proposed_technique"}, {"score": 0.0025842289219860795, "phrase": "deuce"}, {"score": 0.0025151755329660837, "phrase": "wide_range"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["software transactional memory", " Java", " bytecode instrumentation", " data structures"], "paper_abstract": "Software transactional memory (STM) algorithms associate metadata with the memory locations accessed during a transaction's lifetime. This metadata may be stored in an external table by resorting to a mapping function that associates the address of a memory cell with the table entry containing the corresponding metadata (out-place or external strategy). Alternatively, the metadata may be stored adjacent to the associated memory cell by wrapping the cell and metadata together (in-place strategy). The implementation techniques to support these two approaches are very different and each STM framework is usually biased towards one of them, only allowing the efficient implementation of STM algorithms which suit one of the approaches and inhibiting a fair comparison with STM algorithms suiting the other. In this paper, we introduce a technique to implement in-place metadata that does not wrap memory cells, thus overcoming the bias and allowing STM algorithms to directly access the transactional metadata. The proposed technique is available as an extension to Deuce and enables the efficient implementation of a wide range of STM algorithms and their fair (unbiased) comparison in a common STM framework. We illustrate the benefits of our approach by analyzing its impact in two popular transactional memory algorithms with several transactional workloads, TL2 and multiversioning, each befitting out-place and in-place, respectively. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Efficient support for in-place metadata in Java software transactional memory", "paper_id": "WOS:000326023200005"}