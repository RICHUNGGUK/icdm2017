{"auto_keywords": [{"score": 0.037239348221425404, "phrase": "code_size"}, {"score": 0.00481495049065317, "phrase": "vliw_architectures"}, {"score": 0.004752221133109136, "phrase": "embedded_systems"}, {"score": 0.004568871736067739, "phrase": "good_performance"}, {"score": 0.00450933377534525, "phrase": "low_cost"}, {"score": 0.00433531459712787, "phrase": "compiled_code"}, {"score": 0.004140726362519362, "phrase": "overall_cost"}, {"score": 0.00406001734835979, "phrase": "embedded_system"}, {"score": 0.003980875186335867, "phrase": "compilation_strategy"}, {"score": 0.003752550907120244, "phrase": "high_performance"}, {"score": 0.003631390978147703, "phrase": "system_cost"}, {"score": 0.003584025547693836, "phrase": "memory_size"}, {"score": 0.003468287913322255, "phrase": "important_issue"}, {"score": 0.003423042581201533, "phrase": "code_generation"}, {"score": 0.003334309053314909, "phrase": "cost-effective_optimization_strategies"}, {"score": 0.0031845067058084583, "phrase": "good_trade-off"}, {"score": 0.0028480459059007468, "phrase": "novel_method"}, {"score": 0.0027924625350414655, "phrase": "integer_linear_programming_for"}, {"score": 0.0027560092576928595, "phrase": "efficient_unroll_factors"}, {"score": 0.00268452026617243, "phrase": "loop_nests"}, {"score": 0.0022041312401435346, "phrase": "excellent_trade-offs"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["loop unrolling", " iterative compilation", " code optimization", " feedback directed compilation", " instruction level parallelism"], "paper_abstract": "Embedded systems are increasingly expected to provide good performance at low cost. As the characteristics of compiled code can have an impact on the overall cost of an embedded system, a compilation strategy must be cost aware as well as achieve high performance. As one major factor for system cost is memory size, code size becomes an important issue in code generation. Thus, cost-effective optimization strategies that are able to perform a good trade-off between code size and performance improvement are needed. In this paper, we propose a novel method based on Integer Linear Programming for computing efficient unroll factors for collections of loop nests with control over code size and side-effects of the transformation. We define a notion of trade-off between code size and performance. Experiments on the Philips Trimedia show that our method achieves excellent trade-offs. Copyright (c) 2006 John Wiley & Sons, Ltd.", "paper_title": "UFS: a global trade-off strategy for loop unrolling for VLIW architectures", "paper_id": "WOS:000240214200005"}