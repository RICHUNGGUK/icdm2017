{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "model-driven_engineering"}, {"score": 0.03618690757685971, "phrase": "model_management_operations"}, {"score": 0.004660702714929615, "phrase": "software_engineering_paradigm"}, {"score": 0.004585433265422727, "phrase": "active_use"}, {"score": 0.004493045859210086, "phrase": "development_process"}, {"score": 0.0044025116437190785, "phrase": "inherently_type-centric"}, {"score": 0.004141663280057689, "phrase": "specific_meta-models"}, {"score": 0.004008897491380646, "phrase": "existing_mde_artefacts"}, {"score": 0.003740679163860117, "phrase": "reuse_opportunities"}, {"score": 0.003710323357333052, "phrase": "mde_artefacts"}, {"score": 0.003635503288514593, "phrase": "paradigm_shift"}, {"score": 0.003562186600028245, "phrase": "-centric_specifications"}, {"score": 0.00332375606483146, "phrase": "so-called_concepts"}, {"score": 0.0032967724149749853, "phrase": "structural_and_behavioural_requirements"}, {"score": 0.002881793492919646, "phrase": "model_templates"}, {"score": 0.0028121429464519733, "phrase": "suitable_interfaces"}, {"score": 0.0027330029055210926, "phrase": "reusable_model_components"}, {"score": 0.00266693888510356, "phrase": "mixin_layers"}, {"score": 0.002581324549141829, "phrase": "meta-model_level"}, {"score": 0.0024882810071079797, "phrase": "modular_way"}, {"score": 0.002274684393868218, "phrase": "metadepth"}, {"score": 0.0021659920594094407, "phrase": "action_languages"}, {"score": 0.0021396386320044172, "phrase": "epsilon_family"}, {"score": 0.0021222476760114914, "phrase": "model_management"}, {"score": 0.0021049977753042253, "phrase": "code_generation"}], "paper_keywords": ["Model-driven engineering", " Language engineering", " Meta-modelling", " Genericity", " Reutilization"], "paper_abstract": "Model-driven engineering (MDE) is a software engineering paradigm that proposes an active use of models during the development process. This paradigm is inherently type-centric, in the sense that models and their manipulation are defined over the types of specific meta-models. This fact hinders the reuse of existing MDE artefacts with other meta-models in new contexts, even if all these meta-models share common characteristics. To increase the reuse opportunities of MDE artefacts, we propose a paradigm shift from type-centric to requirement-centric specifications by bringing genericity into models, meta-models and model management operations. For this purpose, we introduce so-called concepts gathering structural and behavioural requirements for models and meta-models. In this way, model management operations are defined over concepts, enabling the application of the operations to any meta-model satisfying the requirements imposed by the concept. Model templates rely on concepts to define suitable interfaces, hence enabling the definition of reusable model components. Finally, similar to mixin layers, templates can be defined at the meta-model level as well, to define languages in a modular way, as well as layers of functionality to be plugged-in into other meta-models. These ideas have been implemented in MetaDepth, a multi-level meta-modelling tool that integrates action languages from the Epsilon family for model management and code generation.", "paper_title": "From types to type requirements: genericity for model-driven engineering", "paper_id": "WOS:000321268300005"}