{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "library_abstraction"}, {"score": 0.004633429997452688, "phrase": "complex_concurrent_systems"}, {"score": 0.004263168852219819, "phrase": "concurrent_libraries"}, {"score": 0.004155283263388382, "phrase": "abstract_specifications"}, {"score": 0.004050116768809519, "phrase": "implementation_details"}, {"score": 0.0039729853486821995, "phrase": "memory_models"}, {"score": 0.003922378980031565, "phrase": "substantial_challenges"}, {"score": 0.0036788184374592706, "phrase": "sequentially_consistent_abstractions"}, {"score": 0.0035856674209019234, "phrase": "unnecessary_synchronisation"}, {"score": 0.0034063576796640603, "phrase": "relaxed_memory_effects"}, {"score": 0.00334144503360907, "phrase": "library_specifications"}, {"score": 0.003054450075234415, "phrase": "sound_library_abstraction"}, {"score": 0.0029203055813347874, "phrase": "standard_sequentially_consistent_notion"}, {"score": 0.0027212777001495176, "phrase": "client-library_interactions"}, {"score": 0.0026184796288543878, "phrase": "return_values"}, {"score": 0.002535779689260244, "phrase": "subtle_synchronisation_effects"}, {"score": 0.0024714996534331668, "phrase": "memory_model"}, {"score": 0.002273605493468005, "phrase": "lock-free_treiber_stack"}, {"score": 0.0022302306304023602, "phrase": "producer-consumer_queue"}, {"score": 0.0021597662797996843, "phrase": "first_approach"}, {"score": 0.0021322065604537617, "phrase": "compositional_reasoning"}], "paper_keywords": ["Languages", " Theory", " Verification", " Verification", " Concurrency", " Modularity", " C", " C plus"], "paper_abstract": "When constructing complex concurrent systems, abstraction is vital: programmers should be able to reason about concurrent libraries in terms of abstract specifications that hide the implementation details. Relaxed memory models present substantial challenges in this respect, as libraries need not provide sequentially consistent abstractions: to avoid unnecessary synchronisation, they may allow clients to observe relaxed memory effects, and library specifications must capture these. In this paper, we propose a criterion for sound library abstraction in the new C11 and C++11 memory model, generalising the standard sequentially consistent notion of linearizability. We prove that our criterion soundly captures all client-library interactions, both through call and return values, and through the subtle synchronisation effects arising from the memory model. To illustrate our approach, we verify implementations against specifications for the lock-free Treiber stack and a producer-consumer queue. Ours is the first approach to compositional reasoning for concurrent C11/C++11 programs.", "paper_title": "Library Abstraction for C/C++ Concurrency", "paper_id": "WOS:000318629900021"}