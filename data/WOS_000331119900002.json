{"auto_keywords": [{"score": 0.04481780851221896, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "free_-_polymorphic_views"}, {"score": 0.0045108906244892165, "phrase": "novel_technique"}, {"score": 0.0036026484429137998, "phrase": "haskell-level_lambdas"}, {"score": 0.0034742854447532678, "phrase": "key_idea"}, {"score": 0.0033748847621075536, "phrase": "rich_types"}, {"score": 0.0032310733124059536, "phrase": "additional_free_variable"}, {"score": 0.002876747208161839, "phrase": "v.v_x_term"}, {"score": 0.002347378595930709, "phrase": "term_construction"}, {"score": 0.002263639474937039, "phrase": "natural_way"}, {"score": 0.002182881082103045, "phrase": "good_properties"}, {"score": 0.0021049977753042253, "phrase": "de_bruijn_indices"}], "paper_keywords": ["name binding", " polymorphism", " parametricity", " type-classes", " nested types"], "paper_abstract": "We propose a novel technique to represent names and binders in Haskell. The dynamic (run-time) representation is based on de Bruijn indices, but it features an interface to write and manipulate variables conviently, using Haskell-level lambdas and variables. The key idea is to use rich types: a subterm with an additional free variable is viewed either as for all v.v -> Term (a + v) or there exists v.v X Term (a + v) depending on whether it is constructed or analysed. We demonstrate on a number of examples how this approach permits to express term construction and manipulation in a natural way, while retaining the good properties of representations based on de Bruijn indices.", "paper_title": "Names For Free - Polymorphic Views of Names and Binders", "paper_id": "WOS:000331119900002"}