{"auto_keywords": [{"score": 0.049867775103737924, "phrase": "orc"}, {"score": 0.0131134800025239, "phrase": "orc_programs"}, {"score": 0.006626846812846936, "phrase": "orc_calculus"}, {"score": 0.005007160328186459, "phrase": "formal_verification"}, {"score": 0.00481495049065317, "phrase": "logic_semantics"}, {"score": 0.004772593750252861, "phrase": "formal_analysis"}, {"score": 0.004637478829869904, "phrase": "great_versatility"}, {"score": 0.004617032591561129, "phrase": "practical_applicability"}, {"score": 0.004466519142879166, "phrase": "orc_language"}, {"score": 0.004397961100937846, "phrase": "powerful_programming_constructs"}, {"score": 0.004330450801016359, "phrase": "underlying_formal_calculus"}, {"score": 0.0041707622112716, "phrase": "formal_semantics"}, {"score": 0.004124920849728372, "phrase": "great_importance"}, {"score": 0.0038859115106376794, "phrase": "language_implementations"}, {"score": 0.003750839029189621, "phrase": "wide_range"}, {"score": 0.0037342872423881076, "phrase": "semantics-based_program_verification_tools"}, {"score": 0.003685067218455088, "phrase": "theorem_provers"}, {"score": 0.0036364935743448236, "phrase": "formal_executable_semantics"}, {"score": 0.0035178323426661626, "phrase": "possible_semantics-based_correct-by-construction_orc_implementations"}, {"score": 0.00342568771304873, "phrase": "quite_subtle_semantics"}, {"score": 0.003319181835368832, "phrase": "morc"}, {"score": 0.0031845067058084583, "phrase": "internal_computations"}, {"score": 0.003163439005885435, "phrase": "orc_expression"}, {"score": 0.003149471116658739, "phrase": "external_computations"}, {"score": 0.003114819780703495, "phrase": "external_sites"}, {"score": 0.003053402354907241, "phrase": "simple_and_elegant_way"}, {"score": 0.0029733865110222785, "phrase": "order-sorted_type_system"}, {"score": 0.0029471818883482688, "phrase": "subtype_polymorphism"}, {"score": 0.0028446460307503343, "phrase": "useful_semantic_equivalences"}, {"score": 0.002807118943000936, "phrase": "equational_attributes"}, {"score": 0.0026560059162940453, "phrase": "sos"}, {"score": 0.0026036031415940563, "phrase": "original_sos"}, {"score": 0.0023935128386292966, "phrase": "strong_bisimulation_theorem"}, {"score": 0.0023359162620524105, "phrase": "model_checking_tool"}, {"score": 0.0023153166541790213, "phrase": "rewriting_semantics"}, {"score": 0.0022248385043105103, "phrase": "user-defined_state_predicates"}, {"score": 0.002215011840295757, "phrase": "ltl"}, {"score": 0.002176106263033925, "phrase": "prior_knowledge"}, {"score": 0.0021664893025452048, "phrase": "maude"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Rewriting logic", " Orc", " Executable semantics", " Maude", " Formal analysis", " Service orchestration"], "paper_abstract": "The Orc calculus is a simple, yet powerful theory of concurrent computations with great versatility and practical applicability to a very wide range of applications, as it has been amply demonstrated by the Orc language, which extends the Orc calculus with powerful programming constructs that can be desugared into the underlying formal calculus. This means that for: (i) theoretical, (ii) program verification, and (iii) language implementation reasons, the formal semantics of Orc is of great importance. Furthermore, having a semantics of Orc that is executable is essential to provide: (i) a formally-defined interpreter against which language implementations can be validated, and (ii) a (semi-)automatic way of generating a wide range of semantics-based program verification tools, including model checkers and theorem provers. This work proposes a formal executable semantics for Orc in rewriting logic, to support formal verification of Orc programs and to make possible semantics-based correct-by-construction Orc implementations. While being a very simple calculus, Orc has a quite subtle semantics, so that fully capturing all its semantic aspects is highly nontrivial. The two main sources of subtlety are: (i) its real-time semantics, and (ii) the priority of internal computations within an Orc expression over external computations that process responses from external sites. In this paper, we show a simple and elegant way of handling these two sources of subtlety in rewriting logic using an order-sorted type system supporting subtypes and subtype polymorphism, and \"tick\" rewrite rules for capturing time. Moreover, our rewriting semantics incorporates useful semantic equivalences between Orc programs as equations and equational attributes, making the semantics both more abstract and more efficient. The semantics of Orc is given in two different styles: (i) an SOS style, which is directly based on the original SOS of Orc, whose correctness follows immediately by construction, and (ii) a reduction semantics, which is much more efficiently executable and analyzable, as shown through several experiments, and whose correctness is proved using a strong bisimulation theorem. The paper also presents MORC, a simulator and model checking tool based on the rewriting semantics of Orc and Real-Time Maude. MORC facilitates formal verification of Orc programs, and allows for user-defined state predicates and LTL formulas, with no need for any prior knowledge of Maude or its rewriting logic foundations. (C) 2015 The Authors. Published by Elsevier Inc.", "paper_title": "Executable rewriting logic semantics of Orc and formal analysis of Orc programs", "paper_id": "WOS:000357904900003"}