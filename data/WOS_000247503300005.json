{"auto_keywords": [{"score": 0.0490124379843987, "phrase": "conspiratorial_executions"}, {"score": 0.00481495049065317, "phrase": "non-conspiratorial_executions"}, {"score": 0.00450020161335541, "phrase": "model_checking"}, {"score": 0.004020492138367616, "phrase": "non-equivalence_robust_executions"}, {"score": 0.0038431888954930083, "phrase": "distributed_setting"}, {"score": 0.0034332736827447654, "phrase": "strongly_fair_manner"}, {"score": 0.0031845067058084613, "phrase": "formal_connection"}, {"score": 0.0030901063954739375, "phrase": "equivalence_robustness"}, {"score": 0.002931569771634119, "phrase": "transformation_scheme"}, {"score": 0.002678433668156676, "phrase": "well-known_distributed_scheduler"}, {"score": 0.0023566987138026285, "phrase": "potential_conspiracies"}, {"score": 0.0022022878843247257, "phrase": "particular_interaction_model"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["distributed systems", " concurrency", " conspiracies", " equivalence robustness", " fairness"], "paper_abstract": "Avoiding conspiratorial executions is useful for debugging, model checking or refinement, and helps implement several well-known problems in faulty environments; furthermore, avoiding non-equivalence robust executions prevents conflicting observations in a distributed setting from occurring. Our results prove that scheduling pairs of states and transitions in a strongly fair manner suffices to prevent conspiratorial executions; we then establish a formal connection between conspiracies and equivalence robustness; finally, we present a transformation scheme to implement our results and show how to build them into a well-known distributed scheduler. Previous results were applicable to a subset of systems only, just attempted to characterise potential conspiracies, or were tightly bound up with a particular interaction model. (C) 2007 Elsevier B.V. All rights reserved.", "paper_title": "Generating non-conspiratorial executions", "paper_id": "WOS:000247503300005"}