{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "recursive_definitions"}, {"score": 0.035544412132803634, "phrase": "intersection_types"}, {"score": 0.004668059458774745, "phrase": "intersection_type_system"}, {"score": 0.003916098498242888, "phrase": "simple_type"}, {"score": 0.0037769520261285872, "phrase": "new_typing_rules"}, {"score": 0.0034236045013591437, "phrase": "typing_rules"}, {"score": 0.002643386043540555, "phrase": "interesting_examples"}, {"score": 0.0026161698049580804, "phrase": "polymorphic_recursion"}, {"score": 0.002445950676329976, "phrase": "different_occurrences"}, {"score": 0.0023467391904246834, "phrase": "different_types"}, {"score": 0.0022749744354271816, "phrase": "underlying_techniques"}], "paper_keywords": ["type inference", " principal typings", " polymorphic recursion"], "paper_abstract": "Let proves be an intersection type system. We say that a term is proves-simple (or just simple when the system proves is clear from the context) if system proves can prove that it has a simple type. In this paper we propose new typing rules and algorithms that are able to type (with rank 2 intersection types) recursive definitions that are not simple. Typing rules for assigning intersection types to (non-simple) recursive definitions have been already proposed in the literature. However, at the best of our knowledge, previous algorithms for typing recursive definitions in the presence of intersection types allow only simple recursive definitions to be typed. The rules and algorithms proposed in this paper are also able to type interesting examples of polymorphic recursion (i.e., recursive definitions rec {x = e} where different occurrences of x in e are used with different types). Moreover, the underlying techniques do not depend on particulars of rank 2 intersection, so they can be applied to other type systems.", "paper_title": "Rank 2 intersection for recursive definitions", "paper_id": "WOS:000248423100007"}