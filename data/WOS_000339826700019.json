{"auto_keywords": [{"score": 0.042797072212735154, "phrase": "data_reuse"}, {"score": 0.02375580606425023, "phrase": "cgcm"}, {"score": 0.00481495049065317, "phrase": "data_movements"}, {"score": 0.004754600386388821, "phrase": "locality-aware_searching"}, {"score": 0.004665483918844599, "phrase": "cpu-gpu_communication_bottleneck"}, {"score": 0.0044922081848067135, "phrase": "gpu_applications"}, {"score": 0.004435885269134359, "phrase": "heterogeneous_gpgpu_systems"}, {"score": 0.004035282762331904, "phrase": "dag_abstraction"}, {"score": 0.0038608730929994696, "phrase": "run-time_data_reuse"}, {"score": 0.003467940281748612, "phrase": "run-time_optimization_framework"}, {"score": 0.003194580334752371, "phrase": "locality-aware_searching_approach"}, {"score": 0.0027278178983579085, "phrase": "gpu_computation"}, {"score": 0.002544616720630384, "phrase": "compiler-based_approaches"}, {"score": 0.002481085648977411, "phrase": "better_reuse_effect"}, {"score": 0.002434477906829832, "phrase": "experimental_results"}, {"score": 0.002285335999629823, "phrase": "compiler-based_approach_openmpc"}, {"score": 0.0022002633747977593, "phrase": "single-node_execution"}, {"score": 0.0021049977753042253, "phrase": "multi-node_execution"}], "paper_keywords": ["CPU-GPU", " Run-time optimization", " Dynamic searching", " Data reuse"], "paper_abstract": "The CPU-GPU communication bottleneck limits the performance improvement of GPU applications in heterogeneous GPGPU systems and usually is handled by data reuse optimization. This paper analyzes data reuse through DAG abstraction and obtains rules showing that the run-time data reuse optimization can effectively relieve the bottleneck. Based on the rules, this paper proposes a run-time optimization framework for data reuse, called R-Tracker. The R-Tracker uses locality-aware searching approach to handle reuses. It can not only low costly implement the data reuse optimization but also effectively implement the searching, the data transfers, and the GPU computation concurrently. R-Tracker relaxes the constraints that are required in compiler-based approaches and thus achieves better reuse effect. The experimental results show that R-Tracker improves the performance by 1.77-16.42 % over compiler-based approach OpenMPC and 1.40-8.39 % over CGCM in single-node execution, and 48.78-60 % over CGCM in multi-node execution.", "paper_title": "A run-time optimization approach for reducing data movements using locality-aware searching", "paper_id": "WOS:000339826700019"}