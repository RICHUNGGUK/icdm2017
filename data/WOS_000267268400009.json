{"auto_keywords": [{"score": 0.04980018473144978, "phrase": "sharc"}, {"score": 0.021312277173284967, "phrase": "individual_objects"}, {"score": 0.01938407510392708, "phrase": "sharing_rules"}, {"score": 0.019052344116171484, "phrase": "sharing_cast"}, {"score": 0.007293403254835894, "phrase": "shoal"}, {"score": 0.0063047247921204416, "phrase": "sharing_mode"}, {"score": 0.006249832020008075, "phrase": "group_leader"}, {"score": 0.00481495049065317, "phrase": "concurrent_data_structures"}, {"score": 0.004745179442957631, "phrase": "recently_developed_system"}, {"score": 0.004676414661927138, "phrase": "multithreaded_programs"}, {"score": 0.004359903343872771, "phrase": "sharc_compiler"}, {"score": 0.004296697688671517, "phrase": "static_and_dynamic_checks"}, {"score": 0.004209739667710983, "phrase": "unintended_data_sharing"}, {"score": 0.004148701869050005, "phrase": "underlying_cause"}, {"score": 0.00412453424255527, "phrase": "harmful_data-races"}, {"score": 0.003970826351364956, "phrase": "specific_object"}, {"score": 0.0037563823007675766, "phrase": "object's_lifetime"}, {"score": 0.0036481919610079753, "phrase": "multi-threaded_c_programs"}, {"score": 0.0034209783636653317, "phrase": "whole_data_structures"}, {"score": 0.003115428684709861, "phrase": "new_concept"}, {"score": 0.0029212989109921594, "phrase": "distinguished_member"}, {"score": 0.0024154111611296215, "phrase": "safe_concurrency"}, {"score": 0.002380327476198495, "phrase": "data_structures"}, {"score": 0.0022319010540230847, "phrase": "wide_range"}, {"score": 0.0022188745774815847, "phrase": "concurrent_c_programs"}, {"score": 0.0021802485562376047, "phrase": "million_lines"}, {"score": 0.002136032060238817, "phrase": "benchmarks_groups"}, {"score": 0.002123563931605599, "phrase": "low_annotation_burden"}, {"score": 0.0021049977753042253, "phrase": "significant_additional_performance_overhead"}], "paper_keywords": ["Languages", " Verification"], "paper_abstract": "SharC is a recently developed system for checking data-sharing in multithreaded programs. Programmers specify sharing rules (read-only, protected by a lock, etc.) for individual objects, and the SharC compiler enforces these rules using static and dynamic checks. Violations of these rules indicate unintended data sharing, which is the underlying cause of harmful data-races. Additionally, SharC allows programmers to change the sharing rules for a specific object using a sharing cast, to capture the fact that sharing rules for an object often change during the object's lifetime. SharC was successfully applied to a number of multi-threaded C programs. However, many programs are not readily checkable using SharC because their sharing rules, and changes to sharing rules, effectively apply to whole data structures rather than to individual objects. We have developed a system called Shoal to address this shortcoming. In addition to the sharing rules and sharing cast of SharC, our system includes a new concept that we call groups. A group is a collection of objects all having the same sharing mode. Each group has a distinguished member called the group leader. When the sharing mode of the group leader changes by way of a sharing cast, the sharing mode of all members of the group also changes. This operation is made sound by maintaining the invariant that at the point of a sharing cast, the only external pointer into the group is the pointer to the group leader. The addition of groups allows checking safe concurrency at the level of data structures rather than at the level of individual objects. We demonstrate the necessity and practicality of groups by applying Shoal to a wide range of concurrent C programs ( the largest approaching a million lines of code). In all benchmarks groups entail low annotation burden and no significant additional performance overhead.", "paper_title": "Lightweight Annotations for Controlling Sharing in Concurrent Data Structures", "paper_id": "WOS:000267268400009"}