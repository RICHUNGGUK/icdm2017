{"auto_keywords": [{"score": 0.04940067902469232, "phrase": "emof"}, {"score": 0.043726272486193644, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "object-oriented_modelling_languages"}, {"score": 0.004614643339546038, "phrase": "domain_specific_meta-models"}, {"score": 0.004506968388996092, "phrase": "modelling_languages"}, {"score": 0.004339867166576126, "phrase": "operational_semantics"}, {"score": 0.004120136329371957, "phrase": "ocl"}, {"score": 0.004081385289516914, "phrase": "executable_meta-languages"}, {"score": 0.0040049806975968145, "phrase": "experience_report"}, {"score": 0.00389303738902168, "phrase": "smalltalk"}, {"score": 0.0038382392088338784, "phrase": "executable_meta-language"}, {"score": 0.0037309384824565695, "phrase": "moose_reengineering_environment"}, {"score": 0.003378385493203297, "phrase": "meta-described_reengineering_environment"}, {"score": 0.0032223742018434856, "phrase": "code-oriented_view"}, {"score": 0.002890266318361907, "phrase": "underlying_implementation_language"}, {"score": 0.002822712709335093, "phrase": "uniform_way"}, {"score": 0.0022175019341824603, "phrase": "introspective_api"}, {"score": 0.002186249757477356, "phrase": "ruby"}, {"score": 0.0021657533510539262, "phrase": "python"}], "paper_keywords": ["Meta behavior description", " Reflective language", " Executable modeling language", " Smalltalk"], "paper_abstract": "Object-oriented modelling languages such as EMOF are often used to specify domain specific meta-models. However, these modelling languages lack the ability to describe behavior or operational semantics. Several approaches have used a subset of Java mixed with OCL as executable meta-languages. In this experience report we show how we use Smalltalk as an executable meta-language in the context of the Moose reengineering environment. We present how we implemented EMOF and its behavioral aspects. Over the last decade we validated this approach through incrementally building a meta-described reengineering environment. Such an approach bridges the gap between a code-oriented view and a meta-model driven one. It avoids the creation of yet another language and reuses the infrastructure and run-time of the underlying implementation language. It offers an uniform way of letting developers focus on their tasks while at the same time allowing them to meta-describe their domain model. The advantage of our approach is that developers use the same tools and environment they use for their regular tasks. Still the approach is not Smalltalk specific but can be applied to language offering an introspective API such as Ruby, Python, CLOS, Java and C#.", "paper_title": "Meta-environment and executable meta-language using smalltalk: an experience report", "paper_id": "WOS:000261289000002"}