{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java-like_languages"}, {"score": 0.049465088868450476, "phrase": "fjig"}, {"score": 0.004662036750452837, "phrase": "basic_building_blocks"}, {"score": 0.00455788259881503, "phrase": "featherweight_java"}, {"score": 0.0042591158963728665, "phrase": "bracha's_jigsaw_framework"}, {"score": 0.004163925706345031, "phrase": "also_the_role"}, {"score": 0.004031603526620806, "phrase": "rich_set"}, {"score": 0.0038783340581919797, "phrase": "minimal_core"}, {"score": 0.0035087260813209593, "phrase": "nominal_approach"}, {"score": 0.0034081501761600067, "phrase": "class_names"}, {"score": 0.003299765620885585, "phrase": "structural_subtype"}, {"score": 0.0030732613046470314, "phrase": "subtyping_relation"}, {"score": 0.0030239842475439814, "phrase": "required_subtyping_relations"}, {"score": 0.0029089095588612007, "phrase": "type_system"}, {"score": 0.002825478348161608, "phrase": "large_variety"}, {"score": 0.0028072645684856313, "phrase": "different_mechanisms"}, {"score": 0.0027891678712374975, "phrase": "software_composition"}, {"score": 0.002771187508004562, "phrase": "class-based_languages"}, {"score": 0.0027444334639134217, "phrase": "standard_inheritance"}, {"score": 0.002726740692380339, "phrase": "mixin_classes"}, {"score": 0.0026060359255636444, "phrase": "unifying_framework"}, {"score": 0.0025808721879758243, "phrase": "existing_mechanisms"}, {"score": 0.002555950807368337, "phrase": "new_extensions"}, {"score": 0.0024987304152852873, "phrase": "fjig_program"}, {"score": 0.0023421884529240882, "phrase": "former_where_inherited_methods"}, {"score": 0.0023120743774800176, "phrase": "heir_classes"}, {"score": 0.0022676260293002706, "phrase": "member_lookup"}, {"score": 0.00222403027114726, "phrase": "inheritance_chain"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": [""], "paper_abstract": "We present FJIG, a simple calculus where basic building blocks are classes in the style of Featherweight Java, declaring fields, methods and one constructor. However, inheritance has been generalized to the much more flexible notion originally proposed in Bracha's Jigsaw framework. That is, classes play also the role of modules, that can be composed by a rich set of operators, all of which can be expressed by a minimal core. Fields and methods can be declared of four different kinds (abstract, virtual, frozen, local) determining how they are affected by the operators. We keep the nominal approach of Java-like languages, that is, types are class names. However, a class is not necessarily a structural subtype of any class used in its defining expression. While this allows a more flexible reuse, it may prevent the (generalized) inheritance relation from being a subtyping relation. So, the required subtyping relations among classes are declared by the programmer and checked by the type system. The calculus allows the encoding of a large variety of different mechanisms for software composition in class-based languages, including standard inheritance, mixin classes, traits and hiding. Hence, FJIG can be used as a unifying framework for analyzing existing mechanisms and proposing new extensions. We provide two different semantics of an FJIG program: flattening and direct semantics. The difference is analogous to that between two intuitive models to understand inheritance: the former where inherited methods are copied into heir classes, and the latter where member lookup is performed by ascending the inheritance chain. Here we address equivalence of these two views for a more sophisticated composition mechanism. (C) 2012 Elsevier Inc. All rights reserved.", "paper_title": "Featherweight Jigsaw - Replacing inheritance by composition in Java-like languages", "paper_id": "WOS:000302387500005"}