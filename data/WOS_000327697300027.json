{"auto_keywords": [{"score": 0.03185561073255786, "phrase": "option_contracts"}, {"score": 0.00931494241863604, "phrase": "server_components"}, {"score": 0.00477513738640734, "phrase": "behavioral_software_contracts"}, {"score": 0.004638354165775803, "phrase": "component's_obligations"}, {"score": 0.004561950666122737, "phrase": "logical_assertions"}, {"score": 0.00446820572467064, "phrase": "contract_system"}, {"score": 0.004431246962597134, "phrase": "program_execution"}, {"score": 0.004163587877500036, "phrase": "guilty_component"}, {"score": 0.00402748353567517, "phrase": "debugging_process"}, {"score": 0.00396110232316167, "phrase": "right_direction"}, {"score": 0.003928321515373316, "phrase": "quality_contracts"}, {"score": 0.0038796562792487, "phrase": "serious_runtime_cost"}, {"score": 0.0031647054743284947, "phrase": "blame_information"}, {"score": 0.002936451109357539, "phrase": "contract_tool_box"}, {"score": 0.0028640745158229875, "phrase": "ordinary_contract_systems"}, {"score": 0.0027934768366077397, "phrase": "client_components"}, {"score": 0.0026796495639791426, "phrase": "server's_promises"}, {"score": 0.002212812864395738, "phrase": "flexible_checking_policies"}, {"score": 0.0021049977753042253, "phrase": "complete_monitoring_theorem"}], "paper_keywords": ["programming language design", " behavioral software contracts", " random testing", " probabilistic spot checking"], "paper_abstract": "Many languages support behavioral software contracts so that programmers can describe a component's obligations and promises via logical assertions in its interface. The contract system monitors program execution, checks whether the assertions hold, and, if not, blames the guilty component. Pinning down the violator gets the debugging process started in the right direction. Quality contracts impose a serious runtime cost, however, and programmers therefore compromise in many ways. Some turn off contracts for deployment, but then contracts and code quickly get out of sync during maintenance. Others test contracts randomly or probabilistically. In all cases, programmers have to cope with lack of blame information when the program eventually fails. In response, we propose option contracts as an addition to the contract tool box. Our key insight is that in ordinary contract systems, server components impose their contract on client components, giving them no choice whether to trust the server's promises or check them. With option contracts, server components may choose to tag a contract as an option and clients may choose to exercise the option or accept it, in which case they also shoulder some responsibility. We show that option contracts permit programmers to specify flexible checking policies, that their cost is reasonable, and that they satisfy a complete monitoring theorem.", "paper_title": "Option Contracts", "paper_id": "WOS:000327697300027"}