{"auto_keywords": [{"score": 0.04871093899700793, "phrase": "multicore_architectures"}, {"score": 0.015719716506582538, "phrase": "dynamic_programming"}, {"score": 0.014986764587083602, "phrase": "dp"}, {"score": 0.012613362041087765, "phrase": "npdp"}, {"score": 0.008713703289556236, "phrase": "parallel_pipelining_algorithm"}, {"score": 0.00450000390667755, "phrase": "popular_technique"}, {"score": 0.0043713857434347254, "phrase": "combinatorial_search_and_optimization_problems"}, {"score": 0.0038924989779389424, "phrase": "nonuniform_data_dependencies"}, {"score": 0.0031922210879462513, "phrase": "fine_grain_parallelism"}, {"score": 0.0030267296900520217, "phrase": "latency-tolerant_model"}, {"score": 0.0029830992938695007, "phrase": "percolation_technique"}, {"score": 0.002869793011316547, "phrase": "algorithmic_level"}, {"score": 0.0027474453262607834, "phrase": "specific_data_dependence_transformation"}, {"score": 0.0027209713296448296, "phrase": "npdp._next"}, {"score": 0.0026175952455594277, "phrase": "computation_operators"}, {"score": 0.002542642270762272, "phrase": "memory_hierarchy"}, {"score": 0.0025059724686541263, "phrase": "just-in-time_locality"}, {"score": 0.0024224481033945943, "phrase": "execution_time"}, {"score": 0.0023644936731468252, "phrase": "analytical_performance_model"}, {"score": 0.0023303871145705954, "phrase": "parallel_algorithm"}, {"score": 0.0022094759531152072, "phrase": "portable_performance"}, {"score": 0.002115232559299828, "phrase": "intel"}, {"score": 0.0021049977753042253, "phrase": "clovertown"}], "paper_keywords": ["Dynamic programming", " memory hierarchy", " latency tolerant", " percolation", " multicore"], "paper_abstract": "Dynamic programming (DP) is a popular technique which is used to solve combinatorial search and optimization problems. This paper focuses on one type of DP, which is called nonserial polyadic dynamic programming (NPDP). Owing to the nonuniform data dependencies of NPDP, it is difficult to exploit either parallelism or locality. Worse still, the emerging multi/many-core architectures with small on-chip memory make these issues more challenging. In this paper, we address the challenges of exploiting the fine grain parallelism and locality of NPDP on multicore architectures. We describe a latency-tolerant model and a percolation technique for programming on multicore architectures. On an algorithmic level, both parallelism and locality do benefit from a specific data dependence transformation of NPDP. Next, we propose a parallel pipelining algorithm by decomposing computation operators and percolating data through a memory hierarchy to create just-in-time locality. In order to predict the execution time, we formulate an analytical performance model of the parallel algorithm. The parallel pipelining algorithm achieves not only high scalability on the 160-core IBM Cyclops64, but portable performance as well, across the 8-core Sun Niagara and quad-cores Intel Clovertown.", "paper_title": "Improving Performance of Dynamic Programming via Parallelism and Locality on Multicore Architectures", "paper_id": "WOS:000261892000011"}