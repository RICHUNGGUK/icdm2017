{"auto_keywords": [{"score": 0.04286943736618536, "phrase": "potential_variables"}, {"score": 0.040596147832638006, "phrase": "classical_variables"}, {"score": 0.00481495049065317, "phrase": "conditional_constraint_specification_problems"}, {"score": 0.004724980378009193, "phrase": "product_configuration"}, {"score": 0.004671803485255806, "phrase": "major_industrial_application_domain"}, {"score": 0.00463668357590034, "phrase": "constraint_satisfaction_techniques"}, {"score": 0.0046018264570209765, "phrase": "conditional_constraint_satisfaction_problems"}, {"score": 0.0045158206186680224, "phrase": "feature_models"}, {"score": 0.004365022891478405, "phrase": "configuration_problems"}, {"score": 0.004315879542755464, "phrase": "natural_way"}, {"score": 0.0042351951710402425, "phrase": "constraint_satisfaction_problems"}, {"score": 0.0036830211726031946, "phrase": "ccsps_model"}, {"score": 0.003226899588787952, "phrase": "acyclic_graphs"}, {"score": 0.0031308163228919773, "phrase": "fms_model"}, {"score": 0.00307221807606505, "phrase": "cell_phone"}, {"score": 0.00302612773666719, "phrase": "utility_functions"}, {"score": 0.002837811982066224, "phrase": "java_support"}, {"score": 0.0027846824619356583, "phrase": "existing_techniques"}, {"score": 0.002763709443278514, "phrase": "formal_methods"}, {"score": 0.0027325449069867222, "phrase": "set_programming"}, {"score": 0.0026611838252683486, "phrase": "ccsps"}, {"score": 0.0026411545993340743, "phrase": "fms"}, {"score": 0.002476721068743341, "phrase": "model_builder"}, {"score": 0.0024120254489878585, "phrase": "ccsp"}, {"score": 0.002366847878952636, "phrase": "classic_csp"}, {"score": 0.0022876463319883634, "phrase": "\"does_not_exist\"_value"}, {"score": 0.0021049977753042253, "phrase": "model_flaws"}], "paper_keywords": ["Alloy", " Answer-Set Programming", " Configuration", " Constraint Satisfaction", " Flaw Detection"], "paper_abstract": "Product configuration is a major industrial application domain for constraint satisfaction techniques. Conditional constraint satisfaction problems (CCSPs) and feature models (FMs) have been developed to represent configuration problems in a natural way. CCSPs are like constraint satisfaction problems (CSPs), but they also include potential variables, which might or might not exist in any given solution, as well as classical variables, which are required to take a value in every solution. CCSPs model, for example, options on a car, for which the style of sunroof (a variable) only makes sense if the car has a sunroof at all. FMs are directed acyclic graphs of features with constraints on edges. FMs model, for example, cell phone features, where utility functions are required, but the particular utility function \"games\" is optional, but requires Java support. We show that existing techniques from formal methods and answer set programming can be used to naturally model CCSPs and FMs. We demonstrate configurators in both approaches. An advantage of these approaches is that the model builder does not have to reformulate the CCSP or FM into a classic CSP, converting potential variables into classical variables by adding a \"does not exist\" value and modifying the problem constraints. Our configurators automatically reason about the model itself, enumerating all solutions and discovering several kinds of model flaws.", "paper_title": "Reasoning about conditional constraint specification problems and feature models", "paper_id": "WOS:000290077300005"}