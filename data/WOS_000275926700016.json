{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "severe_concurrency_bugs"}, {"score": 0.004766877640444116, "phrase": "effect-oriented_approach"}, {"score": 0.004672160300006692, "phrase": "concurrent_programs"}, {"score": 0.004503350877279651, "phrase": "reliable_concurrent_programs"}, {"score": 0.0044286400018187354, "phrase": "huge_and_non-deterministic_interleaving_space"}, {"score": 0.0042543303585113965, "phrase": "interleaving_space"}, {"score": 0.004225950334493496, "phrase": "critical_concurrency_bugs"}, {"score": 0.004169754607580288, "phrase": "production_runs"}, {"score": 0.00400559360117678, "phrase": "best_use"}, {"score": 0.0039655692352351625, "phrase": "limited_resources"}, {"score": 0.003899745240916238, "phrase": "software_release"}, {"score": 0.003822191555851545, "phrase": "previous_work"}, {"score": 0.0037336520904376687, "phrase": "specific_interleavings"}, {"score": 0.0035865983700531278, "phrase": "paper_targets"}, {"score": 0.0034917831997090328, "phrase": "severe_effects"}, {"score": 0.003399466007862412, "phrase": "error-propagation_process"}, {"score": 0.003376769321692139, "phrase": "real-world_concurrency_bugs"}, {"score": 0.0032005497177523025, "phrase": "program_crashes"}, {"score": 0.0030847461428168614, "phrase": "buggy_interleavings"}, {"score": 0.003053894781246847, "phrase": "memory_bugs"}, {"score": 0.0028463798740405665, "phrase": "shared_memory_objects"}, {"score": 0.0027341763737751467, "phrase": "program_execution"}, {"score": 0.0027068216332674895, "phrase": "memory_accesses"}, {"score": 0.0026352026958982367, "phrase": "common_and_severe_concurrency-memory_bugs"}, {"score": 0.002582731586309754, "phrase": "validator_conmem-v"}, {"score": 0.002548331088496964, "phrase": "false_positives"}, {"score": 0.002522830979240594, "phrase": "potential_bug-triggering_interleavings"}, {"score": 0.0024396547357855777, "phrase": "conmem"}, {"score": 0.0023356021521252495, "phrase": "lock-set-based_race_detector"}, {"score": 0.0022284920601703595, "phrase": "false_positive_rate"}, {"score": 0.0021987994275190314, "phrase": "compared_tools"}, {"score": 0.002184101477091303, "phrase": "conmem-v"}, {"score": 0.0021262835396323623, "phrase": "reasonable_overhead"}, {"score": 0.0021049977753042253, "phrase": "development_usage"}], "paper_keywords": ["Languages", " Reliability", " Software testing", " concurrency bugs"], "paper_abstract": "Multicore technology is making concurrent programs increasingly pervasive. Unfortunately, it is difficult to deliver reliable concurrent programs, because of the huge and non-deterministic interleaving space. In reality, without the resources to thoroughly check the interleaving space, critical concurrency bugs can slip into production runs and cause failures in the field. Approaches to making the best use of the limited resources and exposing severe concurrency bugs before software release would be desirable. Unlike previous work that focuses on bugs caused by specific interleavings (e.g., races and atomicity-violations), this paper targets concurrency bugs that result in one type of severe effects: program crashes. Our study of the error-propagation process of real-world concurrency bugs reveals a common pattern (50% in our non-deadlock concurrency bug set) that is highly correlated with program crashes. We call this pattern concurrency-memory bugs: buggy interleavings directly cause memory bugs (NULL-pointer-dereference, dangling-pointer, buffer-overflow, uninitialized-read) on shared memory objects. Guided by this study, we built ConMem to monitor program execution, analyze memory accesses and synchronizations, and predicatively detect these common and severe concurrency-memory bugs. We also built a validator ConMem-v to automatically prune false positives by enforcing potential bug-triggering interleavings. We evaluated ConMem using 7 open-source programs with 9 real-world severe concurrency bugs. ConMem detects more tested bugs (8 out of 9 bugs) than a lock-set-based race detector and an unserializable-interleaving detector that detect 4 and 5 bugs respectively, with a false positive rate about one tenth of the compared tools. ConMem-v further prunes out all the false positives. ConMem has reasonable overhead suitable for development usage.", "paper_title": "ConMem: Detecting Severe Concurrency Bugs through an Effect-Oriented Approach", "paper_id": "WOS:000275926700016"}