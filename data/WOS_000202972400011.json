{"auto_keywords": [{"score": 0.042599325952589605, "phrase": "static_semantics"}, {"score": 0.00481495049065317, "phrase": "syntax_objects"}, {"score": 0.004605748839642513, "phrase": "s-expression_based_syntax-extension_framework"}, {"score": 0.004289686492089576, "phrase": "key_additional_facility"}, {"score": 0.0039248128268720645, "phrase": "type_systems"}, {"score": 0.0038556354709511818, "phrase": "program_analysis"}, {"score": 0.0032852337992126564, "phrase": "language_levels"}, {"score": 0.0027495914857929584, "phrase": "improved_reasoning_power"}, {"score": 0.0024490834773668153, "phrase": "language_level"}, {"score": 0.002220551141101661, "phrase": "assembly_language"}, {"score": 0.0021049977753042253, "phrase": "static_analyses"}], "paper_keywords": ["extensible programming languages", " domain-specific languages", " macros", " language towers", " static analysis", " type inference", " flow analysis", " lazy delegation"], "paper_abstract": "We describe an s-expression based syntax-extension framework much like Scheme macros, with a key additional facility: the ability to define static semantics, such as type systems or program analysis, for the new, user-defined forms or embedded languages, thus allowing us to construct \"towers\" of language levels. In addition, the static semantics of the languages at two adjacent levels in the tower can be connected, allowing improved reasoning power at a higher ( and perhaps more restricted) level to be reflected down to the static semantics of the language level below. We demonstrate our system by designing macros for an assembly language, together with some example static analyses ( termination analysis, type inference and control-flow analysis).", "paper_title": "Static analysis for syntax objects", "paper_id": "WOS:000202972400011"}