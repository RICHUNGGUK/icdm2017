{"auto_keywords": [{"score": 0.04565234764693532, "phrase": "sophisticated_locking_schemes"}, {"score": 0.015594896635038083, "phrase": "fine-grained_locking"}, {"score": 0.00481495049065317, "phrase": "fine-grained_concurrency_control"}, {"score": 0.004550783060775205, "phrase": "today's_concurrency_primitives"}, {"score": 0.00445997627516653, "phrase": "race_conditions"}, {"score": 0.004249332848326785, "phrase": "new_approach"}, {"score": 0.00421520166010848, "phrase": "concurrency_control"}, {"score": 0.004032302251481604, "phrase": "static_checks"}, {"score": 0.0038263136898042285, "phrase": "partial_interface"}, {"score": 0.003515479934694842, "phrase": "incompatibility_declaration"}, {"score": 0.003282383509542342, "phrase": "view_annotations"}, {"score": 0.0031271827534050493, "phrase": "simple_static_checks"}, {"score": 0.0030278017562213265, "phrase": "basic_approach"}, {"score": 0.0029913511336659327, "phrase": "inference_algorithm"}, {"score": 0.0029434299787644445, "phrase": "view_incompatibility_specifications"}, {"score": 0.0027816546451972725, "phrase": "vuze"}, {"score": 0.0027150658583211746, "phrase": "mailpuccino"}, {"score": 0.0025554669315362424, "phrase": "tuplesoup"}, {"score": 0.0023287359930308864, "phrase": "concurrency_bugs"}, {"score": 0.00224558083320154, "phrase": "view_implementation"}, {"score": 0.002218526133566788, "phrase": "red-black_tree"}, {"score": 0.0021049977753042253, "phrase": "lock-based_implementation"}], "paper_keywords": ["Languages", " Design", " Reliability", " concurrency", " language design", " static verification"], "paper_abstract": "Fine-grained locking is often necessary to increase concurrency. Correctly implementing fine-grained locking with today's concurrency primitives can be challenging-race conditions often plague programs with sophisticated locking schemes. We present views, a new approach to concurrency control. Views ease the task of implementing sophisticated locking schemes and provide static checks to automatically detect many data races. A view of an object declares a partial interface, consisting of fields and methods, to the object that the view protects. A view also contains an incompatibility declaration, which lists views that may not be simultaneously held by other threads. A set of view annotations specify which code regions hold a view of an object. Our view compiler performs simple static checks that identify many data races. We pair the basic approach with an inference algorithm that can infer view incompatibility specifications for many applications. We have ported four benchmark applications to use views: portions of Vuze, a BitTorrent client; Mailpuccino, a graphical email client; jphonelite, a VoIP softphone implementation; and TupleSoup, a database. Our experience indicates that views are easy to use, make implementing sophisticated locking schemes simple, and can help eliminate concurrency bugs. We have evaluated the performance of a view implementation of a red-black tree and found that views can significantly improve performance over that of the lock-based implementation.", "paper_title": "Views: Synthesizing Fine-Grained Concurrency Control", "paper_id": "WOS:000330483700004"}