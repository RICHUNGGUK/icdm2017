{"auto_keywords": [{"score": 0.04555525338591093, "phrase": "constant_fraction"}, {"score": 0.0298971785416569, "phrase": "adversarial_error"}, {"score": 0.015719716506582538, "phrase": "interactive_coding"}, {"score": 0.009503875298367966, "phrase": "failure_probability"}, {"score": 0.004791189907641631, "phrase": "adversarial_noise"}, {"score": 0.004639565230823192, "phrase": "interactive_protocol_pi"}, {"score": 0.004582528208024817, "phrase": "communication_channel"}, {"score": 0.0041815958876974665, "phrase": "error-free_channel"}, {"score": 0.0040996103024637295, "phrase": "single_long_message"}, {"score": 0.004059219816495496, "phrase": "good_error"}, {"score": 0.0038631357705923124, "phrase": "interactive_protocols"}, {"score": 0.003649277504586372, "phrase": "protocol_pi"}, {"score": 0.0034901729647741353, "phrase": "constant_rate_adversarial_channel_errors"}, {"score": 0.0033879628186273625, "phrase": "schulman's_simulator"}, {"score": 0.0032402142645120958, "phrase": "communication_complexity"}, {"score": 0.002504011301105577, "phrase": "computational_complexity"}, {"score": 0.0024731627211475823, "phrase": "ram_model"}, {"score": 0.0024487570422601058, "phrase": "first_two_simulators"}, {"score": 0.002376972143189719, "phrase": "random_string"}, {"score": 0.0022120408738490437, "phrase": "equivalent_performance"}], "paper_keywords": ["Design", " Algorithms", " Theory", " Interactive coding"], "paper_abstract": "Consider two parties who wish to communicate in order to execute some interactive protocol pi. However, the communication channel between them is noisy: An adversary sees everything that is transmitted over the channel and can change a constant fraction of the bits arbitrarily, thus interrupting the execution of (which was designed for an error-free channel). If pi only contains a single long message, then a good error correcting code would overcome the noise with only a constant overhead in communication. However, this solution is not applicable to interactive protocols consisting of many short messages. Schulman [1992, 1993] introduced the notion of interactive coding: A simulator that, given any protocol pi, is able to simulate it (i.e., produce its intended transcript) even in the presence of constant rate adversarial channel errors, and with only constant (multiplicative) communication overhead. However, the running time of Schulman's simulator, and of all simulators that followed, has been exponential (or subexponential) in the communication complexity of pi (which we denote by N). In this work, we present three efficient simulators, all of which are randomized and have a certain failure probability (over the choice of coins). The first runs in time poly(N), has failure probability roughly 2(-N), and is resilient to 1/32-fraction of adversarial error. The second runs in time 0(N log N), has failure probability roughly 2-N, and is resilient to some constant fraction of adversarial error. The third runs in time 0(N), has failure probability 1/poly(N), and is resilient to some constant fraction of adversarial error. (Computational complexity is measured in the RAM model.) The first two simulators can be made deterministic if they are a priori given a random string (which may be known to the adversary ahead of time). In particular, the simulators can be made to be nonuniform and deterministic (with equivalent performance). Categories and Subject Descriptors: E.4 [Coding and Information Theory]: Error control codes; F.2 [Analysis of Algorithms and Problem Complexity]", "paper_title": "Fast Interactive Coding against Adversarial Noise", "paper_id": "WOS:000347051200003"}