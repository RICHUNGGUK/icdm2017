{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "quantum_adiabatic_algorithm"}, {"score": 0.03981719821100098, "phrase": "poor_choices"}, {"score": 0.004490842671590769, "phrase": "hamiltonian_based_quantum_algorithm"}, {"score": 0.0041469500929423595, "phrase": "classical_cost_function"}, {"score": 0.003685373198827389, "phrase": "hamiltonian"}, {"score": 0.0032324864013225166, "phrase": "run_time"}, {"score": 0.003075296862372287, "phrase": "root_n."}, {"score": 0.0027284410545226306, "phrase": "cost_function"}, {"score": 0.0023727863021828547, "phrase": "grover_speedup"}, {"score": 0.0021049977753042253, "phrase": "quantum_adiabatic_algorithms"}], "paper_keywords": ["adiabatic", " quantum", " bounds"], "paper_abstract": "The quantum adiabatic algorithm is a Hamiltonian based quantum algorithm designed to find the minimum of a classical cost function whose domain has size N. We show that poor choices for the Hamiltonian can guarantee that the algorithm will not find the minimum if the run time grows more slowly than root N. These poor choices are nonlocal and wash out any structure in the cost function to be minimized, and the best that can be hoped for is Grover speedup. These failures tell us what not to do when designing quantum adiabatic algorithms.", "paper_title": "How to make the quantum adiabatic algorithm fail", "paper_id": "WOS:000257540500009"}