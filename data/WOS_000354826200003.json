{"auto_keywords": [{"score": 0.03777349805062935, "phrase": "inter-procedural_path-sensitive_analyses"}, {"score": 0.03128898671324496, "phrase": "partial_orders"}, {"score": 0.00481495049065317, "phrase": "type-based_partial-order_constraints"}, {"score": 0.004561019117546361, "phrase": "path-sensitive_program_analyses"}, {"score": 0.004359625030298944, "phrase": "program_paths"}, {"score": 0.004281568920264999, "phrase": "path_feasibility"}, {"score": 0.00418595288276353, "phrase": "conjoined_branch_conditions"}, {"score": 0.004037370832877034, "phrase": "decision_procedures"}, {"score": 0.003947186611084043, "phrase": "satisfiability_modulo_theory"}, {"score": 0.0038070472635126276, "phrase": "efficient_underlying_decision_procedures"}, {"score": 0.003638823482920949, "phrase": "branch_conditions"}, {"score": 0.003369669078274226, "phrase": "object's_dynamic_type"}, {"score": 0.0032794890195334513, "phrase": "explicit_type_tests"}, {"score": 0.0031917146566068245, "phrase": "dynamic_dispatch"}, {"score": 0.0031629800646754505, "phrase": "type_casting"}, {"score": 0.0030783143919343972, "phrase": "common_form"}, {"score": 0.0028634235895823594, "phrase": "type-based_partial_orders"}, {"score": 0.0027993885490232677, "phrase": "state-of-the-art_smt_solvers"}, {"score": 0.002627587221594597, "phrase": "tpo_constraints"}, {"score": 0.0025572160146590623, "phrase": "significantly_better_performance"}, {"score": 0.0024442185960277508, "phrase": "java"}, {"score": 0.002400241288973103, "phrase": "custom_procedures"}, {"score": 0.0021925226977381244, "phrase": "portfolio_approach"}, {"score": 0.0021049977753042253, "phrase": "program_analyses"}], "paper_keywords": ["Algorithms", " Experimentation", " Verification", " SMT", " decision procedure", " type hierarchy", " subtyping", " path-sensitive analysis"], "paper_abstract": "The precision and scalability of path-sensitive program analyses depend on their ability to distinguish feasible and infeasible program paths. Analyses express path feasibility as the satisfiability of conjoined branch conditions, which is then decided by cooperating decision procedures such as those in satisfiability modulo theory (SMT) solvers. Consequently, efficient underlying decision procedures are key to precise, scalable program analyses. When we investigate the branch conditions accumulated by inter-procedural path-sensitive analyses of object-oriented programs, we find that many relate to an object's dynamic type. These conditions arise from explicit type tests and the branching implicit in dynamic dispatch and type casting. These conditions share a common form that comprises a fragment of the theory of partial orders, which we refer to as type-based partial orders (TPO). State-of-the-art SMT solvers can heuristically instantiate the quantified formulae that axiomatize partial orders, and thereby support TPO constraints. We present two custom decision procedures with significantly better performance. On benchmarks that reflect inter-procedural path-sensitive analyses applied to significant Java systems, the custom procedures run three orders of magnitude faster. The performance of the two decision procedures varies across benchmarks, which suggests that a portfolio approach may be beneficial for solving constraints generated by program analyses.", "paper_title": "Deciding Type-Based Partial-Order Constraints for Path-Sensitive Analysis", "paper_id": "WOS:000354826200003"}