{"auto_keywords": [{"score": 0.04118498548932341, "phrase": "utp"}, {"score": 0.015719709579057044, "phrase": "unifying_theory"}, {"score": 0.00409895142748329, "phrase": "unifying_theories"}, {"score": 0.0036422425344358037, "phrase": "alphabetised_relational_calculus"}, {"score": 0.003378385493203297, "phrase": "different_programming_paradigms"}, {"score": 0.002969628818856786, "phrase": "verification_framework"}, {"score": 0.0027543636132088332, "phrase": "formal_semantics"}, {"score": 0.00266693888510356, "phrase": "imperative_programming_language"}, {"score": 0.002447101794397243, "phrase": "deep_embedding"}, {"score": 0.0023189818169615135, "phrase": "z._we_use_proofpowerz"}, {"score": 0.0021049977753042253, "phrase": "mechanised_support"}], "paper_keywords": [""], "paper_abstract": "In this paper, we present a formalisation of a subset of the unifying theories of programming (UTP). In UTP, the alphabetised relational calculus is used to describe and relate different programming paradigms, including functional, imperative, logic, and parallel programming. We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z. We use ProofpowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.", "paper_title": "Mechanising a unifying theory", "paper_id": "WOS:000239422200013"}