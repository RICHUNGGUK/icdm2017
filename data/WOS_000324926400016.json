{"auto_keywords": [{"score": 0.03923307184680597, "phrase": "lup"}, {"score": 0.031428469928266346, "phrase": "input_structure"}, {"score": 0.00481495049065317, "phrase": "inductive_definitions"}, {"score": 0.00475413908468027, "phrase": "tabled_prolog_rules"}, {"score": 0.00454725669814484, "phrase": "first-order_logic"}, {"score": 0.004159997145421619, "phrase": "first_grounds"}, {"score": 0.00378145978325955, "phrase": "lifted_unit_propagation"}, {"score": 0.003503497128638099, "phrase": "problem_specifications"}, {"score": 0.002821685815956478, "phrase": "preprocessing_step"}, {"score": 0.0026986685585382347, "phrase": "prolog_code"}, {"score": 0.0026475981474045414, "phrase": "xsb_prolog"}, {"score": 0.0021731423856364003, "phrase": "experimental_results"}], "paper_keywords": ["program transformation", " FO(.)", " logic programming", " tabling", " knowledge base systems", " IDP system", " declarative modeling"], "paper_abstract": "FO(.)(IDP3) extends first-order logic with inductive definitions, partial functions, types and aggregates. Its model generator IDP3 first grounds the theory and then uses search to find the models. The grounder uses Lifted Unit Propagation (LUP) to reduce the size of the groundings of problem specifications in IDP3. LUP is in general very effective, but performs poorly on definitions of predicates whose two-valued interpretation can be computed from data in the input structure. To solve this problem, a preprocessing step is introduced that converts such definitions to Prolog code and uses XSB Prolog to compute their interpretation. The interpretation of these predicates is then added to the input structure, their definitions are removed from the theory and further processing is done by the standard IDP3 system. Experimental results show the effectiveness of our method.", "paper_title": "Compiling Input* FO(.) inductive definitions into tabled prolog rules for IDP3", "paper_id": "WOS:000324926400016"}