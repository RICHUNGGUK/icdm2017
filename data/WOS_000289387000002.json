{"auto_keywords": [{"score": 0.04327832021381773, "phrase": "resulting_code"}, {"score": 0.03062023849585726, "phrase": "generated_code"}, {"score": 0.00481495049065317, "phrase": "generic_code"}, {"score": 0.00470341117804131, "phrase": "multi-stage_programming"}, {"score": 0.004594443767709888, "phrase": "ocaml's_advanced_module_system"}, {"score": 0.004332894955218135, "phrase": "generic_programs"}, {"score": 0.003968112038249246, "phrase": "gaussian_elimination"}, {"score": 0.0038989120088094185, "phrase": "representative_family"}, {"score": 0.0038534477978822133, "phrase": "symbolic_and_numeric_algorithms"}, {"score": 0.003698442219929622, "phrase": "great_extent"}, {"score": 0.0035496495489801667, "phrase": "permutation_matrix_representations"}, {"score": 0.0033473779327638322, "phrase": "result_types"}, {"score": 0.003212663446866797, "phrase": "run-time_cost"}, {"score": 0.0029592333031063156, "phrase": "metaocaml"}, {"score": 0.002232364384065567, "phrase": "domain-specific_knowledge"}, {"score": 0.002193367454830741, "phrase": "\"clearly_wrong\"_compositions"}, {"score": 0.0021049977753042253, "phrase": "generation_time"}], "paper_keywords": ["MetaOCaml", " Linear algebra", " Genericity", " Generative", " Staging", " Functor", " Symbolic"], "paper_abstract": "We use multi-stage programming, monads and Ocaml's advanced module system to demonstrate how to eliminate all abstraction overhead from generic programs, while avoiding any inspection of the resulting code. We demonstrate this clearly with Gaussian Elimination as a representative family of symbolic and numeric algorithms. We parameterize our code to a great extent - over domain, input and permutation matrix representations, determinant and rank tracking, pivoting policies, result types, etc. - at no run-time cost. Because the resulting code is generated just right and not changed afterward, MetaOCaml guarantees that the generated code is well-typed. We further demonstrate that various abstraction parameters (aspects) can be made orthogonal and compositional, even in the presence of name-generation for temporaries, and \"interleaving\" of aspects. We also show how to encode some domain-specific knowledge so that \"clearly wrong\" compositions can be rejected at or before generation time, rather than during the compilation or running of the generated code. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Multi-stage programming with functors and monads: Eliminating abstraction overhead from generic code", "paper_id": "WOS:000289387000002"}