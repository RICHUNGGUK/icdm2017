{"auto_keywords": [{"score": 0.03794103686733496, "phrase": "helper"}, {"score": 0.01757781242429022, "phrase": "parallel_regions"}, {"score": 0.010612346608027973, "phrase": "helper_locks"}, {"score": 0.009933818095769386, "phrase": "helper_lock"}, {"score": 0.009708021492547021, "phrase": "parallel_region"}, {"score": 0.0047872135686404275, "phrase": "fork-join_parallel_programming"}, {"score": 0.004339293854115301, "phrase": "processor_p"}, {"score": 0.003832092687255493, "phrase": "a._additional_processors"}, {"score": 0.0037228709592978556, "phrase": "a._the_helper"}, {"score": 0.0037121208432871118, "phrase": "runtime_system"}, {"score": 0.003680055701720573, "phrase": "fork-join_computations"}, {"score": 0.003575151757072538, "phrase": "unbounded_nesting"}, {"score": 0.003513645211548667, "phrase": "theoretical_completion-time"}, {"score": 0.0034933782525914682, "phrase": "space-usage_bounds"}, {"score": 0.002886110744751351, "phrase": "expected_time"}, {"score": 0.0027634902834910184, "phrase": "p_processors"}, {"score": 0.0026924262536607915, "phrase": "small_number"}, {"score": 0.0026768834201668806, "phrase": "highly_parallel_critical_sections"}, {"score": 0.00265373679629359, "phrase": "linear_speedup"}, {"score": 0.0023228223366301226, "phrase": "stack_space"}, {"score": 0.002276210060619432, "phrase": "serial_execution"}, {"score": 0.0021794454466797382, "phrase": "multithreaded_runtime_system"}, {"score": 0.00212336833618933, "phrase": "concurrent_hash_table"}, {"score": 0.0021049977753042253, "phrase": "resize_operation"}], "paper_keywords": ["Algorithms", " Performance", " Theory", " Cilk", " fork-join multithreading", " helper lock", " nested parallelism", " parallel region", " scheduling", " work stealing"], "paper_abstract": "Helper locks allow programs with large parallel critical sections, called parallel regions, to execute more efficiently by enlisting processors that might otherwise be waiting on the helper lock to aid in the execution of the parallel region. Suppose that a processor p is executing a parallel region A after having acquired the lock L protecting A. If another processor p' tries to acquire L, then instead of blocking and waiting for p to complete A, processor p' joins p to help it complete A. Additional processors not blocked on L may also help to execute A. The HELPER runtime system can execute fork-join computations augmented with helper locks and parallel regions. HELPER supports the unbounded nesting of parallel regions. We provide theoretical completion-time and space-usage bounds for a design of HELPER based on work stealing. Specifically, let V be the number of parallel regions in a computation, let T(1) be its work, and let (T) over tilde (infinity) be its \"aggregate span\" - the sum of the spans (critical-path lengths) of all its parallel regions. We prove that HELPER completes the computation in expected time O(T(1)/P + (T) over tilde (infinity) + PV) on P processors. This bound indicates that programs with a small number of highly parallel critical sections can attain linear speedup. For the space bound, we prove that HELPER completes a program using only O(P (S) over tilde (1)) stack space, where e (S) over tilde (1) is the sum, over all regions, of the stack space used by each region in a serial execution. Finally, we describe a prototype of HELPER implemented by modifying the Cilk multithreaded runtime system. We used this prototype to implement a concurrent hash table with a resize operation protected by a helper lock.", "paper_title": "Helper Locks for Fork-Join Parallel Programming", "paper_id": "WOS:000280548100023"}