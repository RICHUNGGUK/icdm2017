{"auto_keywords": [{"score": 0.04346898089428129, "phrase": "race_conditions"}, {"score": 0.006769736604580767, "phrase": "concurrent_programs"}, {"score": 0.00481495049065317, "phrase": "finding_race_conditions"}, {"score": 0.0047507045987179855, "phrase": "erlang"}, {"score": 0.004624751696958501, "phrase": "pulse."}, {"score": 0.004382737590042589, "phrase": "debugging_concurrent"}, {"score": 0.004295269532032448, "phrase": "erlang_applications"}, {"score": 0.00407042677958844, "phrase": "common_class"}, {"score": 0.0037549546301384336, "phrase": "traditional_unit_testing"}, {"score": 0.0031738126998349775, "phrase": "system_testing"}, {"score": 0.0030482430937467013, "phrase": "vast_amount"}, {"score": 0.002628747519488797, "phrase": "quickcheck"}, {"score": 0.002593784705750412, "phrase": "pulse"}, {"score": 0.002297585503415527, "phrase": "unit_testing"}, {"score": 0.0021049977753042253, "phrase": "industrial_concurrent_case_study"}], "paper_keywords": ["Verification", " QuickCheck", " Race Conditions", " Erlang"], "paper_abstract": "We address the problem of testing and debugging concurrent, distributed Erlang applications. In concurrent programs, race conditions are a common class of bugs and are very hard to find in practice. Traditional unit testing is normally unable to help finding all race conditions, because their occurrence depends so much on timing. Therefore, race conditions are often found during system testing, where due to the vast amount of code under test, it is often hard to diagnose the error resulting from race conditions. We present three tools (QuickCheck, PULSE, and a visualizer) that in combination can be used to test and debug concurrent programs in unit testing with a much better possibility of detecting race conditions. We evaluate our method on an industrial concurrent case study and illustrate how we find and analyze the race conditions.", "paper_title": "Finding Race Conditions in Erlang with QuickCheck and PULSE", "paper_id": "WOS:000271211700017"}