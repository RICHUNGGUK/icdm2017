{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "singly_linked_lists"}, {"score": 0.004536592536813498, "phrase": "time_overhead"}, {"score": 0.00443638953122199, "phrase": "two-way_movement"}, {"score": 0.004338390136272005, "phrase": "singly_linked_list"}, {"score": 0.003737934295442975, "phrase": "finite_number"}, {"score": 0.0031963987773420068, "phrase": "intuitive_feeling"}, {"score": 0.002944715025443487, "phrase": "efficiency_gap"}, {"score": 0.0028795712616923462, "phrase": "read-only_situation"}, {"score": 0.0024620842899061614, "phrase": "desired_value"}, {"score": 0.0023719332915829268, "phrase": "tight_tradeoffs"}, {"score": 0.002285075675790214, "phrase": "amortized_and_worst-case_settings"}, {"score": 0.0021049977753042253, "phrase": "singly-linked_input"}], "paper_keywords": ["algorithms", " theory", " incompressibility", " string matching", " two way automata"], "paper_abstract": "We show how to reduce the time overhead for implementing two-way movement on a singly linked list to O(n(epsilon)) per operation without modifying the list and without making use of storage other than a finite number of pointers into the list. We also prove a matching lower bound. These results add precision to the intuitive feeling that doubly linked lists are more efficient than singly linked lists, and quantify the efficiency gap in a read-only situation. We further analyze the number of points of access into the list (pointers) necessary for obtaining a desired value of c. We obtain tight tradeoffs which also separate the amortized and worst-case settings. Our upper bound implies that read-only programs with singly-linked input can do string matching much faster than previously expected.", "paper_title": "Backing up in singly linked lists", "paper_id": "WOS:000241211400004"}