{"auto_keywords": [{"score": 0.043509087233037196, "phrase": "previous_solutions"}, {"score": 0.03435134115120626, "phrase": "run-length_encoding"}, {"score": 0.00481495049065317, "phrase": "highly_run-length_compressible_texts"}, {"score": 0.004278807087784626, "phrase": "substring_t"}, {"score": 0.0042542311446793725, "phrase": "exactly_x"}, {"score": 0.004039277955304532, "phrase": "pre-processing_step"}, {"score": 0.00392456965725842, "phrase": "constant_time"}, {"score": 0.0038907941451460566, "phrase": "fastest_algorithms"}, {"score": 0.0034077417500035134, "phrase": "rahman"}, {"score": 0.003216804708106142, "phrase": "construction_time"}, {"score": 0.0025761937402886954, "phrase": "worst_case"}, {"score": 0.0025613718456881742, "phrase": "preliminary_investigations"}, {"score": 0.002531982746907987, "phrase": "vertical_bar_l_vertical_bar"}, {"score": 0.002223654214753248, "phrase": "prefix_normal_forms"}, {"score": 0.0021917969986115673, "phrase": "fici"}, {"score": 0.0021791815390109744, "phrase": "liptak"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["String algorithms", " Data structures", " Jumbled pattern matching", " Parikh vectors", " Prefix normal form", " Run-length encoding"], "paper_abstract": "The Binary Jumbled String Matching Problem is defined as follows: Given a string s over {a, b} of length n and a query (x, y), with x, y non-negative integers, decide whether s has a substring t with exactly x a's and y b's. Previous solutions created an index of size O(n) in a pre-processing step, which was then used to answer queries in constant time. The fastest algorithms for construction of this index have running time O(n(2)/logn) (Burcsi et al., 2010 [1]; Moosa and Rahman, 2010 [7]), or O(n(2)/log(2) n) in the word-RAM model (Moosa and Rahman, 2012 [8]). We propose an index constructed directly from the run-length encoding of s. The construction time of our index is O(n + rho(2) log rho), where O(n) is the time for computing the run-length encoding of s and rho is the length of this encoding-this is no worse than previous solutions if rho = O(n/logn) and better if rho = O(n/ logn). Our index L can be queried in O(log rho) time. While vertical bar L vertical bar = O(min(n, rho(2))) in the worst case, preliminary investigations have indicated that vertical bar L vertical bar may often be close to rho. Furthermore, the algorithm for constructing the index is conceptually simple and easy to implement. In an attempt to shed light on the structure and size of our index, we characterize it in terms of the prefix normal forms of s introduced in Fici and Liptak (2011) [6]. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Binary jumbled string matching for highly run-length compressible texts", "paper_id": "WOS:000322295500003"}