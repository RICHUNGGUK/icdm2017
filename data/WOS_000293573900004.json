{"auto_keywords": [{"score": 0.03692674992710848, "phrase": "outlined_loop_nests"}, {"score": 0.02566923055929586, "phrase": "code_variant"}, {"score": 0.00481495049065317, "phrase": "concrete_step"}, {"score": 0.004627944735913613, "phrase": "fully_automatic_end-to-end_tuning_infrastructure"}, {"score": 0.004324031677173549, "phrase": "general-purpose_offline_auto-tuning_framework"}, {"score": 0.003927203683176278, "phrase": "structured_grids"}, {"score": 0.0037959868107895053, "phrase": "proposed_system"}, {"score": 0.0037320255482878365, "phrase": "computationally_intensive_loop_nests"}, {"score": 0.003689982350051231, "phrase": "separate_executable_functions"}, {"score": 0.0032026066791743866, "phrase": "loop_nest"}, {"score": 0.003078028357912228, "phrase": "composable_code_transformations"}, {"score": 0.002958281631770322, "phrase": "unbound_optimization_parameters"}, {"score": 0.002859345731792013, "phrase": "tuning_process"}, {"score": 0.0026864540069792275, "phrase": "search-based_auto-tuner"}, {"score": 0.0026113524778702624, "phrase": "parallel_heuristic_search"}, {"score": 0.0025673005153462707, "phrase": "best-performing_optimized_variants"}, {"score": 0.002305014991156598, "phrase": "original_loop_nest"}, {"score": 0.002253299769886694, "phrase": "full_application"}, {"score": 0.0021049977753042253, "phrase": "application's_performance"}], "paper_keywords": ["Active Harmony", " CHiLL", " offline auto-tuning", " PERI", " ROSE"], "paper_abstract": "In this paper, we take a concrete step towards materializing our long-term goal of providing a fully automatic end-to-end tuning infrastructure for arbitrary program components and full applications. We describe a general-purpose offline auto-tuning framework and apply it to an application benchmark, SMG2000, a semi-coarsening multigrid on structured grids. We show that the proposed system first extracts computationally intensive loop nests into separate executable functions, a code transformation called outlining. The outlined loop nests are then tuned by the framework and subsequently integrated back into the application. Each loop nest is optimized through a series of composable code transformations, with the transformations parameterized by unbound optimization parameters that are bound during the tuning process. The values for these parameters are selected using a search-based auto-tuner, which performs a parallel heuristic search for the best-performing optimized variants of the outlined loop nests. We show that our system pinpoints a code variant that performs 2.37 times faster than the original loop nest. When the full application is run using the code variant found by the system, the application's performance improves by 27%.", "paper_title": "Auto-tuning full applications: A case study", "paper_id": "WOS:000293573900004"}