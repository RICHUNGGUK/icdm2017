{"auto_keywords": [{"score": 0.04458003012492909, "phrase": "skeleton_program"}, {"score": 0.00481495049065317, "phrase": "single_shot"}, {"score": 0.0046993598473345395, "phrase": "skeleton-based_parallel_programming_languages"}, {"score": 0.004161553532799662, "phrase": "parallel_semantics"}, {"score": 0.0035965032173588753, "phrase": "semantic_formalism"}, {"score": 0.0033637374697995616, "phrase": "informal_way"}, {"score": 0.0032828706086018133, "phrase": "functional_and_parallel_semantics"}, {"score": 0.003089080923888397, "phrase": "semantic_tools"}, {"score": 0.0028195727965553367, "phrase": "formal_semantic_framework"}, {"score": 0.002685558057339722, "phrase": "functional_and_parallel_aspects"}, {"score": 0.0026530590435527527, "phrase": "skeleton-based_parallel_programs"}, {"score": 0.002526938673434697, "phrase": "labeled_transition_system"}, {"score": 0.002421499421848063, "phrase": "skeleton_programs"}, {"score": 0.0021968073007043675, "phrase": "java"}, {"score": 0.0021049977753042253, "phrase": "case_study"}], "paper_keywords": ["algorithmical skeletons", " structured parallel programming", " labeled transition systems", " functional semantics", " parallel semantics"], "paper_abstract": "Semantics of skeleton-based parallel programming languages comes usually as two distinct items: a functional semantics, modeling the function computed by the skeleton program, and a parallel semantics describing the ways used to exploit parallelism during the execution of the skeleton program. The former is usually expressed using some kind of semantic formalism, while the latter is almost always given in an informal way. Such a separation of functional and parallel semantics seriously impairs the possibility of programmers to use the semantic tools to prove properties of programs. In this work, we show how a formal semantic framework can be set up that handles both functional and parallel aspects of skeleton-based parallel programs. The framework is based on a labeled transition system. We show how different properties related to skeleton programs can be proved using such a system. We use Lithium, a skeleton-based full Java parallel programming environment, as the case study. (c) 2006 Elsevier Ltd. All rights reserved.", "paper_title": "Skeleton-based parallel programming: Functional and parallel semantics in a single shot", "paper_id": "WOS:000245779000006"}