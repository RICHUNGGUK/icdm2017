{"auto_keywords": [{"score": 0.04546648155091688, "phrase": "nasa"}, {"score": 0.00481495049065317, "phrase": "flight_software_reliability"}, {"score": 0.00437913966678655, "phrase": "mission-critical_flight_software"}, {"score": 0.0043258453436258405, "phrase": "jet_propulsion_laboratory"}, {"score": 0.004169806294929081, "phrase": "higher_level"}, {"score": 0.004068907083697369, "phrase": "standard_software_testing"}, {"score": 0.00399483173553482, "phrase": "current_state"}, {"score": 0.003850686614685676, "phrase": "tight_deadlines"}, {"score": 0.0038271712887391015, "phrase": "resource_limitations"}, {"score": 0.0037921662574137535, "phrase": "flight_project"}, {"score": 0.003689053436223376, "phrase": "rigorous_formal_proof"}, {"score": 0.003644126753595137, "phrase": "even_a_well-specified_stand-alone_module"}, {"score": 0.003334309053314909, "phrase": "practical_alternative"}, {"score": 0.0032836104153151973, "phrase": "traditional_testing"}, {"score": 0.0030601162942933665, "phrase": "model_checking"}, {"score": 0.002895841197640062, "phrase": "static_code_analysis"}, {"score": 0.002799810685137358, "phrase": "file_systems"}, {"score": 0.0026986685585382347, "phrase": "complex_data_structures"}, {"score": 0.0026252106881752067, "phrase": "constraint_solvers"}, {"score": 0.0024842242921857705, "phrase": "model_checking_tool"}, {"score": 0.0023221248824337576, "phrase": "model_checkers"}, {"score": 0.0022938068444116827, "phrase": "non-file-system_flight_software_modules"}, {"score": 0.0022382002476510573, "phrase": "traditional_static_formal_methods"}, {"score": 0.0022041312401435346, "phrase": "formal_approaches"}, {"score": 0.002163930783583212, "phrase": "test_engineers"}, {"score": 0.0021506938783242215, "phrase": "software_developers"}, {"score": 0.0021179540310789446, "phrase": "key_problem_shifts"}, {"score": 0.0021049977753042253, "phrase": "test_generation"}], "paper_keywords": ["File systems", " Testing", " Model checking", " Verification", " Flight software", " Formal proof"], "paper_abstract": "In this paper we discuss the application of a range of techniques to the verification of mission-critical flight software at NASA's Jet Propulsion Laboratory. For this type of application we want to achieve a higher level of confidence than can be achieved through standard software testing. Unfortunately, given the current state of the art, especially when efforts are constrained by the tight deadlines and resource limitations of a flight project, it is not feasible to produce a rigorous formal proof of correctness of even a well-specified stand-alone module such as a file system (much less more tightly coupled or difficult-to-specify modules). This means that we must look for a practical alternative in the area between traditional testing and proof, as we attempt to optimize rigor and coverage. The approaches we describe here are based on testing, model checking, constraint-solving, monitoring, and finite-state machine learning, in addition to static code analysis. The results we have obtained in the domain of file systems are encouraging, and suggest that for more complex properties of programs with complex data structures, it is possibly more beneficial to use constraint solvers to guide and analyze execution (i.e., as in testing, even if performed by a model checking tool) than to translate the program and property into a set of constraints, as in abstraction-based and bounded model checkers. Our experience with non-file-system flight software modules shows that methods even further removed from traditional static formal methods can be assisted by formal approaches, yet readily adopted by test engineers and software developers, even as the key problem shifts from test generation and selection to test evaluation.", "paper_title": "Establishing flight software reliability: testing, model checking, constraint-solving, monitoring and learning", "paper_id": "WOS:000336365800002"}