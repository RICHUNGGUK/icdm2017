{"auto_keywords": [{"score": 0.0435321307553151, "phrase": "input_size"}, {"score": 0.01397857251528385, "phrase": "individual_routines"}, {"score": 0.00481495049065317, "phrase": "input-sensitive_profiling"}, {"score": 0.0046650615456476155, "phrase": "building_block_technique"}, {"score": 0.004573748810476845, "phrase": "automatic_discovery"}, {"score": 0.00453772385360173, "phrase": "workload-dependent_performance_bottlenecks"}, {"score": 0.0036360703245710124, "phrase": "collected_profiles"}, {"score": 0.0035507457285983268, "phrase": "performance_plots"}, {"score": 0.003508834578859094, "phrase": "trend_functions"}, {"score": 0.0034811680446852054, "phrase": "statistical_curve"}, {"score": 0.0034674164050273568, "phrase": "fitting_techniques"}, {"score": 0.0034264854489231148, "phrase": "key_feature"}, {"score": 0.0032034752726003025, "phrase": "generic_code_fragment"}, {"score": 0.0030913302090179967, "phrase": "effective_metric"}, {"score": 0.0027999339042953076, "phrase": "asymptotic_bottlenecks"}, {"score": 0.0026911959223982727, "phrase": "useful_characterizations"}, {"score": 0.002566255769251419, "phrase": "mainstream_applications"}, {"score": 0.002370748155770563, "phrase": "valgrind_tool"}, {"score": 0.0023150468182777813, "phrase": "extensive_experimental_evaluation"}, {"score": 0.0022250978492127163, "phrase": "comparable_performance"}, {"score": 0.002164216680934624, "phrase": "informative_plots"}, {"score": 0.002138636271204459, "phrase": "single_runs"}, {"score": 0.00212175050242788, "phrase": "typical_workloads"}], "paper_keywords": ["Performance profiling", " asymptotic analysis", " dynamic program analysis", " instrumentation"], "paper_abstract": "In this article we present a building block technique and a toolkit towards automatic discovery of workload-dependent performance bottlenecks. From one or more runs of a program, our profiler automatically measures how the performance of individual routines scales as a function of the input size, yielding clues to their growth rate. The output of the profiler is, for each executed routine of the program, a set of tuples that aggregate performance costs by input size. The collected profiles can be used to produce performance plots and derive trend functions by statistical curve fitting techniques. A key feature of our method is the ability to automatically measure the size of the input given to a generic code fragment: to this aim, we propose an effective metric for estimating the input size of a routine and show how to compute it efficiently. We discuss several examples, showing that our approach can reveal asymptotic bottlenecks that other profilers may fail to detect and can provide useful characterizations of the workload and behavior of individual routines in the context of mainstream applications, yielding several code optimizations as well as algorithmic improvements. To prove the feasibility of our techniques, we implemented a Valgrind tool called aprof and performed an extensive experimental evaluation on the SPEC CPU2006 benchmarks. Our experiments show that aprof delivers comparable performance to other prominent Valgrind tools, and can generate informative plots even from single runs on typical workloads for most algorithmically-critical routines.", "paper_title": "Input-Sensitive Profiling", "paper_id": "WOS:000346224400003"}