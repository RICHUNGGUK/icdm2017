{"auto_keywords": [{"score": 0.014659517348392426, "phrase": "parameterized_classes"}, {"score": 0.013670337622192183, "phrase": "template_specialization"}, {"score": 0.004695183699894267, "phrase": "powerful_but_poorly_understood_feature"}, {"score": 0.0038964032225585117, "phrase": "turing-complete_sub-language"}, {"score": 0.0035048567587934254, "phrase": "popular_tool"}, {"score": 0.003452218803245602, "phrase": "program_generators"}, {"score": 0.003282383509542342, "phrase": "natural_language"}, {"score": 0.0031208772639433145, "phrase": "meta-theoretic_properties"}, {"score": 0.002709589081384597, "phrase": "first_formal_account"}, {"score": 0.0025503112711036994, "phrase": "partial_specialization"}, {"score": 0.0024617483174454113, "phrase": "type_safety"}, {"score": 0.0023762535034673017, "phrase": "isabelle_proof_assistant"}, {"score": 0.0021917966722180132, "phrase": "member_instantiation"}, {"score": 0.0021049977753042253, "phrase": "unnecessary_template_specializations"}], "paper_keywords": [""], "paper_abstract": "Templates are a powerful but poorly understood feature of the C++ language. Their syntax resembles the parameterized classes of other languages (e.g., of Java). But because C++ supports template specialization, their semantics is quite different from that of parameterized classes. Template specialization provides a Turing-complete sub-language within C++ that executes at compile-time. Programmers put this power to many uses. For example, templates are a popular tool for writing program generators. The C++ Standard defines the semantics of templates using natural language, so it is prone to misinterpretation. The meta-theoretic properties of C++ templates have not been studied, so the semantics of templates has not been systematically checked for errors. In this paper we present the first formal account of C++ templates including some of the more complex aspects, such as template partial specialization. We validate our semantics by proving type safety and verify the proof with the Isabelle proof assistant. Our formalization reveals two interesting issues in the C++ Standard:, the first is a problem with member instantiation and the second concerns the generation of unnecessary template specializations.", "paper_title": "A semantic analysis of C++ templates", "paper_id": "WOS:000239558900018"}