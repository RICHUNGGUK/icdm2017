{"auto_keywords": [{"score": 0.04906009284763672, "phrase": "java"}, {"score": 0.00481495049065317, "phrase": "language_extensions"}, {"score": 0.004612147352416241, "phrase": "pattern-based_reflective_declaration"}, {"score": 0.004494570360108983, "phrase": "disciplined_form"}, {"score": 0.004286708921931472, "phrase": "mainstream_languages"}, {"score": 0.0034562118159899772, "phrase": "getter_and_setter_methods"}, {"score": 0.0030239842475439814, "phrase": "nested_patterns"}, {"score": 0.0029722900280316216, "phrase": "outer-most_pattern"}, {"score": 0.0027324986756380554, "phrase": "morphj"}, {"score": 0.0026916956768363158, "phrase": "real-world_applications"}, {"score": 0.002622947550220266, "phrase": "morphj_reimplementation"}, {"score": 0.0024799423362011582, "phrase": "java_reflection"}, {"score": 0.0024586427394152196, "phrase": "bytecode_engineering_library"}, {"score": 0.0024061887405214186, "phrase": "morphj_code"}, {"score": 0.0023346234464901978, "phrase": "morphj_solution"}, {"score": 0.002304606411453748, "phrase": "high_level"}, {"score": 0.002150900082318562, "phrase": "morphj_type_system"}, {"score": 0.0021049977753042253, "phrase": "type-checking_algorithm"}], "paper_keywords": ["languages", " object-oriented programming", " structural abstraction", " class morphing", " aspect-oriented programming", " meta-programming", " language extensions"], "paper_abstract": "Recently, language extensions have been proposed for Java and C# to support pattern-based reflective declaration. These extensions introduce a disciplined form of meta-programming and aspect-oriented programming to mainstream languages: They allow members of a class (i.e., fields and methods) to be declared by statically iterating over and pattern-matching on members of other classes. Such techniques, however, have been unable to safely express simple, but common, idioms such as declaring getter and setter methods for fields. In this paper, we present a mechanism that addresses the lack of expressiveness in past work without sacrificing safety. Our technique is based on the idea of nested patterns that elaborate the outer-most pattern with blocking or enabling conditions. We implemented this mechanism in a language, MorphJ. We demonstrate the expressiveness of MorphJ with real-world applications. In particular, the MorphJ reimplementation of DSTM2, a software transactional memory library, reduces 1,107 lines of Java reflection and bytecode engineering library calls to just 374 lines of MorphJ code. At the same time, the MorphJ solution is both high level and safer, as MorphJ can separately type check generic classes and catch errors early. We present and formalize the MorphJ type system, and offer a type-checking algorithm.", "paper_title": "Expressive and safe static reflection with MorphJ", "paper_id": "WOS:000257820400008"}