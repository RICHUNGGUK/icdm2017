{"auto_keywords": [{"score": 0.04939422255606209, "phrase": "deterministic_parallelism"}, {"score": 0.004815059535982149, "phrase": "modular"}, {"score": 0.004655742198075387, "phrase": "concurrency_control_protocol"}, {"score": 0.004208881856146758, "phrase": "well-studied_approach"}, {"score": 0.004108942392772092, "phrase": "sequential_program"}, {"score": 0.0038973170902076707, "phrase": "automatically_injected_control_constructs"}, {"score": 0.0038230844545071303, "phrase": "observable_behaviour"}, {"score": 0.003750260412839128, "phrase": "original_program"}, {"score": 0.003643607569483598, "phrase": "formal_specification"}, {"score": 0.003422781254306241, "phrase": "correct_execution"}, {"score": 0.00334144503360907, "phrase": "program_dependencies"}, {"score": 0.0032777653153451265, "phrase": "deterministic_behaviour"}, {"score": 0.003199864072042816, "phrase": "high-level_specification"}, {"score": 0.0030642636185693054, "phrase": "low-level_library_implementation"}, {"score": 0.002977061391551628, "phrase": "client's_requirements"}, {"score": 0.0027830917623582903, "phrase": "library_correctness"}, {"score": 0.0027431953780099826, "phrase": "abstraction_boundaries"}, {"score": 0.0026395715432958665, "phrase": "concurrent_abstract_predicates"}, {"score": 0.0025892330566358503, "phrase": "separation_logic"}, {"score": 0.0025398521156505425, "phrase": "racy_behaviour"}, {"score": 0.0025034338848015166, "phrase": "library's_implementation"}, {"score": 0.0024556852466581527, "phrase": "generic_specifications"}, {"score": 0.00236289633510808, "phrase": "client_programs"}, {"score": 0.0022845800828325577, "phrase": "higher-order_parameters"}], "paper_keywords": ["Languages", " Theory", " Verification", " Separation Logic", " Concurrent Abstract Predicates", " Concurrency", " Futures"], "paper_abstract": "Weaving a concurrency control protocol into a program is difficult and error-prone. One way to alleviate this burden is deterministic parallelism. In this well-studied approach to parallelisation, a sequential program is annotated with sections that can execute concurrently, with automatically injected control constructs used to ensure observable behaviour consistent with the original program. This paper examines the formal specification and verification of these constructs. Our high-level specification defines the conditions necessary for correct execution; these conditions reflect program dependencies necessary to ensure deterministic behaviour. We connect the high-level specification used by clients of the library with the low-level library implementation, to prove that a client's requirements for determinism are enforced. Significantly, we can reason about program and library correctness without breaking abstraction boundaries. To achieve this, we use concurrent abstract predicates, based on separation logic, to encapsulate racy behaviour in the library's implementation. To allow generic specifications of libraries that can be instantiated by client programs, we extend the logic with higher-order parameters and quantification. We show that our high-level specification abstracts the details of deterministic parallelism by verifying two different low-level implementations of the library.", "paper_title": "Modular Reasoning for Deterministic Parallelism", "paper_id": "WOS:000286472700022"}