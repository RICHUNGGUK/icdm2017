{"auto_keywords": [{"score": 0.047936900215165286, "phrase": "hard_errors"}, {"score": 0.00842101670069699, "phrase": "long-term_device_reliability"}, {"score": 0.006206591521595693, "phrase": "hardware_cost"}, {"score": 0.004787500676821839, "phrase": "chip_multiprocessors"}, {"score": 0.0047330673988744435, "phrase": "semiconductor_industry"}, {"score": 0.004679250110504641, "phrase": "nano-cmos_technologies"}, {"score": 0.004534372661692015, "phrase": "major_concern"}, {"score": 0.004343982746943174, "phrase": "hard_failures"}, {"score": 0.004173474505821137, "phrase": "itrs_roadmap"}, {"score": 0.004125993684094709, "phrase": "traditional_burn-in_test"}, {"score": 0.003986754910294139, "phrase": "sufficient_product_reliability"}, {"score": 0.003964007795174772, "phrase": "fault_detection"}, {"score": 0.003941389954037981, "phrase": "system_reconfiguration"}, {"score": 0.003819270233027538, "phrase": "regular_memory_structures"}, {"score": 0.003754255812075932, "phrase": "error-correcting_codes"}, {"score": 0.003606811438631612, "phrase": "concurrent_testing"}, {"score": 0.003445356410458517, "phrase": "significant_design_effort"}, {"score": 0.003329010133725679, "phrase": "microarchitectural_states"}, {"score": 0.0032443276816348575, "phrase": "golden_patterns"}, {"score": 0.003161792525012037, "phrase": "low-cost_scheme"}, {"score": 0.0030901868389687534, "phrase": "fine_granularity"}, {"score": 0.0030375455671507374, "phrase": "faulty_cores"}, {"score": 0.003002949021343299, "phrase": "potentially_reduced_capability"}, {"score": 0.002918166770275602, "phrase": "runtime_software"}, {"score": 0.0028932006069319386, "phrase": "codesigned_virtual_machine_concept"}, {"score": 0.0027715286135219933, "phrase": "small_noncache_array_structures"}, {"score": 0.002724300844023273, "phrase": "combinational_logic"}, {"score": 0.002693262404213432, "phrase": "hardware_signature_registers"}, {"score": 0.0025948026124758394, "phrase": "functional_modules"}, {"score": 0.002550578610483457, "phrase": "runtime_layer"}, {"score": 0.0024999332729520084, "phrase": "functional_tests"}, {"score": 0.0024785363812738384, "phrase": "multiple_cores"}, {"score": 0.002450291099666278, "phrase": "signature_footprints"}, {"score": 0.002320449502337321, "phrase": "functional_test_sequences"}, {"score": 0.002267854514730502, "phrase": "fine-granular_level"}, {"score": 0.0021786592967334506, "phrase": "software_tasks"}, {"score": 0.0021049977753042253, "phrase": "relatively_low_design_effort"}], "paper_keywords": ["Chip Multiprocessor (CMP)", " hard error detection", " isolation and tolerance", " hardware/software codesign"], "paper_abstract": "As the semiconductor industry continues its relentless push for nano-CMOS technologies, long-term device reliability and occurrence of hard errors have emerged as a major concern. Long-term device reliability includes parametric degradation that results in loss of performance as well as hard failures that result in loss of functionality. It has been reported in the ITRS roadmap that effectiveness of traditional burn-in test in product life acceleration is eroding. Thus, to assure sufficient product reliability, fault detection and system reconfiguration must be performed in the field at runtime. Although regular memory structures are protected against hard errors using error-correcting codes, many structures within cores are left unprotected. Several proposed online testing techniques either rely on concurrent testing or periodically check for correctness. These techniques are attractive, but limited due to significant design effort and hardware cost. Furthermore, lack of observability and controllability of microarchitectural states result in long latency, long test sequences, and large storage of golden patterns. In this paper, we propose a low-cost scheme for detecting and debugging hard errors with a fine granularity within cores and keeping the faulty cores functional, with potentially reduced capability and performance. The solution includes both hardware and runtime software based on codesigned virtual machine concept. It has the ability to detect, debug, and isolate hard errors in small noncache array structures, execution units, and combinational logic within cores. Hardware signature registers are used to capture the footprint of execution at the output of functional modules within the cores. A runtime layer of software (microvisor) initiates functional tests concurrently on multiple cores to capture the signature footprints across cores to detect, debug, and isolate hard errors. Results show that using targeted set of functional test sequences, faults can be debugged to a fine-granular level within cores. The hardware cost of the scheme is less than three percent, while the software tasks are performed at a high-level, resulting in a relatively low design effort and cost.", "paper_title": "Hardware/Software Codesign Architecture for Online Testing in Chip Multiprocessors", "paper_id": "WOS:000294417500007"}