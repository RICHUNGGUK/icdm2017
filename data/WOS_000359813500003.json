{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "infinite_state_processes"}, {"score": 0.033151764504575625, "phrase": "verification_conditions"}, {"score": 0.027609121139143697, "phrase": "decision_procedures"}, {"score": 0.004725385523804256, "phrase": "uniform_verification_problem"}, {"score": 0.004534136929881113, "phrase": "parallel_composition"}, {"score": 0.00448332888936155, "phrase": "arbitrary_number"}, {"score": 0.004334280585565239, "phrase": "finite_collection"}, {"score": 0.004237666411136617, "phrase": "temporal_property"}, {"score": 0.004127657126534723, "phrase": "general_framework"}, {"score": 0.004081385289516914, "phrase": "temporal_verification"}, {"score": 0.0040508247605225214, "phrase": "concurrent_datatypes"}, {"score": 0.0039308449157320815, "phrase": "general_method"}, {"score": 0.0038576618286586387, "phrase": "safety_properties"}, {"score": 0.003828770052266183, "phrase": "parametrized_programs"}, {"score": 0.003785836059995376, "phrase": "complex_local_and_global_data"}, {"score": 0.003591733916159209, "phrase": "clear_division"}, {"score": 0.003446208270665051, "phrase": "executing_threads"}, {"score": 0.003382017342396959, "phrase": "parametrized_invariance_proof_rules"}, {"score": 0.0032571885279065126, "phrase": "specialized_decision_procedures"}, {"score": 0.0025795066118838067, "phrase": "complex_data-types"}, {"score": 0.0025409639091476363, "phrase": "off-the-shelf_smt_solvers"}, {"score": 0.0024287485834314027, "phrase": "formal_verification"}, {"score": 0.0022022878843247274, "phrase": "concurrent_lists"}, {"score": 0.0021530945641993152, "phrase": "empirical_results"}, {"score": 0.002128910637262527, "phrase": "prototype_implementation"}, {"score": 0.0021049977753042253, "phrase": "proof_rules"}], "paper_keywords": [""], "paper_abstract": "We study the uniform verification problem for infinite state processes. This problem consists of proving that the parallel composition of an arbitrary number of processes running the same program (or a finite collection of programs) satisfies a temporal property. Our practical motivation is to build a general framework for the temporal verification of concurrent datatypes. In this paper we propose a general method for the verification of safety properties of parametrized programs that manipulate complex local and global data, including mutable state in the heap. Our method is based on a clear division between the following two dimensions of the problem: the interaction between executing threads-handled by novel parametrized invariance proof rules, and the data being manipulated-handled by specialized decision procedures. Our proof rules discharge automatically a finite collection of verification conditions. The size of this collection depends only on the size of the program and the specification, but not on the number of processes in any given instance or on the kind of data manipulated. Moreover, all verification conditions are quantifier free, which eases the development of decision procedures for complex data-types on top of off-the-shelf SMT solvers. We prove soundness of our proof rules and illustrate their application in the formal verification of (1) two infinite-state mutual exclusion protocols; (2) shape and functional correctness properties of several concurrent data-types, including fine-grained and non-blocking concurrent lists and queues. We report empirical results using a prototype implementation of the proof rules and decision procedures.", "paper_title": "Parametrized invariance for infinite state processes", "paper_id": "WOS:000359813500003"}