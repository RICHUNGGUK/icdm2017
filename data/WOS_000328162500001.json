{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "multicore_applications"}, {"score": 0.040881676335714635, "phrase": "race_detectors"}, {"score": 0.032548317552603324, "phrase": "data-mining_techniques"}, {"score": 0.004608121749000898, "phrase": "multicore_computers"}, {"score": 0.004535124351828787, "phrase": "expert_developers"}, {"score": 0.004288581530198804, "phrase": "multithreaded_software"}, {"score": 0.004203803478570494, "phrase": "mainstream_shared-memory_hardware"}, {"score": 0.004087910779160781, "phrase": "parallel_programming_errors"}, {"score": 0.004039221742250308, "phrase": "complex_and_arduous_task"}, {"score": 0.003758981686762617, "phrase": "incorrect_usage"}, {"score": 0.003729065012001506, "phrase": "synchronization_constructs"}, {"score": 0.003669941438286456, "phrase": "missing_synchronization"}, {"score": 0.0035973486787314883, "phrase": "debugging_techniques"}, {"score": 0.0034426417353349567, "phrase": "new_perspective"}, {"score": 0.0033880439015902446, "phrase": "largely_unexplored_direction"}, {"score": 0.003361069456060196, "phrase": "defect_localization"}, {"score": 0.003321008590273796, "phrase": "wrong_usage"}, {"score": 0.003294566092612857, "phrase": "nonparallel_programming_constructs"}, {"score": 0.003255295296893174, "phrase": "wrong_parallel_application_behavior"}, {"score": 0.0030171910207671205, "phrase": "multithreaded_shared-memory_programs"}, {"score": 0.002957471572421436, "phrase": "execution_anomalies"}, {"score": 0.002922207118572208, "phrase": "condensed_representation"}, {"score": 0.00288736193515505, "phrase": "dynamic_call_graphs"}, {"score": 0.0028529310661977577, "phrase": "multithreaded_object-oriented_application"}, {"score": 0.0026760974046034854, "phrase": "incorrect_synchronization"}, {"score": 0.0025918235228843444, "phrase": "wider_range"}, {"score": 0.002530359917257626, "phrase": "control_flow"}, {"score": 0.0025001755089445092, "phrase": "parallel_program"}, {"score": 0.0024604876113911173, "phrase": "controlled_experiments"}, {"score": 0.0023079225317714815, "phrase": "incorrect_parallel_program_behavior"}, {"score": 0.002262209824105154, "phrase": "fruitful_new_ground"}, {"score": 0.002244178699939059, "phrase": "parallel_program_debugging"}, {"score": 0.0021909411820497707, "phrase": "long-term_directions"}, {"score": 0.0021647968783414504, "phrase": "interesting_field"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["parallel computing", " software defect localization", " multithreaded programs", " dynamic call graphs", " data mining"], "paper_abstract": "Multicore computers are ubiquitous. Expert developers as well as developers with little experience in parallelism are now asked to create multithreaded software to exploit parallelism in mainstream shared-memory hardware. However, finding and fixing parallel programming errors is a complex and arduous task. Programmers thus rely on tools such as race detectors that typically focus on reporting errors due to incorrect usage of synchronization constructs or due to missing synchronization. This arsenal of debugging techniques, however, is incomplete. This article presents a new perspective and addresses a largely unexplored direction of defect localization where a wrong usage of nonparallel programming constructs might cause wrong parallel application behavior. In particular, we make a contribution by showing how to use data-mining techniques to locate defects in multithreaded shared-memory programs. Our technique analyzes execution anomalies in a condensed representation of the dynamic call graphs of a multithreaded object-oriented application and identifies methods that contain a defect. Compared with race detectors that concentrate on finding incorrect synchronization, our method is able to reveal a wider range of defects that affect the control flow of a parallel program. Results from controlled experiments show that our data-mining approach finds not only race conditions in different types of multicore applications but also other errors that cause incorrect parallel program behavior. Data-mining techniques offer a fruitful new ground for parallel program debugging, and we also discuss long-term directions for this interesting field. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "Data mining for defects in multicore applications: an entropy-based call-graph technique", "paper_id": "WOS:000328162500001"}