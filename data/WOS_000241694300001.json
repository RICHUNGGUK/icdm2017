{"auto_keywords": [{"score": 0.03595205366625649, "phrase": "program_refinement"}, {"score": 0.029871506941939893, "phrase": "programming_constructs"}, {"score": 0.00481495049065317, "phrase": "initial_chapter"}, {"score": 0.004672160300006692, "phrase": "general_background"}, {"score": 0.004625506452304716, "phrase": "remaining_chapters"}, {"score": 0.004533585346030341, "phrase": "relevant_notions"}, {"score": 0.004458375125223899, "phrase": "simple_and_well-known_programming_notation"}, {"score": 0.004428661058121552, "phrase": "dijkstra"}, {"score": 0.0043697607816770775, "phrase": "guarded_commands"}, {"score": 0.004197758831410097, "phrase": "semantic_meaning"}, {"score": 0.0039259432210911925, "phrase": "associated_reasoning_framework"}, {"score": 0.003899745240916238, "phrase": "hoare_logic"}, {"score": 0.0037839928025418896, "phrase": "calculational_style"}, {"score": 0.003622811707147052, "phrase": "predicate_transformer"}, {"score": 0.0035507457285983268, "phrase": "partial_and_total_correctness"}, {"score": 0.003433796409346569, "phrase": "important_notion"}, {"score": 0.0032328778271536454, "phrase": "weakest_precondition_based_definition"}, {"score": 0.0029830992938695007, "phrase": "program_semantics"}, {"score": 0.002943381865409788, "phrase": "refinement_algebra"}, {"score": 0.002799080959445996, "phrase": "algebraic_laws"}, {"score": 0.0027341763737751467, "phrase": "program_transformation"}, {"score": 0.0025313026089662165, "phrase": "morgan's_specification_statement"}, {"score": 0.0025059724686541263, "phrase": "morgan's_refinement_calculus"}, {"score": 0.0022284920601703595, "phrase": "well-established_results"}, {"score": 0.002191438157029621, "phrase": "programming_methodologies"}, {"score": 0.002133426416881756, "phrase": "brief_discussion"}], "paper_keywords": [""], "paper_abstract": "The purpose of this initial chapter is to introduce concepts and techniques assumed as general background in the remaining chapters of this book. The relevant notions are introduced using a simple and well-known programming notation: Dijkstra's language of guarded commands [81], presented in Section 1. Three classical approaches to assigning semantic meaning to programs are then explored. In Section 2 we discuss the annotation of programs with assertions and the associated reasoning framework (Hoare Logic). Section 3 is dedicated to a calculational style where the behaviour of a program is defined in terms of a predicate transformer: its weakest precondition. Partial and total correctness of programs are contrasted in these two sections. The important notion of program refinement is introduced in Section 4. We start with some intuition and then we give a weakest precondition based definition, followed by an alternative (but equivalent) definition in terms of nondeterminism. In Section 5, we explore another approach to program semantics, known as refinement algebra, which is based on equations and inequations (laws) relating programming constructs; algebraic laws allow a term rewriting style of program transformation. We then show, in Section 6, how the programming constructs can be embedded into a more abstract space of specifications; we introduce Morgan's specification statement and illustrate Morgan's refinement calculus concerning both algorithmic and data refinement. In Section 7 we discuss how a programming (or specification) language with a refinement ordering can be regarded as a lattice. This allows using well-established results of lattice theory in programming methodologies. We conclude this chapter with a brief discussion of refinement in other programming paradigms and the importance of tools to support program refinement in practice.", "paper_title": "Refinement: An overview", "paper_id": "WOS:000241694300001"}