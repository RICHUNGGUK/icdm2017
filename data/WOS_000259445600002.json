{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "nominal_logic"}, {"score": 0.004539005582217309, "phrase": "first-order_logic"}, {"score": 0.004329630571352367, "phrase": "simple_foundation"}, {"score": 0.0040334640350288, "phrase": "abstract_syntax_modulo"}, {"score": 0.00384731849108269, "phrase": "bound_names"}, {"score": 0.003541923233726252, "phrase": "logic_programming"}, {"score": 0.0032223742018434856, "phrase": "typical_nominal_logic_programs"}, {"score": 0.0025436978068459565, "phrase": "correct_behavior"}, {"score": 0.0023139986108451967, "phrase": "rigorous_foundation"}, {"score": 0.0021049977753042253, "phrase": "nominal_logic_programs"}], "paper_keywords": ["languages", " nominal logic", " logic programming", " name-binding", " semantics"], "paper_abstract": "Nominal logic is an extension of first-order logic which provides a simple foundation for formalizing and reasoning about abstract syntax modulo consistent renaming of bound names (that is, alpha-equivalence). This article investigates logic programming based on nominal logic. We describe some typical nominal logic programs, and develop the model-theoretic, proof-theoretic, and operational semantics of such programs. Besides being of interest for ensuring the correct behavior of implementations, these results provide a rigorous foundation for techniques for analysis and reasoning about nominal logic programs, as we illustrate via examples.", "paper_title": "Nominal logic programming", "paper_id": "WOS:000259445600002"}