{"auto_keywords": [{"score": 0.04843778234608258, "phrase": "directed_graph"}, {"score": 0.03655825658316862, "phrase": "main_memory"}, {"score": 0.030068504519803585, "phrase": "tree_construction"}, {"score": 0.00481495049065317, "phrase": "massive_graphs"}, {"score": 0.0046875099587735825, "phrase": "maximal_subgraph"}, {"score": 0.004395185177346749, "phrase": "directed_acyclic_graph"}, {"score": 0.004255913054923765, "phrase": "dag."}, {"score": 0.004199173074059755, "phrase": "graph_pattern"}, {"score": 0.004066076430818046, "phrase": "best_way"}, {"score": 0.004011867299107537, "phrase": "general_directed_graph"}, {"score": 0.003832884214087895, "phrase": "critical_operation"}, {"score": 0.003802135020791801, "phrase": "existing_in-memory_algorithms"}, {"score": 0.0037615180375561805, "phrase": "first_search"}, {"score": 0.0036717033873979125, "phrase": "linear_time"}, {"score": 0.003175962507754933, "phrase": "massive_directed_graph"}, {"score": 0.003050508020268648, "phrase": "existing_dfs-based_semi-external_algorithm"}, {"score": 0.002953711377604328, "phrase": "weak_order"}, {"score": 0.0029064676523923886, "phrase": "new_algorithms"}, {"score": 0.0028676739670326426, "phrase": "new_two-phase_algorithm"}, {"score": 0.0028218024896224814, "phrase": "tree_search"}, {"score": 0.0027916287357898544, "phrase": "tree_construction_phase"}, {"score": 0.002769209760453212, "phrase": "spanning_tree"}, {"score": 0.002724909017963099, "phrase": "bounded_number"}, {"score": 0.0027102997281261733, "phrase": "sequential_scans"}, {"score": 0.002674117345585327, "phrase": "tree_search_phase"}, {"score": 0.0025341419804996387, "phrase": "new_single-phase_algorithm"}, {"score": 0.0024536899866226805, "phrase": "single_phase"}, {"score": 0.002407941567598653, "phrase": "early_acceptance"}, {"score": 0.0023950275815082297, "phrase": "early_rejection"}, {"score": 0.0023440589015485077, "phrase": "single-phase_algorithm"}, {"score": 0.002325225883106, "phrase": "new_optimization_techniques"}, {"score": 0.0022513914267746397, "phrase": "cpu_cost"}, {"score": 0.0021798963627236915, "phrase": "extensive_experimental_studies"}, {"score": 0.0021507795710951384, "phrase": "massive_real_dataset"}], "paper_keywords": ["Graph processing", " I/O efficiency", " Directed acyclic graphs", " Strongly connected components"], "paper_abstract": "A strongly connected component () is a maximal subgraph of a directed graph in which every pair of nodes is reachable from each other in the . With such a property, a general directed graph can be represented by a directed acyclic graph (DAG) by contracting every of to a node in DAG. In many real applications that need graph pattern matching, topological sorting, or reachability query processing, the best way to deal with a general directed graph is to deal with its DAG representation. Therefore, finding all s in a directed graph is a critical operation. The existing in-memory algorithms based on depth first search (DFS) can find all s in linear time with respect to the size of a graph. However, when a graph cannot reside entirely in the main memory, the existing external or semi-external algorithms to find all s have limitation to achieve high I/O efficiency. In this paper, we study new I/O-efficient semi-external algorithms to find all s for a massive directed graph that cannot reside in main memory entirely. To overcome the deficiency of the existing DFS-based semi-external algorithm that heavily relies on a total order, we explore a weak order based on which we investigate new algorithms. We propose a new two-phase algorithm, namely, tree construction and tree search. In the tree construction phase, a spanning tree of can be constructed in bounded number of sequential scans of . In the tree search phase, it needs to sequentially scan the graph once to find all s. In addition, we propose a new single-phase algorithm, which combines the tree construction and tree search phases into a single phase, with three new optimization techniques. They are early acceptance, early rejection, and batch processing. By the single-phase algorithm with the new optimization techniques, we can significantly reduce the number of I/Os and the CPU cost. We prove the correctness of the algorithms. We conduct extensive experimental studies using 4 real datasets including a massive real dataset and several synthetic datasets to confirm the I/O efficiency of our approaches.", "paper_title": "I/O efficient: computing SCCs in massive graphs", "paper_id": "WOS:000351381200004"}