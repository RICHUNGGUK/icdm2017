{"auto_keywords": [{"score": 0.04862067267774044, "phrase": "embedded_devices"}, {"score": 0.03549023770311801, "phrase": "rmp"}, {"score": 0.012966675462219805, "phrase": "profiling_tools"}, {"score": 0.00481495049065317, "phrase": "android_applications"}, {"score": 0.004627244470096107, "phrase": "tight_constraints"}, {"score": 0.004546174820239776, "phrase": "energy_resources"}, {"score": 0.004311352359122141, "phrase": "resource-constrained_devices"}, {"score": 0.0042171108629745655, "phrase": "energy_constraint"}, {"score": 0.0036932254391253134, "phrase": "large_space"}, {"score": 0.0036445446531633368, "phrase": "detailed_profiling_data"}, {"score": 0.003533428121425737, "phrase": "hard_demand"}, {"score": 0.0033955105098235345, "phrase": "reconfigurable_multi-resolution_profiling"}, {"score": 0.003135564707433078, "phrase": "profiling_points"}, {"score": 0.0031079352545607267, "phrase": "source_code"}, {"score": 0.003066945490483524, "phrase": "target_application"}, {"score": 0.0028699415886017468, "phrase": "profiling_scope"}, {"score": 0.002832081745025006, "phrase": "configuration_tool_step"}, {"score": 0.0027578496677536373, "phrase": "profiled_targets"}, {"score": 0.002661883310629088, "phrase": "open_source_tool"}, {"score": 0.0026384167183586015, "phrase": "android_systems"}, {"score": 0.002615156460073562, "phrase": "experiment_results"}, {"score": 0.0025692477422626678, "phrase": "required_log_space"}, {"score": 0.002512990657100351, "phrase": "web_browser_application"}, {"score": 0.002425524064992056, "phrase": "android_debug_class"}, {"score": 0.002382936364692606, "phrase": "profiling_error_rate"}, {"score": 0.002361923085067681, "phrase": "execution_time"}, {"score": 0.0022696277881969896, "phrase": "debug_class"}, {"score": 0.0021049977753042253, "phrase": "browsing_scenario"}], "paper_keywords": ["time profiling", " multi-resolution profiling", " android", " reconfigurable profiling"], "paper_abstract": "The computing of applications in embedded devices suffers tight constraints on computation and energy resources. Thus, it is important that applications running on these resource-constrained devices are aware of the energy constraint and are able to execute efficiently. The existing execution time and energy profiling tools could help developers to identify the bottlenecks of applications. However, the profiling tools need large space to store detailed profiling data at runtime, which is a hard demand upon embedded devices. In this article, a reconfigurable multi-resolution profiling (RMP) approach is proposed to handle this issue on embedded devices. It first instruments all profiling points into source code of the target application and framework. Developers can narrow down the causes of bottleneck by adjusting the profiling scope using the configuration tool step by step without recompiling the profiled targets. RMP has been implemented as an open source tool on Android systems. Experiment results show that the required log space using RMP for a web browser application is 25 times smaller than that of Android debug class, and the profiling error rate of execution time is proven 24 times lower than that of debug class. Besides, the CPU and memory overheads of RMP are only 5% and 6.53% for the browsing scenario, respectively.", "paper_title": "Reconfigurable Multi-Resolution Performance Profiling in Android Applications", "paper_id": "WOS:000326409300019"}