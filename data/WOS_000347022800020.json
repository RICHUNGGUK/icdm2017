{"auto_keywords": [{"score": 0.043035202886745394, "phrase": "usability_features"}, {"score": 0.012070176535735581, "phrase": "conceptual_primitives"}, {"score": 0.007123436893698386, "phrase": "generated_code"}, {"score": 0.006918228354926721, "phrase": "functional_usability_features"}, {"score": 0.005872985087230178, "phrase": "empirical_study"}, {"score": 0.005653727873849833, "phrase": "end_users'_satisfaction"}, {"score": 0.00481495049065317, "phrase": "model-driven_development_methods"}, {"score": 0.00470341117804131, "phrase": "sound_methods"}, {"score": 0.004621447740470602, "phrase": "model-driven_development_approach"}, {"score": 0.004514375152076706, "phrase": "mdd"}, {"score": 0.004330857568807407, "phrase": "mdd_analysts"}, {"score": 0.004195418010131832, "phrase": "second_place"}, {"score": 0.004026712228523795, "phrase": "mdd_tool"}, {"score": 0.003742084495435749, "phrase": "system_functionality"}, {"score": 0.003591542373891629, "phrase": "usability_guidelines"}, {"score": 0.0035600768845860937, "phrase": "usability_properties"}, {"score": 0.003487721546598799, "phrase": "conceptual_model"}, {"score": 0.0034369381458785025, "phrase": "new_primitives"}, {"score": 0.0033769698684652646, "phrase": "model_compiler"}, {"score": 0.002717750004930131, "phrase": "spent_time"}, {"score": 0.002608308441459177, "phrase": "software_development_process"}, {"score": 0.002570296816631395, "phrase": "comparison_show"}, {"score": 0.0025106241866273897, "phrase": "mdd_method"}, {"score": 0.0022258171833127636, "phrase": "conceptual_models"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Model-Driven Development", " Usability", " Conceptual model"], "paper_abstract": "Context: Nowadays, there are sound methods and tools which implement the Model-Driven Development approach (MDD) satisfactorily. However, MDD approaches focus on representing and generating code that represents functionality, behaviour and persistence, putting the interaction, and more specifically the usability, in a second place. If we aim to include usability features in a system developed with a MDD tool, we need to extend manually the generated code. Objective: This paper tackles how to include functional usability features (usability recommendations strongly related to system functionality) in MDD through conceptual primitives. Method: The approach consists of studying usability guidelines to identify usability properties that can be represented in a conceptual model. Next, these new primitives are the input for a model compiler that generates the code according to the characteristics expressed in them. An empirical study with 66 subjects was conducted to study the effect of including functional usability features regarding end users' satisfaction and time to complete tasks. Moreover, we have compared the workload of two MDD analysts including usability features by hand in the generated code versus including them through conceptual primitives according to our approach. Results: Results of the empirical study shows that after including usability features, end users' satisfaction improves while spent time does not change significantly. This justifies the use of usability features in the software development process. Results of the comparison show that the workload required to adapt the MDD method to support usability features through conceptual primitives is heavy. However, once MDD supports these features, MDD analysts working with primitives are more efficient than MDD analysts implementing these features manually. Conclusion: This approach brings us a step closer to conceptual models where models represent not only functionality, behaviour or persistence, but also usability features. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "A framework to identify primitives that represent usability within Model-Driven Development methods", "paper_id": "WOS:000347022800020"}