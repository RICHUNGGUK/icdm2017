{"auto_keywords": [{"score": 0.04247015589711413, "phrase": "signal"}, {"score": 0.00481495049065317, "phrase": "modular_memory_optimization"}, {"score": 0.0047747348769918, "phrase": "synchronous_data-flow_languages_application"}, {"score": 0.004675652357253327, "phrase": "lustre_compiler"}, {"score": 0.004578616481036476, "phrase": "efficient_sequential_code"}, {"score": 0.004540365779658683, "phrase": "synchronous_data-flow_languages"}, {"score": 0.004100985453211912, "phrase": "lustre"}, {"score": 0.003887438245620965, "phrase": "restricted_manner"}, {"score": 0.0038227112550093863, "phrase": "memory_optimization"}, {"score": 0.00377487157059352, "phrase": "pressing_issue"}, {"score": 0.003589404014552974, "phrase": "two-level_solution"}, {"score": 0.0035444736871640147, "phrase": "memory_optimization_problem"}, {"score": 0.0034708317974593136, "phrase": "compile-time_optimization_algorithm"}, {"score": 0.0034130176595901104, "phrase": "register_allocation"}, {"score": 0.0033561632967173856, "phrase": "language_annotations"}, {"score": 0.0030089355635315005, "phrase": "external_functions"}, {"score": 0.002789763110395331, "phrase": "semilinear_type_system"}, {"score": 0.002766415324343602, "phrase": "additional_scheduling_constraints"}, {"score": 0.0027317585060414253, "phrase": "key_feature"}, {"score": 0.00267495669519805, "phrase": "well-typed_programs"}, {"score": 0.002358050109031317, "phrase": "new_compiler"}, {"score": 0.0023284972218506157, "phrase": "lustre-like_synchronous_language"}, {"score": 0.0022139352210982398, "phrase": "proposed_approach"}, {"score": 0.0021678771715091492, "phrase": "unnecessary_array_copies"}, {"score": 0.002131720106846481, "phrase": "faster_code"}], "paper_keywords": ["Algorithms", " Languages", " Theory", " Real-time systems", " Synchronous languages", " Block-diagrams", " Compilation", " Optimization", " Semantics", " Type systems"], "paper_abstract": "The generation of efficient sequential code for synchronous data-flow languages raises two intertwined issues: control and memory optimization. While the former has been extensively studied, for instance in the compilation of LUSTRE and SIGNAL, the latter has only been addressed in a restricted manner. Yet, memory optimization becomes a pressing issue when arrays are added to such languages. This article presents a two-level solution to the memory optimization problem. It combines a compile-time optimization algorithm, reminiscent of register allocation, paired with language annotations on the source given by the designer. Annotations express in-place modifications and control where allocation is performed. Moreover, they allow external functions performing in-place modifications to be safely imported. Soundness of annotations is guaranteed by a semilinear type system and additional scheduling constraints. A key feature is that annotations for well-typed programs do not change the semantics of the language: removing them may lead to less efficient code but will not alter the semantics. The method has been implemented in a new compiler for a LUSTRE-like synchronous language extended with hierarchical automata and arrays. Experiments show that the proposed approach removes most of the unnecessary array copies, resulting in faster code that uses less memory.", "paper_title": "A Modular Memory Optimization for Synchronous Data-Flow Languages Application to Arrays in a Lustre Compiler", "paper_id": "WOS:000307580000006"}