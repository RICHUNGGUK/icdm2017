{"auto_keywords": [{"score": 0.04576021885069074, "phrase": "maximum_lateness"}, {"score": 0.00481495049065317, "phrase": "exponential_neighborhood_search"}, {"score": 0.004709333998298903, "phrase": "batching_machine"}, {"score": 0.0044800522651664695, "phrase": "single_batching_machine"}, {"score": 0.004238307626560739, "phrase": "batch_size"}, {"score": 0.004099542199088835, "phrase": "np-hard_problem"}, {"score": 0.0032470094613727433, "phrase": "dynamic_program"}, {"score": 0.0030376623293574905, "phrase": "underlying_job_order"}, {"score": 0.002970914475538276, "phrase": "solution_representation"}, {"score": 0.002585638506308606, "phrase": "multiple_job_inserts"}, {"score": 0.002542890176213921, "phrase": "single_move"}, {"score": 0.0025008468316682036, "phrase": "split-merge_neighborhood"}, {"score": 0.0024594969044952108, "phrase": "exponential_size"}, {"score": 0.0023656467839555458, "phrase": "polynomial_time"}, {"score": 0.0023394947463129642, "phrase": "dynamic_programming"}, {"score": 0.0023136311468961125, "phrase": "computational_results"}, {"score": 0.002275369652100353, "phrase": "iterated_descent_algorithm"}, {"score": 0.0021049977753042253, "phrase": "corresponding_iterated_descent_algorithms"}], "paper_keywords": ["Batching machine", " Maximum lateness", " Local search", " Exponential neighborhoods", " Dynamic programming"], "paper_abstract": "We address the problem of scheduling a single batching machine to minimize the maximum lateness with a constraint restricting the batch size. A solution for this NP-hard problem is defined by a selection of jobs for each batch and an ordering of those batches. As an alternative, we choose to represent a solution as a sequence of jobs. This approach is justified by our development of a dynamic program to find a schedule that minimizes the maximum lateness while preserving the underlying job order. Given this solution representation, we are able to define and evaluate various job-insert and job-swap neighborhood searches. Furthermore we introduce a new neighborhood, named split-merge, that allows multiple job inserts in a single move. The split-merge neighborhood is of exponential size, but can be searched in polynomial time by dynamic programming. Computational results with an iterated descent algorithm that employs the split-merge neighborhood show that it compares favorably with corresponding iterated descent algorithms based on the job-insert and job-swap neighborhoods. (C) 2015 Elsevier Ltd. All rights reserved.", "paper_title": "Split-merge: Using exponential neighborhood search for scheduling a batching machine", "paper_id": "WOS:000358268000011"}