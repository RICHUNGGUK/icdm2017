{"auto_keywords": [{"score": 0.04239815405562918, "phrase": "speculative_storage"}, {"score": 0.010612387000973441, "phrase": "reference_idempotency"}, {"score": 0.010479126673145274, "phrase": "speculative_storage_overflow"}, {"score": 0.00793265793352614, "phrase": "larger_threads"}, {"score": 0.007047561519844134, "phrase": "idempotent_references"}, {"score": 0.006287138409925664, "phrase": "nonparallelizable_program_sections"}, {"score": 0.004714023408114857, "phrase": "recent_proposals"}, {"score": 0.00467424463996457, "phrase": "multithreaded_architectures"}, {"score": 0.004634799977448855, "phrase": "speculative_execution"}, {"score": 0.004537631845923196, "phrase": "unknown_dependences"}, {"score": 0.004349337717774093, "phrase": "hardware_speculative_storage"}, {"score": 0.004294381488413906, "phrase": "speculative_data"}, {"score": 0.004240116703465252, "phrase": "data_dependences"}, {"score": 0.004204320052179726, "phrase": "correct_incorrect_executions"}, {"score": 0.004098725744818192, "phrase": "memory_references"}, {"score": 0.004012751049253625, "phrase": "current_proposals"}, {"score": 0.003945266418163835, "phrase": "small_memory_structures"}, {"score": 0.0038953958723049287, "phrase": "fast_access"}, {"score": 0.0038461532860146535, "phrase": "limited_capacity"}, {"score": 0.0037654565082218595, "phrase": "considerable_performance_loss"}, {"score": 0.003670843919846253, "phrase": "thread's_speculative_state"}, {"score": 0.003624429617337833, "phrase": "speculative_storage_capacity"}, {"score": 0.003548368289666932, "phrase": "overflow_problem"}, {"score": 0.0034738975998176323, "phrase": "smaller_threads"}, {"score": 0.00327356326590461, "phrase": "new_program_property"}, {"score": 0.0026701760128830573, "phrase": "nonspeculative_storage"}, {"score": 0.0024947959375982614, "phrase": "speculative_storage_space"}, {"score": 0.0024736973328071026, "phrase": "large_threads"}, {"score": 0.002421726275597666, "phrase": "formal_framework"}, {"score": 0.002360796860462937, "phrase": "novel_compiler-assisted_speculative_execution_model"}, {"score": 0.002311192286067765, "phrase": "necessary_and_sufficient_conditions"}, {"score": 0.002215081186105616, "phrase": "compiler_algorithm"}, {"score": 0.0021870332034407817, "phrase": "idempotent_memory_references"}, {"score": 0.0021410718792612173, "phrase": "experimental_results"}], "paper_keywords": ["idempotent references", " speculation", " compiler-assisted speculative execution"], "paper_abstract": "Recent proposals for multithreaded architectures employ speculative execution to allow threads with unknown dependences to execute speculatively in parallel. The architectures use hardware speculative storage to buffer speculative data, track data dependences and correct incorrect executions through roll-backs. Because all memory references access the speculative storage, current proposals implement speculative storage using small memory structures to achieve fast access. The limited capacity of the speculative storage causes considerable performance loss due to speculative storage overflow whenever a thread's speculative state exceeds the speculative storage capacity. Larger threads exacerbate the overflow problem but are preferable to smaller threads, as larger threads uncover more parallelism. In this article, we discover a new program property called memory reference idempotency. Idempotent references are guaranteed to be eventually corrected, though the references may be temporarily incorrect in the process of speculation. Therefore, idempotent references, even from nonparallelizable program sections, need not be tracked in the speculative storage, and instead can directly access nonspeculative storage (i.e., conventional memory hierarchy). Thus, we reduce the demand for speculative storage space in large threads. We define a formal framework for reference idempotency and present a novel compiler-assisted speculative execution model. We prove the necessary and sufficient conditions for reference idempotency using our model. We present a compiler algorithm to label idempotent memory references for the hardware. Experimental results show that for our benchmarks, over 60% of the references in nonparallelizable program sections are idempotent.", "paper_title": "Exploiting reference idempotency to reduce speculative storage overflow", "paper_id": "WOS:000240456900004"}