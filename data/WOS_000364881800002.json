{"auto_keywords": [{"score": 0.0453665111651286, "phrase": "yield_annotations"}, {"score": 0.02819827616624647, "phrase": "thread_interference"}, {"score": 0.023941863960210887, "phrase": "type_system"}, {"score": 0.006886519417712533, "phrase": "well-typed_programs"}, {"score": 0.004767892479149162, "phrase": "java"}, {"score": 0.004721162131188487, "phrase": "multithreaded_programs"}, {"score": 0.004606479650820579, "phrase": "unintended_interference"}, {"score": 0.004561386908745206, "phrase": "concurrent_threads"}, {"score": 0.004278807087784626, "phrase": "source_code"}, {"score": 0.003954837422946628, "phrase": "undocumented_interference"}, {"score": 0.003916098498242888, "phrase": "java_programs"}, {"score": 0.003728000957725218, "phrase": "context_switches"}, {"score": 0.003496868378204657, "phrase": "intuitive_sequential_reasoning"}, {"score": 0.0032800186243040663, "phrase": "experimental_results"}, {"score": 0.0031377955308198634, "phrase": "prior_techniques"}, {"score": 0.003091767402370757, "phrase": "method-level_atomicity_specifications"}, {"score": 0.002943147037670826, "phrase": "interference_points"}, {"score": 0.0026933542552712033, "phrase": "prior_methods"}, {"score": 0.00266693888510356, "phrase": "race_freedom"}, {"score": 0.002576503437739865, "phrase": "known_concurrency_defects"}, {"score": 0.0024768883044869023, "phrase": "program_behavior"}, {"score": 0.0024405312482831646, "phrase": "method-level_specifications"}, {"score": 0.0023811153883132536, "phrase": "programmer_burden"}, {"score": 0.002255431275670053, "phrase": "method_specification_inference"}, {"score": 0.0021682027434117095, "phrase": "large_code_bases"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v._all_rights"}], "paper_keywords": ["Cooperability", " Concurrency", " Type systems"], "paper_abstract": "Multithreaded programs are notoriously prone to unintended interference between concurrent threads. To address this problem, we argue that yield annotations in the source code should document all thread interference, and we present a type system for verifying the absence of undocumented interference in Java programs. Under this type system, well-typed programs behave as if context switches occur only at yield annotations. Thus, well-typed programs can be understood using intuitive sequential reasoning, except where yield annotations remind the programmer to account for thread interference. Experimental results show that yield annotations describe thread interference more precisely than prior techniques based on method-level atomicity specifications. In particular, yield annotations reduce the number of interference points one must reason about by an order of magnitude. The type system is also more precise than prior methods targeting race freedom, and yield annotations highlight all known concurrency defects in our benchmarks. The type system reasons about program behavior modularly via method-level specifications. To alleviate the programmer burden of writing these specifications, we extend our system to support method specification inference, which makes our technique more practical for large code bases. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Cooperative types for controlling thread interference in Java", "paper_id": "WOS:000364881800002"}