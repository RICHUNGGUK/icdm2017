{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "bayesian_optimisation"}, {"score": 0.012862942935608556, "phrase": "analysis_cost"}, {"score": 0.009627613288289951, "phrase": "existing_codebase"}, {"score": 0.004737579882204798, "phrase": "cost-effective_static_analyser"}, {"score": 0.0046993598473345395, "phrase": "real-world_programs"}, {"score": 0.004512814529823301, "phrase": "grim_reputation"}, {"score": 0.004229556887896042, "phrase": "ideal_analyser"}, {"score": 0.003700037700138249, "phrase": "large_amount"}, {"score": 0.003670157084732341, "phrase": "engineering_efforts"}, {"score": 0.0035530197642369464, "phrase": "new_approach"}, {"score": 0.003495855671790616, "phrase": "adaptive_static_analyser"}, {"score": 0.003370565320453525, "phrase": "sophisticated_parameterised_strategy"}, {"score": 0.003171615440419782, "phrase": "precision-improving_technique"}, {"score": 0.0029965060407413898, "phrase": "good_parameter"}, {"score": 0.002877361619893651, "phrase": "learnt_strategy"}, {"score": 0.002707444334463544, "phrase": "context-sensitive_variants"}, {"score": 0.002674681176379472, "phrase": "realistic_c_static_analyser"}, {"score": 0.0026423134393535243, "phrase": "experimental_results"}, {"score": 0.002436289099444074, "phrase": "program_queries"}, {"score": 0.002348883765159185, "phrase": "flow-and_context-sensitive_analysis"}, {"score": 0.0022011501095573747, "phrase": "baseline_flow-"}, {"score": 0.002183347623351868, "phrase": "context-insensitive_analysis"}, {"score": 0.0021049977753042253, "phrase": "fully_sensitive_version"}], "paper_keywords": ["Program Analysis", " Bayesian Optimization"], "paper_abstract": "Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this grim reputation is the difficulty in balancing the cost and the precision of an analyser. An ideal analyser should be adaptive to a given analysis task, and avoid using techniques that unnecessarily improve precision and increase analysis cost. However, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts. In this paper we present a new approach for building an adaptive static analyser. In our approach, the analyser includes a sophisticated parameterised strategy that decides, for each part of a given program, whether to apply a precision-improving technique to that part or not. We present a method for learning a good parameter for such a strategy from an existing codebase via Bayesian optimisation. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow- and context-sensitive variants of a realistic C static analyser. The experimental results demonstrate that using Bayesian optimisation is crucial for learning from an existing codebase. Also, they show that among all program queries that require flow- or context-sensitivity, our partially flow-and context-sensitive analysis answers the 75% of them, while increasing the analysis cost only by 3.3x of the baseline flow- and context-insensitive analysis, rather than 40x or more of the fully sensitive version.", "paper_title": "Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation", "paper_id": "WOS:000367256500033"}