{"auto_keywords": [{"score": 0.02362435145289292, "phrase": "gcc"}, {"score": 0.005914582617023224, "phrase": "llvm."}, {"score": 0.00481495049065317, "phrase": "value-graph_translation_validation"}, {"score": 0.004575053987970206, "phrase": "static_analyzers"}, {"score": 0.004347057700479576, "phrase": "program_transformations"}, {"score": 0.004201381218977942, "phrase": "normalizing_translation_validators"}, {"score": 0.0038253590626087237, "phrase": "original_function"}, {"score": 0.0033660587983313536, "phrase": "llvm's_intra-procedural_optimizations"}, {"score": 0.0028623555849897632, "phrase": "source_code"}], "paper_keywords": ["Algorithms", " languages", " reliability", " theory", " verification", " Translation validation", " symbolic evaluation", " LLVM", " optimization"], "paper_abstract": "Translation validators are static analyzers that attempt to verify that program transformations preserve semantics. Normalizing translation validators do so by trying to match the value-graphs of an original function and its transformed counterpart. In this paper, we present the design of such a validator for LLVM's intra-procedural optimizations, a design that does not require any instrumentation of the optimizer, nor any rewriting of the source code to compile, and needs to run only once to validate a pipeline of optimizations. We present the results of our preliminary experiments on a set of benchmarks that include GCC, a perl interpreter, SQLite3, and other C programs.", "paper_title": "Evaluating Value-Graph Translation Validation for LLVM", "paper_id": "WOS:000294609500026"}