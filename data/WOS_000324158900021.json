{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "private_deques"}, {"score": 0.02036568993915237, "phrase": "concurrent_deques"}, {"score": 0.009436821997089331, "phrase": "load_balancing"}, {"score": 0.004789760466836797, "phrase": "work_stealing"}, {"score": 0.0047149746167903465, "phrase": "effective_method"}, {"score": 0.004678018655587085, "phrase": "parallel_programs"}, {"score": 0.0046535416582068785, "phrase": "multicore_computers"}, {"score": 0.004604969434921559, "phrase": "high_performance"}, {"score": 0.004521179256835894, "phrase": "concurrent_queues"}, {"score": 0.004135296401536423, "phrase": "local_deque_operations"}, {"score": 0.0041136473765874815, "phrase": "expensive_memory_fences"}, {"score": 0.00409211122248989, "phrase": "modern_weak-memory_architectures"}, {"score": 0.0039341294012600085, "phrase": "flexible_forms"}, {"score": 0.003913529383328025, "phrase": "task_distribution_strategies"}, {"score": 0.0038726511261766377, "phrase": "e._g."}, {"score": 0.0035981701736904495, "phrase": "lot_recent_interest"}, {"score": 0.0035326342965847583, "phrase": "non-concurrent_deques"}, {"score": 0.0033255627814855163, "phrase": "memory_fences"}, {"score": 0.0033081387767897445, "phrase": "local_operations"}, {"score": 0.0032393479516888996, "phrase": "efficient_techniques"}, {"score": 0.003213920601037463, "phrase": "task-creation_overheads"}, {"score": 0.003188692204564829, "phrase": "task_distribution"}, {"score": 0.002985988377995789, "phrase": "theoretical_guarantees"}, {"score": 0.0027741761880779535, "phrase": "similar_theoretical_bounds"}, {"score": 0.002673957615079041, "phrase": "probabilistic_model"}, {"score": 0.002645992747675361, "phrase": "new_parameter"}, {"score": 0.0023694065215394593, "phrase": "flexible_task_creation"}, {"score": 0.0023261986886876336, "phrase": "specific_example"}, {"score": 0.002253949158637255, "phrase": "half_strategies"}, {"score": 0.0021441057555396013, "phrase": "graph_algorithms"}, {"score": 0.0021049977753042253, "phrase": "depth-first-search_problem"}], "paper_keywords": ["work stealing", " nested parallelism", " dynamic load balancing"], "paper_abstract": "Work stealing has proven to be an effective method for scheduling parallel programs on multicore computers. To achieve high performance, work stealing distributes tasks between concurrent queues, called deques, which are assigned to each processor. Each processor operates on its deque locally except when performing load balancing via steals. Unfortunately, concurrent deques suffer from two limitations: 1) local deque operations require expensive memory fences in modern weak-memory architectures, 2) they can be very difficult to extend to support various optimizations and flexible forms of task distribution strategies needed many applications, e. g., those that do not fit nicely into the divide-and-conquer, nested data parallel paradigm. For these reasons, there has been a lot recent interest in implementations of work stealing with non-concurrent deques, where deques remain entirely private to each processor and load balancing is performed via message passing. Private deques eliminate the need for memory fences from local operations and enable the design and implementation of efficient techniques for reducing task-creation overheads and improving task distribution. These advantages, however, come at the cost of communication. It is not known whether work stealing with private deques enjoys the theoretical guarantees of concurrent deques and whether they can be effective in practice. In this paper, we propose two work-stealing algorithms with private deques and prove that the algorithms guarantee similar theoretical bounds as work stealing with concurrent deques. For the analysis, we use a probabilistic model and consider a new parameter, the branching depth of the computation. We present an implementation of the algorithm as a C++ library and show that it compares well to Cilk on a range of benchmarks. Since our approach relies on private deques, it enables implementing flexible task creation and distribution strategies. As a specific example, we show how to implement task coalescing and steal-half strategies, which can be important in fine-grain, non-divide-and-conquer algorithms such as graph algorithms, and apply them to the depth-first-search problem.", "paper_title": "Scheduling Parallel Programs by Work Stealing with Private Deques", "paper_id": "WOS:000324158900021"}