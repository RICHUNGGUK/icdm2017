{"auto_keywords": [{"score": 0.02861484474712816, "phrase": "sigma"}, {"score": 0.00481495049065317, "phrase": "common_recurrent_patterns"}, {"score": 0.004785682967399109, "phrase": "multiple_strings"}, {"score": 0.004756592495553215, "phrase": "large_alphabets"}, {"score": 0.004698938469311569, "phrase": "short_recurring_patterns"}, {"score": 0.004502572578226444, "phrase": "gene_expression"}, {"score": 0.00442093689661089, "phrase": "efficient_deterministic_algorithm"}, {"score": 0.00435403401018622, "phrase": "identical_string_motifs"}, {"score": 0.004197551473726497, "phrase": "input_strings"}, {"score": 0.004096353910862841, "phrase": "n_different_strings"}, {"score": 0.0039611630554706205, "phrase": "exact_instances"}, {"score": 0.0037609217735040715, "phrase": "quorums_theta"}, {"score": 0.0032384375096920024, "phrase": "encoded_substring"}, {"score": 0.0031124046570971398, "phrase": "multiple_copies"}, {"score": 0.0027629000130849598, "phrase": "alphabet_sigma"}, {"score": 0.0025286424059485745, "phrase": "longest_identical_string_motif"}, {"score": 0.002482706594054615, "phrase": "experimental_purposes"}, {"score": 0.002437603221807513, "phrase": "real_biological_sequences"}, {"score": 0.002371476222721094, "phrase": "randomly_generated_sequences"}, {"score": 0.002244543215797895, "phrase": "linear_complexity"}, {"score": 0.002157106830907686, "phrase": "important_and_difficult_case"}, {"score": 0.00214396012113301, "phrase": "large_alphabet_inputs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["String motifs", " Conserved string motifs", " Sequence analysis", " Algorithms", " DNA", " Protein"], "paper_abstract": "Motifs are short recurring patterns that are of much interest as they help us understand the mechanism behind regulating gene expression. This paper presents an efficient deterministic algorithm that exhaustively discovers all identical string motifs of all sizes that appears in all or most of the input strings. The input is a set of n different strings each of length N. The problem is to discover all exact instances of any size occurring at least theta times per string in q or more input strings. The quorums theta and q are user set positive integers. The algorithm starts with substrings of size 2, and keeps augmenting them one symbol a time We encode the substrings, such that it is not possible to have two different substrings with the same encoding. After the sorting of the encoded substring, we can tell where, and which of the substrings have multiple copies. Next, we eliminate all the substrings that appear less than the quorums, and repeat the process. Theoretically the algorithm is competitive and scales extremely well with the size of the alphabet. For strings over the alphabet Sigma, it is O(nN + vertical bar Sigma vertical bar) in space, and O(nNL - nL(2)) in time, where L is the length of the longest identical string motif satisfying the constraint. For experimental purposes we applied the algorithm on real biological sequences (DNA and protein), and on randomly generated sequences using alphabet of sizes up to 1000 symbols. These experiments confirm that in practice the algorithm has indeed a linear complexity, both in space and time, making it practical for the important and difficult case of large alphabet inputs. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Discovering common recurrent patterns in multiple strings over large alphabets", "paper_id": "WOS:000349556800011"}