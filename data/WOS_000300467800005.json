{"auto_keywords": [{"score": 0.004686329649818146, "phrase": "intel"}, {"score": 0.0045302298105691615, "phrase": "new_instruction"}, {"score": 0.0042912493195237725, "phrase": "computational_bottleneck"}, {"score": 0.004148305776825594, "phrase": "iscsi"}, {"score": 0.004092468841742468, "phrase": "rdma"}, {"score": 0.003956113993518042, "phrase": "data_integrity_checks"}, {"score": 0.0035979378467361762, "phrase": "arbitrary_length"}, {"score": 0.00338493754743055, "phrase": "consecutive_chunks"}, {"score": 0.0025804616931593897, "phrase": "alternative_algorithm"}, {"score": 0.00222249726328354, "phrase": "oriented_ones"}, {"score": 0.0021049977753042253, "phrase": "pipelined_hardware"}], "paper_keywords": ["Algorithms", " Software design and implementation", " CRC", " ISCSI"], "paper_abstract": "Intel has recently introduced a new instruction, namely CRC32, to address a computational bottleneck in protocols such as ISCSI and RDMA that use CRC32C for data integrity checks. This instruction is designed to accumulate the CRC32C value of a buffer of arbitrary length, by a sequence of invocations that consume consecutive chunks of 8 bytes of the buffer per invocation. This instruction has latency of 3 cycles, and therefore using it serially allows software to process data at the rate of similar to 2.67 bytes per cycle. We introduce here an alternative algorithm for computing the CRC32C value of a buffer, using the same instruction. This algorithm converts the latency bounded computations to throughput oriented ones, and maximizes the utilization of the pipelined hardware that underlies the instruction, achieving speedup of a factor of almost 3. (C) 2011 Elsevier BM. All rights reserved.", "paper_title": "Speeding up CRC32C computations with Intel CRC32 instruction", "paper_id": "WOS:000300467800005"}