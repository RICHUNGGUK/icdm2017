{"auto_keywords": [{"score": 0.04907923672166454, "phrase": "memory_efficiency"}, {"score": 0.04461799901716509, "phrase": "ip_lookup"}, {"score": 0.041498423361887804, "phrase": "longer_prefix_lengths"}, {"score": 0.03504539381871914, "phrase": "total_memory_requirement"}, {"score": 0.00481495049065317, "phrase": "scalable_tree-based"}, {"score": 0.004742904841489477, "phrase": "prefix_partitioning"}, {"score": 0.004671932143798307, "phrase": "updateable_data_structures"}, {"score": 0.004643839937761046, "phrase": "internet_protocol"}, {"score": 0.004546834746561801, "phrase": "research_community"}, {"score": 0.004425072111844721, "phrase": "classic_tree-based_approach"}, {"score": 0.004372002674739612, "phrase": "longest_prefix"}, {"score": 0.004116012194714212, "phrase": "large_and_sparsely_distributed_routing_tables"}, {"score": 0.0038749521906474593, "phrase": "tree-based_lpm"}, {"score": 0.003771114171630529, "phrase": "memory_stages"}, {"score": 0.0036369902631756363, "phrase": "dpp"}, {"score": 0.0035609154384221567, "phrase": "k_groups"}, {"score": 0.003539479990299223, "phrase": "disjoint_prefixes"}, {"score": 0.0034342161742428635, "phrase": "dynamic_programming"}, {"score": 0.0033929894721242367, "phrase": "optimal_split_lengths"}, {"score": 0.0032722454818973853, "phrase": "substantial_reduction"}, {"score": 0.0032427347282370225, "phrase": "memory_footprint"}, {"score": 0.0030991131563500446, "phrase": "linear_pipelined_architectures"}, {"score": 0.00306189690236109, "phrase": "high_throughput"}, {"score": 0.0030342774028555377, "phrase": "incremental_updates"}, {"score": 0.0029707940194245216, "phrase": "proposed_algorithm"}, {"score": 0.0025388705701873075, "phrase": "state-of-the-art_fpga_device"}, {"score": 0.0022909325048608054, "phrase": "larger_routing_tables"}, {"score": 0.0022771244331421586, "phrase": "longer_prefix_length"}, {"score": 0.0021960024679620886, "phrase": "proposed_architectures"}, {"score": 0.002163058716517137, "phrase": "external_srams"}, {"score": 0.002124176532827015, "phrase": "on-chip_memory"}, {"score": 0.0021049977753042253, "phrase": "target_devices"}], "paper_keywords": ["IP Lookup", " longest prefix matching", " reconfigurable", " field-programmable gate array (FPGA)", " pipeline", " partitioning"], "paper_abstract": "Memory efficiency and dynamically updateable data structures for Internet Protocol (IP) lookup have regained much interest in the research community. In this paper, we revisit the classic tree-based approach for solving the longest prefix matching (LPM) problem used in IP lookup. In particular, we target our solutions for a class of large and sparsely distributed routing tables, such as those potentially arising in the next-generation IPv6 routing protocol. Due to longer prefix lengths and much larger address space, preprocessing such routing tables for tree-based LPM can significantly increase the number of prefixes and/or memory stages required for IP lookup. We propose a prefix partitioning algorithm (DPP) to divide a given routing table into k groups of disjoint prefixes (k is given). The algorithm employs dynamic programming to determine the optimal split lengths between the groups to minimize the total memory requirement. Our algorithm demonstrates a substantial reduction in the memory footprint compared with those of the state of the art in both IPv4 and IPv6 cases. Two proposed linear pipelined architectures, which achieve high throughput and support incremental updates, are also presented. The proposed algorithm and architectures achieve a memory efficiency of 1 byte of memory for each byte of prefix for both IPv4 and IPv6. As a result, our design scales well to support either larger routing tables, longer prefix lengths, or both. The total memory requirement depends solely on the number of prefixes. Implementations on 45 nm ASIC and a state-of-the-art FPGA device (for a routing table consisting of 330K prefixes) show that our algorithm achieves 980 and 410 million lookups per second, respectively. These results are well suited for 100 Gbps lookup. The implementations also scale to support larger routing tables and longer prefix length when we go from IPv4 to IPv6. Additionally, the proposed architectures can easily interface with external SRAMs to ease the limitation of on-chip memory of the target devices.", "paper_title": "Scalable Tree-Based Architectures for IPv4/v6 Lookup Using Prefix Partitioning", "paper_id": "WOS:000304448100009"}