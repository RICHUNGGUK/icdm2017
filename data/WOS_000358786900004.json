{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "temporal_graphs"}, {"score": 0.02451187547921387, "phrase": "immortalgraph"}, {"score": 0.004684157900507474, "phrase": "graph_changes"}, {"score": 0.004556901872357751, "phrase": "increasing_interest"}, {"score": 0.004506968388996092, "phrase": "research_communities"}, {"score": 0.00433645229352341, "phrase": "temporal_characteristics"}, {"score": 0.00428892403807229, "phrase": "social_interactions"}, {"score": 0.004218602458288531, "phrase": "time-evolving_social_graph"}, {"score": 0.004058951880810154, "phrase": "execution_engine"}, {"score": 0.003757480190200645, "phrase": "immortalgraph's_design"}, {"score": 0.0035755653799043, "phrase": "persistent_storage"}, {"score": 0.003459191419478298, "phrase": "account_data_locality"}, {"score": 0.0031845067058084583, "phrase": "locality-aware_batch_scheduling"}, {"score": 0.0030808211830129304, "phrase": "common_\"bulk\"_operations"}, {"score": 0.0028993944292191433, "phrase": "in-memory_data_locality"}, {"score": 0.0027741761880779535, "phrase": "interesting_interplay"}, {"score": 0.002669042572650594, "phrase": "incremental_computation"}, {"score": 0.0026252106881752067, "phrase": "common_mining_tasks"}, {"score": 0.002511803988580901, "phrase": "high-performance_temporal-graph_system"}, {"score": 0.0023768935613577985, "phrase": "existing_database_solutions"}, {"score": 0.0023507916951658455, "phrase": "graph_queries"}, {"score": 0.002312174113289583, "phrase": "locality_optimizations"}, {"score": 0.002200077887697072, "phrase": "magnitude_speedup"}, {"score": 0.002175913488493802, "phrase": "temporal_iterative_graph_mining"}, {"score": 0.002128376306688074, "phrase": "straightforward_application"}, {"score": 0.0021049977753042253, "phrase": "existing_graph_engines"}], "paper_keywords": ["Design", " Algorithms", " Concurrent computing", " temporal graph", " graph algorithms"], "paper_abstract": "Temporal graphs that capture graph changes over time are attracting increasing interest from research communities, for functions such as understanding temporal characteristics of social interactions on a time-evolving social graph. ImmortalGraph is a storage and execution engine designed and optimized specifically for temporal graphs. Locality is at the center of ImmortalGraph's design: temporal graphs are carefully laid out in both persistent storage and memory, taking into account data locality in both time and graph-structure dimensions. ImmortalGraph introduces the notion of locality-aware batch scheduling in computation, so that common \"bulk\" operations on temporal graphs are scheduled to maximize the benefit of in-memory data locality. The design of ImmortalGraph explores an interesting interplay among locality, parallelism, and incremental computation in supporting common mining tasks on temporal graphs. The result is a high-performance temporal-graph system that is up to 5 times more efficient than existing database solutions for graph queries. The locality optimizations in ImmortalGraph offer up to an order of magnitude speedup for temporal iterative graph mining compared to a straightforward application of existing graph engines on a series of snapshots.", "paper_title": "ImmortalGraph: A System for Storage and Analysis of Temporal Graphs", "paper_id": "WOS:000358786900004"}