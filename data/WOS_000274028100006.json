{"auto_keywords": [{"score": 0.0401960790312752, "phrase": "smash"}, {"score": 0.014812311741026154, "phrase": "program_executions"}, {"score": 0.004778923541463994, "phrase": "program_analysis_tools"}, {"score": 0.0038721890530859578, "phrase": "new_algorithm"}, {"score": 0.003659890662429693, "phrase": "procedure_boundary"}, {"score": 0.003344076203780408, "phrase": "demand-driven_manner"}, {"score": 0.003172551230409948, "phrase": "predicate_abstraction"}, {"score": 0.003043957650600757, "phrase": "dynamic_test_generation"}, {"score": 0.00266837303806956, "phrase": "large_programs"}, {"score": 0.002560162916190598, "phrase": "specific_property"}, {"score": 0.002465593351432208, "phrase": "directed_testing"}, {"score": 0.002437907960209364, "phrase": "fine-grained_coupling"}, {"score": 0.0022781884538102264, "phrase": "code_fragments"}], "paper_keywords": ["Verification", " Abstraction refinement", " Directed testing", " Software model checking"], "paper_abstract": "Program analysis tools typically compute two types of information: (1) may information that is true of all program executions and is used to prove the absence of bugs in the program, and (2) must information that is true of some program executions and is used to prove the existence of bugs in the program. In this paper, we propose a new algorithm, dubbed SMASH, which computes both may and must information compositionally. At each procedure boundary, may and must information is represented and stored as may and must summaries, respectively. Those summaries are computed in a demand-driven manner and possibly using summaries of the opposite type. We have implemented SMASH using predicate abstraction (as in SLAM) for the may part and using dynamic test generation (as in DART) for the must part. Results of experiments with 69 Microsoft Windows 7 device drivers show that SMASH can significantly outperform may-only, must-only and non-compositional may-must algorithms. Indeed, our empirical results indicate that most complex code fragments in large programs are actually often either easy to prove irrelevant to the specific property of interest using may analysis or easy to traverse using directed testing. The fine-grained coupling and alternation of may (universal) and must (existential) summaries allows SMASH to easily navigate through these code fragments while traditional may-only, must-only or non-compositional may-must algorithms are stuck in their specific analyses.", "paper_title": "Compositional May-Must Program Analysis: Unleashing the Power of Alternation", "paper_id": "WOS:000274028100006"}