{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "type_classes"}, {"score": 0.04952525101149597, "phrase": "type_families"}, {"score": 0.004704187604192605, "phrase": "key_ingredients"}, {"score": 0.00464976086880886, "phrase": "haskell_programming"}, {"score": 0.004438250823243621, "phrase": "ad-hoc_polymorphism"}, {"score": 0.0042610532651691305, "phrase": "functional_dependencies"}, {"score": 0.004138813595009761, "phrase": "type-level_programming"}, {"score": 0.003996727479807572, "phrase": "encoding_type-level_functions"}, {"score": 0.003792657064634775, "phrase": "rewrite_rules"}, {"score": 0.003435092524339692, "phrase": "overlapping_instances"}, {"score": 0.0032978134802348433, "phrase": "formal_proof"}, {"score": 0.003093054709625219, "phrase": "instance_constraints"}, {"score": 0.0029694040368299624, "phrase": "proposed_extensions"}, {"score": 0.002867348342846275, "phrase": "closed_sets"}, {"score": 0.00280126189041041, "phrase": "instance_chains"}, {"score": 0.0027049694095434905, "phrase": "search_procedure"}, {"score": 0.002244494905883452, "phrase": "current_haskell"}, {"score": 0.0021049977753042253, "phrase": "rewriting_phase"}], "paper_keywords": ["Type classes", " Type families", " Haskell", " Elaboration", " Functional dependencies", " Directives"], "paper_abstract": "Type classes and type families are key ingredients in Haskell programming. Type classes were introduced to deal with ad-hoc polymorphism, although with the introduction of functional dependencies, their use expanded to type-level programming. Type families also allow encoding type-level functions, but more directly in the form of rewrite rules. In this paper we show that type families are powerful enough to simulate type classes (without overlapping instances), and we provide a formal proof of the soundness and completeness of this simulation. Encoding instance constraints as type families eases the path to proposed extensions to type classes, like closed sets of instances, instance chains, and control over the search procedure. The only feature which type families cannot simulate is elaboration, that is, generating code from the derivation of a rewriting. We look at ways to solve this problem in current Haskell, and propose an extension to allow elaboration during the rewriting phase.", "paper_title": "Type Families with Class, Type Classes with Family", "paper_id": "WOS:000370549100013"}