{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "potential_deadlocks"}, {"score": 0.0496708883687454, "phrase": "static_analysis"}, {"score": 0.03441652477229552, "phrase": "run-time_checking"}, {"score": 0.008487237288646306, "phrase": "deadlock_types"}, {"score": 0.00473320761888448, "phrase": "run-time_monitoring"}, {"score": 0.004692880700811315, "phrase": "concurrent"}, {"score": 0.004382127278148236, "phrase": "common_kind"}, {"score": 0.004344755264641137, "phrase": "concurrency_error"}, {"score": 0.0037719988989298983, "phrase": "havelund"}, {"score": 0.003537155405923517, "phrase": "exactly_two_threads"}, {"score": 0.003447349911141396, "phrase": "generalized_version"}, {"score": 0.0034033029171804106, "phrase": "goodlock_algorithm"}, {"score": 0.00319134078848996, "phrase": "unexecuted_code"}, {"score": 0.003137074867443131, "phrase": "positive_side"}, {"score": 0.0027821202902740846, "phrase": "extended_parameterized_atomic_java"}, {"score": 0.0026538960171433985, "phrase": "atomicity_violations"}, {"score": 0.0026199603775129516, "phrase": "boyapati_et_al"}, {"score": 0.0023434058350520763, "phrase": "type_inference"}, {"score": 0.0023134312557290043, "phrase": "run-time_checks"}, {"score": 0.002244969789802093, "phrase": "new_type_system"}, {"score": 0.002216251512062482, "phrase": "deadlock-free_epaj"}, {"score": 0.002150659690967412, "phrase": "added_benefit"}, {"score": 0.0021231452870210965, "phrase": "stronger_atomicity_guarantees"}, {"score": 0.0021049977753042253, "phrase": "previous_atomicity_type_systems"}], "paper_keywords": [""], "paper_abstract": "Concurrent programs are notorious for containing errors that are difficult to reproduce and diagnose. A common kind of concurrency error is deadlock, which occurs when a set of threads is blocked each trying to acquire a lock held by another thread in that set. Static and dynamic (run-time) analysis techniques exist to detect deadlocks. Havelund's GoodLock algorithm detects potential deadlocks at runtime. However, it detects only potential deadlocks involving exactly two threads. This paper presents a generalized version of the GoodLock algorithm that detects potential deadlocks involving any number of threads. Run-time checking may miss errors in unexecuted code. On the positive side, run-time checking generally produces fewer false alarms than static analysis. This paper explores the use of static analysis to automatically reduce the overhead of run-time checking. We extend our type system, Extended Parameterized Atomic Java (EPAJ), which ensures absence of races and atomicity violations, with Boyapati et al.'s deadlock types. We give an algorithm that infers deadlock types for a given program and an algorithm that determines, based on the result of type inference, which run-time checks can safely be omitted. The new type system, called Deadlock-Free EPAJ (DEPAJ), has the added benefit of giving stronger atomicity guarantees than previous atomicity type systems.", "paper_title": "Detecting potential deadlocks with static analysis and run-time monitoring", "paper_id": "WOS:000237451000014"}