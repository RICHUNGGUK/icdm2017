{"auto_keywords": [{"score": 0.027252920471074818, "phrase": "rtalk"}, {"score": 0.010612387000973441, "phrase": "program_analyses"}, {"score": 0.00803398074448574, "phrase": "null"}, {"score": 0.004784448637292493, "phrase": "programmer_productivity_tools"}, {"score": 0.00454725669814484, "phrase": "productivity_tools"}, {"score": 0.004081385289516914, "phrase": "programmer_and_program_analyses"}, {"score": 0.0033508547759861186, "phrase": "different_vocabularies"}, {"score": 0.0032150572968898923, "phrase": "simplified_representation"}, {"score": 0.0031044458412608084, "phrase": "source_code"}, {"score": 0.0029786045405384926, "phrase": "source_language"}, {"score": 0.0028397103530211415, "phrase": "ssa_form"}, {"score": 0.0024063484128685367, "phrase": "analysis'_vocabulary"}, {"score": 0.002222149081895309, "phrase": "program_understanding"}, {"score": 0.0022010126160835024, "phrase": "optimization_tools"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["program analyses", " analysis communication", " programmer interaction"], "paper_abstract": "Because software continues to grow in size and complexity, programmers increasingly rely on productivity tools to understand, debug, and modify their programs. These tools typically use program analyses to produce information for the programmer. This is problematic because it is based on the assumption that the programmer and program analyses all use the same vocabulary. If the programmer and analyses did not use the same vocabulary then the results of the analyses will be meaningless to the programmer. For example, 'v124 may be NULL' does not mean much to the programmer but 'myStack may be NULL' is meaningful. Often, the programmer and analyses prefer different vocabularies. While the programmer prefers his programs' source code, an analysis will prefer a simplified representation. Unfortunately, writing an analysis that works on the source code is difficult because the analysis must deal with the idiosyncracies of the source language (e. g. nested classes). In comparison, writing an analysis on SSA form is easy but the output of the analysis is not meaningful to the programmer; it must somehow be translated into something the programmer understands. We present a system, RTalk, that makes it easy to support both the programmers' and the analysis' needs. RTalk generates a translator between the programmers' and the analysis' vocabulary. Thus both the programmer and the analysis can use the vocabulary most natural to them. We demonstrate the effectiveness of RTalk by describing program understanding and program optimization tools that we have already built using RTalk. Copyright (C) 2011 John Wiley & Sons, Ltd.", "paper_title": "Integrating program analyses with programmer productivity tools", "paper_id": "WOS:000290810300004"}