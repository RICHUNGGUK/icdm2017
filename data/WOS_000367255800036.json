{"auto_keywords": [{"score": 0.033774157571272015, "phrase": "optimal_error_source"}, {"score": 0.03310342048452109, "phrase": "principal_types"}, {"score": 0.00481495049065317, "phrase": "statically_typed_functional_programming_languages"}, {"score": 0.004716520738331953, "phrase": "confusing_type_error_messages"}, {"score": 0.0045820747375409435, "phrase": "type_error"}, {"score": 0.00446987606516801, "phrase": "program_location"}, {"score": 0.004098291340525772, "phrase": "actual_root_cause"}, {"score": 0.003916098498242888, "phrase": "possible_error_sources"}, {"score": 0.003804381587788162, "phrase": "usefulness_criterion"}, {"score": 0.0035755653799043, "phrase": "optimization_problem"}, {"score": 0.003531474887552889, "phrase": "satisfiability_modulo_theories"}, {"score": 0.0033883824438527316, "phrase": "heuristic_nature"}, {"score": 0.003360464999544279, "phrase": "usefulness_criteria"}, {"score": 0.0033190180867511605, "phrase": "underlying_search_problem"}, {"score": 0.003030247482854539, "phrase": "exponential-time_complexity"}, {"score": 0.0029928611380840757, "phrase": "decision_problem"}, {"score": 0.002968192753809507, "phrase": "polymorphic_type_checking"}, {"score": 0.0028596699752849682, "phrase": "new_algorithm"}, {"score": 0.0026986685585382347, "phrase": "improved_smt_encoding"}, {"score": 0.002643386043540555, "phrase": "high_complexity"}, {"score": 0.002621590601574503, "phrase": "polymorphic_typing"}, {"score": 0.0025678829712650437, "phrase": "typing_constraints"}, {"score": 0.0024535580495414783, "phrase": "clean_separation"}, {"score": 0.002393353846080347, "phrase": "actual_search"}, {"score": 0.00232498306843282, "phrase": "ocaml"}, {"score": 0.002184943946549964, "phrase": "optimal_type_error_localization"}, {"score": 0.0021049977753042253, "phrase": "previous_localization_algorithms"}], "paper_keywords": ["Type Error Localization", " Satisfiability Modulo Theories", " Polymorphic Types"], "paper_abstract": "Compilers for statically typed functional programming languages are notorious for generating confusing type error messages. When the compiler detects a type error, it typically reports the program location where the type checking failed as the source of the error. Since other error sources are not even considered, the actual root cause is often missed. A more adequate approach is to consider all possible error sources and report the most useful one subject to some usefulness criterion. In our previous work, we showed that this approach can be formulated as an optimization problem related to satisfiability modulo theories (SMT). This formulation cleanly separates the heuristic nature of usefulness criteria from the underlying search problem. Unfortunately, algorithms that search for an optimal error source cannot directly use principal types which are crucial for dealing with the exponential-time complexity of the decision problem of polymorphic type checking. In this paper, we present a new algorithm that efficiently finds an optimal error source in a given ill-typed program. Our algorithm uses an improved SMT encoding to cope with the high complexity of polymorphic typing by iteratively expanding the typing constraints from which principal types are derived. The algorithm preserves the clean separation between the heuristics and the actual search. We have implemented our algorithm for OCaml. In our experimental evaluation, we found that the algorithm reduces the running times for optimal type error localization from minutes to seconds and scales better than previous localization algorithms.", "paper_title": "Practical SMT-Based Type Error Localization", "paper_id": "WOS:000367255800036"}