{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "refinement_calculus"}, {"score": 0.0046797114400479135, "phrase": "high-level_language_program_compilation_strategies"}, {"score": 0.00388828234270598, "phrase": "refinement_steps"}, {"score": 0.0037789720824759503, "phrase": "source_code"}, {"score": 0.0036207206487324506, "phrase": "machine-level_description"}, {"score": 0.003051073364818384, "phrase": "recursively-defined_procedures"}, {"score": 0.002923214590192792, "phrase": "well-established_predicate_transformer_semantics"}, {"score": 0.0022933216359142736, "phrase": "stack_frames"}, {"score": 0.0021659920594094407, "phrase": "run_time"}, {"score": 0.0021049977753042253, "phrase": "procedure_parameters"}], "paper_keywords": ["program refinement", " program compilation", " procedures", " predicate transformers"], "paper_abstract": "High-level language program compilation strategies can be proven correct by modelling the process as a series of refinement steps from source code to a machine-level description. We show how this can be done for programs containing recursively-defined procedures in the well-established predicate transformer semantics for refinement. To do so the formalism is extended with an abstraction of the way stack frames are created at run time for procedure parameters and variables.", "paper_title": "Procedure compilation in the refinement calculus", "paper_id": "WOS:000238766200004"}