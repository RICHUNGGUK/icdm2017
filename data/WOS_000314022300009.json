{"auto_keywords": [{"score": 0.0495290999002817, "phrase": "word-oriented_memories"}, {"score": 0.039452474962437374, "phrase": "fault_addresses"}, {"score": 0.00481495049065317, "phrase": "optimal_repair_rate"}, {"score": 0.004597457370802855, "phrase": "built-in_self_repair_analyzer"}, {"score": 0.004415189385015778, "phrase": "memory_arrays"}, {"score": 0.004289419884432487, "phrase": "proposed_method"}, {"score": 0.004119313626110943, "phrase": "worst_case"}, {"score": 0.004001938457469328, "phrase": "must-repair_analysis"}, {"score": 0.003463196032143783, "phrase": "stored_fault_addresses"}, {"score": 0.0033644530302903513, "phrase": "possible_solutions"}, {"score": 0.0033257460346754687, "phrase": "existing_techniques"}, {"score": 0.003268516165008941, "phrase": "first_search"}, {"score": 0.003156984631072011, "phrase": "finite-state_machine"}, {"score": 0.003031650815900696, "phrase": "new_algorithm"}, {"score": 0.002795671770303977, "phrase": "parallel_prefix_algorithm"}, {"score": 0.0026384167183586015, "phrase": "area_and_test_time_requirements"}, {"score": 0.002447101794397243, "phrase": "content_addressable_memory_entries"}, {"score": 0.0022176487309947266, "phrase": "repair_elements"}], "paper_keywords": ["Built-in self repair (BISR)", " memory test", " redundancy allocation", " repair analysis", " spare allocation"], "paper_abstract": "This paper presents a built-in self repair analyzer with the optimal repair rate for memory arrays with redundancy. The proposed method requires only a single test, even in the worst case. By performing the must-repair analysis on the fly during the test, it selectively stores fault addresses, and the final analysis to find a solution is performed on the stored fault addresses. To enumerate all possible solutions, existing techniques use depth first search using a stack and a finite-state machine. Instead, we propose a new algorithm and its combinational circuit implementation. Since our formulation for the circuit allows us to use the parallel prefix algorithm, it can be configured in various ways to meet area and test time requirements. The total area of our infrastructure is dominated by the number of content addressable memory entries to store the fault addresses, and it only grows quadratically with respect to the number of repair elements. The infrastructure is also extended to support various types of word-oriented memories.", "paper_title": "A Built-In Repair Analyzer With Optimal Repair Rate for Word-Oriented Memories", "paper_id": "WOS:000314022300009"}