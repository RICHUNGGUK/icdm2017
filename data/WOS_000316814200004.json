{"auto_keywords": [{"score": 0.02246846748295755, "phrase": "sparkle"}, {"score": 0.00481495049065317, "phrase": "editor-based_programming"}, {"score": 0.004757643419056999, "phrase": "state-based_interactive_applications"}, {"score": 0.004454377387615279, "phrase": "web_application"}, {"score": 0.0042459818200777846, "phrase": "interconnected_editors"}, {"score": 0.004195418010131832, "phrase": "structured_values"}, {"score": 0.003789137457228946, "phrase": "gec_and_idata_toolkits"}, {"score": 0.003677280504320636, "phrase": "high_level"}, {"score": 0.0035901685646972585, "phrase": "programming_desktop_and_web_gui_applications"}, {"score": 0.002981216610222911, "phrase": "arrow_framework"}, {"score": 0.002945669860541221, "phrase": "present_editorarrow"}, {"score": 0.0027741761880779535, "phrase": "shared_state_and_event_handling"}, {"score": 0.0026600905156986317, "phrase": "editorarrow"}, {"score": 0.0024604876113911173, "phrase": "definedness_properties"}, {"score": 0.002373472641477602, "phrase": "reference_implementation"}, {"score": 0.0023311233166534214, "phrase": "editorarrow_model"}, {"score": 0.002262209824105154, "phrase": "small_program_examples"}, {"score": 0.0022085455097790537, "phrase": "formal_reasoning"}], "paper_keywords": [""], "paper_abstract": "State-based interactive applications, whether they run on the desktop or as a web application, can be considered as collections of interconnected editors of structured values that allow users to manipulate data. This is the view that is advocated by the GEC and iData toolkits, which offer a high level of abstraction to programming desktop and web GUI applications respectively. Special features of these toolkits are that editors have shared, persistent state, and that they handle events individually. In this paper we cast these toolkits within the Arrow framework and present EditorArrow: a single, unified semantic model that defines shared state and event handling. We study the properties of EditorArrow, and of editors in particular. Furthermore, we present the definedness properties of the combinators. A reference implementation of the EditorArrow model is given with some small program examples. We discuss formal reasoning about the model using the proof assistant Sparkle. The availability of this tool has proved to be indispensable in this endeavor.", "paper_title": "EditorArrow: An arrow-based model for editor-based programming", "paper_id": "WOS:000316814200004"}