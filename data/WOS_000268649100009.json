{"auto_keywords": [{"score": 0.0498021329116458, "phrase": "flash_memory"}, {"score": 0.008713768692145006, "phrase": "database_management_systems"}, {"score": 0.005931710567595135, "phrase": "buffer_replacement_algorithm"}, {"score": 0.004745665541429529, "phrase": "growing_storage_capacity"}, {"score": 0.004583403452794034, "phrase": "small_mobile_devices"}, {"score": 0.004517435235940661, "phrase": "mobile_phones"}, {"score": 0.004375580474509386, "phrase": "tpc-c_benchmark"}, {"score": 0.004225950334493496, "phrase": "hard_disk_drives"}, {"score": 0.004189337956225294, "phrase": "unique_characteristics"}, {"score": 0.004129017936622578, "phrase": "direct_application"}, {"score": 0.004093241899787004, "phrase": "existing_dbmss"}, {"score": 0.003884977091580757, "phrase": "flash_suffer"}, {"score": 0.0037738708560271354, "phrase": "full_advantage"}, {"score": 0.003644714340300824, "phrase": "small_percentage"}, {"score": 0.0030888830649190282, "phrase": "first_shortcoming"}, {"score": 0.0028229469652714507, "phrase": "cost-based_approach"}, {"score": 0.0027903390304306335, "phrase": "optimal_column_groupings"}, {"score": 0.0027183379628570835, "phrase": "heuristic_solution"}, {"score": 0.00269475174341129, "phrase": "partitioning_problem"}, {"score": 0.0024987020562103448, "phrase": "cost_model"}, {"score": 0.002469830206270585, "phrase": "expected_read"}, {"score": 0.002448394921890037, "phrase": "energy_usage"}, {"score": 0.002385196172577967, "phrase": "leutenegger"}, {"score": 0.00237137451107918, "phrase": "d._dias"}, {"score": 0.0022834609591262977, "phrase": "acm_sigmod"}, {"score": 0.0021670777282518424, "phrase": "energy_usage_savings"}, {"score": 0.0021420294823879292, "phrase": "state-of-the-art_in-page_logging_approach"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Flash memory", " Database", " Caching", " Buffer replacement", " Vertical partitioning", " Database optimization"], "paper_abstract": "The growing storage capacity of flash memory (up to 640 GB) and the proliferation of small mobile devices such as PDAs and mobile phones makes it attractive to build database management systems (DBMSs) on top of flash memory. However, most existing DBMSs are designed to run on hard disk drives. The unique characteristics of flash memory make the direct application of these existing DBMSs to flash memory very energy inefficient and slow. The relatively few DBMSs that are designed for flash suffer from two major short-comings. First, they do not take full advantage of the fact that updates to tuples usually only involve a small percentage of the attributes. A tuple refers to a row of a table in a database. Second, they do not cater for the asymmetry of write versus read costs of flash memory when designing the buffer replacement algorithm. In this paper, we have developed algorithms that address both of these short-comings. We overcome the first shortcoming by partitioning tables into columns and then group the columns based on which columns are read or updated together. To this end, we developed an algorithm that uses a cost-based approach, which produces optimal column groupings for a given workload. We also propose a heuristic solution to the partitioning problem. The second short-coming is overcome by the design of the buffer replacement algorithm that automatically determines which page to evict from buffer based on a cost model that minimizes the expected read and write energy usage. Experiments using the TPC-C benchmark [S.T, Leutenegger, D. Dias, A modeling study of the TPC-C benchmark, in: Proceedings of ACM SIGMOD, 1993, pp. 22-31] show that our approach produces up to 40-fold in energy usage savings compared to the state-of-the-art in-page logging approach. (C) 2009 Elsevier Inc. All rights reserved.", "paper_title": "Fine-grained updates in database management systems for flash memory", "paper_id": "WOS:000268649100009"}