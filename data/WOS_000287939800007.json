{"auto_keywords": [{"score": 0.025989646938442575, "phrase": "dsu"}, {"score": 0.00481495049065317, "phrase": "dynamic_software"}, {"score": 0.0047602693158272655, "phrase": "parallel_high-performance_applications"}, {"score": 0.004688321299229397, "phrase": "multiple_concurrent_processors"}, {"score": 0.00463507149599759, "phrase": "typical_high-performance_parallel_application"}, {"score": 0.004295136518467118, "phrase": "running_high-performance_parallel_application"}, {"score": 0.003995226376780718, "phrase": "updated_version"}, {"score": 0.0036183419672924095, "phrase": "dynamic_software_updates"}, {"score": 0.00348300993356662, "phrase": "parallel_application"}, {"score": 0.003378385493203297, "phrase": "programmer's_time"}, {"score": 0.0033399639721674954, "phrase": "expensive_computing_resources"}, {"score": 0.003276893480994257, "phrase": "net_effect"}, {"score": 0.0032396224508754387, "phrase": "parallel_applications"}, {"score": 0.0031784407245606704, "phrase": "total_time"}, {"score": 0.002867425368894356, "phrase": "dynamic_updates"}, {"score": 0.0028456326741466494, "phrase": "high_performance_applications"}, {"score": 0.0027812405653371503, "phrase": "two-pronged_approach"}, {"score": 0.002636587060621144, "phrase": "dynamically_updating_applications"}, {"score": 0.002596653214530156, "phrase": "parallel_cluster"}, {"score": 0.002537880772794665, "phrase": "large_body"}, {"score": 0.0024899186481178075, "phrase": "existing_state"}, {"score": 0.0023424328921363585, "phrase": "high-performance_applications"}, {"score": 0.0022375675189464715, "phrase": "powerful_tool"}, {"score": 0.0021620042653528846, "phrase": "high-performance_parallel_applications"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["dynamic software updates", " high-performance applications", " binary rewriting", " HotSwap"], "paper_abstract": "Despite using multiple concurrent processors, a typical high-performance parallel application is long-running, taking hours, even days to arrive at a solution. To modify a running high-performance parallel application, the programmer has to stop the computation, change the code, redeploy, and enqueue the updated version to be scheduled to run, thus wasting not only the programmer's time, but also expensive computing resources. To address these inefficiencies, this article describes how dynamic software updates (DSU) can be used to modify a parallel application on the fly, thus saving the programmer's time and using expensive computing resources more productively. The net effect of updating parallel applications dynamically can reduce the total time that elapses between posing a problem and arriving at a solution, otherwise known as time-to-discovery. To explore the benefits of dynamic updates for high performance applications, this article takes a two-pronged approach. First, we describe our experiences of building and evaluating a system for dynamically updating applications running on a parallel cluster. We then review a large body of literature describing the existing state of the art in DSU and point out how this research can be applied to high-performance applications. Our experimental results indicate that DSU have the potential to become a powerful tool in reducing time-to-discovery for high-performance parallel applications. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "Dynamic software updates for parallel high-performance applications", "paper_id": "WOS:000287939800007"}