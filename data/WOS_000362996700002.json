{"auto_keywords": [{"score": 0.04449906714128008, "phrase": "silent_errors"}, {"score": 0.00481495049065317, "phrase": "numerical_time-stepping_schemes"}, {"score": 0.0046875099587735825, "phrase": "hardware_or_low-level_software_problems"}, {"score": 0.004165497627464024, "phrase": "application_state"}, {"score": 0.004077005481951783, "phrase": "low-level_error_detection"}, {"score": 0.00366185681714204, "phrase": "computed_results"}, {"score": 0.0035648266669315943, "phrase": "new_paradigm"}, {"score": 0.003451766520526601, "phrase": "application_level"}, {"score": 0.0033243718810317254, "phrase": "computed_values"}, {"score": 0.0032189132350239013, "phrase": "cheap_checking_computation"}, {"score": 0.0031335830806256777, "phrase": "error_detectors"}, {"score": 0.002985631781749091, "phrase": "numerical_analysis"}, {"score": 0.0029221312451219203, "phrase": "usable_checking_computations"}, {"score": 0.0028446460307503343, "phrase": "initial-value_problems"}, {"score": 0.0027543636132088332, "phrase": "arguably_the_most_common_problems"}, {"score": 0.0025137990854120075, "phrase": "runge-kutta"}, {"score": 0.0024868972942701582, "phrase": "linear_multistep_methods"}, {"score": 0.002407941567598653, "phrase": "implicit_and_explicit_finite_difference_schemes"}, {"score": 0.0023189818169615135, "phrase": "heat_equation"}, {"score": 0.0022941723937662927, "phrase": "navier-stokes_equations"}, {"score": 0.002209406458446019, "phrase": "artificially_injected_errors"}, {"score": 0.0021392418081444798, "phrase": "almost_all_meaningful_errors"}, {"score": 0.0021049977753042253, "phrase": "significant_slowdown"}], "paper_keywords": ["Silent errors", " resilience", " Runge-Kutta", " linear multi-step methods", " heat equation", " initial-value problems"], "paper_abstract": "Errors due to hardware or low-level software problems, if detected, can be fixed by various schemes, such as recomputation from a checkpoint. Silent errors are errors in application state that have escaped low-level error detection. At extreme scale, where machines can perform astronomically many operations per second, silent errors threaten the validity of computed results. We propose a new paradigm for detecting silent errors at the application level. Our central idea is to frequently compare computed values to those provided by a cheap checking computation, and to build error detectors based on the difference between the two output sequences. Numerical analysis provides us with usable checking computations for the solution of initial-value problems in ODEs and PDEs, arguably the most common problems in computational science. Here, we provide, optimize, and test methods based on Runge-Kutta and linear multistep methods for ODEs, and on implicit and explicit finite difference schemes for PDEs. We take the heat equation and Navier-Stokes equations as examples. In tests with artificially injected errors, this approach effectively detects almost all meaningful errors, without significant slowdown.", "paper_title": "Silent error detection in numerical time-stepping schemes", "paper_id": "WOS:000362996700002"}