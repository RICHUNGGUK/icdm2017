{"auto_keywords": [{"score": 0.04132712815039597, "phrase": "adb"}, {"score": 0.008220188539212586, "phrase": "multiple_power_modes"}, {"score": 0.005848808483794167, "phrase": "adb_allocation"}, {"score": 0.00481495049065317, "phrase": "adjustable_delay_buffers"}, {"score": 0.004740197030914445, "phrase": "clock_skew"}, {"score": 0.004695900553353526, "phrase": "multiple_power_mode_designs"}, {"score": 0.004637478829869904, "phrase": "clock_skew_constraint"}, {"score": 0.004536976344964643, "phrase": "clock_tree_synthesis"}, {"score": 0.0043560464825349275, "phrase": "clock_tree"}, {"score": 0.004288386935585756, "phrase": "multiple_power_mode_environment"}, {"score": 0.004169226023596022, "phrase": "design_module"}, {"score": 0.004117329555194574, "phrase": "power_mode_changes"}, {"score": 0.003759835076089236, "phrase": "clock_skew_problem"}, {"score": 0.003369322866499541, "phrase": "complete_solution"}, {"score": 0.00320453237792, "phrase": "linear-time_algorithm"}, {"score": 0.0027828888187069636, "phrase": "power_mode"}, {"score": 0.002765490759189057, "phrase": "experimental_results"}, {"score": 0.0026969765105207457, "phrase": "previous_work"}, {"score": 0.0026055251533586804, "phrase": "value_assignment"}, {"score": 0.0025730425700096365, "phrase": "consistently_better_designs"}, {"score": 0.002548945980967458, "phrase": "tested_benchmarks"}, {"score": 0.0023864566654035924, "phrase": "shorter_clock_latencies"}, {"score": 0.0023493172499168763, "phrase": "previous_algorithm"}, {"score": 0.002298288831092204, "phrase": "delay_assignment"}, {"score": 0.0022133711375320244, "phrase": "new_adb_design_technique"}, {"score": 0.0021995257343837547, "phrase": "systematic_algorithmic_solutions"}, {"score": 0.002158505888557746, "phrase": "discrete_delay_values"}, {"score": 0.0021450029487459403, "phrase": "slew_rate_variation"}, {"score": 0.0021315842986705485, "phrase": "nonzero_initial_adb_delay"}, {"score": 0.0021049977753042253, "phrase": "possible_exploration"}], "paper_keywords": ["Adjustable delay buffer (ADB)", " cell allocation", " clock skew", " clock tree synthesis", " multiple power modes"], "paper_abstract": "Satisfying a clock skew constraint is one of the most important tasks in clock tree synthesis. Moreover, the task becomes much harder to solve when the clock tree is designed in a multiple power mode environment, in which the voltage applied to some design module varies as the power mode changes. Recently, it has been shown that an adjustable delay buffer (ADB), whose delay can be tuned dynamically, can be used to solve the clock skew problem effectively under multiple power modes. However, due to the area or control overhead by ADBs, it is very important to minimize the number of ADBs to be allocated. This paper provides a complete solution to the problem of clock skew optimization using ADBs under multiple power modes. We propose a linear-time algorithm that simultaneously solves the problems of computing: 1) the minimum (optimal) number of ADBs to be used; 2) the location where each ADB is to be placed; and 3) the delay value of each ADB to be assigned to each power mode. Experimental results show that, in comparison with the previous work, which iteratively performs the ADB allocation, placement, and value assignment, our integrated algorithm produces consistently better designs for all tested benchmarks; it reduces the numbers of ADBs by 9.27% on average under the skew bound of 30-50 ps, even with shorter clock latencies compared to that of previous algorithm of ADB allocation, placement, and delay assignment. To make it practically feasible, we also propose a new ADB design technique and systematic algorithmic solutions to address the problems of discrete delay values, slew rate variation, nonzero initial ADB delay, and a possible exploration of ADB resizing.", "paper_title": "An Optimal Allocation Algorithm of Adjustable Delay Buffers and Practical Extensions for Clock Skew Optimization in Multiple Power Mode Designs", "paper_id": "WOS:000315481000006"}