{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "binary_code"}, {"score": 0.007286454397795971, "phrase": "c_program"}, {"score": 0.00446471538346719, "phrase": "source-to-source_transformations"}, {"score": 0.004327981760540394, "phrase": "executable_programs"}, {"score": 0.004176813329075736, "phrase": "complex_transformations"}, {"score": 0.003687960013746783, "phrase": "automatic_parallelizer"}, {"score": 0.003574929398913029, "phrase": "advanced_parallelization"}, {"score": 0.003404244237372396, "phrase": "high-level_information"}, {"score": 0.0031562971707460802, "phrase": "program_semantics"}, {"score": 0.002811464848641341, "phrase": "advanced_polyhedral_parallelizers"}, {"score": 0.0027741761880779535, "phrase": "original_program_semantics"}, {"score": 0.0026652435674846095, "phrase": "transformed_parallel_loop_nests"}, {"score": 0.00260657976055413, "phrase": "standard_c_compiler"}, {"score": 0.002537880772794665, "phrase": "benchmark_suite"}, {"score": 0.0024600113832396187, "phrase": "almost_all_the_loop_nests"}, {"score": 0.0023739321566540682, "phrase": "recent_polyhedral_loop_parallelizer"}, {"score": 0.0021716540012278744, "phrase": "non-linear_accesses"}], "paper_keywords": ["Algorithms", " Performance"], "paper_abstract": "Many automatic software parallelization systems have been proposed in the past decades, but most of them are dedicated to source-to-source transformations. This paper shows that parallelizing executable programs is feasible, even if they require complex transformations, and in effect decouples parallelization from compilation, for example, for closed-source or legacy software, where binary code is the only available representation. We propose an automatic parallelizer, which is able to perform advanced parallelization on binary code. It first parses the binary code and extracts high-level information. From this information, a C program is generated. This program captures only a subset of the program semantics, namely, loops and memory accesses. This C program is then parallelized using existing, state-of-the-art parallelizers, including advanced polyhedral parallelizers. The original program semantics is then re-injected, and the transformed parallel loop nests are recompiled by a standard C compiler. We show on the Poly Bench benchmark suite that our system successfully detects and parallelizes almost all the loop nests from the binary code, using a recent polyhedral loop parallelizer as a backend. The paper ends by elaborating a strategy to parallelize more complex programs, such as those containing non-linear accesses to memory, and provides a few example case-studies.", "paper_title": "Polyhedral Parallelization of Binary Code", "paper_id": "WOS:000299995000022"}