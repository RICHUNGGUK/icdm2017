{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "accumulative_functions"}, {"score": 0.004676575291629554, "phrase": "call-time_and_return-time_computations"}, {"score": 0.00436890075128947, "phrase": "transformational_developments"}, {"score": 0.003925633992809873, "phrase": "tail-recursive_functions"}, {"score": 0.003294875957676514, "phrase": "program_transformation"}, {"score": 0.0032000908854470742, "phrase": "io"}, {"score": 0.0027922467043592597, "phrase": "accumulative_parameters"}, {"score": 0.0026337482179592422, "phrase": "interesting_transformations"}, {"score": 0.0021049977753042253, "phrase": "circular_programs"}], "paper_keywords": [""], "paper_abstract": "Functional languages are suitable for transformational developments of programs. However, accumulative functions, or in particular tail-recursive functions, are known to be less suitable for manipulation. In this paper, we propose a program transformation named \"IO swapping\" that swaps call-time and return-time computations. It moves computations in accumulative parameters to results and thereby enables interesting transformations. We demonstrate effectiveness of IO swapping by several applications: deforestation, higher order removal, program inversion, and manipulation of circular programs.", "paper_title": "Manipulating accumulative functions by swapping call-time and return-time computations", "paper_id": "WOS:000306533300003"}