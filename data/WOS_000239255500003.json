{"auto_keywords": [{"score": 0.04908569685437738, "phrase": "high-performance_computing"}, {"score": 0.047727054184086584, "phrase": "high-performance_applications"}, {"score": 0.00481495049065317, "phrase": "program_generator"}, {"score": 0.0047547526023100665, "phrase": "generic_transformations"}, {"score": 0.004617187934074393, "phrase": "compiler-optimized_code"}, {"score": 0.004483585361583022, "phrase": "optimization_and_domain_experts"}, {"score": 0.00426344619171077, "phrase": "first_glance"}, {"score": 0.004210114198411514, "phrase": "performance_gap"}, {"score": 0.00403709306806495, "phrase": "tremendous_complexity_increase"}, {"score": 0.00396988421137599, "phrase": "memory_architectures"}, {"score": 0.003887438245620965, "phrase": "rising_level"}, {"score": 0.0038227112550093863, "phrase": "popular_programming_languages"}, {"score": 0.0035148319209810128, "phrase": "target_architecture"}, {"score": 0.003456287408801543, "phrase": "complex_sequences"}, {"score": 0.003370287778450475, "phrase": "real_codes"}, {"score": 0.00330025288273863, "phrase": "generative_programming"}, {"score": 0.00325893016361821, "phrase": "practical_means"}, {"score": 0.0032181231788427655, "phrase": "architecture-aware_optimizations"}, {"score": 0.0030857431184193765, "phrase": "generative_programming_languages"}, {"score": 0.0030216031606457214, "phrase": "high-performance_computing_expert"}, {"score": 0.002789763110395331, "phrase": "careful_combination"}, {"score": 0.002586513876943306, "phrase": "generative_approaches"}, {"score": 0.002511522462767081, "phrase": "technical_caveats"}, {"score": 0.0024904974828343033, "phrase": "implementation_barriers"}, {"score": 0.002289667393538803, "phrase": "abstract_syntaxes"}, {"score": 0.002270495425498003, "phrase": "heterogeneous_generators"}, {"score": 0.0022514836269627186, "phrase": "code_generators"}, {"score": 0.0021049977753042253, "phrase": "back-end_generator"}], "paper_keywords": ["multi-stage programming", " loop transformations", " adaptive libraries", " application-specific program generators"], "paper_abstract": "The quality of compiler-optimized code for high-performance applications is far behind what optimization and domain experts can achieve by hand. Although it may seem surprising at first glance, the performance gap has been widening over time, due to the tremendous complexity increase in microprocessor and memory architectures, and to the rising level of abstraction of popular programming languages and styles. This paper explores in-between solutions, neither fully automatic nor fully manual ways to adapt a computationally intensive application to the target architecture. By mimicking complex sequences of transformations useful to optimize real codes, we show that generative programming is a practical means to implement architecture-aware optimizations for high-performance applications. This work explores the promises of generative programming languages and techniques for the high-performance computing expert. We show that complex, architecture-specific optimizations can be implemented in a type-safe, purely generative framework. Peak performance is achievable through the careful combination of a high-level, multi-stage evaluation language - MetaOCaml with low-level code generation techniques. Nevertheless, our results also show that generative approaches for high-performance computing do not come without technical caveats and implementation barriers concerning productivity and reuse. We describe these difficulties and identify ways to hide or overcome them, from abstract syntaxes to heterogeneous generators of code generators, combining high-level and type-safe multi-stage programming with a back-end generator of imperative code. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "In search of a program generator to implement generic transformations for high-performance computing", "paper_id": "WOS:000239255500003"}