{"auto_keywords": [{"score": 0.05007840182816712, "phrase": "temporal_reuse_profile"}, {"score": 0.03281428926510873, "phrase": "trp"}, {"score": 0.028497818623658133, "phrase": "branch-and-bound_algorithm"}, {"score": 0.004594582559945568, "phrase": "average_memory_access_latency"}, {"score": 0.004421770937919324, "phrase": "significant_positive_impact"}, {"score": 0.004273601449537163, "phrase": "modern_embedded_processors"}, {"score": 0.004219321533320583, "phrase": "cache_locking_mechanisms"}, {"score": 0.0041657281535389615, "phrase": "memory_blocks"}, {"score": 0.00402610372759447, "phrase": "software_control"}, {"score": 0.00399206679864652, "phrase": "cache"}, {"score": 0.00387459052649752, "phrase": "timing_predictability"}, {"score": 0.003841699919521703, "phrase": "hard_real-time_applications"}, {"score": 0.003776750773624222, "phrase": "prior_techniques"}, {"score": 0.003634587156159668, "phrase": "worst-case_execution_time"}, {"score": 0.0035731269727067496, "phrase": "cache_locking"}, {"score": 0.0034532961266947734, "phrase": "average-case_execution_time"}, {"score": 0.0032531496610470377, "phrase": "static_instruction_cache"}, {"score": 0.0031845067058084583, "phrase": "average-case_program_performance"}, {"score": 0.0029491324941225356, "phrase": "locking_memory_blocks"}, {"score": 0.002742787059497186, "phrase": "locking_mechanism"}, {"score": 0.002465210678474529, "phrase": "experimental_results"}, {"score": 0.0024234763342790852, "phrase": "heuristic_approach"}, {"score": 0.0021968238865548812, "phrase": "real-world_benchmarks"}, {"score": 0.0021412594173592513, "phrase": "significant_improvement"}, {"score": 0.0021049977753042253, "phrase": "state-of-the-art_locking_algorithm"}], "paper_keywords": ["Cache", " cache locking", " performance", " temporal reuse profile (TRP)"], "paper_abstract": "The performance of most embedded systems is critically dependent on the average memory access latency. Improving the cache hit rate can have significant positive impact on the performance of an application. Modern embedded processors often feature cache locking mechanisms that allow memory blocks to be locked in the cache under software control. Cache locking was primarily designed to offer timing predictability for hard real-time applications. Hence, prior techniques focus on employing cache locking to improve the worst-case execution time. However, cache locking can be quite effective in improving the average-case execution time of general embedded applications as well. In this paper, we explore static instruction cache locking to improve the average-case program performance. We introduce temporal reuse profile (TRP) to accurately and efficiently model the cost and benefit of locking memory blocks in the cache. We consider two locking mechanisms, line locking and way locking. For each locking mechanism, we propose a branch-and-bound algorithm and a heuristic approach that use the TRP to determine the most beneficial memory blocks to be locked in the cache. Experimental results show that the heuristic approach achieves close to the results of branch-and-bound algorithm and can improve the performance by 12% on average for 4 KB cache across a suite of real-world benchmarks. Moreover, our heuristic provides significant improvement compared to the state-of-the-art locking algorithm both in terms of performance and efficiency.", "paper_title": "Instruction Cache Locking Using Temporal Reuse Profile", "paper_id": "WOS:000360405500002"}