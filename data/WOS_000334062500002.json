{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "convolutions"}, {"score": 0.004615202066192795, "phrase": "subquadratic_algorithms"}, {"score": 0.004377077848734575, "phrase": "arbitrary_positions"}, {"score": 0.004285289574869884, "phrase": "optimal_rotation"}, {"score": 0.0036359780843400625, "phrase": "best_perfect_matching"}, {"score": 0.003559675269411366, "phrase": "surprisingly_different_results"}, {"score": 0.0032184697893776052, "phrase": "standard_convolution"}, {"score": 0.002833689453299307, "phrase": "latter_two_convolution_problems"}, {"score": 0.0027303606813078255, "phrase": "interesting_results"}, {"score": 0.0024423826953133844, "phrase": "order_statistics"}, {"score": 0.0021731423856364003, "phrase": "obvious_algorithms"}], "paper_keywords": ["Necklace alignment", " Cyclic swap distance", " Convolution", " Sorting X plus Y", " All pairs shortest paths"], "paper_abstract": "We give subquadratic algorithms that, given two necklaces each with n beads at arbitrary positions, compute the optimal rotation of the necklaces to best align the beads. Here alignment is measured according to the a\"\" (p) norm of the vector of distances between pairs of beads from opposite necklaces in the best perfect matching. We show surprisingly different results for p=1, p even, and p=a. For p even, we reduce the problem to standard convolution, while for p=a and p=1, we reduce the problem to (min,+) convolution and convolution. Then we solve the latter two convolution problems in subquadratic time, which are interesting results in their own right. These results shed some light on the classic sorting X+Y problem, because the convolutions can be viewed as computing order statistics on the antidiagonals of the X+Y matrix. All of our algorithms run in o(n (2)) time, whereas the obvious algorithms for these problems run in I similar to(n (2)) time.", "paper_title": "Necklaces, Convolutions, and X plus Y", "paper_id": "WOS:000334062500002"}