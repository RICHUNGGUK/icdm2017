{"auto_keywords": [{"score": 0.04932092433893311, "phrase": "armus"}, {"score": 0.00481495049065317, "phrase": "dynamic_deadlock_verification_for_general_barrier_synchronisation"}, {"score": 0.004608121749000898, "phrase": "deadlock_detection"}, {"score": 0.004517055580214742, "phrase": "barrier_synchronisation"}, {"score": 0.004203803478570494, "phrase": "building_block"}, {"score": 0.0041703614123283165, "phrase": "parallel_computing"}, {"score": 0.0038043055953253047, "phrase": "novel_event-based_representation"}, {"score": 0.0036262124965265015, "phrase": "deadlock_analysis"}, {"score": 0.003334309053314909, "phrase": "barrier_deadlock"}, {"score": 0.003268333444704392, "phrase": "core_language"}, {"score": 0.003005151718290603, "phrase": "graph_analysis_technique"}, {"score": 0.0028529310661977577, "phrase": "favours_programs"}, {"score": 0.0025202582748972122, "phrase": "verification_algorithm"}, {"score": 0.0023171750718791713, "phrase": "local_and_distributed_scenarios"}, {"score": 0.002262209824105154, "phrase": "graph_analysis"}, {"score": 0.002244178699939059, "phrase": "automatic_graph-representation_selection"}, {"score": 0.0021821915946356168, "phrase": "traditional_fixed_graph_representation"}, {"score": 0.0021561514733516676, "phrase": "performance_measurements"}, {"score": 0.0021389638834794136, "phrase": "distributed_deadlock_detection"}, {"score": 0.0021049977753042253, "phrase": "negligible_overheads"}], "paper_keywords": ["Verification", " barrier synchronisation", " phasers", " deadlock detection", " deadlock avoidance", " X10", " Java"], "paper_abstract": "We present Armus, a dynamic verification tool for deadlock detection and avoidance specialised in barrier synchronisation. Barriers are used to coordinate the execution of groups of tasks, and serve as a building block of parallel computing. Our tool verifies more barrier synchronisation patterns than current state-of-the-art. To improve the scalability of verification, we introduce a novel event-based representation of concurrency constraints, and a graph-based technique for deadlock analysis. The implementation is distributed and fault-tolerant, and can verify X10 and Java programs. To formalise the notion of barrier deadlock, we introduce a core language expressive enough to represent the three most widespread barrier synchronisation patterns: group, split-phase, and dynamic membership. We propose a graph analysis technique that selects from two alternative graph representations: the Wait-For Graph, that favours programs with more tasks than barriers; and the State Graph, optimised for programs with more barriers than tasks. We prove that finding a deadlock in either representation is equivalent, and that the verification algorithm is sound and complete with respect to the notion of deadlock in our core language. Armus is evaluated with three benchmark suites in local and distributed scenarios. The benchmarks show that graph analysis with automatic graph-representation selection can record a 7-fold execution increase versus the traditional fixed graph representation. The performance measurements for distributed deadlock detection between 64 processes show negligible overheads.", "paper_title": "Dynamic Deadlock Verification for General Barrier Synchronisation", "paper_id": "WOS:000367254800015"}