{"auto_keywords": [{"score": 0.04703570948560473, "phrase": "non-orthogonal_architectures"}, {"score": 0.00481495049065317, "phrase": "non-orthogonal_dsp_architecture"}, {"score": 0.004731492618963217, "phrase": "strict_speed_and_power_requirements"}, {"score": 0.004392565073466714, "phrase": "irregular_data_paths"}, {"score": 0.004354315061804687, "phrase": "heterogeneous_registers"}, {"score": 0.004297560964892607, "phrase": "multiple_memory_banks"}, {"score": 0.0041136473765874815, "phrase": "non-orthogonal_architecture"}, {"score": 0.003818807671883534, "phrase": "great_challenge"}, {"score": 0.0037855348847339655, "phrase": "compiler_design"}, {"score": 0.0037361664435836845, "phrase": "usual_compilation_techniques"}, {"score": 0.003703611021999795, "phrase": "general-purpose_cpus"}, {"score": 0.003529543381704363, "phrase": "entire_code_generation_process"}, {"score": 0.003438058620195309, "phrase": "intermediate_representation"}, {"score": 0.003408091901859624, "phrase": "code_compaction"}, {"score": 0.003378385493203297, "phrase": "instruction_scheduling"}, {"score": 0.0033489371483830153, "phrase": "memory_bank_assignment"}, {"score": 0.003305243635051068, "phrase": "variable_partition"}, {"score": 0.0029110999689379497, "phrase": "rotation_scheduling_with_spill_codes_predicting"}, {"score": 0.0027379609683723938, "phrase": "six_parts"}, {"score": 0.0026786469998321084, "phrase": "entire_phases"}, {"score": 0.0026436755508085223, "phrase": "code_generation_process"}, {"score": 0.0025638362414466278, "phrase": "detailed_principles"}, {"score": 0.002508284945907166, "phrase": "proposed_rssp"}, {"score": 0.002453934333239467, "phrase": "analytic_model"}, {"score": 0.0024007585788965655, "phrase": "evaluation_results"}, {"score": 0.002328238264850759, "phrase": "proposed_method"}, {"score": 0.0022480304016499605, "phrase": "preliminary_ideas"}, {"score": 0.002218668420806254, "phrase": "rssp"}, {"score": 0.0021049977753042253, "phrase": "similar_architectural_features"}], "paper_keywords": ["DSP", " non-orthogonal architecture", " code generation"], "paper_abstract": "To meet strict speed and power requirements for embedded applications, many high-end digital Signal Processors (DSPs) commonly employ non-orthogonal architectures that are typically characterized by irregular data paths, heterogeneous registers, and multiple memory banks. Obviously to harvest the benefits provided by this non-orthogonal architecture sufficient compiler support is necessary and important. However, the complexity of such architectures presents a great challenge to compiler design and the usual compilation techniques for general-purpose CPUs do not adapt well to the irregularity of DSP. The entire code generation process must include the following phases: intermediate representation, code compaction, instruction scheduling, memory bank assignment (or variable partition), and register/accumulator assignment. Much related research only considers some phases, which is inadequate. In this paper, we present an effective code generation algorithm named Rotation Scheduling with Spill Codes Predicting (RSSP) to maximally exploit the benefits of non-orthogonal architectures. It contains six parts that cover almost the entire phases of the code generation process. As well as introducing the detailed principles and algorithms of the proposed RSSP, we use an analytic model to evaluate its preliminary performance. Evaluation results clearly demonstrate the effectiveness of the proposed method. Furthermore, we also present some preliminary ideas to generalize RSSP, which can make it more practicable and suit various DSPs with similar architectural features.", "paper_title": "An efficient code generation algorithm for non-orthogonal DSP architecture", "paper_id": "WOS:000246599000006"}