{"auto_keywords": [{"score": 0.02676969238862161, "phrase": "p-np_parallel"}, {"score": 0.0075707006468254505, "phrase": "bpp_algorithm"}, {"score": 0.00481495049065317, "phrase": "approximate_list-decoding"}, {"score": 0.004786821283037044, "phrase": "direct_product_codes"}, {"score": 0.004689650818647484, "phrase": "message_msg"}, {"score": 0.004294962474996283, "phrase": "possible_k-tuples"}, {"score": 0.003968112038249246, "phrase": "efficient_randomized_algorithm"}, {"score": 0.0039449104968131655, "phrase": "approximate_local_list-decoding"}, {"score": 0.0037311260623089436, "phrase": "k-wise_direct_product_encoding"}, {"score": 0.003175175896313016, "phrase": "boolean_circuits"}, {"score": 0.003138124398958758, "phrase": "jth_bit"}, {"score": 0.0031106189016953142, "phrase": "ith_output_string"}, {"score": 0.00304737045343781, "phrase": "ith_circuit"}, {"score": 0.002749851878361472, "phrase": "randomized_approximate_list-decoding_algorithm"}, {"score": 0.0025328377393370642, "phrase": "uniform_hardness_amplification"}, {"score": 0.002452833707464047, "phrase": "np"}, {"score": 0.0024236964502593254, "phrase": "parallel_oracle_queries"}], "paper_keywords": ["uniform hardness amplification", " direct product theorems", " Yao's XOR lemma", " error-correcting codes", " approximately list-decodable codes"], "paper_abstract": "Given a message msg is an element of {0, 1}(N), its k-wise direct product encoding is the sequence of k-tuples (msg(i(1)),..., msg(i(k))) over all possible k-tuples of indices (i(1),..., i(k)) is an element of {1,..., N}(k). We give an efficient randomized algorithm for approximate local list-decoding of direct product codes. That is, given oracle access to a word which agrees with a k-wise direct product encoding of some message msg is an element of {0, 1}(N) in at least epsilon >= poly(1/k) fraction of positions, our algorithm outputs a list of poly(1/epsilon) strings that contains at least one string msg' which is equal to msg in all but at most k(-Omega)(1) fraction of positions. The decoding is local in that our algorithm outputs a list of Boolean circuits so that the jth bit of the ith output string can be computed by running the ith circuit on input j. The running time of the algorithm is polynomial in log N and 1/epsilon. In general, when epsilon > e(-k alpha) for a sufficiently small constant alpha > 0, we get a randomized approximate list-decoding algorithm that runs in time quasi-polynomial in 1/epsilon, i.e., (1/epsilon) (poly log 1/epsilon). As an application of our decoding algorithm, we get uniform hardness amplification for P-NP parallel to, the class of languages reducible to NP through one round of parallel oracle queries: If there is a language in P-NP parallel to that cannot be decided by any BPP algorithm on more than 1 - 1/n(Omega(1)) fraction of inputs, then there is another language in P-NP parallel to that cannot be decided by any BPP algorithm on more than 1/2 + 1/n(omega)(1) fraction of inputs.", "paper_title": "APPROXIMATE LIST-DECODING OF DIRECT PRODUCT CODES AND UNIFORM HARDNESS AMPLIFICATION", "paper_id": "WOS:000268859000011"}