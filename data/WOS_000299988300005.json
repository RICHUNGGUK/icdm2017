{"auto_keywords": [{"score": 0.040179907029343674, "phrase": "memory_accesses"}, {"score": 0.033067104039962776, "phrase": "order_scheduling"}, {"score": 0.015719716506582538, "phrase": "embedded_systems"}, {"score": 0.004764220976404241, "phrase": "growing_gap"}, {"score": 0.0047306971679760175, "phrase": "microprocessor_speed"}, {"score": 0.00469740813902244, "phrase": "dram_speed"}, {"score": 0.004647911247507267, "phrase": "major_problem"}, {"score": 0.004615202066192795, "phrase": "computer_designers"}, {"score": 0.004361644989356558, "phrase": "dram's_speed"}, {"score": 0.004021267064832957, "phrase": "contemporary_dram_chips"}, {"score": 0.003800215925586887, "phrase": "different_banks"}, {"score": 0.0037336520904376687, "phrase": "bubble_filling_scheduling"}, {"score": 0.003578600071301459, "phrase": "memory_access_schedule_length"}, {"score": 0.0035408501923902477, "phrase": "memory_access_time"}, {"score": 0.003466536738232506, "phrase": "memory_access_trace"}, {"score": 0.0034057975804778293, "phrase": "application-specific_embedded_systems"}, {"score": 0.003287482882222731, "phrase": "efficient_memory_access_schedules"}, {"score": 0.0032527939106509946, "phrase": "offline_bfs_algorithm"}, {"score": 0.002946122903079259, "phrase": "single_memory_controller"}, {"score": 0.0029253546782349875, "phrase": "real_time"}, {"score": 0.002793874145713024, "phrase": "online_bfs_algorithm"}, {"score": 0.0025125151618810523, "phrase": "memory_throughput"}, {"score": 0.002468450551616404, "phrase": "memory_access_schedule"}, {"score": 0.0024251568696803177, "phrase": "dual_memory_controllers"}, {"score": 0.002365815362517737, "phrase": "experimental_results"}, {"score": 0.0023408288327263316, "phrase": "dual_controller_algorithm"}, {"score": 0.002211947103318718, "phrase": "burst_scheduling"}, {"score": 0.0021654633404434623, "phrase": "single_controller_bfs_algorithms"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Memory scheduling", " Memory access latency", " Memory controller", " Embedded systems"], "paper_abstract": "The growing gap between microprocessor speed and DRAM speed is a major problem that computer designers are facing. In order to narrow the gap, it is necessary to improve DRAM's speed and throughput. To achieve this goal, this paper proposes techniques to take advantage of the characteristics of the 3-stage access of contemporary DRAM chips by grouping the accesses of the same row together and interleaving the execution of memory accesses from different banks. A family of Bubble Filling Scheduling (BFS) algorithms are proposed in this paper to minimize memory access schedule length and improve memory access time for embedded systems. When the memory access trace is known in some application-specific embedded systems, this information can be fully utilized to generate efficient memory access schedules. The offline BFS algorithm can generate schedules which are 47.49% shorter than in-order scheduling and 8.51% shorter than existing burst scheduling on average. When memory accesses are received by the single memory controller in real time, the memory accesses have to be scheduled as they come. The online BFS algorithm in this paper serves this purpose and generates schedules which are 58.47% shorter than in-order scheduling and 4.73% shorter than burst scheduling on average. To improve the memory throughput and further reduce the memory access schedule, an architecture with dual memory controllers is proposed. According to the experimental results, the dual controller algorithm can generate schedules which are 62.89% shorter than in-order scheduling, 14.23% shorter than burst scheduling, and 10.07% shorter than single controller BFS algorithms on average. (C) 2011 Elsevier B.V. All rights reserved.", "paper_title": "Memory access schedule minimization for embedded systems", "paper_id": "WOS:000299988300005"}