{"auto_keywords": [{"score": 0.0420367178459397, "phrase": "big_data"}, {"score": 0.00481495049065317, "phrase": "classical_detectors"}, {"score": 0.004751045411634624, "phrase": "big_data_analysis"}, {"score": 0.004719410128388276, "phrase": "emerging_research_topic"}, {"score": 0.004667149874736771, "phrase": "clone_detection"}, {"score": 0.004564351133950942, "phrase": "big_data_inter-project_clone_corpora"}, {"score": 0.004503757012546883, "phrase": "corporate-source_code_repositories"}, {"score": 0.004414364098081967, "phrase": "developer_behavior"}, {"score": 0.004375203045167542, "phrase": "engineering_costs"}, {"score": 0.004336387887678151, "phrase": "duplicated_efforts"}, {"score": 0.004317109072311102, "phrase": "new_apis"}, {"score": 0.004259783171264835, "phrase": "code_completion"}, {"score": 0.004240843476350716, "phrase": "api_usage_support"}, {"score": 0.004193860286586621, "phrase": "scalable_clone_detection_tools"}, {"score": 0.00392265006194262, "phrase": "average_user's_resources"}, {"score": 0.00387917832030318, "phrase": "inherent_limitations"}, {"score": 0.003768384664666166, "phrase": "extraordinary_resources"}, {"score": 0.00366891394885193, "phrase": "source_code"}, {"score": 0.00337086009350476, "phrase": "classical_clone_detection_tools"}, {"score": 0.003296518894660701, "phrase": "commodity_hardware"}, {"score": 0.003267242013792253, "phrase": "input_dataset"}, {"score": 0.0032094634756436595, "phrase": "computing_resources"}, {"score": 0.0031880600799608257, "phrase": "non-deterministic_process"}, {"score": 0.002955209381882065, "phrase": "single_report"}, {"score": 0.0028900083929929827, "phrase": "subject_tools"}, {"score": 0.0028199428880719426, "phrase": "acceptable_loss"}, {"score": 0.002708925531970643, "phrase": "big_data_dataset"}, {"score": 0.002602267374116007, "phrase": "computationally_inexpensive_version"}, {"score": 0.0025733906235044803, "phrase": "pure_random_shuffling"}, {"score": 0.002510981884877877, "phrase": "ijadataset"}, {"score": 0.0024720556355285056, "phrase": "desirable_recall"}, {"score": 0.002401354087983099, "phrase": "satisfactory_recall"}, {"score": 0.0023535921028031864, "phrase": "efficient_file_tracking"}, {"score": 0.0023431077027921744, "phrase": "file-similarity_heuristics"}, {"score": 0.002322278481664192, "phrase": "shuffling_algorithm"}, {"score": 0.0022811726154932494, "phrase": "undetected_clone_pairs"}, {"score": 0.002235795635149101, "phrase": "recall_performance"}, {"score": 0.0021525265056673982, "phrase": "tool's_native_recall"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["shuffling framework", " clone detection", " scalability", " big data", " clone corpus"], "paper_abstract": "Big data analysis is an emerging research topic in various domains, and clone detection is no exception. The goal is to create big data inter-project clone corpora across open-source or corporate-source code repositories. Such corpora can be used to study developer behavior and to reduce engineering costs by extracting globally duplicated efforts into new APIs and as a basis for code completion and API usage support. However, building scalable clone detection tools is challenging. It is often impractical to use existing state-of-the-art tools to analyze big data because the memory and execution time required exceed the average user's resources. Some tools have inherent limitations in their data structures and algorithms that prevent the analysis of big data even when extraordinary resources are available. These limitations are impossible to overcome if the source code of the tool is unavailable or if the user lacks the time or expertise to modify the tool without harming its performance or accuracy. In this research, we have investigated the use of our shuffling framework for scaling classical clone detection tools to big data. The framework achieves scalability on commodity hardware by partitioning the input dataset into subsets manageable by the tool and computing resources. A non-deterministic process is used to randomly 'shuffle' the contents of the dataset into a series of subsets. The tool is executed for each subset, and its output for each is merged into a single report. This approach does not require modification to the subject tools, allowing their individual strengths and precision to be captured at an acceptable loss of recall. In our study, we explored the performance and applicability of the framework for the big data dataset, IJaDataset 2.0, which consists of 356 million lines of code from 25,000 open-source Java projects. We begin with a computationally inexpensive version of our framework based on pure random shuffling. This version was successful at scaling the tools to IJaDataset but required many subsets to achieve a desirable recall. Using our findings, we incrementally improved the framework to achieve a satisfactory recall using fewer resources. We investigated the use of efficient file tracking and file-similarity heuristics to bias the shuffling algorithm toward subsets of the dataset that contain undetected clone pairs. These changes were successful in improving the recall performance of the framework. Our study shows that the framework is able to achieve up to 90-95% of a tool's native recall using standard hardware. Copyright (C) 2014 John Wiley & Sons, Ltd.", "paper_title": "Big data clone detection using classical detectors: an exploratory study", "paper_id": "WOS:000357822800003"}