{"auto_keywords": [{"score": 0.04878908082713497, "phrase": "reverse_mode"}, {"score": 0.007740491397435411, "phrase": "rios"}, {"score": 0.007230964719955034, "phrase": "original_program"}, {"score": 0.0071574632082311565, "phrase": "reverse_order"}, {"score": 0.004733458808453602, "phrase": "reverse_direction"}, {"score": 0.004653339900995785, "phrase": "automatic_differentiation"}, {"score": 0.004605917942709477, "phrase": "adjoint_statements"}, {"score": 0.004405919996432158, "phrase": "original_program_flow"}, {"score": 0.0043610084347896596, "phrase": "program_flow_reversal"}, {"score": 0.004243460284890507, "phrase": "control_flow"}, {"score": 0.004129067429043414, "phrase": "intermediate_values"}, {"score": 0.0038431888954930083, "phrase": "partial_derivatives"}, {"score": 0.003803991592917943, "phrase": "corresponding_statement"}, {"score": 0.0037651925588909783, "phrase": "stored_information"}, {"score": 0.0035526625882388936, "phrase": "standard_implementations"}, {"score": 0.003528458369404996, "phrase": "file_systems"}, {"score": 0.003504418473478722, "phrase": "operating_systems"}, {"score": 0.0034332736827447654, "phrase": "common_buffering_strategy"}, {"score": 0.003375087185182269, "phrase": "future_read_requests"}, {"score": 0.0032283609741926476, "phrase": "forward_direction"}, {"score": 0.002903628734069691, "phrase": "data_storage"}, {"score": 0.002702363975375762, "phrase": "novel_software"}, {"score": 0.002567180189640976, "phrase": "particular_requirements"}, {"score": 0.0023486473525617816, "phrase": "real-world_example"}, {"score": 0.002324657548285756, "phrase": "fluid_mechanics"}, {"score": 0.0022541681080598536, "phrase": "matlab"}, {"score": 0.0021932609696277937, "phrase": "automatic_differentiation_tools"}, {"score": 0.0021857668144031903, "phrase": "tapenade"}, {"score": 0.002170854875902186, "phrase": "adimat"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["automatic differentiation", " reverse mode", " discrete adjoint", " stack", " multithreading", " parallel computing", " program reversal"], "paper_abstract": "The reverse mode of automatic differentiation executes the adjoint statements induced by each statement in the original program in the reverse order of the original program flow. This program flow reversal commonly requires storage of information on the control flow of the original program. In addition, intermediate values of variables that are overwritten have to be recorded, as these values may later be needed to compute the partial derivatives of the corresponding statement. The stored information will be accessed in reverse order of being written. This runs contrary to many assumptions made in standard implementations of file systems, operating systems, and input/output (I/O) libraries. A common buffering strategy aimed at speeding up future read requests is to employ read-ahead. This strategy is useful for accesses in forward direction but is considered to be harmful to the performance of the reverse mode. To increase the performance of the reverse mode, it is also advantageous to interleave computations with the data storage and retrieval operations, which can be achieved using multithreading. To this end, we design and implement a novel software called reverse-mode I/O stream (RIOS) that is adapted to these particular requirements of the reverse mode. We show the advantages of RIOS in two empirical case studies, an artificially constructed example of a typical I/O pattern in the reverse mode and a real-world example arising from fluid mechanics, which is studied in Fortran90 and in Matlab where the reverse mode is generated via the automatic differentiation tools Tapenade and ADiMat, respectively. Copyright (c) 2014 John Wiley & Sons, Ltd.", "paper_title": "RIOS: efficient I/O in reverse direction", "paper_id": "WOS:000360814800005"}