{"auto_keywords": [{"score": 0.04600549658293279, "phrase": "template_metaprogramming"}, {"score": 0.014258147037176833, "phrase": "core_calculus"}, {"score": 0.00481495049065317, "phrase": "type-reflective_metaprogramming"}, {"score": 0.00466016686289196, "phrase": "great_success"}, {"score": 0.004595356579614969, "phrase": "software_applications"}, {"score": 0.003884212965525665, "phrase": "emergent_properties"}, {"score": 0.003848088904418221, "phrase": "disparate_language_features"}, {"score": 0.0036553070575015344, "phrase": "solid_and_sound_language_support"}, {"score": 0.0035376693476114733, "phrase": "firm_semantic_foundations"}, {"score": 0.003504756881063581, "phrase": "select_capabilities"}, {"score": 0.0032370412139943808, "phrase": "language-neutral_fashion"}, {"score": 0.0028799352389969443, "phrase": "fundamental_metaprogramming_capabilities"}, {"score": 0.002839812512030847, "phrase": "static_computation"}, {"score": 0.0028133741785871867, "phrase": "code_generation"}, {"score": 0.0027741761880779535, "phrase": "type_reflection"}, {"score": 0.0027100527874262446, "phrase": "type-safety_property"}, {"score": 0.002684819249720834, "phrase": "compile-time_evaluation"}, {"score": 0.002562123444678208, "phrase": "programming_practice"}, {"score": 0.002410942838102255, "phrase": "type-directed_translation"}, {"score": 0.002237036807966899, "phrase": "idealized_presentation"}], "paper_keywords": ["Design", " Languages", " Theory", " C plus", " metaprogramming", " reflection", " semantics"], "paper_abstract": "C++ template metaprogramming has been used with great success to build software applications and libraries. In practice, however, template metaprogramming suffers usability, reliability, and capability shortcomings, and it is not well understood in theory. Template metaprogramming has these problems because it relies on emergent properties of disparate language features that were tailored to other purposes. As a step toward solid and sound language support for metaprogramming, this paper establishes firm semantic foundations for select capabilities of template metaprogramming. We analyze C++ and the idioms of template metaprogramming and isolate, in a language-neutral fashion, fundamental capabilities of C++ that enable metaprogramming. Guided by this analysis, we present a design for a core calculus that directly expresses fundamental metaprogramming capabilities, including static computation, code generation, and type reflection. We prove a type-safety property for compile-time evaluation of metaprograms. To formally connect the core calculus to programming practice, we present a more convenient surface language for metaprogramming. Its semantics are captured by type-directed translation to the core calculus. We prove that this translation preserves well-typing. This idealized presentation averts some of the shortcomings of C++ template metaprogramming and provides a framework for further study.", "paper_title": "Toward Foundations for Type-Reflective Metaprogramming", "paper_id": "WOS:000280547600003"}