{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "hard_errors"}, {"score": 0.004699916946246509, "phrase": "resilient_system_design"}, {"score": 0.00464343008299973, "phrase": "continued_cmos_scaling"}, {"score": 0.004606148097788071, "phrase": "future_shipped_hardware"}, {"score": 0.004283739213556286, "phrase": "hardware_reliability_solution"}, {"score": 0.004232232993872917, "phrase": "low_overheads"}, {"score": 0.004147756103284082, "phrase": "expensive_redundancy"}, {"score": 0.004064958518350867, "phrase": "cooperative_hardware-software_solution"}, {"score": 0.003999907278478564, "phrase": "anomalous_software_behavior"}, {"score": 0.0039042694651106884, "phrase": "hardware_faults"}, {"score": 0.003734810936407523, "phrase": "different_micro_architectural_structures"}, {"score": 0.0036898803847106023, "phrase": "modern_processor"}, {"score": 0.0034452601929727752, "phrase": "low-cost_detection_methods"}, {"score": 0.003308986613384597, "phrase": "diagnosis_components"}, {"score": 0.003216804708106142, "phrase": "hard_faults"}, {"score": 0.003114584448820957, "phrase": "different_system_implications"}, {"score": 0.003003452468800793, "phrase": "fault_injection_experiments"}, {"score": 0.0029672941061574375, "phrase": "micro_architecture-level_full_system_timing_simulator"}, {"score": 0.002759279370360986, "phrase": "unmasked_faults"}, {"score": 0.002682370021834353, "phrase": "micro_architectural_structures"}, {"score": 0.00266079124891013, "phrase": "simple_detectors"}, {"score": 0.002504374718975704, "phrase": "existing_hardware_checkpointing_schemes"}, {"score": 0.0024345529783611703, "phrase": "software_checkpointing"}, {"score": 0.002319346861878611, "phrase": "detected_faults"}, {"score": 0.0021566565951738658, "phrase": "hardware_checkpointing"}, {"score": 0.0021220787047953093, "phrase": "os_recovery"}, {"score": 0.0021049977753042253, "phrase": "virtually_all_such_cases"}], "paper_keywords": ["reliability", " experimentation", " design", " error detection", " architecture", " permanent fault", " fault injection"], "paper_abstract": "With continued CMOS scaling, future shipped hardware will be increasingly vulnerable to in-the-field faults. To be broadly deployable, the hardware reliability solution must incur low overheads, precluding use of expensive redundancy. We explore a cooperative hardware-software solution that watches for anomalous software behavior to indicate the presence of hardware faults. Fundamental to such a solution is a characterization of how hardware faults in different micro architectural structures of a modern processor propagate through the application and OS. This paper aims to provide such a characterization, resulting in identifying low-cost detection methods and providing guidelines for implementation of the recovery and diagnosis components of such a reliability solution. We focus on hard faults because they are increasingly important and have different system implications than the much studied transients. We achieve our goals through fault injection experiments with a micro architecture-level full system timing simulator. Our main results are: (1) we are able to detect 95% of the unmasked faults in 7 out of 8 studied micro architectural structures with simple detectors that incur zero to little hardware overhead; (2) over 86% of these detections are within latencies that existing hardware checkpointing schemes can handle, while others require software checkpointing; and (3) a surprisingly large fraction of the detected faults corrupt OS state, but almost all of these are detected with latencies short enough to use hardware checkpointing, thereby enabling OS recovery in virtually all such cases.", "paper_title": "Understanding the propagation of hard errors to software and implications for resilient system design", "paper_id": "WOS:000256501300027"}