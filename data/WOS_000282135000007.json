{"auto_keywords": [{"score": 0.008086441453127929, "phrase": "network_protocol_reverse_engineering"}, {"score": 0.00481495049065317, "phrase": "engineering_input_syntactic_structure"}, {"score": 0.004661868629458321, "phrase": "program_input_syntactic_structure"}, {"score": 0.004555499634179394, "phrase": "wide_range"}, {"score": 0.004451546786101008, "phrase": "test_case_generation"}, {"score": 0.004410629943506433, "phrase": "software_debugging"}, {"score": 0.004349955692802962, "phrase": "network_security"}, {"score": 0.004040123129261597, "phrase": "secret_protocols"}, {"score": 0.003734979290204709, "phrase": "plain_text"}, {"score": 0.0035010071030752883, "phrase": "published_format"}, {"score": 0.0032364494905485677, "phrase": "input_structure"}, {"score": 0.0031479142819948007, "phrase": "input_symbols"}, {"score": 0.00309023627455429, "phrase": "execution_and_most_programs"}, {"score": 0.0028172726995962173, "phrase": "grammar_category"}, {"score": 0.0027275289970185015, "phrase": "real-world_programs"}, {"score": 0.0026163210719740847, "phrase": "engineer_input_syntactic_structure"}, {"score": 0.0025212722607043546, "phrase": "hierarchical_delta_debugging"}, {"score": 0.002396179086883189, "phrase": "complete_automation"}, {"score": 0.0023741114327613952, "phrase": "hdd"}, {"score": 0.002266765479420981, "phrase": "input_grammars"}, {"score": 0.0022149235007885826, "phrase": "runtime_performance"}, {"score": 0.0021945194903838132, "phrase": "hdd."}, {"score": 0.0021049977753042253, "phrase": "existing_techniques"}], "paper_keywords": ["Input syntactic structure", " reverse engineering", " control dependence", " grammar inference", " delta debugging", " top-down grammar", " bottom-up grammar"], "paper_abstract": "Program input syntactic structure is essential for a wide range of applications such as test case generation, software debugging, and network security. However, such important information is often not available (e.g., most malware programs make use of secret protocols to communicate) or not directly usable by machines (e.g., many programs specify their inputs in plain text or other random formats). Furthermore, many programs claim they accept inputs with a published format, but their implementations actually support a subset or a variant. Based on the observations that input structure is manifested by the way input symbols are used during execution and most programs take input with top-down or bottom-up grammars, we devise two dynamic analyses, one for each grammar category. Our evaluation on a set of real-world programs shows that our technique is able to precisely reverse engineer input syntactic structure from execution. We apply our technique to hierarchical delta debugging (HDD) and network protocol reverse engineering. Our technique enables the complete automation of HDD, in which programmers were originally required to provide input grammars, and improves the runtime performance of HDD. Our client study on network protocol reverse engineering also shows that our technique supersedes existing techniques.", "paper_title": "Reverse Engineering Input Syntactic Structure from Program Execution and Its Applications", "paper_id": "WOS:000282135000007"}