{"auto_keywords": [{"score": 0.029226340870437198, "phrase": "evolved_solution"}, {"score": 0.00481495049065317, "phrase": "cartesian_genetic_programming's_evolutionary_mechanisms"}, {"score": 0.004737201825299411, "phrase": "search_operators"}, {"score": 0.0046797114400479135, "phrase": "solution_representation"}, {"score": 0.00462291551375938, "phrase": "critical_step"}, {"score": 0.004511373893354558, "phrase": "cartesian_genetic_programming"}, {"score": 0.0044025116437190785, "phrase": "genetic_programming"}, {"score": 0.004367038244106268, "phrase": "gp"}, {"score": 0.004261419841494814, "phrase": "complex_genotype_to_phenotype_map"}, {"score": 0.004041686156098498, "phrase": "tuned_parameter_values"}, {"score": 0.00399260264462941, "phrase": "search_quality"}, {"score": 0.003960210592458847, "phrase": "cgp_variants"}, {"score": 0.0039280803011236395, "phrase": "different_problem_difficulties"}, {"score": 0.003848886045448135, "phrase": "replacement_properties"}, {"score": 0.003710323357333052, "phrase": "cgp_search"}, {"score": 0.0035477010181860376, "phrase": "cgp_evaluations"}, {"score": 0.00335095982979018, "phrase": "cgps_search_limitations"}, {"score": 0.003310236836421397, "phrase": "genome_ordering"}, {"score": 0.0031910037920846817, "phrase": "boolean_problems"}, {"score": 0.0031522260413586506, "phrase": "cgp"}, {"score": 0.0029773436815290215, "phrase": "seemingly_useless_constants"}, {"score": 0.0026560841114619147, "phrase": "large_portions"}, {"score": 0.0024182330686905256, "phrase": "entire_genome"}, {"score": 0.0022287497627555895, "phrase": "hard_problems"}, {"score": 0.00220163445285539, "phrase": "least_number"}, {"score": 0.0021571717917276724, "phrase": "least_amount"}, {"score": 0.0021049977753042253, "phrase": "degenerate_behavior"}], "paper_keywords": ["Analysis", " Cartesian genetic programming"], "paper_abstract": "Understanding how search operators interact with solution representation is a critical step to improving search. In Cartesian genetic programming (CGP), and genetic programming (GP) in general, the complex genotype to phenotype map makes achieving this understanding a challenge. By examining aspects such as tuned parameter values, the search quality of CGP variants at different problem difficulties, node behavior, and offspring replacement properties we seek to better understand the characteristics of CGP search. Our focus is two-fold: creating methods to prevent wasted CGP evaluations (skip, accumulate, and single) and creating methods to overcome CGPs search limitations imposed by genome ordering (reorder and DAG). Our results on Boolean problems show that CGP evolves genomes that are highly inactive, very redundant, and full of seemingly useless constants. On some tested problems we found that less than 1% of the genome was actually required to encode the evolved solution. Furthermore, traditional CGP ordering results in large portions of the genome that are never used by any ancestor of the evolved solution. Reorder and DAG allow evolution to utilize the entire genome. More generally, our results suggest that skip-reorder and single-reorder are most likely to solve hard problems using the least number of evaluations and the least amount of time while better avoiding degenerate behavior.", "paper_title": "Analysis of Cartesian Genetic Programming's Evolutionary Mechanisms", "paper_id": "WOS:000356517700004"}