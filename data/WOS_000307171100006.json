{"auto_keywords": [{"score": 0.04955111375780366, "phrase": "storage_networks"}, {"score": 0.00481495049065317, "phrase": "flexible_reading"}, {"score": 0.004567866351326822, "phrase": "linear_block_codes"}, {"score": 0.004530023871441992, "phrase": "efficient_and_flexible_erasure_codes"}, {"score": 0.004406121974246201, "phrase": "message_x"}, {"score": 0.004381749459671914, "phrase": "k_symbols"}, {"score": 0.004309434349688514, "phrase": "n_symbols"}, {"score": 0.004273723657275637, "phrase": "rw_code"}, {"score": 0.004250080379144324, "phrase": "additional_parameters"}, {"score": 0.00411093109406312, "phrase": "enhanced_possibilities"}, {"score": 0.004065563703649516, "phrase": "fault-tolerance_capability"}, {"score": 0.003965302554920218, "phrase": "rwc"}, {"score": 0.0033570147767493746, "phrase": "code_alphabet"}, {"score": 0.0033384259516301223, "phrase": "different_block_codes"}, {"score": 0.003310734892784563, "phrase": "parity_codes"}, {"score": 0.003229056136334788, "phrase": "reed-solomon"}, {"score": 0.002913710827597771, "phrase": "considerable_advantages"}, {"score": 0.002810373366887749, "phrase": "intensive_applications"}, {"score": 0.0025358343095525275, "phrase": "tight_lower_bound_and_basic_conditions"}, {"score": 0.0024663408903032695, "phrase": "special_rw_codes"}, {"score": 0.0024390784088340715, "phrase": "mentioned_parameters"}, {"score": 0.0023394947463129642, "phrase": "changing_demands"}, {"score": 0.0021946217240332707, "phrase": "coding_system"}, {"score": 0.0021703562417144558, "phrase": "binary_alphabet"}, {"score": 0.0021049977753042253, "phrase": "rw_codes"}], "paper_keywords": ["Reliability", " Theory", " Coding systems", " storage networks", " RAID"], "paper_abstract": "We introduce the Read-Write-Coding-System (RWC), a very flexible class of linear block codes that generate efficient and flexible erasure codes for storage networks. In particular, given a message x of k symbols and a codeword y of n symbols, an RW code defines additional parameters k <= r, w <= n that offer enhanced possibilities to adjust the fault-tolerance capability of the code. More precisely, an RWC provides linear (n, r, d)-codes that have: (a) minimum (Hamming) distance d = n - r + 1 for any two codewords, and (b) for any codeword y(1) there exists a codeword y(2) with distance of at most w. Furthermore, depending on the values r, w and the code alphabet, different block codes such as parity codes (e. g., RAID 4/5) or Reed-Solomon (RS) codes (if r = k and thus, w = n) can be generated. In storage networks in which I/O accesses are very costly and redundancy is crucial, this flexibility has considerable advantages as r and w can optimally be adapted to read or write intensive applications; only w symbols must be updated if the message x changes completely, which is different from other codes that always need to rewrite y completely as x changes. In this article, we first state a tight lower bound and basic conditions for all RW codes. Furthermore, we introduce special RW codes in which all mentioned parameters are adjustable even online, that is, RW codes which are adaptive to changing demands. At last, we investigate the question for which choices of (k, r, w, n) a coding system exists over the binary alphabet F-2 = {0, 1} and discuss how RW codes can be combined.", "paper_title": "An Erasure-Resilient Encoding System for Flexible Reading and Writing in Storage Networks", "paper_id": "WOS:000307171100006"}