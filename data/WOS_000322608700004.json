{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "productive_performance_optimization"}, {"score": 0.004773692073488661, "phrase": "modern_supercomputers"}, {"score": 0.004732785510739708, "phrase": "large_computational_power"}, {"score": 0.004398872331144531, "phrase": "application_performance"}, {"score": 0.004342430078306461, "phrase": "single_node_performance"}, {"score": 0.004106063237069123, "phrase": "serial_node_performance_issues"}, {"score": 0.004053362743156545, "phrase": "complex_semantics"}, {"score": 0.003899269293218826, "phrase": "inexperienced_developer"}, {"score": 0.003767203575060969, "phrase": "easy_identification"}, {"score": 0.0037028514035425037, "phrase": "serial_node_performance_bottlenecks"}, {"score": 0.003426556090707852, "phrase": "performance_inefficiencies"}, {"score": 0.0033971539563683174, "phrase": "small_regions"}, {"score": 0.0029722900280316216, "phrase": "functional_units"}, {"score": 0.0028468767420392945, "phrase": "identified_code"}, {"score": 0.0023145690608400425, "phrase": "applications'_performance"}, {"score": 0.0021601997088758957, "phrase": "increased_problem_sizes"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Performance tools", " Performance analysis", " Performance models", " Application tuning", " Sampling", " Instrumentation"], "paper_abstract": "Modern supercomputers deliver large computational power, but it is difficult for an application to exploit such power. One factor that limits the application performance is the single node performance. While many performance tools use the microprocessor performance counters to provide insights on serial node performance issues, the complex semantics of these counters pose an obstacle to an inexperienced developer. We present a framework that allows easy identification and qualification of serial node performance bottlenecks in parallel applications. The output of the framework is precise and it is capable of correlating performance inefficiencies with small regions of code within the application. The framework not only points to regions of code but also simplifies the semantics of the performance counters into metrics that refer to processor functional units. With such information the developer can focus on the identified code and improve it by knowing which processor execution unit is degrading the performance. To demonstrate the usefulness of the framework we apply it to three already optimized applications using realistic inputs and, according to the results, modify their source code. By doing modifications that require little effort, we successfully increase the applications' performance from 10% to 30% and thus shorten the time required to reach the solution and/or allow facing increased problem sizes. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Framework for a productive performance optimization", "paper_id": "WOS:000322608700004"}