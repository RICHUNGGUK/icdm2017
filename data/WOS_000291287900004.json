{"auto_keywords": [{"score": 0.048522326887293465, "phrase": "performance_bottlenecks"}, {"score": 0.015719716506582538, "phrase": "spmd-style_parallel_programs"}, {"score": 0.01494512609696059, "phrase": "performance_optimization"}, {"score": 0.01181166461745122, "phrase": "autoanalyzer"}, {"score": 0.0047289360793096044, "phrase": "parallel_applications"}, {"score": 0.004547782274166457, "phrase": "previous_work"}, {"score": 0.004479961909330417, "phrase": "challenging_issue"}, {"score": 0.004269630481719451, "phrase": "confined_way"}, {"score": 0.004218602458288531, "phrase": "performance_problems"}, {"score": 0.004180730376667435, "phrase": "priori_knowledge"}, {"score": 0.004105998946407227, "phrase": "exploratory_or_confirmatory_data_analysis"}, {"score": 0.0040569185796103845, "phrase": "relevant_performance_data_relationships"}, {"score": 0.0038663716354483176, "phrase": "simple_program"}, {"score": 0.00377446822050123, "phrase": "high_performance_computing"}, {"score": 0.003751834457361072, "phrase": "cloud_computing"}, {"score": 0.00362974436427641, "phrase": "innovative_system"}, {"score": 0.0035328029694928296, "phrase": "debugging_performance_problems"}, {"score": 0.003448801009772625, "phrase": "performance_behavior_analysis"}, {"score": 0.0032376465741070274, "phrase": "prior_knowledge"}, {"score": 0.0030120629787745426, "phrase": "performance_data"}, {"score": 0.0027853332413658666, "phrase": "process_behavior_dissimilarity"}, {"score": 0.0027686143852727156, "phrase": "code_region_behavior_disparity"}, {"score": 0.0026068329296254087, "phrase": "rough_set_theory"}, {"score": 0.0025678829712650437, "phrase": "innovative_approach"}, {"score": 0.0025371413754846474, "phrase": "root_causes"}, {"score": 0.002476755123108715, "phrase": "cluster_systems"}, {"score": 0.0024033190759769215, "phrase": "fortran"}, {"score": 0.0022022878843247257, "phrase": "experimental_approach"}, {"score": 0.002162844717299508, "phrase": "different_metrics"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["SPMD parallel programs", " Automatic performance debugging", " Performance bottleneck", " Root cause analysis", " Performance optimization"], "paper_abstract": "Automatic performance debugging of parallel applications includes two main steps: locating performance bottlenecks and uncovering their root causes for performance optimization. Previous work fails to resolve this challenging issue in two ways: first, several previous efforts automate locating bottlenecks, but present results in a confined way that only identifies performance problems with a priori knowledge: second, several tools take exploratory or confirmatory data analysis to automatically discover relevant performance data relationships, but these efforts do not focus on locating performance bottlenecks or uncovering their root causes. The simple program and multiple data (SPMD) programming model is widely used for both high performance computing and Cloud computing. In this paper, we design and implement an innovative system, AutoAnalyzer, that automates the process of debugging performance problems of SPMD-style parallel programs, including data collection, performance behavior analysis, locating bottlenecks, and uncovering their root causes. AutoAnalyzer is unique in terms of two features: first, without any prior knowledge, it automatically locates bottlenecks and uncovers their root causes for performance optimization; second, it is lightweight in terms of the size of performance data to be collected and analyzed. Our contributions are three-fold: first, we propose two effective clustering algorithms to investigate the existence of performance bottlenecks that cause process behavior dissimilarity or code region behavior disparity, respectively; meanwhile, we present two searching algorithms to locate bottlenecks; second, on the basis of the rough set theory, we propose an innovative approach to automatically uncover root causes of bottlenecks; third, on the cluster systems with two different configurations, we use two production applications, written in Fortran 77, and one open source code MPIBZIP2 (http://compression.ca/mpibzip2/), written in C++, to verify the effectiveness and correctness of our methods. For three applications, we also propose an experimental approach to investigating the effects of different metrics on locating bottlenecks. (C) 2011 Elsevier Inc. All rights reserved.", "paper_title": "Automatic performance debugging of SPMD-style parallel programs", "paper_id": "WOS:000291287900004"}