{"auto_keywords": [{"score": 0.043412284212692755, "phrase": "cas_operations"}, {"score": 0.014176591696180386, "phrase": "cas_operation"}, {"score": 0.00481495049065317, "phrase": "efficient_compare-and-swap_operations"}, {"score": 0.004715465748738294, "phrase": "non-blocking_-_use"}, {"score": 0.0044159264136285035, "phrase": "inter-thread_synchronization"}, {"score": 0.004376575566619566, "phrase": "key_weakness"}, {"score": 0.004247910389657671, "phrase": "memory_contention"}, {"score": 0.004210050422187886, "phrase": "multiple_threads"}, {"score": 0.004013733930501799, "phrase": "shared_variable's_value"}, {"score": 0.0038725043244407387, "phrase": "significant_degradation"}, {"score": 0.003781221188413525, "phrase": "cas"}, {"score": 0.0036808626034099973, "phrase": "failed_cas_operations"}, {"score": 0.0036263171149449997, "phrase": "memory_devices"}, {"score": 0.003583261176506348, "phrase": "successful_cas_operations"}, {"score": 0.00345712586265106, "phrase": "software-based_contention_management"}, {"score": 0.0034058845212645915, "phrase": "hardware-provided_cas_operations"}, {"score": 0.0033254681817919403, "phrase": "software_contention_management_layer"}, {"score": 0.003276171848389645, "phrase": "hardware_cas_instructions"}, {"score": 0.0032179767877362512, "phrase": "cas-based_concurrent_data_structures"}, {"score": 0.0030404045763332437, "phrase": "first_study"}, {"score": 0.002995321291230709, "phrase": "contention_management_algorithms"}, {"score": 0.0028726027956447885, "phrase": "java's_atomicreference_class"}, {"score": 0.0028131366865158302, "phrase": "native_cas_instruction"}, {"score": 0.0027963729616768784, "phrase": "simple_contention_management_mechanisms"}, {"score": 0.0027714139741120587, "phrase": "different_hardware_platforms"}, {"score": 0.002746677144043828, "phrase": "key_property"}, {"score": 0.002681783466572198, "phrase": "almost-transparent_interchange"}, {"score": 0.00266580039440334, "phrase": "java's_atomicreference_objects"}, {"score": 0.002618418957665835, "phrase": "concurrent_data_structures"}, {"score": 0.002518621016346282, "phrase": "cas-based_concurrent_implementations"}, {"score": 0.002503607929521596, "phrase": "widely-used_data_structures"}, {"score": 0.0024298709882519965, "phrase": "lightweight_software-based_contention_management_support"}, {"score": 0.0023724444453105983, "phrase": "high_contention_levels"}, {"score": 0.00231637194556478, "phrase": "low_contention"}, {"score": 0.002268394245801392, "phrase": "efficient_contention_management"}, {"score": 0.0022280604516919417, "phrase": "simpler_data-structure_implementation"}, {"score": 0.0021949961292124145, "phrase": "highly_optimized_implementations"}, {"score": 0.0021559645899673664, "phrase": "native_cas_operations"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Compare-and-swap", " contention management", " concurrent algorithms"], "paper_abstract": "Many concurrent data-structure implementations - both blocking and non-blocking - use the well-known compare-and-swap (CAS) operation, supported in hardware by most modern multiprocessor architectures, for inter-thread synchronization. A key weakness of the CAS operation is its performance in the presence of memory contention. When multiple threads concurrently attempt to apply CAS operations to the same shared variable, at most a single thread will succeed in changing the shared variable's value and the CAS operations of all other threads will fail. Moreover, significant degradation in performance occurs when variables manipulated by CAS become contention 'hot spots', because failed CAS operations congest the interconnect and memory devices and slow down successful CAS operations. In this work, we study the following question: can software-based contention management improve the efficiency of hardware-provided CAS operations? In other words, can a software contention management layer, encapsulating invocations of hardware CAS instructions, improve the performance of CAS-based concurrent data structures? To address this question, we conduct what is, to the best of our knowledge, the first study on the impact of contention management algorithms on the efficiency of the CAS operation. We implemented several Java classes, that extend Java's AtomicReference class, and encapsulate calls to the native CAS instruction with simple contention management mechanisms tuned for different hardware platforms. A key property of our algorithms is the support for an almost-transparent interchange with Java's AtomicReference objects, used in implementations of concurrent data structures. We evaluate the impact of these algorithms on both a synthetic micro-benchmark and on CAS-based concurrent implementations of widely-used data structures such as stacks and queues. Our performance evaluation establishes that lightweight software-based contention management support can greatly improve performance under medium and high contention levels while typically incurring only small overhead under low contention. In some cases, applying efficient contention management for CAS operations used by a simpler data-structure implementation yields better results than highly optimized implementations of the same data structure that use native CAS operations directly. Copyright (C) 2014 John Wiley & Sons, Ltd.", "paper_title": "Software-based contention management for efficient compare-and-swap operations", "paper_id": "WOS:000342806400004"}