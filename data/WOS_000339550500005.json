{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "higher-order_logic"}, {"score": 0.014463680079252458, "phrase": "functional_programs"}, {"score": 0.013206104138018766, "phrase": "programming_language"}, {"score": 0.011651417936442567, "phrase": "operational_semantics"}, {"score": 0.004778258911940497, "phrase": "pure_and_stateful_ml."}, {"score": 0.004687742829233727, "phrase": "proof_assistants"}, {"score": 0.004634291647527514, "phrase": "coq"}, {"score": 0.0045464538515249085, "phrase": "convenient_setting"}, {"score": 0.003991919038804365, "phrase": "ml"}, {"score": 0.003961354471278874, "phrase": "haskell"}, {"score": 0.003916098498242888, "phrase": "current_techniques"}, {"score": 0.0037546039916845947, "phrase": "similar_looking_objects"}, {"score": 0.0036413370053909886, "phrase": "set-theoretic_model"}, {"score": 0.0032836104153151973, "phrase": "automated_technique"}, {"score": 0.0032336801561165113, "phrase": "functional_program"}, {"score": 0.0031240868074933078, "phrase": "corresponding_program"}, {"score": 0.003088384809415812, "phrase": "functional_language"}, {"score": 0.0029722900280316216, "phrase": "mechanically_checked_theorem"}, {"score": 0.0028278480051602355, "phrase": "verified_properties"}, {"score": 0.0027955219242123013, "phrase": "logical_function"}, {"score": 0.0025892330566358503, "phrase": "standard_ml"}, {"score": 0.0024918548761791435, "phrase": "functional_data_structures"}, {"score": 0.0024633601573822114, "phrase": "parser_generator"}, {"score": 0.002444544487772349, "phrase": "cryptographic_algorithms"}, {"score": 0.002416589459425828, "phrase": "garbage_collector"}, {"score": 0.002361632539339945, "phrase": "hol_light_theorem_prover"}, {"score": 0.0022041312401435346, "phrase": "state-and-exception_monad"}, {"score": 0.002129356014992349, "phrase": "stateful_ml_code"}, {"score": 0.0021049977753042253, "phrase": "hol_light_example"}], "paper_keywords": [""], "paper_abstract": "The higher-order logic found in proof assistants such as Coq and various HOL systems provides a convenient setting for the development and verification of functional programs. However, to efficiently run these programs, they must be converted (or 'extracted') to functional programs in a programming language such as ML or Haskell. With current techniques, this step, which must be trusted, relates similar looking objects that have very different semantic definitions, such as the set-theoretic model of a logic and the operational semantics of a programming language. In this paper, we show how to increase the trustworthiness of this step with an automated technique. Given a functional program expressed in higher-order logic, our technique provides the corresponding program for a functional language defined with an operational semantics, and it provides a mechanically checked theorem relating the two. This theorem can then be used to transfer verified properties of the logical function to the program. We have implemented our technique in the HOL4 theorem prover, translating functions to a subset of Standard ML, and have applied the implementation to examples including functional data structures, a parser generator, cryptographic algorithms, a garbage collector and the 500-line kernel of the HOL light theorem prover. This paper extends our previous conference publication with new material that shows how functions defined in terms of a state-and-exception monad can be translated, with proofs, into stateful ML code. The HOL light example is also new.", "paper_title": "Proof-producing translation of higher-order logic into pure and stateful ML", "paper_id": "WOS:000339550500005"}