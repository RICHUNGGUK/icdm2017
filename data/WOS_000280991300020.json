{"auto_keywords": [{"score": 0.040398493807671056, "phrase": "pointer-based_trees"}, {"score": 0.00481495049065317, "phrase": "matrix_trees"}, {"score": 0.004688321299229397, "phrase": "new_data_representation"}, {"score": 0.004492573860101133, "phrase": "memory_size"}, {"score": 0.004444921827311577, "phrase": "algorithm_speed"}, {"score": 0.00439777299939725, "phrase": "existing_techniques"}, {"score": 0.004327981760540394, "phrase": "pointerless_approaches"}, {"score": 0.004259293347851015, "phrase": "regular_structure"}, {"score": 0.0041251561573501455, "phrase": "efficient_data_access"}, {"score": 0.0038900709793274484, "phrase": "tree_increases"}, {"score": 0.003668333531296882, "phrase": "tree_nodes"}, {"score": 0.003571751184289622, "phrase": "typical_sparsity"}, {"score": 0.0035338315037521627, "phrase": "large_trees"}, {"score": 0.003314591878914152, "phrase": "explicit_pointers"}, {"score": 0.003261934055562238, "phrase": "different_levels"}, {"score": 0.0031760175583084274, "phrase": "pointerless_approach"}, {"score": 0.003108911488613549, "phrase": "tree_level"}, {"score": 0.002994859407965545, "phrase": "traditional_pointerless_trees"}, {"score": 0.002900426826591769, "phrase": "novel_data_organization"}, {"score": 0.002794001681064862, "phrase": "tree's_regular_structure"}, {"score": 0.0027058852678238632, "phrase": "tree_operations"}, {"score": 0.0026345758986796703, "phrase": "sparse_matrix_data_structure"}, {"score": 0.0025109095718850376, "phrase": "sparse_and_dense_trees"}, {"score": 0.00232995025271599, "phrase": "data_set"}, {"score": 0.0021621690817987893, "phrase": "gpu"}, {"score": 0.0021049977753042253, "phrase": "typical_visualization_scenarios"}], "paper_keywords": [""], "paper_abstract": "We propose a new data representation for octrees and kd-trees that improves upon memory size and algorithm speed of existing techniques. While pointerless approaches exploit the regular structure of the tree to facilitate efficient data access, their memory footprint becomes prohibitively large as the height of the tree increases. Pointer-based trees require memory consumption proportional to the number of tree nodes, thus exploiting the typical sparsity of large trees. Yet, their traversal is slowed by the need to follow explicit pointers across the different levels. Our solution is a pointerless approach that represents each tree level with its own matrix, as opposed to traditional pointerless trees that use only a single vector. This novel data organization allows us to fully exploit the tree's regular structure and improve the performance of tree operations. By using a sparse matrix data structure we obtain a representation that is suited for sparse and dense trees alike. In particular, it uses less total memory than pointer-based trees even when the data set is extremely sparse. We show how our approach is easily implemented on the GPU and illustrate its performance in typical visualization scenarios.", "paper_title": "Matrix Trees", "paper_id": "WOS:000280991300020"}