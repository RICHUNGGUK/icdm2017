{"auto_keywords": [{"score": 0.0495648351427175, "phrase": "genetic_programming"}, {"score": 0.00481495049065317, "phrase": "bloat_control_methods"}, {"score": 0.004392565073466714, "phrase": "average_size"}, {"score": 0.004050625770007516, "phrase": "tree-based_genetic_programming_individuals"}, {"score": 0.003921393143378986, "phrase": "allowed_depth"}, {"score": 0.0035965032173588753, "phrase": "excess_size"}, {"score": 0.0029126002350975634, "phrase": "nine_bloat_control_methods"}, {"score": 0.0025031188149336257, "phrase": "bloat_control_method"}, {"score": 0.002436289099444074, "phrase": "per-problem_basis"}, {"score": 0.0021394674440767124, "phrase": "unexpected_winner"}, {"score": 0.0021049977753042253, "phrase": "cross-platform_category"}], "paper_keywords": [""], "paper_abstract": "Genetic programming has highlighted the problem of bloat, the uncontrolled growth of the average size of an individual in the population. The most common approach to dealing with bloat in tree-based genetic programming individuals is to limit their maximal allowed depth. An alternative to depth limiting is to punish individuals in some way based on excess size, and our experiments have shown that the combination of depth limiting with such a punitive method is generally more effective than either alone. Which such combinations are most effective at reducing bloat? In this article we augment depth limiting with nine bloat control methods and compare them with one another. These methods are chosen from past literature and from techniques of our own devising. esting with four genetic programming problems, we identify where each bloat control method performs well on a per-problem basis, and under what settings various methods are effective independent of problem. We report on the results of these tests, and discover an unexpected winner in the cross-platform category.", "paper_title": "A comparison of bloat control methods for genetic programming", "paper_id": "WOS:000240667000004"}