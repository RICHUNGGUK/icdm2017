{"auto_keywords": [{"score": 0.015616903057111652, "phrase": "java"}, {"score": 0.01332077109022332, "phrase": "vm"}, {"score": 0.00473509474652851, "phrase": "java_language"}, {"score": 0.00447331713604276, "phrase": "embedded_devices"}, {"score": 0.004443482801729777, "phrase": "high-performance_systems"}, {"score": 0.004399102320426124, "phrase": "platform-independent_property"}, {"score": 0.004268591456106124, "phrase": "java_bytecode_level"}, {"score": 0.004100555318595827, "phrase": "virtual_machine"}, {"score": 0.0039259432210911925, "phrase": "underlying_hardware_platform"}, {"score": 0.0036349635956605675, "phrase": "behavioral_characteristics"}, {"score": 0.0035507457285983268, "phrase": "large_set"}, {"score": 0.0035270425911920595, "phrase": "java_benchmarks"}, {"score": 0.0033994943214460615, "phrase": "ibm"}, {"score": 0.0033206861608068025, "phrase": "powerpc-based_ibm_machine"}, {"score": 0.003265531406540679, "phrase": "powerpc_machine"}, {"score": 0.0026263842544386948, "phrase": "minimally_required_heap_size"}, {"score": 0.0024975854002361794, "phrase": "hardware_performance_monitors"}, {"score": 0.0024152394732063908, "phrase": "significantly_larger_number"}, {"score": 0.0023990982005125763, "phrase": "data_cache"}, {"score": 0.0023434465472518943, "phrase": "memory_hierarchy"}, {"score": 0.0022661710658109916, "phrase": "sufficiently_large_heap"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Java", " Virtual Machine", " 64-bit versus 32-bit computing", " performance evaluation", " PowerPC"], "paper_abstract": "The Java language is popular because of its platform independence, making it useful in a lot of technologies ranging from embedded devices to high-performance systems. The platform-independent property of Java, which is visible at the Java bytecode level, is only made possible thanks to the availability of a Virtual Machine (VM), which needs to be designed specifically for each underlying hardware platform. More specifically, the same Java bytecode should run properly on a 32-bit or a 64-bit VM. In this paper, we compare the behavioral characteristics of 32-bit and 64-bit VMs using a large set of Java benchmarks. This is done using the Jikes Research VM as well as the IBM JDK 1.4.0 production VM on a PowerPC-based IBM machine. By running the PowerPC machine in both 32-bit and 64-bit mode we are able to compare 32-bit and 64-bit VMs. We conclude that the space an object takes in the heap in 64-bit mode is 39.3% larger on average than in 32-bit mode. We identify three reasons for this: (i) the larger pointer size, (ii) the increased header and (iii) the increased alignment. The minimally required heap size is 51.1% larger on average in 64-bit than in 32-bit mode. From our experimental setup using hardware performance monitors, we observe that 64-bit computing typically results in a significantly larger number of data cache misses at all levels of the memory hierarchy. In addition, we observe that when a sufficiently large heap is available, the IBM JDK 1.4.0 VM is 1.7% slower on average in 64-bit mode than in 32-bit mode. Copyright (c) 2005 John Wiley & Sons, Ltd.", "paper_title": "64-bit versus 32-bit virtual machines for Java", "paper_id": "WOS:000234610800001"}