{"auto_keywords": [{"score": 0.04230702677122493, "phrase": "tupling_transformation"}, {"score": 0.00481495049065317, "phrase": "redundant_call_elimination"}, {"score": 0.004669845451682529, "phrase": "important_program_optimisation_process"}, {"score": 0.004494570360108983, "phrase": "super-linear_speedup"}, {"score": 0.0038271712887391015, "phrase": "first-order_functional_language"}, {"score": 0.0033599501775954024, "phrase": "restricted_variant"}, {"score": 0.0031360786664165093, "phrase": "single_recursion_argument"}, {"score": 0.003018196463874475, "phrase": "semantic_understanding"}, {"score": 0.0029722900280316216, "phrase": "call_redundancy"}, {"score": 0.002649472341607234, "phrase": "multiple_recursion_arguments"}, {"score": 0.002290291401956985, "phrase": "polynomial_complexity"}, {"score": 0.0021049977753042253, "phrase": "compiler_optimisation"}], "paper_keywords": [""], "paper_abstract": "Redundant call elimination has been an important program optimisation process as it can produce super-linear speedup in optimised programs. In this paper, we investigate use of the tupling transformation in achieving this optimisation over a first-order functional language. Standard tupling technique, as described in [6], works excellently in a restricted variant of the language; namely, functions with single recursion argument. We provide a semantic understanding of call redundancy, upon which we construct an analysis for handling the tupling of functions with multiple recursion arguments. The analysis provides a means to ensure termination of the tupling transformation. As the analysis is of polynomial complexity, it makes the tupling suitable as a step in compiler optimisation.", "paper_title": "Redundant call elimination via tupling", "paper_id": "WOS:000235949900002"}