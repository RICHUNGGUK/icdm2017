{"auto_keywords": [{"score": 0.047004135453779426, "phrase": "visualization_systems"}, {"score": 0.00481495049065317, "phrase": "pipeline_model"}, {"score": 0.0046683172874085015, "phrase": "conceptual_model"}, {"score": 0.004627244470096107, "phrase": "data_processing"}, {"score": 0.004566308708871429, "phrase": "widely_used_architecture"}, {"score": 0.004106725110985659, "phrase": "distributed_pipelines"}, {"score": 0.004052616113326177, "phrase": "demand-driven_processing"}, {"score": 0.003911771812701971, "phrase": "stateful_programming_technologies"}, {"score": 0.0036932254391253134, "phrase": "lower_layers"}, {"score": 0.0036445446531633368, "phrase": "complex_hierarchy"}, {"score": 0.0035648266669315943, "phrase": "good_news"}, {"score": 0.003191560305761507, "phrase": "bad_news"}, {"score": 0.0030942116765996426, "phrase": "low-level_services"}, {"score": 0.0028826733506942554, "phrase": "programming_language"}, {"score": 0.00278237555651743, "phrase": "processing_model"}, {"score": 0.0027578496677536373, "phrase": "lazy_functional_languages"}, {"score": 0.002733539375462443, "phrase": "fine-grained_demand-driven_processing"}, {"score": 0.002447101794397243, "phrase": "visualization_applications"}, {"score": 0.0024148064819862337, "phrase": "surface_extraction_algorithms"}, {"score": 0.0023935128386292966, "phrase": "illustrative_examples"}, {"score": 0.0023204771421446433, "phrase": "haskell"}, {"score": 0.0022496114364599328, "phrase": "clear_and_concise_expression"}, {"score": 0.002123730137917387, "phrase": "functional_abstraction"}, {"score": 0.0021049977753042253, "phrase": "new_insight"}], "paper_keywords": ["pipeline model", " laziness", " functional programming"], "paper_abstract": "The pipeline model in visualization has evolved from a conceptual model of data processing into a widely used architecture for implementing visualization systems. In the process, a number of capabilities have been introduced, including streaming of data in chunks, distributed pipelines, and demand-driven processing. Visualization systems have invariably built on stateful programming technologies, and these capabilities have had to be implemented explicitly within the lower layers of a complex hierarchy of services. The good news for developers is that applications built on top of this hierarchy can access these capabilities without concern for how they are implemented. The bad news is that by freezing capabilities into low-level services expressive power and flexibility is lost. In this paper we express visualization systems in a programming language that more naturally supports this kind of processing model. Lazy functional languages support fine-grained demand-driven processing, a natural form of streaming, and pipeline-like function composition for assembling applications. The technology thus appears well suited to visualization applications. Using surface extraction algorithms as illustrative examples, and the lazy functional language Haskell, we argue the benefits of clear and concise expression combined with fine-grained, demand-driven computation. Just as visualization provides insight into data, functional abstraction provides new insight into visualization.", "paper_title": "Fine-grained visualization pipelines and lazy functional languages", "paper_id": "WOS:000241383300041"}