{"auto_keywords": [{"score": 0.048809793344885305, "phrase": "algebraic_laws"}, {"score": 0.046363267640327735, "phrase": "dynamic_binding"}, {"score": 0.04127853893061471, "phrase": "normal_form"}, {"score": 0.00481495049065317, "phrase": "sequential_object-oriented_programming"}, {"score": 0.00454772672262359, "phrase": "sequential_java"}, {"score": 0.004471978831302331, "phrase": "recursive_classes"}, {"score": 0.004368037394395782, "phrase": "type_tests"}, {"score": 0.0038702962539127867, "phrase": "imperative_program"}, {"score": 0.0036430378180975667, "phrase": "empty_bodies"}, {"score": 0.003594369823549604, "phrase": "object_class"}, {"score": 0.003131393466870228, "phrase": "behaviour_preserving_program_transformations"}, {"score": 0.002821403369887269, "phrase": "java"}, {"score": 0.0024742098091226203, "phrase": "reduction_strategy"}, {"score": 0.002400373755068185, "phrase": "presented_laws"}, {"score": 0.002199189123395672, "phrase": "reference_semantics"}], "paper_keywords": [""], "paper_abstract": "In this chapter, we present algebraic laws for a language similar to a subset of sequential Java that includes inheritance, recursive classes, dynamic binding, access control, type tests and casts, assignment, but no sharing. We show that these laws are complete, in the sense that they are sufficient to reduce any program to a normal form substantially close to an imperative program: classes and inheritance are used only to preserve the notion of subtyping; all classes have empty bodies, except the object class, which collects all the attributes moved up from all its subclasses. Methods are also eliminated by first resolving dynamic binding, and then in-lining their bodies in place of the calls. This suggests that our laws are expressive enough to formally derive behaviour preserving program transformations; this is illustrated through the derivation of refactorings. We present the motivation for our work in Section 1. In Section 2, we give an overview of the subset of Java that we consider. After that, in Section 3, we present the algebraic laws of our language, concentrating on its object-oriented features. Completeness of our set of laws is considered in Section 4, where we present the normal form and a reduction strategy. In Section 5 we show how the presented laws can serve as a basis for proving refactorings. Section 6 summarises our results, briefly discusses soundness of the laws, considers the impact of reference semantics, relates our results with work involving concurrency, and suggests topics for further research.", "paper_title": "Transformation laws for sequential object-oriented programming", "paper_id": "WOS:000241694300002"}