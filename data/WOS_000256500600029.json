{"auto_keywords": [{"score": 0.0428614620458835, "phrase": "initial_algebras"}, {"score": 0.00481495049065317, "phrase": "structured_programming"}, {"score": 0.004680851157467745, "phrase": "cutting_edge"}, {"score": 0.004647911247507267, "phrase": "functional_programming"}, {"score": 0.004455061431809975, "phrase": "semantic_foundations"}, {"score": 0.004439354841093929, "phrase": "underlying_gadts"}, {"score": 0.004180622964109706, "phrase": "standard_theory"}, {"score": 0.004151188559520802, "phrase": "data_types"}, {"score": 0.003992950134435965, "phrase": "algebraic_and_nested_data_types"}, {"score": 0.0038271712887391015, "phrase": "initial_algebra_semantics"}, {"score": 0.0036942726653704213, "phrase": "accumulated_knowledge"}, {"score": 0.0034421126037849, "phrase": "expressive_and_principled_tools"}, {"score": 0.0033937776228549557, "phrase": "well-known_and_widely-used_ones"}, {"score": 0.0030306764358079214, "phrase": "gadt"}, {"score": 0.0030093137393901355, "phrase": "initial_algebra_package"}, {"score": 0.0029150253706493852, "phrase": "constructive_demonstration"}, {"score": 0.0025938179480905783, "phrase": "particular_syntactic_presentation"}, {"score": 0.0025755270174228225, "phrase": "gadts"}, {"score": 0.0025036399134110822, "phrase": "host_language"}, {"score": 0.002433754579432554, "phrase": "metatheoretical_artifact"}, {"score": 0.002408052242408488, "phrase": "main_technical_ideas"}, {"score": 0.0022997683233147125, "phrase": "higher-order_functor"}, {"score": 0.0022041312401435346, "phrase": "higher-order_functors"}, {"score": 0.0021425882815624803, "phrase": "left_kan_extensions"}, {"score": 0.0021199543519570376, "phrase": "arbitrary_gadts"}, {"score": 0.0021049977753042253, "phrase": "simpler-but-equivalent_ones"}], "paper_keywords": ["languages", " theory"], "paper_abstract": "GADTs are at the cutting edge of functional programming and become more widely used every day. Nevertheless, the semantic foundations underlying GADTs are not well understood. In this paper we solve this problem by showing that the standard theory of data types as carriers of initial algebras of functors can be extended from algebraic and nested data types to GADTs. We then use this observation to derive an initial algebra semantics for GADTs, thus ensuring that all of the accumulated knowledge about initial algebras can be brought to bear on them. Next, we use our initial algebra semantics for GADTs to derive expressive and principled tools analogous to the well-known and widely-used ones for algebraic and nested data types - for reasoning about, programming with, and improving the performance of programs involving, GADTs; we christen such a collection of tools for a GADT an initial algebra package. Along the way, we give a constructive demonstration that every GADT can be reduced to one which uses only the equality GADT and existential quantification. Although other such reductions exist in the literature, ours is entirely local, is independent of any particular syntactic presentation of GADTs, and can be implemented in the host language, rather than existing solely as a metatheoretical artifact. The main technical ideas underlying our approach are (i) to modify the notion of a higher-order functor so that GADTs can be seen as carriers of initial algebras of higher-order functors, and (ii) to use left Kan extensions to trade arbitrary GADTs for simpler-but-equivalent ones for which initial algebra semantics can be derived.", "paper_title": "Foundations for structured programming with GADTs", "paper_id": "WOS:000256500600029"}