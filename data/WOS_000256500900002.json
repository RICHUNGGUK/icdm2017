{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "program_slicing"}, {"score": 0.004429727701202369, "phrase": "modular_behavioral_analysis"}, {"score": 0.004363058588000252, "phrase": "modular_reasoning"}, {"score": 0.004297388539539564, "phrase": "aspect-oriented_language"}, {"score": 0.004075198669927074, "phrase": "traditional_paradigms"}, {"score": 0.003748937184382714, "phrase": "object-oriented_language"}, {"score": 0.0036368625017975343, "phrase": "crosscutting_modules"}, {"score": 0.0032951702142329357, "phrase": "pre-condition_and_post-condition_failures"}, {"score": 0.0028309318332306703, "phrase": "checking_algorithm"}, {"score": 0.002623881637290192, "phrase": "repeated_contract_checks"}, {"score": 0.002564763827975352, "phrase": "original_algorithm"}, {"score": 0.0023591417077156555, "phrase": "unnecessary_repeat_checks"}], "paper_keywords": ["aspect-oriented language", " crosscutting safety", " crosscutting quality", " crosscutting interference"], "paper_abstract": "Owing to the characteristics of quantification and obliviousness, modular behavioral analysis and modular reasoning in aspect-oriented language are more difficult than that of traditional paradigms. Similar to the method of Design by Contract in object-oriented language, we annotate crosscutting modules and affected modules with pre-conditions and post-conditions. Because assigning blame for pre-condition and post-condition failures during the process of crosscutting is subtle and complex, we introduce a notion of crosscutting invariant and a checking algorithm based on this notion. Since there are some repeated contract checks in the original algorithm, we use the technology of program slicing to search those unnecessary repeat checks and delete them. We also represent an example to represent the algorithm and its improvement.", "paper_title": "Crosscutting invariant and an efficient checking algorithm using program slicing", "paper_id": "WOS:000256500900002"}