{"auto_keywords": [{"score": 0.04559556617638774, "phrase": "call_strings"}, {"score": 0.03984961577718066, "phrase": "contribution_information"}, {"score": 0.02823868227936384, "phrase": "contribution-based_call_stack_abstraction"}, {"score": 0.00481495049065317, "phrase": "call_string"}, {"score": 0.00466016686289196, "phrase": "different_method_calls"}, {"score": 0.004595356579614969, "phrase": "different_contributions"}, {"score": 0.004468415400599571, "phrase": "final_application"}, {"score": 0.004304574865291508, "phrase": "existing_call_string"}, {"score": 0.00428451995524549, "phrase": "based_pointer_analysis_algorithms"}, {"score": 0.0040890178236849825, "phrase": "best_cost-effectiveness"}, {"score": 0.003689628075766217, "phrase": "call_string_based_pointer_analysis"}, {"score": 0.0035376693476114733, "phrase": "contribution-based_call_stack_abstraction_method"}, {"score": 0.0032370412139943808, "phrase": "new_call_stack_abstraction_method"}, {"score": 0.0031480082727877667, "phrase": "aspect"}, {"score": 0.0030461580449080553, "phrase": "concern-sensitive_points"}, {"score": 0.003003726508522467, "phrase": "analysis_method"}, {"score": 0.0029343128039167185, "phrase": "new_abstraction_method"}, {"score": 0.0028664985822266344, "phrase": "multi-threaded_java_programs"}, {"score": 0.0028002471976921054, "phrase": "thread-sensitive_pointer_analysis_method"}, {"score": 0.002735522834514124, "phrase": "experimental_results"}, {"score": 0.002550165781755603, "phrase": "ordinary_call_string"}, {"score": 0.002456486927713543, "phrase": "harmful_advices"}, {"score": 0.002388487669097511, "phrase": "inter-thread_data_flow"}, {"score": 0.002333258365963461, "phrase": "pointer_analysis_methods"}, {"score": 0.002195552442011313, "phrase": "better_cost-effectiveness"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Pointer analysis", " Contribution-based", " Stack abstraction", " Aspect-oriented", " Multi-threaded", " Data flow"], "paper_abstract": "Context: Different method calls may have different contributions to the precision of the final application when abstracted into the call strings. The existing call string based pointer analysis algorithms do not consider such contribution difference and hence may not achieve best cost-effectiveness. Objective: To be more cost-effective, we try to leverage the contribution information of each method call in call string based pointer analysis. Method: The paper firstly proposes a contribution-based call stack abstraction method which abstracts the call stacks into call strings with the contribution information under consideration. Then, we apply the new call stack abstraction method to the pointer analysis of Aspect., programs and propose a concern-sensitive points-to analysis method. Besides, the new abstraction method is also applied to multi-threaded Java programs and results in a thread-sensitive pointer analysis method. Results: The experimental results show that the two pointer analysis methods with contribution-based call stack abstraction can be more cost-effective than the ordinary call string based approaches for an application that detects harmful advices and an application that detects inter-thread data flow. Conclusion: These pointer analysis methods more concretely and more clearly show that the contribution-based call stack abstraction can lead to better cost-effectiveness for the given applications. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Contribution-based call stack abstraction for call string based pointer analysis", "paper_id": "WOS:000290460900010"}