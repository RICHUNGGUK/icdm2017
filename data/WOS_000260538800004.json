{"auto_keywords": [{"score": 0.03600109886723128, "phrase": "high-level_models"}, {"score": 0.00481495049065317, "phrase": "model_checkers"}, {"score": 0.004665162327051461, "phrase": "formal_verification"}, {"score": 0.004623224002010226, "phrase": "high-level_design_models"}, {"score": 0.004167086373747367, "phrase": "model_checking"}, {"score": 0.003929391999210588, "phrase": "implementation_level_artifacts"}, {"score": 0.003738847528809348, "phrase": "hand-crafted_representations"}, {"score": 0.003235305151177897, "phrase": "different_way"}, {"score": 0.002639502113350897, "phrase": "model_checker"}, {"score": 0.002592163447843447, "phrase": "powerful_forms"}, {"score": 0.0024774888010414206, "phrase": "abstract_state_space"}, {"score": 0.002433048706565187, "phrase": "verification_process"}, {"score": 0.002400241288973103, "phrase": "model-driven_code_checking_method"}, {"score": 0.0023465400668244386, "phrase": "implementation_level_code"}, {"score": 0.0023148964315569866, "phrase": "high-level_safety"}, {"score": 0.0021241414408077895, "phrase": "new_paradigm"}, {"score": 0.0021049977753042253, "phrase": "code_verification"}], "paper_keywords": ["Software verification", " Logic model checking", " Spin model checker", " Embedded C code"], "paper_abstract": "Model checkers were originally developed to support the formal verification of high-level design models of distributed system designs. Over the years, they have become unmatched in precision and performance in this domain. Research in model checking has meanwhile moved towards methods that allow us to reason also about implementation level artifacts (e.g., software code) directly, instead of hand-crafted representations of those artifacts. This does not mean that there is no longer a place for the use of high-level models, but it does mean that such models are used in a different way today. In the approach that we describe here, high-level models are used to represent the environment for which the code is to be verified, but not the application itself. The code of the application is now executed as is by the model checker, while using powerful forms of abstraction on-the-fly to build the abstract state space that guides the verification process. This model-driven code checking method allows us to verify implementation level code efficiently for high-level safety and liveness properties. In this paper, we give an overview of the methodology that supports this new paradigm of code verification.", "paper_title": "Model driven code checking", "paper_id": "WOS:000260538800004"}