{"auto_keywords": [{"score": 0.04664820233091626, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "lazy_higher-order_functional_programs"}, {"score": 0.004582812484394996, "phrase": "alfl"}, {"score": 0.004515004397496303, "phrase": "functional_languages"}, {"score": 0.00427578268550103, "phrase": "orwell"}, {"score": 0.004212759658511567, "phrase": "ponder."}, {"score": 0.003740770420003364, "phrase": "imperative_languages"}, {"score": 0.003472927015404464, "phrase": "data_objects"}, {"score": 0.0032563083791198534, "phrase": "compound_data_structures"}, {"score": 0.003176626803985225, "phrase": "\"lazy\"_evaluation_strategy"}, {"score": 0.003023047748772801, "phrase": "data_flow_analysis"}, {"score": 0.0026973310437053573, "phrase": "\"safe\"_descriptions"}, {"score": 0.002605329434787829, "phrase": "intermediate_results"}, {"score": 0.002579622880371082, "phrase": "regular_sets"}, {"score": 0.0025289662786567896, "phrase": "potential_applications"}, {"score": 0.0024793019587009035, "phrase": "strictness_analysis"}, {"score": 0.002454835845644037, "phrase": "partial_evaluation"}, {"score": 0.0023947191132328233, "phrase": "earlier_work"}, {"score": 0.0023130151703068444, "phrase": "higher-order_functions"}, {"score": 0.0022010965931147735, "phrase": "call-by-name_aspect"}], "paper_keywords": ["collecting semantics", " higher-order program", " program flow analysis", " lazy evaluation", " Reynolds analysis of applicative LISP programs", " term rewriting system", " tree grammar"], "paper_abstract": "In recent years much interest has been shown in a class of functional languages including HASKELL, lazy ML, SASL/KRC/MIRANDA, ALFL, ORWELL, and PONDER. It has been seen that their expressive power is great, programs are compact, and program manipulation and transformation is much easier than with imperative languages or more traditional applicative ones. Common characteristics: they are purely applicative, manipulate trees as data objects, use pattern matching both to determine control flow and to decompose compound data structures, and use a \"lazy\" evaluation strategy. In this paper we describe a technique for data flow analysis of programs in this class by safely approximating the behavior of a certain class of term rewriting systems. In particular we obtain \"safe\" descriptions of program inputs, outputs and intermediate results by regular sets of trees. Potential applications include optimization, strictness analysis and partial evaluation. The technique improves earlier work because of its applicability to programs with higher-order functions, and with either eager or lazy evaluation. The technique addresses the call-by-name aspect of laziness, but not memoization. (c) 2007 Elsevier B.V. All rights reserved.", "paper_title": "Flow analysis of lazy higher-order functional programs", "paper_id": "WOS:000246750700007"}