{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "\"compact\"_semantics"}, {"score": 0.004518442937844318, "phrase": "effective_semantics-based_program_manipulation_tools"}, {"score": 0.004017989546119125, "phrase": "functional_programming"}, {"score": 0.0037336520904376687, "phrase": "input_expression"}, {"score": 0.0034355662264234864, "phrase": "smaller_set"}, {"score": 0.002995427206425849, "phrase": "semantic_closure"}, {"score": 0.0028244513779243107, "phrase": "ascertained_conditions"}, {"score": 0.002548331088496964, "phrase": "big-step_semantics"}, {"score": 0.002379379676378223, "phrase": "fixpoint_computation"}, {"score": 0.0021678232353129472, "phrase": "prototypical_implementation"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Term rewriting systems", " Functional programming", " Denotational semantics", " Operational semantics", " Fixpoint semantics", " Goal-independent semantics"], "paper_abstract": "This work is motivated by the fact that a \"compact\" semantics for term rewriting systems, which is essential for the development of effective semantics-based program manipulation tools (e.g. automatic program analyzers and debuggers), does not exist. The big-step rewriting semantics that is most commonly considered in functional programming is the set of values/normal forms that the program is able to compute for any input expression. Such a big-step semantics is unnecessarily oversized, as it contains many \"semantically useless\" elements that can be retrieved from a smaller set of terms. Therefore, in this article, we present a compressed, goal-independent collecting fixpoint semantics that contains the smallest set of terms that are sufficient to describe, by semantic closure, all possible rewritings. We prove soundness and completeness under ascertained conditions. The compactness of the semantics makes it suitable for applications. Actually, our semantics can be finite whereas the big-step semantics is generally not, and even when both semantics are infinite, the fixpoint computation of our semantics produces fewer elements at each step. To support this claim we report several experiments performed with a prototypical implementation. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "A compact fixpoint semantics for term rewriting systems", "paper_id": "WOS:000281020500003"}