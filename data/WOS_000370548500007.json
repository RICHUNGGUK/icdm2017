{"auto_keywords": [{"score": 0.03700385809508468, "phrase": "new_opportunities"}, {"score": 0.0322229253613515, "phrase": "worst_case_time"}, {"score": 0.00481495049065317, "phrase": "high_performance_garbage_collected_languages"}, {"score": 0.004721162131188487, "phrase": "design_space"}, {"score": 0.004516733575701128, "phrase": "running_program"}, {"score": 0.004406994912939125, "phrase": "well-defined_points"}, {"score": 0.004278807087784626, "phrase": "exact_garbage_collection"}, {"score": 0.00376488621224566, "phrase": "yieldpoint_design_choices"}, {"score": 0.003709693561373117, "phrase": "previously_undocumented_designs"}, {"score": 0.003168859801438632, "phrase": "common_case_execution_time_overhead"}, {"score": 0.002914288956035066, "phrase": "java_benchmarks"}, {"score": 0.00266693888510356, "phrase": "untaken_yieldpoints"}, {"score": 0.0026278444968308103, "phrase": "vm"}, {"score": 0.0024891269874339553, "phrase": "modern_hardware"}, {"score": 0.0022113879114507577, "phrase": "new_insight"}, {"score": 0.0021789194955896124, "phrase": "critical_but_overlooked_aspect"}, {"score": 0.002157538586313944, "phrase": "garbage_collector_implementation"}, {"score": 0.0021049977753042253, "phrase": "new_optimization"}], "paper_keywords": ["yieldpoints", " safe points", " code patching", " managed code", " managed run-time"], "paper_abstract": "Yieldpoints are critical to the implementation of high performance garbage collected languages, yet the design space is not well understood. Yieldpoints allow a running program to be interrupted at well-defined points in its execution, facilitating exact garbage collection, biased locking, on-stack replacement, profiling, and other important virtual machine behaviors. In this paper we identify and evaluate yieldpoint design choices, including previously undocumented designs and optimizations. One of the designs we identify opens new opportunities for very low overhead profiling. We measure the frequency with which yieldpoints are executed and establish a methodology for evaluating the common case execution time overhead. We also measure the median and worst case time-to-yield. We find that Java benchmarks execute about 100 M yieldpoints per second, of which about 1/20000 are taken. The average execution time overhead for untaken yieldpoints on the VM we use ranges from 2.5% to close to zero on modern hardware, depending on the design, and we find that the designs trade off total overhead with worst case time-to-yield. This analysis gives new insight into a critical but overlooked aspect of garbage collector implementation, and identifies a new optimization and new opportunities for very low overhead profiling.", "paper_title": "Stop and Go: Understanding Yieldpoint Behavior", "paper_id": "WOS:000370548500007"}