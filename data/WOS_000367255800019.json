{"auto_keywords": [{"score": 0.046800023565389516, "phrase": "multicore_cpus"}, {"score": 0.033255588523354467, "phrase": "rewrite_rules"}, {"score": 0.00481495049065317, "phrase": "rewrite_rules_from_high-level_functional_expressions"}, {"score": 0.004769702911065878, "phrase": "high-performance_opencl_code"}, {"score": 0.004528301408585875, "phrase": "heterogeneous_hardware"}, {"score": 0.00438105507792004, "phrase": "parallel_systems"}, {"score": 0.004339867166576126, "phrase": "tremendous_computational_power"}, {"score": 0.004238576355081601, "phrase": "increased_programming_effort"}, {"score": 0.004081385289516914, "phrase": "code_portability"}, {"score": 0.0038930368103015467, "phrase": "low-level_imperative_language"}, {"score": 0.0038564191670589884, "phrase": "hardware-specific_optimizations"}, {"score": 0.003802135020791801, "phrase": "maximum_performance"}, {"score": 0.003475582268210954, "phrase": "novel_approach"}, {"score": 0.003410479630045025, "phrase": "high-level_programming"}, {"score": 0.0032376465741070274, "phrase": "high-level_functional_expression"}, {"score": 0.0031769866037536045, "phrase": "simple_set"}, {"score": 0.0030590445140753187, "phrase": "low-level_functional_representation"}, {"score": 0.002987557906013826, "phrase": "opencl_programming_model"}, {"score": 0.002931569771634119, "phrase": "opencl_code"}, {"score": 0.0028093921138602606, "phrase": "possible_implementations"}, {"score": 0.0027178867838199734, "phrase": "hardware-specific_opencl_implementations"}, {"score": 0.0026293540353514075, "phrase": "core_dependently-typed_lambda-calculus"}, {"score": 0.0023030731312573246, "phrase": "high_performance_imperative_opencl_code"}, {"score": 0.002196609505859369, "phrase": "hardware-specific_implementations"}, {"score": 0.002175913488493802, "phrase": "simple_functional_high-level_algorithmic_expressions"}, {"score": 0.0021049977753042253, "phrase": "highly_tuned_code"}], "paper_keywords": ["Algorithmic patterns", " rewrite rules", " performance portability", " GPU", " OpenCL", " code generation"], "paper_abstract": "Computers have become increasingly complex with the emergence of heterogeneous hardware combining multicore CPUs and GPUs. These parallel systems exhibit tremendous computational power at the cost of increased programming effort resulting in a tension between performance and code portability. Typically, code is either tuned in a low-level imperative language using hardware-specific optimizations to achieve maximum performance or is written in a high-level, possibly functional, language to achieve portability at the expense of performance. We propose a novel approach aiming to combine high-level programming, code portability, and high-performance. Starting from a high-level functional expression we apply a simple set of rewrite rules to transform it into a low-level functional representation, close to the OpenCL programming model, from which OpenCL code is generated. Our rewrite rules define a space of possible implementations which we automatically explore to generate hardware-specific OpenCL implementations. We formalize our system with a core dependently-typed lambda-calculus along with a denotational semantics which we use to prove the correctness of the rewrite rules. We test our design in practice by implementing a compiler which generates high performance imperative OpenCL code. Our experiments show that we can automatically derive hardware-specific implementations from simple functional high-level algorithmic expressions offering performance on a par with highly tuned code for multicore CPUs and GPUs written by experts.", "paper_title": "Generating Performance Portable Code using Rewrite Rules From High-Level Functional Expressions to High-Performance OpenCL Code", "paper_id": "WOS:000367255800019"}