{"auto_keywords": [{"score": 0.02520637481347554, "phrase": "serrge"}, {"score": 0.015547084727554774, "phrase": "sparse_intracluster_routing_crossbars"}, {"score": 0.00481495049065317, "phrase": "field_programmable_gate_arrays"}, {"score": 0.00470862827326028, "phrase": "field_programmable_gate_array"}, {"score": 0.004354572391793908, "phrase": "typical_computer-aided_design_flow"}, {"score": 0.004141093507753515, "phrase": "np-complete_problem"}, {"score": 0.00400459716272594, "phrase": "disjoint_paths"}, {"score": 0.0038725824361608243, "phrase": "routing_resource_graph"}, {"score": 0.003724034990158436, "phrase": "fpga_routing_network"}, {"score": 0.003501991125315889, "phrase": "modern_fpgas"}, {"score": 0.0032383707002544755, "phrase": "memory_footprint"}, {"score": 0.003202361402737197, "phrase": "fpga_routing"}, {"score": 0.0029612292670237505, "phrase": "application-specific_memory_manager"}, {"score": 0.0028957238173610697, "phrase": "rrg"}, {"score": 0.002847540262784593, "phrase": "compressed_form"}, {"score": 0.002722930209707764, "phrase": "router_proceeds"}, {"score": 0.0025461386232786356, "phrase": "logic_cluster"}, {"score": 0.002475898613632249, "phrase": "global_routing_stage"}, {"score": 0.0023941594714694003, "phrase": "ppr"}, {"score": 0.0023021895404322767, "phrase": "traditional_router"}, {"score": 0.002263861731320045, "phrase": "fully_expanded_rrg._ppr"}, {"score": 0.0021049977753042253, "phrase": "highest_clock_frequencies"}], "paper_keywords": ["Field programmable gate array (FPGA)", " routing", " routing resource graph (RRG)"], "paper_abstract": "Field programmable gate array (FPGA) routing is one of the most time consuming steps in a typical computer-aided design flow. The problem itself is similar to the NP-complete problem of computing a set of disjoint paths in a graph. The routing resource graph (RRG) that represents an FPGA routing network is necessarily large, and becomes even larger when modeling modern FPGAs that integrate sparse intracluster routing crossbars. This paper introduces two scalable heuristics that reduce the runtime and memory footprint of FPGA routing: 1) selective RRG expansion (SERRGE), which employs an application-specific memory manager that stores the RRG in a compressed form, and dynamically decompresses it as the router proceeds and 2) partial prerouting (PPR) locally routes all nets within each logic cluster, followed by a global routing stage to complete the routes. PPR and SERRGE converge faster than a traditional router using a fully expanded RRG. PPR runs faster and uses less memory than SERRGE, while SERRGE yields the highest clock frequencies among the three.", "paper_title": "Fast and Memory-Efficient Routing Algorithms for Field Programmable Gate Arrays With Sparse Intracluster Routing Crossbars", "paper_id": "WOS:000365222400004"}