{"auto_keywords": [{"score": 0.015719716506582538, "phrase": "configuration_constraints"}, {"score": 0.004396790930873782, "phrase": "specific_needs"}, {"score": 0.004358903464536199, "phrase": "valid_combinations"}, {"score": 0.0043213410601860985, "phrase": "configuration_options"}, {"score": 0.004228839109569368, "phrase": "intricate_constraints"}, {"score": 0.004084920064588169, "phrase": "variability_model"}, {"score": 0.003997458586709491, "phrase": "supported_configurations"}, {"score": 0.0036500346000495317, "phrase": "static_analysis_approach"}, {"score": 0.0029012378668247397, "phrase": "existing_constraints"}, {"score": 0.0028145455182562807, "phrase": "qualitative_study"}, {"score": 0.0027781870000242004, "phrase": "constraint_sources"}, {"score": 0.0026951616152303373, "phrase": "manual_inspections"}, {"score": 0.0025474814283429213, "phrase": "low-level_implementation_dependencies"}, {"score": 0.0024928553725344933, "phrase": "correct_runtime_behavior"}, {"score": 0.0024606422183102382, "phrase": "users'_configuration_experience"}, {"score": 0.0024183363693242943, "phrase": "corner_cases"}, {"score": 0.0022464835515931592, "phrase": "complete_model"}, {"score": 0.0021049977753042253, "phrase": "variability_model_engineering"}], "paper_keywords": ["Variability models", " reverse-engineering", " qualitative studies", " static analyses", " configuration constraints"], "paper_abstract": "Highly configurable systems allow users to tailor software to specific needs. Valid combinations of configuration options are often restricted by intricate constraints. Describing options and constraints in a variability model allows reasoning about the supported configurations. To automate creating and verifying such models, we need to identify the origin of such constraints. We propose a static analysis approach, based on two rules, to extract configuration constraints from code. We apply it on four highly configurable systems to evaluate the accuracy of our approach and to determine which constraints are recoverable from the code. We find that our approach is highly accurate (93% and 77% respectively) and that we can recover 28% of existing constraints. We complement our approach with a qualitative study to identify constraint sources, triangulating results from our automatic extraction, manual inspections, and interviews with 27 developers. We find that, apart from low-level implementation dependencies, configuration constraints enforce correct runtime behavior, improve users' configuration experience, and prevent corner cases. While the majority of constraints is extractable from code, our results indicate that creating a complete model requires further substantial domain knowledge and testing. Our results aim at supporting researchers and practitioners working on variability model engineering, evolution, and verification techniques.", "paper_title": "Where Do Configuration Constraints Stem From? An Extraction Approach and an Empirical Study", "paper_id": "WOS:000359563800006"}