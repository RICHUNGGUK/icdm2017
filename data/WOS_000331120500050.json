{"auto_keywords": [{"score": 0.03352763753987084, "phrase": "symba"}, {"score": 0.008713766275018558, "phrase": "smt_solvers"}, {"score": 0.005558252328673365, "phrase": "objective_functions"}, {"score": 0.004701247803858319, "phrase": "satisfiability_modulo_theories"}, {"score": 0.004590217765551337, "phrase": "numerous_uses"}, {"score": 0.004527947981009528, "phrase": "software_verification"}, {"score": 0.004497129150551236, "phrase": "program_synthesis"}, {"score": 0.004466519142879166, "phrase": "functional_programming"}, {"score": 0.004436116555817464, "phrase": "refinement_types"}, {"score": 0.004214569581360156, "phrase": "satisfying_assignments"}, {"score": 0.003949693102823493, "phrase": "subtyping_relation"}, {"score": 0.0035648266669315943, "phrase": "program_executions"}, {"score": 0.003528458369404996, "phrase": "energy_usage"}, {"score": 0.0034332736827447654, "phrase": "short_programs"}, {"score": 0.003375087185182269, "phrase": "expensive_api_calls"}, {"score": 0.0032952735750239924, "phrase": "available_smt"}, {"score": 0.003014948673771347, "phrase": "linear_real_arithmetic"}, {"score": 0.0028349323966217386, "phrase": "satisfying_assignment"}, {"score": 0.0027584046728703297, "phrase": "t._symba"}, {"score": 0.0027395968397212053, "phrase": "efficient_smt_solvers"}, {"score": 0.002720916895509682, "phrase": "black_boxes"}, {"score": 0.0025759787655463212, "phrase": "future_advances"}, {"score": 0.002293051006249274, "phrase": "large_number"}, {"score": 0.0022774088820755366, "phrase": "optimization_benchmarks"}, {"score": 0.002254145085288829, "phrase": "program_analysis_tasks"}, {"score": 0.0021560445153869985, "phrase": "competing_approaches"}], "paper_keywords": ["optimization", " satisfiability modulo theories", " invariant generation", " symbolic abstraction", " program analysis"], "paper_abstract": "The rise in efficiency of Satisfiability Modulo Theories (SMT) solvers has created numerous uses for them in software verification, program synthesis, functional programming, refinement types, etc. In all of these applications, SMT solvers are used for generating satisfying assignments (e.g., a witness for a bug) or proving unsatisfiability/ validity (e.g., proving that a subtyping relation holds). We are often interested in finding not just an arbitrary satisfying assignment, but one that optimizes (minimizes/maximizes) certain criteria. For example, we might be interested in detecting program executions that maximize energy usage (performance bugs), or synthesizing short programs that do not make expensive API calls. Unfortunately, none of the available SMT solvers offer such optimization capabilities. In this paper, we present SYMBA, an efficient SMT-based optimization algorithm for objective functions in the theory of linear real arithmetic (LRA). Given a formula phi and an objective function t, SYMBA finds a satisfying assignment of phi that maximizes the value of t. SYMBA utilizes efficient SMT solvers as black boxes. As a result, it is easy to implement and it directly benefits from future advances in SMT solvers. Moreover, SYMBA can optimize a set of objective functions, reusing information between them to speed up the analysis. We have implemented SYMBA and evaluated it on a large number of optimization benchmarks drawn from program analysis tasks. Our results indicate the power and efficiency of SYMBA in comparison with competing approaches, and highlight the importance of its multi-objective-function feature.", "paper_title": "Symbolic Optimization with SMT Solvers", "paper_id": "WOS:000331120500050"}