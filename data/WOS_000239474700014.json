{"auto_keywords": [{"score": 0.04731911255680173, "phrase": "u_pages"}, {"score": 0.00481495049065317, "phrase": "request_sets"}, {"score": 0.004758188582347737, "phrase": "generalized_paging_problem"}, {"score": 0.004143196873246147, "phrase": "page_fault"}, {"score": 0.00344007531836105, "phrase": "single_utility"}, {"score": 0.0030791137853734152, "phrase": "next_request"}, {"score": 0.0028786467218197245, "phrase": "classical_paging_problem"}, {"score": 0.002669959049383929, "phrase": "offline_problem"}, {"score": 0.002556109032208553, "phrase": "cache_size"}, {"score": 0.002447101794397243, "phrase": "polynomial_time"}, {"score": 0.0024277864377046016, "phrase": "constant_values"}, {"score": 0.0023801608396295396, "phrase": "mainly_online_algorithms"}, {"score": 0.0023427323356117365, "phrase": "competitive_algorithms"}, {"score": 0.002324238863944163, "phrase": "arbitrary_values"}, {"score": 0.0021049977753042253, "phrase": "resource_augmentation"}], "paper_keywords": [""], "paper_abstract": "A generalized paging problem is considered. Each request is expressed as a set of u pages. In order to satisfy the request, at least one of these pages must be in the cache. Therefore, on a page fault, the algorithm must load into the cache at least one page out of the u pages given in the request. The problem arises in systems in which requests can be serviced by various utilities (e.g., a request for a data that lies in various web-pages) and a single utility can service many requests (e.g., a web-page containing various data). The server has the freedom to select the utility that will service the next request and hopefully additional requests in the future. The case u = 1 is simply the classical paging problem, which is known to be polynomially solvable. We show that for any u > 1 the offline problem is NP-hard and hard to approximate if the cache size k is part of the input, but solvable in polynomial time for constant values of k. We consider mainly online algorithms, and design competitive algorithms for arbitrary values of k, u. We study in more detail the cases where u and k are small. We also give an algorithm which uses resource augmentation and which is asymptotically optimal for u = 2.", "paper_title": "Paging with request sets", "paper_id": "WOS:000239474700014"}