{"auto_keywords": [{"score": 0.033865838751225646, "phrase": "falling_staircase_anti-monge_weight-arrays"}, {"score": 0.00481495049065317, "phrase": "hamiltonian_path"}, {"score": 0.0047707093928203, "phrase": "minimum_euclidean_length"}, {"score": 0.0047051051659828275, "phrase": "simple_polygon"}, {"score": 0.004619027561771169, "phrase": "n-vertex_convex_polygon"}, {"score": 0.004492841495994535, "phrase": "shortest_hamiltonian_path"}, {"score": 0.0036328561748082138, "phrase": "n-vertex_simple_polygon"}, {"score": 0.0035828427627676075, "phrase": "previous_best_algorithms"}, {"score": 0.0032364494905485677, "phrase": "dynamic_programming_scheme"}, {"score": 0.002225196379204285, "phrase": "constant_time"}], "paper_keywords": ["Monge array", " Hamiltonian path", " Simple polygon", " Dynamic programming", " Computational complexity", " Computational geometry"], "paper_abstract": "Given an n-vertex convex polygon, we show that a shortest Hamiltonian path visiting all vertices without imposing any restriction on the starting and ending vertices of the path can be found in O(nlogn) time and I similar to(n) space. The time complexity increases to O(nlog(2) n) for computing this path inside an n-vertex simple polygon. The previous best algorithms for these problems are quadratic in time and space. For our purposes, we reformulate the above shortest-path problems in terms of a dynamic programming scheme involving falling staircase anti-Monge weight-arrays, and, in addition, we provide an O(nlogn) time and Theta(n) space algorithm to solve the following one-dimensional dynamic programming recurrence E[i] = min(1 <= j <= k) min(k <= i){V[k - 1] + b(i, j) + c(j, k)}, i = 1, ... , n, where V[0] is known, V[k], for k = 1, ... , n, can be computed from E[k] in constant time, and B = {b(i, j)} and C = {c(j, k)} are known falling staircase anti-Monge weight-arrays of size n x n.", "paper_title": "Computing a Hamiltonian Path of Minimum Euclidean Length Inside a Simple Polygon", "paper_id": "WOS:000314359200001"}