{"auto_keywords": [{"score": 0.04941061878695795, "phrase": "live_vm_migration"}, {"score": 0.012147651767310535, "phrase": "xen"}, {"score": 0.010380833566340186, "phrase": "operating_system"}, {"score": 0.009747554340523934, "phrase": "address_space"}, {"score": 0.009511957485991937, "phrase": "linux"}, {"score": 0.00481495049065317, "phrase": "live_migration"}, {"score": 0.004781215097314411, "phrase": "virtual_machines"}, {"score": 0.004664983066310498, "phrase": "major_primitive_operations"}, {"score": 0.004616034337089482, "phrase": "virtualized_cloud_platforms"}, {"score": 0.004425299304063172, "phrase": "running_services"}, {"score": 0.004183137595671171, "phrase": "increasing_amount"}, {"score": 0.0040958040072620475, "phrase": "vm"}, {"score": 0.0038579703525471985, "phrase": "comprehensive_analysis"}, {"score": 0.003817456968395921, "phrase": "parallelization_opportunities"}, {"score": 0.003621160116056119, "phrase": "abundant_resources"}, {"score": 0.0035957586558176932, "phrase": "cpu_cores"}, {"score": 0.003545487140867762, "phrase": "contemporary_server_platforms"}, {"score": 0.0033988361874354306, "phrase": "data_parallelism"}, {"score": 0.0032697235411641695, "phrase": "parallelization_framework"}, {"score": 0.0032013710938940424, "phrase": "address_space_management_system"}, {"score": 0.0030047427137652218, "phrase": "concurrent_mutation"}, {"score": 0.00284009509859163, "phrase": "per-process_address_space_lock"}, {"score": 0.0027129670661026964, "phrase": "costly_operations"}, {"score": 0.0026844452074327265, "phrase": "requesting_address_range"}, {"score": 0.002646880721119838, "phrase": "per-process_lock"}, {"score": 0.0025733174977357704, "phrase": "kvm"}, {"score": 0.0022507989506447413, "phrase": "vm_migration"}], "paper_keywords": ["Design", " Performance", " Parallelized VM Migration", " Parallelized VM Save/Restore", " Range Lock"], "paper_abstract": "Live VM migration is one of the major primitive operations to manage virtualized cloud platforms. Such operation is usually mission-critical and disruptive to the running services, and thus should be completed as fast as possible. Unfortunately, with the increasing amount of resources configured to a VM, such operations are becoming increasingly time-consuming. In this paper, we make a comprehensive analysis on the parallelization opportunities of live VM migration on two popular open-source VMMs (i.e., Xen and KVM). By leveraging abundant resources like CPU cores and NICs in contemporary server platforms, we design and implement a system called PMigrate that leverages data parallelism and pipeline parallelism to parallelize the operation. As the parallelization framework requires intensive mmap/munmap operations that tax the address space management system in an operating system, we further propose an abstraction called range lock, which improves scalability of concurrent mutation to the address space of an operating system (i.e., Linux) by selectively replacing the per-process address space lock inside kernel with dynamic and fine-grained range locks that exclude costly operations on the requesting address range from using the per-process lock. Evaluation with our working prototype on Xen and KVM shows that PMigrate accelerates the live VM migration ranging from 2.49X to 9.88X, and decreases the downtime ranging from 1.9X to 279.89X. Performance analysis shows that our integration of range lock to Linux significantly improves parallelism in mutating the address space in VM migration and thus boosts the performance ranging from 2.06X to 3.05X. We also show that PMigrate makes only small disruption to other co-hosted production VMs.", "paper_title": "Parallelizing Live Migration of Virtual Machines", "paper_id": "WOS:000324470900009"}