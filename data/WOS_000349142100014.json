{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "cache_locality"}, {"score": 0.015566326322503593, "phrase": "fork-join_parallelism"}, {"score": 0.004720419202969916, "phrase": "sequential_program"}, {"score": 0.004643055780443262, "phrase": "directed_acyclic_graph"}, {"score": 0.004566954456805558, "phrase": "directed_dependency_edges"}, {"score": 0.004274766964161756, "phrase": "popular_and_effective_way"}, {"score": 0.0035637545647574853, "phrase": "recent_research"}, {"score": 0.0033911868693238894, "phrase": "structured_way"}, {"score": 0.0033245147666408157, "phrase": "deleterious_effect"}, {"score": 0.0032591491777773035, "phrase": "worst_case"}, {"score": 0.003050376875258722, "phrase": "additional_cache"}, {"score": 0.0029608318458226755, "phrase": "cache_lines"}, {"score": 0.002771115819151223, "phrase": "computation_span"}, {"score": 0.0027166013332405453, "phrase": "large_impact"}, {"score": 0.0026986685585382347, "phrase": "software_performance"}, {"score": 0.002680853843094522, "phrase": "modern_multicores"}, {"score": 0.0021049977753042253, "phrase": "parallel_applications"}], "paper_keywords": ["scheduling", " work stealing", " futures", " parallel programming", " cache locality", " performance bounds"], "paper_abstract": "In fork-join parallelism, a sequential program is split into a directed acyclic graph of tasks linked by directed dependency edges, and the tasks are executed, possibly in parallel, in an order consistent with their dependencies. A popular and effective way to extend fork-join parallelism is to allow threads to create futures. A thread creates a future to hold the results of a computation, which may or may not be executed in parallel. That result is returned when some thread touches that future, blocking if necessary until the result is ready. Recent research has shown that while futures can, of course, enhance parallelism in a structured way, they can have a deleterious effect on cache locality. In the worst case, futures can incur Omega(PT infinity + tT(infinity)) deviations, which implies Omega(CPT infinity + CtT(infinity)) additional cache misses, where C is the number of cache lines, P is the number of processors, t is the number of touches, and T-infinity is the computation span. Since cache locality has a large impact on software performance on modern multicores, this result is troubling. In this paper, however, we show that if futures are used in a simple, disciplined way, then the situation is much better: if each future is touched only once, either by the thread that created it, or by a later descendant of the thread that created it, then parallel executions with work stealing can incur at most O(CPT infinity 2) additional cache misses, a substantial improvement. This structured use of futures is characteristic of many (but not all) parallel applications.", "paper_title": "Well-Structured Futures and Cache Locality", "paper_id": "WOS:000349142100014"}