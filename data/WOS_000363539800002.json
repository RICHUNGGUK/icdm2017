{"auto_keywords": [{"score": 0.03455018268948868, "phrase": "bt"}, {"score": 0.00481495049065317, "phrase": "newly_added_hardware_feature"}, {"score": 0.0047273577269638725, "phrase": "underlying_instruction"}, {"score": 0.004473982381245469, "phrase": "existing_code"}, {"score": 0.004312622975366676, "phrase": "great_number"}, {"score": 0.004096409451697279, "phrase": "specific_isa"}, {"score": 0.0036822794196763506, "phrase": "general_purpose_field"}, {"score": 0.003601951458683923, "phrase": "embedded_systems"}, {"score": 0.003510439768484619, "phrase": "wide_gamut"}, {"score": 0.0033837256154018204, "phrase": "isa"}, {"score": 0.003297728079517964, "phrase": "binary_translation"}, {"score": 0.003097865379563127, "phrase": "binary_code"}, {"score": 0.00300803677566719, "phrase": "target_architecture"}, {"score": 0.002888747754856871, "phrase": "actual_execution"}, {"score": 0.002846549461929597, "phrase": "huge_performance_penalties"}, {"score": 0.0027437235598539904, "phrase": "new_mechanism"}, {"score": 0.0027036380093304747, "phrase": "dynamic_two-level_binary_translation_system"}, {"score": 0.0026252106881752067, "phrase": "multiple_architectures"}, {"score": 0.0025963890234079333, "phrase": "intermediate-level_code"}, {"score": 0.002521064923851732, "phrase": "second_level"}, {"score": 0.00247509835229599, "phrase": "dynamic_reconfigurable_array"}, {"score": 0.0023594603878391417, "phrase": "bt_system"}, {"score": 0.0023249757987087055, "phrase": "multiple_fields"}, {"score": 0.0022575078732617678, "phrase": "underlying_architecture"}, {"score": 0.0021441057555396013, "phrase": "first_bt_level"}], "paper_keywords": ["Binary translation", " Reconfigurable architecture", " Code optimization", " Transparent execution"], "paper_abstract": "In these days, every newly added hardware feature must not change the underlying instruction set architecture (ISA), in order to avoid adaptation or recompilation of existing code. Nevertheless, this need for compatibility imposes a great number of restrictions to the designers, because it keeps them tied to a specific ISA and all its legacy hardware issues. Considering that the market is mainly dominated by three different ISAs (and, very likely, more to come): 86, used in the general purpose field; ARM, used in embedded systems, and PowerPC which covers a wide gamut of solutions, the need for another level (at the ISA) of adaptability is evident. Binary translation (BT) appears as a solution for that, since it is capable of transforming binary code so it can be executed on another target architecture. However, BT adds another layer between code and actual execution, therefore bringing huge performance penalties. To overcome this drawback, we propose a new mechanism based on a dynamic two-level binary translation system. The first level can translate from multiple architectures into an intermediate-level code, which will be optimized by the second level for execution on a dynamic reconfigurable array. In this way, the designer can take advantage of a BT system and program for multiple fields of application, without worrying about the underlying architecture. We present three case studies, along with a discussion as to how the first BT level is easily expandable to other ISAs.", "paper_title": "A multiple-ISA reconfigurable architecture", "paper_id": "WOS:000363539800002"}