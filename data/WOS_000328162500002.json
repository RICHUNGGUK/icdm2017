{"auto_keywords": [{"score": 0.04350337824761057, "phrase": "message-passing_programs"}, {"score": 0.010657962654973293, "phrase": "test_model"}, {"score": 0.00481495049065317, "phrase": "message-passing_concurrent_programs"}, {"score": 0.0046602528492463045, "phrase": "error-free_message-passing_concurrent_programs"}, {"score": 0.004525259757290933, "phrase": "different_primitives"}, {"score": 0.0044957939485759995, "phrase": "associated_semantics"}, {"score": 0.004294813202198633, "phrase": "testing_process"}, {"score": 0.00411620854480626, "phrase": "new_structural_testing_criteria"}, {"score": 0.004049501224016734, "phrase": "additional_features"}, {"score": 0.003945001936004421, "phrase": "collective_communication"}, {"score": 0.0038181472934630347, "phrase": "non-blocking_receives"}, {"score": 0.003695356628334569, "phrase": "sender_primitives"}, {"score": 0.0034727910226495197, "phrase": "significant_number"}, {"score": 0.003450154514800989, "phrase": "infeasible_synchronization_edges"}, {"score": 0.00320016832003312, "phrase": "message-passing_interface_standard"}, {"score": 0.0029779674919563734, "phrase": "different_message-passing_environments"}, {"score": 0.002901039092967117, "phrase": "case_studies"}, {"score": 0.002844646030750337, "phrase": "new_test_model"}, {"score": 0.002708399936381754, "phrase": "inter-process_communication"}, {"score": 0.0025368092524479637, "phrase": "overall_cost"}, {"score": 0.0024391051991149663, "phrase": "synchronization_edges"}, {"score": 0.002360559092734843, "phrase": "infeasible_edges"}, {"score": 0.0023451553255837317, "phrase": "unmatchable_communication_primitives"}, {"score": 0.0023222375006409675, "phrase": "main_contribution"}, {"score": 0.0022401007567642347, "phrase": "improved_coverage"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["concurrent software testing", " message-passing programs", " structural testing criteria"], "paper_abstract": "Developing high-quality, error-free message-passing concurrent programs is not trivial. Although a number of different primitives with associated semantics are available to assist such development, they often increase the complexity of the testing process. In this paper, we extend our previous test model for message-passing programs and present new structural testing criteria, taking into account additional features used in this paradigm, such as collective communication, non-blocking sends, distinct semantics for non-blocking receives, and persistent operations. Our new model also recognizes that sender primitives cannot always be matched with every receive primitive. This improvement allows us to remove statically a significant number of infeasible synchronization edges that would otherwise have to be analyzed later by the tester. In this paper, the test model is presented using the Message-Passing Interface standard; however, our new model has been designed to be flexible, and it can be configured to support a range of different message-passing environments or languages. We have carried out case studies showing the applicability of the new test model to represent message-passing programs and also to reveal errors, mainly those errors related to inter-process communication. In addition to increasing the number of features supported by the test model, we have also reduced the overall cost of testing significantly. Our case studies suggest that the number of synchronization edges can be reduced by up to 93%, mainly by eliminating infeasible edges between unmatchable communication primitives. The main contribution of the paper is to present a more flexible test model that provides improved coverage for message-passing programs and at the same time reduces the cost of testing significantly. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "Structural testing for message-passing concurrent programs: an extended test model", "paper_id": "WOS:000328162500002"}