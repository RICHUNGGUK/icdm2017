{"auto_keywords": [{"score": 0.03918347337434733, "phrase": "partial_bypassing"}, {"score": 0.013852152234914355, "phrase": "power_consumption"}, {"score": 0.00481495049065317, "phrase": "partially_bypassed_processors"}, {"score": 0.004693476992528682, "phrase": "widely_used_feature"}, {"score": 0.004653667500876187, "phrase": "modern_processors"}, {"score": 0.004536244367689415, "phrase": "complete_bypassing"}, {"score": 0.0043842558719324526, "phrase": "significant_impact"}, {"score": 0.004328576620172571, "phrase": "cycle_time"}, {"score": 0.004095323392273661, "phrase": "strict_design_constraints"}, {"score": 0.0039077616208517026, "phrase": "embedded_processor_systems"}, {"score": 0.003776750773624222, "phrase": "design_parameters"}, {"score": 0.003512702405367876, "phrase": "traditional_data_hazard_detection"}, {"score": 0.003423969509052361, "phrase": "retargetable_compilers"}, {"score": 0.0033660587983313536, "phrase": "constant_value"}, {"score": 0.0033374705499418377, "phrase": "operation_latency"}, {"score": 0.0030776686414001964, "phrase": "operation_tables"}, {"score": 0.002936577024096783, "phrase": "data_hazards"}, {"score": 0.002850168497994985, "phrase": "incomplete_bypassing"}, {"score": 0.0027311076665349657, "phrase": "pipeline_hazards"}, {"score": 0.002696366237523415, "phrase": "unified_framework"}, {"score": 0.0025291601927956765, "phrase": "better_schedules"}, {"score": 0.002475755804232436, "phrase": "popular_intel_xscale_embedded_processor"}, {"score": 0.002413153346716919, "phrase": "mibench_suite"}, {"score": 0.002372298201966367, "phrase": "accurate_pipeline_hazard_detection"}, {"score": 0.0022538323352598896, "phrase": "gcc"}, {"score": 0.0021049977753042253, "phrase": "intel_xscale"}], "paper_keywords": ["bypasses", " forwarding path", " operation table", " partial bypassing", " partially bypassed processor", " pipeline hazard detection", " processor pipeline"], "paper_abstract": "Register bypassing is a widely used feature in modern processors to eliminate certain data hazards. Although complete bypassing is ideal for performance, it has significant impact on the cycle time, area, and power consumption of the processor. Owing to the strict design constraints on the performance, cost, and the power consumption of embedded processor systems, architects seek a compromise between the design parameters by implementing partial bypassing in processors. However, partial bypassing in processors presents challenges for compilation. Traditional data hazard detection and/or avoidance techniques used in retargetable compilers that assume a constant value of operation latency, break down in the presence of partial bypassing. In this article, we present the concept of operation tables (OTs) that can be used to accurately detect data hazards, even in the presence of incomplete bypassing. OTs integrate the detection of all kinds of pipeline hazards in a unified framework, and can, therefore, be easily deployed in a compiler to generate better schedules. Our experimental results on the popular Intel XScale embedded processor running embedded applications from the MiBench suite, demonstrate that accurate pipeline hazard detection by OTs can result in up to 20% performance improvement over the best performing, GCC generated code. Finally, we demonstrate the usefulness A OTs over various bypass configurations of the Intel XScale.", "paper_title": "Retargetable pipeline hazard detection for partially bypassed processors", "paper_id": "WOS:000239367100002"}