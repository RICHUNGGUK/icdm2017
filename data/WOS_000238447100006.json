{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "arbitrary_aggregation_functions"}, {"score": 0.04737883303680886, "phrase": "aggregate_queries"}, {"score": 0.004350308086118336, "phrase": "conjunctive_queries"}, {"score": 0.004225950334493496, "phrase": "built-in_predicates"}, {"score": 0.0036553070575015344, "phrase": "pure_candidates"}, {"score": 0.0034995881411519925, "phrase": "arbitrary_aggregate_queries"}, {"score": 0.0034491650585057754, "phrase": "aggregate_candidates"}, {"score": 0.0032546105164772995, "phrase": "aggregate_functions"}, {"score": 0.003115908199991072, "phrase": "commutative-semigroup_operation"}, {"score": 0.0025611773887867255, "phrase": "query_equivalence"}, {"score": 0.0022148335975074904, "phrase": "rewriting-existence_problem"}, {"score": 0.0021049977753042253, "phrase": "lower_complexity_bounds"}], "paper_keywords": ["algorithms", " languages", " theory", " view usability", " query rewriting", " query equivalence"], "paper_abstract": "The problem of rewriting aggregate queries using views is studied for conjunctive queries with arbitrary aggregation functions and built-in predicates. Two types of queries over views are introduced for rewriting aggregate queries: pure candidates and aggregate candidates. Pure candidates can be used to rewrite arbitrary aggregate queries. Aggregate candidates can be used to rewrite queries containing aggregate functions definable in terms of a commutative-semigroup operation. For both types of candidates (as well as for several relaxations of these candidates), the unfolding property holds. This allows characterizations for query equivalence to be used to determine whether a candidate is a rewriting of a query. The complexity of the rewriting-existence problem is also studied and upper and lower complexity bounds are given.", "paper_title": "Rewriting queries with arbitrary aggregation functions using views", "paper_id": "WOS:000238447100006"}