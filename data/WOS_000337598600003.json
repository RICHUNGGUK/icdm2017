{"auto_keywords": [{"score": 0.028048543728099447, "phrase": "pareto"}, {"score": 0.00481495049065317, "phrase": "lookup_table_program_transformations"}, {"score": 0.004636594774238505, "phrase": "function_evaluation"}, {"score": 0.004483585361583022, "phrase": "lookup_table"}, {"score": 0.004353831792593701, "phrase": "costly_evaluation_code"}, {"score": 0.004299374036140852, "phrase": "inexpensive_memory_access"}, {"score": 0.0042455945330942746, "phrase": "code_transformation"}, {"score": 0.004157446556371582, "phrase": "lut_code"}, {"score": 0.0038549394272661356, "phrase": "lut_data"}, {"score": 0.003727628340195049, "phrase": "expensive_elementary_functions"}, {"score": 0.0036809741830924796, "phrase": "current_practice"}, {"score": 0.003634901808509402, "phrase": "software_developers"}, {"score": 0.003245270848972794, "phrase": "lut_transformation"}, {"score": 0.0030857431184193765, "phrase": "resulting_error"}, {"score": 0.0030470980812086247, "phrase": "application_requirements"}, {"score": 0.0029275807586903306, "phrase": "lut"}, {"score": 0.002897283610433351, "phrase": "programmer_control"}, {"score": 0.0028015105858516702, "phrase": "source_code_analysis"}, {"score": 0.002778064757980489, "phrase": "program_transformation"}, {"score": 0.0027317585060414253, "phrase": "lut_transformations"}, {"score": 0.00267495669519805, "phrase": "novel_optimization_algorithm"}, {"score": 0.002630364569659529, "phrase": "optimal_sets"}, {"score": 0.00246964807581858, "phrase": "error_and_performance_estimates"}, {"score": 0.0023980368333253147, "phrase": "mesa_tool"}, {"score": 0.002318728604587962, "phrase": "scientific_codes"}, {"score": 0.002289667393538803, "phrase": "acceptable_loss"}, {"score": 0.0021678771715091492, "phrase": "effective_lut_transformations"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["lookup table", " performance optimization", " error analysis", " code generation", " scientific computing", " memoization"], "paper_abstract": "Scientific programmers can improve the performance of function evaluation by precomputing and storing results in a lookup table (LUT), thereby replacing costly evaluation code with an inexpensive memory access. A code transformation that replaces computation with LUT code can improve performance; however, accuracy is reduced because of error inherent in reconstructing values from LUT data. LUTs are commonly used to approximate expensive elementary functions. The current practice is for software developers to: (i) manually identify expressions that can benefit from an LUT; (ii) modify the code by hand to implement the LUT transformation; and (iii) run experiments to determine if the resulting error is within application requirements. This approach reduces productivity, obfuscates code, and limits programmer control over accuracy and performance. We propose source code analysis and program transformation to substantially automate LUT transformations. Our approach uses a novel optimization algorithm that selects Pareto optimal sets of expressions that benefit most from an LUT, on the basis of the error and performance estimates. We demonstrate our methodology with the Mesa tool, which achieves speedups of 1.4-6.8x on scientific codes with an acceptable loss of accuracy. Our tool makes the programmer more productive and facilitates finding effective LUT transformations. Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "An optimization-based approach to lookup table program transformations", "paper_id": "WOS:000337598600003"}