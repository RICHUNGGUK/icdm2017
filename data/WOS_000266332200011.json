{"auto_keywords": [{"score": 0.04305671692018979, "phrase": "memory-space_occupancy"}, {"score": 0.023418806020594006, "phrase": "memory_space"}, {"score": 0.00481495049065317, "phrase": "data_compression"}, {"score": 0.00479361170318707, "phrase": "increasing_memory_system_utilization"}, {"score": 0.004761779859548054, "phrase": "memory_system"}, {"score": 0.004709193603747991, "phrase": "critical_challenges"}, {"score": 0.004688321299229397, "phrase": "embedded_system_design"}, {"score": 0.004585332915477379, "phrase": "ever-increasing_code_complexity"}, {"score": 0.004524624065803229, "phrase": "exponential_increase"}, {"score": 0.004415395176043526, "phrase": "memory_bottleneck"}, {"score": 0.003916098498242888, "phrase": "on-chip_memory_capacity"}, {"score": 0.003796102411433359, "phrase": "embedded_applications"}, {"score": 0.0035988560001022924, "phrase": "compiler-driven_approach"}, {"score": 0.003434662174045939, "phrase": "data_elements"}, {"score": 0.0032489004068215407, "phrase": "single-core_systems"}, {"score": 0.0031006232333900055, "phrase": "application_execution"}, {"score": 0.0030391630652687658, "phrase": "mpsocs"}, {"score": 0.002965684305115369, "phrase": "compression_and_decompression_activities"}, {"score": 0.002842920225545139, "phrase": "static_scheme"}, {"score": 0.00264750749413377, "phrase": "dynamic_scheme"}, {"score": 0.0024986435094583263, "phrase": "dynamic_variations"}, {"score": 0.002482013330276732, "phrase": "data_access_pattern"}, {"score": 0.002438203996977464, "phrase": "single-core_system"}, {"score": 0.002421975107313603, "phrase": "proposed_approach"}, {"score": 0.002411215758438532, "phrase": "maximum_memory_occupancy"}, {"score": 0.0022857632887682655, "phrase": "average_energy_saving"}, {"score": 0.0022604585778195152, "phrase": "eight_benchmarks"}, {"score": 0.002215612396745814, "phrase": "related_bookkeeping_activities"}, {"score": 0.0022057677637040396, "phrase": "extra_cycles"}, {"score": 0.0021813467128927347, "phrase": "additional_energy"}, {"score": 0.0021191072118924045, "phrase": "execution_cycles"}, {"score": 0.0021049977753042253, "phrase": "energy_perspectives"}], "paper_keywords": ["Compilers", " data compression", " embedded systems", " memory optimization", " multiprocessor-system-on-a-chip (MPSoC)"], "paper_abstract": "The memory system presents one of the critical challenges in embedded system design and optimization. This is mainly due to the ever-increasing code complexity of embedded applications and the exponential increase seen in the amount of data they manipulate. The memory bottleneck is even more important for multiprocessor-system-on-a-chip (MPSoC) architectures due to the high cost of off-chip memory accesses in terms of both energy and performance. As a result, reducing the memory-space occupancy of embedded applications is very important and will be even more important in the next decade. While it is true that the on-chip memory capacity of embedded systems is continuously increasing, the increases in the complexity of embedded applications and the sizes of the data sets they process are far greater. Motivated by this observation, this paper presents and evaluates a compiler-driven approach to data compression for reducing memory-space occupancy. Our goal is to study how automated compiler support can help in deciding the set of data elements to compress/decompress and the points during execution at which these compressions/decompressions should be performed. We first study this problem in the context of single-core systems and then extend it to MPSoCs where we schedule compressions and decompressions intelligently such that they do not conflict with application execution as much as possible. Particularly, in MPSoCs, one needs to decide which processors should participate in the compression and decompression activities at any given point during the course of execution. We propose both static and dynamic algorithms for this purpose. In the static scheme, the processors are divided into two groups: those performing compression/decompression and those executing the application, and this grouping is maintained throughout the execution of the application. In the dynamic scheme, on the other hand, the execution starts with some grouping but this grouping can change during the course of execution, depending on the dynamic variations in the data access pattern. Our experimental results show that, in a single-core system, the proposed approach reduces maximum memory occupancy by 47.9% and average memory occupancy by 48.3% when averaged over all the benchmarks. Our results also indicate that, in an MPSoC, the average energy saving is 12.7% when all eight benchmarks are considered. While compressions and decompressions and related bookkeeping activities take extra cycles and memory space and consume additional energy, we found that the improvements they bring from the memory space, execution cycles, and energy perspectives are much higher than these overheads.", "paper_title": "Using Data Compression for Increasing Memory System Utilization", "paper_id": "WOS:000266332200011"}