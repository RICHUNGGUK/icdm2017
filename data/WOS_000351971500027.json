{"auto_keywords": [{"score": 0.030110191114715582, "phrase": "remaining_defects"}, {"score": 0.009884975605151903, "phrase": "defective_code"}, {"score": 0.00481495049065317, "phrase": "\"defect_co-fix"}, {"score": 0.0047864177420244795, "phrase": "quality_assurance_resource_allocation"}, {"score": 0.0046739596755881185, "phrase": "pre-release_quality_assurance"}, {"score": 0.004600452596028764, "phrase": "source_code_analysis"}, {"score": 0.004582256337863881, "phrase": "peer_review"}, {"score": 0.004465714498712808, "phrase": "software_project_manager"}, {"score": 0.004360758417794798, "phrase": "available_qa_resources"}, {"score": 0.003980687255880279, "phrase": "historical_data"}, {"score": 0.003964932602985595, "phrase": "different_software_metrics"}, {"score": 0.003910278811774747, "phrase": "previous_defects"}, {"score": 0.0038335012244266452, "phrase": "qa_budget"}, {"score": 0.0038107621416891167, "phrase": "allocation_technique"}, {"score": 0.0037359312167652117, "phrase": "qa_team"}, {"score": 0.0036120633512220853, "phrase": "qa_resource_allocation_approaches"}, {"score": 0.003527099244225379, "phrase": "selected_artifact"}, {"score": 0.00339662744922317, "phrase": "software_issue"}, {"score": 0.003125034135647482, "phrase": "defective_part"}, {"score": 0.0027962928006287184, "phrase": "qa_resource_allocation_approach"}, {"score": 0.002719644855867468, "phrase": "smallest_number"}, {"score": 0.0026661825674374902, "phrase": "large_releases"}, {"score": 0.0026556165534143915, "phrase": "open_source_systems"}, {"score": 0.002618964082241891, "phrase": "netbeans"}, {"score": 0.0025421108712476367, "phrase": "software_projects"}, {"score": 0.0024479855128495534, "phrase": "new_cost-effectiveness_measure"}, {"score": 0.002433444782735987, "phrase": "qa_resource_allocation"}, {"score": 0.002399850604120431, "phrase": "\"remaining_defects"}, {"score": 0.002357337046408753, "phrase": "co-fix-aware_prioritization"}, {"score": 0.002329412930430366, "phrase": "new_measure"}, {"score": 0.0023063950940761927, "phrase": "historical_defect"}, {"score": 0.002252073915338034, "phrase": "six_releases"}, {"score": 0.00213023743193503, "phrase": "search-based_software_engineering_techniques"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Defect prediction", " Co-fix", " Search-based prioritization"], "paper_abstract": "Allocation of resources to pre-release quality assurance (QA) tasks, such as source code analysis, peer review, and testing, is one of the challenges faced by a software project manager. The goal is to find as many defects as possible with the available QA resources prior to the release. This can be achieved by assigning more resources to the more defect-prone artifacts, e.g., components, classes, and methods. The state-of-the-art QA resource allocation approaches predict the defect-proneness of an artifact using the historical data of different software metrics, e.g., the number of previous defects and the changes in the artifact. Given a QA budget, an allocation technique selects the most defect-prone artifacts, for further investigation by the QA team. While there has been many research efforts on discovering more predictive software metrics and more effective defect prediction algorithms, the cost-effectiveness of the QA resource allocation approaches has always been evaluated by counting the number of defects per selected artifact. The problem with such an evaluation approach is that it ignores the fact that, in practice, fixing a software issue is not bounded to an artifact under investigation. In other words, one may start reviewing a file that is identified as defect-prone and detect a defect, but to fix the defect one may modify not only the defective part of the file under review, but also several other artifacts that are somehow related to the defective code (e.g., a method that calls the defective code). Such co-fixes (fixing several defects together) during analyzing/reviewing/testing of an artifact under investigation will change the number of remaining defects in the other artifacts. Therefore, a QA resource allocation approach is more effective if it prioritizes the artifacts that would lead to the smallest number of remaining defects. Investigating six medium-to-large releases of open source systems (Mylyn, Eclipse, and NetBeans, two releases each), we found that co-fixes happen quite often in software projects (30-42% of the fixes modify more than one artifact). Therefore, in this paper, we first introduce a new cost-effectiveness measure to evaluate QA resource allocation, based on the concept of \"remaining defects\" per file. We then propose several co-fix-aware prioritization approaches to dynamically optimize the new measure, based on the historical defect co-fixes. The evaluation of these approaches on the six releases shows that (a) co-fix-aware QA prioritization approaches improve the traditional defect prediction-based ones, in terms of density of remaining defects per file and (b) co-fix-aware QA prioritization can potentially benefit from search-based software engineering techniques. (C) 2014 Elsevier Inc. All rights reserved,", "paper_title": "Investigating the effect of \"defect co-fix\" on quality assurance resource allocation: A search-based approach", "paper_id": "WOS:000351971500027"}