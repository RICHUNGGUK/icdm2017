{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "sequence_diagrams"}, {"score": 0.004759635663291431, "phrase": "modular_software_design"}, {"score": 0.004544629724830453, "phrase": "discrete_scalable"}, {"score": 0.004492406361795448, "phrase": "reusable_modules"}, {"score": 0.004215677131963292, "phrase": "independent_offerings"}, {"score": 0.003955926499405168, "phrase": "customer_demands"}, {"score": 0.0038431888954930083, "phrase": "software_architectures"}, {"score": 0.003503497128638102, "phrase": "automatic_partitioning"}, {"score": 0.003463196032143783, "phrase": "object-oriented_classes"}, {"score": 0.0031753062090452864, "phrase": "source_code"}, {"score": 0.0030141556259370675, "phrase": "development_process"}, {"score": 0.0029622717081190667, "phrase": "implementation_stage"}, {"score": 0.0027634902834910184, "phrase": "search-based_mechanism"}, {"score": 0.0027159094186967247, "phrase": "automatic_functionality-based_system"}, {"score": 0.00265373679629359, "phrase": "architecture_design_phase"}, {"score": 0.002608040688794517, "phrase": "conceptual_sequence_diagrams"}, {"score": 0.0025044454602720597, "phrase": "applicable_theoretical_properties"}, {"score": 0.002432971714608409, "phrase": "hypothetical_and_real-case_studies"}, {"score": 0.0022434880661725493, "phrase": "partitioning_mechanism"}, {"score": 0.0021049977753042253, "phrase": "conceptual_classes"}], "paper_keywords": ["Search-based software engineering", " Automatic software packaging", " Software modularization", " Software architecture", " Packaging metric", " Package functionality"], "paper_abstract": "Modular software design is characterized by partitioning the system into discrete scalable, reusable modules consisting of isolated, self-contained functional elements. Software architects use modularity to allow independent offerings and reuse. Moreover, modularity allows dealing with changing customer demands, as it offers software architectures that are stable and more adaptive to changes. There have been some attempts at automatic partitioning of object-oriented classes into modules (i.e., packages). However, all these attempts are based on source code, i.e., they occur late in the development process at the implementation stage. In this paper, we present a metric and a search-based mechanism to allow automatic functionality-based system partitioning during the architecture design phase using requirements conceptual sequence diagrams. The metric is validated against applicable theoretical properties and also experimentally against hypothetical and real-case studies using different search techniques. Results suggest that the metric together with the partitioning mechanism is promising and can be used in effectively partitioning system conceptual classes into packages.", "paper_title": "Functionality-based software packaging using sequence diagrams", "paper_id": "WOS:000353572800004"}