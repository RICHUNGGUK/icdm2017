{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "formal_approaches"}, {"score": 0.004492406361795448, "phrase": "concurrent_programs"}, {"score": 0.003978866233891427, "phrase": "useful_properties"}, {"score": 0.003306559295382181, "phrase": "programming_languages"}, {"score": 0.0032496585171039797, "phrase": "tractable_specifications"}, {"score": 0.0030847461428168614, "phrase": "useful_frameworks"}, {"score": 0.002391067964886602, "phrase": "response_thereto"}, {"score": 0.0022960713730673494, "phrase": "fundamental_challenges"}, {"score": 0.0021794454466797382, "phrase": "ubiquitous_tool"}, {"score": 0.0021049977753042253, "phrase": "key_issues"}], "paper_keywords": ["Concurrency", " Rely/guarantee reasoning", " Separation logic"], "paper_abstract": "One might think that specifying and reasoning about concurrent programs would be easier with more expressive languages. This paper questions that view. Clearly too weak a notation can mean that useful properties either cannot be expressed or their expression is unnatural. But choosing too powerful a notation also has its drawbacks since reasoning receives little guidance. For example, few would suggest that programming languages themselves provide tractable specifications. Both rely/guarantee methods and separation logic(s) provide useful frameworks in which it is natural to reason about aspects of concurrency. Rather than pursue an approach of extending the notations of either approach, this paper starts with the issues that appear to be inescapable with concurrency and-only as a response thereto-examines ways in which these fundamental challenges can be met. Abstraction is always a ubiquitous tool and its influence on how the key issues are tackled is examined in each case.", "paper_title": "Balancing expressiveness in formal approaches to concurrency", "paper_id": "WOS:000353826900002"}