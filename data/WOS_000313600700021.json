{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "software_models"}, {"score": 0.031042443925142046, "phrase": "composite_operations"}, {"score": 0.004689321062844586, "phrase": "software_artifact"}, {"score": 0.004477270137801732, "phrase": "continuous_evolution"}, {"score": 0.003820144626025562, "phrase": "atomic_operations"}, {"score": 0.003482160257566501, "phrase": "cluttered_difference_reports"}, {"score": 0.0032591491777773035, "phrase": "orthogonal_extension"}, {"score": 0.0030706395717772436, "phrase": "also_composite_operations"}, {"score": 0.0028360962841331634, "phrase": "detected_atomic_operations"}, {"score": 0.0027803070408286158, "phrase": "post-processing_manner"}, {"score": 0.0023096222276192194, "phrase": "real-world_case_study"}], "paper_keywords": ["Model evolution", " Model refactoring", " Model comparison"], "paper_abstract": "As every software artifact, also software models are subject to continuous evolution. The operations applied between two successive versions of a model are crucial for understanding its evolution. Generic approaches for detecting operations a posteriori identify atomic operations, but neglect composite operations, such as refactorings, which leads to cluttered difference reports. To tackle this limitation, we present an orthogonal extension of existing atomic operation detection approaches for detecting also composite operations. Our approach searches for occurrences of composite operations within a set of detected atomic operations in a post-processing manner. One major benefit is the reuse of specifications available for executing composite operations also for detecting applications of them. We evaluate the accuracy of the approach in a real-world case study and investigate the scalability of our implementation in an experiment. (c) 2012 Elsevier Inc. All rights reserved.", "paper_title": "A posteriori operation detection in evolving software models", "paper_id": "WOS:000313600700021"}