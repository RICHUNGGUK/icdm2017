{"auto_keywords": [{"score": 0.03810463830315169, "phrase": "stata"}, {"score": 0.005672035704171271, "phrase": "jvml"}, {"score": 0.00481495049065317, "phrase": "jvm_lock_primitives"}, {"score": 0.004592016716046632, "phrase": "java_virtual_machine_language"}, {"score": 0.004233492114255375, "phrase": "fatal_error"}, {"score": 0.004092463367307375, "phrase": "present_verifier"}, {"score": 0.003850299959557491, "phrase": "lock_primitives"}, {"score": 0.00357362651129581, "phrase": "abadi's_type_system"}, {"score": 0.0031629800646754505, "phrase": "resulting_type_system"}, {"score": 0.002494361792853833, "phrase": "prototype_java_bytecode_verifier"}, {"score": 0.002427549902743566, "phrase": "type_system"}, {"score": 0.002252880693912436, "phrase": "java_run_time_library"}, {"score": 0.0021049977753042253, "phrase": "correct_answers"}], "paper_keywords": ["type system", " Java bytecode verifier", " lock"], "paper_abstract": "A bytecode verifier for the Java virtual machine language (JVML) statically checks that bytecode does not cause any fatal error. However, the present verifier does not check correctness of the usage of lock primitives. To solve this problem, we extend Stata and Abadi's type system for JVML by augmenting types with information about how each object is locked and unlocked. The resulting type system guarantees that when a thread terminates, it has released all the locks it has acquired and that a thread releases a lock only if it has acquired the lock previously. We have implemented a prototype Java bytecode verifier based on the type system. We have tested the verifier for several classes in the Java run time library and confirmed that the verifier runs efficiently and gives correct answers.", "paper_title": "A new type system for JVM lock primitives", "paper_id": "WOS:000254109300002"}