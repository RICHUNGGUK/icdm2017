{"auto_keywords": [{"score": 0.04903785587923539, "phrase": "auxiliary_functionality"}, {"score": 0.02322730111336099, "phrase": "code_search"}, {"score": 0.014060010128374082, "phrase": "codegenie"}, {"score": 0.006193994314415371, "phrase": "tdcs"}, {"score": 0.004651407155355244, "phrase": "software_developers"}, {"score": 0.004622271625219495, "phrase": "considerable_effort"}, {"score": 0.004535950496583731, "phrase": "main_features"}, {"score": 0.004273047608656344, "phrase": "increasing_amount"}, {"score": 0.004246271940215511, "phrase": "open_source_code"}, {"score": 0.004025320909035849, "phrase": "informal_practices"}, {"score": 0.0038158228131483854, "phrase": "ad_hoc_manner"}, {"score": 0.0036860898876135534, "phrase": "code_results"}, {"score": 0.003418089698750318, "phrase": "test_cases"}, {"score": 0.003100465875551721, "phrase": "desired_functionality"}, {"score": 0.0029855707714361813, "phrase": "matching_results"}, {"score": 0.0029389598856744436, "phrase": "local_context"}, {"score": 0.002777088408582301, "phrase": "code_search_engine"}, {"score": 0.0027596607038845923, "phrase": "sourcerer"}, {"score": 0.0025750071068101356, "phrase": "performance_study"}, {"score": 0.0025428208165514505, "phrase": "google"}, {"score": 0.0024951987856762646, "phrase": "manual_approach"}, {"score": 0.0024026792279374784, "phrase": "good_performance"}, {"score": 0.00227743851871825, "phrase": "source_code_search"}, {"score": 0.0021998931213841567, "phrase": "promising_results"}, {"score": 0.002138410677608455, "phrase": "tdcs."}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Code search", " Test-Driven Development", " Software reuse", " Software development", " Development tools"], "paper_abstract": "Context: Software developers spend considerable effort implementing auxiliary functionality used by the main features of a system (e.g., compressing/decompressing files, encryption/decription of data, scaling/rotating images). With the increasing amount of open source code available on the Internet, time and effort can be saved by reusing these utilities through informal practices of code search and reuse. However, when this type of reuse is performed in an ad hoc manner, it can be tedious and error-prone: code results have to be manually inspected and integrated into the workspace. Objective: In this paper we introduce and evaluate the use of test cases as an interface for automating code search and reuse. We call our approach Test-Driven Code Search (TDCS). Test cases serve two purposes: (1) they define the behavior of the desired functionality to be searched; and (2) they test the matching results for suitability in the local context. We also describe CodeGenie, an Eclipse plugin we have developed that performs TDCS using a code search engine called Sourcerer. Method: Our evaluation consists of two studies: an applicability study with 34 different features that were searched using CodeGenie; and a performance study comparing CodeGenie, Google Code Search, and a manual approach. Results: Both studies present evidence of the applicability and good performance of TDCS in the reuse of auxiliary functionality. Conclusion: This paper presents an approach to source code search and its application to the reuse of auxiliary functionality. Our exploratory evaluation shows promising results, which motivates the use and further investigation of TDCS. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "A test-driven approach to code search and its application to the reuse of auxiliary functionality", "paper_id": "WOS:000288732700002"}