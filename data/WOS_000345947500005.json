{"auto_keywords": [{"score": 0.04928409246925515, "phrase": "unanticipated_exceptions"}, {"score": 0.03531917121851837, "phrase": "test_suite_execution"}, {"score": 0.00481495049065317, "phrase": "fault_injection"}, {"score": 0.0046046429665581555, "phrase": "error_cases"}, {"score": 0.004515532787428149, "phrase": "design_time"}, {"score": 0.004428139418750855, "phrase": "testing_time"}, {"score": 0.004187614134377688, "phrase": "anticipated_errors"}, {"score": 0.0040609174534657995, "phrase": "unanticipated_ones"}, {"score": 0.00381886412166831, "phrase": "first_objective"}, {"score": 0.0037449033166879874, "phrase": "exception_handling"}, {"score": 0.003641713874009232, "phrase": "second_one"}, {"score": 0.0035911864946764614, "phrase": "resilience_capabilities"}, {"score": 0.003531474887552889, "phrase": "source_code"}, {"score": 0.0033023607867257517, "phrase": "unanticipated_errors"}, {"score": 0.0032383707002544755, "phrase": "fault-injection_techniques"}, {"score": 0.0029364923713649026, "phrase": "code_modification_technique"}, {"score": 0.0028555145499043564, "phrase": "error-recovery_code"}, {"score": 0.0028080006828162156, "phrase": "catch_blocks"}, {"score": 0.0025604233506352375, "phrase": "resilience_properties"}, {"score": 0.002341164727388946, "phrase": "software_resilience"}, {"score": 0.0022893422054387235, "phrase": "collected_information"}, {"score": 0.002176887956041267, "phrase": "test_suite"}, {"score": 0.0021586889403581518, "phrase": "exceptional_programming_language"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Dynamic verification", " Contract", " Exception handling", " Fault injection"], "paper_abstract": "Context: In software, there are the error cases that are anticipated at specification and design time, those encountered at development and testing time, and those that were never anticipated before happening in production. Is it possible to learn from the anticipated errors during design to analyze and improve the resilience against the unanticipated ones in production? Objective: In this paper, we aim at analyzing and improving how software handles unanticipated exceptions. The first objective is to set up contracts about exception handling and a way to assess them automatically. The second one is to improve the resilience capabilities of software by transforming the source code. Method: We devise an algorithm, called short-circuit testing, which injects exceptions during test suite execution so as to simulate unanticipated errors. It is a kind of fault-injection techniques dedicated to exception-handling. This algorithm collects data that is used for verifying two formal contracts that capture two resilience properties w.r.t exceptions: the source-independence and pure-resilience contracts. Then we propose a code modification technique, called \"catch-stretching\" which allows error-recovery code (of the form of catch blocks) to be more resilient. Results: Our evaluation is performed on 9 open-source software applications and consists in analyzing 241 catch blocks executed during test suite execution. Our results show that 101/214 of them (47%) expose resilience properties as defined by our exception contracts and that 84/214 of them (39%) can be transformed to be more resilient. Conclusion: Our work shows that it is possible to reason on software resilience by injecting exceptions during test suite execution. The collected information allows us to apply one source code transformation that improves the resilience against unanticipated exceptions. This works best if the test suite exercises the exceptional programming language constructs in many different scenarios. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Exception handling analysis and transformation using fault injection: Study of resilience against unanticipated exceptions", "paper_id": "WOS:000345947500005"}