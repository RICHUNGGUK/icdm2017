{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "nested_trees"}, {"score": 0.004642604455537883, "phrase": "nested_trees-structures"}, {"score": 0.004422325007817267, "phrase": "nested_jump-edges"}, {"score": 0.004161553532799662, "phrase": "pushdown_programs"}, {"score": 0.0037301606780397456, "phrase": "membership_question"}, {"score": 0.003107935254560724, "phrase": "model-checking_problem"}, {"score": 0.0030147970456037274, "phrase": "pushdown_systems"}, {"score": 0.002978338750527512, "phrase": "exptime"}, {"score": 0.0027854565462509095, "phrase": "nt-mu"}, {"score": 0.002511600086227213, "phrase": "\"context-free\"_requirements"}, {"score": 0.002421499421848063, "phrase": "monadic_second_order_logic"}, {"score": 0.002278452259955051, "phrase": "mso"}, {"score": 0.0021049977753042253, "phrase": "undecidable_model_checking_problem"}], "paper_keywords": [""], "paper_abstract": "We study languages of nested trees-structures obtained by augmenting trees with sets of nested jump-edges. These graphs can naturally model branching behaviors of pushdown programs, so that the problem of branching-time software model checking may be phrased as a membership question for such languages. We define finite-state automata accepting such languages-these automata can pass states along jump-edges as well as tree edges. We find that the model-checking problem for these automata on pushdown systems is EXPTIME-complete, and that their alternating versions are expressively equivalent to NT-mu, a recently proposed temporal logic for nested trees that can express a variety of branching-time, \"context-free\" requirements. We also show that monadic second order logic (MSO) cannot exploit the structure: MSO on nested trees is too strong in the sense that it has an undecidable model checking problem, and seems too weak to capture NT-mu.", "paper_title": "Languages of nested trees", "paper_id": "WOS:000240257000029"}