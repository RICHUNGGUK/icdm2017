{"auto_keywords": [{"score": 0.04752996363942487, "phrase": "operating_system"}, {"score": 0.007152368807539886, "phrase": "application_guidance"}, {"score": 0.006111774737434743, "phrase": "application_software"}, {"score": 0.004784093722351956, "phrase": "virtual_memory_systems"}, {"score": 0.004692699265201631, "phrase": "collaborative_approach"}, {"score": 0.00447174501210281, "phrase": "physical_memory"}, {"score": 0.0043302273768286905, "phrase": "physical_page"}, {"score": 0.004233826962599848, "phrase": "particular_virtual_page"}, {"score": 0.004193169496350484, "phrase": "key_intuition"}, {"score": 0.0040343909885467485, "phrase": "memory_accesses"}, {"score": 0.0038941106036522216, "phrase": "relative_access_rates"}, {"score": 0.003869132124880576, "phrase": "overlapping_patterns"}, {"score": 0.0034905093340212045, "phrase": "spillover_effects"}, {"score": 0.0032940025020351082, "phrase": "latter_schedule_memory"}, {"score": 0.003058875648995241, "phrase": "power_efficiency"}, {"score": 0.002777156434571452, "phrase": "application's_memory_usage"}, {"score": 0.0025132071574192672, "phrase": "efficient_way"}, {"score": 0.0024730434312323296, "phrase": "physical_memory_pages"}, {"score": 0.0024571577953004546, "phrase": "intermediate_level_grouping_structures"}, {"score": 0.0023946267004932736, "phrase": "physically_independent_access_channels"}, {"score": 0.002379243574322898, "phrase": "self-refresh_domains"}, {"score": 0.0022742871983734737, "phrase": "lower_level_details"}, {"score": 0.0022451572368358476, "phrase": "bandwidth_management"}, {"score": 0.0021669551936989886, "phrase": "memory_management"}, {"score": 0.00214610313234565, "phrase": "recent_linux_kernel"}], "paper_keywords": ["Design", " Performance", " Memory virtualization", " Memory management", " Resource allocation", " Power", " Performance", " Containerization"], "paper_abstract": "This paper proposes a collaborative approach in which applications can provide guidance to the operating system regarding allocation and recycling of physical memory. The operating system incorporates this guidance to decide which physical page should be used to back a particular virtual page. The key intuition behind this approach is that application software, as a generator of memory accesses, is best equipped to inform the operating system about the relative access rates and overlapping patterns of usage of its own address space. It is also capable of steering its own algorithms in order to keep its dynamic memory footprint under check when there is a need to reduce power or to contain the spillover effects from bursts in demand. Application software, working cooperatively with the operating system, can therefore help the latter schedule memory more effectively and efficiently than when the operating system is forced to act alone without such guidance. It is particularly difficult to achieve power efficiency without application guidance since power expended in memory is a function not merely of the intensity with which memory is accessed in time but also how many physical ranks are affected by an application's memory usage. Our framework introduces an abstraction called \"colors\" for the application to communicate its intent to the operating system. We modify the operating system to receive this communication in an efficient way, and to organize physical memory pages into intermediate level grouping structures called \"trays\" which capture the physically independent access channels and self-refresh domains, so that it can apply this guidance without entangling the application in lower level details of power or bandwidth management. This paper describes how we re-architect the memory management of a recent Linux kernel to realize a three way collaboration between hardware, supervisory software, and application tasks.", "paper_title": "A Framework for Application Guidance in Virtual Memory Systems", "paper_id": "WOS:000324470900015"}