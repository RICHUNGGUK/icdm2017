{"auto_keywords": [{"score": 0.03272315614385495, "phrase": "mock_classes"}, {"score": 0.00481495049065317, "phrase": "generating_test_cases"}, {"score": 0.0046293571653565095, "phrase": "annotations"}, {"score": 0.004588891098290524, "phrase": "automatic_test_case_generation"}, {"score": 0.004373398434399966, "phrase": "key_limitation"}, {"score": 0.00407781620412982, "phrase": "additional_pieces"}, {"score": 0.0037361664435836845, "phrase": "pex_state-of-the-art_test_case_generator"}, {"score": 0.0035918768194006735, "phrase": "current_test_case_generators"}, {"score": 0.003408091901859624, "phrase": "multiple_interfaces"}, {"score": 0.0032336801561165113, "phrase": "object-oriented_setting"}, {"score": 0.0031636612155559267, "phrase": "novel_technique"}, {"score": 0.0031223774204093713, "phrase": "test_cases"}, {"score": 0.0028480459059007468, "phrase": "program_constraints"}, {"score": 0.0028108690791085536, "phrase": "dynamic_symbolic_execution"}, {"score": 0.002737960968372391, "phrase": "constraint_system"}, {"score": 0.00266693888510356, "phrase": "off-the-shelf_constraint_solver"}, {"score": 0.0024325244760735566, "phrase": "open-source_applications"}, {"score": 0.0023079225317714815, "phrase": "competing_approaches"}, {"score": 0.002218668420806254, "phrase": "unintended_side-effects"}, {"score": 0.0021516366862117707, "phrase": "dialog_boxes"}, {"score": 0.0021049977753042253, "phrase": "file_system"}], "paper_keywords": ["Algorithms", " Reliability", " Verification", " Dynamic symbolic execution", " mock classes", " stubs", " test case generation"], "paper_abstract": "Automatic test case generation for software programs is very powerful but suffers from a key limitation. That is, most current test case generation techniques fail to cover testee code when covering that code requires additional pieces of code not yet part of the program under test. To address some of these cases, the Pex state-of-the-art test case generator can generate basic mock code. However, current test case generators cannot handle cases in which the code under test uses multiple interfaces, annotations, or reflection. To cover such code in an object-oriented setting, we describe a novel technique for generating test cases and mock classes. The technique consists of collecting constraints on interfaces, annotations, and reflection, combining them with program constraints collected during dynamic symbolic execution, encoding them in a constraint system, solving them with an off-the-shelf constraint solver, and mapping constraint solutions to test cases and custom mock classes. We demonstrate the value of this technique on open-source applications. Our approach covered such third-party code with generated mock classes, while competing approaches failed to cover the code and sometimes produced unintended side-effects such as filling the screen with dialog boxes and writing into the file system.", "paper_title": "Generating Test Cases for Programs that Are Coded against Interfaces and Annotations", "paper_id": "WOS:000336444200001"}