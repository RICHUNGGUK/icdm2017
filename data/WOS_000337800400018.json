{"auto_keywords": [{"score": 0.024119066074930657, "phrase": "openmp"}, {"score": 0.00481495049065317, "phrase": "multicore_technologies"}, {"score": 0.00468627326602559, "phrase": "parallelization_techniques"}, {"score": 0.004644146045859622, "phrase": "existing_sequential_applications"}, {"score": 0.00439918275666155, "phrase": "good_candidates"}, {"score": 0.0038070472635126276, "phrase": "bonafide_c_analyzer"}, {"score": 0.0036553070575015344, "phrase": "static_analysis"}, {"score": 0.0036224139706218916, "phrase": "source_code"}, {"score": 0.003525493807130663, "phrase": "complete_reports"}, {"score": 0.0034311578789991363, "phrase": "c_application"}, {"score": 0.00338493754743055, "phrase": "loop_coverage"}, {"score": 0.0033544692489307676, "phrase": "loop_suitability"}, {"score": 0.002955533639862811, "phrase": "particular_language_constructs"}, {"score": 0.0029025435402480326, "phrase": "real-world_applications"}, {"score": 0.002592163447843447, "phrase": "in-depth_loop_characterization"}, {"score": 0.0022940375532231145, "phrase": "existent_parallel_programming_models"}, {"score": 0.0021049977753042253, "phrase": "runtime_speculative_parallelization_techniques"}], "paper_keywords": ["Automatic parallelization", " Code analysis", " Compiler framework", " Profiling information", " Source code representation", " Source transformation", " XML"], "paper_abstract": "The advent of multicore technologies has increased the interest in parallelization techniques for existing sequential applications. These techniques include the need of detecting loops that are good candidates for parallelization, and classifying all variables of these loops according to their use, a task surprisingly hard to be carried out manually. In this paper, we introduce the BonaFide C Analyzer, an XML-based framework that combines static analysis of source code with profiling information to generate complete reports regarding all loops in a C application, including loop coverage, loop suitability for parallelization, a classification of all variables inside loops based on their accesses, and other hurdles that restrict the parallelization. This information allows to analyze how particular language constructs are used in real-world applications, and helps the programmer to parallelize the code. To show the features of the framework, we present the results of an in-depth loop characterization of C applications that are part of the SPEC CPU2006 benchmark suite. Our study shows that 47.72 % of loops present in the applications analyzed are potentially parallelizable with existent parallel programming models such as OpenMP, while an additional 37.7 % of loops could be run in parallel with the help of runtime speculative parallelization techniques.", "paper_title": "The BonaFide C Analyzer: automatic loop-level characterization and coverage measurement", "paper_id": "WOS:000337800400018"}