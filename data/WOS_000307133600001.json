{"auto_keywords": [{"score": 0.04979417185091988, "phrase": "state_machine_specifications"}, {"score": 0.005550064836066688, "phrase": "software_development"}, {"score": 0.00481495049065317, "phrase": "code_generation_proposals"}, {"score": 0.00472955160788118, "phrase": "model_driven_development"}, {"score": 0.004701427927987301, "phrase": "mdd"}, {"score": 0.00457688347567955, "phrase": "complex_software_systems"}, {"score": 0.0045225925147033205, "phrase": "mdd_approach"}, {"score": 0.004495687920571303, "phrase": "modelling_languages"}, {"score": 0.0043505358211043425, "phrase": "object-oriented_software"}, {"score": 0.0042989181990989965, "phrase": "state-based_languages"}, {"score": 0.004260605564118872, "phrase": "uml_state_machines"}, {"score": 0.004235252881661159, "phrase": "finite_state_machines"}, {"score": 0.004210050422187886, "phrase": "harel_statecharts"}, {"score": 0.004086260758014118, "phrase": "dynamic_behaviour"}, {"score": 0.003966096429996537, "phrase": "state_machine_models"}, {"score": 0.003907340732073545, "phrase": "final_system"}, {"score": 0.0037139814615660943, "phrase": "object-oriented_programming_languages"}, {"score": 0.003583261176506345, "phrase": "great_attention"}, {"score": 0.003509135412622647, "phrase": "overall_objective"}, {"score": 0.0034058845212645915, "phrase": "published_proposals"}, {"score": 0.003355400119144156, "phrase": "object_oriented_code_generation"}, {"score": 0.003256657868307919, "phrase": "specific_context"}, {"score": 0.0032179767877362512, "phrase": "particular_programming_language"}, {"score": 0.0030769577726521323, "phrase": "oriented_implementation"}, {"score": 0.00301327406964098, "phrase": "systematic_review"}, {"score": 0.002968591879288644, "phrase": "comprehensive_set"}, {"score": 0.00254891711988866, "phrase": "desirable_features"}, {"score": 0.002351260304188475, "phrase": "analysed_works"}, {"score": 0.00231637194556478, "phrase": "software_design_pattern"}, {"score": 0.0022956873374614926, "phrase": "key_finding"}, {"score": 0.002234732712120406, "phrase": "main_components"}, {"score": 0.0022147755031000703, "phrase": "expressive_richness"}, {"score": 0.0021753930127723386, "phrase": "implementation_strategy"}, {"score": 0.0021559645899673664, "phrase": "relevant_qualitative_aspects"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["UML state machines", " Finite state machines", " Statecharts", " Code generation", " Systematic review"], "paper_abstract": "Context: Model Driven Development (MDD) encourages the use of models for developing complex software systems. Following a MDD approach, modelling languages are used to diagrammatically model the structure and behaviour of object-oriented software, among which state-based languages (including UML state machines, finite state machines and Harel statecharts) constitute the most widely used to specify the dynamic behaviour of a system. However, generating code from state machine models as part of the final system constitutes one of the most challenging tasks due to its dynamic nature and because many state machine concepts are not supported by the object-oriented programming languages. Therefore, it is not surprising that such code generation has received great attention over the years. Objective: The overall objective of this paper is to plot the landscape of published proposals in the field of object oriented code generation from state machine specifications, restricting the search neither to a specific context nor to a particular programming language. Method: We perform a systematic, accurate literature review of published studies focusing on the object oriented implementation of state machine specifications. Results: The systematic review is based on a comprehensive set of 53 resources in all, which we have classified into two groups: pattern-based and not pattern-based. For each proposal, we have analysed both the state machine specification elements they support and the means rile authors propose for their implementation. Additionally, the review investigates which proposals take into account desirable features to be considered in software development such as maintenance or reusability. Conclusions: One of the conclusions drawn from the review is that most of the analysed works are based on a software design pattern. Another key finding is that many papers neither support several of the main components of the expressive richness of state machine specifications nor provide an implementation strategy that considers relevant qualitative aspects in software development. (C) 2012 Elsevier B.V. All rights reserved.", "paper_title": "A systematic review of code generation proposals from state machine specifications", "paper_id": "WOS:000307133600001"}