{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "concurrent"}, {"score": 0.0047747348769918, "phrase": "parallel_garbage_collection"}, {"score": 0.004734853555630616, "phrase": "linear_time"}, {"score": 0.004617187934074393, "phrase": "new_concurrent_garbage_collection_algorithm"}, {"score": 0.00426344619171077, "phrase": "strong_references"}, {"score": 0.004003348169928476, "phrase": "weak_references"}, {"score": 0.003727628340195049, "phrase": "reduced_processing"}, {"score": 0.003696460568091852, "phrase": "nontrivial_garbage_collection_work"}, {"score": 0.003604506544515226, "phrase": "last_strong_reference"}, {"score": 0.003456287408801543, "phrase": "garbage_cycle"}, {"score": 0.0030089355635315005, "phrase": "support_cycles"}, {"score": 0.002778064757980489, "phrase": "live_system"}, {"score": 0.0026193328696791306, "phrase": "collection_operations"}, {"score": 0.0025974077149412, "phrase": "different_parts"}, {"score": 0.0024904974828343033, "phrase": "previous_variants"}, {"score": 0.002438699976481979, "phrase": "exponential_cleanup_time"}, {"score": 0.002318728604587962, "phrase": "total_time"}, {"score": 0.002299313860419974, "phrase": "i.e._any_changes"}, {"score": 0.0022326306658609365, "phrase": "time_steps"}, {"score": 0.002131720106846481, "phrase": "affected_subgraph"}, {"score": 0.002113867869575397, "phrase": "e.g._the_subgraph"}], "paper_keywords": ["Algorithms", " Performance", " Experimentation", " Languages", " Design", " Termination", " Garbage Collection", " Parallel programming theory and models", " Compilers and runtime systems", " Software for productivity parallel programming", " Parallel algorithms", " Concurrent data structures"], "paper_abstract": "This paper presents a new concurrent garbage collection algorithm based on two types of reference, strong and weak, to link the graph of objects. Strong references connect the roots to all the nodes in the graph but do not contain cycles. Weak references may, however, contain cycles. Advantages of this system include: (1) reduced processing, nontrivial garbage collection work is only required when the last strong reference is lost; (2) fewer memory traces to delete objects, a garbage cycle only needs to be traversed twice to be deleted; (3) fewer memory traces to retain objects, since the collector can often prove objects are reachable without fully tracing support cycles to which the objects belong; (4) concurrency, it can run in parallel with a live system without \"stopping the world;\" (5) parallel, because collection operations in different parts of the memory can proceed at the same time. Previous variants of this technique required exponential cleanup time [27, 31], but our algorithm is linear in total time, i.e. any changes in the graph take only O(N) time steps, where N is the number of edges in the affected subgraph (e.g. the subgraph whose strong support is affected by the operations).", "paper_title": "Concurrent, Parallel Garbage Collection in Linear Time", "paper_id": "WOS:000358310800005"}