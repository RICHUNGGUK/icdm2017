{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "convolutional_codes"}, {"score": 0.004717723626157272, "phrase": "distinct_memory_sizes"}, {"score": 0.004622450915803531, "phrase": "minimal_encoders"}, {"score": 0.004260134699483774, "phrase": "minimal_trellises"}, {"score": 0.004007083686875716, "phrase": "shifted_versions"}, {"score": 0.003438058620195309, "phrase": "minimal_trellis"}, {"score": 0.0031042018721479385, "phrase": "conventional_code_trellis"}, {"score": 0.0030414140732789186, "phrase": "n-bit_branches"}, {"score": 0.0022382002476510573, "phrase": "minimal_trellis_module"}, {"score": 0.0021484955960643167, "phrase": "convolutional_code"}], "paper_keywords": ["error-correction coding", " convolutional codes", " minimal trellis", " minimal trellis module", " trellis complexity"], "paper_abstract": "In this correspondence, it is shown that some convolutional codes with distinct memory sizes of minimal encoders are equivalent in the sense that the minimal trellises of these codes are the shifted versions of one another. For an (n, k) binary convolutional code, the weight spectrum obtained from the minimal trellis may be slightly different from that obtained from the conventional code trellis with n-bit branches. Code search is conducted to find some good (n, n-1) binary convolutional codes. Bounds on the trellis complexity, measured by the number of states and the number of branches in the minimal trellis module, of any convolutional code and its equivalent codes are also derived.", "paper_title": "Minimal trellis modules and equivalent convolutional codes", "paper_id": "WOS:000239408700027"}