{"auto_keywords": [{"score": 0.028144631874934337, "phrase": "sbpa"}, {"score": 0.00481495049065317, "phrase": "unsynchronized_thread_communication"}, {"score": 0.004673530058379246, "phrase": "parallel_programs"}, {"score": 0.004594582559945568, "phrase": "deterministic_execution_engines"}, {"score": 0.0045556080393342165, "phrase": "data_race_detectors"}, {"score": 0.0044786435725543685, "phrase": "transactional_memory_systems"}, {"score": 0.004421770937919324, "phrase": "instrumenting_loads"}, {"score": 0.004095323392273661, "phrase": "uninstrumented_code"}, {"score": 0.004060566667226606, "phrase": "multithreaded_programming"}, {"score": 0.0038090874465452214, "phrase": "process's_address_space"}, {"score": 0.003557924423642353, "phrase": "unsynchronized_memory_accesses"}, {"score": 0.003468053168607071, "phrase": "single_thread"}, {"score": 0.0033374705499418377, "phrase": "section-based_program_analysis"}, {"score": 0.003157455511069507, "phrase": "disjoint_code_sections"}, {"score": 0.003025597247856977, "phrase": "program_compilation"}, {"score": 0.002617007341172262, "phrase": "deterministic_execution_runtime_environment"}, {"score": 0.0025291601927956765, "phrase": "dynamic_memory_access_instrumentations"}, {"score": 0.00235213013487844, "phrase": "threadsanitizer"}, {"score": 0.0021049977753042253, "phrase": "geometric_mean_basis"}], "paper_keywords": ["Program Analysis", " Race Detection", " Deterministic Execution", " Software Transactional Memory", " Multiprocessing/multiprogramming/multitasking", " program analysis", " compilers", " threads", " parallel processing", " runtime environments"], "paper_abstract": "Most systems that test and verify parallel programs, such as deterministic execution engines, data race detectors, and software transactional memory systems, require instrumenting loads and stores in an application. This can cause a very significant runtime and memory overhead compared to executing uninstrumented code. Multithreaded programming typically allows any thread to perform loads and stores to any location in the process's address space independently, and such tools monitor all these memory accesses. However, many of the addresses in these unsynchronized memory accesses are only used by a single thread and do not affect other executing threads. We propose Section-Based Program Analysis (SBPA), a novel way to decompose the program into disjoint code sections to identify and eliminate instrumenting such loads and stores during program compilation so that the program runtime overhead is significantly reduced. Our analysis includes improvements to pointer analysis and uses a few user directives to increase the effectiveness of SBPA further. We implemented SBPA for a deterministic execution runtime environment and were able to eliminate 51% of dynamic memory access instrumentations. When combined with directives, such reduction increased to 63%. We also integrated SBPA with ThreadSanitizer, a state-of-the-art dynamic race detector, and achieved a speedup of 2.43 (2.74 with directives) on a geometric mean basis.", "paper_title": "Section-Based Program Analysis to Reduce Overhead of Detecting Unsynchronized Thread Communication", "paper_id": "WOS:000357952000015"}