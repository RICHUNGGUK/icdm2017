{"auto_keywords": [{"score": 0.03703953629110321, "phrase": "multi-gpu_system"}, {"score": 0.00481495049065317, "phrase": "mapping_streaming_applications"}, {"score": 0.004764859786310636, "phrase": "multi-gpu_systems"}, {"score": 0.004690694501758065, "phrase": "processing_units"}, {"score": 0.004593591780245872, "phrase": "large_array"}, {"score": 0.004545793387330536, "phrase": "parallel_processing_cores"}, {"score": 0.004382364826200616, "phrase": "specific_streaming_computation_pattern"}, {"score": 0.004291617358806677, "phrase": "graphics_applications"}, {"score": 0.0040942189695983185, "phrase": "required_streaming_behavior"}, {"score": 0.003988487841970088, "phrase": "unfavorable_data_layout_and_poor_computation-to-communication_ratios"}, {"score": 0.00378514792399478, "phrase": "gpu."}, {"score": 0.0036489343475053187, "phrase": "efficient_and_scalable_code_generation_framework"}, {"score": 0.0035733198242955634, "phrase": "general_purpose_streaming_applications"}, {"score": 0.0034088473318056537, "phrase": "entire_core"}, {"score": 0.003373334961160647, "phrase": "memory_hierarchy"}, {"score": 0.0031348622158167195, "phrase": "complex_streaming_applications"}, {"score": 0.0030220049006970317, "phrase": "efficient_stream_graph"}, {"score": 0.0029284999172756103, "phrase": "complex_application"}, {"score": 0.002867771524071872, "phrase": "best_performance"}, {"score": 0.002750056254309311, "phrase": "resulting_partitions"}, {"score": 0.002693018258362651, "phrase": "multiple_gpus"}, {"score": 0.002651015392318126, "phrase": "efficient_architecture-driven_strategy"}, {"score": 0.0025156683465194967, "phrase": "communication_overhead"}, {"score": 0.002450602177683066, "phrase": "highly_effective_pipeline_execution"}, {"score": 0.002172266188075892, "phrase": "streamit_programming_language_compiler"}, {"score": 0.0021049977753042253, "phrase": "significant_performance_speedup"}], "paper_keywords": ["Algorithms", " Performance", " Design"], "paper_abstract": "Graphics processing units leverage on a large array of parallel processing cores to boost the performance of a specific streaming computation pattern frequently found in graphics applications. Unfortunately, while many other general purpose applications do exhibit the required streaming behavior, they also possess unfavorable data layout and poor computation-to-communication ratios that penalize any straight-forward execution on the GPU. In this paper we describe an efficient and scalable code generation framework that can map general purpose streaming applications onto a multi-GPU system. This framework spans the entire core and memory hierarchy exposed by the multi-GPU system. Several key features in our framework ensure the scalability required by complex streaming applications. First, we propose an efficient stream graph partitioning algorithm that partitions the complex application to achieve the best performance under a given shared memory constraint. Next, the resulting partitions are mapped to multiple GPUs using an efficient architecture-driven strategy. The mapping balances the workload while considering the communication overhead. Finally, a highly effective pipeline execution is employed for the execution of the partitions on the multi-GPU system. The framework has been implemented as a back-end of the StreamIt programming language compiler. Our comprehensive experiments show its scalability and significant performance speedup compared with a previous state-of-the-art solution.", "paper_title": "Scalable Framework for Mapping Streaming Applications onto Multi-GPU Systems", "paper_id": "WOS:000309350200001"}