{"auto_keywords": [{"score": 0.03704300676831513, "phrase": "sat_solver"}, {"score": 0.015483621666231859, "phrase": "finite_domain_propagation"}, {"score": 0.00903026914369701, "phrase": "resulting_system"}, {"score": 0.00481495049065317, "phrase": "lazy_clause_generation"}, {"score": 0.004563880494020726, "phrase": "possible_values"}, {"score": 0.0041001740903338834, "phrase": "boolean_variables"}, {"score": 0.003769006950727621, "phrase": "finite_domain_propagation_engine"}, {"score": 0.0033599501775954024, "phrase": "strong_nogoods"}, {"score": 0.003208999546225013, "phrase": "naive_static_translation"}, {"score": 0.003088384809415812, "phrase": "limited_cases"}, {"score": 0.00288255520607591, "phrase": "lazy_clause_generators"}, {"score": 0.0025110337774260773, "phrase": "propagation_engine"}, {"score": 0.0023079225317714815, "phrase": "dual_modelling"}], "paper_keywords": ["Finite domain propagation", " Boolean variables", " SAT solver"], "paper_abstract": "Finite domain propagation solvers effectively represent the possible values of variables by a set of choices which can be naturally modelled as Boolean variables. In this paper we describe how to mimic a finite domain propagation engine, by mapping propagators into clauses in a SAT solver. This immediately results in strong nogoods for finite domain propagation. But a naive static translation is impractical except in limited cases. We show how to convert propagators to lazy clause generators for a SAT solver. The resulting system introduces flexibility in modelling since variables are modelled dually in the propagation engine and the SAT solver, and we explore various approaches to the dual modelling. We show that the resulting system solves many finite domain problems significantly faster than other techniques.", "paper_title": "Propagation via lazy clause generation", "paper_id": "WOS:000266448200004"}