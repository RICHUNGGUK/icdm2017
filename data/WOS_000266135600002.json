{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "efficient_compilation"}, {"score": 0.004774937143916685, "phrase": "queue_size"}, {"score": 0.004735254735115024, "phrase": "queue_processors"}, {"score": 0.004695900553353526, "phrase": "queue_computers"}, {"score": 0.004637478829869904, "phrase": "fifo_data_structure"}, {"score": 0.004598933498016774, "phrase": "data_processing"}, {"score": 0.004541712637353326, "phrase": "essential_characteristics"}, {"score": 0.004485200522202792, "phrase": "queue-based_architecture"}, {"score": 0.0043560464825349275, "phrase": "embedded_systems"}, {"score": 0.004301834610818624, "phrase": "compact_instruction"}, {"score": 0.004160531596936783, "phrase": "low_power_consumption"}, {"score": 0.004007083686875716, "phrase": "important_concern"}, {"score": 0.00390792986752692, "phrase": "realizable_embedded_queue_processor"}, {"score": 0.0037324526526073404, "phrase": "data_dependency_edges"}, {"score": 0.0031448288291084, "phrase": "available_hardware"}, {"score": 0.003066945490483524, "phrase": "data_flow_graph"}, {"score": 0.00290473242917264, "phrase": "queue_limits"}, {"score": 0.0028685304140180137, "phrase": "target_architecture"}, {"score": 0.0026055251533586804, "phrase": "variables'_reaching_definitions"}, {"score": 0.002509284173541882, "phrase": "generated_code"}, {"score": 0.002447101794397243, "phrase": "different_queue_size_configurations"}, {"score": 0.0023764959294052964, "phrase": "reasonable_queue_sizes"}, {"score": 0.0022413233627905696, "phrase": "infinite_resources"}, {"score": 0.0022041312401435346, "phrase": "instruction_count"}, {"score": 0.0021857667493036786, "phrase": "static_execution_time"}, {"score": 0.002158505888557746, "phrase": "instruction_level_parallelism"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Queue register file", " Queue processor", " Constrained", " Optimization", " Compiler"], "paper_abstract": "Queue computers use a FIFO data structure for data processing. The essential characteristics of a queue-based architecture excel at satisfying the demands of embedded systems, including compact instruction set, simple hardware logic, high parallelism, and low power consumption. The size of the queue is an important concern in the design of a realizable embedded queue processor. We introduce the relationship between parallelism, length of data dependency edges in data flow graphs and the queue utilization requirements. This paper presents a technique developed to make the compiler aware of the size of the queue register file and, thus, optimize the programs to effectively utilize the available hardware. The compiler examines the data flow graph of the programs and partitions it into clusters whenever it exceeds the queue limits of the target architecture. The presented algorithm deals with the two factors that affect the utilization of the queue, namely parallelism and the length of variables' reaching definitions. We analyze how the quality of the generated code is affected for SPEC CINT95 benchmark programs and different queue size configurations. Our results show that for reasonable queue sizes the compiler generates a code that is comparable to the code generated for infinite resources in terms of instruction count, static execution time, and instruction level parallelism. (C) 2008 Elsevier B.V. All rights reserved.", "paper_title": "Efficient compilation for queue size constrained queue processors", "paper_id": "WOS:000266135600002"}