{"auto_keywords": [{"score": 0.044552909500734754, "phrase": "leaked_memory"}, {"score": 0.0393378573740974, "phrase": "memory_leaks"}, {"score": 0.00481495049065317, "phrase": "general-purpose_memory_allocator"}, {"score": 0.00471228691115201, "phrase": "continuing_problem"}, {"score": 0.0046118021635786315, "phrase": "programming_languages"}, {"score": 0.004338530593157634, "phrase": "software_application"}, {"score": 0.0042004472903194616, "phrase": "specially_constructed_memory_allocation_routines"}, {"score": 0.004096082254543022, "phrase": "usual_general-purpose_memory_allocator"}, {"score": 0.003937273640906994, "phrase": "memory_utilization"}, {"score": 0.0038671299350540554, "phrase": "new_scheme"}, {"score": 0.003798231095121328, "phrase": "existing_memory_allocation_routines"}, {"score": 0.003611751858608048, "phrase": "kernel_level"}, {"score": 0.0035473867669654174, "phrase": "major_advantages"}, {"score": 0.0034467717443162015, "phrase": "application_software"}, {"score": 0.0031164983132321417, "phrase": "remote_host"}, {"score": 0.002963390095037466, "phrase": "application_program's_performance"}, {"score": 0.00284837132359445, "phrase": "service_availability"}, {"score": 0.0026600905156986317, "phrase": "gnu_c_library"}, {"score": 0.0026220625042810706, "phrase": "linux_kernel"}, {"score": 0.00247529638625566, "phrase": "computational_overhead"}, {"score": 0.002387758958649797, "phrase": "conventional_memory_allocator"}, {"score": 0.0023367260405565814, "phrase": "average_response_time"}, {"score": 0.0021587414711262904, "phrase": "synthetic_workloads"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["memory leak toleration", " memory leak", " garbage collection", " Lea memory allocator", " operating systems"], "paper_abstract": "Memory leaks are a continuing problem in the software developed with programming languages, such as C and C++. A recent approach adopted by some researchers is to tolerate leaks in the software application and to reclaim the leaked memory by use of specially constructed memory allocation routines. However, such routines replace the usual general-purpose memory allocator and tend to be less efficient in speed and in memory utilization. We propose a new scheme which coexists with the existing memory allocation routines and which reclaims memory leaks. Our scheme identifies and reclaims leaked memory at the kernel level. There are some major advantages to our approach: (I) the application software does not need to be modified; (2) the application does not need to be suspended while leaked memory is reclaimed; (3) a remote host can be used to identify the leaked memory, thus minimizing impact on the application program's performance; and (4) our scheme does not degrade the service availability of the application while detecting and reclaiming memory leaks. We have implemented a prototype that works with the GNU C library and with the Linux kernel. Our prototype has been tested and evaluated with various real-world applications. Our results show that the computational overhead of our approach is around 2% of that incurred by the conventional memory allocator in terms of throughput and average response time. We also verified that the prototype successfully suppressed address space expansion caused by memory leaks when the applications are run on synthetic workloads. Copyright (C) 2010 John Wiley & Sons, Ltd.", "paper_title": "KAL: kernel-assisted non-invasive memory leak tolerance with a general-purpose memory allocator", "paper_id": "WOS:000280044400002"}