{"auto_keywords": [{"score": 0.004687645903373103, "phrase": "ever_growing_complexity"}, {"score": 0.004645959941491617, "phrase": "system-on-chip_design"}, {"score": 0.0044430006374681285, "phrase": "higher_levels"}, {"score": 0.004325487452170154, "phrase": "high-level_synthesis_solutions"}, {"score": 0.004136469845987887, "phrase": "uniform_communication_interface"}, {"score": 0.004045068727683462, "phrase": "high-level_implementations"}, {"score": 0.0037157201349604222, "phrase": "dedicated_hardware_ips"}, {"score": 0.0035532533960012298, "phrase": "component_communication_framework"}, {"score": 0.0034902664176377943, "phrase": "object-oriented_remote_call_mechanism"}, {"score": 0.0033525843225012918, "phrase": "proposed_framework"}, {"score": 0.003278447235176858, "phrase": "efficiently_abstract_communication"}, {"score": 0.0031350397225314262, "phrase": "portability_layer"}, {"score": 0.0030248298759040695, "phrase": "different_hardware_platforms"}, {"score": 0.002997886346903894, "phrase": "operating_systems"}, {"score": 0.0028667159745494933, "phrase": "area_footprint"}, {"score": 0.0027659126653647712, "phrase": "voice_processing_pipeline"}, {"score": 0.0027047136845332917, "phrase": "network-on-chip_based_architecture"}, {"score": 0.0026095920086044145, "phrase": "previous_related_works"}, {"score": 0.0024292428060702803, "phrase": "software_memory"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["System-on-Chip", " System-level design", " High-level synthesis", " HW/SW co-design", " HW/SW communication"], "paper_abstract": "With the ever growing complexity of System-on-Chip design, a considerable effort has been made to introduce higher levels of abstraction and to integrate high-level synthesis solutions to the design flow. In such design flows, a uniform communication interface is needed to enable high-level implementations of SoC components regardless of whether they are compiled as software running on a processor or synthesized to dedicated hardware IPs. This paper addresses this issue and proposes a component communication framework that defines an object-oriented remote call mechanism which allows transparent communication across hardware/software boundaries. The proposed framework relies on C++ static metaprogramming techniques to efficiently abstract communication between components implemented using high-level C++. We also define a portability layer that enables the migration of designs throughout different hardware platforms, operating systems, and tools. We assessed the performance and area footprint of our communication infrastructure through the implementation of a voice processing pipeline on top of a Network-on-Chip based architecture. Our results, when compared to previous related works with the same set of capabilities, show that our mechanisms yield small overhead in terms of software memory (up to 64% smaller), FPGA resources (up to 40% smaller), and hardware/software communication latency (up to 51% smaller). (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "A metaprogrammed C plus plus framework for hardware/software component integration and communication", "paper_id": "WOS:000349277600003"}