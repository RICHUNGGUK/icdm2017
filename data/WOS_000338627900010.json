{"auto_keywords": [{"score": 0.039072027586954265, "phrase": "dynamic_designs"}, {"score": 0.009332120039799507, "phrase": "design_space"}, {"score": 0.008551743679011226, "phrase": "static_designs"}, {"score": 0.00481495049065317, "phrase": "finite-difference_applications"}, {"score": 0.0047051051659828275, "phrase": "finite-difference_methods"}, {"score": 0.004451546786101008, "phrase": "finite-difference_algorithm"}, {"score": 0.004370087541308677, "phrase": "grid_size"}, {"score": 0.004172874316207784, "phrase": "algorithm_instances"}, {"score": 0.004134508282135594, "phrase": "different_constant_coefficients"}, {"score": 0.004077616905584829, "phrase": "algorithm_instance"}, {"score": 0.004040123129261597, "phrase": "specific_coefficients"}, {"score": 0.003929689573550262, "phrase": "general_operators"}, {"score": 0.0037696519417841287, "phrase": "constant-specific_operators"}, {"score": 0.0036496814103475174, "phrase": "runtime_reconfiguration"}, {"score": 0.0035994372026264478, "phrase": "algorithm_coefficients"}, {"score": 0.0035010071030752883, "phrase": "tuning_method"}, {"score": 0.0032514447965530323, "phrase": "evaluation_method"}, {"score": 0.0031625006830124512, "phrase": "maximum_overall_throughput"}, {"score": 0.0031045562469735307, "phrase": "algorithm_characteristics"}, {"score": 0.0030336118627011786, "phrase": "available_resources"}, {"score": 0.0030056887638095883, "phrase": "runtime_data"}, {"score": 0.002950608985750058, "phrase": "benchmark_applications_option_pricing"}, {"score": 0.002856632173450493, "phrase": "rtm"}, {"score": 0.002640636493247601, "phrase": "precision_requirements"}, {"score": 0.0025922289692173997, "phrase": "single_hardware_implementation"}, {"score": 0.0025565050791036973, "phrase": "rtm_design"}, {"score": 0.0025096359514694523, "phrase": "proposed_approach"}, {"score": 0.002396179086883189, "phrase": "best_published_design"}, {"score": 0.002363150587804677, "phrase": "tuned_static_designs"}, {"score": 0.0022355167967736326, "phrase": "small_data_size"}, {"score": 0.0021945194903838132, "phrase": "tuned_dynamic_designs"}, {"score": 0.0021245712108461227, "phrase": "corresponding_static_designs"}, {"score": 0.0021049977753042253, "phrase": "large-scale_finite-difference_algorithms"}], "paper_keywords": ["Algorithm tuning", " finite-difference methods", " reconfigurable computing"], "paper_abstract": "Finite-difference methods are computationally intensive and required by many applications. Parameters of a finite-difference algorithm, such as grid size, can be varied to generate design space which contains algorithm instances with different constant coefficients. An algorithm instance with specific coefficients can either be mapped into general operators to construct static designs, or be implemented as constant-specific operators to form dynamic designs, which require runtime reconfiguration to update algorithm coefficients. This article proposes a tuning method to explore the design space to optimise both the static and the dynamic designs, and an evaluation method to select the design with maximum overall throughput, based on algorithm characteristics, design properties, available resources and runtime data size. For benchmark applications option pricing and Reverse-Time Migration (RTM), over 50% reduction in resource consumption has been achieved for both static designs and dynamic designs, while meeting precision requirements. For a single hardware implementation, the RTM design optimised with the proposed approach is expected to run 1.8 times faster than the best published design. The tuned static designs run thousands of times faster than the dynamic designs for algorithms with small data size, while the tuned dynamic designs achieve up to 5.9 times speedup over the corresponding static designs for large-scale finite-difference algorithms.", "paper_title": "A Self-Aware Tuning and Self-Aware Evaluation Method for Finite-Difference Applications in Reconfigurable Systems", "paper_id": "WOS:000338627900010"}