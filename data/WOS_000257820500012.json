{"auto_keywords": [{"score": 0.04888818798303966, "phrase": "synchronous_block_diagrams"}, {"score": 0.024078734408397192, "phrase": "intermediate_language"}, {"score": 0.00481495049065317, "phrase": "synchronous_data-flow_languages"}, {"score": 0.00464811139983244, "phrase": "sequential_imperative_code"}, {"score": 0.004160319763461951, "phrase": "existing_compilers"}, {"score": 0.004077272409331917, "phrase": "industrial_ones"}, {"score": 0.0037423521744765075, "phrase": "long-term_goal"}, {"score": 0.0036676174658755683, "phrase": "mathematically_certified_compiler"}, {"score": 0.0036125439380579626, "phrase": "synchronous_language"}, {"score": 0.0035048567587934254, "phrase": "existing_implementations"}, {"score": 0.0034003686971964707, "phrase": "full_detail"}, {"score": 0.003366233863411861, "phrase": "modular_compilation"}, {"score": 0.0032989853590079153, "phrase": "sequential_code"}, {"score": 0.003105174940950593, "phrase": "lustre"}, {"score": 0.0029973957125353306, "phrase": "general_n-ary_merge_operator"}, {"score": 0.002878785759716458, "phrase": "richer_notion"}, {"score": 0.0025503112711036994, "phrase": "compilation_process"}, {"score": 0.0025119730908615104, "phrase": "efficient_imperative_code"}, {"score": 0.0024493494346360415, "phrase": "generic_machine-based_intermediate_language"}, {"score": 0.0023287359930308864, "phrase": "concise_clock-directed_translation"}, {"score": 0.002202894673025544, "phrase": "target_code_generation_phase"}, {"score": 0.0021051140664200304, "phrase": "java"}], "paper_keywords": ["algorithms", " languages", " theory", " verification", " real-time systems", " synchronous languages", " compilation", " semantics", " type systems"], "paper_abstract": "The compilation of synchronous block diagrams into sequential imperative code has been addressed in the early eighties and can now be considered as folklore. However, separate, or modular, code generation, though largely used in existing compilers and particularly in industrial ones, has never been precisely described or entirely formalized. Such a formalization is now fundamental in the long-term goal to develop a mathematically certified compiler for a synchronous language as well as in simplifying existing implementations. This article presents in full detail the modular compilation of synchronous block diagrams into sequential code. We consider a first-order functional language reminiscent of LUSTRE, which it extends with a general n-ary merge operator, a reset construct, and a richer notion of clocks. The clocks are used to express activation of computations in the program and are specifically taken into account during the compilation process to produce efficient imperative code. We introduce a generic machine-based intermediate language to represent transition functions, and we present a concise clock-directed translation from the source to this intermediate language. We address the target code generation phase by describing a translation from the intermediate language to JAVA and C.", "paper_title": "Clock-directed modular code generation for synchronous data-flow languages", "paper_id": "WOS:000257820500012"}