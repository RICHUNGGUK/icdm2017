{"auto_keywords": [{"score": 0.04927465911141675, "phrase": "mutation_testing"}, {"score": 0.029178185356459253, "phrase": "mutation_operators"}, {"score": 0.00481495049065317, "phrase": "practical_mutation_testing"}, {"score": 0.004774324145784758, "phrase": "aspectj_programs"}, {"score": 0.00467424463996457, "phrase": "test_selection_criterion"}, {"score": 0.004537631845923196, "phrase": "test_cases"}, {"score": 0.004461359547152617, "phrase": "artificial_faults"}, {"score": 0.004276216827737399, "phrase": "real_ones"}, {"score": 0.003829877278269543, "phrase": "testing-related_specificities"}, {"score": 0.003797530813314321, "phrase": "contemporary_programming_techniques"}, {"score": 0.0037495207047193034, "phrase": "aspect-oriented_programming"}, {"score": 0.003400984514637656, "phrase": "simulated_faults"}, {"score": 0.003301461490509176, "phrase": "adequate_tool_support"}, {"score": 0.00327356326590461, "phrase": "proper_evaluation"}, {"score": 0.0031912706211861324, "phrase": "application_cost"}, {"score": 0.003032820755030689, "phrase": "comprehensive_mutation-based_testing_approach"}, {"score": 0.0029691399875682416, "phrase": "aspectj"}, {"score": 0.0027274643070540733, "phrase": "aspectj-specific_constructs"}, {"score": 0.002548331088496964, "phrase": "preliminary_evaluation_study_show"}, {"score": 0.002177762848946681, "phrase": "practical_fault-based_testing"}, {"score": 0.0021593396036472777, "phrase": "aspectj-like_programs"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Mutation testing", " Aspect-oriented programming", " AspectJ", " Testing AspectJ programs", " Test evaluation"], "paper_abstract": "Mutation testing is a test selection criterion that relies on the assumption that test cases which can reveal artificial faults in the software are also good to reveal the real ones. It helps to expose faults which would go otherwise unnoticed. This criterion has been shown to be a promising means to deal with testing-related specificities of contemporary programming techniques such as Aspect-Oriented Programming. However, to date the few initiatives for customising mutation testing for aspect-oriented (AO) programs show either limited coverage with respect to the range of simulated faults, or a need for both adequate tool support and proper evaluation in regard to properties like application cost and effectiveness. This article tackles these limitations by describing a comprehensive mutation-based testing approach for programs written in AspectJ, which represents the most investigated AO programming language to date. The approach encompasses the definition of a set of mutation operators for AspectJ-specific constructs and the implementation of a tool that automates the approach. The results of a preliminary evaluation study show that the mutation operators are able to simulate faults that may not be revealed by pre-existing, non-mutation-based test suites. The results also suggest that the approach seems not to overwhelm the testers and hence represents a step towards the practical fault-based testing of AspectJ-like programs. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Towards the practical mutation testing of AspectJ programs", "paper_id": "WOS:000321536100022"}