{"auto_keywords": [{"score": 0.049655608595442415, "phrase": "callstack-sensitive_slicing"}, {"score": 0.009714962048662294, "phrase": "bad_output"}, {"score": 0.009253843311761885, "phrase": "print_statements"}, {"score": 0.006909106249254199, "phrase": "slice_sizes"}, {"score": 0.00481495049065317, "phrase": "output_tracing"}, {"score": 0.004232875294230749, "phrase": "actual_bug"}, {"score": 0.004158290806404304, "phrase": "debugger_break_points"}, {"score": 0.003449972561293443, "phrase": "backward_slices"}, {"score": 0.003329368827624161, "phrase": "original_program"}, {"score": 0.0022806798371116698, "phrase": "callstack-sensitive_slice"}, {"score": 0.0021910825909008946, "phrase": "corresponding_full_slice"}, {"score": 0.002123831297790248, "phrase": "best_case"}, {"score": 0.0021049977753042253, "phrase": "slice_intersection"}], "paper_keywords": ["Static program slicing", " callstack-sensitive analysis", " points of failure", " output tracing and attribution"], "paper_abstract": "Debugging often involves 1) finding the point of failure (the first statement that produces bad output) and 2) finding and fixing the actual bug. Print statements and debugger break points can help with step 1. Slicing the program back from values used at the point of failure can help with step 2. However, neither approach is ideal: Debuggers and print statements can be clumsy and time-consuming and backward slices can be almost as large as the original program. This paper addresses both problems. We present callstack-sensitive slicing, which reduces slice sizes by leveraging the series of calls active when a program fails. We also show how slice intersections may further reduce slice sizes. We then describe a set of tools that identifies points of failure for programs that produce bad output. Finally, we apply our point-of-failure tools to a suite of buggy programs and evaluate callstack-sensitive slicing and slice intersection as applied to debugging. Callstack-sensitive slicing is very effective: On average, a callstack-sensitive slice is about 0.31 time the size of the corresponding full slice, down to just 0.06 time in the best case. Slice intersection is less impressive, on average, but may sometimes prove useful in practice.", "paper_title": "Better Debugging via Output Tracing and Callstack-Sensitive Slicing", "paper_id": "WOS:000273988900003"}