{"auto_keywords": [{"score": 0.03820278862285535, "phrase": "preconditioning_techniques"}, {"score": 0.00481495049065317, "phrase": "efficient_spilling_reduction"}, {"score": 0.004634459424542272, "phrase": "multiple_register"}, {"score": 0.004568525347438891, "phrase": "embedded_vliw_processors"}, {"score": 0.004503525064934708, "phrase": "register_allocation"}, {"score": 0.004460703838987562, "phrase": "software_pipelining"}, {"score": 0.004355415885815204, "phrase": "active_research_area"}, {"score": 0.004172094622123562, "phrase": "dependence_graph"}, {"score": 0.003977403701783668, "phrase": "register_spill_instructions"}, {"score": 0.0038834787946979863, "phrase": "register_allocator"}, {"score": 0.003828187766572941, "phrase": "software_pipelined_loop"}, {"score": 0.0036669760226536977, "phrase": "input_code"}, {"score": 0.003597514862052876, "phrase": "dependence_arcs"}, {"score": 0.003529364798514874, "phrase": "maximum_register_pressure"}, {"score": 0.0035125292519354724, "phrase": "maxlive"}, {"score": 0.0034459835582278746, "phrase": "loop_schedule"}, {"score": 0.003348513474852869, "phrase": "available_registers"}, {"score": 0.00326939082861424, "phrase": "initiation_interval"}, {"score": 0.00311669276800628, "phrase": "spill-free_software_pipeline"}, {"score": 0.0030285084113651035, "phrase": "existing_preconditioning_techniques"}, {"score": 0.0026742419973883134, "phrase": "multiple_register_types"}, {"score": 0.002549269480908849, "phrase": "existing_theory"}, {"score": 0.002524982927936405, "phrase": "register_pressure_minimization"}, {"score": 0.002500927169609655, "phrase": "cyclic_scheduling"}, {"score": 0.0023954743066925714, "phrase": "production_compiler"}, {"score": 0.0022834993174767016, "phrase": "industry_benchmarks"}, {"score": 0.0022617389804167943, "phrase": "ffmpeg"}, {"score": 0.0022401862074914263, "phrase": "mediabench"}, {"score": 0.0021354538918029286, "phrase": "high_spill_reduction_rate"}, {"score": 0.0021049977753042253, "phrase": "significant_initiation_interval_loss"}], "paper_keywords": ["Languages", " Performance", " Algorithms", " Software pipelining", " register allocation", " backend compilation", " code optimization", " instruction-level parallelism"], "paper_abstract": "Integrating register allocation and software pipelining of loops is an active research area. We focus on techniques that precondition the dependence graph before software pipelining in order to ensure that no register spill instructions are inserted by the register allocator in the software pipelined loop. If spilling is not necessary for the input code, preconditioning techniques insert dependence arcs so that the maximum register pressure MAXLIVE achieved by any loop schedule is below the number of available registers, without hurting the initiation interval if possible. When a solution exists, a spill-free software pipeline is guaranteed to exist. Existing preconditioning techniques consider one register type (register class) at a time [Deschinkel and Touati 2008]. In this article, we extend preconditioning techniques so that multiple register types are considered simultaneously. First, we generalize the existing theory of register pressure minimization for cyclic scheduling. Second, we implement our method inside the production compiler of the ST2xx VLIW family, and we demonstrate its efficiency on industry benchmarks (FFMPEG, MEDIABENCH, SPEC2000, SPEC2006). We demonstrate a high spill reduction rate without a significant initiation interval loss.", "paper_title": "Efficient Spilling Reduction for Software Pipelined Loops in Presence of Multiple Register Types in Embedded VLIW Processors", "paper_id": "WOS:000297636300009"}