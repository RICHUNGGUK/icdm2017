{"auto_keywords": [{"score": 0.04028252665987456, "phrase": "mathfinder"}, {"score": 0.013286960893780217, "phrase": "unit_tests"}, {"score": 0.00932504784645499, "phrase": "math_apis"}, {"score": 0.007294491359370973, "phrase": "api_methods"}, {"score": 0.0047889255373616, "phrase": "discovery"}, {"score": 0.004708271862317615, "phrase": "today's_programming_languages"}, {"score": 0.0046558180142346264, "phrase": "powerful_third-party_apis"}, {"score": 0.004594304573816642, "phrase": "api_discovery"}, {"score": 0.004476768460196375, "phrase": "similar_functionality"}, {"score": 0.004451755800490286, "phrase": "programmer_productivity"}, {"score": 0.004405251146889534, "phrase": "api_migration"}, {"score": 0.0043775495353727085, "phrase": "programmer's_ability"}, {"score": 0.004340909525179319, "phrase": "suitable_apis"}, {"score": 0.004292530731019078, "phrase": "initial_coding_phase"}, {"score": 0.004220967333660075, "phrase": "software_maintenance"}, {"score": 0.0038914782116254622, "phrase": "scientific_computations"}, {"score": 0.0038051815323870224, "phrase": "executable_specifications"}, {"score": 0.0037839069098097983, "phrase": "mathematical_computations"}, {"score": 0.0036587247965487366, "phrase": "math_expression"}, {"score": 0.0035277634006184756, "phrase": "mining_unit_tests"}, {"score": 0.0034495044604576385, "phrase": "sequential_version"}, {"score": 0.0032430998954652043, "phrase": "math_algorithms"}, {"score": 0.0031094742030008346, "phrase": "client_programs"}, {"score": 0.003083415089790538, "phrase": "math_api"}, {"score": 0.003023455343804771, "phrase": "api."}, {"score": 0.002931569771634119, "phrase": "diverse_collection"}, {"score": 0.00291516518556239, "phrase": "math_expressions"}, {"score": 0.002850457082930323, "phrase": "wide_range"}, {"score": 0.002834505099882888, "phrase": "application_areas"}, {"score": 0.0028107438825394, "phrase": "control_systems"}, {"score": 0.0027950135231005063, "phrase": "structural_dynamics"}, {"score": 0.0027638156862940465, "phrase": "user_study"}, {"score": 0.002732965124214202, "phrase": "productivity_gains"}, {"score": 0.002562123444678208, "phrase": "usual_techniques"}, {"score": 0.002456486927713543, "phrase": "library_documentation"}, {"score": 0.002388487669097511, "phrase": "case_study"}, {"score": 0.002342009109681423, "phrase": "weka"}, {"score": 0.0022141245558628263, "phrase": "highly_precise_results"}, {"score": 0.0021588732488356994, "phrase": "small_number"}, {"score": 0.0021049977753042253, "phrase": "large_collections"}], "paper_keywords": ["Algorithms", " Design", " Experimentation", " API discovery", " API migration", " mathematical computation", " mining", " unit tests"], "paper_abstract": "Today's programming languages are supported by powerful third-party APIs. For a given application domain, it is common to have many competing APIs that provide similar functionality. Programmer productivity therefore depends heavily on the programmer's ability to discover suitable APIs both during an initial coding phase, as well as during software maintenance. The aim of this work is to support the discovery and migration of math APIs. Math APIs are at the heart of many application domains ranging from machine learning to scientific computations. Our approach, called MATHFINDER, combines executable specifications of mathematical computations with unit tests (operational specifications) of API methods. Given a math expression, MATHFINDER synthesizes pseudo-code comprised of API methods to compute the expression by mining unit tests of the API methods. We present a sequential version of our unit test mining algorithm and also design a more scalable data-parallel version. We perform extensive evaluation of MATHFINDER (1) for API discovery, where math algorithms are to be implemented from scratch and (2) for API migration, where client programs utilizing a math API are to be migrated to another API. We evaluated the precision and recall of MATHFINDER on a diverse collection of math expressions, culled from algorithms used in a wide range of application areas such as control systems and structural dynamics. In a user study to evaluate the productivity gains obtained by using MATHFINDER for API discovery, the programmers who used MATHFINDER finished their programming tasks twice as fast as their counterparts who used the usual techniques like web and code search, IDE code completion, and manual inspection of library documentation. For the problem of API migration, as a case study, we used MATHFINDER to migrate Weka, a popular machine learning library. Overall, our evaluation shows that MATHFINDER is easy to use, provides highly precise results across several math APIs and application domains even with a small number of unit tests per method, and scales to large collections of unit tests.", "paper_title": "Mining Unit Tests for Discovery and Migration of Math APIs", "paper_id": "WOS:000344320200004"}