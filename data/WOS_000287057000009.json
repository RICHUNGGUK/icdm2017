{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "omega"}, {"score": 0.049737504238110006, "phrase": "unknown_membership"}, {"score": 0.03825664445954391, "phrase": "correct_processes"}, {"score": 0.028960483244326204, "phrase": "first_implementation"}, {"score": 0.004686791459644141, "phrase": "eventual_leader_election_functionality"}, {"score": 0.0042500322609733574, "phrase": "n_the_number"}, {"score": 0.0039061983019451903, "phrase": "crashed_processes"}, {"score": 0.0037133478610481994, "phrase": "omega_crash"}, {"score": 0.0029714533918949798, "phrase": "add_link"}, {"score": 0.002853396755102163, "phrase": "consecutive_messages"}, {"score": 0.0026579417954765137, "phrase": "partially_synchronous_systems"}, {"score": 0.002640038329840458, "phrase": "add_links"}, {"score": 0.0022145052062614514, "phrase": "correct_process"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Distributed computing", " Fault tolerance", " Unreliable failure detectors"], "paper_abstract": "The failure detector class Omega (Omega) provides an eventual leader election functionality. i.e., eventually all correct processes permanently trust the same correct process. An algorithm is communication-efficient if the number of links that carry messages forever is bounded by n, being n the number of processes in the system. It has been defined that an algorithm is crash-quiescent if it eventually stops sending messages to crashed processes. In this regard, it has been recently shown the impossibility of implementing Omega crash quiescently without a majority of correct processes. We say that the membership is unknown if each process p(i) only knows its own identity and the number of processes in the system (that is, i and n), but p(i) does not know the identity of the rest of processes of the system. There is a type of link (denoted by ADD link) in which a bounded (but unknown) number of consecutive messages can be delayed or lost. In this work we present the first implementation (to our knowledge) of Omega in partially synchronous systems with ADD links and with unknown membership. Furthermore, it is the first implementation of Omega that combines two very interesting properties: communication-efficiency and crash-quiescence when the majority of processes are correct. Finally, we also obtain with the same algorithm a failure detector (lozenge(P) over bar) such that every correct process eventually and permanently outputs the set of all correct processes. (C) 2010 Elsevier B.V. All rights reserved.", "paper_title": "Communication-efficient and crash-quiescent Omega with unknown membership", "paper_id": "WOS:000287057000009"}