{"auto_keywords": [{"score": 0.028966655209534835, "phrase": "execution_levels"}, {"score": 0.017573389135452602, "phrase": "infinite_regression"}, {"score": 0.010612387000973441, "phrase": "aspect-oriented_programming"}, {"score": 0.008803788683373864, "phrase": "base_level_computation"}, {"score": 0.004543436145505023, "phrase": "advice_evaluation"}, {"score": 0.0044209926093642235, "phrase": "base_program_evaluation"}, {"score": 0.0042001988034802125, "phrase": "aspectj"}, {"score": 0.004157374465795314, "phrase": "simply_all_pointcuts"}, {"score": 0.004129067429043414, "phrase": "higher-order_aspect_languages"}, {"score": 0.004100952337610039, "phrase": "aspectscheme"}, {"score": 0.003949696038487492, "phrase": "aop"}, {"score": 0.003663645143713398, "phrase": "base_level"}, {"score": 0.003540539868937462, "phrase": "aspect_languages"}, {"score": 0.003516417950483685, "phrase": "ad-hoc_mechanisms"}, {"score": 0.0030879936732269293, "phrase": "programming_language"}, {"score": 0.00293357578778008, "phrase": "defensive_default"}, {"score": 0.002777341265639153, "phrase": "level-shifting_operators"}, {"score": 0.0025409639091476363, "phrase": "existing_aspect-oriented_programs"}, {"score": 0.002430411367515404, "phrase": "default_semantics"}, {"score": 0.0022618732192713235, "phrase": "existing_implementations"}, {"score": 0.0022311183974368484, "phrase": "aspect-oriented_extensions"}, {"score": 0.00221716919219477, "phrase": "scheme"}, {"score": 0.0022007909875054305, "phrase": "javascript"}, {"score": 0.0021858069963786374, "phrase": "java"}, {"score": 0.002148677187261496, "phrase": "current_applications"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Aspect-oriented programming", " Meta-programming", " Infinite regression", " Execution levels"], "paper_abstract": "In aspect-oriented programming (AOP) languages, advice evaluation is usually considered as part of the base program evaluation. This is also the case for certain pointcuts, such as if pointcuts in AspectJ, or simply all pointcuts in higher-order aspect languages like AspectScheme. While viewing aspects as part of base level computation clearly distinguishes AOP from reflection, it also comes at a price: because aspects observe base level computation, evaluating pointcuts and advice at the base level can trigger infinite regression. To avoid these pitfalls, aspect languages propose ad-hoc mechanisms, which increase the complexity for programmers while being insufficient in many cases. After shedding light on the many facets of the issue, this paper proposes to clarify the situation by introducing levels of execution in the programming language, thereby allowing aspects to observe and run at specific, possibly different, levels. We adopt a defensive default that avoids infinite regression, and gives advanced programmers the means to override this default using level-shifting operators. We then study execution levels both in practice and in theory. First, we study the relevance of the issues addressed by execution levels in existing aspect-oriented programs. We then formalize the semantics of execution levels and prove that the default semantics is indeed free of a certain form of infinite regression, which we call aspect loops. Finally, we report on existing implementations of execution levels for aspect-oriented extensions of Scheme, JavaScript and Java, discussing their implementation techniques and current applications. (C) 2013 Elsevier B.V. All rights reserved.", "paper_title": "Execution levels for aspect-oriented programming: Design, semantics, implementations and applications", "paper_id": "WOS:000329887100005"}