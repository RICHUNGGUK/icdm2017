{"auto_keywords": [{"score": 0.04095500111954475, "phrase": "gta_algorithm"}, {"score": 0.011817534943758019, "phrase": "large_data"}, {"score": 0.00481495049065317, "phrase": "generate-test-aggregate"}, {"score": 0.004740197030914445, "phrase": "systematic_parallel_programming"}, {"score": 0.004522796947899013, "phrase": "combinatorial_problems"}, {"score": 0.004328856052035968, "phrase": "invalid_ones"}, {"score": 0.0042350135188564285, "phrase": "final_result"}, {"score": 0.003953068310598579, "phrase": "algorithm_design"}, {"score": 0.0037130155038449554, "phrase": "exponential-cost_computation"}, {"score": 0.0032858981413454802, "phrase": "mapreduce_program"}, {"score": 0.0030192479661007303, "phrase": "important_and_challenge_problem"}, {"score": 0.002962986184540317, "phrase": "gta_program_transformations"}, {"score": 0.0028268629720802772, "phrase": "practical_gta_library"}, {"score": 0.0027828888187069636, "phrase": "functional_language"}, {"score": 0.00277418382621194, "phrase": "scala"}, {"score": 0.0027310193758440376, "phrase": "systematic_parallel_programming_approach"}, {"score": 0.0027139447110929586, "phrase": "big-data_analysis"}, {"score": 0.0026970086220487926, "phrase": "mapreduce"}, {"score": 0.0026467041118198977, "phrase": "simple_functional_style_programming_interface"}, {"score": 0.002548945980967458, "phrase": "parallel_programs"}, {"score": 0.002525074485615743, "phrase": "sequential_manner"}, {"score": 0.002431797888365548, "phrase": "generated_mapreduce_programs"}, {"score": 0.0023789822182914877, "phrase": "parallel_programming"}, {"score": 0.002262518422441041, "phrase": "interesting_problems"}, {"score": 0.002105002791163301, "phrase": "elsevier"}], "paper_keywords": ["High-level parallel programming", " Generate-Test-Aggregate algorithm", " Program transformation", " Program calculation", " MapReduce", " Functional programming"], "paper_abstract": "The Generate-Test-Aggregate (GTA for short) algorithm is modeled following a simple and straightforward programming pattern, for combinatorial problems. First, generate all candidates; second, test and filter out invalid ones; finally, aggregate valid ones to make the final result. These three processing steps can be specified by three building blocks namely, generator, tester, and aggregator. Despite the simplicity of algorithm design, implementing the GTA algorithm naively following the three processing steps, i.e., brute-force, will result in an exponential-cost computation, and thus it is impractical for processing large data. The theory of GTA illustrates that if the definitions of generator, tester, and aggregator satisfy certain conditions, an efficient (usually near-linear cost) MapReduce program can be automatically derived from the GTA algorithm. The principle of GTA is attractive but how to make it being practically useful, remains as an important and challenge problem due to the complexity of GTA program transformations. In this paper, we report on our studying and implementation of a practical GTA library (written in the functional language Scala) which provides a systematic parallel programming approach for big-data analysis with MapReduce. The library provides a simple functional style programming interface and hides all the internal transformations. With this library, users can write parallel programs in a sequential manner in terms of the GTA algorithm, and the efficiency of the generated MapReduce programs is guaranteed systematically. Therefore, parallel programming for many problems could become no more a tough job. We demonstrate the usefulness of our GTA library on some interesting problems involving large data and show that lots of applications can be easily and efficiently solved by using our library. (C) 2013 Elsevier By. All rights reserved.", "paper_title": "A Generate-Test-Aggregate parallel programming library for systematic parallel programming", "paper_id": "WOS:000332751900007"}