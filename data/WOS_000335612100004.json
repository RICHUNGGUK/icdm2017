{"auto_keywords": [{"score": 0.048304899972243916, "phrase": "page_mapping"}, {"score": 0.015589848469957947, "phrase": "flash_memory_devices"}, {"score": 0.00481495049065317, "phrase": "flash_storage_devices"}, {"score": 0.004695303774351139, "phrase": "traditional_address_mapping_schemes"}, {"score": 0.004597861947580946, "phrase": "block_mapping"}, {"score": 0.004317450843594688, "phrase": "hybrid_mapping"}, {"score": 0.00422781730455246, "phrase": "block_boundaries"}, {"score": 0.0038227112550093863, "phrase": "novel_mapping_schemes"}, {"score": 0.003712011863784581, "phrase": "existing_mapping_strategies"}, {"score": 0.003634901808509402, "phrase": "new_schemes"}, {"score": 0.003619672388007568, "phrase": "virtual_extent"}, {"score": 0.0035743661303413907, "phrase": "vet"}, {"score": 0.0031912018800904314, "phrase": "basic_mapping_units"}, {"score": 0.0030343239259424497, "phrase": "individual_addresses"}, {"score": 0.0029463874016490976, "phrase": "mapping_information"}, {"score": 0.0027548146060608902, "phrase": "memory_consumption"}, {"score": 0.0026193328696791306, "phrase": "traditional_mapping_schemes"}, {"score": 0.0025221012517852907, "phrase": "increasing_address_spaces"}, {"score": 0.002500987934534128, "phrase": "synthetic_workloads"}, {"score": 0.0024489727828322693, "phrase": "asymptotic_mapping_cost"}, {"score": 0.002318728604587962, "phrase": "page_mapping_scheme"}, {"score": 0.002270495425498003, "phrase": "increased_overhead"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Flash memory", " I/O request", " Extent mapping", " Canonical extent"], "paper_abstract": "Flash memory devices commonly rely upon traditional address mapping schemes such as page mapping, block mapping or a hybrid of the two. Page mapping is more flexible than block or hybrid mapping without being restricted by block boundaries. However, its mapping table tends to grow large quickly as the capacity of flash memory devices does. To overcome this limitation, we propose novel mapping schemes that are fundamentally different from the existing mapping strategies. We call these new schemes Virtual Extent Trie (VET) and Extent Mapping Tree (EMT), as they manage mapping information by treating each 110 request as an extent and by using extents as basic mapping units rather than pages or blocks. By storing extents instead of individual addresses, our extent mapping schemes consume much less memory to store mapping information and still remain as flexible as page mapping. We observed in our experiments that our schemes reduced memory consumption by up to an order of magnitude in comparison with the traditional mapping schemes for several real world workloads. Our extent mapping schemes also scaled well with increasing address spaces by synthetic workloads. Even though the asymptotic mapping cost of VET and EMT is higher than the O(1) time of a page mapping scheme, the amount of increased overhead was almost negligible or low enough to be hidden by an accompanying I/O operation. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Memory efficient and scalable address mapping for flash storage devices", "paper_id": "WOS:000335612100004"}