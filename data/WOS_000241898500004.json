{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "zeno-timelocks"}, {"score": 0.049059435817091136, "phrase": "timed_automata"}, {"score": 0.03948473373922519, "phrase": "strongly_non-zeno"}, {"score": 0.035766971834428035, "phrase": "sufficient-and-necessary_condition"}, {"score": 0.026530664470825603, "phrase": "unsafe_loops"}, {"score": 0.004737829884207618, "phrase": "formal_verification"}, {"score": 0.004441449270168749, "phrase": "timelock-free_models"}, {"score": 0.00437028472643795, "phrase": "tripakis"}, {"score": 0.004335129332699343, "phrase": "syntactic_check"}, {"score": 0.003924017234842341, "phrase": "snz"}, {"score": 0.003648747692496864, "phrase": "strong_non-zenoness"}, {"score": 0.003542195914738294, "phrase": "non-zeno_specifications"}, {"score": 0.0034480238286659073, "phrase": "tctl_formula"}, {"score": 0.003284757805760914, "phrase": "demanding_model-checking_algorithm"}, {"score": 0.003078994644402931, "phrase": "alternative_solutions"}, {"score": 0.003013303396020895, "phrase": "compositional_application"}, {"score": 0.0027791677186501623, "phrase": "new_syntactic"}, {"score": 0.002640358015455532, "phrase": "simple_form"}, {"score": 0.002626154851822891, "phrase": "reachability_analysis"}, {"score": 0.0023895799632294586, "phrase": "syntactic_checks"}, {"score": 0.002376722584437227, "phrase": "uppaal_models"}, {"score": 0.002245819278872486, "phrase": "uppaal"}, {"score": 0.0022217110026330066, "phrase": "product_automaton"}, {"score": 0.0021393542556570706, "phrase": "modified_version"}, {"score": 0.0021221066364072766, "phrase": "carrier_sense"}, {"score": 0.0021163883202110034, "phrase": "multiple_access"}, {"score": 0.0021049977753042253, "phrase": "collision_detection_protocol"}], "paper_keywords": ["timed automata", " zeno-timelocks", " model checking", " non-zenoness conditions"], "paper_abstract": "Zeno-timelocks constitute a challenge for the formal verification of timed automata: they are difficult to detect, and the verification of most properties (e.g., safety) is only correct for timelock-free models. Some time ago, Tripakis proposed a syntactic check on the structure of timed automata: if a certain condition (called strong non-zenoness' SNZ) is met by all the loops in a given automaton, then zeno-timelocks are guaranteed not to occur. Checking for SNZ is efficient, and compositional (if all components in a network of automata are strongly non-zeno, then the network is free from zeno-timelocks). Strong non-zenoness, however, is sufficient-only: There exist non-zeno specifications which are not strongly non-zeno. A TCTL formula is known that represents a sufficient-and-necessary condition for non-zenoness; unfortunately, this formula requires a demanding model-checking algorithm, and not all model-checkers are able to express it. In addition, this algorithm provides only limited diagnostic information. Here we propose a number of alternative solutions. First, we show that the compositional application of SNZ can be weakened: some networks can be guaranteed to be free from Zeno-timelocks, even if not every component is strongly non-zeno. Secondly, we present new syntactic, sufficient-only conditions that complement SNZ. Finally, we describe a sufficient-and-necessary condition that only requires a simple form of reachability analysis. Furthermore, our conditions identify the cause of zeno-timelocks directly on the model, in the form of unsafe loops. We also comment on a tool that we have developed, which implements the syntactic checks on Uppaal models. The tool is also able to derive, from those unsafe loops in a given automaton (in general, an Uppaal model representing a product automaton of a given network), the reachability formulas that characterise the occurrence of zeno-timelocks. A modified version of the carrier sense multiple access with collision detection protocol is used as a case-study.", "paper_title": "How to stop time stopping", "paper_id": "WOS:000241898500004"}