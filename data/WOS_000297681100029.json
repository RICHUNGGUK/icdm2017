{"auto_keywords": [{"score": 0.0458078008187391, "phrase": "explicit_object-to-image_space_mapping"}, {"score": 0.00481495049065317, "phrase": "efficient_micropolygon_ray"}, {"score": 0.004638788604042707, "phrase": "shading_reuse_method"}, {"score": 0.004581505405526037, "phrase": "micropolygon_ray_tracing"}, {"score": 0.0044968982227349625, "phrase": "previous_shading_reuse_methods"}, {"score": 0.004071249707923223, "phrase": "density_control"}, {"score": 0.00402094658848301, "phrase": "actual_shading_reuse"}, {"score": 0.003971262520692664, "phrase": "different_spaces"}, {"score": 0.0039221899471111, "phrase": "uncorrelated_criterions"}, {"score": 0.0037551444630619015, "phrase": "shading_points"}, {"score": 0.003662892058072211, "phrase": "user-controlled_number"}, {"score": 0.003528730431045574, "phrase": "image_space"}, {"score": 0.0034420211080526094, "phrase": "evaluated_shading_values"}, {"score": 0.0032749212355657215, "phrase": "nearest_neighbor_searches"}, {"score": 0.003234425353582135, "phrase": "shading_samples"}, {"score": 0.0031549249117721946, "phrase": "separate_layers"}, {"score": 0.0030582832134483685, "phrase": "ray_paths"}, {"score": 0.0030017207229983385, "phrase": "spurious_reuse"}, {"score": 0.0026835920552084514, "phrase": "ray_tracing_effects"}, {"score": 0.002444333100610621, "phrase": "highly_parallel_implementation"}, {"score": 0.0023991392756507386, "phrase": "gpu."}, {"score": 0.002340081450249521, "phrase": "state-of-the-art_micropolygon_ray_tracing_algorithm"}, {"score": 0.002212535878761148, "phrase": "required_shading_evaluations"}, {"score": 0.0021049977753042253, "phrase": "significant_performance_gains"}], "paper_keywords": ["micropolygon", " GPU", " Reyes", " ray tracing"], "paper_abstract": "We present a shading reuse method for micropolygon ray tracing. Unlike previous shading reuse methods that require an explicit object-to-image space mapping for shading density estimation or shading accuracy, our method performs shading density control and actual shading reuse in different spaces with uncorrelated criterions. Specifically, we generate the shading points by shooting a user-controlled number of shading rays from the image space, while the evaluated shading values are assigned to antialiasing samples through object-space nearest neighbor searches. Shading samples are generated in separate layers corresponding to first bounce ray paths to reduce spurious reuse from very different ray paths. This method eliminates the necessity of an explicit object-to-image space mapping, enabling the elegant handling of ray tracing effects such as reflection and refraction. The overhead of our shading reuse operations is minimized by a highly parallel implementation on the GPU. Compared to the state-of-the-art micropolygon ray tracing algorithm, our method is able to reduce the required shading evaluations by an order of magnitude and achieve significant performance gains.", "paper_title": "A Shading Reuse Method for Efficient Micropolygon Ray Tracing", "paper_id": "WOS:000297681100029"}