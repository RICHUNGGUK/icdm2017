{"auto_keywords": [{"score": 0.046081391722127725, "phrase": "zero_initialization"}, {"score": 0.015585084079454931, "phrase": "memory_safety"}, {"score": 0.012619409476522231, "phrase": "indirect_costs"}, {"score": 0.0047113960612140335, "phrase": "inadvertent_and_malicious_misuse"}, {"score": 0.004590052784169268, "phrase": "program_correctness"}, {"score": 0.004491313367627919, "phrase": "critical_element"}, {"score": 0.004356620736507642, "phrase": "direct_cost"}, {"score": 0.004135010810625326, "phrase": "average_costs"}, {"score": 0.003993544228876303, "phrase": "high_performance_virtual_machine"}, {"score": 0.003773870856027139, "phrase": "cache_displacement_effects"}, {"score": 0.003613119346373748, "phrase": "direct_costs"}, {"score": 0.0035507457285983268, "phrase": "large_blocks"}, {"score": 0.003384695931421288, "phrase": "allocation_sequence"}, {"score": 0.0033262524445013303, "phrase": "cache_displacement"}, {"score": 0.003170667618004276, "phrase": "zero_initialization_designs"}, {"score": 0.0030888830649190282, "phrase": "different_tradeoffs"}, {"score": 0.002629026692001082, "phrase": "parallel_hardware"}, {"score": 0.0025611773887867255, "phrase": "application's_critical_path"}, {"score": 0.0023270035715132866, "phrase": "available_hardware_parallelism"}, {"score": 0.0022967713922705, "phrase": "new_software_strategies"}, {"score": 0.0022277448907881306, "phrase": "direct_overhead"}, {"score": 0.0021987994275190314, "phrase": "total_performance"}, {"score": 0.002123433075137768, "phrase": "additional_optimizations"}, {"score": 0.0021049977753042253, "phrase": "microarchitectural_support"}], "paper_keywords": ["Performance", " Measurement", " Memory safety", " Zero initialization"], "paper_abstract": "Memory safety defends against inadvertent and malicious misuse of memory that may compromise program correctness and security. A critical element of memory safety is zero initialization. The direct cost of zero initialization is surprisingly high: up to 12.7%, with average costs ranging from 2.7 to 4.5% on a high performance virtual machine on IA32 architectures. Zero initialization also incurs indirect costs due to its memory bandwidth demands and cache displacement effects. Existing virtual machines either: a) minimize direct costs by zeroing in large blocks, or b) minimize indirect costs by zeroing in the allocation sequence, which reduces cache displacement and bandwidth. This paper evaluates the two widely used zero initialization designs, showing that they make different tradeoffs to achieve very similar performance. Our analysis inspires three better designs: (1) bulk zeroing with cache-bypassing (non-temporal) instructions to reduce the direct and indirect zeroing costs simultaneously, (2) concurrent non-temporal bulk zeroing that exploits parallel hardware to move work off the application's critical path, and (3) adaptive zeroing, which dynamically chooses between (1) and (2) based on available hardware parallelism. The new software strategies offer speedups sometimes greater than the direct overhead, improving total performance by 3% on average. Our findings invite additional optimizations and microarchitectural support.", "paper_title": "Why Nothing Matters: The Impact of Zeroing", "paper_id": "WOS:000298294500020"}