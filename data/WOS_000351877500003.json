{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "feature_implementations"}, {"score": 0.049593242225692294, "phrase": "source_code_elements"}, {"score": 0.04586846484671967, "phrase": "software_variants"}, {"score": 0.00457553517865013, "phrase": "revpline_approach"}, {"score": 0.004152818376630929, "phrase": "specific_requirements"}, {"score": 0.0040481944502103505, "phrase": "existing_software_variants"}, {"score": 0.003986684503518077, "phrase": "software_product_line"}, {"score": 0.003866443402315402, "phrase": "feature_model"}, {"score": 0.0036928221419965253, "phrase": "first_step"}, {"score": 0.003438058620195309, "phrase": "optional_and_mandatory_features"}, {"score": 0.003010496595090984, "phrase": "complementary_approach"}, {"score": 0.00290473242917264, "phrase": "mined_feature_implementations"}, {"score": 0.0026630475331025955, "phrase": "use-case_diagrams"}, {"score": 0.002416589459425828, "phrase": "feature_implementation"}, {"score": 0.002392008392892289, "phrase": "use-case_levels"}, {"score": 0.0023435920614377306, "phrase": "information_retrieval_methods"}, {"score": 0.0023079225317714815, "phrase": "efficient_way"}, {"score": 0.0021705796895687864, "phrase": "argouml-spl"}, {"score": 0.0021049977753042253, "phrase": "promising_results"}], "paper_keywords": ["Software variants", " Software Product Line", " feature documentation", " code comprehension", " Formal Concept Analysis", " Relational Concept Analysis", " use-case diagram", " Latent Semantic Indexing", " Feature Models"], "paper_abstract": "Companies often develop a set of software variants that share some features and differ in others to meet specific requirements. To exploit the existing software variants as a Software Product Line (SPL), a Feature Model of this SPL must be built as a first step. To do so, it is necessary to define and document the optional and mandatory features that compose the variants. In our previous work, we mined a set of feature implementations as identified sets of source code elements. In this paper, we propose a complementary approach, which aims to document the mined feature implementations by giving them names and descriptions, based on the source code elements that form feature implementations and the use-case diagrams that specify software variants. The novelty of our approach is its use of commonality and variability across software variants, at feature implementation and use-case levels, to run Information Retrieval methods in an efficient way. Experiments on several real case studies (Mobile media and ArgoUML-SPL) validate our approach and show promising results.", "paper_title": "Automatic Documentation of [Mined] Feature Implementations from Source Code Elements and Use-Case Diagrams with the REVPLINE Approach", "paper_id": "WOS:000351877500003"}