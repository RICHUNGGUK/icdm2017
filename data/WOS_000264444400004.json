{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "constraint-directed_search"}, {"score": 0.004676575291629554, "phrase": "constraint-based_local_search"}, {"score": 0.0037392451233558234, "phrase": "new_ideas"}, {"score": 0.0028471655497661528, "phrase": "specialised_algorithms"}, {"score": 0.0027922467043592597, "phrase": "common_constraints"}, {"score": 0.0024842242921857705, "phrase": "general_algorithm"}, {"score": 0.0022536005664642294, "phrase": "monadic_existential_second-order_logic"}, {"score": 0.0021049977753042253, "phrase": "common_constraint-directed_local_search_algorithms"}], "paper_keywords": ["Constraint-based local search", " Constraint-directed search", " Monadic existential second-order logic"], "paper_abstract": "In constraint-based local search the solutions are described declaratively by a conjunction of (often high-level) constraints. In this article we show that this opens up new ideas for constraint-directed search. For a constraint we introduce three neighbourhoods, where the penalty for that constraint alone is decreasing, increasing, or unchanged. We give specialised algorithms for common constraints that efficiently implement these neighbourhoods. Further, we give a general algorithm that implements these neighbourhoods from specifications of constraints in monadic existential second-order logic. Finally, we show how common constraint-directed local search algorithms are often easier to express using these neighbourhoods. (C) 2008 Elsevier Inc. All rights reserved.", "paper_title": "Revisiting constraint-directed search", "paper_id": "WOS:000264444400004"}