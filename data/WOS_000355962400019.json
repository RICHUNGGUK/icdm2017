{"auto_keywords": [{"score": 0.048296005549671464, "phrase": "flash_memory"}, {"score": 0.03620728805533268, "phrase": "dirty_pages"}, {"score": 0.00481495049065317, "phrase": "flash-based_b"}, {"score": 0.004539005582217309, "phrase": "fast_access"}, {"score": 0.004481954307639453, "phrase": "low_power_consumption"}, {"score": 0.0043150485532080065, "phrase": "out-of-place_updates"}, {"score": 0.004154332348800334, "phrase": "limited_number"}, {"score": 0.003982741546775355, "phrase": "existing_system_designs"}, {"score": 0.0038343546245999285, "phrase": "buffer_replacement_policy"}, {"score": 0.003802135020791801, "phrase": "flash-based_systems"}, {"score": 0.0033641551050434663, "phrase": "recent_studies"}, {"score": 0.003335873298309004, "phrase": "buffer_designs"}, {"score": 0.003266201217790818, "phrase": "clean-first_lru_strategy"}, {"score": 0.0032250961348210473, "phrase": "clean_pages"}, {"score": 0.002889778121878728, "phrase": "different_effect"}, {"score": 0.0027469703311742647, "phrase": "lazy-split_lru-based_buffer_management_scheme"}, {"score": 0.0025458479274370832, "phrase": "different_dirty_pages"}, {"score": 0.002450864311898833, "phrase": "intensive_overwrites"}, {"score": 0.0023794391656001466, "phrase": "semi-clean_state"}, {"score": 0.0023100907305651872, "phrase": "clean_part"}, {"score": 0.0022906498741695094, "phrase": "dirty_part"}, {"score": 0.0021866066626507028, "phrase": "experimental_results"}, {"score": 0.0021228663458966813, "phrase": "pure_lru"}, {"score": 0.0021049977753042253, "phrase": "cfdc"}], "paper_keywords": ["buffer management", " B+-tree", " flash memory", " replacement policy", " split policy"], "paper_abstract": "Most embedded systems are equipped with flash memory owing to its shock resistance, fast access, and low power consumption. However, some of its distinguishing characteristics, including out-of-place updates, an asymmetric read/write/erase speed, and a limited number of write/erase cycles, make it necessary to reconsider the existing system designs to explore its performance potential. For example, the buffer replacement policy of flash-based systems should not only consider the cache hit ratio, but also the relative heavy write and erase costs that are caused by flushing dirty pages. Most of the recent studies on buffer designs have focused on a Clean-First LRU strategy that evicts clean pages preferentially to reduce the number of writes to flash memory. However, each of them fails to distinguish dirty pages, which may have a different effect on the flash memory. In this paper, we propose a Lazy-Split LRU-based buffer management scheme that not only considers an imbalance of the read and write speeds but also different effects of different dirty pages and frequent changes of the B+-tree index structure caused by intensive overwrites. Specifically, it introduces a semi-clean state to further classify some dirty pages into clean part and dirty part and several efficient replacement policies to reduce the number of B+-tree splits. The experimental results show that our solution outperforms other algorithms including pure LRU and CFDC, and is effective and efficient for improving the performance of B+-tree on flash memory.", "paper_title": "LS-LRU: A Lazy-Split LRU Buffer Replacement Policy for Flash-Based B plus -tree Index", "paper_id": "WOS:000355962400019"}