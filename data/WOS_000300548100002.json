{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "interleaved_bugs"}, {"score": 0.010240040083641513, "phrase": "precise_harness"}, {"score": 0.004776669953449352, "phrase": "static_assertion_checking"}, {"score": 0.0047386923107107645, "phrase": "open_programs"}, {"score": 0.004571478018964363, "phrase": "environment_assumptions"}, {"score": 0.004392565073466714, "phrase": "file_handle"}, {"score": 0.004039221742250308, "phrase": "appropriate_preconditions"}, {"score": 0.0038043055953253047, "phrase": "even_the_most_precise_automated_static_checkers"}, {"score": 0.003729065012001506, "phrase": "numerous_false_alarms"}, {"score": 0.002852931066197755, "phrase": "interleaved_bug"}, {"score": 0.002752075650871066, "phrase": "nosequential_interleaving"}, {"score": 0.0026022112631368223, "phrase": "static_analysis"}, {"score": 0.002530359917257626, "phrase": "false_positives"}, {"score": 0.0025101968585850474, "phrase": "static_concurrency_analysis"}, {"score": 0.0024506642262508735, "phrase": "imprecise_harness"}, {"score": 0.002382987346529592, "phrase": "differential_analysis"}, {"score": 0.0023545567809591804, "phrase": "original_program"}, {"score": 0.0021304214257321, "phrase": "precise_harnesses"}, {"score": 0.0021049977753042253, "phrase": "real-life_concurrent_programs"}], "paper_keywords": ["Concurrency verification", " differential analysis", " static analysis", " false alarms"], "paper_abstract": "Static assertion checking of open programs requires setting up a precise harness to capture the environment assumptions. For instance, a library may require a file handle to be properly initialized before it is passed into it. A harness is used to setup or specify the appropriate preconditions before invoking methods from the program. In the absence of a precise harness, even the most precise automated static checkers are bound to report numerous false alarms.This often limits the adoption of static assertion checking in the hands of a user. In this work, we explore the possibility of automatically filtering away (or prioritizing) warnings that result from imprecision in the harness. We limit our attention to the scenario when one is interested in finding bugs due to concurrency. We define a warning to be an interleaved bug when it manifests on an input for which nosequential interleaving produces a warning. As we argue in the paper, limiting a static analysis to only consider interleaved bugs greatly reduces false positives during static concurrency analysis in the presence of an imprecise harness. We formalize interleaved bugs as a differential analysis between the original program and its sequential version and provide various techniques for finding them. Our implementation CBUGS demonstrates that the scheme of finding interleaved bugs can alleviate the need to construct precise harnesses while checking real-life concurrent programs.", "paper_title": "Underspecified Harnesses and Interleaved Bugs", "paper_id": "WOS:000300548100002"}