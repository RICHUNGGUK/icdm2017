{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "correct_compilers"}, {"score": 0.004505638402009237, "phrase": "new_approach"}, {"score": 0.004063348730077936, "phrase": "simple_but_general_technique"}, {"score": 0.003830312347175889, "phrase": "high-level_semantics"}, {"score": 0.0033288399506044763, "phrase": "calculation_process"}, {"score": 0.0031146967095233586, "phrase": "standard_equational_reasoning_techniques"}, {"score": 0.0028715299874549245, "phrase": "wide_range"}, {"score": 0.0028293966058473476, "phrase": "language_features"}, {"score": 0.002726740692380339, "phrase": "arithmetic_expressions"}, {"score": 0.002570162055835289, "phrase": "lambda_calculi"}, {"score": 0.002495268931035983, "phrase": "unbounded_loops"}, {"score": 0.0022005118194652704, "phrase": "coq_proof_assistant"}, {"score": 0.0021049977753042253, "phrase": "convenient_interactive_tool"}], "paper_keywords": [""], "paper_abstract": "In this article, we present a new approach to the problem of calculating compilers. In particular, we develop a simple but general technique that allows us to derive correct compilers from high-level semantics by systematic calculation, with all details of the implementation of the compilers falling naturally out of the calculation process. Our approach is based upon the use of standard equational reasoning techniques, and has been applied to calculate compilers for a wide range of language features and their combination, including arithmetic expressions, exceptions, state, various forms of lambda calculi, bounded and unbounded loops, non-determinism and interrupts. All the calculations in the article have been formalised using the Coq proof assistant, which serves as a convenient interactive tool for developing and verifying the calculations.", "paper_title": "Calculating correct compilers", "paper_id": "WOS:000368240300007"}