{"auto_keywords": [{"score": 0.04479194592539347, "phrase": "cpu_capability"}, {"score": 0.00481495049065317, "phrase": "parallel_applications"}, {"score": 0.0047820521205253035, "phrase": "single-isa_multi-core_systems"}, {"score": 0.004589307360976108, "phrase": "multi-core_systems"}, {"score": 0.003919459003028067, "phrase": "new_asymmetric_hardware"}, {"score": 0.0038793218280304825, "phrase": "dynamic_capability_asymmetry"}, {"score": 0.003826441783705964, "phrase": "operating_system"}, {"score": 0.0035849042994947366, "phrase": "os_scheduler"}, {"score": 0.0033701115914053083, "phrase": "user-level_load_balancer"}, {"score": 0.003114219280081737, "phrase": "entire_cpu_capability"}, {"score": 0.003019444345150991, "phrase": "existing_kernel-level_load_balancer"}, {"score": 0.002947723206640026, "phrase": "kernel_balancer"}, {"score": 0.0029175079344240227, "phrase": "capability_balancer"}, {"score": 0.002809336972473929, "phrase": "real_workloads"}, {"score": 0.0027805362553564336, "phrase": "nas_parallel_benchmark"}, {"score": 0.002649978056195926, "phrase": "dynamic_and_static_asymmetries"}, {"score": 0.0025429488129788077, "phrase": "dynamic_asymmetry"}, {"score": 0.002508239347479441, "phrase": "static_asymmetry"}, {"score": 0.002482517733720377, "phrase": "competitive_environment"}, {"score": 0.002278152865899792, "phrase": "cache_policy"}, {"score": 0.0022163699144426155, "phrase": "overall_execution_time"}, {"score": 0.0021562588804528667, "phrase": "overall_cache"}, {"score": 0.0021049977753042253, "phrase": "fifo_policy"}], "paper_keywords": ["Scheduler", " Load balancing", " Capability asymmetry", " OS noise", " Multi-core"], "paper_abstract": "Contemporary operating systems for single-ISA (instruction set architecture) multi-core systems attempt to distribute tasks equally among all the CPUs. This approach works relatively well when there is no difference in CPU capability. However, there are cases in which CPU capability differs from one another. For instance, static capability asymmetry results from the advent of new asymmetric hardware, and dynamic capability asymmetry comes from the operating system (OS) outside noise caused from networking or I/O handling. These asymmetries can make it hard for the OS scheduler to evenly distribute the tasks, resulting in less efficient load balancing. In this paper, we propose a user-level load balancer for parallel applications, called the' capability balancer', which recognizes the difference of CPU capability and makes subtasks share the entire CPU capability fairly. The balancer can coexist with the existing kernel-level load balancer without detrimenting the behavior of the kernel balancer. The capability balancer can fairly distribute CPU capability to tasks with very little overhead. For real workloads like the NAS Parallel Benchmark (NPB), we have accomplished speedups of up to 9.8% and 8.5% in dynamic and static asymmetries, respectively. We have also experienced speedups of 13.3% for dynamic asymmetry and 24.1% for static asymmetry in a competitive environment. The impacts of our task selection policies, FIFO (first in, first out) and cache, were compared. The use of the cache policy led to a speedup of 5.3% in overall execution time and a decrease of 4.7% in the overall cache miss count, compared with the FIFO policy, which is used by default.", "paper_title": "Asymmetry-aware load balancing for parallel applications in single-ISA multi-core systems", "paper_id": "WOS:000304694300002"}