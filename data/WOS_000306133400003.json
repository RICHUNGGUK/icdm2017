{"auto_keywords": [{"score": 0.04979001683121731, "phrase": "dynamic_slicing"}, {"score": 0.0075165971476256555, "phrase": "efficient_computation"}, {"score": 0.007448852478382954, "phrase": "ddg"}, {"score": 0.005744647840459238, "phrase": "execution_history"}, {"score": 0.00481495049065317, "phrase": "online_tracing"}, {"score": 0.004714023408114857, "phrase": "promising_trace"}, {"score": 0.004477595431209663, "phrase": "failed_run"}, {"score": 0.004410331572207815, "phrase": "dynamic_dependence_graph"}, {"score": 0.004317848984770719, "phrase": "particular_run"}, {"score": 0.00418907090251818, "phrase": "debugging_technique"}, {"score": 0.004039576329942698, "phrase": "dynamic_slice"}, {"score": 0.003990935112773993, "phrase": "ddg."}, {"score": 0.0038953958723049287, "phrase": "efficient_debugger"}, {"score": 0.0036553070575015344, "phrase": "computed_ddg"}, {"score": 0.003578600071301459, "phrase": "program_slowdown"}, {"score": 0.003546218640291191, "phrase": "online_computation"}, {"score": 0.0034717929086014636, "phrase": "design_decision"}, {"score": 0.0034195866335851935, "phrase": "computed_dependencies"}, {"score": 0.003287482882222731, "phrase": "specially_allocated_fixed_size_circular_buffer"}, {"score": 0.002929792688461903, "phrase": "generated_dependencies"}, {"score": 0.0027490536097875685, "phrase": "cpu-intensive_programs"}, {"score": 0.002675039053570178, "phrase": "trace_rate"}, {"score": 0.0026268035120419536, "phrase": "executed_instruction"}, {"score": 0.0025638362414466278, "phrase": "dependence_trace_history"}, {"score": 0.0022571426190350157, "phrase": "online_tracing_step"}, {"score": 0.002236691727668501, "phrase": "recently_proposed_architectural_support"}, {"score": 0.002169848044716866, "phrase": "multithreaded_programs"}, {"score": 0.0021501863832966966, "phrase": "multicore_processors"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["dynamic slicing", " debugger", " dynamic dependence graph", " tracing"], "paper_abstract": "Dynamic slicing is a promising trace based technique that helps programmers in the process of debugging. In order to debug a failed run, dynamic slicing requires the dynamic dependence graph (DDG) information for that particular run. The two major challenges involved in utilizing dynamic slicing as a debugging technique are the efficient computation of the DDG and the efficient computation of the dynamic slice, given the DDG. In this paper, we present an efficient debugger, which first computes the DDG efficiently while the program is executing; dynamic slicing is later performed efficiently on the computed DDG, on demand. To minimize program slowdown during the online computation of DDG, we make the design decision of not outputting the computed dependencies to a file, instead, storing them in memory in a specially allocated fixed size circular buffer. The size of the buffer limits the length of the execution history that can be stored. To maximize the execution history that can be maintained, we introduce optimizations to eliminate the storage of most of the generated dependencies, at the same time ensuring that those that are stored are sufficient to capture the bug. Experiments conducted on CPU-intensive programs show that our optimizations are able to reduce the trace rate from 16 to 0.8?bytes per executed instruction. This enables us to store the dependence trace history for a window of 20 million executed instructions in a 16-MB buffer. Our debugger is also very efficient, yielding slicing times of around a second, and only slowing down the execution of the program by a factor of 19 during the online tracing step. Using recently proposed architectural support for monitoring, we are also able to handle multithreaded programs running on multicore processors. Copyright (c) 2011 John Wiley & Sons, Ltd.", "paper_title": "A system for debugging via online tracing and dynamic slicing", "paper_id": "WOS:000306133400003"}