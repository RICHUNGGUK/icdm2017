{"auto_keywords": [{"score": 0.04984259146309732, "phrase": "flash_memory"}, {"score": 0.01353824859325388, "phrase": "prefix_sum_cube"}, {"score": 0.008713768692145006, "phrase": "olap_range_queries"}, {"score": 0.006018310961414513, "phrase": "in-place_updates"}, {"score": 0.0047322977318269765, "phrase": "efficient_ways"}, {"score": 0.004662577395989494, "phrase": "online_analytical_processing"}, {"score": 0.004582528208024817, "phrase": "particular_type"}, {"score": 0.004526189187835712, "phrase": "range_queries"}, {"score": 0.004492717291734985, "phrase": "aggregate_functions"}, {"score": 0.004437477842155451, "phrase": "avg."}, {"score": 0.004415571399902181, "phrase": "asymmetric_cost"}, {"score": 0.004329018365016614, "phrase": "higher_importance"}, {"score": 0.004244154690664235, "phrase": "flash_memory_environment"}, {"score": 0.004212759658511567, "phrase": "popular_data_structure"}, {"score": 0.004171259063201874, "phrase": "olap_range-sum_queries"}, {"score": 0.004089475312474684, "phrase": "range-sum_query"}, {"score": 0.004039173440038674, "phrase": "constant_time"}, {"score": 0.003844054013713442, "phrase": "chun_et_al"}, {"score": 0.003778004256546193, "phrase": "range-sum_queries"}, {"score": 0.0036583255551120276, "phrase": "san_francisco"}, {"score": 0.003533662113818541, "phrase": "morgan_kaufmann_publisher"}, {"score": 0.0034047882921717913, "phrase": "separate_r-tree"}, {"score": 0.0033379819706003885, "phrase": "hard_disk"}, {"score": 0.0031297538950335233, "phrase": "four-pronged_approach"}, {"score": 0.0029858260644202647, "phrase": "ram."}, {"score": 0.0029417581395045867, "phrase": "whole_trees"}, {"score": 0.0029272547177399038, "phrase": "ram"}, {"score": 0.002862648127577722, "phrase": "disk_resident_tree"}, {"score": 0.0027925723953701083, "phrase": "bounded_amounts"}, {"score": 0.0027513507830537165, "phrase": "lossy_compression"}, {"score": 0.002704025235449717, "phrase": "quadtree_index_structure"}, {"score": 0.0026378222146697648, "phrase": "quadtree_compression_problem"}, {"score": 0.0026250444996909865, "phrase": "np"}, {"score": 0.0025924443774713473, "phrase": "greedy_heuristic"}, {"score": 0.0025541693207036167, "phrase": "optimal_solutions"}, {"score": 0.0025415366388578465, "phrase": "polynomial_time"}, {"score": 0.0024916260764216752, "phrase": "proposed_algorithms"}, {"score": 0.0024731627211475823, "phrase": "existing_delta-tree"}, {"score": 0.0023418708663358895, "phrase": "customized_algorithms"}, {"score": 0.0022507751993132543, "phrase": "small_error"}, {"score": 0.0022175333584329177, "phrase": "accurate_solution"}, {"score": 0.002168586864007222, "phrase": "parameter_settings"}, {"score": 0.0021049977753042253, "phrase": "effective_trade-off"}], "paper_keywords": ["relational databases", " OLAP", " range queries", " flash memory"], "paper_abstract": "This paper explores efficient ways to use flash memory to store online analytical processing (OLAP) data. The particular type of queries considered are range queries using the aggregate functions SUM, COUNT and AVG. The asymmetric cost of reads and writes for flash memory gives higher importance to how updates are handled in a flash memory environment. A popular data structure used for answering OLAP range-sum queries is the prefix sum cube. It allows the range-sum query to be answered in constant time. However, updating the prefix sum cube is very expensive. To overcome this, the delta-tree was proposed by Chun et al. (Dynamic update cube for range-sum queries. Proc. Int. Conf. Very Large Data Bases, San Francisco, CA, USA, 2001, pp. 521-530. Morgan Kaufmann Publisher). The delta-tree stores all updates to the prefix sum cube in a separate r-tree. This approach worked well for the hard disk where in-place updates are relatively cheap. However, for flash memory where in-place updates are very expensive, the delta-tree performs very poorly. We take a four-pronged approach to overcome the problem of expensive in-place updates. The first is efficient caching of updates in RAM. The second is writing out whole trees from RAM to flash memory instead of incrementally updating a disk resident tree. The third is we allow users to trade bounded amounts of accuracy for less updates via lossy compression. Finally, we use a quadtree index structure instead of the R-tree. We prove that the quadtree compression problem is NP-complete. A greedy heuristic is proposed to find near optimal solutions in polynomial time. Various experiments were conducted to compare the proposed algorithms against the existing delta-tree. The results show that our algorithms consistently outperformed delta-tree by factors of between 10 and 100. This demonstrates the importance of designing flash memory customized algorithms for OLAP range queries. In addition, among our algorithms, the error bound solutions with a small error bound setting significantly outperform the accurate solution in terms of performance for a variety of parameter settings. This indicates that the error bound algorithms offer users an effective trade-off between execution time and accuracy.", "paper_title": "Efficient Updates for OLAP Range Queries on Flash Memory", "paper_id": "WOS:000296300500003"}