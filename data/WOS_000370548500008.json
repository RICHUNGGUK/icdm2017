{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "java"}, {"score": 0.038373284137546405, "phrase": "region_allocation"}, {"score": 0.004720606036240263, "phrase": "automatic_memory_management"}, {"score": 0.004582528208024817, "phrase": "garbage-collected_heap"}, {"score": 0.004212759658511567, "phrase": "significant_runtime_overhead"}, {"score": 0.004130165601475531, "phrase": "memory_footprint"}, {"score": 0.003989487818395848, "phrase": "hybrid_memory_management_scheme"}, {"score": 0.00393066798511457, "phrase": "region-based_memory_management"}, {"score": 0.003815607281455725, "phrase": "region_exits"}, {"score": 0.003778004256546193, "phrase": "static_program_analysis"}, {"score": 0.0037407704200033607, "phrase": "allocation_sites"}, {"score": 0.0035600143547053287, "phrase": "static_analysis"}, {"score": 0.0033379819706003885, "phrase": "region_exit"}, {"score": 0.0032887360307856635, "phrase": "regular_garbage-collected_heap"}, {"score": 0.003053159610975692, "phrase": "temporal_locality"}, {"score": 0.003023047748772801, "phrase": "object_allocation"}, {"score": 0.0029637093924781825, "phrase": "coarse-grain_source_code_annotations"}, {"score": 0.0028911669203979156, "phrase": "non-overlapping_lifetimes"}, {"score": 0.002806449337145999, "phrase": "different_memory_scopes"}, {"score": 0.0027787638791664663, "phrase": "regional-located_memory"}, {"score": 0.002724207384182295, "phrase": "garbage_collection"}, {"score": 0.0025289662786567896, "phrase": "region_allocation_technique"}, {"score": 0.002467038647952607, "phrase": "garbage_collector"}, {"score": 0.0023130151703068444, "phrase": "detailed_description"}, {"score": 0.0022452005651385095, "phrase": "experimental_results"}], "paper_keywords": ["Static program analysis", " region-based memory management", " garbage collection"], "paper_abstract": "Java uses automatic memory management, usually implemented as a garbage-collected heap. That lifts the burden of manually allocating and deallocating memory, but it can incur significant runtime overhead and increase the memory footprint of applications. We propose a hybrid memory management scheme that utilizes region-based memory management to deallocate objects automatically on region exits. Static program analysis detects allocation sites that are safe for region allocation, i.e., the static analysis proves that the objects allocated at such a site are not reachable after the region exit. A regular garbage-collected heap is used for objects that are not region allocatable. The region allocation exploits the temporal locality of object allocation. Our analysis uses coarse-grain source code annotations to disambiguate objects with non-overlapping lifetimes, and maps them to different memory scopes. Regional-located memory does not require garbage collection as the regions are simply deallocated when they go out of scope. The region allocation technique is backed by a garbage collector that manages memory that is not region allocated. We provide a detailed description of the analysis, provide experimental results showing that as much as 78% of the memory is region allocatable and discuss how our hybrid memory management system can be implemented efficiently with respect to both space and time.", "paper_title": "Safe and Efficient Hybrid Memory Management for Java", "paper_id": "WOS:000370548500008"}