{"auto_keywords": [{"score": 0.0500785296201053, "phrase": "subset-sum_problem"}, {"score": 0.028323570143780116, "phrase": "problem_sizes"}, {"score": 0.01222849153809717, "phrase": "gpu"}, {"score": 0.009972902807383601, "phrase": "small_problem_sizes"}, {"score": 0.0046797114400479135, "phrase": "well-known_np-complete_combinatorial_problem"}, {"score": 0.004613516457919661, "phrase": "pseudo-polynomial_time"}, {"score": 0.00447115003744675, "phrase": "input_objects"}, {"score": 0.004284037022875158, "phrase": "dynamic_programming_table"}, {"score": 0.003910552008800604, "phrase": "ibm"}, {"score": 0.0038114550483341766, "phrase": "nvidia"}, {"score": 0.0035796471115594553, "phrase": "cray_xmt"}, {"score": 0.003528957477793481, "phrase": "word-level_locking"}, {"score": 0.0033811403330431897, "phrase": "alternating_word_algorithm"}, {"score": 0.003333252253488408, "phrase": "efficient_solution"}, {"score": 0.003193606324727067, "phrase": "device_memory"}, {"score": 0.002906575389963227, "phrase": "medium-sized_problems"}, {"score": 0.0028490783932465288, "phrase": "poor_scalability"}, {"score": 0.0028087048250773766, "phrase": "processors_increases"}, {"score": 0.0027374647587075935, "phrase": "problem_size"}, {"score": 0.002592931959322531, "phrase": "large_problems"}, {"score": 0.002570817338292482, "phrase": "sustained_performance"}, {"score": 0.002548890846638283, "phrase": "problem_size_increases"}, {"score": 0.0024984517279573906, "phrase": "poor_scaling"}, {"score": 0.0022608057001451414, "phrase": "different_ranges"}, {"score": 0.0021971473452127126, "phrase": "varying_problem_sizes"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["Cray XMT", " dynamic programming", " IBM x3755", " multicore", " multithreading", " NVIDIA FX 5800", " OMP", " Opteron", " parallel algorithms", " parallel computing", " shared memory", " subset-sum problem"], "paper_abstract": "The subset-sum problem is a well-known NP-complete combinatorial problem that is solvable in pseudo-polynomial time, that is, time proportional to the number of input objects multiplied by the sum of their sizes. This product defines the size of the dynamic programming table used to solve the problem. We show how this problem can be parallelized on three contemporary architectures, that is, a 128-processor Cray Extreme Multithreading (XMT) massively multithreaded machine, a 16-processor IBM x3755 shared memory machine, and a 240-core NVIDIA FX 5800 graphics processing unit (GPU). We show that it is straightforward to parallelize this algorithm on the Cray XMT primarily because of the word-level locking that is available on this architecture. For the other two machines, we present an alternating word algorithm that can implement an efficient solution. Our results show that the GPU performs well for problems whose tables fit within the device memory. Because GPUs typically have memories in the order of 10GB, such architectures are best for small problem sizes that have tables of size approximately 10(10). The IBM x3755 performs very well on medium-sized problems that fit within its 64-GB memory but has poor scalability as the number of processors increases and is unable to sustain performance as the problem size increases. This machine tends to saturate for problem sizes of 10(11) bits. The Cray XMT shows very good scaling for large problems and demonstrates sustained performance as the problem size increases. However, this machine has poor scaling for small problem sizes; it performs best for problem sizes of 10(12) bits or more. The results in this paper illustrate that the subset-sum problem can be parallelized well on all three architectures, albeit for different ranges of problem sizes. The performance of these three machines under varying problem sizes show the strengths and weaknesses of the three architectures. Copyright (c) 2012 John Wiley & Sons, Ltd.", "paper_title": "Parallel solution of the subset-sum problem: an empirical study", "paper_id": "WOS:000310732400002"}