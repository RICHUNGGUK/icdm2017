{"auto_keywords": [{"score": 0.025158343193522895, "phrase": "monad"}, {"score": 0.02194956433545677, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "monadic_embedded_languages_functional_pearl"}, {"score": 0.004633429997452688, "phrase": "embedded_domain_specific_languages"}, {"score": 0.003934970057482768, "phrase": "monad_class"}, {"score": 0.003608732492631878, "phrase": "extensive_monad_libraries"}, {"score": 0.002977061391551628, "phrase": "monad_reification"}, {"score": 0.0027564303939865476, "phrase": "monadic_computation"}, {"score": 0.0025521085778978042, "phrase": "monad_reification_problem"}, {"score": 0.0024088451312725924, "phrase": "small_robot_control_language"}], "paper_keywords": ["Compiling", " embedded language", " reification", " monads"], "paper_abstract": "When writing embedded domain specific languages in Haskell, it is often convenient to be able to make an instance of the Monad class to take advantage of the do-notation and the extensive monad libraries. Commonly it is desirable to compile such languages rather than just interpret them. This introduces the problem of monad reification, i.e. observing the structure of the monadic computation. We present a solution to the monad reification problem and illustrate it with a small robot control language. Monad reification is not new but the novelty of our approach is in its directness, simplicity and compositionality.", "paper_title": "Simple and Compositional Reification of Monadic Embedded Languages Functional Pearl", "paper_id": "WOS:000327696700028"}