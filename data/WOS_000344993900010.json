{"auto_keywords": [{"score": 0.04458003012492911, "phrase": "edit_distance"}, {"score": 0.015719716506582538, "phrase": "edit_distance_based_string_similarity_search"}, {"score": 0.010221498665310687, "phrase": "reference_strings"}, {"score": 0.009120302805593469, "phrase": "knn_queries"}, {"score": 0.004523272849033429, "phrase": "primitive_operation"}, {"score": 0.004234456398783788, "phrase": "existing_approaches"}, {"score": 0.004147123642915346, "phrase": "filter-and-verify_framework"}, {"score": 0.003964007795174772, "phrase": "data_sets"}, {"score": 0.003909301559145041, "phrase": "main_memory"}, {"score": 0.0036595438031512217, "phrase": "similarity_queries"}, {"score": 0.0035222812668916736, "phrase": "existing_rdbmss"}, {"score": 0.00342568771304873, "phrase": "similarity_search"}, {"score": 0.003401954670986958, "phrase": "pruning_techniques"}, {"score": 0.0033549790559972053, "phrase": "metric_space"}, {"score": 0.0032067276476968032, "phrase": "string_collection"}, {"score": 0.002657677633954843, "phrase": "optimal_partitioning"}, {"score": 0.0025937408242280757, "phrase": "np-hard_problem"}, {"score": 0.002540160379502092, "phrase": "heuristic_approach"}, {"score": 0.002461852774571558, "phrase": "optimal_partition_assignment_strategy"}, {"score": 0.002427826856342292, "phrase": "expected_number"}, {"score": 0.002344800544183559, "phrase": "query_evaluation"}, {"score": 0.002320449502337321, "phrase": "extensive_experiments"}, {"score": 0.002280423827531483, "phrase": "real_data_sets"}], "paper_keywords": ["Similarity search", " string", " edit distance", " B+-tree"], "paper_abstract": "Edit distance is widely used for measuring the similarity between two strings. As a primitive operation, edit distance based string similarity search is to find strings in a collection that are similar to a given query string using edit distance. Existing approaches for answering such string similarity queries follow the filter-and-verify framework by using various indexes. Typically, most approaches assume that indexes and data sets are maintained in main memory. To overcome this limitation, in this paper, we propose B+-tree based approaches to answer edit distance based string similarity queries, and hence, our approaches can be easily integrated into existing RDBMSs. In general, we answer string similarity search using pruning techniques employed in the metric space in that edit distance is a metric. First, we split the string collection into partitions according to a set of reference strings. Then, we index strings in all partitions using a single B+-tree based on the distances of these strings to their corresponding reference strings. Finally, we propose two approaches to efficiently answer range and KNN queries, respectively, based on the B+-tree. We prove that the optimal partitioning of the data set is an NP-hard problem, and therefore propose a heuristic approach for selecting the reference strings greedily and present an optimal partition assignment strategy to minimize the expected number of strings that need to be verified during the query evaluation. Through extensive experiments over a variety of real data sets, we demonstrate that our B+-tree based approaches provide superior performance over state-of-the-art techniques on both range and KNN queries in most cases.", "paper_title": "Efficiently Supporting Edit Distance Based String Similarity Search Using B+-Trees", "paper_id": "WOS:000344993900010"}