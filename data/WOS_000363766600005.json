{"auto_keywords": [{"score": 0.0497141445691543, "phrase": "opencl"}, {"score": 0.00481495049065317, "phrase": "vector_data_type_usage"}, {"score": 0.004723742646716804, "phrase": "open_computing_language"}, {"score": 0.004511799033574768, "phrase": "highly_parallel_processors"}, {"score": 0.004359078118356132, "phrase": "underlying_platforms"}, {"score": 0.0042928648367867835, "phrase": "explicit_support"}, {"score": 0.004211504818267892, "phrase": "local_memory_and_vector_data_types"}, {"score": 0.003916098498242888, "phrase": "different_platforms"}, {"score": 0.003697538418750941, "phrase": "systematic_way"}, {"score": 0.003424916005912503, "phrase": "opencl_kernels"}, {"score": 0.003334309053314909, "phrase": "scalar_opencl_kernels"}, {"score": 0.003308862957060602, "phrase": "vectorized_ones"}, {"score": 0.0032585499655442404, "phrase": "vectorized_code"}, {"score": 0.0031967297437935772, "phrase": "performance_effects"}, {"score": 0.0029270797740550973, "phrase": "execution_model"}, {"score": 0.00283870598459543, "phrase": "compiler-aided_vectorizer"}, {"score": 0.002700738055025905, "phrase": "memory_access_patterns"}, {"score": 0.0025014259919355453, "phrase": "opencl's_vdts"}, {"score": 0.0024633601573822114, "phrase": "different_processors"}, {"score": 0.002325689073229477, "phrase": "memory_accesses"}, {"score": 0.0022041312401435346, "phrase": "performance_portability"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["vectorization", " openCL", " vector data types", " benchmarking", " performance", " portability"], "paper_abstract": "Open Computing Language (OpenCL) is an open, functionally portable programming model for a large range of highly parallel processors. To provide users with access to the underlying platforms, OpenCL has explicit support for features such as local memory and vector data types (VDTs). However, these are often low-level, hardware-specific features, which can be detrimental to performance on different platforms. In this paper, we focus on VDTs and investigate their usage in a systematic way. First, we propose two different approaches (inter-vdt and intra-vdt) to use VDTs in OpenCL kernels, and show how to translate scalar OpenCL kernels to vectorized ones. After obtaining vectorized code, we evaluate the performance effects of using VDTs with two types of benchmarks: micro-benchmarks and macro-benchmarks. With micro-benchmarks, we study the execution model of VDTs and the role of the compiler-aided vectorizer on five devices. With macro-benchmarks, we explore the changes of memory access patterns before and after using VDTs, and the resulting performance impact. Not only our evaluation provides insights into how OpenCL's VDTs are mapped on different processors, but it also indicates that using such data types introduces changes in both computation and memory accesses. Based on the lessons learned, we discuss how to deal with performance portability in the presence of VDTs. Copyright (c) 2014 John Wiley & Sons, Ltd.", "paper_title": "Evaluating vector data type usage in OpenCL kernels", "paper_id": "WOS:000363766600005"}