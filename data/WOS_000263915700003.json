{"auto_keywords": [{"score": 0.04350337824761057, "phrase": "k-synchronous_executions"}, {"score": 0.00481495049065317, "phrase": "robust_and_high-throughput_shared_objects"}, {"score": 0.004629912133717504, "phrase": "known_implementations"}, {"score": 0.0045997680394590365, "phrase": "shared_counters"}, {"score": 0.00445195298244008, "phrase": "sequential_bottleneck"}, {"score": 0.004379828513102091, "phrase": "first_counter_algorithm"}, {"score": 0.004184010117063648, "phrase": "high_throughput"}, {"score": 0.0040893952934649485, "phrase": "process_speeds"}, {"score": 0.0038937639582738415, "phrase": "novel_variation"}, {"score": 0.0034841647157189985, "phrase": "combinable_operations"}, {"score": 0.003361069456060196, "phrase": "previous_combining_algorithms"}, {"score": 0.003210652026669616, "phrase": "bwc_algorithm"}, {"score": 0.003107337317471694, "phrase": "bounded_period"}, {"score": 0.0028446460307503343, "phrase": "novel_metric"}, {"score": 0.002789346122034762, "phrase": "shared_objects"}, {"score": 0.002360559092734843, "phrase": "highly_parallel_non-blocking_implementation"}, {"score": 0.0022995431219125536, "phrase": "\"synchronous_locks"}, {"score": 0.0021467594103960585, "phrase": "pseduo-transactions\"aeuro\"a_weakening"}, {"score": 0.0021049977753042253, "phrase": "higher_parallelism"}], "paper_keywords": [""], "paper_abstract": "Shared counters are among the most basic coordination structures in distributed computing. Known implementations of shared counters are either blocking, non-linearizable, or have a sequential bottleneck. We present the first counter algorithm that is both linearizable, non-blocking, and can provably achieve high throughput in k-synchronous executions-executions in which process speeds vary by at most a constant factor k. The algorithm is based on a novel variation of the software combining paradigm that we call bounded-wait combining (BWC). It can thus be used to obtain implementations, possessing the same properties, of any object that supports combinable operations, such as a stack or a queue. Unlike previous combining algorithms where processes may have to wait for each other indefinitely, in the BWC algorithm, a process only waits for other processes for a bounded period of time and then \"takes destiny in its own hands\". In order to reason rigorously about the parallelism attainable by our algorithm, we define a novel metric for measuring the throughput of shared objects, which we believe is interesting in its own right. We use this metric to prove that our algorithm achieves throughput of Omega(N/ log N) in k-synchronous executions, where N is the number of processes that can participate in the algorithm. Our algorithm uses two tools that we believe may prove useful for obtaining highly parallel non-blocking implementation of additional objects. The first are \"synchronous locks\", locks that are respected by processes only in k-synchronous executions and are disregarded otherwise; the second are \"pseduo-transactions\"aEuro\"a weakening of regular transactions that allows higher parallelism.", "paper_title": "Bounded-wait combining: constructing robust and high-throughput shared objects", "paper_id": "WOS:000263915700003"}