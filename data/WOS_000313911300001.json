{"auto_keywords": [{"score": 0.039150156501511525, "phrase": "hermit"}, {"score": 0.012829487030845122, "phrase": "equational_reasoning"}, {"score": 0.0044967055264893184, "phrase": "central_tenet"}, {"score": 0.004445739135694758, "phrase": "functional_programming"}, {"score": 0.0043208252177835815, "phrase": "development_toolchains"}, {"score": 0.004247560712327667, "phrase": "rudimentary_support"}, {"score": 0.004035107125458193, "phrase": "programmatic_and_compiler-centric_interface"}, {"score": 0.0036207206487324506, "phrase": "informal_but_systematic_transformation"}, {"score": 0.00357966840389264, "phrase": "haskell"}, {"score": 0.0034789831290103967, "phrase": "glasgow_haskell_compiler's_optimization_pipeline"}, {"score": 0.003193606324727067, "phrase": "tedious_heavy_lifting"}, {"score": 0.0031215289677725693, "phrase": "actual_transformations"}, {"score": 0.002965229277927781, "phrase": "transformation_api"}, {"score": 0.002849078393246526, "phrase": "higher-level_rewrite_tools"}, {"score": 0.0027689017918347755, "phrase": "new_optimizations"}, {"score": 0.002690999601390995, "phrase": "api"}, {"score": 0.0026003455833291124, "phrase": "ghc_toolchain"}, {"score": 0.002527150892127982, "phrase": "hermit_application"}, {"score": 0.0023463203637929466, "phrase": "hermit."}, {"score": 0.0021784009230363627, "phrase": "specific_example"}, {"score": 0.0021049977753042253, "phrase": "remaining_challenges"}], "paper_keywords": ["Experimentation", " Languages", " Performance", " Verification", " DSLs", " Equational Reasoning", " GHC", " Optimization", " Strategic Programming"], "paper_abstract": "The importance of reasoning about and refactoring programs is a central tenet of functional programming. Yet our compilers and development toolchains only provide rudimentary support for these tasks. This paper introduces a programmatic and compiler-centric interface that facilitates refactoring and equational reasoning. To develop our ideas, we have implemented HERMIT, a toolkit enabling informal but systematic transformation of Haskell programs from inside the Glasgow Haskell Compiler's optimization pipeline. With HERMIT, users can experiment with optimizations and equational reasoning, while the tedious heavy lifting of performing the actual transformations is done for them. HERMIT provides a transformation API that can be used to build higher-level rewrite tools. One use-case is prototyping new optimizations as clients of this API before being committed to the GHC toolchain. We describe a HERMIT application-a read-eval-print shell for performing transformations using HERMIT. We also demonstrate using this shell to prototype an optimization on a specific example, and report our initial experiences and remaining challenges.", "paper_title": "The HERMIT in the Machine A Plugin for the Interactive Transformation of GHC Core Language Programs", "paper_id": "WOS:000313911300001"}