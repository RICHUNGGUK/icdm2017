{"auto_keywords": [{"score": 0.028145961928881916, "phrase": "sle"}, {"score": 0.015719485614456893, "phrase": "mde"}, {"score": 0.004466519142879166, "phrase": "software_system_development"}, {"score": 0.004342430078306461, "phrase": "different_research_communities"}, {"score": 0.003825173769489887, "phrase": "growing_complexity"}, {"score": 0.003789395499639015, "phrase": "software_systems"}, {"score": 0.003615443704375908, "phrase": "domain-specific_languages"}, {"score": 0.0035648266669315943, "phrase": "abstract_models"}, {"score": 0.0034984340449789745, "phrase": "automated_methods"}, {"score": 0.0033851984021896287, "phrase": "compiler_technology"}, {"score": 0.003322140088192527, "phrase": "advanced_techniques"}, {"score": 0.0032602525602322832, "phrase": "program_transformation"}, {"score": 0.0031399038722901788, "phrase": "complex_analyses"}, {"score": 0.0030097975788892896, "phrase": "semantic_analyses"}, {"score": 0.002953711377604328, "phrase": "platform-specific_optimizations"}, {"score": 0.002726740692380339, "phrase": "software_language_engineering"}, {"score": 0.0025892330566358503, "phrase": "software_language_lifecycle"}, {"score": 0.0023127544795063263, "phrase": "compiler_research_communities"}, {"score": 0.0021049977753042253, "phrase": "current_state"}], "paper_keywords": ["Model-driven engineering (MDE)", " Domain-specific language (DSL)", " Compilation", " Intermediate representation (IR)", " Software language engineering (SLE)"], "paper_abstract": "Modeling and transforming have always been the cornerstones of software system development, albeit often investigated by different research communities. Modeling addresses how information is represented and processed, while transformation cares about what the results of processing this information are. To address the growing complexity of software systems, model-driven engineering (MDE) leverages domain-specific languages to define abstract models of systems and automated methods to process them. Meanwhile, compiler technology mostly concentrates on advanced techniques and tools for program transformation. For this, it has developed complex analyses and transformations (from lexical and syntactic to semantic analyses, down to platform-specific optimizations). These two communities appear today quite complementary and are starting to meet again in the software language engineering (SLE) field. SLE addresses all the stages of a software language lifecycle, from its definition to its tooling. In this article, we show how SLE can lean on the expertise of both MDE and compiler research communities and how each community can bring its solutions to the other one. We then draw a picture of the current state of SLE and of the challenges it has still to face.", "paper_title": "Bridging the chasm between MDE and the world of compilation", "paper_id": "WOS:000310087500011"}