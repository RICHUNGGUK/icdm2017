{"auto_keywords": [{"score": 0.04572946919208604, "phrase": "deadlock_potentials"}, {"score": 0.00481495049065317, "phrase": "multi-threaded_programs"}, {"score": 0.004548253531664032, "phrase": "dynamic_program_analysis_algorithm"}, {"score": 0.004255639740735269, "phrase": "multi-threaded_program"}, {"score": 0.0040969285074699, "phrase": "single_execution_trace"}, {"score": 0.0038698476651328898, "phrase": "instrumented_version"}, {"score": 0.003199687131875466, "phrase": "examined_execution"}, {"score": 0.002827474331638941, "phrase": "deadlock_detection"}, {"score": 0.0026202187680903063, "phrase": "existing_algorithm"}, {"score": 0.0024281181691350085, "phrase": "false_positives"}], "paper_keywords": [""], "paper_abstract": "This paper presents a dynamic program analysis algorithm that can detect deadlock potentials in a multi-threaded program by examining a single execution trace, obtained by running an instrumented version of the program. The algorithm is interesting because it can identify deadlock potentials even though no deadlocks occur in the examined execution, and therefore it scales very well in contrast to more formal approaches to deadlock detection. It is an improvement of an existing algorithm in that it reduces the number of false positives (false warnings). The paper describes an implementation and an application to three case studies.", "paper_title": "Dynamic deadlock analysis of multi-threaded programs", "paper_id": "WOS:000237451000015"}