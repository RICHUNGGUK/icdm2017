{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "multithreaded_programs"}, {"score": 0.00462919213721188, "phrase": "critical_path"}, {"score": 0.004551781491498328, "phrase": "communication_session"}, {"score": 0.004500891637057374, "phrase": "end_points"}, {"score": 0.004376131419366239, "phrase": "operating_system_kernels"}, {"score": 0.004278807087784626, "phrase": "attendant_overheads"}, {"score": 0.003845154818609644, "phrase": "communication_protocols"}, {"score": 0.003802135020791801, "phrase": "user_space"}, {"score": 0.0035339597999254064, "phrase": "optimal_communication_performance"}, {"score": 0.003378385493203297, "phrase": "reliable_user-space_protocols"}, {"score": 0.003303177222901723, "phrase": "threads_framework"}, {"score": 0.003175556211659149, "phrase": "internal_threads'_scheduling_techniques"}, {"score": 0.0030017207229983385, "phrase": "scheduling_strategies"}, {"score": 0.002853396755102163, "phrase": "communication-related_processing"}, {"score": 0.00266693888510356, "phrase": "different_scheduling_strategies"}, {"score": 0.0026370661343466354, "phrase": "different_levels"}, {"score": 0.002607527117561699, "phrase": "application-processing_efficiency"}, {"score": 0.0023962545023307937, "phrase": "larger_study"}, {"score": 0.0023296961971785357, "phrase": "multiple_thread-based_protocols"}, {"score": 0.0022906498741695094, "phrase": "single_address_space"}, {"score": 0.0022145052062614514, "phrase": "coupling_protocols"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["user-level protocol", " threads", " scheduling", " latency", " interrupts", " signals"], "paper_abstract": "When the critical path of a communication session between end points includes the actions of operating system kernels, there are attendant overheads. Along with other factors, such as functionality and flexibility, such overheads motivate and favor the implementation of communication protocols in user space. When implemented with threads, such protocols may hold the key to optimal communication performance and functionality. Based on implementations of reliable user-space protocols supported by a threads framework, we focus on our experiences with internal threads' scheduling techniques and their potential impact on performance. We present scheduling strategies that enable threads to do both application-level and communication-related processing. With experiments performed on a Sun SPARG-5 LAN environment, we show how different scheduling strategies yield different levels of application-processing efficiency, communication latency and packet-loss. This work forms part of a larger study on the implementation of multiple thread-based protocols in a single address space, and the benefits of coupling protocols with applications. Copyright (c) 2005 John Wiley & Sons, Ltd.", "paper_title": "Scheduling communication in multithreaded programs: experimental results", "paper_id": "WOS:000234017200001"}