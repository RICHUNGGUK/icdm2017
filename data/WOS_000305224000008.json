{"auto_keywords": [{"score": 0.04236613065377659, "phrase": "stream_programs"}, {"score": 0.036294028396745705, "phrase": "streampi"}, {"score": 0.01160420355438966, "phrase": "multicore_architectures"}, {"score": 0.00481495049065317, "phrase": "object-oriented_programming_languages"}, {"score": 0.004629977311316031, "phrase": "major_hardware_manufacturers"}, {"score": 0.004515967518891287, "phrase": "programming_languages"}, {"score": 0.004467965784278827, "phrase": "programming_abstractions"}, {"score": 0.004357927940322685, "phrase": "parallel_architectures"}, {"score": 0.004326987090971404, "phrase": "stream_processing"}, {"score": 0.0042809854543795255, "phrase": "programming_paradigm"}, {"score": 0.004190438004831167, "phrase": "independent_actors"}, {"score": 0.004131135118662576, "phrase": "fifo_data-channels"}, {"score": 0.004087207102190335, "phrase": "coarse-grained_parallelism"}, {"score": 0.003944112858235306, "phrase": "underlying_multicore_hardware"}, {"score": 0.0038744481564444173, "phrase": "stream-parallel_programming_abstraction"}, {"score": 0.0038332390893263844, "phrase": "object-oriented_languages"}, {"score": 0.0038060092376105414, "phrase": "stream-programming_facilities"}, {"score": 0.003725470458263889, "phrase": "class_hierarchy"}, {"score": 0.003646629717560631, "phrase": "language-independent_runtime_system"}, {"score": 0.0034690732089830045, "phrase": "language-specific_part"}, {"score": 0.0032883848851259123, "phrase": "library-level_programming_language_extension"}, {"score": 0.0032533888943254144, "phrase": "library-level_extension"}, {"score": 0.0031845067058084613, "phrase": "existing_programming_language_implementation"}, {"score": 0.003051073364818384, "phrase": "stream-parallel_application"}, {"score": 0.002986461855862617, "phrase": "sequential_legacy_code"}, {"score": 0.002912803994461996, "phrase": "previous_approaches"}, {"score": 0.0028715299874549245, "phrase": "dynamic_creation"}, {"score": 0.0028511121935559072, "phrase": "subsequent_execution"}, {"score": 0.0028107098861552124, "phrase": "streampi_actors"}, {"score": 0.0027121844541913367, "phrase": "stream_graph_creation_time"}, {"score": 0.002664221051021009, "phrase": "streampi's_language-independent_runtime_system"}, {"score": 0.0025800243626697915, "phrase": "intel"}, {"score": 0.0024281181691350085, "phrase": "performance_comparison"}, {"score": 0.0023513512089705325, "phrase": "international_conference_on_architectural_support_for_programming_languages_and_operating_systems"}, {"score": 0.0022527488455744674, "phrase": "stream-parallel_programming"}, {"score": 0.002212892265364764, "phrase": "greater_programming_flexibility"}, {"score": 0.002120083747913758, "phrase": "static_compilation_model"}, {"score": 0.0021049977753042253, "phrase": "streamit"}], "paper_keywords": ["Programming language support for multicore architectures", " Stream-parallel programming abstraction", " Synchronous data-flow", " Multicore architectures"], "paper_abstract": "Because multicore CPUs have become the standard with all major hardware manufacturers, it becomes increasingly important for programming languages to provide programming abstractions that can be mapped effectively onto parallel architectures. Stream processing is a programming paradigm where computations are expressed as independent actors that communicate via FIFO data-channels. The coarse-grained parallelism exposed in stream programs facilitates such an efficient mapping of actors onto the underlying multicore hardware. We propose a stream-parallel programming abstraction that extends object-oriented languages with stream-programming facilities. StreamPI consists of a class hierarchy for actor-specification together with a language-independent runtime system that supports the execution of stream programs on multicore architectures. We show that the language-specific part of StreamPI, i.e., the class hierarchy, can be implemented as a library-level programming language extension. A library-level extension has the advantage that an existing programming language implementation need not be touched. Legacy-code can be mixed with a stream-parallel application, and the use of sequential legacy code with actors is supported. Unlike previous approaches, StreamPI allows dynamic creation and subsequent execution of stream programs. StreamPI actors are typed. Type-safety is achieved through type-checks at stream graph creation time. We have implemented StreamPI's language-independent runtime system and language interfaces for Ada 2005 and C++ for Intel multicore architectures. We have evaluated StreamPI for up to 16 cores on a two CPU 8-core Intel Xeon X7560 server, and we provide a performance comparison with StreamIt (Gordon et al. in International Conference on Architectural Support for Programming Languages and Operating Systems, 2006), which is the de facto standard for stream-parallel programming. Although our approach provides greater programming flexibility than StreamIt, the performance of StreamPI compares favorably to the static compilation model of StreamIt.", "paper_title": "StreamPI: a stream-parallel programming extension for object-oriented programming languages", "paper_id": "WOS:000305224000008"}