{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "parallel_runtime"}, {"score": 0.004772818068176176, "phrase": "self-stabilizing_graph_linearization"}, {"score": 0.0047310525657970615, "phrase": "topological_self-stabilization"}, {"score": 0.004669085371587273, "phrase": "important_concept"}, {"score": 0.0046079260641779755, "phrase": "robust_open_distributed_systems"}, {"score": 0.004527619017250708, "phrase": "peer-to-peer_systems"}, {"score": 0.004371160978838441, "phrase": "meaningful_network_topologies"}, {"score": 0.004238682850598745, "phrase": "distributed_algorithms"}, {"score": 0.0040385352882334235, "phrase": "neighboring_nodes"}, {"score": 0.0038309141193444015, "phrase": "initial_network_configuration"}, {"score": 0.0037311260623089436, "phrase": "new_model"}, {"score": 0.0036660436272785476, "phrase": "parallel_convergence_time"}, {"score": 0.00355485940716082, "phrase": "achievable_parallelism"}, {"score": 0.003477505397536663, "phrase": "existing_models"}, {"score": 0.0034018288705284427, "phrase": "distorted_picture"}, {"score": 0.003342471131048328, "phrase": "case_study"}, {"score": 0.003284145698220425, "phrase": "local_graph"}, {"score": 0.003142732162296465, "phrase": "sorted_list"}, {"score": 0.0030608148631528767, "phrase": "connected_graph"}, {"score": 0.0030206579994328975, "phrase": "distributed_and_self-stabilizing_manner"}, {"score": 0.0029289895726382653, "phrase": "main_structure"}, {"score": 0.0026121403051734744, "phrase": "best-case_parallel_time_complexities"}, {"score": 0.0025106241866273897, "phrase": "greedy_selection"}, {"score": 0.002298902547676131, "phrase": "simple_setting"}, {"score": 0.0021049977753042253, "phrase": "average_case"}], "paper_keywords": ["Distributed algorithms", " Distributed systems", " Peer-to-peer systems", " Self-stabilization", " Overlay networks", " Performance"], "paper_abstract": "Topological self-stabilization is an important concept to build robust open distributed systems (such as peer-to-peer systems) where nodes can organize themselves into meaningful network topologies. The goal is to devise distributed algorithms where nodes forward, insert, and delete links to neighboring nodes, and that converge quickly to such a desirable topology, independently of the initial network configuration. This article proposes a new model to study the parallel convergence time. Our model sheds light on the achievable parallelism by avoiding bottlenecks of existing models that can yield a distorted picture. As a case study, we consider local graph linearization-i.e., how to build a sorted list of the nodes of a connected graph in a distributed and self-stabilizing manner. In order to study the main structure and properties of our model, we propose two variants of a most simple local linearization algorithm. For each of these variants, we present analyses of the worst-case and best-case parallel time complexities, as well as the performance under a greedy selection of the actions to be executed. It turns out that the analysis is non-trivial despite the simple setting, and to complement our formal insights we report on our experiments which indicate that the runtimes may be better in the average case.", "paper_title": "A Note on the Parallel Runtime of Self-Stabilizing Graph Linearization", "paper_id": "WOS:000336928800005"}