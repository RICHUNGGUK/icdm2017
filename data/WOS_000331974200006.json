{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "memory_affinity"}, {"score": 0.00476697427418509, "phrase": "transactional_worklist_applications"}, {"score": 0.004625881588444304, "phrase": "key_element"}, {"score": 0.004556901872357751, "phrase": "scalable_performance"}, {"score": 0.004511485198940203, "phrase": "multi-core_platforms"}, {"score": 0.004399905285945236, "phrase": "thread_scheduling"}, {"score": 0.0043560464825349275, "phrase": "page_allocation"}, {"score": 0.004312622975366676, "phrase": "cache_prefetching"}, {"score": 0.003441891354624516, "phrase": "existing_stm_runtime_systems"}, {"score": 0.0032900200522703923, "phrase": "memory_management"}, {"score": 0.003129096013910626, "phrase": "skeleton-driven_mechanism"}, {"score": 0.003051601113971322, "phrase": "stm_applications"}, {"score": 0.0029909851863915283, "phrase": "worklist_pattern"}, {"score": 0.0029463123778313196, "phrase": "two-level_approach"}, {"score": 0.002816246391862638, "phrase": "dram_level"}, {"score": 0.0027881294891497115, "phrase": "automatic_selecting_page_allocation_policies"}, {"score": 0.0026919067120537055, "phrase": "helper_threads"}, {"score": 0.0026120705848349055, "phrase": "cache_level"}, {"score": 0.002534596206835737, "phrase": "skeleton_framework"}, {"score": 0.0024842242921857705, "phrase": "application_pattern"}, {"score": 0.002422661411769552, "phrase": "automatic_memory_page_allocation"}, {"score": 0.002327310963701377, "phrase": "stamp_benchmark_suite"}, {"score": 0.0022582634725291225, "phrase": "performance_improvements"}, {"score": 0.0021262403223013242, "phrase": "baseline_version"}], "paper_keywords": ["Memory affinity", " Software transactional memory", " Parallel algorithmic skeleton", " Multi-core platforms"], "paper_abstract": "Memory affinity has become a key element to achieve scalable performance on multi-core platforms. Mechanisms such as thread scheduling, page allocation and cache prefetching are commonly employed to enhance memory affinity which keeps data close to the cores that access it. In particular, software transactional memory (STM) applications exhibit irregular memory access behavior that makes harder to determine which and when data will be needed by each core. Additionally, existing STM runtime systems are decoupled from issues such as thread and memory management. In this paper, we thus propose a skeleton-driven mechanism to improve memory affinity on STM applications that fit the worklist pattern employing a two-level approach. First, it addresses memory affinity in the DRAM level by automatic selecting page allocation policies. Then it employs data prefetching helper threads to improve affinity in the cache level. It relies on a skeleton framework to exploit the application pattern in order to provide automatic memory page allocation and cache prefetching. Our experimental results on the STAMP benchmark suite show that our proposed mechanism can achieve performance improvements of up to 46 %, with an average of 11 %, over a baseline version on two NUMA multi-core machines.", "paper_title": "Automatic Skeleton-Driven Memory Affinity for Transactional Worklist Applications", "paper_id": "WOS:000331974200006"}