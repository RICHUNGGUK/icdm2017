{"auto_keywords": [{"score": 0.00481495049065317, "phrase": "memory_faults"}, {"score": 0.0036248955128033084, "phrase": "running_times"}, {"score": 0.0035648266669315943, "phrase": "mergesort-based_algorithms"}, {"score": 0.003279039724748895, "phrase": "software_testbed"}, {"score": 0.003197843245296877, "phrase": "different_fault_injection_strategies"}, {"score": 0.003066945490483524, "phrase": "thorough_experimental_study"}, {"score": 0.0027974705482714884, "phrase": "simple-minded_approaches"}, {"score": 0.0022696277881969896, "phrase": "carefully_engineered_implementation"}, {"score": 0.0022133711375320244, "phrase": "resilient_sorting_algorithm"}, {"score": 0.0021049977753042253, "phrase": "different_memory_fault_patterns"}], "paper_keywords": ["Sorting", " Memory faults", " Memory models", " Fault injection", " Computing with unreliable information", " Experimental algorithmics"], "paper_abstract": "We address the problem of sorting in the presence of faults that may arbitrarily corrupt memory locations, and investigate the impact of memory faults both on the correctness and on the running times of mergesort-based algorithms. To achieve this goal, we develop a software testbed that simulates different fault injection strategies, and perform a thorough experimental study using a combination of several fault parameters. Our experiments give evidence that simple-minded approaches to this problem are largely impractical, while the design of more sophisticated resilient algorithms seems really worth the effort. Another contribution of our computational study is a carefully engineered implementation of a resilient sorting algorithm, which appears robust to different memory fault patterns.", "paper_title": "The Price of Resiliency: a Case Study on Sorting with Memory Faults", "paper_id": "WOS:000264698900009"}