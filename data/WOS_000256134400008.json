{"auto_keywords": [{"score": 0.046081391722127746, "phrase": "incorrect_computations"}, {"score": 0.010132232548106534, "phrase": "rolled-back_input_event"}, {"score": 0.00481495049065317, "phrase": "time_warp_parallel_simulation"}, {"score": 0.004777034835192062, "phrase": "time_warp_parallel_simulations"}, {"score": 0.0046650615456476155, "phrase": "erroneous_event_messages"}, {"score": 0.004573748810476845, "phrase": "acceptable_performance_levels"}, {"score": 0.00453772385360173, "phrase": "lazy_cancellation"}, {"score": 0.0043790755286923794, "phrase": "rolled-back_events"}, {"score": 0.004110549138321181, "phrase": "output_message"}, {"score": 0.0034129490818185595, "phrase": "enhanced_lazy_cancellation_technique"}, {"score": 0.0032934951320964276, "phrase": "logical_processes"}, {"score": 0.003190817088774159, "phrase": "output_messages"}, {"score": 0.003128270147867462, "phrase": "first_execution"}, {"score": 0.002867268370615848, "phrase": "blocked_state"}, {"score": 0.002701877448139625, "phrase": "receiving_lp"}, {"score": 0.0026384167183586015, "phrase": "blocked_input_message"}, {"score": 0.002607246047604476, "phrase": "next_message"}, {"score": 0.002476451645510228, "phrase": "lp"}, {"score": 0.002324238863944163, "phrase": "previously_marked_output_message"}, {"score": 0.0022517100995552443, "phrase": "equality_test"}, {"score": 0.0022250978492127163, "phrase": "output_message's_versions"}, {"score": 0.002172811149894415, "phrase": "experimental_results"}, {"score": 0.0021471293746360026, "phrase": "synthetic_benchmark_show"}, {"score": 0.0021049977753042253, "phrase": "better_performance"}], "paper_keywords": ["Time Warp", " lazy cancellation", " blocking message", " unblocking message", " antimessage"], "paper_abstract": "Time Warp parallel simulations need efficient schemes to cancel erroneous event messages in order to achieve acceptable performance levels. Lazy cancellation depends on delaying the cancellation of incorrect computations until rolled-back events are re-processed. An antimessage is then sent for cancellation only if an output message re-produced after rollback is found to be unequal to its counterpart produced before rollback. One drawback of this approach is that antimessages are sent too late to catch the wave of incorrect computations, which results in more rollbacks. In this paper, we suggest an enhanced lazy cancellation technique that aims to throttle incorrect computations. It asks logical processes (LPs) that have received any output messages, generated from the first execution of a rolled-back input event in some neighboring LP, to mark those messages as temporarily blocked. Those messages remain in a blocked state until it is later decided whether or not they must be cancelled. The receiving LP becomes blocked only after a blocked input message becomes the next message to process. After re-executing the rolled-back input event, the sending LP sends each of its receiving LPs either an 'Unblock' message or an antimessage for each previously marked output message, depending on the result of the equality test of that output message's versions before and after rollback. Experimental results for a synthetic benchmark show that our technique can yield better performance than both lazy and aggressive cancellation.", "paper_title": "Throttled lazy cancellation in Time Warp parallel simulation", "paper_id": "WOS:000256134400008"}