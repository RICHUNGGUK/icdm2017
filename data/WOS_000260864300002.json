{"auto_keywords": [{"score": 0.035149400889238576, "phrase": "pipeline_logic"}, {"score": 0.010493650423511915, "phrase": "sbst"}, {"score": 0.007872990957927666, "phrase": "systematic_sbst_methodology"}, {"score": 0.0076756326471508415, "phrase": "sbst_programs"}, {"score": 0.00756811852146998, "phrase": "functional_components"}, {"score": 0.00481495049065317, "phrase": "systematic_software-based_self-test_for_pipelined_processors"}, {"score": 0.00478778190213169, "phrase": "software-based_self-test"}, {"score": 0.004667399058297227, "phrase": "effective_methodology"}, {"score": 0.004627944735913613, "phrase": "manufacturing_test"}, {"score": 0.0044105602025248936, "phrase": "test_related_functions"}, {"score": 0.004385663349966071, "phrase": "external_resources"}, {"score": 0.004348580182733617, "phrase": "soc's_interior"}, {"score": 0.004275347843870176, "phrase": "test_programs"}, {"score": 0.0042391934825554076, "phrase": "on-chip_processor"}, {"score": 0.004028572475177205, "phrase": "speed_testing"}, {"score": 0.004005823201694909, "phrase": "performance_binning"}, {"score": 0.003949508242904001, "phrase": "sbst_approaches"}, {"score": 0.0036587599268245417, "phrase": "important_component"}, {"score": 0.0036380913496453994, "phrase": "modern_processors"}, {"score": 0.003285333896994258, "phrase": "significant_loss"}, {"score": 0.003266767911612594, "phrase": "overall_processor_fault_coverage"}, {"score": 0.003211695083676408, "phrase": "testability_hotspots"}, {"score": 0.003017562858065794, "phrase": "existing_sbst_programs"}, {"score": 0.002933232194777296, "phrase": "proposed_methodology"}, {"score": 0.00290016162105678, "phrase": "previous_sbst_techniques"}, {"score": 0.0027480831196871093, "phrase": "test_development_effort"}, {"score": 0.0026411384812121503, "phrase": "integrated_software_environment"}, {"score": 0.002611400540853827, "phrase": "java"}, {"score": 0.0025966112491168027, "phrase": "xml"}, {"score": 0.0025455532832484367, "phrase": "automatic_generation"}, {"score": 0.0025311573083044545, "phrase": "sbst_routines"}, {"score": 0.002398382089724878, "phrase": "fault_model"}, {"score": 0.0023512362295366454, "phrase": "simulation_results"}, {"score": 0.002318127769195112, "phrase": "significant_improvements"}, {"score": 0.0022661190184053628, "phrase": "entire_processor"}, {"score": 0.0021049977753042253, "phrase": "conventional_sbst_approach"}], "paper_keywords": ["Functional testing", " microprocessor testing", " pipeline", " software-based self-test (SBST)"], "paper_abstract": "Software-based self-test (SBST) has recently emerged as an effective methodology for the manufacturing test of processors and other components in systems-on-chip (SoCs). By moving test related functions from external resources to the SoC's interior, in the form of test programs that the on-chip processor executes, SBST significantly reduces the need for high-cost, big-iron testers, and enables high-quality at-speed testing and performance binning. Thus far, SBST approaches have focused almost exclusively on the functional (programmer visible) components of the processor. In this paper, we analyze the challenges involved in testing an important component of modern processors, namely, the pipelining logic, and propose a systematic SBST methodology to address them. We first demonstrate that SBST programs that only target the functional components of the processor are not sufficient to test the pipeline logic, resulting in a significant loss of overall processor fault coverage. We further identify the testability hotspots in the pipeline logic using two fully pipelined reduced instruction set computer (RISC) processor benchmarks. Finally, we develop a systematic SBST methodology that enhances existing SBST programs so that they comprehensively test the pipeline logic. The proposed methodology is complementary to previous SBST techniques that target functional components (their results can form the input to our methodology, and thus we can reuse the test development effort behind preexisting SBST programs). We automate our methodology and incorporate it in an integrated software environment (developed using Java, XML, and archC) for the automatic generation of SBST routines for microprocessors. We apply the methodology to the two complex benchmark RISC processors with respect to two fault models: stuck-at fault model and transition delay fault model. Simulation results show that our methodology provides significant improvements for the two fault models, both for the entire processor (12% fault coverage improvement on average) and for the pipeline logic itself (19% fault coverage improvement on average), compared to a conventional SBST approach.", "paper_title": "Systematic Software-Based Self-Test for Pipelined Processors", "paper_id": "WOS:000260864300002"}