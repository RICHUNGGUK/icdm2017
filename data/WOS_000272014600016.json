{"auto_keywords": [{"score": 0.0490494776391455, "phrase": "explicitly_managed_memory_hierarchies"}, {"score": 0.00481495049065317, "phrase": "programming_models"}, {"score": 0.004203030435498069, "phrase": "fast_local_memories"}, {"score": 0.003916098498242888, "phrase": "expert_programmers"}, {"score": 0.0033262524445013303, "phrase": "reasonable_effort"}, {"score": 0.0031845067058084583, "phrase": "vast_on-chip_memory_bandwidth"}, {"score": 0.0031500213134140953, "phrase": "emm_multi-processors"}, {"score": 0.0029830992938695033, "phrase": "hand-tuned_codes"}, {"score": 0.002934764205541183, "phrase": "sti_cell"}, {"score": 0.002779217021776702, "phrase": "first_programming_model"}, {"score": 0.0027491092724954446, "phrase": "sequoia"}, {"score": 0.0026898636962522505, "phrase": "memory_hierarchy"}, {"score": 0.0026607205525625995, "phrase": "private_address_spaces"}, {"score": 0.002575167114383286, "phrase": "parallel_task"}, {"score": 0.0025059724686541263, "phrase": "cellgen"}, {"score": 0.0024519545383399773, "phrase": "new_framework"}, {"score": 0.002412204754253618, "phrase": "openmp-like_semantics"}, {"score": 0.0023346234464901978, "phrase": "shared_address_spaces"}, {"score": 0.0022967713922705, "phrase": "private_and_shared_data"}, {"score": 0.0021049977753042253, "phrase": "programming_complexity"}], "paper_keywords": ["Design", " Languages", " Cell BE", " Explicitly Managed Memory Hierarchies", " Programming Models"], "paper_abstract": "On multiprocessors with explicitly managed memory hierarchies (EMM), software has the responsibility of moving data in and out of fast local memories. This task can be complex and error-prone even for expert programmers. Before we can allow compilers to handle the complexity for us, we must identify the abstractions that are general enough to allow us to write applications with reasonable effort, yet specific enough to exploit the vast on-chip memory bandwidth of EMM multi-processors. To this end, we compare two programming models against hand-tuned codes on the STI Cell, paying attention to programmability and performance. The first programming model, Sequoia, abstracts the memory hierarchy as private address spaces, each corresponding to a parallel task. The second, Cellgen, is a new framework which provides OpenMP-like semantics and the abstraction of a shared address spaces divided into private and shared data. We compare three applications programmed using these models against their hand-optimized counterparts in terms of abstractions, programming complexity, and performance.", "paper_title": "A Comparison of Programming Models for Multiprocessors with Explicitly Managed Memory Hierarchies", "paper_id": "WOS:000272014600016"}