{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "dynamic_indexability"}, {"score": 0.004718230196581402, "phrase": "one-dimensional_range_queries"}, {"score": 0.004439519886195092, "phrase": "large_databases"}, {"score": 0.004337710093279712, "phrase": "external_index"}, {"score": 0.004275262915031191, "phrase": "disk_block_accesses"}, {"score": 0.0041170581247889654, "phrase": "static_case"}, {"score": 0.004010960493946656, "phrase": "linear_size"}, {"score": 0.0039531986393405785, "phrase": "range_query"}, {"score": 0.003872722202521245, "phrase": "k"}, {"score": 0.0038290225494224017, "phrase": "output_size"}, {"score": 0.0037738708560271354, "phrase": "disk_block_size"}, {"score": 0.003644714340300824, "phrase": "standard_solution"}, {"score": 0.0034491650585057754, "phrase": "data_set"}, {"score": 0.0033602211267167435, "phrase": "main_memory_size"}, {"score": 0.003331084078553706, "phrase": "typical_values"}, {"score": 0.0030799267141887058, "phrase": "dynamic_setting"}, {"score": 0.002957222630196853, "phrase": "smart_buffering"}, {"score": 0.00269475174341129, "phrase": "query_performance"}, {"score": 0.0024842242921857705, "phrase": "query-update_tradeoffs"}, {"score": 0.0023303871145705954, "phrase": "substantially_better_solutions"}, {"score": 0.0023101592330916822, "phrase": "practical_values"}, {"score": 0.002250520617413885, "phrase": "dynamic_version"}, {"score": 0.002230984431056064, "phrase": "indexability_model"}, {"score": 0.0021987994275190314, "phrase": "independent_interests"}, {"score": 0.0021670777282518424, "phrase": "clean_yet_powerful_model"}, {"score": 0.002148264328397543, "phrase": "dynamic_indexing_problems"}], "paper_keywords": ["Theory", " Indexability", " B-trees", " range query", " lower bound", " dynamization"], "paper_abstract": "One-dimensional range queries, as one of the most basic type of queries in databases, have been studied extensively in the literature. For large databases, the goal is to build an external index that is optimized for disk block accesses (or I/Os). The problem is well understood in the static case. Theoretically, there exists an index of linear size that can answer a range query in O(1 + K/B) I/Os, where K is the output size and B is the disk block size, but it is highly impractical. In practice, the standard solution is the B-tree, which answers a query in O(log(B) N/M + K/B) I/Os on a data set of size N, where M is the main memory size. For typical values of N, M, and B, log(B) N/M can be considered a constant. However, the problem is still wide open in the dynamic setting, when insertions and deletions of records are to be supported. With smart buffering, it is possible to speed up updates significantly to o(1) I/Os amortized. Indeed, several dynamic B-trees have been proposed, but they all cause certain levels of degradation in the query performance, with the most interesting tradeoff point at O(1/B log N/M) I/Os for updates and O(log N/M + K/B) I/Os for queries. In this article, we prove that the query-update tradeoffs of all the known dynamic B-trees are optimal, when log(B) N/M is a constant. This implies that one should not hope for substantially better solutions for all practical values of the parameters. Our lower bounds hold in a dynamic version of the indexability model, which is of independent interests. Dynamic indexability is a clean yet powerful model for studying dynamic indexing problems, and can potentially lead to more interesting lower bound results.", "paper_title": "Dynamic Indexability and the Optimality of B-Trees", "paper_id": "WOS:000308330700005"}