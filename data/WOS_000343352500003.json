{"auto_keywords": [{"score": 0.03705807455203699, "phrase": "hymr"}, {"score": 0.015233268351698488, "phrase": "hybrid_address_spaces"}, {"score": 0.013799264269043534, "phrase": "mapreduce"}, {"score": 0.00481495049065317, "phrase": "scalable_high-level_programming_models"}, {"score": 0.004771435352180973, "phrase": "non-coherent_many-core_architectures"}, {"score": 0.00460125407969429, "phrase": "fundamental_design_methodology"}, {"score": 0.004539005582217309, "phrase": "scalable_runtime_systems"}, {"score": 0.004497973025639345, "phrase": "many-core_architectures"}, {"score": 0.004397000006837371, "phrase": "cache_coherence"}, {"score": 0.0041074234667687875, "phrase": "large-scale_data_processing"}, {"score": 0.003978866233891427, "phrase": "remote_memory"}, {"score": 0.003925006901257, "phrase": "rma"}, {"score": 0.0037506567448470163, "phrase": "intel_scc"}, {"score": 0.0036663981146086103, "phrase": "similar_architectures"}, {"score": 0.00334780964309978, "phrase": "synchronization_operations"}, {"score": 0.003257727050827128, "phrase": "distributed_memory_address_space"}, {"score": 0.0032135959043774085, "phrase": "shared_memory_address_space"}, {"score": 0.0030291453183733897, "phrase": "reference_implementation"}, {"score": 0.0028037753646260937, "phrase": "representative_mapreduce_benchmarks"}, {"score": 0.00266693888510356, "phrase": "state-of-art_implementation"}, {"score": 0.0026188490199688013, "phrase": "hardware-managed_cache_coherence"}, {"score": 0.002525248554951453, "phrase": "peak_data_processing_bandwidth"}, {"score": 0.0021049977753042253, "phrase": "elsevier_inc."}], "paper_keywords": ["Parallel programming models", " Runtime systems", " Many-core processors"], "paper_abstract": "This paper introduces hybrid address spaces as a fundamental design methodology for implementing scalable runtime systems on many-core architectures without hardware support for cache coherence. We use hybrid address spaces for an implementation of MapReduce, a programming model for large-scale data processing, and the implementation of a remote memory access (RMA) model. Both implementations are available on the Intel SCC and are portable to similar architectures. We present the design and implementation of HyMR, a MapReduce runtime system whereby different stages and the synchronization operations between them alternate between a distributed memory address space and a shared memory address space, to improve performance and scalability. We compare HyMR to a reference implementation and we find that HyMR improves performance by a factor of 1.71 x over a set of representative MapReduce benchmarks. We also compare HyMR with Phoenix(++), a state-of-art implementation for systems with hardware-managed cache coherence in terms of scalability and sustained to peak data processing bandwidth, where HyMR demonstrates improvements of a factor of 3.1 x and 3.2x respectively. We further evaluate our hybrid remote memory access (HyRMA) programming model and assess its performance to be superior of that of message passing. (C) 2014 Elsevier Inc. All rights reserved.", "paper_title": "Hybrid address spaces: A methodology for implementing scalable high-level programming models on non-coherent many-core architectures", "paper_id": "WOS:000343352500003"}