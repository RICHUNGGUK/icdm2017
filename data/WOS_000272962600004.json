{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "message-passing_applications"}, {"score": 0.029370048019070182, "phrase": "local_intervals"}, {"score": 0.004592214823540993, "phrase": "performance_behavior"}, {"score": 0.004426092397211699, "phrase": "in-depth_analysis"}, {"score": 0.00433386573276633, "phrase": "synchronization_patterns"}, {"score": 0.004177049813981273, "phrase": "synchronized_clocks"}, {"score": 0.004025885154716127, "phrase": "inaccurate_relative_event_timings"}, {"score": 0.003941964605885606, "phrase": "logical_event_order"}, {"score": 0.003492155652400838, "phrase": "time-dependent_drifts"}, {"score": 0.0033480035183418642, "phrase": "original_succession"}, {"score": 0.0032437952431945724, "phrase": "longer_runs"}, {"score": 0.0031929098985796814, "phrase": "controlled_logical_clock_algorithm"}, {"score": 0.0029814443878969973, "phrase": "message_events"}, {"score": 0.0026270572353632297, "phrase": "controlled_logical_clock"}, {"score": 0.0025722202862084186, "phrase": "collective_communication"}, {"score": 0.002492098272172066, "phrase": "realistic_message-passing_traces"}, {"score": 0.0024272350606639147, "phrase": "parallel_version"}, {"score": 0.002242577809454225, "phrase": "inconsistent_inter-process_timings"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Performance analysis", " Event tracing", " Clock synchronization"], "paper_abstract": "Event traces are helpful in understanding the performance behavior of message-passing applications since they allow the in-depth analysis of communication and synchronization patterns. However, the absence of synchronized clocks may render the analysis ineffective because inaccurate relative event timings may misrepresent the logical event order and lead to errors when quantifying the impact of certain behaviors. Although linear offset interpolation can restore consistency to some degree, time-dependent drifts and other inaccuracies may still disarrange the original succession of events - especially during longer runs. The controlled logical clock algorithm accounts for such violations in point-to-point communication by shifting message events in time as much as needed while trying to preserve the length of local intervals. In this article, we describe how the controlled logical clock is extended to collective communication to enable the correction of realistic message-passing traces. We present a parallel version of the algorithm scaling to more than thousand processes and evaluate its accuracy by showing that it eliminates inconsistent inter-process timings while preserving the length of local intervals. (C) 2009 Elsevier B.V. All rights reserved.", "paper_title": "Scalable timestamp synchronization for event traces of message-passing applications", "paper_id": "WOS:000272962600004"}