{"auto_keywords": [{"score": 0.05007852962010532, "phrase": "design_patterns"}, {"score": 0.049159622808007675, "phrase": "software_reuse"}, {"score": 0.00464976086880886, "phrase": "major_goal"}, {"score": 0.004560438999891081, "phrase": "programming_languages"}, {"score": 0.004252793268613575, "phrase": "current_software_tools"}, {"score": 0.004075053556360943, "phrase": "object-oriented_programming"}, {"score": 0.003996727479807572, "phrase": "aspect-oriented_programming"}, {"score": 0.003904713104101532, "phrase": "new_operators"}, {"score": 0.003859512921884243, "phrase": "oop"}, {"score": 0.003800026771283179, "phrase": "superior_support"}, {"score": 0.0037125240439927114, "phrase": "aop_operators"}, {"score": 0.0034217766191752628, "phrase": "independent_manner"}, {"score": 0.0033821367649595254, "phrase": "key_construct"}, {"score": 0.0033429545815200825, "phrase": "systematic_software_reuse"}, {"score": 0.003228101865545105, "phrase": "practical_software_tools"}, {"score": 0.0031298806127471324, "phrase": "independent"}, {"score": 0.0031050953733360825, "phrase": "pluggable_software_unit"}, {"score": 0.002963640433319524, "phrase": "software_topologies"}, {"score": 0.0028506887602994264, "phrase": "aop"}, {"score": 0.0028067105937184954, "phrase": "reusable_software"}, {"score": 0.0027102313244646934, "phrase": "well_described_problems"}, {"score": 0.0026788122684116224, "phrase": "software_design_patterns"}, {"score": 0.0026069066266394118, "phrase": "pu_and_aop_versions"}, {"score": 0.0024784363584530976, "phrase": "chain_of_responsibility"}, {"score": 0.0023289568500915207, "phrase": "unified_representation"}, {"score": 0.002293014162421338, "phrase": "aop_representations"}, {"score": 0.0021970000365512227, "phrase": "aop_solutions"}, {"score": 0.002163089417146551, "phrase": "independent_and_reusable_software"}, {"score": 0.0021049977753042253, "phrase": "john_wiley"}], "paper_keywords": ["software composition", " aspect programming", " design patterns"], "paper_abstract": "The support for software reuse has been a major goal in the design of programming languages. This goal, however, has proven difficult to reach, being only partially enabled by current software tools. In particular, reuse is not fully supported by object-oriented programming (OOP). Aspect-oriented programming (AOP) has introduced new operators that extend OOP, enabling a superior support for reusability. However, AOP operators exhibit limitations in supporting software reuse and more powerful constructs are still required. We consider the ability to define software in an independent manner as the key construct to enable systematic software reuse. To bridge the gap between independence and practical software tools, we have developed the concept of Independent and Pluggable Software Unit (PU), a construct that supports the definition of software topologies. In this paper, we compare PUs with AOP in their support for reusable software. To enable comparison, we employ some well described problems addressed by Software Design Patterns (SDPs). We provide PU and AOP versions of several SDPs, including, Observer, Composite, Command, Chain of Responsibility, and Proxy. In particular, we show that, whereas PUs provide a unified representation of design patterns, AOP representations do not achieve this unification. We also show that AOP solutions do not promote independent and reusable software.Copyright (c) 2013 John Wiley & Sons, Ltd.", "paper_title": "Aspect-oriented programming and pluggable software units: a comparison based on design patterns", "paper_id": "WOS:000348429500001"}