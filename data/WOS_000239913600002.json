{"auto_keywords": [{"score": 0.04504330710057516, "phrase": "runtime_system"}, {"score": 0.04431277486761943, "phrase": "process-local_heaps"}, {"score": 0.03254376137231176, "phrase": "incremental_collector"}, {"score": 0.00481495049065317, "phrase": "efficient_memory_management"}, {"score": 0.004774115617883476, "phrase": "concurrent_programs"}, {"score": 0.004594582559945568, "phrase": "efficient_memory_management_scheme"}, {"score": 0.0045556080393342165, "phrase": "concurrent_programming_languages"}, {"score": 0.004148014765950199, "phrase": "memory_manager"}, {"score": 0.004112812699639956, "phrase": "redundant_synchronization"}, {"score": 0.004060566667226606, "phrase": "multi-threaded_implementation"}, {"score": 0.003991932110277654, "phrase": "memory_reclamation"}, {"score": 0.003891140864902669, "phrase": "private_business"}, {"score": 0.0037446875860947916, "phrase": "garbage_collection"}, {"score": 0.0036191240628152205, "phrase": "static_analysis"}, {"score": 0.0034532961266947734, "phrase": "shared_memory_area"}, {"score": 0.0029491324941225356, "phrase": "costly_barrier_mechanisms"}, {"score": 0.0028992294924613327, "phrase": "relatively_small_space_overhead"}, {"score": 0.0027311076665349657, "phrase": "work_quantum"}, {"score": 0.0025947642929906407, "phrase": "industrial-strength_implementation"}, {"score": 0.002561752783323717, "phrase": "concurrent_functional_language"}, {"score": 0.002342110338541984, "phrase": "total_runtime"}, {"score": 0.002178144355363467, "phrase": "high_degree"}, {"score": 0.002159623311924437, "phrase": "mutator_utilization"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["incremental and real-time garbage collection", " thread-local heaps", " message analysis", " concurrent languages", " mutator utilization", " erlang"], "paper_abstract": "We present an efficient memory management scheme for concurrent programming languages where communication occurs by using message passing with copying semantics. The runtime system is built around process-local heaps, which frees the memory manager from redundant synchronization in a multi-threaded implementation and allows the memory reclamation of process-local heaps to be a private business and to often take place without ever triggering garbage collection. The allocator is guided by a static analysis which speculatively allocates data possibly used as messages in a shared memory area. To respect the (soft) real-time requirements of the language, we develop and present in detail a generational, incremental garbage collection scheme tailored to the characteristics of this runtime system. The incremental collector imposes no overhead on the mutator, requires no costly barrier mechanisms, has a relatively small space overhead, and can be scheduled on the basis of either a time or a work quantum. We have implemented these schemes in the context of an industrial-strength implementation of a concurrent functional language used to develop large-scale, highly concurrent, telecommunication applications. Our measurements across a range of applications indicate that the incremental collector imposes only very small overhead on the total runtime and can achieve very short pause times (1 ms or less) while being able to sustain a high degree of mutator utilization. (c) 2006 Elsevier B.V. All rights reserved.", "paper_title": "Efficient memory management for concurrent programs that use message passing", "paper_id": "WOS:000239913600002"}