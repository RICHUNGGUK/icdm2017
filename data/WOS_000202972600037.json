{"auto_keywords": [{"score": 0.04936538823130262, "phrase": "peephole_optimizers"}, {"score": 0.00481495049065317, "phrase": "peephole_superoptimizers"}, {"score": 0.004568326972997448, "phrase": "human-written_pattern_matching_rules"}, {"score": 0.003757480190200645, "phrase": "fully_automatic_construction"}, {"score": 0.0036461569988218267, "phrase": "brute_force_superoptimization"}, {"score": 0.003306559295382181, "phrase": "human-written_counterparts"}, {"score": 0.0027602925235474317, "phrase": "current_peephole_optimizers"}, {"score": 0.0025409639091476363, "phrase": "performance_opportunities"}, {"score": 0.002465593351432208, "phrase": "existing_compilers"}, {"score": 0.0021530945641993152, "phrase": "intensive_kernels"}, {"score": 0.0021049977753042253, "phrase": "conventional_optimizing_compiler"}], "paper_keywords": ["algorithms", " performance", " design", " reliability", " superoptimization", " peephole optimization", " code selection"], "paper_abstract": "Peephole optimizers are typically constructed using human-written pattern matching rules, an approach that requires expertise and time, as well as being less than systematic at exploiting all opportunities for optimization. We explore fully automatic construction of peephole optimizers using brute force superoptimization. While the optimizations discovered by our automatic system may be less general than human-written counterparts, our approach has the potential to automatically learn a database of thousands to millions of optimizations, in contrast to the hundreds found in current peephole optimizers. We show experimentally that our optimizer is able to exploit performance opportunities not found by existing compilers; in particular, we show speedups from 1.7 to a factor of 10 on some compute intensive kernels over a conventional optimizing compiler.", "paper_title": "Automatic generation of peephole superoptimizers", "paper_id": "WOS:000202972600037"}