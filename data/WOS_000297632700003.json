{"auto_keywords": [{"score": 0.010530032644788669, "phrase": "principal_types"}, {"score": 0.00481495049065317, "phrase": "lightweight_monadic_programming"}, {"score": 0.004559661374976129, "phrase": "probabilistic_modeling"}, {"score": 0.004518442937844318, "phrase": "functional_reactive_programming"}, {"score": 0.004417012437860011, "phrase": "information_flow_tracking"}, {"score": 0.004317848984770719, "phrase": "effectful_functionality"}, {"score": 0.004088807948906792, "phrase": "type-based_rewriting_algorithm"}, {"score": 0.003996983218174335, "phrase": "arbitrary_monads"}, {"score": 0.003907212558276185, "phrase": "ml's_built-in_support"}, {"score": 0.0037506567448470163, "phrase": "monadic_values"}, {"score": 0.003716724243777879, "phrase": "type_m_tau"}, {"score": 0.0036167509502276294, "phrase": "type_tau"}, {"score": 0.0035194572615570977, "phrase": "necessary_binds"}, {"score": 0.0034403745992576808, "phrase": "monad-to-monad_morphisms"}, {"score": 0.003257727050827128, "phrase": "jones'_qualified_types"}, {"score": 0.0030847461428168614, "phrase": "program's_semantics"}, {"score": 0.0026188490199688013, "phrase": "strictly_more_programs"}, {"score": 0.002316105585203396, "phrase": "particular_rewriting"}, {"score": 0.0022847009758393405, "phrase": "related_rewritings"}, {"score": 0.0021632743048552536, "phrase": "core_functional_language"}, {"score": 0.0021049977753042253, "phrase": "simple_examples"}], "paper_keywords": ["Languages", " Theory", " monad", " type", " rewriting", " coherence", " coercion"], "paper_abstract": "Many useful programming constructions can be expressed as monads. Examples include probabilistic modeling, functional reactive programming, parsing, and information flow tracking, not to mention effectful functionality like state and I/O. In this paper, we present a type-based rewriting algorithm to make programming with arbitrary monads as easy as using ML's built-in support for state and I/O. Developers write programs using monadic values of type m tau as if they were of type tau, and our algorithm inserts the necessary binds, units, and monad-to-monad morphisms so that the program type checks. Our algorithm, based on Jones' qualified types, produces principal types. But principal types are sometimes problematic: the program's semantics could depend on the choice of instantiation when more than one instantiation is valid. In such situations we are able to simplify the types to remove any ambiguity but without adversely affecting typability; thus we can accept strictly more programs. Moreover, we have proved that this simplification is efficient (linear in the number of constraints) and coherent: while our algorithm induces a particular rewriting, all related rewritings will have the same semantics. We have implemented our approach for a core functional language and applied it successfully to simple examples from the domains listed above, which are used as illustrations throughout the paper.", "paper_title": "Lightweight Monadic Programming in ML", "paper_id": "WOS:000297632700003"}