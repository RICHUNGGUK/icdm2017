{"auto_keywords": [{"score": 0.02324910993267869, "phrase": "service_demand"}, {"score": 0.00481495049065317, "phrase": "autonomic_resource_management"}, {"score": 0.00475254914916922, "phrase": "autonomic_computing_paradigm"}, {"score": 0.004690952711665194, "phrase": "operational_challenges"}, {"score": 0.004630150894006861, "phrase": "increasingly_complex_software_systems"}, {"score": 0.004356620736507642, "phrase": "runtime_reconfiguration"}, {"score": 0.004189337956225294, "phrase": "whole_software_system"}, {"score": 0.004135010810625326, "phrase": "emergent_property"}, {"score": 0.004099183062034004, "phrase": "local_adaptation"}, {"score": 0.003976203286249396, "phrase": "autonomous_system_elements"}, {"score": 0.003924629168434799, "phrase": "appropriate_local_adaptation_policies"}, {"score": 0.0037903327482565097, "phrase": "major_challenge"}, {"score": 0.003660614912817745, "phrase": "system's_scale"}, {"score": 0.003535320700255283, "phrase": "central_executive"}, {"score": 0.003170667618004276, "phrase": "self-regulatory_system_response"}, {"score": 0.0031023662967184216, "phrase": "local_interactions"}, {"score": 0.0030754582519753474, "phrase": "autonomic_system_elements"}, {"score": 0.002843519597398796, "phrase": "system_performance"}, {"score": 0.002770150086489194, "phrase": "system_components"}, {"score": 0.0026175952455594277, "phrase": "maximum_efficiency"}, {"score": 0.0025723630851105304, "phrase": "individual_components"}, {"score": 0.0023990982005125763, "phrase": "appropriate_community_structures"}, {"score": 0.002357632753637638, "phrase": "information_flow"}, {"score": 0.0021607883988873492, "phrase": "resource-limited_environments"}, {"score": 0.0021049977753042253, "phrase": "unnecessary_reconfiguration"}], "paper_keywords": ["Autonomic computing", " networks", " self-organization", " community structure", " decentralized control", " emergence"], "paper_abstract": "The autonomic computing paradigm addresses the operational challenges presented by increasingly complex software systems by proposing that they be composed of many autonomous components, each responsible for the runtime reconfiguration of its own dedicated hardware and software components. Consequently, regulation of the whole software system becomes an emergent property of local adaptation and learning carried out by these autonomous system elements. Designing appropriate local adaptation policies for the components of such systems remains a major challenge. This is particularly true where the system's scale and dynamism compromise the efficiency of a central executive and/or prevent components from pooling information to achieve a shared, accurate evidence base for their negotiations and decisions. In this paper, we investigate how a self-regulatory system response may arise spontaneously from local interactions between autonomic system elements tasked with adaptively consuming/providing computational resources or services when the demand for such resources is continually changing. We demonstrate that system performance is not maximized when all system components are able to freely share information with one another. Rather, maximum efficiency is achieved when individual components have only limited knowledge of their peers. Under these conditions, the system self-organizes into appropriate community structures. By maintaining information flow at the level of communities, the system is able to remain stable enough to efficiently satisfy service demand in resource-limited environments, and thus minimize any unnecessary reconfiguration whilst remaining sufficiently adaptive to be able to reconfigure when service demand changes.", "paper_title": "Self-organizing agent communities for autonomic resource management", "paper_id": "WOS:000314239600001"}