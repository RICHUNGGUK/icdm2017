{"auto_keywords": [{"score": 0.035399176283572455, "phrase": "ram."}, {"score": 0.005466942653894465, "phrase": "sequitur"}, {"score": 0.00481495049065317, "phrase": "random_access_to_grammar-compressed_strings_and_trees._grammar-based_compression"}, {"score": 0.004672444473700524, "phrase": "small_context-free_grammar"}, {"score": 0.004561468495520688, "phrase": "simple_and_powerful_paradigm"}, {"score": 0.004479961909330417, "phrase": "slight_reduction"}, {"score": 0.004386701682320949, "phrase": "popular_compression_schemes"}, {"score": 0.004334280585565239, "phrase": "lempel-ziv_family"}, {"score": 0.004308304400698582, "phrase": "run-length_encoding"}, {"score": 0.004282483226549419, "phrase": "byte-pair_encoding"}, {"score": 0.004081385289516914, "phrase": "novel_grammar_representation"}, {"score": 0.004044740057668712, "phrase": "efficient_random_access"}, {"score": 0.003785836059995376, "phrase": "context-free_grammar_s"}, {"score": 0.003469613024006653, "phrase": "pointer_machine_model"}, {"score": 0.0032571885279065126, "phrase": "kth_row"}, {"score": 0.0032376465741070274, "phrase": "ackermann's_function"}, {"score": 0.0030577296589049704, "phrase": "length_m"}, {"score": 0.0030030115662983956, "phrase": "single_random_access_query"}, {"score": 0.0029052181875265995, "phrase": "fast_algorithms"}, {"score": 0.0028877818105020434, "phrase": "uncompressed_approximate_string_matching"}, {"score": 0.0028446460307503343, "phrase": "approximate_string_matching"}, {"score": 0.0028275721614025714, "phrase": "grammar-compressed_strings"}, {"score": 0.0027354763093906547, "phrase": "approximate_occurrences"}, {"score": 0.002710882597152324, "phrase": "pattern_p"}, {"score": 0.0023390219342052623, "phrase": "grammar-compressed_ordered_trees"}, {"score": 0.0022764737473071296, "phrase": "currently_best_known_results"}, {"score": 0.0022022878843247257, "phrase": "data_structures"}, {"score": 0.002189061053183049, "phrase": "independent_interest"}, {"score": 0.002162844717299508, "phrase": "predecessor_data_structure"}, {"score": 0.0021049977753042253, "phrase": "heavy_paths"}], "paper_keywords": ["grammar-based compression", " straight-line program", " approximate string matching", " tree compression"], "paper_abstract": "Grammar-based compression, where one replaces a long string by a small context-free grammar that generates the string, is a simple and powerful paradigm that captures (sometimes with slight reduction in efficiency) many of the popular compression schemes, including the Lempel-Ziv family, run-length encoding, byte-pair encoding, Sequitur, and Re-Pair. In this paper, we present a novel grammar representation that allows efficient random access to any character or substring without decompressing the string. Let S be a string of length N compressed into a context-free grammar S of size n. We present two representations of S achieving O(logN) random access time, and either O(n . alpha(k)(n)) construction time and space on the pointer machine model, or O(n) construction time and space on the RAM. Here, alpha(k)(n) is the inverse of the kth row of Ackermann's function. Our representations also efficiently support decompression of any substring in S: we can decompress any substring of length m in the same complexity as a single random access query and additional O(m) time. Combining these results with fast algorithms for uncompressed approximate string matching leads to several efficient algorithms for approximate string matching on grammar-compressed strings without decompression. For instance, we can find all approximate occurrences of a pattern P with at most k errors in time O(n(min{vertical bar P vertical bar k, k(4) +vertical bar P vertical bar} + log N) + occ), where occ is the number of occurrences of P in S. Finally, we generalize our results to navigation and other operations on grammar-compressed ordered trees. All of the above bounds significantly improve the currently best known results. To achieve these bounds, we introduce several new techniques and data structures of independent interest, including a predecessor data structure, two \"biased\" weighted ancestor data structures, and a compact representation of heavy paths in grammars.", "paper_title": "RANDOM ACCESS TO GRAMMAR-COMPRESSED STRINGS AND TREES", "paper_id": "WOS:000357414100001"}