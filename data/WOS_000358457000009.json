{"auto_keywords": [{"score": 0.04458003012492911, "phrase": "logic_program"}, {"score": 0.02258157726260256, "phrase": "logical_consequence"}, {"score": 0.010450484320901121, "phrase": "logic_programming"}, {"score": 0.010359068272175533, "phrase": "classical_notion"}, {"score": 0.00722114489065831, "phrase": "generation_process"}, {"score": 0.006424870100928087, "phrase": "well-founded_semantics"}, {"score": 0.00481495049065317, "phrase": "classical_inference"}, {"score": 0.004762062634628325, "phrase": "denotationsl_semantics"}, {"score": 0.004606843145343611, "phrase": "main_proposed_semantics"}, {"score": 0.004586531354697466, "phrase": "logic_programs"}, {"score": 0.004388252997694986, "phrase": "form_t"}, {"score": 0.003894512634265439, "phrase": "existential_quantification"}, {"score": 0.0035727196464877147, "phrase": "logical_setting"}, {"score": 0.0035178323426661626, "phrase": "classical_modal_logic"}, {"score": 0.003479142341385732, "phrase": "modal_operators"}, {"score": 0.0033955105098235345, "phrase": "basic_modal_formulas"}, {"score": 0.003335948601271999, "phrase": "logical_program"}, {"score": 0.003135564707433078, "phrase": "stage_beta"}, {"score": 0.002940667082364658, "phrase": "rondogiannis"}, {"score": 0.002927679643820598, "phrase": "wadge's_version"}, {"score": 0.002850949001103202, "phrase": "well-founded_model"}, {"score": 0.002832081745025006, "phrase": "closed_atom"}, {"score": 0.002807118943000936, "phrase": "ordinal_truth_value"}, {"score": 0.0025978455868072214, "phrase": "natural_representation"}, {"score": 0.002447101794397243, "phrase": "proposed_traditional_semantics"}, {"score": 0.0022297712188622293, "phrase": "theoretical_foundation"}, {"score": 0.002219916677664081, "phrase": "sophisticated_ways"}, {"score": 0.002205216286162867, "phrase": "local_use"}, {"score": 0.0021857667493036786, "phrase": "knowledge-based_systems"}, {"score": 0.0021049977753042253, "phrase": "elsevier_b.v."}], "paper_keywords": ["Denotational semantics of logic programs", " Contextual hypotheses", " kappa-structures and kappa-formulas", " Partial infinity-interpretations"], "paper_abstract": "We propose a denotationsl semantics for logic programming based on a classical notion of logical consequence which is apt to capture the main proposed semantics of logic programs. In other words, we show that any of those semantics can be viewed as a relation of the form T (sic)star X where T is a theory which naturally represents the logic program under consideration together with a set of formulas playing the role of \"hypotheses\", in a way which is dictated by that semantics, (sic)star is a notion of logical consequence which is classical because negation, disjunction and existential quantification receive their classical meaning, and X represents what can be inferred from the logic program, or an intended interpretation of that logic program (such as an answer-set, its well-founded model, etc.). The logical setting we propose extends the language of classical modal logic as it deals with modal operators indexed by ordinals. We make use of two kinds of basic modal formulas: square(alpha)phi which intuitively means that the logical program can generate phi by stage alpha of the generation process, and lozenge(alpha)square(beta)phi with alpha > beta, which intuitively means that phi can be used as a hypothesis from stage beta of the generation process onwards, possibly expecting to confirm phi by stage alpha (so expecting square(alpha)phi) to be generated). This allows us to capture Rondogiannis and Wadge's version of the well-founded semantics [27] where a member of the well-founded model is a closed atom which receives an ordinal truth value of true(alpha), or false(alpha), for some ordinal a: in our framework, this corresponds to having T (sic)star or T (sic)(alpha)-phi, respectively, with T being the natural representation of the logic program under consideration and the right set of \"hypotheses\" as dictated by the well-founded semantics. The framework we present goes much beyond the proposed traditional semantics for logic programming, as it can for instance let us investigate under which conditions a set of hypotheses can be minimal, with each hypothesis being activated as late as possible and confirmed, as soon as possible, setting the theoretical foundation to sophisticated ways of making local use of hypotheses in knowledge-based systems, while still being theoretically grounded in a classical notion of logical consequence. (C) 2015 Elsevier B.V. All rights reserved.", "paper_title": "Logic programming as classical inference", "paper_id": "WOS:000358457000009"}