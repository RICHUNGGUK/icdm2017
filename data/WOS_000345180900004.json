{"auto_keywords": [{"score": 0.031960253074459766, "phrase": "haskell"}, {"score": 0.00481495049065317, "phrase": "extensible_languages"}, {"score": 0.004504969093304219, "phrase": "extensible_compilers"}, {"score": 0.004238307626560739, "phrase": "pre-compiled_components"}, {"score": 0.004099542199088835, "phrase": "first-class_values"}, {"score": 0.003987367359722647, "phrase": "good_use"}, {"score": 0.0035684266744407485, "phrase": "core_compiler"}, {"score": 0.003283272764794988, "phrase": "extra_components"}, {"score": 0.0026584843838039166, "phrase": "new_semantics"}, {"score": 0.0026000466400112974, "phrase": "already_existing_semantics"}, {"score": 0.002542890176213921, "phrase": "syntax_macros"}, {"score": 0.002152332983488664, "phrase": "macro_system"}], "paper_keywords": ["Attribute grammar macro", " Extensible language", " First-class attribute grammar", " Attribute redefinition", " Haskell"], "paper_abstract": "Having extensible languages is appealing, but raises the question of how to construct extensible compilers and how to compose compilers out of a collection of pre-compiled components. We show how having attribute grammar fragments as first-class values can be put into good use to answer this question; the approach leads naturally to a plug-in architecture, in which a core compiler can be constructed out of a (collection of) precompiled component(s), to which extra components can safely be added as the need arises. We extend AspectAG, our Haskell library for building strongly typed first-class attribute grammars, with a set of combinators that make it easy to describe new semantics in terms of already existing semantics, just as syntax macros extend the syntax of a language. We especially show how semantics thus defined can be redefined, thus adapting some aspects of the behavior as defined by the macro system only. (C) 2014 Elsevier B.V. All rights reserved.", "paper_title": "Attribute grammar macros", "paper_id": "WOS:000345180900004"}