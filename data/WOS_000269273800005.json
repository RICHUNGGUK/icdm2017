{"auto_keywords": [{"score": 0.04967913398382337, "phrase": "actor-oriented_components"}, {"score": 0.03384504841096873, "phrase": "formal_structure"}, {"score": 0.030941205714661, "phrase": "structural_constraints"}, {"score": 0.00481495049065317, "phrase": "actor-oriented_design"}, {"score": 0.004695303774351139, "phrase": "temporal_semantics"}, {"score": 0.004540365779658683, "phrase": "embedded_software"}, {"score": 0.004299374036140852, "phrase": "messaging_schema"}, {"score": 0.004157446556371582, "phrase": "domain-specific_actor-oriented_languages"}, {"score": 0.004054086664336862, "phrase": "simulink"}, {"score": 0.003696460568091852, "phrase": "object-oriented_components"}, {"score": 0.003427380591229386, "phrase": "host_language"}, {"score": 0.003138030910104256, "phrase": "prototype_implementation"}, {"score": 0.003072807453368781, "phrase": "actor-oriented_class_definitions"}, {"score": 0.0025974077149412, "phrase": "disciplined_form"}, {"score": 0.002575665611013556, "phrase": "multiple_inheritance"}, {"score": 0.0025541050375256992, "phrase": "unambiguous_inheritance"}, {"score": 0.002532724486603177, "phrase": "overriding_behavior"}, {"score": 0.002438699976481979, "phrase": "generalized_ultrametric_space"}, {"score": 0.0024081387633065206, "phrase": "remarkable_properties"}, {"score": 0.0022326306658609365, "phrase": "generalized_ultrametric"}, {"score": 0.0021227752613696606, "phrase": "multiple_sources"}], "paper_keywords": ["Algorithms", " Design", " Languages", " Actors", " components", " generalized ultrametric", " inheritance", " interfaces", " overriding", " type systems"], "paper_abstract": "Actor-oriented components emphasize concurrency and temporal semantics and are used for modeling and designing embedded software and hardware. Actors interact with one another through ports via a messaging schema that can follow any of several concurrent semantics. Domain-specific actor-oriented languages and frameworks are common (Simulink, LabVIEW, SystemC, etc.). However, they lack many modularity and abstraction mechanisms that programmers have become accustomed to in object-oriented components, such as classes, inheritance, interfaces, and polymorphism, except as inherited from the host language. This article shows a form that such mechanisms can take in actor-oriented components, gives a formal structure, and describes a prototype implementation. The mechanisms support actor-oriented class definitions, subclassing, inheritance, and overriding. The formal structure imposes structural constraints on a model (mainly the \"derivation invariant\") that lead to a policy to govern inheritance. In particular, the structural constraints permit a disciplined form of multiple inheritance with unambiguous inheritance and overriding behavior. The policy is based formally on a generalized ultrametric space with some remarkable properties. In this space, inheritance is favored when actors are \"closer\" (in the generalized ultrametric), and we show that when inheritance can occur from multiple sources, one source is always unambiguously closer than the other.", "paper_title": "Classes and Inheritance in Actor-Oriented Design", "paper_id": "WOS:000269273800005"}