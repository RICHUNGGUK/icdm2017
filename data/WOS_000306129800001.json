{"auto_keywords": [{"score": 0.027375070288572386, "phrase": "forgiving_tree"}, {"score": 0.015719716506582538, "phrase": "low_stretch"}, {"score": 0.004783232571029632, "phrase": "adversarial_attack"}, {"score": 0.004643055780443262, "phrase": "peer-to-peer_networks"}, {"score": 0.0045218909699308385, "phrase": "omniscient_adversary"}, {"score": 0.00424659225577246, "phrase": "arbitrary_connections"}, {"score": 0.004190796368475121, "phrase": "arbitrary_node"}, {"score": 0.004027751272984522, "phrase": "quick_\"repairs"}, {"score": 0.003896717568943166, "phrase": "small_number"}, {"score": 0.0037450707321601963, "phrase": "adversarial_deletions"}, {"score": 0.0036958398682001015, "phrase": "node_degrees"}, {"score": 0.0030706395717772436, "phrase": "total_number"}, {"score": 0.002931569771634119, "phrase": "node_v"}, {"score": 0.0028360962841331634, "phrase": "adversarial_insertions"}, {"score": 0.0027346529452880585, "phrase": "actual_graph"}, {"score": 0.0026455755027979533, "phrase": "low_latency_and_bandwidth_requirements"}, {"score": 0.0025678829712650437, "phrase": "distributed_data_structure"}, {"score": 0.0025509294021449254, "phrase": "hayes_et_al"}, {"score": 0.0023481972886024347, "phrase": "low_diameter_increase"}, {"score": 0.002294369814584028, "phrase": "node_insertions"}, {"score": 0.0021049977753042253, "phrase": "spanning_tree"}], "paper_keywords": ["Self-healing", " Networks", " Peer-to-peer", " Stretch", " Trees", " Dynamic", " Responsive"], "paper_abstract": "We consider the problem of self-healing in peer-to-peer networks that are under repeated attack by an omniscient adversary. We assume that, over a sequence of rounds, an adversary either inserts a node with arbitrary connections or deletes an arbitrary node from the network. The network responds to each such change by quick \"repairs,\" which consist of adding or deleting a small number of edges. These repairs essentially preserve closeness of nodes after adversarial deletions, without increasing node degrees by too much, in the following sense. At any point in the algorithm, nodes v and w whose distance would have been a\"\" in the graph formed by considering only the adversarial insertions (not the adversarial deletions), will be at distance at most a\"\" log n in the actual graph, where n is the total number of vertices seen so far. Similarly, at any point, a node v whose degree would have been d in the graph with adversarial insertions only, will have degree at most 3d in the actual graph. Our distributed data structure, which we call the Forgiving Graph, has low latency and bandwidth requirements. The Forgiving Graph improves on the Forgiving Tree distributed data structure from Hayes et al. (2008) in the following ways: 1) it ensures low stretch over all pairs of nodes, while the Forgiving Tree only ensures low diameter increase; 2) it handles both node insertions and deletions, while the Forgiving Tree only handles deletions; 3) it requires only a very simple and minimal initialization phase, while the Forgiving Tree initially requires construction of a spanning tree of the network.", "paper_title": "The Forgiving Graph: a distributed data structure for low stretch under adversarial attack", "paper_id": "WOS:000306129800001"}